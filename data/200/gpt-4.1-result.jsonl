{"project_name": "jedis", "pair_id": "1", "src_id": "M127", "code": "\n  private void build() {\n    // check build state to prevent recursion\n    if (building) {\n      return;\n    }\n\n    building = true;\n    try {\n      if (data != null) {\n        if (data instanceof JedisDataException) {\n          exception = (JedisDataException) data;\n        } else {\n          response = builder.build(data);\n        }\n      }\n      data = null;\n    } finally {\n      building = false;\n      built = true;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "2", "src_id": "M1184", "code": "\n  @Override\n  public int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "3", "src_id": "M1128", "code": "\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "4", "src_id": "M1154", "code": "\n  public String getElement() {\n    if (element != null) {\n      return SafeEncoder.encode(element);\n    }\n    return null;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "5", "src_id": "M937", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    GeoCoordinate that = (GeoCoordinate) o;\n    return Double.compare(that.longitude, longitude) == 0\n        && Double.compare(that.latitude, latitude) == 0;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "6", "src_id": "M1073", "code": "\n  @SuppressWarnings(\"unchecked\")\n  public List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "7", "src_id": "M127", "code": "\n    private void build() {\n        // check build state to prevent recursion\n        if (building) {\n            return;\n        }\n        building = true;\n        try {\n            if (data != null) {\n                if (data instanceof JedisDataException) {\n                    exception = (JedisDataException) data;\n                } else {\n                    response = builder.build(data);\n                }\n            }\n            data = null;\n        } finally {\n            building = false;\n            built = true;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "8", "src_id": "M1184", "code": "\n    @Override\n    public int read(byte[] b, int off, int len) throws JedisConnectionException {\n        ensureFill();\n        final int length = Math.min(limit - count, len);\n        System.arraycopy(buf, count, b, off, length);\n        count += length;\n        return length;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "9", "src_id": "M1128", "code": "\n    private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n        String host = getMasterAddrByNameResult.get(0);\n        int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n        return new HostAndPort(host, port);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "10", "src_id": "M1154", "code": "\n    public String getElement() {\n        if (null != element) {\n            return SafeEncoder.encode(element);\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "11", "src_id": "M937", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (o == null) return false;\n        if (o == this) return true;\n        if (!(o instanceof GeoCoordinate)) return false;\n        GeoCoordinate that = (GeoCoordinate) o;\n        if (Double.compare(that.longitude, longitude) != 0) return false;\n        return Double.compare(that.latitude, latitude) == 0;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "12", "src_id": "M1073", "code": "\n    @SuppressWarnings(\"unchecked\")\n    public List<byte[]> getBinaryMultiBulkReply() {\n        flush();\n        return (List<byte[]>) readProtocolWithCheckingBroken();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "13", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "14", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "15", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "16", "src_id": "M284", "code": "\n    @Override\n    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "17", "src_id": "M792", "code": "\n    @Override\n    public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "18", "src_id": "M727", "code": "\n    @Override\n    public Map<String, CommandDocument> commandDocs(String... commands) {\n        checkIsInMultiOrPipeline();\n        connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n        return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "19", "src_id": "M728", "code": "\n    @Override\n    public List<String> commandGetKeys(String... command) {\n        checkIsInMultiOrPipeline();\n        connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n        return BuilderFactory.STRING_LIST.build(connection.getOne());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "20", "src_id": "M245", "code": "\n    public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n        this.byBox = true;\n        this.width = width;\n        this.height = height;\n        this.unit = unit;\n        return this;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "21", "src_id": "M732", "code": "\n    @Override\n    public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n        checkIsInMultiOrPipeline();\n        CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n        connection.sendCommand(args);\n        return BuilderFactory.STRING_LIST.build(connection.getOne());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "22", "src_id": "M712", "code": "\n    @Override\n    public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "23", "src_id": "M551", "code": "\n    @Override\n    public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "24", "src_id": "M844", "code": "\n    @Override\n    public List<Object> functionListBinary() {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.functionListBinary());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "25", "src_id": "M298", "code": "\n    @Override\n    public long sintercard(int limit, byte[]... keys) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.sintercard(limit, keys));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "26", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "27", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "28", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "29", "src_id": "M1291", "code": "\n  private static void appendNum(final StringBuilder sb, final double n, final boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "30", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    final StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "31", "src_id": "M1290", "code": "\n  @Override\n  public String toString(final Parenthesize parenMode) {\n    final StringBuilder sb = new StringBuilder();\n    final StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (final Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "32", "src_id": "M1291", "code": "\n  private static void appendNum(final StringBuilder sb, final double n, final boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "33", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "34", "src_id": "M1290", "code": "\n  @Override\n  public String toString(final Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "35", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) return null;\n    List list = (List) data;\n    if (list.isEmpty()) return Collections.emptyList();\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n              STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (Object anObj : list) {\n        List<Object> streamObj = (List<Object>) anObj;\n        byte[] streamKey = BINARY.build(streamObj.get(0));\n        List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "36", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "37", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object other) {\n    if (this == other) return true;\n    if (other == null || getClass() != other.getClass()) return false;\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "38", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "39", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD)\n        .addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "40", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD)\n        .addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "41", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "42", "src_id": "M1177", "code": "\n  public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource != null) {\n      try {\n        resource.close();\n      } catch (Exception e) {\n        // ignored\n      }\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "43", "src_id": "M620", "code": "\n  @Override\n  public Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "44", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n      List<Object> list = (List<Object>) data;\n      if (list.isEmpty()) {\n        return Collections.emptyMap();\n      }\n\n      Map<byte[], byte[]> map = new JedisByteHashMap();\n      Iterator iterator = list.iterator();\n\n      if (list.get(0) instanceof KeyValue) {\n        while (iterator.hasNext()) {\n          KeyValue kv = (KeyValue) iterator.next();\n          map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n        }\n        return map;\n      } else {\n        while (iterator.hasNext()) {\n          map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n        }\n        return map;\n      }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "45", "src_id": "M933", "code": "\n  @Deprecated\n  public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n    if (credentialsProvider != null) {\n      builder.credentialsProvider(credentialsProvider);\n    } else {\n      builder.user(copy.getUser());\n      builder.password(copy.getPassword());\n    }\n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n      builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "46", "src_id": "M1146", "code": "\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            // TODO: Pipeline asking with the original command to make it faster....\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        consecutiveConnectionFailures++;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        // avoid updating lastException if it is a connection exception\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        // if MOVED redirection occurred,\n        if (jre instanceof JedisMovedDataException) {\n          // it rebuilds cluster's slot cache recommended by Redis cluster specification\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "47", "src_id": "M884", "code": "\n  @Override\n  public void addParams(CommandArguments args) {\n    if (filters == null) {\n      throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n    }\n\n    if (fromTimestamp == null) {\n      args.add(MINUS);\n    } else {\n      args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n      args.add(PLUS);\n    } else {\n      args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n      args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n      args.add(FILTER_BY_TS);\n      for (long ts : filterByTimestamps) {\n        args.add(toByteArray(ts));\n      }\n    }\n\n    if (filterByValues != null) {\n      args.add(FILTER_BY_VALUE);\n      for (double value : filterByValues) {\n        args.add(toByteArray(value));\n      }\n    }\n\n    if (withLabels) {\n      args.add(WITHLABELS);\n    } else if (selectedLabels != null) {\n      args.add(SELECTED_LABELS);\n      for (String label : selectedLabels) {\n        args.add(label);\n      }\n    }\n\n    if (count != null) {\n      args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n      if (align != null) {\n        args.add(ALIGN).add(align);\n      }\n\n      args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n      if (bucketTimestamp != null) {\n        args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n      }\n\n      if (empty) {\n        args.add(EMPTY);\n      }\n    }\n\n    args.add(FILTER);\n    for (String filter : filters) {\n      args.add(filter);\n    }\n\n    if (groupByLabel != null && groupByReduce != null) {\n      args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "48", "src_id": "M502", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "49", "src_id": "M416", "code": "\n  @Override\n  public List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "50", "src_id": "M390", "code": "\n  @Override\n  public Long objectFreq(final byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "51", "src_id": "M231", "code": "\n  public GeoRadiusStoreParam storeDist(String key) {\n    if (key != null) {\n      this.storeDist = true;\n      this.key = key;\n    }\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "52", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "53", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "54", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "55", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "56", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "57", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND)\n        .add(LIST)\n        .addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "58", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "59", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "60", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "61", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "62", "src_id": "M107", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n      if (data == null) return null;\n\n      List list = (List) data;\n      if (list.isEmpty()) {\n        return Collections.emptyList();\n      }\n\n      if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n            .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n                STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n            .collect(Collectors.toList());\n      } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n        for (Object anObj : list) {\n          List<Object> streamObj = (List<Object>) anObj;\n          byte[] streamKey = BINARY.build(streamObj.get(0));\n          List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n          result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n      }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "63", "src_id": "M1012", "code": "\n    public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n        byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n        Map<byte[], StreamEntryID> streams) {\n\n      CommandArguments args = commandArguments(XREADGROUP)\n          .add(GROUP).add(groupName).add(consumer)\n          .addParams(xReadGroupParams).add(STREAMS);\n\n      Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n      entrySet.forEach(entry -> args.key(entry.getKey()));\n      entrySet.forEach(entry -> args.add(entry.getValue()));\n\n      return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "64", "src_id": "M1172", "code": "\n        @Override\n        public boolean equals(Object other) {\n          if (other == null) return false;\n          if (other == this) return true;\n          if (!(other instanceof ByteArrayWrapper)) return false;\n\n          return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "65", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "66", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "67", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "68", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "69", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (Double.NEGATIVE_INFINITY == n) {\n      sb.append(\"-inf\");\n    } else if (Double.POSITIVE_INFINITY == n) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "70", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "71", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "72", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "73", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "74", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "75", "src_id": "M127", "code": "\n  private void build() {\n    // check build state to prevent recursion\n    if (building) {\n      return;\n    }\n\n    building = true;\n    try {\n      if (data != null) {\n        if (data instanceof JedisDataException) {\n          exception = (JedisDataException) data;\n        } else {\n          response = builder.build(data);\n        }\n      }\n      data = null;\n    } finally {\n      building = false;\n      built = true;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "76", "src_id": "M1184", "code": "\n  @Override\n  public int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "77", "src_id": "M1128", "code": "\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "78", "src_id": "M1154", "code": "\n  public String getElement() {\n    if (element != null) {\n      return SafeEncoder.encode(element);\n    }\n    return null;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "79", "src_id": "M937", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    GeoCoordinate that = (GeoCoordinate) o;\n    return Double.compare(that.longitude, longitude) == 0 &&\n        Double.compare(that.latitude, latitude) == 0;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "80", "src_id": "M1073", "code": "\n  @SuppressWarnings(\"unchecked\")\n  public List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "81", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "82", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "83", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "84", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "85", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "86", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "87", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "88", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "89", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND)\n      .add(LIST)\n      .addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "90", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "91", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "92", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "93", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "94", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "95", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "96", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "97", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "98", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "99", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND)\n        .add(LIST)\n        .addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "100", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "101", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "102", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "103", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "104", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "105", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "106", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "107", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) {\n      return null;\n    }\n\n    List list = (List) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()), STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (Object anObj : list) {\n        List<Object> streamObj = (List<Object>) anObj;\n        byte[] streamKey = BINARY.build(streamObj.get(0));\n        List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "108", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "109", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ByteArrayWrapper that = (ByteArrayWrapper) o;\n    return Arrays.equals(data, that.data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "110", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "111", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "112", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "113", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n      XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "114", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) {\n      return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()), STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (Object anObj : list) {\n        List<Object> streamObj = (List<Object>) anObj;\n        byte[] streamKey = BINARY.build(streamObj.get(0));\n        List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "115", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "116", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    ByteArrayWrapper that = (ByteArrayWrapper) o;\n    return Arrays.equals(data, that.data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "117", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "118", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "119", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "120", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "121", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(final String key, final HGetExParams params, final String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "122", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    final BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration)\n        && Objects.equals(expirationValue, setParams.expirationValue);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "123", "src_id": "M227", "code": "\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    final HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "124", "src_id": "M868", "code": "\n  private void safeReAuthenticate(final Token token) {\n    try {\n      final byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n      final byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n      final Token newToken = pendingTokenRef.getAndSet(token);\n      if (newToken == null) {\n        commandSync.lock();\n        try {\n          sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n          resultHandler.add(this.authResultHandler);\n        } finally {\n          pendingTokenRef.set(null);\n          commandSync.unlock();\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error while re-authenticating connection\", e);\n      client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "125", "src_id": "M957", "code": "\n  public void setListener(final AuthXEventListener listener) {\n    if (listener != null) {\n      this.listener = listener;\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "126", "src_id": "M960", "code": "\n  private void processPingReply(final Object reply) {\n    final byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n      onPong(null);\n    } else {\n      onPong(encode(resp));\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "127", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(final String key, final String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "128", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(final Object data) {\n    if (data == null) {\n      return null;\n    }\n    final List<?> list = (List<?>) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()), STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      final List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (final Object anObj : list) {\n        final List<Object> streamObj = (List<Object>) anObj;\n        final byte[] streamKey = BINARY.build(streamObj.get(0));\n        final List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "129", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      final byte[] groupName, final byte[] consumer, final XReadGroupParams xReadGroupParams,\n      final Map<byte[], StreamEntryID> streams) {\n    final CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n    final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "130", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(final Object other) {\n    if (other == null) {\n      return false;\n    }\n    if (other == this) {\n      return true;\n    }\n    if (!(other instanceof ByteArrayWrapper)) {\n      return false;\n    }\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "131", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\n      final XReadParams xReadParams, final Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "132", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      final XReadParams xReadParams, final Map<byte[], StreamEntryID> streams) {\n    final CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "133", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      final XReadParams xReadParams, final Map<byte[], StreamEntryID> streams) {\n    final CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "134", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(final byte[] groupName, final byte[] consumer,\n      final XReadGroupParams xReadGroupParams, final Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "135", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "136", "src_id": "M1104", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "137", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change\n        && existence == that.existence\n        && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "138", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "139", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs)\n        && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "140", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy\n        && replace == that.replace\n        && Objects.equals(username, that.username)\n        && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "141", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "142", "src_id": "M1177", "code": "\n  public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource != null) {\n      try {\n        resource.close();\n      } catch (Exception e) {\n        // ignored\n      }\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "143", "src_id": "M620", "code": "\n  @Override\n  public Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "144", "src_id": "M50", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public Map<byte[], byte[]> build(Object data) {\n    List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n      return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      Map<byte[], byte[]> map = new JedisByteHashMap();\n      Iterator<?> iterator = list.iterator();\n      while (iterator.hasNext()) {\n        KeyValue kv = (KeyValue) iterator.next();\n        map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n      }\n      return map;\n    } else {\n      Map<byte[], byte[]> map = new JedisByteHashMap();\n      Iterator<?> iterator = list.iterator();\n      while (iterator.hasNext()) {\n        map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n      }\n      return map;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "145", "src_id": "M933", "code": "\n  @Deprecated\n  public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n    if (credentialsProvider != null) {\n      builder.credentialsProvider(credentialsProvider);\n    } else {\n      builder.user(copy.getUser());\n      builder.password(copy.getPassword());\n    }\n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n      builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "146", "src_id": "M1146", "code": "\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            // TODO: Pipeline asking with the original command to make it faster....\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica\n              ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        consecutiveConnectionFailures++;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        // avoid updating lastException if it is a connection exception\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        // if MOVED redirection occurred,\n        if (jre instanceof JedisMovedDataException) {\n          // it rebuilds cluster's slot cache recommended by Redis cluster specification\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException =\n        new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "147", "src_id": "M884", "code": "\n  @Override\n  public void addParams(CommandArguments args) {\n    if (filters == null) {\n      throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n    }\n\n    if (fromTimestamp == null) {\n      args.add(MINUS);\n    } else {\n      args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n      args.add(PLUS);\n    } else {\n      args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n      args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n      args.add(FILTER_BY_TS);\n      for (long ts : filterByTimestamps) {\n        args.add(toByteArray(ts));\n      }\n    }\n\n    if (filterByValues != null) {\n      args.add(FILTER_BY_VALUE);\n      for (double value : filterByValues) {\n        args.add(toByteArray(value));\n      }\n    }\n\n    if (withLabels) {\n      args.add(WITHLABELS);\n    } else if (selectedLabels != null) {\n      args.add(SELECTED_LABELS);\n      for (String label : selectedLabels) {\n        args.add(label);\n      }\n    }\n\n    if (count != null) {\n      args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n      if (align != null) {\n        args.add(ALIGN).add(align);\n      }\n\n      args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n      if (bucketTimestamp != null) {\n        args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n      }\n\n      if (empty) {\n        args.add(EMPTY);\n      }\n    }\n\n    args.add(FILTER);\n    for (String filter : filters) {\n      args.add(filter);\n    }\n\n    if (groupByLabel != null && groupByReduce != null) {\n      args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "148", "src_id": "M502", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "149", "src_id": "M416", "code": "\n  @Override\n  public List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "150", "src_id": "M390", "code": "\n  @Override\n  public Long objectFreq(final byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "151", "src_id": "M231", "code": "\n  public GeoRadiusStoreParam storeDist(String key) {\n    if (key != null) {\n      this.storeDist = true;\n      this.key = key;\n    }\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "152", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "153", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "154", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "155", "src_id": "M127", "code": "\n  private void build() {\n    // check build state to prevent recursion\n    if (building) {\n      return;\n    }\n\n    building = true;\n    try {\n      if (data != null) {\n        if (data instanceof JedisDataException) {\n          exception = (JedisDataException) data;\n        } else {\n          response = builder.build(data);\n        }\n      }\n      data = null;\n    } finally {\n      building = false;\n      built = true;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "156", "src_id": "M1184", "code": "\n  @Override\n  public int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "157", "src_id": "M1128", "code": "\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "158", "src_id": "M1154", "code": "\n  public String getElement() {\n    if (element != null) {\n      return SafeEncoder.encode(element);\n    }\n    return null;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "159", "src_id": "M937", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (o == null) {\n      return false;\n    }\n    if (o == this) {\n      return true;\n    }\n    if (!(o instanceof GeoCoordinate)) {\n      return false;\n    }\n    GeoCoordinate that = (GeoCoordinate) o;\n    if (Double.compare(that.longitude, longitude) != 0) {\n      return false;\n    }\n    return Double.compare(that.latitude, latitude) == 0;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "160", "src_id": "M1073", "code": "\n  @SuppressWarnings(\"unchecked\")\n  public List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "161", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "162", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "163", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "164", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "165", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "166", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND)\n        .add(LIST)\n        .addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "167", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "168", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "169", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "170", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "171", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(String key, HGetExParams params, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "172", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration)\n        && Objects.equals(expirationValue, setParams.expirationValue);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "173", "src_id": "M227", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        HSetExParams setParams = (HSetExParams) o;\n        return Objects.equals(existance, setParams.existance)\n                && super.equals((BaseSetExParams) o);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "174", "src_id": "M868", "code": "\n  private void safeReAuthenticate(Token token) {\n    try {\n      byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n      byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n      Token newToken = pendingTokenRef.getAndSet(token);\n      if (newToken == null) {\n        commandSync.lock();\n        try {\n          sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n          resultHandler.add(this.authResultHandler);\n        } finally {\n          pendingTokenRef.set(null);\n          commandSync.unlock();\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error while re-authenticating connection\", e);\n      client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "175", "src_id": "M957", "code": "\n    public void setListener(AuthXEventListener listener) {\n        if (listener != null) {\n            this.listener = listener;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "176", "src_id": "M960", "code": "\n  private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n      onPong(null);\n    } else {\n      onPong(encode(resp));\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "177", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(String key, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "178", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "179", "src_id": "M1104", "code": "\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      return Arrays.equals(raw, ((Raw) o).raw);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "180", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change\n        && existence == that.existence\n        && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "181", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "182", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs)\n        && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "183", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy\n        && replace == that.replace\n        && Objects.equals(username, that.username)\n        && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "184", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "185", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (o == this) {\n      return true;\n    }\n    if (!(o instanceof TSArithByParams)) {\n      return false;\n    }\n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "186", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (o == this) {\n      return true;\n    }\n    if (!(o instanceof TSCreateParams)) {\n      return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "187", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "188", "src_id": "M1177", "code": "\n  public static void closeQuietly(AutoCloseable resource) {\n      // It's same thing as Apache Commons - IOUtils.closeQuietly()\n      if (resource != null) {\n          try {\n              resource.close();\n          } catch (Exception e) {\n              // ignored\n          }\n      }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "189", "src_id": "M620", "code": "\n  @Override\n  public Set<String> sinter(final String... keys) {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.sinter(keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "190", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) return Collections.emptyMap();\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "191", "src_id": "M933", "code": "\n  @Deprecated\n  public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n      Builder builder = builder();\n      builder.protocol(copy.getRedisProtocol());\n      builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n      builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n      builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n      Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n      if (credentialsProvider != null) {\n          builder.credentialsProvider(credentialsProvider);\n      } else {\n          builder.user(copy.getUser());\n          builder.password(copy.getPassword());\n      }\n\n      builder.database(copy.getDatabase());\n      builder.clientName(copy.getClientName());\n\n      builder.ssl(copy.isSsl());\n      builder.sslSocketFactory(copy.getSslSocketFactory());\n      builder.sslParameters(copy.getSslParameters());\n      builder.hostnameVerifier(copy.getHostnameVerifier());\n      builder.sslOptions(copy.getSslOptions());\n      builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n      builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n      if (copy.isReadOnlyForRedisClusterReplicas()) {\n          builder.readOnlyForRedisClusterReplicas();\n      }\n\n      builder.authXManager(copy.getAuthXManager());\n\n      return builder.build();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "192", "src_id": "M1146", "code": "\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n      Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n      JedisRedirectionException redirect = null;\n      int consecutiveConnectionFailures = 0;\n      Exception lastException = null;\n      for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n          Connection connection = null;\n          try {\n              if (redirect != null) {\n                  connection = provider.getConnection(redirect.getTargetNode());\n                  if (redirect instanceof JedisAskDataException) {\n                      // TODO: Pipeline asking with the original command to make it faster....\n                      connection.executeCommand(Protocol.Command.ASKING);\n                  }\n              } else {\n                  connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                          : provider.getConnection(commandObject.getArguments());\n              }\n\n              return execute(connection, commandObject);\n\n          } catch (JedisClusterOperationException jnrcne) {\n              throw jnrcne;\n          } catch (JedisConnectionException jce) {\n              lastException = jce;\n              ++consecutiveConnectionFailures;\n              log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n              // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n              boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n              if (reset) {\n                  consecutiveConnectionFailures = 0;\n                  redirect = null;\n              }\n          } catch (JedisRedirectionException jre) {\n              // avoid updating lastException if it is a connection exception\n              if (lastException == null || lastException instanceof JedisRedirectionException) {\n                  lastException = jre;\n              }\n              log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n              consecutiveConnectionFailures = 0;\n              redirect = jre;\n              // if MOVED redirection occurred,\n              if (jre instanceof JedisMovedDataException) {\n                  // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                  provider.renewSlotCache(connection);\n              }\n          } finally {\n              IOUtils.closeQuietly(connection);\n          }\n          if (Instant.now().isAfter(deadline)) {\n              throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n          }\n      }\n\n      JedisClusterOperationException maxAttemptsException\n              = new JedisClusterOperationException(\"No more cluster attempts left.\");\n      maxAttemptsException.addSuppressed(lastException);\n      throw maxAttemptsException;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "193", "src_id": "M884", "code": "\n  @Override\n  public void addParams(CommandArguments args) {\n\n      if (filters == null) {\n          throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n      }\n\n      if (fromTimestamp == null) {\n          args.add(MINUS);\n      } else {\n          args.add(toByteArray(fromTimestamp));\n      }\n\n      if (toTimestamp == null) {\n          args.add(PLUS);\n      } else {\n          args.add(toByteArray(toTimestamp));\n      }\n\n      if (latest) {\n          args.add(LATEST);\n      }\n\n      if (filterByTimestamps != null) {\n          args.add(FILTER_BY_TS);\n          for (long ts : filterByTimestamps) {\n              args.add(toByteArray(ts));\n          }\n      }\n\n      if (filterByValues != null) {\n          args.add(FILTER_BY_VALUE);\n          for (double value : filterByValues) {\n              args.add(toByteArray(value));\n          }\n      }\n\n      if (withLabels) {\n          args.add(WITHLABELS);\n      } else if (selectedLabels != null) {\n          args.add(SELECTED_LABELS);\n          for (String label : selectedLabels) {\n              args.add(label);\n          }\n      }\n\n      if (count != null) {\n          args.add(COUNT).add(toByteArray(count));\n      }\n\n      if (aggregationType != null) {\n\n          if (align != null) {\n              args.add(ALIGN).add(align);\n          }\n\n          args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n          if (bucketTimestamp != null) {\n              args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n          }\n\n          if (empty) {\n              args.add(EMPTY);\n          }\n      }\n\n      args.add(FILTER);\n      for (String filter : filters) {\n          args.add(filter);\n      }\n\n      if (groupByLabel != null && groupByReduce != null) {\n          args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n      }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "194", "src_id": "M502", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "195", "src_id": "M416", "code": "\n  @Override\n  public List<byte[]> aclLogBinary() {\n      checkIsInMultiOrPipeline();\n      connection.sendCommand(ACL, LOG);\n      return connection.getBinaryMultiBulkReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "196", "src_id": "M390", "code": "\n  @Override\n  public Long objectFreq(final byte[] key) {\n      connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n      return connection.getIntegerReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "197", "src_id": "M231", "code": "\n  public GeoRadiusStoreParam storeDist(String key) {\n      if (key != null) {\n          this.storeDist = true;\n          this.key = key;\n      }\n      return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "198", "src_id": "M777", "code": "\n  @Override\n  public List<Map<String, Object>> clusterLinks() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n    return connection.getObjectMultiBulkReply().stream()\n        .map(BuilderFactory.ENCODED_OBJECT_MAP::build)\n        .collect(Collectors.toList());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "199", "src_id": "M779", "code": "\n  @Override\n  public String clusterDelSlotsRange(int... ranges) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(\n        CLUSTER,\n        joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges))\n    );\n    return connection.getStatusCodeReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "200", "src_id": "M818", "code": "\n  @Override\n  public Map<String, Object> memoryStats() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(MEMORY, STATS);\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "201", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(String key, HGetExParams params, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "202", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration) &&\n        Objects.equals(expirationValue, setParams.expirationValue);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "203", "src_id": "M227", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance) &&\n        super.equals((BaseSetExParams) o);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "204", "src_id": "M868", "code": "\n  private void safeReAuthenticate(Token token) {\n    try {\n      byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n      byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n      Token newToken = pendingTokenRef.getAndSet(token);\n      if (newToken == null) {\n        commandSync.lock();\n        try {\n          sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n          resultHandler.add(this.authResultHandler);\n        } finally {\n          pendingTokenRef.set(null);\n          commandSync.unlock();\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error while re-authenticating connection\", e);\n      client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "205", "src_id": "M957", "code": "\n  public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n      this.listener = listener;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "206", "src_id": "M960", "code": "\n  private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n      onPong(null);\n    } else {\n      onPong(encode(resp));\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "207", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(String key, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "208", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    final TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "209", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(final Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    final TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "210", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "211", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(String key, HGetExParams params, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "212", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration)\n        && Objects.equals(expirationValue, setParams.expirationValue);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "213", "src_id": "M227", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance)\n        && super.equals((BaseSetExParams) o);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "214", "src_id": "M868", "code": "\n  private void safeReAuthenticate(Token token) {\n    try {\n      byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n      byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n      Token newToken = pendingTokenRef.getAndSet(token);\n      if (newToken == null) {\n        commandSync.lock();\n        try {\n          sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n          resultHandler.add(this.authResultHandler);\n        } finally {\n          pendingTokenRef.set(null);\n          commandSync.unlock();\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error while re-authenticating connection\", e);\n      client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "215", "src_id": "M957", "code": "\n  public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n      this.listener = listener;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "216", "src_id": "M960", "code": "\n  private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n      onPong(null);\n    } else {\n      onPong(encode(resp));\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "217", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(String key, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "218", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "219", "src_id": "M1104", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "220", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change && existence == that.existence && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "221", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "222", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "223", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy && replace == that.replace\n        && Objects.equals(username, that.username)\n        && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "224", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "225", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) {\n      return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n              STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (Object anObj : list) {\n        List<Object> streamObj = (List<Object>) anObj;\n        byte[] streamKey = BINARY.build(streamObj.get(0));\n        List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "226", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "227", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof ByteArrayWrapper)) {\n      return false;\n    }\n    return Arrays.equals(data, ((ByteArrayWrapper) obj).data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "228", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n      Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "229", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "230", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "231", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n      XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "232", "src_id": "M777", "code": "\n  @Override\n  public List<Map<String, Object>> clusterLinks() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n\n    return connection.getObjectMultiBulkReply().stream()\n        .map(BuilderFactory.ENCODED_OBJECT_MAP::build)\n        .collect(Collectors.toList());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "233", "src_id": "M779", "code": "\n  @Override\n  public String clusterDelSlotsRange(int... ranges) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(\n        CLUSTER,\n        joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges))\n    );\n\n    return connection.getStatusCodeReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "234", "src_id": "M818", "code": "\n  @Override\n  public Map<String, Object> memoryStats() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(MEMORY, STATS);\n\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "235", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      XAutoClaimParams that = (XAutoClaimParams) o;\n      return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "236", "src_id": "M1104", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        return Arrays.equals(raw, ((Raw) o).raw);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "237", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ZAddParams that = (ZAddParams) o;\n      return change == that.change && existence == that.existence && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "238", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ClientKillParams that = (ClientKillParams) o;\n      return Objects.equals(params, that.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "239", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ModuleLoadExParams that = (ModuleLoadExParams) o;\n      return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "240", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      MigrateParams that = (MigrateParams) o;\n      return copy == that.copy && replace == that.replace\n              && Objects.equals(username, that.username)\n              && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "241", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ZParams zParams = (ZParams) o;\n      return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "242", "src_id": "M890", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        TSArithByParams<?> that = (TSArithByParams<?>) o;\n        return ignore == that.ignore\n                && ignoreMaxTimediff == that.ignoreMaxTimediff\n                && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n                && Objects.equals(timestamp, that.timestamp)\n                && Objects.equals(retentionPeriod, that.retentionPeriod)\n                && encoding == that.encoding\n                && Objects.equals(chunkSize, that.chunkSize)\n                && duplicatePolicy == that.duplicatePolicy\n                && Objects.equals(labels, that.labels);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "243", "src_id": "M903", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        TSCreateParams that = (TSCreateParams) o;\n        return ignore == that.ignore\n                && ignoreMaxTimediff == that.ignoreMaxTimediff\n                && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n                && Objects.equals(retentionPeriod, that.retentionPeriod)\n                && encoding == that.encoding\n                && Objects.equals(chunkSize, that.chunkSize)\n                && duplicatePolicy == that.duplicatePolicy\n                && Objects.equals(labels, that.labels);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "244", "src_id": "M907", "code": "\n    @Override\n    public int hashCode() {\n        int result = Boolean.hashCode(latest);\n        result = 31 * result + Boolean.hashCode(withLabels);\n        result = 31 * result + Arrays.hashCode(selectedLabels);\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "1", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n                || entry.getLastLine() == line\n                && entry.getLastColumn() >= column;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "2", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n                && modifiers.findFirstToken(TokenTypes.FINAL) == null\n                && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "3", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "4", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "5", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "6", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "7", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n                && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "8", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n\n        return forwardReference;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "19", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n                || (entry.getLastLine() == line && entry.getLastColumn() >= column);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "20", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n                && modifiers.findFirstToken(TokenTypes.FINAL) == null\n                && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "21", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "22", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "23", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "24", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(\n            DetailAST ast, DetailAST token, int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "25", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n                && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "26", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n        return forwardReference;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "27", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "28", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n            DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "29", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "30", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "31", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "32", "src_id": "M597", "code": "\n    private void checkTypeDefinition(DetailAST ast) {\n\n        if (!ScopeUtil.isOuterMostType(ast)\n            && isSemicolon(ast.getNextSibling())) {\n            log(ast.getNextSibling(), MSG_SEMI);\n        }\n\n        final DetailAST firstMember =\n            ast.findFirstToken(TokenTypes.OBJBLOCK)\n                .getFirstChild().getNextSibling();\n\n        if (isSemicolon(firstMember)\n            && !ScopeUtil.isInEnumBlock(firstMember)) {\n            log(firstMember, MSG_SEMI);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "33", "src_id": "M655", "code": "\n    private void checkLambda(DetailAST ast, DetailAST currentStatement) {\n\n        int countOfSemiInCurrentLambda = countOfSemiInLambda.pop();\n        countOfSemiInCurrentLambda++;\n        countOfSemiInLambda.push(countOfSemiInCurrentLambda);\n\n        if (!inForHeader\n            && countOfSemiInCurrentLambda > 1\n            && isOnTheSameLine(currentStatement,\n                lastStatementEnd, forStatementEnd, lambdaStatementEnd)) {\n            log(ast, MSG_KEY);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "34", "src_id": "M587", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n\n        final DetailAST enumBlock = ast.findFirstToken(TokenTypes.OBJBLOCK);\n        final DetailAST semicolon = enumBlock.findFirstToken(TokenTypes.SEMI);\n\n        if (semicolon != null\n            && isEndOfEnumerationAfter(semicolon)) {\n            log(semicolon, MSG_SEMI);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "35", "src_id": "M202", "code": "\n    public static InputSource sourceFromFilename(String filename)\n            throws CheckstyleException {\n\n        // figure out if this is a File or a URL\n        final URI uri = getUriByFilename(filename);\n        return new InputSource(uri.toASCIIString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "36", "src_id": "M633", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.RECORD_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "37", "src_id": "M285", "code": "\n    private static void addSuppressions(List<String> values, DetailAST targetAST) {\n\n        // get text range of target\n        final int firstLine = targetAST.getLineNo();\n        final int firstColumn = targetAST.getColumnNo();\n\n        final DetailAST nextAST = targetAST.getNextSibling();\n\n        final int lastLine;\n        final int lastColumn;\n\n        if (nextAST == null) {\n            lastLine = Integer.MAX_VALUE;\n            lastColumn = Integer.MAX_VALUE;\n        }\n        else {\n            lastLine = nextAST.getLineNo();\n            lastColumn = nextAST.getColumnNo();\n        }\n\n        final List<Entry> entries = ENTRIES.get();\n\n        for (String value : values) {\n            // strip off the checkstyle-only prefix if present\n            final String checkName = removeCheckstylePrefixIfExists(value);\n            entries.add(new Entry(\n                checkName, firstLine, firstColumn, lastLine, lastColumn));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "38", "src_id": "M276", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n\n        if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n            final int length = getLength(ast);\n            if (length > max) {\n                log(ast, MSG_KEY, length, max);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "39", "src_id": "M279", "code": "\n    private static int getFirstNodeLineNumber(DetailAST lambdaBody) {\n\n        DetailAST node = lambdaBody;\n        int result;\n\n        do {\n            result = node.getLineNo();\n            node = node.getFirstChild();\n        }\n        while (node != null);\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "40", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(\n            DetailAST startingBranch, DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "41", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(\n            DetailAST token, DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "42", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(\n                        expressionBranch, branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "43", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "44", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "45", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "46", "src_id": "M79", "code": "\n    private static Stream<?> getValuesStream(Object value) {\n        final Stream<?> result;\n        if (value instanceof Collection) {\n            final Collection<?> collection = (Collection<?>) value;\n            result = collection.stream();\n        }\n        else {\n            final Object[] array = (Object[]) value;\n            result = Arrays.stream(array);\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "47", "src_id": "M103", "code": "\n    @Override\n    public void body() {\n        write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding + \"\\\"?>\");\n        writeEOL();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "48", "src_id": "M72", "code": "\n    private static DetailNode getSinceJavadocTag(DetailNode javadoc) {\n        final DetailNode[] children = javadoc.getChildren();\n        DetailNode result = null;\n        for (final DetailNode child : children) {\n            if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                final DetailNode sinceNode = JavadocUtil.findFirstToken(\n                        child, JavadocTokenTypes.SINCE_LITERAL);\n                if (sinceNode != null) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "49", "src_id": "M46", "code": "\n    private static String getLinkToParentModule(String parentModule, String moduleName)\n            throws MacroExecutionException {\n        final Path templatePath = SiteUtil.getTemplatePath(moduleName);\n        if (templatePath == null) {\n            throw new MacroExecutionException(\n                    String.format(Locale.ROOT, \"Could not find template for %s\", moduleName));\n        }\n        final Path templatePathParent = templatePath.getParent();\n        if (templatePathParent == null) {\n            throw new MacroExecutionException(\"Failed to get parent path for \" + templatePath);\n        }\n        return templatePathParent\n                .relativize(Path.of(\"src\", \"site/xdoc\", \"config.xml\"))\n                .toString()\n                .replace(\".xml\", \".html\")\n                .replace('\\\\', '/')\n                + \"#\" + parentModule;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "50", "src_id": "M78", "code": "\n    private static String getStringArrayPropertyValue(String propertyName, Object value) {\n        String result;\n        if (value == null) {\n            result = \"\";\n        }\n        else {\n            try (Stream<?> valuesStream = getValuesStream(value)) {\n                result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(COMMA_SPACE));\n            }\n        }\n\n        if (result.isEmpty()) {\n            if (FILE_EXTENSIONS.equals(propertyName)) {\n                result = \"all files\";\n            }\n            else {\n                result = CURLY_BRACKETS;\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "51", "src_id": "M114", "code": "\n    private static void createListItem(XdocSink sink, Class<?> clss, String messageKey) {\n        final String messageKeyUrl = constructMessageKeyUrl(clss, messageKey);\n        final String indentLevel10 = SiteUtil.getNewlineAndIndentSpaces(10);\n        final String indentLevel12 = SiteUtil.getNewlineAndIndentSpaces(12);\n        final String indentLevel14 = SiteUtil.getNewlineAndIndentSpaces(14);\n\n        sink.rawText(indentLevel10);\n        sink.setInsertNewline(false);\n        sink.listItem();\n        sink.setInsertNewline(true);\n\n        sink.rawText(indentLevel12);\n        sink.link(messageKeyUrl);\n        sink.rawText(indentLevel14);\n        sink.rawText(messageKey);\n\n        sink.rawText(indentLevel12);\n        sink.link_();\n        sink.rawText(indentLevel10);\n        sink.listItem_();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "52", "src_id": "M58", "code": "\n    private static Set<Field> getCheckMessageKeys(Class<?> module)\n            throws MacroExecutionException {\n        try {\n            final Set<Field> result = new HashSet<>();\n\n            final Field[] fields = module.getDeclaredFields();\n\n            for (Field field : fields) {\n                if (field.getName().startsWith(\"MSG_\")) {\n                    result.add(field);\n                }\n            }\n\n            final Class<?> superModule = module.getSuperclass();\n\n            if (superModule != null) {\n                result.addAll(getCheckMessageKeys(superModule));\n            }\n\n            if (module == RegexpMultilineCheck.class) {\n                result.addAll(getCheckMessageKeys(Class\n                        .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.MultilineDetector\")));\n            }\n            else if (module == RegexpSinglelineCheck.class\n                    || module == RegexpSinglelineJavaCheck.class) {\n                result.addAll(getCheckMessageKeys(Class\n                        .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.SinglelineDetector\")));\n            }\n\n            return result;\n        }\n        catch (ClassNotFoundException exc) {\n            final String message = String.format(Locale.ROOT, \"Couldn't find class: %s\",\n                    module.getName());\n            throw new MacroExecutionException(message, exc);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "53", "src_id": "M68", "code": "\n    private static Set<String> getNonExplicitProperties(\n            Object instance, Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                result.add(TOKENS);\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n            result.add(\"violateExecutionOnNonTightHtml\");\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                result.add(JAVADOC_TOKENS);\n            }\n        }\n\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            result.add(FILE_EXTENSIONS);\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "54", "src_id": "M65", "code": "\n    private static void processModule(String moduleName, Path modulePath)\n            throws MacroExecutionException {\n        if (!Files.isRegularFile(modulePath)) {\n            final String message = String.format(Locale.ROOT,\n                    \"File %s is not a file. Please check the 'modulePath' property.\", modulePath);\n            throw new MacroExecutionException(message);\n        }\n        ClassAndPropertiesSettersJavadocScraper.initialize(moduleName);\n        final Checker checker = new Checker();\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n        final DefaultConfiguration scraperCheckConfig =\n                new DefaultConfiguration(\n                        ClassAndPropertiesSettersJavadocScraper.class.getName());\n        final DefaultConfiguration defaultConfiguration =\n                new DefaultConfiguration(\"configuration\");\n        final DefaultConfiguration treeWalkerConfig =\n                new DefaultConfiguration(TreeWalker.class.getName());\n        defaultConfiguration.addProperty(CHARSET, StandardCharsets.UTF_8.name());\n        defaultConfiguration.addChild(treeWalkerConfig);\n        treeWalkerConfig.addChild(scraperCheckConfig);\n        try {\n            checker.configure(defaultConfiguration);\n            final List<File> filesToProcess = List.of(modulePath.toFile());\n            checker.process(filesToProcess);\n            checker.destroy();\n        }\n        catch (CheckstyleException checkstyleException) {\n            final String message = String.format(Locale.ROOT, \"Failed processing %s\", moduleName);\n            throw new MacroExecutionException(message, checkstyleException);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "55", "src_id": "M110", "code": "\n    private static DetailAST getParentAst(DetailAST ast, int type) {\n        DetailAST result = ast.getParent();\n\n        while (result != null && result.getType() != type) {\n            result = result.getParent();\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "56", "src_id": "M697", "code": "\n@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(\n        DetailAST startingBranch, DetailAST bound, int neededTokenType) {\n    DetailAST match = null;\n    DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n    while (iteratedBranch != null) {\n        if (iteratedBranch.getType() == neededTokenType) {\n            match = iteratedBranch;\n            break;\n        }\n        iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n    }\n    return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "57", "src_id": "M564", "code": "\nprivate static boolean isTokenNotOnPreviousSiblingLines(\n        DetailAST token, DetailAST parentToken) {\n    DetailAST previousSibling = parentToken.getPreviousSibling();\n    for (DetailAST astNode = previousSibling; astNode != null;\n         astNode = astNode.getLastChild()) {\n        previousSibling = astNode;\n    }\n    return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "58", "src_id": "M695", "code": "\nprivate static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n    final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n    final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n    for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n         expressionBranch != null;\n         expressionBranch = traverseUntilNeededBranchType(\n                 expressionBranch, branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n        final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n        if (assignToken != null) {\n            reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n        }\n    }\n    return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "59", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        final boolean result;\n        if (entry.getLastLine() > line) {\n            result = true;\n        }\n        else if (entry.getLastLine() == line && entry.getLastColumn() >= column) {\n            result = true;\n        }\n        else {\n            result = false;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "60", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        final boolean result;\n        if (classDef.getType() != TokenTypes.ENUM_DEF\n                && modifiers.findFirstToken(TokenTypes.FINAL) == null\n                && hasDefaultOrExplicitNonPrivateCtor(classDef)) {\n            result = true;\n        }\n        else {\n            result = false;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "61", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "62", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "63", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "64", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "65", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n                && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "66", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        final boolean result;\n        boolean found = false;\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            result = true;\n        }\n        else {\n            result = false;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "67", "src_id": "M37", "code": "\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        ModuleType result = null;\n\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "68", "src_id": "M28", "code": "\n    private void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "69", "src_id": "M27", "code": "\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName.substring(0, moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "70", "src_id": "M35", "code": "\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n            Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "71", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n            || (entry.getLastLine() == line\n            && entry.getLastColumn() >= column);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "72", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n\n        return classDef.getType() != TokenTypes.ENUM_DEF\n            && modifiers.findFirstToken(TokenTypes.FINAL) == null\n            && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "73", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "74", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "75", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "76", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast,\n                                                                     DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "77", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n               && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "78", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n\n        return forwardReference;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "79", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "80", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "81", "src_id": "M646", "code": "\n    private static List<DetailAST> getChildList(DetailAST ast) {\n        final List<DetailAST> children = new ArrayList<>();\n        DetailAST child = ast.findFirstToken(TokenTypes.OBJBLOCK).getFirstChild();\n        while (child != null) {\n            children.add(child);\n            child = child.getNextSibling();\n        }\n        return children;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "82", "src_id": "M373", "code": "\n    private void checkParagraphTag(DetailNode tag) {\n        if (!isNestedParagraph(tag)) {\n            final DetailNode newLine = getNearestEmptyLine(tag);\n\n            if (isFirstParagraph(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_REDUNDANT_PARAGRAPH);\n            }\n            else if (newLine == null || tag.getLineNumber() - newLine.getLineNumber() != 1) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_LINE_BEFORE);\n            }\n\n            final String blockTagName = findFollowedBlockTagName(tag);\n            if (blockTagName != null) {\n                log(tag.getLineNumber(), tag.getColumnNumber(),\n                        MSG_PRECEDED_BLOCK_TAG, blockTagName);\n            }\n\n            if (!allowNewlineParagraph && isImmediatelyFollowedByNewLine(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n            }\n            if (isImmediatelyFollowedByText(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "83", "src_id": "M406", "code": "\n    @Override\n    public void finishJavadocTree(DetailNode rootAst) {\n        // this method checks the alignment of closing javadoc tag.\n        final DetailAST javadocEndToken = getBlockCommentAst().getLastChild();\n        final String lastLine = fileLines[javadocEndToken.getLineNo() - 1];\n        final Optional<Integer> endingBlockColumnNumber = getAsteriskColumnNumber(lastLine);\n\n        endingBlockColumnNumber\n                .map(columnNumber -> expandedTabs(lastLine, columnNumber))\n                .filter(columnNumber -> !hasValidAlignment(expectedColumnNumberTabsExpanded, columnNumber))\n                .ifPresent(columnNumber -> {\n                    logViolation(javadocEndToken.getLineNo(),\n                            columnNumber,\n                            expectedColumnNumberTabsExpanded);\n                });\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "84", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "85", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "86", "src_id": "M37", "code": "\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        final ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "87", "src_id": "M28", "code": "\n    private void scrapeContent(DetailNode ast) {\n\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n\n        }\n\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "88", "src_id": "M27", "code": "\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName\n                    .substring(0, moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n            moduleDetails.setModuleType(getModuleType());\n        }\n\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "89", "src_id": "M35", "code": "\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                   Pattern pattern) {\n\n        return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "90", "src_id": "M37", "code": "\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "91", "src_id": "M28", "code": "\n    private void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "92", "src_id": "M27", "code": "\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName.substring(0,\n                    moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "93", "src_id": "M35", "code": "\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n            Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "94", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "95", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "96", "src_id": "M601", "code": "\n    @Override\n    public void beginTree(DetailAST root) {\n        variables.clear();\n        typeDeclarations.clear();\n        typeDeclAstToTypeDeclDesc.clear();\n        anonInnerAstToTypeDeclDesc.clear();\n        anonInnerClassHolders.clear();\n        packageName = null;\n        depth = 0;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "97", "src_id": "M600", "code": "\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.DOT,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.IDENT,\n            TokenTypes.SLIST,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.OBJBLOCK,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.STATIC_INIT,\n            TokenTypes.INSTANCE_INIT,\n            TokenTypes.COMPILATION_UNIT,\n            TokenTypes.LAMBDA,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "98", "src_id": "M615", "code": "\n    private void iterateOverBlockContainingLocalAnonInnerClass(\n            DetailAST ast, Deque<VariableDesc> variablesStack) {\n        DetailAST currNode = ast;\n        while (currNode != null) {\n            customVisitToken(currNode, variablesStack);\n            DetailAST toVisit = currNode.getFirstChild();\n            while (currNode != ast && toVisit == null) {\n                customLeaveToken(currNode, variablesStack);\n                toVisit = currNode.getNextSibling();\n                currNode = currNode.getParent();\n            }\n            currNode = toVisit;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "99", "src_id": "M383", "code": "\n    private static void extractInlineTagContent(DetailNode node,\n                                               StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "100", "src_id": "M593", "code": "\n    private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            parameterNames.add(ast.getText());\n        }\n        else {\n            visitParameters(ast);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "101", "src_id": "M175", "code": "\n    @Override\n    public void auditFinished(AuditEvent event) {\n        errorWriter.flush();\n\n        if (closeErrorWriter) {\n            errorWriter.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "102", "src_id": "M603", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isOfType(ast, SCOPES)) {\n            logViolations(ast, variables);\n        }\n        else if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n            leaveCompilationUnit();\n        }\n        else if (isNonLocalTypeDeclaration(ast)) {\n            depth--;\n            typeDeclarations.pop();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "103", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "104", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "105", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "106", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "107", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "108", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(\n            DetailAST startingBranch, DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "109", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(\n            DetailAST token, DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "110", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "121", "src_id": "M601", "code": "\n    @Override\n    public void beginTree(DetailAST root) {\n        variables.clear();\n        typeDeclarations.clear();\n        typeDeclAstToTypeDeclDesc.clear();\n        anonInnerAstToTypeDeclDesc.clear();\n        anonInnerClassHolders.clear();\n        packageName = null;\n        depth = 0;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "122", "src_id": "M600", "code": "\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.DOT,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.IDENT,\n            TokenTypes.SLIST,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.OBJBLOCK,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.STATIC_INIT,\n            TokenTypes.INSTANCE_INIT,\n            TokenTypes.COMPILATION_UNIT,\n            TokenTypes.LAMBDA,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "123", "src_id": "M615", "code": "\n    private void iterateOverBlockContainingLocalAnonInnerClass(\n            DetailAST ast, Deque<VariableDesc> variablesStack) {\n        DetailAST currNode = ast;\n        while (currNode != null) {\n            customVisitToken(currNode, variablesStack);\n            DetailAST toVisit = currNode.getFirstChild();\n            while (currNode != ast && toVisit == null) {\n                customLeaveToken(currNode, variablesStack);\n                toVisit = currNode.getNextSibling();\n                currNode = currNode.getParent();\n            }\n            currNode = toVisit;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "124", "src_id": "M383", "code": "\n    private static void extractInlineTagContent(DetailNode node,\n                                               StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "125", "src_id": "M593", "code": "\n    private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            parameterNames.add(ast.getText());\n        }\n        else {\n            visitParameters(ast);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "126", "src_id": "M175", "code": "\n    @Override\n    public void auditFinished(AuditEvent event) {\n        errorWriter.flush();\n\n        if (closeErrorWriter) {\n            errorWriter.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "127", "src_id": "M603", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isOfType(ast, SCOPES)) {\n            logViolations(ast, variables);\n        }\n        else if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n            leaveCompilationUnit();\n        }\n        else if (isNonLocalTypeDeclaration(ast)) {\n            depth--;\n            typeDeclarations.pop();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "128", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "129", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "130", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "131", "src_id": "M697", "code": "\n@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(\n        DetailAST startingBranch,\n        DetailAST bound,\n        int neededTokenType) {\n    DetailAST match = null;\n    DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n    while (iteratedBranch != null) {\n        if (iteratedBranch.getType() == neededTokenType) {\n            match = iteratedBranch;\n            break;\n        }\n        iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n    }\n    return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "132", "src_id": "M564", "code": "\nprivate static boolean isTokenNotOnPreviousSiblingLines(\n        DetailAST token,\n        DetailAST parentToken) {\n    DetailAST previousSibling = parentToken.getPreviousSibling();\n    for (DetailAST astNode = previousSibling; astNode != null;\n            astNode = astNode.getLastChild()) {\n        previousSibling = astNode;\n    }\n    return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "133", "src_id": "M695", "code": "\nprivate static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n    final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n    final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n    for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n            expressionBranch != null;\n            expressionBranch = traverseUntilNeededBranchType(\n                    expressionBranch,\n                    branchLeadingToReassignedVar,\n                    TokenTypes.EXPR)) {\n        final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n        if (assignToken != null) {\n            reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n        }\n    }\n    return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "134", "src_id": "M502", "code": "\n    private int expandedTabsColumnNo(DetailAST ast) {\n        final String line =\n            indentCheck.getLine(ast.getLineNo() - 1);\n\n        return CommonUtil.lengthExpandedTabs(\n            line,\n            ast.getColumnNo(),\n            indentCheck.getIndentationTabWidth());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "135", "src_id": "M455", "code": "\n    @Override\n    public void init() {\n        if (fileNamePattern == null && folderPattern == null) {\n            fileNamePattern = CommonUtil.createPattern(\"\\\\s\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "136", "src_id": "M456", "code": "\n    @Override\n    protected void processFiltered(File file, FileText fileText)\n            throws CheckstyleException {\n        final String fileName = getFileName(file);\n        final String folderPath = getFolderPath(file);\n\n        if (isMatchFolder(folderPath) && isMatchFile(fileName)) {\n            log();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "137", "src_id": "M165", "code": "\n    private AxisIterator getPrecedingSiblingsIterator() {\n        final AxisIterator result;\n        if (indexAmongSiblings == 0) {\n            result = EmptyIterator.ofNodes();\n        }\n        else {\n            result = new ReverseListIterator(getPrecedingSiblings());\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "138", "src_id": "M750", "code": "\n    private static String convertUpperCamelToUpperUnderscore(String text) {\n        final StringBuilder result = new StringBuilder(20);\n        boolean first = true;\n        for (char letter : text.toCharArray()) {\n            if (!first && Character.isUpperCase(letter)) {\n                result.append('_');\n            }\n            result.append(Character.toUpperCase(letter));\n            first = false;\n        }\n        return result.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "139", "src_id": "M346", "code": "\n    @Override\n    protected boolean matchesExactly(String pkg, String fileName) {\n        final boolean result;\n        if (fileName == null) {\n            result = false;\n        }\n        else if (regex) {\n            result = patternForExactMatch.matcher(fileName).matches();\n        }\n        else {\n            result = name.equals(fileName);\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "140", "src_id": "M706", "code": "\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        frames = new HashMap<>();\n        current.clear();\n\n        final Deque<AbstractFrame> frameStack = new LinkedList<>();\n        DetailAST curNode = rootAST;\n        while (curNode != null) {\n            collectDeclarations(frameStack, curNode);\n            DetailAST toVisit = curNode.getFirstChild();\n            while (curNode != null && toVisit == null) {\n                endCollectingDeclarations(frameStack, curNode);\n                toVisit = curNode.getNextSibling();\n                curNode = curNode.getParent();\n            }\n            curNode = toVisit;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "141", "src_id": "M308", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n            case TokenTypes.INSTANCE_INIT:\n            case TokenTypes.STATIC_INIT:\n            case TokenTypes.COMPACT_CTOR_DEF:\n                leaveMethodDef(ast);\n                break;\n            default:\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "142", "src_id": "M167", "code": "\n    private AttributeNode getAttributeNode() {\n        if (attributeNode == ATTRIBUTE_NODE_UNINITIALIZED) {\n            attributeNode = createAttributeNode();\n        }\n        return attributeNode;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "143", "src_id": "M398", "code": "\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "144", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "145", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "146", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "147", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n        final String[] attributes = config.getPropertyNames();\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n        finishLocalSetup();\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "148", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "149", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "150", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "151", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result = null;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "152", "src_id": "M310", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "153", "src_id": "M200", "code": "\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n\n                if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "154", "src_id": "M201", "code": "\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n\n        return len;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "155", "src_id": "M255", "code": "\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result = false;\n\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n\n        for (DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "156", "src_id": "M689", "code": "\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "157", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "158", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "159", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "160", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "161", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "162", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "163", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n        final String[] attributes = config.getPropertyNames();\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n        finishLocalSetup();\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "164", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "165", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n                                                           DetailAST bound,\n                                                           int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "166", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n                                                            DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "167", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "168", "src_id": "M624", "code": "\n    private static boolean hasLiteralNull(DetailAST caseAST) {\n        return Optional.ofNullable(caseAST.findFirstToken(TokenTypes.EXPR))\n                .map(exp -> exp.findFirstToken(TokenTypes.LITERAL_NULL))\n                .isPresent();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "169", "src_id": "M253", "code": "\n    private void checkUnnamedVariables(DetailAST ast) {\n        if (jdkVersion >= JDK_22 && isUnnamedVariable(ast)) {\n            checkForRedundantModifier(ast, TokenTypes.FINAL);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "170", "src_id": "M638", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.LITERAL_CATCH) {\n            final Optional<CatchParameterDetails> unusedCatchParameter = Optional.ofNullable(catchParameters.peek())\n                    .filter(parameter -> !parameter.isUsed())\n                    .filter(parameter -> !\"_\".equals(parameter.getName()));\n\n            unusedCatchParameter.ifPresent(parameter -> {\n                log(parameter.getParameterDefinition(),\n                        MSG_UNUSED_CATCH_PARAMETER,\n                        parameter.getName());\n            });\n            catchParameters.pop();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "171", "src_id": "M626", "code": "\n    private static boolean hasStringCaseLabel(DetailAST caseAST) {\n        DetailAST curNode = caseAST;\n        boolean hasStringCaseLabel = false;\n        boolean exitCaseLabelExpression = false;\n        while (!exitCaseLabelExpression) {\n            DetailAST toVisit = curNode.getFirstChild();\n            if (curNode.getType() == TokenTypes.STRING_LITERAL) {\n                hasStringCaseLabel = true;\n                break;\n            }\n            while (toVisit == null) {\n                toVisit = curNode.getNextSibling();\n                curNode = curNode.getParent();\n            }\n            curNode = toVisit;\n            exitCaseLabelExpression = TokenUtil.isOfType(curNode,\n                    TokenTypes.COLON, TokenTypes.LAMBDA);\n        }\n        return hasStringCaseLabel;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "172", "src_id": "M673", "code": "\n    private static boolean isLambdaParameterIdentifierCandidate(DetailAST identifierAst) {\n        // we should ignore the ident if it is in the lambda parameters declaration\n        final boolean isLambdaParameterDeclaration =\n                identifierAst.getParent().getType() == TokenTypes.LAMBDA\n                || identifierAst.getParent().getType() == TokenTypes.PARAMETER_DEF;\n\n        return !isLambdaParameterDeclaration\n                && (hasValidParentToken(identifierAst) || isMethodInvocation(identifierAst));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "173", "src_id": "M251", "code": "\n    public void setJdkVersion(String jdkVersion) {\n        final String singleVersionNumber;\n        if (jdkVersion.startsWith(\"1.\")) {\n            singleVersionNumber = jdkVersion.substring(2);\n        }\n        else {\n            singleVersionNumber = jdkVersion;\n        }\n\n        this.jdkVersion = Integer.parseInt(singleVersionNumber);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "174", "src_id": "M675", "code": "\n    private static boolean isLeftHandOfAssignment(DetailAST identAst) {\n        final DetailAST parent = identAst.getParent();\n        return parent.getType() == TokenTypes.ASSIGN\n                && !identAst.equals(parent.getLastChild());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "175", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "176", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "177", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "178", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "179", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "180", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "181", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "182", "src_id": "M697", "code": "\n@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n        DetailAST bound, int neededTokenType) {\n    DetailAST match = null;\n    DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n    while (iteratedBranch != null) {\n        if (iteratedBranch.getType() == neededTokenType) {\n            match = iteratedBranch;\n            break;\n        }\n        iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n    }\n    return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "183", "src_id": "M564", "code": "\nprivate static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n        DetailAST parentToken) {\n    DetailAST previousSibling = parentToken.getPreviousSibling();\n    for (DetailAST astNode = previousSibling; astNode != null;\n            astNode = astNode.getLastChild()) {\n        previousSibling = astNode;\n    }\n    return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "184", "src_id": "M695", "code": "\nprivate static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n    final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n    final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n    for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n            expressionBranch != null;\n            expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                    branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n        final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n        if (assignToken != null) {\n            reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n        }\n    }\n    return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "185", "src_id": "M310", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "186", "src_id": "M200", "code": "\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n                }\n            }\n            final String fileName = file.getName();\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "187", "src_id": "M201", "code": "\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "188", "src_id": "M255", "code": "\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result = false;\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n        for (DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "189", "src_id": "M689", "code": "\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "190", "src_id": "M310", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "191", "src_id": "M200", "code": "\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        final boolean result;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n            boolean found = false;\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    found = true;\n                    break;\n                }\n            }\n            result = found;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "192", "src_id": "M201", "code": "\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "193", "src_id": "M255", "code": "\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n        boolean result = false;\n        for (final DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "194", "src_id": "M689", "code": "\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "195", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "196", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "197", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "198", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "199", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "9", "src_id": "M855", "code": "    @Override\n    public DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n\n        final DetailAstImpl bop = create(ctx.bop);\n        bop.addChild(visit(ctx.expr()));\n        bop.addChild(create(ctx.LITERAL_THIS()));\n\n        return bop;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "10", "src_id": "M770", "code": "    @Override\n    public DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n\n        final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n        interfaceExtends.addChild(visit(ctx.typeList()));\n\n        return interfaceExtends;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "11", "src_id": "M854", "code": "    @Override\n    public DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n\n        final DetailAstImpl lambda = create(ctx.LAMBDA());\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n        final JavaLanguageParser.BlockContext blockContext = ctx.block();\n        final DetailAstImpl rightHandLambdaChild;\n        if (blockContext != null) {\n            rightHandLambdaChild = visit(blockContext);\n        }\n        else {\n            // Lambda expression child is built the same way that we build\n            // the initial expression node in visitExpression, i.e. with\n            // an imaginary EXPR node. This results in nested EXPR nodes\n            // in the AST.\n            rightHandLambdaChild = buildExpressionNode(ctx.expr());\n        }\n        lambda.addChild(rightHandLambdaChild);\n\n        return lambda;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "12", "src_id": "M779", "code": "    @Override\n    public DetailAstImpl visitInterfaceMethodDeclaration(\n            JavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n\n        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n        methodDef.addChild(createModifiers(ctx.mods));\n\n        // Process all children except C style array declarators and modifiers\n        final List<ParseTree> children = ctx.children\n            .stream()\n            .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n            .collect(Collectors.toUnmodifiableList());\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n        final DetailAstImpl typeAst =\n            (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n        ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n        return methodDef;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "14", "src_id": "M228", "code": "    private static Map.Entry<Integer, Integer> countLinesColumns(\n        String text, int initialLinesCnt, int initialColumnsCnt) {\n\n        int lines = initialLinesCnt;\n        int columns = initialColumnsCnt;\n        boolean foundCr = false;\n\n        for (char c : text.toCharArray()) {\n            if (c == '\\n') {\n                foundCr = false;\n                lines++;\n                columns = 0;\n            }\n            else {\n                if (foundCr) {\n                    foundCr = false;\n                    lines++;\n                    columns = 0;\n                }\n                if (c == '\\r') {\n                    foundCr = true;\n                }\n                columns++;\n            }\n        }\n\n        if (foundCr) {\n            lines++;\n            columns = 0;\n        }\n\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "15", "src_id": "M212", "code": "    public static Properties getResolvedProperties(Properties properties)\n            throws CheckstyleException {\n\n        final Set<String> unresolvedPropertyNames =\n            new HashSet<>(properties.stringPropertyNames());\n        Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n        final Map<Object, Object> comparisonProperties = new Properties();\n\n        while (unresolvedPropertyIterator.hasNext()) {\n            final String propertyName = unresolvedPropertyIterator.next();\n            String propertyValue = properties.getProperty(propertyName);\n            final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n            while (matcher.find()) {\n                final String propertyVariableExpression = matcher.group();\n                final String unresolvedPropertyName =\n                    getPropertyNameFromExpression(propertyVariableExpression);\n\n                final String resolvedPropertyValue =\n                    properties.getProperty(unresolvedPropertyName);\n\n                if (resolvedPropertyValue != null) {\n                    propertyValue = propertyValue.replace(propertyVariableExpression,\n                        resolvedPropertyValue);\n                    properties.setProperty(propertyName, propertyValue);\n                }\n            }\n\n            if (allChainedPropertiesAreResolved(propertyValue)) {\n                unresolvedPropertyIterator.remove();\n            }\n\n            if (!unresolvedPropertyIterator.hasNext()) {\n\n                if (comparisonProperties.equals(properties)) {\n                    // At this point, we will have not resolved any properties in two iterations,\n                    // so unresolvable properties exist.\n                    throw new CheckstyleException(UNDEFINED_PROPERTY_MESSAGE\n                        + unresolvedPropertyNames);\n                }\n                comparisonProperties.putAll(properties);\n                unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n            }\n\n        }\n\n        return properties;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "16", "src_id": "M794", "code": "    @Override\n    public DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n\n        final DetailAstImpl annotations;\n\n        if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n            // There are no annotations, and we don't want to create the empty node\n            annotations = null;\n        }\n        else {\n            // There are annotations, or we just want the empty node\n            annotations = createImaginary(TokenTypes.ANNOTATIONS);\n            processChildren(annotations, ctx.anno);\n        }\n\n        return annotations;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "17", "src_id": "M764", "code": "    @Override\n    public DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n\n        final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n        processChildren(typeParameter, ctx.children);\n\n        return typeParameter;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "18", "src_id": "M492", "code": "    private void checkYield() {\n\n        final DetailAST yieldKey = getMainAst();\n        final int columnNo = expandedTabsColumnNo(yieldKey);\n\n        if (isOnStartOfLine(yieldKey) && !getIndent().isAcceptable(columnNo)) {\n            logError(yieldKey, \"\", columnNo);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "111", "src_id": "M855", "code": "    @Override\n    public DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n        final DetailAstImpl bop = create(ctx.bop);\n        bop.addChild(visit(ctx.expr()));\n        bop.addChild(create(ctx.LITERAL_THIS()));\n        return bop;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "112", "src_id": "M770", "code": "    @Override\n    public DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n        final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n        interfaceExtends.addChild(visit(ctx.typeList()));\n        return interfaceExtends;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "113", "src_id": "M854", "code": "    @Override\n    public DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n        final DetailAstImpl lambda = create(ctx.LAMBDA());\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n        final JavaLanguageParser.BlockContext blockContext = ctx.block();\n        final DetailAstImpl rightHandLambdaChild;\n        if (blockContext != null) {\n            rightHandLambdaChild = visit(blockContext);\n        }\n        else {\n            // Lambda expression child is built the same way that we build\n            // the initial expression node in visitExpression, i.e. with\n            // an imaginary EXPR node. This results in nested EXPR nodes\n            // in the AST.\n            rightHandLambdaChild = buildExpressionNode(ctx.expr());\n        }\n        lambda.addChild(rightHandLambdaChild);\n        return lambda;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "114", "src_id": "M779", "code": "    @Override\n    public DetailAstImpl visitInterfaceMethodDeclaration(JavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n        methodDef.addChild(createModifiers(ctx.mods));\n\n        // Process all children except C style array declarators and modifiers\n        final List<ParseTree> children = ctx.children.stream()\n            .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n            .collect(Collectors.toUnmodifiableList());\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n        final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n        ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n        return methodDef;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "116", "src_id": "M228", "code": "    private static Map.Entry<Integer, Integer> countLinesColumns(String text,\n                                                                int initialLinesCnt,\n                                                                int initialColumnsCnt) {\n        int lines = initialLinesCnt;\n        int columns = initialColumnsCnt;\n        boolean foundCr = false;\n        for (char c : text.toCharArray()) {\n            if (c == '\\n') {\n                foundCr = false;\n                lines++;\n                columns = 0;\n            }\n            else {\n                if (foundCr) {\n                    foundCr = false;\n                    lines++;\n                    columns = 0;\n                }\n                if (c == '\\r') {\n                    foundCr = true;\n                }\n                columns++;\n            }\n        }\n        if (foundCr) {\n            lines++;\n            columns = 0;\n        }\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "117", "src_id": "M212", "code": "    public static Properties getResolvedProperties(Properties properties)\n            throws CheckstyleException {\n        final Set<String> unresolvedPropertyNames = new HashSet<>(properties.stringPropertyNames());\n        Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n        final Map<Object, Object> comparisonProperties = new Properties();\n\n        while (unresolvedPropertyIterator.hasNext()) {\n            final String propertyName = unresolvedPropertyIterator.next();\n            String propertyValue = properties.getProperty(propertyName);\n            final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n            while (matcher.find()) {\n                final String propertyVariableExpression = matcher.group();\n                final String unresolvedPropertyName =\n                    getPropertyNameFromExpression(propertyVariableExpression);\n\n                final String resolvedPropertyValue =\n                    properties.getProperty(unresolvedPropertyName);\n\n                if (resolvedPropertyValue != null) {\n                    propertyValue = propertyValue.replace(propertyVariableExpression,\n                        resolvedPropertyValue);\n                    properties.setProperty(propertyName, propertyValue);\n                }\n            }\n\n            if (allChainedPropertiesAreResolved(propertyValue)) {\n                unresolvedPropertyIterator.remove();\n            }\n\n            if (!unresolvedPropertyIterator.hasNext()) {\n                if (comparisonProperties.equals(properties)) {\n                    // At this point, we will have not resolved any properties in two iterations,\n                    // so unresolvable properties exist.\n                    throw new CheckstyleException(\n                        UNDEFINED_PROPERTY_MESSAGE + unresolvedPropertyNames);\n                }\n                comparisonProperties.putAll(properties);\n                unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n            }\n        }\n        return properties;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "118", "src_id": "M794", "code": "    @Override\n    public DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n        final DetailAstImpl annotations;\n        if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n            // There are no annotations, and we don't want to create the empty node\n            annotations = null;\n        }\n        else {\n            // There are annotations, or we just want the empty node\n            annotations = createImaginary(TokenTypes.ANNOTATIONS);\n            processChildren(annotations, ctx.anno);\n        }\n        return annotations;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "119", "src_id": "M764", "code": "    @Override\n    public DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n        final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n        processChildren(typeParameter, ctx.children);\n        return typeParameter;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "120", "src_id": "M492", "code": "    private void checkYield() {\n        final DetailAST yieldKey = getMainAst();\n        final int columnNo = expandedTabsColumnNo(yieldKey);\n        if (isOnStartOfLine(yieldKey)\n                && !getIndent().isAcceptable(columnNo)) {\n            logError(yieldKey, \"\", columnNo);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "13", "src_id": "M839", "code": "\n    @Override\n    public DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n        final DetailAstImpl dummyRoot = new DetailAstImpl();\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n        if (ctx.forInit() == null) {\n            final DetailAstImpl imaginaryForInitParent =\n                createImaginary(TokenTypes.FOR_INIT);\n            dummyRoot.addChild(imaginaryForInitParent);\n        }\n        else {\n            dummyRoot.addChild(visit(ctx.forInit()));\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n        final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n        forCondParent.addChild(visit(ctx.forCond));\n        dummyRoot.addChild(forCondParent);\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n        final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n        forItParent.addChild(visit(ctx.forUpdate));\n        dummyRoot.addChild(forItParent);\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n        return dummyRoot.getFirstChild();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "115", "src_id": "M839", "code": "\n    @Override\n    public DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n        final DetailAstImpl dummyRoot = new DetailAstImpl();\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n        if (ctx.forInit() == null) {\n            final DetailAstImpl imaginaryForInitParent = createImaginary(TokenTypes.FOR_INIT);\n            dummyRoot.addChild(imaginaryForInitParent);\n        }\n        else {\n            dummyRoot.addChild(visit(ctx.forInit()));\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n        final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n        forCondParent.addChild(visit(ctx.forCond));\n        dummyRoot.addChild(forCondParent);\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n        final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n        forItParent.addChild(visit(ctx.forUpdate));\n        dummyRoot.addChild(forItParent);\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n        return dummyRoot.getFirstChild();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "1", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        String fileExt = \"\";\n        if (this.format == null) {\n            fileExt = \"html\";\n        } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n                || this.format.equals(\"collapsed\")) {\n            fileExt = \"txt\";\n        } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n            fileExt = \"html\";\n        } else if (this.format.equals(\"jfr\")) {\n            fileExt = \"jfr\";\n        } else {\n            // illegal -o option makes async-profiler use flat\n            fileExt = \"txt\";\n        }\n        return fileExt;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "2", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "3", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "4", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "5", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "6", "src_id": "M1751", "code": "\n    @Override\n    public void onNext(GrpcRequest<ArthasUnittest.ArthasUnittestRequest> req) {\n        try {\n            byte[] bytes = req.readData();\n            while (bytes != null && bytes.length != 0) {\n                ArthasUnittest.ArthasUnittestRequest request = ArthasUnittest.ArthasUnittestRequest.parseFrom(bytes);\n                sum.addAndGet(request.getNum());\n                bytes = req.readData();\n            }\n        } catch (InvalidProtocolBufferException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "7", "src_id": "M1772", "code": "\n    public void writeResponseData(Object response) {\n        byte[] encode = null;\n        try {\n            if (ArthasGrpc.ErrorRes.class.equals(clazz)) {\n                encode = ((ArthasGrpc.ErrorRes) response).toByteArray();\n            } else {\n                encode = (byte[]) GrpcDispatcher.responseToByteArrayMap.get(\n                        GrpcDispatcher.generateGrpcMethodKey(service, method)).invoke(response);\n            }\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n        this.byteData = ByteUtil.newByteBuf();\n        this.byteData.writeBoolean(false);\n        this.byteData.writeInt(encode.length);\n        this.byteData.writeBytes(encode);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "8", "src_id": "M1766", "code": "\n    private void handleResetStream(Http2ResetFrame resetFrame, ChannelHandlerContext ctx) {\n        int id = resetFrame.stream().id();\n        System.out.println(\"handleResetStream\");\n        dataBuffer.remove(id);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "9", "src_id": "M1769", "code": "\n    public synchronized byte[] readData() {\n        if (byteData.readableBytes() == 0) {\n            return null;\n        }\n        boolean compressed = byteData.readBoolean();\n        int length = byteData.readInt();\n        byte[] bytes = new byte[length];\n        byteData.readBytes(bytes);\n        return bytes;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "10", "src_id": "M1784", "code": "\n    @Override\n    public void initChannel(SocketChannel ch) {\n        ch.pipeline().addLast(Http2FrameCodecBuilder.forServer().build());\n        ch.pipeline().addLast(new Http2Handler(grpcDispatcher, grpcExecutorFactory));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "11", "src_id": "M1752", "code": "\n    @Override\n    public void onCompleted() {\n        ArthasUnittest.ArthasUnittestResponse response = ArthasUnittest.ArthasUnittestResponse.newBuilder()\n                .setNum(sum.get())\n                .build();\n        GrpcResponse<ArthasUnittest.ArthasUnittestResponse> grpcResponse = new GrpcResponse<>();\n        grpcResponse.setService(\"arthas.grpc.unittest.ArthasUnittestService\");\n        grpcResponse.setMethod(\"clientStreamSum\");\n        grpcResponse.writeResponseData(response);\n        observer.onNext(grpcResponse);\n        observer.onCompleted();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "12", "src_id": "M1768", "code": "\n    public void writeData(ByteBuf byteBuf) {\n        byte[] bytes = ByteUtil.getBytes(byteBuf);\n        if (bytes.length == 0) {\n            return;\n        }\n        byte[] decompressedData = decompressGzip(bytes);\n        if (decompressedData == null) {\n            return;\n        }\n        byteData.writeBytes(ByteUtil.newByteBuf(decompressedData));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "13", "src_id": "M1756", "code": "\n    public void loadGrpcService(String grpcServicePackageName) {\n        List<Class<?>> classes = ReflectUtil.findClasses(\n                Optional.ofNullable(grpcServicePackageName).orElse(DEFAULT_GRPC_SERVICE_PACKAGE_NAME));\n        for (Class<?> clazz : classes) {\n            if (clazz.isAnnotationPresent(GrpcService.class)) {\n                try {\n                    // 处理 service\n                    GrpcService grpcService = clazz.getAnnotation(GrpcService.class);\n                    Object instance = clazz.getDeclaredConstructor().newInstance();\n                    // 处理 method\n                    MethodHandles.Lookup lookup = MethodHandles.lookup();\n                    Method[] declaredMethods = clazz.getDeclaredMethods();\n                    for (Method method : declaredMethods) {\n                        if (method.isAnnotationPresent(GrpcMethod.class)) {\n                            GrpcMethod grpcMethod = method.getAnnotation(GrpcMethod.class);\n                            MethodHandle grpcInvoke = lookup.unreflect(method);\n                            String grpcMethodKey = generateGrpcMethodKey(grpcService.value(), grpcMethod.value());\n                            grpcInvokeTypeMap.put(grpcMethodKey, grpcMethod.grpcType());\n                            grpcInvokeMap.put(grpcMethodKey, grpcInvoke.bindTo(instance));\n\n                            Class<?> requestClass = null;\n                            Class<?> responseClass = null;\n                            if (GrpcInvokeTypeEnum.UNARY.equals(grpcMethod.grpcType())) {\n                                requestClass = grpcInvoke.type().parameterType(1);\n                                responseClass = grpcInvoke.type().returnType();\n                            } else if (GrpcInvokeTypeEnum.CLIENT_STREAM.equals(grpcMethod.grpcType())\n                                    || GrpcInvokeTypeEnum.BI_STREAM.equals(grpcMethod.grpcType())) {\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                requestClass = getInnerGenericClass(method.getGenericReturnType());\n                            } else if (GrpcInvokeTypeEnum.SERVER_STREAM.equals(grpcMethod.grpcType())) {\n                                requestClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[1]);\n                            }\n                            MethodHandle requestParseFrom = lookup.findStatic(requestClass, \"parseFrom\",\n                                    MethodType.methodType(requestClass, byte[].class));\n                            MethodHandle responseParseFrom = lookup.findStatic(responseClass, \"parseFrom\",\n                                    MethodType.methodType(responseClass, byte[].class));\n                            MethodHandle requestToByteArray = lookup.findVirtual(requestClass, \"toByteArray\",\n                                    MethodType.methodType(byte[].class));\n                            MethodHandle responseToByteArray = lookup.findVirtual(responseClass, \"toByteArray\",\n                                    MethodType.methodType(byte[].class));\n                            requestParseFromMap.put(grpcMethodKey, requestParseFrom);\n                            responseParseFromMap.put(grpcMethodKey, responseParseFrom);\n                            requestToByteArrayMap.put(grpcMethodKey, requestToByteArray);\n                            responseToByteArrayMap.put(grpcMethodKey, responseToByteArray);\n\n                            //                            switch (grpcMethod.grpcType()) {\n                            //                                case UNARY:\n                            //                                    unaryInvokeMap.put(grpcMethodKey, grpcInvoke.bindTo(instance));\n                            //                                    return;\n                            //                                case CLIENT_STREAM:\n                            //                                    Object invoke = grpcInvoke.bindTo(instance).invoke();\n                            //                                    if (!(invoke instanceof StreamObserver)) {\n                            //                                        throw new RuntimeException(grpcMethodKey + \" return class is not StreamObserver!\");\n                            //                                    }\n                            //                                    clientStreamInvokeMap.put(grpcMethodKey, (StreamObserver) invoke);\n                            //                                    return;\n                            //                                case SERVER_STREAM:\n                            //                                    return;\n                            //                                case BI_STREAM:\n                            //                                    return;\n                            //                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    logger.error(\"GrpcDispatcher loadGrpcService error.\", e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "14", "src_id": "M1105", "code": "\n    @Override\n    public void onSuspend(Job job) {\n        if (!job.isRunInBackground()) {\n            resetAndReadLine();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "15", "src_id": "M1106", "code": "\n    private void resetAndReadLine() {\n        // reset stdin handler to echo handler\n        // shell.term().stdinHandler(null);\n        shell.setForegroundJob(null);\n        shell.readline();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "16", "src_id": "M504", "code": "\n    private void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n        for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n            String objectName = entry.getKey();\n            List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n            TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n            table.row(true, \"OBJECT_NAME\", objectName);\n            table.row(true, label(\"NAME\").style(Decoration.bold.bold()),\n                    label(\"VALUE\").style(Decoration.bold.bold()));\n\n            for (MBeanAttributeVO attributeVO : attributeVOList) {\n                String attributeName = attributeVO.getName();\n                String valueStr;\n                if (attributeVO.getError() != null) {\n                    valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n                } else {\n                    // convert array to list\n                    // TODO: support all array type\n                    Object value = attributeVO.getValue();\n                    if (value instanceof String[]) {\n                        value = Arrays.asList((String[]) value);\n                    } else if (value instanceof Integer[]) {\n                        value = Arrays.asList((Integer[]) value);\n                    } else if (value instanceof Long[]) {\n                        value = Arrays.asList((Long[]) value);\n                    } else if (value instanceof int[]) {\n                        value = convertArrayToList((int[]) value);\n                    } else if (value instanceof long[]) {\n                        value = convertArrayToList((long[]) value);\n                    }\n                    // to string\n                    valueStr = String.valueOf(value);\n                }\n                table.row(attributeName, valueStr);\n            }\n            process.write(RenderUtil.render(table, process.width()));\n            process.write(\"\\n\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "17", "src_id": "M1157", "code": "\n    private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n        DefaultFullHttpResponse fullResp = null;\n        InputStream in = null;\n        try {\n            URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n            if (res != null) {\n                fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n                in = res.openStream();\n                byte[] tmp = new byte[256];\n                for (int l = 0; l != -1; l = in.read(tmp)) {\n                    fullResp.content().writeBytes(tmp, 0, l);\n                }\n                int li = path.lastIndexOf('.');\n                if (li != -1 && li != path.length() - 1) {\n                    String ext = path.substring(li + 1);\n                    String contentType;\n                    if (\"html\".equals(ext)) {\n                        contentType = \"text/html\";\n                    } else if (\"js\".equals(ext)) {\n                        contentType = \"application/javascript\";\n                    } else if (\"css\".equals(ext)) {\n                        contentType = \"text/css\";\n                    } else {\n                        contentType = null;\n                    }\n                    if (contentType != null) {\n                        fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                    }\n                }\n            }\n        } finally {\n            IOUtils.close(in);\n        }\n        return fullResp;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "18", "src_id": "M381", "code": "\n    @Override\n    public List<ResultModel> pollResults() {\n        try {\n            lastAccessTime = System.currentTimeMillis();\n            long accessTime = lastAccessTime;\n            if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                polling = true;\n                sendingItemCount = 0;\n                long firstResultTime = 0;\n                long sendingDelay = 0;\n                long waitingTime = 0;\n                List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n                while (!closed\n                        && sendingResults.size() < resultBatchSizeLimit\n                        && sendingDelay < 100\n                        && waitingTime < pollTimeLimit) {\n                    ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                    if (aResult != null) {\n                        sendingResults.add(aResult);\n                        if (firstResultTime == 0) {\n                            firstResultTime = System.currentTimeMillis();\n                        }\n                        if (shouldFlush(sendingResults, aResult)) {\n                            break;\n                        }\n                    } else {\n                        if (firstResultTime > 0) {\n                            sendingDelay = System.currentTimeMillis() - firstResultTime;\n                        }\n                        waitingTime = System.currentTimeMillis() - accessTime;\n                    }\n                }\n\n                // resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n                }\n                return sendingResults;\n            }\n        } catch (InterruptedException e) {\n            // e.printStackTrace();\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lastAccessTime = System.currentTimeMillis();\n                polling = false;\n                lock.unlock();\n            }\n        }\n        return Collections.emptyList();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "19", "src_id": "M519", "code": "\n    @Override\n    public void draw(CommandProcess process, DashboardModel result) {\n        int width = process.width();\n        int height = process.height();\n\n        // 上半部分放thread top。下半部分再切分为田字格，其中上面两格放memory, gc的信息。下面两格放tomcat,\n        // runtime的信息\n        int totalHeight = height - 1;\n        int threadTopHeight;\n        if (totalHeight <= 24) {\n            // 总高度较小时取1/2\n            threadTopHeight = totalHeight / 2;\n        } else {\n            // 总高度较大时取1/3，但不少于上面的值(24/2=12)\n            threadTopHeight = totalHeight / 3;\n            if (threadTopHeight < 12) {\n                threadTopHeight = 12;\n            }\n        }\n        int lowerHalf = totalHeight - threadTopHeight;\n\n        // Memory至少保留8行, 显示metaspace信息\n        int memoryInfoHeight = lowerHalf / 2;\n        if (memoryInfoHeight < 8) {\n            memoryInfoHeight = Math.min(8, lowerHalf);\n        }\n\n        // runtime\n        TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n        // tomcat\n        TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n        int runtimeInfoHeight = Math.max(runtimeInfoTable.getRows().size(), tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size());\n        if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n            // 如果runtimeInfo高度有剩余，则增大MemoryInfo的高度\n            memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n        } else {\n            runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n        }\n\n        // 如果MemoryInfo高度有剩余，则增大ThreadHeight\n        int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n        memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n        threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n        String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n        String memoryAndGc = drawMemoryInfoAndGcInfo(result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n        String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n\n        process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "20", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                    .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                    .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.classLoader)))\n                    .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                    .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.additivity)))\n                    .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                            label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash),\n                            label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target),\n                                label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking),\n                                label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef),\n                                label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "21", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = false;\n        if (session.get(ONETIME_SESSION_KEY) != null) {\n            oneTimeAccess = true;\n        }\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<String, Object>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse();\n            response.setSessionId(session.getSessionId())\n                    .setBody(body);\n\n            if (!session.tryLock()) {\n                response.setState(ApiState.REFUSED)\n                        .setMessage(\"Another command is executing.\");\n                return response;\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    response.setState(ApiState.REFUSED)\n                            .setMessage(\"Another job is running.\");\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response;\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                // distribute result message both to origin session channel and request channel by CompositeResultDistributor\n                // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n\n            } catch (Throwable e) {\n                logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n                response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            // wait for job completed or timeout\n            Integer timeout = apiRequest.getExecTimeout();\n            if (timeout == null || timeout <= 0) {\n                timeout = DEFAULT_EXEC_TIMEOUT;\n            }\n            boolean timeExpired = !waitForJob(job, timeout);\n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            // packing results\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            response.setSessionId(session.getSessionId())\n                    // .setConsumerId(consumerId)\n                    .setBody(body);\n            return response;\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "22", "src_id": "M494", "code": "\n    private void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n        callback.callback(deep, isLast, prefix, node);\n        if (!isLeaf(node)) {\n            List<TraceNode> children = node.getChildren();\n            if (children == null) {\n                return;\n            }\n            final int size = children.size();\n            for (int index = 0; index < size; index++) {\n                final boolean isLastFlag = index == size - 1;\n                final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n                recursive(\n                        deep + 1,\n                        isLastFlag,\n                        currentPrefix,\n                        children.get(index),\n                        callback\n                );\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "23", "src_id": "M474", "code": "\n    private static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n        if (parentClassLoader.getChildren() == null) {\n            return;\n        }\n        for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n            TreeElement child = new TreeElement(childClassLoader.getName());\n            parent.addChild(child);\n            renderSubtree(child, childClassLoader);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "24", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        String fileExt = \"\";\n        if (this.format == null) {\n            fileExt = \"html\";\n        } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\")\n                || this.format.equals(\"collapsed\")) {\n            fileExt = \"txt\";\n        } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n            fileExt = \"html\";\n        } else if (this.format.equals(\"jfr\")) {\n            fileExt = \"jfr\";\n        } else {\n            // illegal -o option makes async-profiler use flat\n            fileExt = \"txt\";\n        }\n        return fileExt;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "25", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "26", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "27", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "28", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "29", "src_id": "M604", "code": "\nprivate String outputFileExt() {\n    String fileExt = \"\";\n    if (this.format == null) {\n        fileExt = \"html\";\n    } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n            || this.format.equals(\"collapsed\")) {\n        fileExt = \"txt\";\n    } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n        fileExt = \"html\";\n    } else if (this.format.equals(\"jfr\")) {\n        fileExt = \"jfr\";\n    } else {\n        // illegal -o option makes async-profiler use flat\n        fileExt = \"txt\";\n    }\n    return fileExt;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "30", "src_id": "M579", "code": "\n@Option(longName = \"lock\")\n@Description(\"lock profiling threshold in nanoseconds\")\npublic void setLock(String lock) {\n    this.lock = lock;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "31", "src_id": "M585", "code": "\n@Option(longName = \"cstack\")\n@Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\npublic void setCstack(String cstack) {\n    this.cstack = cstack;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "32", "src_id": "M601", "code": "\n@Option(longName = \"timeout\")\n@Description(\"automatically stop profiler at TIME (absolute or relative)\")\npublic void setTimeout(String timeout) {\n    this.timeout = timeout;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "33", "src_id": "M592", "code": "\n@Option(longName = \"end\")\n@Description(\"automatically stop profiling when the specified native function is executed\")\npublic void setEnd(String end) {\n    this.end = end;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "34", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        String fileExt = \"\";\n        if (this.format == null) {\n            fileExt = \"html\";\n        } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n                || this.format.equals(\"collapsed\")) {\n            fileExt = \"txt\";\n        } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n            fileExt = \"html\";\n        } else if (this.format.equals(\"jfr\")) {\n            fileExt = \"jfr\";\n        } else {\n            // illegal -o option makes async-profiler use flat\n            fileExt = \"txt\";\n        }\n        return fileExt;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "35", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "36", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "37", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "38", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "39", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        String fileExt = \"\";\n        if (this.format == null) {\n            fileExt = \"html\";\n        } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\")\n                || this.format.equals(\"collapsed\")) {\n            fileExt = \"txt\";\n        } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n            fileExt = \"html\";\n        } else if (this.format.equals(\"jfr\")) {\n            fileExt = \"jfr\";\n        } else {\n            // illegal -o option makes async-profiler use flat\n            fileExt = \"txt\";\n        }\n        return fileExt;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "40", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "41", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "42", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "43", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "44", "src_id": "M1539", "code": "\n    @Override\n    public void onError(Throwable t) {\n        Status s = Status.fromThrowable(t);\n        sendResponse.writeError(s);\n        latch.countDown();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "45", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n        Map<String, String> map = new HashMap<>();\n        for (String key : trailer.keys()) {\n            if (EXCLUDED.contains(key.toLowerCase())) {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                map.put(key, new String(value));\n            } else {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                map.put(key, value);\n            }\n        }\n        return map;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "46", "src_id": "M1553", "code": "\n    public byte[] getPrefix(byte[] in, Type type) {\n        int len = in.length;\n        return new byte[] {\n                type.value,\n                (byte) ((len >> 24) & 0xff),\n                (byte) ((len >> 16) & 0xff),\n                (byte) ((len >> 8) & 0xff),\n                (byte) (len & 0xff),\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "47", "src_id": "M1538", "code": "\n    private Method getRpcMethod(Object stub, String rpcMethodName) {\n        for (Method m : stub.getClass().getMethods()) {\n            if (m.getName().equals(rpcMethodName)) {\n                return m;\n            }\n        }\n        throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "48", "src_id": "M1535", "code": "\n    private Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n        // pathInfo starts with \"/\". ignore that first char.\n        String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n        if (rpcClassAndMethodTokens.length != 2) {\n            throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n        }\n\n        String rpcClassName = rpcClassAndMethodTokens[0];\n        String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n        String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n        return new Pair<>(rpcClassName, rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "49", "src_id": "M1530", "code": "\n    @Override\n    public boolean isEndOfInput() throws Exception {\n        if (input.isEndOfInput()) {\n            // Only end of input after last HTTP chunk has been sent\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "50", "src_id": "M308", "code": "\n    HashEntry<K, V> nextEntry() {\n        do {\n            if (nextEntry == null) {\n                throw new NoSuchElementException();\n            }\n\n            lastReturned = nextEntry;\n            currentKey = lastReturned.key();\n            advance();\n        } while (currentKey == null); // Skip GC'd keys\n\n        return lastReturned;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "51", "src_id": "M1284", "code": "\n    @AtInvoke(name = \"\", inline = true, whenComplete = false, excludes = \"java.**\")\n    public static void onInvoke(@Binding.This Object target, @Binding.Class Class<?> clazz,\n                               @Binding.InvokeInfo String invokeInfo) {\n        SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "52", "src_id": "M947", "code": "\n    public void loggers(CommandProcess process) {\n\n        Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<ClassLoader, LoggerTypes>();\n\n        // 如果不指定 classloader，则打印所有 classloader 里的 logger 信息\n        for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n            String className = clazz.getName();\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            // if special classloader\n            if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) {\n                continue;\n            }\n\n            if (classLoader != null) {\n                LoggerTypes loggerTypes = classLoaderLoggerMap.get(classLoader);\n                if (loggerTypes == null) {\n                    loggerTypes = new LoggerTypes();\n                    classLoaderLoggerMap.put(classLoader, loggerTypes);\n                }\n                updateLoggerType(loggerTypes, classLoader, className);\n            }\n        }\n\n        for (Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n            ClassLoader classLoader = entry.getKey();\n            LoggerTypes loggerTypes = entry.getValue();\n\n            if (loggerTypes.contains(LoggerType.LOG4J)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4jHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n\n            if (loggerTypes.contains(LoggerType.LOGBACK)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, LogbackHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n\n            if (loggerTypes.contains(LoggerType.LOG4J2)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4j2Helper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n        }\n\n        process.end();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "53", "src_id": "M249", "code": "\n    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) throws URISyntaxException {\n\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n\n        String appName = null;\n        List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n        if (appNameList != null && !appNameList.isEmpty()) {\n            appName = appNameList.get(0);\n        }\n\n        // generate a random agent id\n        String id = null;\n        if (appName != null) {\n            // 如果有传 app name，则生成带 app name前缀的id，方便管理\n            id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n        } else {\n            id = RandomStringUtils.random(20, true, true).toUpperCase();\n        }\n        // agent传过来，则优先用 agent的\n        List<String> idList = parameters.get(URIConstans.ID);\n        if (idList != null && !idList.isEmpty()) {\n            id = idList.get(0);\n        }\n\n        String arthasVersion = null;\n        List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n        if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n            arthasVersion = arthasVersionList.get(0);\n        }\n\n        final String finalId = id;\n\n        // URI responseUri = new URI(\"response\", null, \"/\", \"method=\" + MethodConstants.AGENT_REGISTER + \"&id=\" + id, null);\n        URI responseUri = UriComponentsBuilder.newInstance().scheme(URIConstans.RESPONSE).path(\"/\")\n                .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n                .queryParam(URIConstans.ID, id)\n                .build()\n                .encode().toUri();\n\n        AgentInfo info = new AgentInfo();\n\n        // 前面可能有nginx代理\n        HttpHeaders headers = handshake.requestHeaders();\n        String host = HttpUtils.findClientIP(headers);\n\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n                info.setHost(inetSocketAddress.getHostString());\n                info.setPort(inetSocketAddress.getPort());\n            }\n        } else {\n            info.setHost(host);\n            Integer port = HttpUtils.findClientPort(headers);\n            if (port != null) {\n                info.setPort(port);\n            }\n        }\n\n        info.setChannelHandlerContext(ctx);\n        if (arthasVersion != null) {\n            info.setArthasVersion(arthasVersion);\n        }\n\n        tunnelServer.addAgent(id, info);\n        ctx.channel().closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {\n            @Override\n            public void operationComplete(Future<? super Void> future) throws Exception {\n                tunnelServer.removeAgent(finalId);\n            }\n        });\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "54", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect) throws SSLException, URISyntaxException, InterruptedException {\n\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER);\n        queryEncoder.addParam(URIConstans.ARTHAS_VERSION, this.version);\n        if (appName != null) {\n            queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        }\n        if (id != null) {\n            queryEncoder.addParam(URIConstans.ID, id);\n        }\n        // ws://127.0.0.1:7777/ws?method=agentRegister\n        final URI agentRegisterURI = queryEncoder.toUri();\n\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = agentRegisterURI.getScheme() == null ? \"ws\" : agentRegisterURI.getScheme();\n        final String host = agentRegisterURI.getHost() == null ? \"127.0.0.1\" : agentRegisterURI.getHost();\n        final int port;\n        if (agentRegisterURI.getPort() == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else if (\"wss\".equalsIgnoreCase(scheme)) {\n                port = 443;\n            } else {\n                port = -1;\n            }\n        } else {\n            port = agentRegisterURI.getPort();\n        }\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n        }\n\n        final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n        final SslContext sslCtx;\n        if (ssl) {\n            sslCtx = SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        WebSocketClientProtocolConfig clientProtocolConfig = WebSocketClientProtocolConfig.newBuilder()\n                .webSocketUri(agentRegisterURI)\n                .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH)\n                .build();\n\n        final WebSocketClientProtocolHandler websocketClientHandler = new WebSocketClientProtocolHandler(\n                clientProtocolConfig);\n        final TunnelClientSocketClientHandler handler = new TunnelClientSocketClientHandler(TunnelClient.this);\n\n        Bootstrap bs = new Bootstrap();\n\n        bs.group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(host, port)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n\n                        p.addLast(new HttpClientCodec(),\n                                new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                                websocketClientHandler,\n                                new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                                handler);\n                    }\n                });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.cause() != null) {\n                        logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n                    }\n                }\n            });\n        }\n        connectFuture.sync();\n\n        return handler.registerFuture();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "55", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[] {\n            0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65,\n            0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x6d, 0x69, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74,\n            0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74,\n            0x20, 0x6c, 0x65, 0x74, 0x20, 0x6d, 0x79, 0x73, 0x65, 0x6c, 0x66, 0x0a, 0x43, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6d,\n            0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x73, 0x6f, 0x20, 0x6d, 0x75, 0x63, 0x68, 0x20, 0x6d, 0x69, 0x73,\n            0x65, 0x72, 0x79, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61,\n            0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x61, 0x79, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x59,\n            0x6f, 0x75, 0x20, 0x66, 0x65, 0x6c, 0x6c, 0x20, 0x73, 0x6f, 0x20, 0x68, 0x61, 0x72, 0x64, 0x0a, 0x0a, 0x49, 0x20,\n            0x76, 0x65, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x72, 0x64,\n            0x20, 0x77, 0x61, 0x79, 0x0a, 0x54, 0x6f, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x69,\n            0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x61, 0x72, 0x0a, 0x0a, 0x42, 0x65, 0x63,\n            0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72,\n            0x20, 0x73, 0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d,\n            0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75,\n            0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64,\n            0x20, 0x74, 0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66,\n            0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67,\n            0x65, 0x74, 0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20,\n            0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20,\n            0x74, 0x6f, 0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d,\n            0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f,\n            0x75, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n            0x6f, 0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x6c,\n            0x6f, 0x73, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x77, 0x61, 0x79, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x73,\n            0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72,\n            0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x74, 0x20, 0x6f, 0x75, 0x74, 0x0a,\n            0x49, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x72, 0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n            0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x20, 0x77,\n            0x65, 0x61, 0x6b, 0x6e, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x65, 0x79, 0x65,\n            0x73, 0x0a, 0x49, 0x20, 0x6d, 0x20, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6b,\n            0x65, 0x0a, 0x41, 0x20, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x2c, 0x20, 0x61, 0x20, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x20,\n            0x65, 0x76, 0x65, 0x72, 0x79, 0x64, 0x61, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66, 0x65,\n            0x0a, 0x4d, 0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x27, 0x74, 0x20, 0x70, 0x6f, 0x73,\n            0x73, 0x69, 0x62, 0x6c, 0x79, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x0a, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74,\n            0x20, 0x77, 0x61, 0x73, 0x6e, 0x27, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x77, 0x68, 0x6f, 0x6c, 0x65, 0x20, 0x74,\n            0x6f, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75,\n            0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x73,\n            0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74,\n            0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,\n            0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74,\n            0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65, 0x20,\n            0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65, 0x74,\n            0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f,\n            0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74, 0x6f,\n            0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d, 0x65, 0x2c,\n            0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f, 0x75, 0x6e,\n            0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75,\n            0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x77, 0x61, 0x74,\n            0x63, 0x68, 0x65, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x65, 0x0a, 0x49, 0x20, 0x68, 0x65, 0x61, 0x72,\n            0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x72, 0x79, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6e, 0x69, 0x67,\n            0x68, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x0a, 0x49, 0x20,\n            0x77, 0x61, 0x73, 0x20, 0x73, 0x6f, 0x20, 0x79, 0x6f, 0x75, 0x6e, 0x67, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x73, 0x68,\n            0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x62, 0x65, 0x74,\n            0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x65, 0x61, 0x6e, 0x20, 0x6f, 0x6e,\n            0x20, 0x6d, 0x65, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x6f, 0x75, 0x67,\n            0x68, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x59,\n            0x6f, 0x75, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x73, 0x61, 0x77, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x70, 0x61,\n            0x69, 0x6e, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x77, 0x20, 0x49, 0x20, 0x63, 0x72, 0x79, 0x20, 0x69, 0x6e,\n            0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,\n            0x6e, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x46, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20,\n            0x64, 0x61, 0x6d, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,\n            0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72,\n            0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65,\n            0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f,\n            0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,\n            0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65, 0x20, 0x73, 0x69,\n            0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x68,\n            0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a,\n            0x49, 0x20, 0x74, 0x72, 0x79, 0x20, 0x6d, 0x79, 0x20, 0x68, 0x61, 0x72, 0x64, 0x65, 0x73, 0x74, 0x20, 0x6a, 0x75,\n            0x73, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x6f, 0x72, 0x67, 0x65, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74,\n            0x68, 0x69, 0x6e, 0x67, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75,\n            0x0a, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74,\n            0x6f, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x20, 0x69,\n            0x6e, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20,\n            0x6d, 0x20, 0x61, 0x73, 0x68, 0x61, 0x6d, 0x65, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66,\n            0x65, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x73, 0x20, 0x65, 0x6d, 0x70, 0x74,\n            0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20,\n            0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20,\n            0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n            0x6f, 0x75, 0x0a, 0x2e, 0x2e, 0x2e, 0x0a, /*0x0a, 0x66, 0x6f, 0x72, 0x20, 0x6a, 0x75, 0x6c, 0x79, 0x0a, 0x0a,*/\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "56", "src_id": "M124", "code": "\n    @Override\n    public int read() throws IOException {\n\n        // Critical section because we're altering __bytesAvailable,\n        // __queueHead, and the contents of _queue in addition to\n        // testing value of __hasReachedEOF.\n        synchronized (__queue) {\n\n            while (true) {\n                if (__ioException != null) {\n                    IOException e;\n                    e = __ioException;\n                    __ioException = null;\n                    throw e;\n                }\n\n                if (__bytesAvailable == 0) {\n                    // Return EOF if at end of file\n                    if (__hasReachedEOF) {\n                        return EOF;\n                    }\n\n                    // Otherwise, we have to wait for queue to get something\n                    if (__threaded) {\n                        __queue.notify();\n                        try {\n                            __readIsWaiting = true;\n                            __queue.wait();\n                            __readIsWaiting = false;\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                        }\n                    } else {\n                        //__alreadyread = false;\n                        __readIsWaiting = true;\n                        int ch;\n                        boolean mayBlock = true;    // block on the first read only\n\n                        do {\n                            try {\n                                if ((ch = __read(mayBlock)) < 0) { // must be EOF\n                                    if (ch != WOULD_BLOCK) {\n                                        return (ch);\n                                    }\n                                }\n                            } catch (InterruptedIOException e) {\n                                synchronized (__queue) {\n                                    __ioException = e;\n                                    __queue.notifyAll();\n                                    try {\n                                        __queue.wait(100);\n                                    } catch (InterruptedException interrupted) {\n                                        // Ignored\n                                    }\n                                }\n                                return EOF;\n                            }\n\n                            try {\n                                if (ch != WOULD_BLOCK) {\n                                    __processChar(ch);\n                                }\n                            } catch (InterruptedException e) {\n                                if (__isClosed) {\n                                    return EOF;\n                                }\n                            }\n\n                            // Reads should not block on subsequent iterations. Potentially, this could happen if the\n                            // remaining buffered socket data consists entirely of Telnet command sequence and no \"user\" data.\n                            mayBlock = false;\n\n                        }\n                        // Continue reading as long as there is data available and the queue is not full.\n                        while (super.available() > 0 && __bytesAvailable < __queue.length - 1);\n\n                        __readIsWaiting = false;\n                    }\n                    continue;\n                } else {\n                    int ch;\n\n                    ch = __queue[__queueHead];\n\n                    if (++__queueHead >= __queue.length) {\n                        __queueHead = 0;\n                    }\n\n                    --__bytesAvailable;\n\n                    // Need to explicitly notify() so available() works properly\n                    if (__bytesAvailable == 0 && __threaded) {\n                        __queue.notify();\n                    }\n\n                    return ch;\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "57", "src_id": "M786", "code": "\n    @Override\n    public void process(CommandProcess process) {\n\n        initTransformer();\n\n        RetransformModel retransformModel = new RetransformModel();\n        Instrumentation inst = process.session().getInstrumentation();\n\n        if (this.list) {\n            List<RetransformEntry> retransformEntryList = allRetransformEntries();\n            retransformModel.setRetransformEntries(retransformEntryList);\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.deleteAll) {\n            deleteAllRetransformEntry();\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.delete > 0) {\n            deleteRetransformEntry(this.delete);\n            process.end();\n            return;\n        } else if (this.classPattern != null) {\n            Set<Class<?>> searchClass = SearchUtils.searchClass(inst, classPattern, false, this.hashCode);\n            if (searchClass.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + classPattern);\n                return;\n            }\n\n            if (searchClass.size() > limit) {\n                process.end(-1, \"match classes size: \" + searchClass.size() + \", more than limit: \" + limit\n                        + \", It is recommended to use a more precise class pattern.\");\n            }\n            try {\n                inst.retransformClasses(searchClass.toArray(new Class[0]));\n                for (Class<?> clazz : searchClass) {\n                    retransformModel.addRetransformClass(clazz.getName());\n                }\n                process.appendResult(retransformModel);\n                process.end();\n                return;\n            } catch (Throwable e) {\n                String message = \"retransform error! \" + e.toString();\n                logger.error(message, e);\n                process.end(-1, message);\n                return;\n            }\n        }\n\n        for (String path : paths) {\n            File file = new File(path);\n            if (!file.exists()) {\n                process.end(-1, \"file does not exist, path:\" + path);\n                return;\n            }\n            if (!file.isFile()) {\n                process.end(-1, \"not a normal file, path:\" + path);\n                return;\n            }\n            if (file.length() >= MAX_FILE_SIZE) {\n                process.end(-1, \"file size: \" + file.length() + \" >= \" + MAX_FILE_SIZE + \", path: \" + path);\n                return;\n            }\n        }\n\n        Map<String, byte[]> bytesMap = new HashMap<String, byte[]>();\n        for (String path : paths) {\n            RandomAccessFile f = null;\n            try {\n                f = new RandomAccessFile(path, \"r\");\n                final byte[] bytes = new byte[(int) f.length()];\n                f.readFully(bytes);\n\n                final String clazzName = readClassName(bytes);\n\n                bytesMap.put(clazzName, bytes);\n\n            } catch (Exception e) {\n                logger.warn(\"load class file failed: \" + path, e);\n                process.end(-1, \"load class file failed: \" + path + \", error: \" + e);\n                return;\n            } finally {\n                if (f != null) {\n                    try {\n                        f.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        }\n\n        if (bytesMap.size() != paths.size()) {\n            process.end(-1, \"paths may contains same class name!\");\n            return;\n        }\n\n        List<RetransformEntry> retransformEntryList = new ArrayList<RetransformEntry>();\n\n        List<Class<?>> classList = new ArrayList<Class<?>>();\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (bytesMap.containsKey(clazz.getName())) {\n\n                if (hashCode == null && classLoaderClass != null) {\n                    List<ClassLoader> matchedClassLoaders = ClassLoaderUtils.getClassLoaderByClassName(inst,\n                            classLoaderClass);\n                    if (matchedClassLoaders.size() == 1) {\n                        hashCode = Integer.toHexString(matchedClassLoaders.get(0).hashCode());\n                    } else if (matchedClassLoaders.size() > 1) {\n                        Collection<ClassLoaderVO> classLoaderVOList = ClassUtils\n                                .createClassLoaderVOList(matchedClassLoaders);\n                        retransformModel.setClassLoaderClass(classLoaderClass)\n                                .setMatchedClassLoaders(classLoaderVOList);\n                        process.appendResult(retransformModel);\n                        process.end(-1,\n                                \"Found more than one classloader by class name, please specify classloader with '-c <classloader hash>'\");\n                        return;\n                    } else {\n                        process.end(-1, \"Can not find classloader by class name: \" + classLoaderClass + \".\");\n                        return;\n                    }\n                }\n\n                ClassLoader classLoader = clazz.getClassLoader();\n                if (classLoader != null && hashCode != null\n                        && !Integer.toHexString(classLoader.hashCode()).equals(hashCode)) {\n                    continue;\n                }\n\n                RetransformEntry retransformEntry = new RetransformEntry(clazz.getName(), bytesMap.get(clazz.getName()),\n                        hashCode, classLoaderClass);\n                retransformEntryList.add(retransformEntry);\n                classList.add(clazz);\n                retransformModel.addRetransformClass(clazz.getName());\n\n                logger.info(\"Try retransform class name: {}, ClassLoader: {}\", clazz.getName(), clazz.getClassLoader());\n            }\n        }\n\n        try {\n            if (retransformEntryList.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + bytesMap.keySet());\n                return;\n            }\n            addRetransformEntry(retransformEntryList);\n\n            inst.retransformClasses(classList.toArray(new Class[0]));\n\n            process.appendResult(retransformModel);\n            process.end();\n        } catch (Throwable e) {\n            String message = \"retransform error! \" + e.toString();\n            logger.error(message, e);\n            process.end(-1, message);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "58", "src_id": "M278", "code": "\n    V get(Object key, int hash) {\n        if (count != 0) { // read-volatile\n            HashEntry<K, V> e = getFirst(hash);\n            while (e != null) {\n                if (e.hash == hash && keyEq(key, e.key())) {\n                    Object opaque = e.valueRef;\n                    if (opaque != null) {\n                        return e.dereferenceValue(opaque);\n                    }\n\n                    return readValueUnderLock(e); // recheck\n                }\n                e = e.next;\n            }\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "59", "src_id": "M184", "code": "\n    @Override\n    protected void initChannel(LocalChannel ch) {\n        ChannelPipeline p = ch.pipeline();\n        p.addLast(new HttpClientCodec(),\n                  new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                  new HttpProxyClientHandler(httpResponsePromise));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "60", "src_id": "M1751", "code": "\n    @Override\n    public void onNext(GrpcRequest<ArthasUnittest.ArthasUnittestRequest> req) {\n        try {\n            byte[] bytes = req.readData();\n            while (bytes != null && bytes.length != 0) {\n                ArthasUnittest.ArthasUnittestRequest request = ArthasUnittest.ArthasUnittestRequest.parseFrom(bytes);\n                sum.addAndGet(request.getNum());\n                bytes = req.readData();\n            }\n        } catch (InvalidProtocolBufferException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "61", "src_id": "M1772", "code": "\n    public void writeResponseData(Object response) {\n        byte[] encode = null;\n        try {\n            if (ArthasGrpc.ErrorRes.class.equals(clazz)) {\n                encode = ((ArthasGrpc.ErrorRes) response).toByteArray();\n            } else {\n                encode = (byte[]) GrpcDispatcher.responseToByteArrayMap\n                        .get(GrpcDispatcher.generateGrpcMethodKey(service, method))\n                        .invoke(response);\n            }\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n        this.byteData = ByteUtil.newByteBuf();\n        this.byteData.writeBoolean(false);\n        this.byteData.writeInt(encode.length);\n        this.byteData.writeBytes(encode);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "62", "src_id": "M1766", "code": "\n    private void handleResetStream(Http2ResetFrame resetFrame, ChannelHandlerContext ctx) {\n        int id = resetFrame.stream().id();\n        System.out.println(\"handleResetStream\");\n        dataBuffer.remove(id);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "63", "src_id": "M1769", "code": "\n    public synchronized byte[] readData() {\n        if (byteData.readableBytes() == 0) {\n            return null;\n        }\n        boolean compressed = byteData.readBoolean();\n        int length = byteData.readInt();\n        byte[] bytes = new byte[length];\n        byteData.readBytes(bytes);\n        return bytes;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "64", "src_id": "M1784", "code": "\n    @Override\n    public void initChannel(SocketChannel ch) {\n        ch.pipeline().addLast(Http2FrameCodecBuilder.forServer().build());\n        ch.pipeline().addLast(new Http2Handler(grpcDispatcher, grpcExecutorFactory));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "65", "src_id": "M1752", "code": "\n    @Override\n    public void onCompleted() {\n        ArthasUnittest.ArthasUnittestResponse response = ArthasUnittest.ArthasUnittestResponse.newBuilder()\n                .setNum(sum.get())\n                .build();\n        GrpcResponse<ArthasUnittest.ArthasUnittestResponse> grpcResponse = new GrpcResponse<>();\n        grpcResponse.setService(\"arthas.grpc.unittest.ArthasUnittestService\");\n        grpcResponse.setMethod(\"clientStreamSum\");\n        grpcResponse.writeResponseData(response);\n        observer.onNext(grpcResponse);\n        observer.onCompleted();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "66", "src_id": "M1768", "code": "\n    public void writeData(ByteBuf byteBuf) {\n        byte[] bytes = ByteUtil.getBytes(byteBuf);\n        if (bytes.length == 0) {\n            return;\n        }\n        byte[] decompressedData = decompressGzip(bytes);\n        if (decompressedData == null) {\n            return;\n        }\n        byteData.writeBytes(ByteUtil.newByteBuf(decompressedData));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "67", "src_id": "M1756", "code": "\n    public void loadGrpcService(String grpcServicePackageName) {\n        List<Class<?>> classes = ReflectUtil.findClasses(\n                Optional.ofNullable(grpcServicePackageName)\n                        .orElse(DEFAULT_GRPC_SERVICE_PACKAGE_NAME)\n        );\n        for (Class<?> clazz : classes) {\n            if (clazz.isAnnotationPresent(GrpcService.class)) {\n                try {\n                    // 处理 service\n                    GrpcService grpcService = clazz.getAnnotation(GrpcService.class);\n                    Object instance = clazz.getDeclaredConstructor().newInstance();\n                    // 处理 method\n                    MethodHandles.Lookup lookup = MethodHandles.lookup();\n                    Method[] declaredMethods = clazz.getDeclaredMethods();\n                    for (Method method : declaredMethods) {\n                        if (method.isAnnotationPresent(GrpcMethod.class)) {\n                            GrpcMethod grpcMethod = method.getAnnotation(GrpcMethod.class);\n                            MethodHandle grpcInvoke = lookup.unreflect(method);\n                            String grpcMethodKey = generateGrpcMethodKey(grpcService.value(), grpcMethod.value());\n                            grpcInvokeTypeMap.put(grpcMethodKey, grpcMethod.grpcType());\n                            grpcInvokeMap.put(grpcMethodKey, grpcInvoke.bindTo(instance));\n\n                            Class<?> requestClass = null;\n                            Class<?> responseClass = null;\n                            if (GrpcInvokeTypeEnum.UNARY.equals(grpcMethod.grpcType())) {\n                                requestClass = grpcInvoke.type().parameterType(1);\n                                responseClass = grpcInvoke.type().returnType();\n                            } else if (GrpcInvokeTypeEnum.CLIENT_STREAM.equals(grpcMethod.grpcType())\n                                    || GrpcInvokeTypeEnum.BI_STREAM.equals(grpcMethod.grpcType())) {\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                requestClass = getInnerGenericClass(method.getGenericReturnType());\n                            } else if (GrpcInvokeTypeEnum.SERVER_STREAM.equals(grpcMethod.grpcType())) {\n                                requestClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[1]);\n                            }\n                            MethodHandle requestParseFrom = lookup.findStatic(\n                                    requestClass, \"parseFrom\", MethodType.methodType(requestClass, byte[].class));\n                            MethodHandle responseParseFrom = lookup.findStatic(\n                                    responseClass, \"parseFrom\", MethodType.methodType(responseClass, byte[].class));\n                            MethodHandle requestToByteArray = lookup.findVirtual(\n                                    requestClass, \"toByteArray\", MethodType.methodType(byte[].class));\n                            MethodHandle responseToByteArray = lookup.findVirtual(\n                                    responseClass, \"toByteArray\", MethodType.methodType(byte[].class));\n                            requestParseFromMap.put(grpcMethodKey, requestParseFrom);\n                            responseParseFromMap.put(grpcMethodKey, responseParseFrom);\n                            requestToByteArrayMap.put(grpcMethodKey, requestToByteArray);\n                            responseToByteArrayMap.put(grpcMethodKey, responseToByteArray);\n\n                            //                            switch (grpcMethod.grpcType()) {\n                            //                                case UNARY:\n                            //                                    unaryInvokeMap.put(grpcMethodKey, grpcInvoke.bindTo(instance));\n                            //                                    return;\n                            //                                case CLIENT_STREAM:\n                            //                                    Object invoke = grpcInvoke.bindTo(instance).invoke();\n                            //                                    if (!(invoke instanceof StreamObserver)) {\n                            //                                        throw new RuntimeException(grpcMethodKey + \" return class is not StreamObserver!\");\n                            //                                    }\n                            //                                    clientStreamInvokeMap.put(grpcMethodKey, (StreamObserver) invoke);\n                            //                                    return;\n                            //                                case SERVER_STREAM:\n                            //                                    return;\n                            //                                case BI_STREAM:\n                            //                                    return;\n                            //                            }\n                        }\n                    }\n                } catch (Throwable e) {\n                    logger.error(\"GrpcDispatcher loadGrpcService error.\", e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "68", "src_id": "M308", "code": "\n    HashEntry<K, V> nextEntry() {\n        do {\n            if (nextEntry == null) {\n                throw new NoSuchElementException();\n            }\n\n            lastReturned = nextEntry;\n            currentKey = lastReturned.key();\n            advance();\n        } while (currentKey == null); // Skip GC'd keys\n\n        return lastReturned;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "69", "src_id": "M1284", "code": "\n    @AtInvoke(name = \"\", inline = true, whenComplete = false, excludes = \"java.**\")\n    public static void onInvoke(@Binding.This Object target, @Binding.Class Class<?> clazz,\n                                @Binding.InvokeInfo String invokeInfo) {\n        SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "70", "src_id": "M947", "code": "\n    public void loggers(CommandProcess process) {\n        Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<ClassLoader, LoggerTypes>();\n\n        // 如果不指定 classloader，则打印所有 classloader 里的 logger 信息\n        for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n            String className = clazz.getName();\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            // if special classloader\n            if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) {\n                continue;\n            }\n\n            if (classLoader != null) {\n                LoggerTypes loggerTypes = classLoaderLoggerMap.get(classLoader);\n                if (loggerTypes == null) {\n                    loggerTypes = new LoggerTypes();\n                    classLoaderLoggerMap.put(classLoader, loggerTypes);\n                }\n                updateLoggerType(loggerTypes, classLoader, className);\n            }\n        }\n\n        for (Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n            ClassLoader classLoader = entry.getKey();\n            LoggerTypes loggerTypes = entry.getValue();\n\n            if (loggerTypes.contains(LoggerType.LOG4J)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4jHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n\n            if (loggerTypes.contains(LoggerType.LOGBACK)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, LogbackHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n\n            if (loggerTypes.contains(LoggerType.LOG4J2)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4j2Helper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n        }\n\n        process.end();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "71", "src_id": "M249", "code": "\n    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) throws URISyntaxException {\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n\n        String appName = null;\n        List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n        if (appNameList != null && !appNameList.isEmpty()) {\n            appName = appNameList.get(0);\n        }\n\n        // generate a random agent id\n        String id = null;\n        if (appName != null) {\n            // 如果有传 app name，则生成带 app name前缀的id，方便管理\n            id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n        } else {\n            id = RandomStringUtils.random(20, true, true).toUpperCase();\n        }\n        // agent传过来，则优先用 agent的\n        List<String> idList = parameters.get(URIConstans.ID);\n        if (idList != null && !idList.isEmpty()) {\n            id = idList.get(0);\n        }\n\n        String arthasVersion = null;\n        List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n        if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n            arthasVersion = arthasVersionList.get(0);\n        }\n\n        final String finalId = id;\n\n        // URI responseUri = new URI(\"response\", null, \"/\", \"method=\" + MethodConstants.AGENT_REGISTER + \"&id=\" + id, null);\n        URI responseUri = UriComponentsBuilder.newInstance()\n                .scheme(URIConstans.RESPONSE)\n                .path(\"/\")\n                .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n                .queryParam(URIConstans.ID, id)\n                .build()\n                .encode()\n                .toUri();\n\n        AgentInfo info = new AgentInfo();\n\n        // 前面可能有nginx代理\n        HttpHeaders headers = handshake.requestHeaders();\n        String host = HttpUtils.findClientIP(headers);\n\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n                info.setHost(inetSocketAddress.getHostString());\n                info.setPort(inetSocketAddress.getPort());\n            }\n        } else {\n            info.setHost(host);\n            Integer port = HttpUtils.findClientPort(headers);\n            if (port != null) {\n                info.setPort(port);\n            }\n        }\n\n        info.setChannelHandlerContext(ctx);\n        if (arthasVersion != null) {\n            info.setArthasVersion(arthasVersion);\n        }\n\n        tunnelServer.addAgent(id, info);\n        ctx.channel().closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {\n            @Override\n            public void operationComplete(Future<? super Void> future) throws Exception {\n                tunnelServer.removeAgent(finalId);\n            }\n        });\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "72", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect) throws SSLException, URISyntaxException, InterruptedException {\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER);\n        queryEncoder.addParam(URIConstans.ARTHAS_VERSION, this.version);\n        if (appName != null) {\n            queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        }\n        if (id != null) {\n            queryEncoder.addParam(URIConstans.ID, id);\n        }\n        // ws://127.0.0.1:7777/ws?method=agentRegister\n        final URI agentRegisterURI = queryEncoder.toUri();\n\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = agentRegisterURI.getScheme() == null ? \"ws\" : agentRegisterURI.getScheme();\n        final String host = agentRegisterURI.getHost() == null ? \"127.0.0.1\" : agentRegisterURI.getHost();\n        final int port;\n        if (agentRegisterURI.getPort() == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else if (\"wss\".equalsIgnoreCase(scheme)) {\n                port = 443;\n            } else {\n                port = -1;\n            }\n        } else {\n            port = agentRegisterURI.getPort();\n        }\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n        }\n\n        final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n        final SslContext sslCtx;\n        if (ssl) {\n            sslCtx = SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        WebSocketClientProtocolConfig clientProtocolConfig = WebSocketClientProtocolConfig.newBuilder()\n                .webSocketUri(agentRegisterURI)\n                .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH)\n                .build();\n\n        final WebSocketClientProtocolHandler websocketClientHandler =\n                new WebSocketClientProtocolHandler(clientProtocolConfig);\n        final TunnelClientSocketClientHandler handler = new TunnelClientSocketClientHandler(TunnelClient.this);\n\n        Bootstrap bs = new Bootstrap();\n\n        bs.group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(host, port)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        p.addLast(new HttpClientCodec(),\n                                new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                                websocketClientHandler,\n                                new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                                handler);\n                    }\n                });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.cause() != null) {\n                        logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n                    }\n                }\n            });\n        }\n        connectFuture.sync();\n\n        return handler.registerFuture();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "73", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[] {\n                0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65,\n                0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x6d, 0x69, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74,\n                0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74,\n                0x20, 0x6c, 0x65, 0x74, 0x20, 0x6d, 0x79, 0x73, 0x65, 0x6c, 0x66, 0x0a, 0x43, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6d,\n                0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x73, 0x6f, 0x20, 0x6d, 0x75, 0x63, 0x68, 0x20, 0x6d, 0x69, 0x73,\n                0x65, 0x72, 0x79, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61,\n                0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x61, 0x79, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x59,\n                0x6f, 0x75, 0x20, 0x66, 0x65, 0x6c, 0x6c, 0x20, 0x73, 0x6f, 0x20, 0x68, 0x61, 0x72, 0x64, 0x0a, 0x0a, 0x49, 0x20,\n                0x76, 0x65, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x72, 0x64,\n                0x20, 0x77, 0x61, 0x79, 0x0a, 0x54, 0x6f, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x69,\n                0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x61, 0x72, 0x0a, 0x0a, 0x42, 0x65, 0x63,\n                0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72,\n                0x20, 0x73, 0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d,\n                0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75,\n                0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64,\n                0x20, 0x74, 0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66,\n                0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67,\n                0x65, 0x74, 0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20,\n                0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20,\n                0x74, 0x6f, 0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d,\n                0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f,\n                0x75, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n                0x6f, 0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x6c,\n                0x6f, 0x73, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x77, 0x61, 0x79, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x73,\n                0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72,\n                0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x74, 0x20, 0x6f, 0x75, 0x74, 0x0a,\n                0x49, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x72, 0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n                0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x20, 0x77,\n                0x65, 0x61, 0x6b, 0x6e, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x65, 0x79, 0x65,\n                0x73, 0x0a, 0x49, 0x20, 0x6d, 0x20, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6b,\n                0x65, 0x0a, 0x41, 0x20, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x2c, 0x20, 0x61, 0x20, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x20,\n                0x65, 0x76, 0x65, 0x72, 0x79, 0x64, 0x61, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66, 0x65,\n                0x0a, 0x4d, 0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x27, 0x74, 0x20, 0x70, 0x6f, 0x73,\n                0x73, 0x69, 0x62, 0x6c, 0x79, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x0a, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74,\n                0x20, 0x77, 0x61, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x77, 0x68, 0x6f, 0x6c, 0x65, 0x20,\n                0x74, 0x6f, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61,\n                0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20,\n                0x73, 0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20,\n                0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n                0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20,\n                0x74, 0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65,\n                0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65,\n                0x74, 0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n                0x6f, 0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74,\n                0x6f, 0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d, 0x65,\n                0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f, 0x75,\n                0x6e, 0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f,\n                0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x77, 0x61,\n                0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x65, 0x0a, 0x49, 0x20, 0x68, 0x65, 0x61,\n                0x72, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x72, 0x79, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6e, 0x69,\n                0x67, 0x68, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x0a, 0x49,\n                0x20, 0x77, 0x61, 0x73, 0x20, 0x73, 0x6f, 0x20, 0x79, 0x6f, 0x75, 0x6e, 0x67, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x73,\n                0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x62, 0x65,\n                0x74, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x65, 0x61, 0x6e, 0x20, 0x6f,\n                0x6e, 0x20, 0x6d, 0x65, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x6f, 0x75,\n                0x67, 0x68, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a,\n                0x59, 0x6f, 0x75, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x73, 0x61, 0x77, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x70, 0x61,\n                0x69, 0x6e, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x77, 0x20, 0x49, 0x20, 0x63, 0x72, 0x79, 0x20, 0x69, 0x6e,\n                0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,\n                0x6e, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x46, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20,\n                0x64, 0x61, 0x6d, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,\n                0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72,\n                0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65,\n                0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f,\n                0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,\n                0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65, 0x20, 0x73, 0x69,\n                0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x68,\n                0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a,\n                0x49, 0x20, 0x74, 0x72, 0x79, 0x20, 0x6d, 0x79, 0x20, 0x68, 0x61, 0x72, 0x64, 0x65, 0x73, 0x74, 0x20, 0x6a, 0x75,\n                0x73, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x6f, 0x72, 0x67, 0x65, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74,\n                0x68, 0x69, 0x6e, 0x67, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75,\n                0x0a, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74,\n                0x6f, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x20, 0x69,\n                0x6e, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20,\n                0x6d, 0x20, 0x61, 0x73, 0x68, 0x61, 0x6d, 0x65, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66,\n                0x65, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x73, 0x20, 0x65, 0x6d, 0x70, 0x74,\n                0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20,\n                0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20,\n                0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n                0x6f, 0x75, 0x0a, 0x2e, 0x2e, 0x2e, 0x0a, /*0x0a, 0x66, 0x6f, 0x72, 0x20, 0x6a, 0x75, 0x6c, 0x79, 0x0a, 0x0a,*/\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "74", "src_id": "M124", "code": "\n    @Override\n    public int read() throws IOException {\n        // Critical section because we're altering __bytesAvailable,\n        // __queueHead, and the contents of _queue in addition to\n        // testing value of __hasReachedEOF.\n        synchronized (__queue) {\n            while (true) {\n                if (__ioException != null) {\n                    IOException e;\n                    e = __ioException;\n                    __ioException = null;\n                    throw e;\n                }\n\n                if (__bytesAvailable == 0) {\n                    // Return EOF if at end of file\n                    if (__hasReachedEOF) {\n                        return EOF;\n                    }\n\n                    // Otherwise, we have to wait for queue to get something\n                    if (__threaded) {\n                        __queue.notify();\n                        try {\n                            __readIsWaiting = true;\n                            __queue.wait();\n                            __readIsWaiting = false;\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                        }\n                    } else {\n                        //__alreadyread = false;\n                        __readIsWaiting = true;\n                        int ch;\n                        boolean mayBlock = true; // block on the first read only\n\n                        do {\n                            try {\n                                if ((ch = __read(mayBlock)) < 0) { // must be EOF\n                                    if (ch != WOULD_BLOCK) {\n                                        return (ch);\n                                    }\n                                }\n                            } catch (InterruptedIOException e) {\n                                synchronized (__queue) {\n                                    __ioException = e;\n                                    __queue.notifyAll();\n                                    try {\n                                        __queue.wait(100);\n                                    } catch (InterruptedException interrupted) {\n                                        // Ignored\n                                    }\n                                }\n                                return EOF;\n                            }\n\n                            try {\n                                if (ch != WOULD_BLOCK) {\n                                    __processChar(ch);\n                                }\n                            } catch (InterruptedException e) {\n                                if (__isClosed) {\n                                    return EOF;\n                                }\n                            }\n\n                            // Reads should not block on subsequent iterations. Potentially, this could happen if the\n                            // remaining buffered socket data consists entirely of Telnet command sequence and no \"user\" data.\n                            mayBlock = false;\n\n                        }\n                        // Continue reading as long as there is data available and the queue is not full.\n                        while (super.available() > 0 && __bytesAvailable < __queue.length - 1);\n\n                        __readIsWaiting = false;\n                    }\n                    continue;\n                } else {\n                    int ch;\n\n                    ch = __queue[__queueHead];\n\n                    if (++__queueHead >= __queue.length) {\n                        __queueHead = 0;\n                    }\n\n                    --__bytesAvailable;\n\n                    // Need to explicitly notify() so available() works properly\n                    if (__bytesAvailable == 0 && __threaded) {\n                        __queue.notify();\n                    }\n\n                    return ch;\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "75", "src_id": "M786", "code": "\n    @Override\n    public void process(CommandProcess process) {\n        initTransformer();\n\n        RetransformModel retransformModel = new RetransformModel();\n        Instrumentation inst = process.session().getInstrumentation();\n\n        if (this.list) {\n            List<RetransformEntry> retransformEntryList = allRetransformEntries();\n            retransformModel.setRetransformEntries(retransformEntryList);\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.deleteAll) {\n            deleteAllRetransformEntry();\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.delete > 0) {\n            deleteRetransformEntry(this.delete);\n            process.end();\n            return;\n        } else if (this.classPattern != null) {\n            Set<Class<?>> searchClass = SearchUtils.searchClass(inst, classPattern, false, this.hashCode);\n            if (searchClass.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + classPattern);\n                return;\n            }\n\n            if (searchClass.size() > limit) {\n                process.end(-1, \"match classes size: \" + searchClass.size() + \", more than limit: \" + limit\n                        + \", It is recommended to use a more precise class pattern.\");\n            }\n            try {\n                inst.retransformClasses(searchClass.toArray(new Class[0]));\n                for (Class<?> clazz : searchClass) {\n                    retransformModel.addRetransformClass(clazz.getName());\n                }\n                process.appendResult(retransformModel);\n                process.end();\n                return;\n            } catch (Throwable e) {\n                String message = \"retransform error! \" + e.toString();\n                logger.error(message, e);\n                process.end(-1, message);\n                return;\n            }\n        }\n\n        for (String path : paths) {\n            File file = new File(path);\n            if (!file.exists()) {\n                process.end(-1, \"file does not exist, path:\" + path);\n                return;\n            }\n            if (!file.isFile()) {\n                process.end(-1, \"not a normal file, path:\" + path);\n                return;\n            }\n            if (file.length() >= MAX_FILE_SIZE) {\n                process.end(-1, \"file size: \" + file.length() + \" >= \" + MAX_FILE_SIZE + \", path: \" + path);\n                return;\n            }\n        }\n\n        Map<String, byte[]> bytesMap = new HashMap<String, byte[]>();\n        for (String path : paths) {\n            RandomAccessFile f = null;\n            try {\n                f = new RandomAccessFile(path, \"r\");\n                final byte[] bytes = new byte[(int) f.length()];\n                f.readFully(bytes);\n\n                final String clazzName = readClassName(bytes);\n\n                bytesMap.put(clazzName, bytes);\n\n            } catch (Exception e) {\n                logger.warn(\"load class file failed: \" + path, e);\n                process.end(-1, \"load class file failed: \" + path + \", error: \" + e);\n                return;\n            } finally {\n                if (f != null) {\n                    try {\n                        f.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        }\n\n        if (bytesMap.size() != paths.size()) {\n            process.end(-1, \"paths may contains same class name!\");\n            return;\n        }\n\n        List<RetransformEntry> retransformEntryList = new ArrayList<RetransformEntry>();\n        List<Class<?>> classList = new ArrayList<Class<?>>();\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (bytesMap.containsKey(clazz.getName())) {\n\n                if (hashCode == null && classLoaderClass != null) {\n                    List<ClassLoader> matchedClassLoaders = ClassLoaderUtils.getClassLoaderByClassName(inst, classLoaderClass);\n                    if (matchedClassLoaders.size() == 1) {\n                        hashCode = Integer.toHexString(matchedClassLoaders.get(0).hashCode());\n                    } else if (matchedClassLoaders.size() > 1) {\n                        Collection<ClassLoaderVO> classLoaderVOList = ClassUtils.createClassLoaderVOList(matchedClassLoaders);\n                        retransformModel.setClassLoaderClass(classLoaderClass)\n                                .setMatchedClassLoaders(classLoaderVOList);\n                        process.appendResult(retransformModel);\n                        process.end(-1,\n                                \"Found more than one classloader by class name, please specify classloader with '-c <classloader hash>'\");\n                        return;\n                    } else {\n                        process.end(-1, \"Can not find classloader by class name: \" + classLoaderClass + \".\");\n                        return;\n                    }\n                }\n\n                ClassLoader classLoader = clazz.getClassLoader();\n                if (classLoader != null && hashCode != null\n                        && !Integer.toHexString(classLoader.hashCode()).equals(hashCode)) {\n                    continue;\n                }\n\n                RetransformEntry retransformEntry = new RetransformEntry(clazz.getName(), bytesMap.get(clazz.getName()), hashCode, classLoaderClass);\n                retransformEntryList.add(retransformEntry);\n                classList.add(clazz);\n                retransformModel.addRetransformClass(clazz.getName());\n\n                logger.info(\"Try retransform class name: {}, ClassLoader: {}\", clazz.getName(), clazz.getClassLoader());\n            }\n        }\n\n        try {\n            if (retransformEntryList.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + bytesMap.keySet());\n                return;\n            }\n            addRetransformEntry(retransformEntryList);\n\n            inst.retransformClasses(classList.toArray(new Class[0]));\n\n            process.appendResult(retransformModel);\n            process.end();\n        } catch (Throwable e) {\n            String message = \"retransform error! \" + e.toString();\n            logger.error(message, e);\n            process.end(-1, message);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "76", "src_id": "M278", "code": "\n    V get(Object key, int hash) {\n        if (count != 0) { // read-volatile\n            HashEntry<K, V> e = getFirst(hash);\n            while (e != null) {\n                if (e.hash == hash && keyEq(key, e.key())) {\n                    Object opaque = e.valueRef;\n                    if (opaque != null) {\n                        return e.dereferenceValue(opaque);\n                    }\n\n                    return readValueUnderLock(e); // recheck\n                }\n                e = e.next;\n            }\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "77", "src_id": "M184", "code": "\n    @Override\n    protected void initChannel(LocalChannel ch) {\n        ChannelPipeline p = ch.pipeline();\n        p.addLast(new HttpClientCodec(),\n                new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                new HttpProxyClientHandler(httpResponsePromise));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "78", "src_id": "M1671", "code": "\n    public void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n        if (frame instanceof CloseWebSocketFrame) {\n            closeOutboundChannel(ctx.channel());\n            ctx.close();\n            return;\n        }\n\n        Channel outboundChannel = channelMappings.get(ctx.channel());\n        if (outboundChannel == null || !outboundChannel.isActive()) {\n            connectToDestinationServer(ctx, frame);\n        } else {\n            forwardWebSocketFrame(frame, outboundChannel);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "79", "src_id": "M1691", "code": "\n        @Override\n        public void onError(Throwable t) {\n            logger.error(\"keep alive error: \" + t.getMessage());\n            t.printStackTrace();\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "80", "src_id": "M1656", "code": "\n    @Override\n    public Map<String, String> findNativeAgent(String address) {\n        if (address == null || \"\".equals(address)) {\n            return null;\n        }\n\n        try {\n            ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n                if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                    connectedSemaphore.countDown();\n                }\n            });\n            connectedSemaphore.await();\n\n            List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n\n            Map<String, String> res = new ConcurrentHashMap<String, String>(children.size());\n            for (String child : children) {\n                String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n                byte[] data = zooKeeper.getData(childPath, false, new Stat());\n                String dataStr = new String(data);\n\n                res.put(child, dataStr);\n            }\n\n            zooKeeper.close();\n            return res;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "81", "src_id": "M1668", "code": "\n    private FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n        OkHttpClient client = new OkHttpClient.Builder()\n                        .connectTimeout(10, TimeUnit.SECONDS)\n                        .readTimeout(30, TimeUnit.SECONDS)\n                        .writeTimeout(30, TimeUnit.SECONDS)\n                        .build();\n\n        String url = \"http://\" + address + \"/api/native-agent\";\n\n        RequestBody requestBody = RequestBody.create(\n                        request.content().toString(CharsetUtil.UTF_8),\n                        MediaType.parse(\"application/json; charset=utf-8\")\n        );\n\n        Request okRequest = new Request.Builder()\n                        .url(url)\n                        .post(requestBody)\n                        .build();\n\n        try {\n            Response response = client.newCall(okRequest).execute();\n\n            if (response.isSuccessful()) {\n                String responseBody = response.body().string();\n                DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(\n                                request.getProtocolVersion(),\n                                HttpResponseStatus.OK,\n                                Unpooled.copiedBuffer(responseBody, StandardCharsets.UTF_8)\n                );\n                // 设置跨域响应头\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\");\n\n                // 设置其他必要的头部\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, fullHttpResponse.content().readableBytes());\n                return fullHttpResponse;\n            } else {\n                return new DefaultFullHttpResponse(\n                                HttpVersion.HTTP_1_1,\n                                HttpResponseStatus.valueOf(response.code()),\n                                Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n                );\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new DefaultFullHttpResponse(\n                            HttpVersion.HTTP_1_1,\n                            HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                            Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n            );\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "82", "src_id": "M1714", "code": "\n    public static void main(String[] args) {\n        // Print welcome info\n        WelcomeUtil.printNativeAgentWelcomeMsg();\n\n        // Check And Find arthas path\n        logger.info(\"check arthas file path...\");\n        ArthasHomeHandler.findArthasHome();\n        logger.info(\"check arthas file path success\");\n\n        // Read bootstrap config\n        logger.info(\"read input config...\");\n        NativeAgentBootstrap nativeAgentBootstrap = new NativeAgentBootstrap();\n        CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n        CommandLine commandLine = cli.parse(Arrays.asList(args));\n        try {\n            CLIConfigurator.inject(commandLine, nativeAgentBootstrap);\n        } catch (Throwable e) {\n            logger.error(\"Missing startup parameter\");\n            e.printStackTrace();\n            System.out.println(usage(cli));\n            System.exit(1);\n        }\n        logger.info(\"read input config success\");\n\n        // Register native agent\n        try {\n            logger.info(\"register native agent ...\");\n            NativeAgentRegistryFactory nativeAgentRegistryFactory = NativeAgentRegistryFactory.getNativeAgentClientRegisterFactory();\n            NativeAgentRegistry nativeAgentRegistry = nativeAgentRegistryFactory.getServiceRegistration(nativeAgentBootstrap.getRegistrationType());\n            nativeAgentRegistry.registerNativeAgent(nativeAgentBootstrap.getRegistrationAddress(),\n                            nativeAgentBootstrap.getIp(),\n                            nativeAgentBootstrap.getHttpPortOrDefault() + \":\" + nativeAgentBootstrap.getWsPortOrDefault());\n            logger.info(\"register native agent success!\");\n        } catch (Exception e) {\n            logger.error(\"register native agent failed!\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n\n        // Start the websocket server\n        final int wsPortOrDefault = nativeAgentBootstrap.getWsPortOrDefault();\n        Thread wsServerThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                logger.info(\"start the websocket server... ws port:\" + wsPortOrDefault);\n                try {\n                    EventLoopGroup bossGroup = new NioEventLoopGroup();\n                    EventLoopGroup workerGroup = new NioEventLoopGroup();\n                    try {\n                        ServerBootstrap b = new ServerBootstrap();\n                        b.group(bossGroup, workerGroup)\n                                        .channel(NioServerSocketChannel.class)\n                                        .handler(new LoggingHandler(LogLevel.INFO))\n                                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                                            @Override\n                                            protected void initChannel(SocketChannel ch) {\n                                                ChannelPipeline p = ch.pipeline();\n                                                p.addLast(new HttpRequestDecoder());\n                                                p.addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                                                p.addLast(new HttpResponseEncoder());\n                                                p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                                                p.addLast(new ForwardClientSocketClientHandler());\n                                            }\n                                        });\n                        ChannelFuture f = b.bind(\"0.0.0.0\", wsPortOrDefault).sync();\n                        logger.info(\"start the websocket server success! ws port:\" + wsPortOrDefault);\n                        f.channel().closeFuture().sync();\n                    } finally {\n                        logger.info(\"shutdown websocket server, ws port:{}\", wsPortOrDefault);\n                        bossGroup.shutdownGracefully();\n                        workerGroup.shutdownGracefully();\n                    }\n                } catch (InterruptedException e) {\n                    logger.error(\"failed to start  websocket server, ws port: {}\", wsPortOrDefault);\n                    Thread.currentThread().interrupt();\n                    e.printStackTrace();\n                }\n            }\n        });\n        wsServerThread.setName(\"native-agent-ws-server\");\n        wsServerThread.start();\n\n        // Start the Http server\n        final int httpPortOrDefault = nativeAgentBootstrap.getHttpPortOrDefault();\n        logger.info(\"start the http server... http port:\" + httpPortOrDefault);\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n        NioEventLoopGroup workGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .handler(new LoggingHandler(LogLevel.INFO))\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                protected void initChannel(SocketChannel ch) {\n                                    ch.pipeline().addLast(new HttpServerCodec());\n                                    ch.pipeline().addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                                    ch.pipeline().addLast(new HttpRequestHandler());\n                                }\n                            });\n            ChannelFuture f = b.bind(\"0.0.0.0\", httpPortOrDefault).sync();\n            logger.info(\"start the http server success, http port:\" + httpPortOrDefault);\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"failed to start http server, http port:\" + httpPortOrDefault);\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            logger.info(\"shutdown http server\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "83", "src_id": "M1677", "code": "\n    private Map<String, String> parseQueryString(String query) {\n        Map<String, String> params = new HashMap<String, String>();\n        if (query != null) {\n            String[] pairs = query.split(\"&\");\n            for (String pair : pairs) {\n                int idx = pair.indexOf(\"=\");\n                try {\n                    String key = URLDecoder.decode(pair.substring(0, idx), \"UTF-8\");\n                    String value = URLDecoder.decode(pair.substring(idx + 1), \"UTF-8\");\n                    params.put(key, value);\n                } catch (UnsupportedEncodingException e) {\n                    // 处理异常\n                }\n            }\n        }\n        return params;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "84", "src_id": "M1675", "code": "\n    private void closeOutboundChannel(Channel inboundChannel) {\n        Channel outboundChannel = channelMappings.remove(inboundChannel);\n        if (outboundChannel != null) {\n            logger.info(\"Closing outbound channel\");\n            outboundChannel.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "85", "src_id": "M1738", "code": "\n    private ByteBuf readInputStream(InputStream is) throws IOException {\n        ByteBuf buffer = Unpooled.buffer();\n        byte[] tmp = new byte[1024];\n        int length;\n        while ((length = is.read(tmp)) != -1) {\n            buffer.writeBytes(tmp, 0, length);\n        }\n        is.close();\n        return buffer;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "86", "src_id": "M1665", "code": "\n        @Override\n        protected void initChannel(SocketChannel ch) {\n            ch.pipeline().addLast(new HttpServerCodec());\n            ch.pipeline().addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH));\n            ch.pipeline().addLast(new RequestHandler());\n            ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "87", "src_id": "M1661", "code": "\n    @Option(longName = \"agent-registration-type\", required = true)\n    @Description(\"agent registration type\")\n    public void setAgentRegistrationType(String agentRegistrationType) {\n        this.agentRegistrationType = agentRegistrationType;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "88", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        String fileExt = \"\";\n        if (this.format == null) {\n            fileExt = \"html\";\n        } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\")\n                || this.format.equals(\"collapsed\")) {\n            fileExt = \"txt\";\n        } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n            fileExt = \"html\";\n        } else if (this.format.equals(\"jfr\")) {\n            fileExt = \"jfr\";\n        } else {\n            // illegal -o option makes async-profiler use flat\n            fileExt = \"txt\";\n        }\n        return fileExt;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "89", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "90", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "91", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "92", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "93", "src_id": "M1105", "code": "\n    @Override\n    public void onSuspend(Job job) {\n        if (!job.isRunInBackground()) {\n            resetAndReadLine();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "94", "src_id": "M1106", "code": "\n    private void resetAndReadLine() {\n        // reset stdin handler to echo handler\n        // shell.term().stdinHandler(null);\n        shell.setForegroundJob(null);\n        shell.readline();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "95", "src_id": "M504", "code": "\n    private void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n        for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n            String objectName = entry.getKey();\n            List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n            TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n            table.row(true, \"OBJECT_NAME\", objectName);\n            table.row(true, label(\"NAME\").style(Decoration.bold.bold()),\n                    label(\"VALUE\").style(Decoration.bold.bold()));\n\n            for (MBeanAttributeVO attributeVO : attributeVOList) {\n                String attributeName = attributeVO.getName();\n                String valueStr;\n                if (attributeVO.getError() != null) {\n                    valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n                } else {\n                    // convert array to list\n                    // TODO support all array type\n                    Object value = attributeVO.getValue();\n                    if (value instanceof String[]) {\n                        value = Arrays.asList((String[]) value);\n                    } else if (value instanceof Integer[]) {\n                        value = Arrays.asList((Integer[]) value);\n                    } else if (value instanceof Long[]) {\n                        value = Arrays.asList((Long[]) value);\n                    } else if (value instanceof int[]) {\n                        value = convertArrayToList((int[]) value);\n                    } else if (value instanceof long[]) {\n                        value = convertArrayToList((long[]) value);\n                    }\n                    // to string\n                    valueStr = String.valueOf(value);\n                }\n                table.row(attributeName, valueStr);\n            }\n            process.write(RenderUtil.render(table, process.width()));\n            process.write(\"\\n\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "96", "src_id": "M1157", "code": "\n    private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n        DefaultFullHttpResponse fullResp = null;\n        InputStream in = null;\n        try {\n            URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n            if (res != null) {\n                fullResp = new DefaultFullHttpResponse(request.protocolVersion(),\n                        HttpResponseStatus.OK);\n                in = res.openStream();\n                byte[] tmp = new byte[256];\n                for (int l = 0; l != -1; l = in.read(tmp)) {\n                    fullResp.content().writeBytes(tmp, 0, l);\n                }\n                int li = path.lastIndexOf('.');\n                if (li != -1 && li != path.length() - 1) {\n                    String ext = path.substring(li + 1);\n                    String contentType;\n                    if (\"html\".equals(ext)) {\n                        contentType = \"text/html\";\n                    } else if (\"js\".equals(ext)) {\n                        contentType = \"application/javascript\";\n                    } else if (\"css\".equals(ext)) {\n                        contentType = \"text/css\";\n                    } else {\n                        contentType = null;\n                    }\n\n                    if (contentType != null) {\n                        fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                    }\n                }\n            }\n        } finally {\n            IOUtils.close(in);\n        }\n        return fullResp;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "97", "src_id": "M381", "code": "\n    @Override\n    public List<ResultModel> pollResults() {\n        try {\n            lastAccessTime = System.currentTimeMillis();\n            long accessTime = lastAccessTime;\n            if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                polling = true;\n                sendingItemCount = 0;\n                long firstResultTime = 0;\n                // sending delay: time elapsed after firstResultTime\n                long sendingDelay = 0;\n                // waiting time: time elapsed after access\n                long waitingTime = 0;\n                List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n                while (!closed\n                        && sendingResults.size() < resultBatchSizeLimit\n                        && sendingDelay < 100\n                        && waitingTime < pollTimeLimit) {\n                    ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                    if (aResult != null) {\n                        sendingResults.add(aResult);\n                        // 是否为第一次获取到数据\n                        if (firstResultTime == 0) {\n                            firstResultTime = System.currentTimeMillis();\n                        }\n                        // 判断是否需要立即发送出去\n                        if (shouldFlush(sendingResults, aResult)) {\n                            break;\n                        }\n                    } else {\n                        if (firstResultTime > 0) {\n                            // 获取到部分数据后，队列已经取完，计算发送延时时间\n                            sendingDelay = System.currentTimeMillis() - firstResultTime;\n                        }\n                        // 计算总共等待时间，长轮询最大等待时间\n                        waitingTime = System.currentTimeMillis() - accessTime;\n                    }\n                }\n\n                // resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n                }\n                return sendingResults;\n            }\n        } catch (InterruptedException e) {\n            // e.printStackTrace();\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lastAccessTime = System.currentTimeMillis();\n                polling = false;\n                lock.unlock();\n            }\n        }\n        return Collections.emptyList();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "98", "src_id": "M519", "code": "\n    @Override\n    public void draw(CommandProcess process, DashboardModel result) {\n        int width = process.width();\n        int height = process.height();\n\n        // 上半部分放thread top。下半部分再切分为田字格，其中上面两格放memory, gc的信息。下面两格放tomcat,\n        // runtime的信息\n        int totalHeight = height - 1;\n        int threadTopHeight;\n        if (totalHeight <= 24) {\n            // 总高度较小时取1/2\n            threadTopHeight = totalHeight / 2;\n        } else {\n            // 总高度较大时取1/3，但不少于上面的值(24/2=12)\n            threadTopHeight = totalHeight / 3;\n            if (threadTopHeight < 12) {\n                threadTopHeight = 12;\n            }\n        }\n        int lowerHalf = totalHeight - threadTopHeight;\n\n        // Memory至少保留8行, 显示metaspace信息\n        int memoryInfoHeight = lowerHalf / 2;\n        if (memoryInfoHeight < 8) {\n            memoryInfoHeight = Math.min(8, lowerHalf);\n        }\n\n        // runtime\n        TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n        // tomcat\n        TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n        int runtimeInfoHeight = Math.max(runtimeInfoTable.getRows().size(), tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size());\n        if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n            // 如果runtimeInfo高度有剩余，则增大MemoryInfo的高度\n            memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n        } else {\n            runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n        }\n\n        // 如果MemoryInfo高度有剩余，则增大ThreadHeight\n        int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n        memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n        threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n        String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n        String memoryAndGc = drawMemoryInfoAndGcInfo(result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n        String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n\n        process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "99", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                    .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                    .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.classLoader)))\n                    .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                    .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.additivity)))\n                    .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                            label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash),\n                            label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target),\n                                label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking),\n                                label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef),\n                                label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "100", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = false;\n        if (session.get(ONETIME_SESSION_KEY) != null) {\n            oneTimeAccess = true;\n        }\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<String, Object>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse();\n            response.setSessionId(session.getSessionId())\n                    .setBody(body);\n\n            if (!session.tryLock()) {\n                response.setState(ApiState.REFUSED)\n                        .setMessage(\"Another command is executing.\");\n                return response;\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    response.setState(ApiState.REFUSED)\n                            .setMessage(\"Another job is running.\");\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response;\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                // distribute result message both to origin session channel and request channel by CompositeResultDistributor\n                // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n\n            } catch (Throwable e) {\n                logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n                response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            // wait for job completed or timeout\n            Integer timeout = apiRequest.getExecTimeout();\n            if (timeout == null || timeout <= 0) {\n                timeout = DEFAULT_EXEC_TIMEOUT;\n            }\n            boolean timeExpired = !waitForJob(job, timeout);\n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            // packing results\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            response.setSessionId(session.getSessionId())\n                    // .setConsumerId(consumerId)\n                    .setBody(body);\n            return response;\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "101", "src_id": "M494", "code": "\n    private void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n        callback.callback(deep, isLast, prefix, node);\n        if (!isLeaf(node)) {\n            List<TraceNode> children = node.getChildren();\n            if (children == null) {\n                return;\n            }\n            final int size = children.size();\n            for (int index = 0; index < size; index++) {\n                final boolean isLastFlag = index == size - 1;\n                final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n                recursive(\n                        deep + 1,\n                        isLastFlag,\n                        currentPrefix,\n                        children.get(index),\n                        callback\n                );\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "102", "src_id": "M474", "code": "\n    private static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n        if (parentClassLoader.getChildren() == null) {\n            return;\n        }\n        for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n            TreeElement child = new TreeElement(childClassLoader.getName());\n            parent.addChild(child);\n            renderSubtree(child, childClassLoader);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "103", "src_id": "M1671", "code": "\n    public void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n        if (frame instanceof CloseWebSocketFrame) {\n            closeOutboundChannel(ctx.channel());\n            ctx.close();\n            return;\n        }\n\n        Channel outboundChannel = channelMappings.get(ctx.channel());\n        if (outboundChannel == null || !outboundChannel.isActive()) {\n            connectToDestinationServer(ctx, frame);\n        } else {\n            forwardWebSocketFrame(frame, outboundChannel);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "104", "src_id": "M1691", "code": "\n    @Override\n    public void onError(Throwable t) {\n        logger.error(\"keep alive error: \" + t.getMessage());\n        t.printStackTrace();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "105", "src_id": "M1656", "code": "\n    @Override\n    public Map<String, String> findNativeAgent(String address) {\n        if (address == null || \"\".equals(address)) {\n            return null;\n        }\n\n        try {\n            ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n                if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                    connectedSemaphore.countDown();\n                }\n            });\n            connectedSemaphore.await();\n\n            List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n\n            Map<String, String> res = new ConcurrentHashMap<>(children.size());\n            for (String child : children) {\n                String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n                byte[] data = zooKeeper.getData(childPath, false, new Stat());\n                String dataStr = new String(data);\n\n                res.put(child, dataStr);\n            }\n\n            zooKeeper.close();\n            return res;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "106", "src_id": "M1668", "code": "\n    private FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n        OkHttpClient client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n\n        String url = \"http://\" + address + \"/api/native-agent\";\n\n        RequestBody requestBody = RequestBody.create(\n                request.content().toString(CharsetUtil.UTF_8),\n                MediaType.parse(\"application/json; charset=utf-8\")\n        );\n\n        Request okRequest = new Request.Builder()\n                .url(url)\n                .post(requestBody)\n                .build();\n\n        try {\n            Response response = client.newCall(okRequest).execute();\n\n            if (response.isSuccessful()) {\n                String responseBody = response.body().string();\n                DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(\n                        request.getProtocolVersion(),\n                        HttpResponseStatus.OK,\n                        Unpooled.copiedBuffer(responseBody, StandardCharsets.UTF_8)\n                );\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\");\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, fullHttpResponse.content().readableBytes());\n                return fullHttpResponse;\n            } else {\n                return new DefaultFullHttpResponse(\n                        HttpVersion.HTTP_1_1,\n                        HttpResponseStatus.valueOf(response.code()),\n                        Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n                );\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1,\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                    Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n            );\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "107", "src_id": "M1714", "code": "\n    public static void main(String[] args) {\n        WelcomeUtil.printNativeAgentWelcomeMsg();\n\n        logger.info(\"check arthas file path...\");\n        ArthasHomeHandler.findArthasHome();\n        logger.info(\"check arthas file path success\");\n\n        logger.info(\"read input config...\");\n        NativeAgentBootstrap nativeAgentBootstrap = new NativeAgentBootstrap();\n        CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n        CommandLine commandLine = cli.parse(Arrays.asList(args));\n        try {\n            CLIConfigurator.inject(commandLine, nativeAgentBootstrap);\n        } catch (Throwable e) {\n            logger.error(\"Missing startup parameter\");\n            e.printStackTrace();\n            System.out.println(usage(cli));\n            System.exit(1);\n        }\n        logger.info(\"read input config success\");\n\n        try {\n            logger.info(\"register native agent ...\");\n            NativeAgentRegistryFactory nativeAgentRegistryFactory = NativeAgentRegistryFactory.getNativeAgentClientRegisterFactory();\n            NativeAgentRegistry nativeAgentRegistry = nativeAgentRegistryFactory.getServiceRegistration(nativeAgentBootstrap.getRegistrationType());\n            nativeAgentRegistry.registerNativeAgent(nativeAgentBootstrap.getRegistrationAddress(),\n                    nativeAgentBootstrap.getIp(),\n                    nativeAgentBootstrap.getHttpPortOrDefault() + \":\" + nativeAgentBootstrap.getWsPortOrDefault());\n            logger.info(\"register native agent success!\");\n        } catch (Exception e) {\n            logger.error(\"register native agent failed!\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n\n        int wsPortOrDefault = nativeAgentBootstrap.getWsPortOrDefault();\n        Thread wsServerThread = new Thread(() -> {\n            logger.info(\"start the websocket server... ws port:\" + wsPortOrDefault);\n            try {\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n                try {\n                    ServerBootstrap b = new ServerBootstrap();\n                    b.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .handler(new LoggingHandler(LogLevel.INFO))\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                protected void initChannel(SocketChannel ch) {\n                                    ChannelPipeline p = ch.pipeline();\n                                    p.addLast(new HttpRequestDecoder());\n                                    p.addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                                    p.addLast(new HttpResponseEncoder());\n                                    p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                                    p.addLast(new ForwardClientSocketClientHandler());\n                                }\n                            });\n                    ChannelFuture f = b.bind(\"0.0.0.0\", wsPortOrDefault).sync();\n                    logger.info(\"start the websocket server success! ws port:\" + wsPortOrDefault);\n                    f.channel().closeFuture().sync();\n                } finally {\n                    logger.info(\"shutdown websocket server, ws port:{}\", wsPortOrDefault);\n                    bossGroup.shutdownGracefully();\n                    workerGroup.shutdownGracefully();\n                }\n            } catch (InterruptedException e) {\n                logger.error(\"failed to start  websocket server, ws port: {}\", wsPortOrDefault);\n                Thread.currentThread().interrupt();\n                e.printStackTrace();\n            }\n        });\n        wsServerThread.setName(\"native-agent-ws-server\");\n        wsServerThread.start();\n\n        int httpPortOrDefault = nativeAgentBootstrap.getHttpPortOrDefault();\n        logger.info(\"start the http server... http port:\" + httpPortOrDefault);\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n        NioEventLoopGroup workGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new HttpServerCodec());\n                            ch.pipeline().addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                            ch.pipeline().addLast(new HttpRequestHandler());\n                        }\n                    });\n            ChannelFuture f = b.bind(\"0.0.0.0\", httpPortOrDefault).sync();\n            logger.info(\"start the http server success, http port:\" + httpPortOrDefault);\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"failed to start http server, http port:\" + httpPortOrDefault);\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            logger.info(\"shutdown http server\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "108", "src_id": "M1677", "code": "\n    private Map<String, String> parseQueryString(String query) {\n        Map<String, String> params = new HashMap<>();\n        if (query != null) {\n            String[] pairs = query.split(\"&\");\n            for (String pair : pairs) {\n                int idx = pair.indexOf(\"=\");\n                try {\n                    String key = URLDecoder.decode(pair.substring(0, idx), \"UTF-8\");\n                    String value = URLDecoder.decode(pair.substring(idx + 1), \"UTF-8\");\n                    params.put(key, value);\n                } catch (UnsupportedEncodingException e) {\n                    // 处理异常\n                }\n            }\n        }\n        return params;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "109", "src_id": "M1675", "code": "\n    private void closeOutboundChannel(Channel inboundChannel) {\n        Channel outboundChannel = channelMappings.remove(inboundChannel);\n        if (outboundChannel != null) {\n            logger.info(\"Closing outbound channel\");\n            outboundChannel.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "110", "src_id": "M1738", "code": "\n    private ByteBuf readInputStream(InputStream is) throws IOException {\n        ByteBuf buffer = Unpooled.buffer();\n        byte[] tmp = new byte[1024];\n        int length;\n        while ((length = is.read(tmp)) != -1) {\n            buffer.writeBytes(tmp, 0, length);\n        }\n        is.close();\n        return buffer;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "111", "src_id": "M1665", "code": "\n    @Override\n    protected void initChannel(SocketChannel ch) {\n        ch.pipeline().addLast(new HttpServerCodec());\n        ch.pipeline().addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH));\n        ch.pipeline().addLast(new RequestHandler());\n        ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "112", "src_id": "M1661", "code": "\n    @Option(longName = \"agent-registration-type\", required = true)\n    @Description(\"agent registration type\")\n    public void setAgentRegistrationType(String agentRegistrationType) {\n        this.agentRegistrationType = agentRegistrationType;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "113", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "114", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "115", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "116", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "117", "src_id": "M1105", "code": "\n    @Override\n    public void onSuspend(Job job) {\n        if (!job.isRunInBackground()) {\n            resetAndReadLine();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "118", "src_id": "M1106", "code": "\n    private void resetAndReadLine() {\n        // reset stdin handler to echo handler\n        // shell.term().stdinHandler(null);\n        shell.setForegroundJob(null);\n        shell.readline();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "119", "src_id": "M504", "code": "\n    private void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n        for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n            String objectName = entry.getKey();\n            List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n            TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n            table.row(true, \"OBJECT_NAME\", objectName);\n            table.row(true, label(\"NAME\").style(Decoration.bold.bold()), label(\"VALUE\").style(Decoration.bold.bold()));\n\n            for (MBeanAttributeVO attributeVO : attributeVOList) {\n                String attributeName = attributeVO.getName();\n                String valueStr;\n                if (attributeVO.getError() != null) {\n                    valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n                } else {\n                    Object value = attributeVO.getValue();\n                    // convert array to list\n                    // TODO support all array type\n                    if (value instanceof String[]) {\n                        value = Arrays.asList((String[]) value);\n                    } else if (value instanceof Integer[]) {\n                        value = Arrays.asList((Integer[]) value);\n                    } else if (value instanceof Long[]) {\n                        value = Arrays.asList((Long[]) value);\n                    } else if (value instanceof int[]) {\n                        value = convertArrayToList((int[]) value);\n                    } else if (value instanceof long[]) {\n                        value = convertArrayToList((long[]) value);\n                    }\n                    valueStr = String.valueOf(value);\n                }\n                table.row(attributeName, valueStr);\n            }\n            process.write(RenderUtil.render(table, process.width()));\n            process.write(\"\\n\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "120", "src_id": "M1157", "code": "\n    private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n        DefaultFullHttpResponse fullResp = null;\n        InputStream in = null;\n        try {\n            URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n            if (res != null) {\n                fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n                in = res.openStream();\n                byte[] tmp = new byte[256];\n                for (int l = 0; l != -1; l = in.read(tmp)) {\n                    fullResp.content().writeBytes(tmp, 0, l);\n                }\n                int li = path.lastIndexOf('.');\n                if (li != -1 && li != path.length() - 1) {\n                    String ext = path.substring(li + 1);\n                    String contentType;\n                    if (\"html\".equals(ext)) {\n                        contentType = \"text/html\";\n                    } else if (\"js\".equals(ext)) {\n                        contentType = \"application/javascript\";\n                    } else if (\"css\".equals(ext)) {\n                        contentType = \"text/css\";\n                    } else {\n                        contentType = null;\n                    }\n                    if (contentType != null) {\n                        fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                    }\n                }\n            }\n        } finally {\n            IOUtils.close(in);\n        }\n        return fullResp;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "121", "src_id": "M381", "code": "\n    @Override\n    public List<ResultModel> pollResults() {\n        try {\n            lastAccessTime = System.currentTimeMillis();\n            long accessTime = lastAccessTime;\n            if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                polling = true;\n                sendingItemCount = 0;\n                long firstResultTime = 0;\n                long sendingDelay = 0;\n                long waitingTime = 0;\n                List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n                while (!closed\n                        && sendingResults.size() < resultBatchSizeLimit\n                        && sendingDelay < 100\n                        && waitingTime < pollTimeLimit) {\n                    ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                    if (aResult != null) {\n                        sendingResults.add(aResult);\n                        if (firstResultTime == 0) {\n                            firstResultTime = System.currentTimeMillis();\n                        }\n                        if (shouldFlush(sendingResults, aResult)) {\n                            break;\n                        }\n                    } else {\n                        if (firstResultTime > 0) {\n                            sendingDelay = System.currentTimeMillis() - firstResultTime;\n                        }\n                        waitingTime = System.currentTimeMillis() - accessTime;\n                    }\n                }\n\n                // resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n                }\n                return sendingResults;\n            }\n        } catch (InterruptedException e) {\n            // e.printStackTrace();\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lastAccessTime = System.currentTimeMillis();\n                polling = false;\n                lock.unlock();\n            }\n        }\n        return Collections.emptyList();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "122", "src_id": "M519", "code": "\n    @Override\n    public void draw(CommandProcess process, DashboardModel result) {\n        int width = process.width();\n        int height = process.height();\n\n        // 上半部分放thread top。下半部分再切分为田字格，其中上面两格放memory, gc的信息。下面两格放tomcat,\n        // runtime的信息\n        int totalHeight = height - 1;\n        int threadTopHeight;\n        if (totalHeight <= 24) {\n            // 总高度较小时取1/2\n            threadTopHeight = totalHeight / 2;\n        } else {\n            // 总高度较大时取1/3，但不少于上面的值(24/2=12)\n            threadTopHeight = totalHeight / 3;\n            if (threadTopHeight < 12) {\n                threadTopHeight = 12;\n            }\n        }\n        int lowerHalf = totalHeight - threadTopHeight;\n\n        // Memory至少保留8行, 显示metaspace信息\n        int memoryInfoHeight = lowerHalf / 2;\n        if (memoryInfoHeight < 8) {\n            memoryInfoHeight = Math.min(8, lowerHalf);\n        }\n\n        // runtime\n        TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n        // tomcat\n        TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n        int runtimeInfoHeight = Math.max(\n                runtimeInfoTable.getRows().size(),\n                tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size()\n        );\n        if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n            // 如果runtimeInfo高度有剩余，则增大MemoryInfo的高度\n            memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n        } else {\n            runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n        }\n\n        // 如果MemoryInfo高度有剩余，则增大ThreadHeight\n        int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n        memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n        threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n        String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n        String memoryAndGc = drawMemoryInfoAndGcInfo(result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n        String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n\n        process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "123", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                    .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                    .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n                    .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                    .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity)))\n                    .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "124", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = false;\n        if (session.get(ONETIME_SESSION_KEY) != null) {\n            oneTimeAccess = true;\n        }\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<String, Object>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse();\n            response.setSessionId(session.getSessionId()).setBody(body);\n\n            if (!session.tryLock()) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n                return response;\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response;\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                // distribute result message both to origin session channel and request channel by CompositeResultDistributor\n                // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n\n            } catch (Throwable e) {\n                logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n                response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            // wait for job completed or timeout\n            Integer timeout = apiRequest.getExecTimeout();\n            if (timeout == null || timeout <= 0) {\n                timeout = DEFAULT_EXEC_TIMEOUT;\n            }\n            boolean timeExpired = !waitForJob(job, timeout);\n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            // packing results\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            response.setSessionId(session.getSessionId()).setBody(body);\n            return response;\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "125", "src_id": "M494", "code": "\n    private void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n        callback.callback(deep, isLast, prefix, node);\n        if (!isLeaf(node)) {\n            List<TraceNode> children = node.getChildren();\n            if (children == null) {\n                return;\n            }\n            final int size = children.size();\n            for (int index = 0; index < size; index++) {\n                final boolean isLastFlag = index == size - 1;\n                final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n                recursive(\n                        deep + 1,\n                        isLastFlag,\n                        currentPrefix,\n                        children.get(index),\n                        callback\n                );\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "126", "src_id": "M474", "code": "\n    private static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n        if (parentClassLoader.getChildren() == null) {\n            return;\n        }\n        for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n            TreeElement child = new TreeElement(childClassLoader.getName());\n            parent.addChild(child);\n            renderSubtree(child, childClassLoader);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "127", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        String fileExt = \"\";\n        if (format == null) {\n            fileExt = \"html\";\n        } else if (format.startsWith(\"flat\") || format.startsWith(\"traces\") || format.equals(\"collapsed\")) {\n            fileExt = \"txt\";\n        } else if (format.equals(\"flamegraph\") || format.equals(\"tree\")) {\n            fileExt = \"html\";\n        } else if (format.equals(\"jfr\")) {\n            fileExt = \"jfr\";\n        } else {\n            // illegal -o option makes async-profiler use flat\n            fileExt = \"txt\";\n        }\n        return fileExt;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "128", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "129", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "130", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "131", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "132", "src_id": "M1671", "code": "\n    public void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n        if (frame instanceof CloseWebSocketFrame) {\n            closeOutboundChannel(ctx.channel());\n            ctx.close();\n            return;\n        } else {\n            Channel outboundChannel = channelMappings.get(ctx.channel());\n            if (outboundChannel == null || !outboundChannel.isActive()) {\n                connectToDestinationServer(ctx, frame);\n            } else {\n                forwardWebSocketFrame(frame, outboundChannel);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "133", "src_id": "M1691", "code": "\n    @Override\n    public void onError(Throwable t) {\n        logger.error(\"keep alive error: \" + t.getMessage());\n        t.printStackTrace();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "134", "src_id": "M1656", "code": "\n    @Override\n    public Map<String, String> findNativeAgent(String address) {\n        if (address == null || \"\".equals(address)) {\n            return null;\n        } else {\n            try {\n                ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n                    if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                        connectedSemaphore.countDown();\n                    }\n                });\n                connectedSemaphore.await();\n\n                List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n                Map<String, String> res = new ConcurrentHashMap<>(children.size());\n                for (String child : children) {\n                    String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n                    byte[] data = zooKeeper.getData(childPath, false, new Stat());\n                    String dataStr = new String(data);\n                    res.put(child, dataStr);\n                }\n                zooKeeper.close();\n                return res;\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "135", "src_id": "M1668", "code": "\n    private FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n        OkHttpClient client = (new OkHttpClient.Builder())\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .build();\n        String url = \"http://\" + address + \"/api/native-agent\";\n        RequestBody requestBody = RequestBody.create(\n            request.content().toString(CharsetUtil.UTF_8),\n            MediaType.parse(\"application/json; charset=utf-8\")\n        );\n        Request okRequest = (new Request.Builder())\n            .url(url)\n            .post(requestBody)\n            .build();\n        try {\n            Response response = client.newCall(okRequest).execute();\n            if (response.isSuccessful()) {\n                String responseBody = response.body().string();\n                DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(\n                    request.getProtocolVersion(),\n                    HttpResponseStatus.OK,\n                    Unpooled.copiedBuffer(responseBody, StandardCharsets.UTF_8)\n                );\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\");\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, fullHttpResponse.content().readableBytes());\n                return fullHttpResponse;\n            } else {\n                return new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1,\n                    HttpResponseStatus.valueOf(response.code()),\n                    Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n                );\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new DefaultFullHttpResponse(\n                HttpVersion.HTTP_1_1,\n                HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n            );\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "136", "src_id": "M1714", "code": "\n    public static void main(String[] args) {\n        WelcomeUtil.printNativeAgentWelcomeMsg();\n        logger.info(\"check arthas file path...\");\n        ArthasHomeHandler.findArthasHome();\n        logger.info(\"check arthas file path success\");\n        logger.info(\"read input config...\");\n        NativeAgentBootstrap nativeAgentBootstrap = new NativeAgentBootstrap();\n        CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n        CommandLine commandLine = cli.parse(Arrays.asList(args));\n        try {\n            CLIConfigurator.inject(commandLine, nativeAgentBootstrap);\n        } catch (Throwable e) {\n            logger.error(\"Missing startup parameter\");\n            e.printStackTrace();\n            System.out.println(usage(cli));\n            System.exit(1);\n        }\n        logger.info(\"read input config success\");\n        try {\n            logger.info(\"register native agent ...\");\n            NativeAgentRegistryFactory nativeAgentRegistryFactory = NativeAgentRegistryFactory.getNativeAgentClientRegisterFactory();\n            NativeAgentRegistry nativeAgentRegistry = nativeAgentRegistryFactory.getServiceRegistration(nativeAgentBootstrap.getRegistrationType());\n            nativeAgentRegistry.registerNativeAgent(\n                nativeAgentBootstrap.getRegistrationAddress(),\n                nativeAgentBootstrap.getIp(),\n                nativeAgentBootstrap.getHttpPortOrDefault() + \":\" + nativeAgentBootstrap.getWsPortOrDefault()\n            );\n            logger.info(\"register native agent success!\");\n        } catch (Exception e) {\n            logger.error(\"register native agent failed!\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n        int wsPortOrDefault = nativeAgentBootstrap.getWsPortOrDefault();\n        Thread wsServerThread = new Thread(() -> {\n            logger.info(\"start the websocket server... ws port:\" + wsPortOrDefault);\n            try {\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n                try {\n                    ServerBootstrap b = new ServerBootstrap();\n                    b.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .handler(new LoggingHandler(LogLevel.INFO))\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            protected void initChannel(SocketChannel ch) {\n                                ChannelPipeline p = ch.pipeline();\n                                p.addLast(new HttpRequestDecoder());\n                                p.addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                                p.addLast(new HttpResponseEncoder());\n                                p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                                p.addLast(new ForwardClientSocketClientHandler());\n                            }\n                        });\n                    ChannelFuture f = b.bind(\"0.0.0.0\", wsPortOrDefault).sync();\n                    logger.info(\"start the websocket server success! ws port:\" + wsPortOrDefault);\n                    f.channel().closeFuture().sync();\n                } finally {\n                    logger.info(\"shutdown websocket server, ws port:{}\", wsPortOrDefault);\n                    bossGroup.shutdownGracefully();\n                    workerGroup.shutdownGracefully();\n                }\n            } catch (InterruptedException e) {\n                logger.error(\"failed to start  websocket server, ws port: {}\", wsPortOrDefault);\n                Thread.currentThread().interrupt();\n                e.printStackTrace();\n            }\n        });\n        wsServerThread.setName(\"native-agent-ws-server\");\n        wsServerThread.start();\n        int httpPortOrDefault = nativeAgentBootstrap.getHttpPortOrDefault();\n        logger.info(\"start the http server... http port:\" + httpPortOrDefault);\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n        NioEventLoopGroup workGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workGroup)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                        ch.pipeline().addLast(new HttpRequestHandler());\n                    }\n                });\n            ChannelFuture f = b.bind(\"0.0.0.0\", httpPortOrDefault).sync();\n            logger.info(\"start the http server success, http port:\" + httpPortOrDefault);\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"failed to start http server, http port:\" + httpPortOrDefault);\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            logger.info(\"shutdown http server\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "137", "src_id": "M1677", "code": "\n    private Map<String, String> parseQueryString(String query) {\n        Map<String, String> params = new HashMap<>();\n        if (query != null) {\n            String[] pairs = query.split(\"&\");\n            for (String pair : pairs) {\n                int idx = pair.indexOf(\"=\");\n                try {\n                    String key = URLDecoder.decode(pair.substring(0, idx), \"UTF-8\");\n                    String value = URLDecoder.decode(pair.substring(idx + 1), \"UTF-8\");\n                    params.put(key, value);\n                } catch (UnsupportedEncodingException e) {\n                    // handle exception\n                }\n            }\n        }\n        return params;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "138", "src_id": "M1675", "code": "\n    private void closeOutboundChannel(Channel inboundChannel) {\n        Channel outboundChannel = channelMappings.remove(inboundChannel);\n        if (outboundChannel != null) {\n            logger.info(\"Closing outbound channel\");\n            outboundChannel.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "139", "src_id": "M1738", "code": "\n    private ByteBuf readInputStream(InputStream is) throws IOException {\n        ByteBuf buffer = Unpooled.buffer();\n        byte[] tmp = new byte[1024];\n        int length;\n        while ((length = is.read(tmp)) != -1) {\n            buffer.writeBytes(tmp, 0, length);\n        }\n        is.close();\n        return buffer;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "140", "src_id": "M1665", "code": "\n    @Override\n    protected void initChannel(SocketChannel ch) {\n        ch.pipeline().addLast(new HttpServerCodec());\n        ch.pipeline().addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH));\n        ch.pipeline().addLast(new RequestHandler());\n        ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "141", "src_id": "M1661", "code": "\n    @Option(longName = \"agent-registration-type\", required = true)\n    @Description(\"agent registration type\")\n    public void setAgentRegistrationType(String agentRegistrationType) {\n        this.agentRegistrationType = agentRegistrationType;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "142", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "143", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "144", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "145", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "146", "src_id": "M742", "code": "\n    @Override\n    public void complete(Completion completion) {\n        int argumentIndex = CompletionUtils.detectArgumentIndex(completion);\n        if (argumentIndex == 1) {\n            if (!completeBeanName(completion)) {\n                super.complete(completion);\n            }\n            return;\n        }\n        if (argumentIndex == 2) {\n            if (!completeAttributeName(completion)) {\n                super.complete(completion);\n            }\n            return;\n        }\n        super.complete(completion);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "147", "src_id": "M1452", "code": "\n    public static String retrievePreviousArg(List<CliToken> tokens, String lastToken) {\n        if (StringUtils.isBlank(lastToken) && tokens.size() > 2) {\n            // tokens = { \" \", \"CLASS_NAME\", \" \"}\n            return tokens.get(tokens.size() - 2).value();\n        }\n        if (tokens.size() > 3) {\n            // tokens = { \" \", \"CLASS_NAME\", \" \", \"PARTIAL_METHOD_NAME\"}\n            return tokens.get(tokens.size() - 3).value();\n        }\n        return Constants.EMPTY_STRING;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "148", "src_id": "M747", "code": "\n    @Override\n    public void handle(Void event) {\n        timer.cancel();\n        super.handle(event);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "149", "src_id": "M744", "code": "\n    private boolean completeAttributeName(Completion completion) {\n        List<CliToken> tokens = completion.lineTokens();\n        String lastToken = TokenUtils.getLast(tokens).value();\n        if (StringUtils.isBlank(lastToken)) {\n            lastToken = \"\";\n        }\n        MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();\n        String beanName = TokenUtils.retrievePreviousArg(tokens, lastToken);\n        Set<ObjectName> objectNames = null;\n        try {\n            objectNames = platformMBeanServer.queryNames(new ObjectName(beanName), null);\n        } catch (MalformedObjectNameException e) {\n            logger.warn(\"queryNames error\", e);\n        }\n        if (objectNames == null || objectNames.size() == 0) {\n            return false;\n        }\n        try {\n            MBeanInfo mBeanInfo = platformMBeanServer.getMBeanInfo(objectNames.iterator().next());\n            List<String> attributeNames = new ArrayList<>();\n            MBeanAttributeInfo[] attributes = mBeanInfo.getAttributes();\n            for (MBeanAttributeInfo attribute : attributes) {\n                if (StringUtils.isBlank(lastToken)) {\n                    attributeNames.add(attribute.getName());\n                } else if (attribute.getName().startsWith(lastToken)) {\n                    attributeNames.add(attribute.getName());\n                }\n            }\n            return CompletionUtils.complete(completion, attributeNames);\n        } catch (Throwable e) {\n            logger.warn(\"getMBeanInfo error\", e);\n        }\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "150", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "151", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "152", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "153", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "154", "src_id": "M1539", "code": "\n    @Override\n    public void onError(Throwable t) {\n        Status s = Status.fromThrowable(t);\n        sendResponse.writeError(s);\n        latch.countDown();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "155", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n        Map<String, String> map = new HashMap<String, String>();\n        for (String key : trailer.keys()) {\n            if (EXCLUDED.contains(key.toLowerCase())) {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                map.put(key, new String(value));\n            } else {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                map.put(key, value);\n            }\n        }\n        return map;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "156", "src_id": "M1553", "code": "\n    public byte[] getPrefix(byte[] in, Type type) {\n        int len = in.length;\n        return new byte[] {\n                type.value,\n                (byte) ((len >> 24) & 0xff),\n                (byte) ((len >> 16) & 0xff),\n                (byte) ((len >> 8) & 0xff),\n                (byte) ((len >> 0) & 0xff),\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "157", "src_id": "M1538", "code": "\n    private Method getRpcMethod(Object stub, String rpcMethodName) {\n        for (Method m : stub.getClass().getMethods()) {\n            if (m.getName().equals(rpcMethodName)) {\n                return m;\n            }\n        }\n        throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "158", "src_id": "M1535", "code": "\n    private Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n        // pathInfo starts with \"/\". ignore that first char.\n        String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n        if (rpcClassAndMethodTokens.length != 2) {\n            throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n        }\n\n        String rpcClassName = rpcClassAndMethodTokens[0];\n        String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n        String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n        return new Pair<String, String>(rpcClassName, rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "159", "src_id": "M1530", "code": "\n    @Override\n    public boolean isEndOfInput() throws Exception {\n        if (input.isEndOfInput()) {\n            // Only end of input after last HTTP chunk has been sent\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "160", "src_id": "M1105", "code": "\n    @Override\n    public void onSuspend(Job job) {\n        if (!job.isRunInBackground()) {\n            resetAndReadLine();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "161", "src_id": "M1106", "code": "\n    private void resetAndReadLine() {\n        // reset stdin handler to echo handler\n        // shell.term().stdinHandler(null);\n        shell.setForegroundJob(null);\n        shell.readline();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "162", "src_id": "M504", "code": "\n    private void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n        for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n            String objectName = entry.getKey();\n            List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n            TableElement table = new TableElement()\n                .leftCellPadding(1)\n                .rightCellPadding(1);\n            table.row(true, \"OBJECT_NAME\", objectName);\n            table.row(true,\n                label(\"NAME\").style(Decoration.bold.bold()),\n                label(\"VALUE\").style(Decoration.bold.bold()));\n\n            for (MBeanAttributeVO attributeVO : attributeVOList) {\n                String attributeName = attributeVO.getName();\n                String valueStr;\n                if (attributeVO.getError() != null) {\n                    valueStr = RenderUtil.render(\n                        new LabelElement(attributeVO.getError())\n                            .style(Decoration.bold_off.fg(Color.red))\n                    );\n                } else {\n                    // convert array to list\n                    // TODO support all array type\n                    Object value = attributeVO.getValue();\n                    if (value instanceof String[]) {\n                        value = Arrays.asList((String[]) value);\n                    } else if (value instanceof Integer[]) {\n                        value = Arrays.asList((Integer[]) value);\n                    } else if (value instanceof Long[]) {\n                        value = Arrays.asList((Long[]) value);\n                    } else if (value instanceof int[]) {\n                        value = convertArrayToList((int[]) value);\n                    } else if (value instanceof long[]) {\n                        value = convertArrayToList((long[]) value);\n                    }\n                    // to string\n                    valueStr = String.valueOf(value);\n                }\n                table.row(attributeName, valueStr);\n            }\n            process.write(RenderUtil.render(table, process.width()));\n            process.write(\"\\n\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "163", "src_id": "M1157", "code": "\n    private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n        DefaultFullHttpResponse fullResp = null;\n        InputStream in = null;\n        try {\n            URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n            if (res != null) {\n                fullResp = new DefaultFullHttpResponse(\n                    request.protocolVersion(),\n                    HttpResponseStatus.OK\n                );\n                in = res.openStream();\n                byte[] tmp = new byte[256];\n                for (int l = 0; l != -1; l = in.read(tmp)) {\n                    fullResp.content().writeBytes(tmp, 0, l);\n                }\n                int li = path.lastIndexOf('.');\n                if (li != -1 && li != path.length() - 1) {\n                    String ext = path.substring(li + 1);\n                    String contentType;\n                    if (\"html\".equals(ext)) {\n                        contentType = \"text/html\";\n                    } else if (\"js\".equals(ext)) {\n                        contentType = \"application/javascript\";\n                    } else if (\"css\".equals(ext)) {\n                        contentType = \"text/css\";\n                    } else {\n                        contentType = null;\n                    }\n\n                    if (contentType != null) {\n                        fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                    }\n                }\n            }\n        } finally {\n            IOUtils.close(in);\n        }\n        return fullResp;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "164", "src_id": "M381", "code": "\n    @Override\n    public List<ResultModel> pollResults() {\n        try {\n            lastAccessTime = System.currentTimeMillis();\n            long accessTime = lastAccessTime;\n            if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                polling = true;\n                sendingItemCount = 0;\n                long firstResultTime = 0;\n                // sending delay: time elapsed after firstResultTime\n                long sendingDelay = 0;\n                // waiting time: time elapsed after access\n                long waitingTime = 0;\n                List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n                while (!closed\n                        && sendingResults.size() < resultBatchSizeLimit\n                        && sendingDelay < 100\n                        && waitingTime < pollTimeLimit) {\n                    ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                    if (aResult != null) {\n                        sendingResults.add(aResult);\n                        // 是否为第一次获取到数据\n                        if (firstResultTime == 0) {\n                            firstResultTime = System.currentTimeMillis();\n                        }\n                        // 判断是否需要立即发送出去\n                        if (shouldFlush(sendingResults, aResult)) {\n                            break;\n                        }\n                    } else {\n                        if (firstResultTime > 0) {\n                            // 获取到部分数据后，队列已经取完，计算发送延时时间\n                            sendingDelay = System.currentTimeMillis() - firstResultTime;\n                        }\n                        // 计算总共等待时间，长轮询最大等待时间\n                        waitingTime = System.currentTimeMillis() - accessTime;\n                    }\n                }\n\n                // resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n                }\n                return sendingResults;\n            }\n        } catch (InterruptedException e) {\n            // e.printStackTrace();\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lastAccessTime = System.currentTimeMillis();\n                polling = false;\n                lock.unlock();\n            }\n        }\n        return Collections.emptyList();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "165", "src_id": "M519", "code": "\n    @Override\n    public void draw(CommandProcess process, DashboardModel result) {\n        int width = process.width();\n        int height = process.height();\n\n        // 上半部分放 thread top。下半部分再切分为田字格，其中上面两格放 memory, gc 的信息。下面两格放 tomcat,\n        // runtime 的信息\n        int totalHeight = height - 1;\n        int threadTopHeight;\n        if (totalHeight <= 24) {\n            // 总高度较小时取 1/2\n            threadTopHeight = totalHeight / 2;\n        } else {\n            // 总高度较大时取 1/3，但不少于上面的值 (24/2=12)\n            threadTopHeight = totalHeight / 3;\n            if (threadTopHeight < 12) {\n                threadTopHeight = 12;\n            }\n        }\n        int lowerHalf = totalHeight - threadTopHeight;\n\n        // Memory 至少保留 8 行, 显示 metaspace 信息\n        int memoryInfoHeight = lowerHalf / 2;\n        if (memoryInfoHeight < 8) {\n            memoryInfoHeight = Math.min(8, lowerHalf);\n        }\n\n        // runtime\n        TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n        // tomcat\n        TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n        int runtimeInfoHeight = Math.max(\n            runtimeInfoTable.getRows().size(),\n            tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size()\n        );\n        if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n            // 如果 runtimeInfo 高度有剩余，则增大 MemoryInfo 的高度\n            memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n        } else {\n            runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n        }\n\n        // 如果 MemoryInfo 高度有剩余，则增大 ThreadHeight\n        int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n        memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n        threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n        String threadInfo = ViewRenderUtil.drawThreadInfo(\n            result.getThreads(), width, threadTopHeight\n        );\n        String memoryAndGc = drawMemoryInfoAndGcInfo(\n            result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight\n        );\n        String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(\n            runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight\n        );\n\n        process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "166", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n\n            TableElement table = new TableElement(2, 10)\n                .leftCellPadding(1)\n                .rightCellPadding(1);\n            TableElement appendersTable = new TableElement()\n                .rightCellPadding(1);\n\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity)))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "167", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = false;\n        if (session.get(ONETIME_SESSION_KEY) != null) {\n            oneTimeAccess = true;\n        }\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<String, Object>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse();\n            response.setSessionId(session.getSessionId())\n                .setBody(body);\n\n            if (!session.tryLock()) {\n                response.setState(ApiState.REFUSED)\n                    .setMessage(\"Another command is executing.\");\n                return response;\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    response.setState(ApiState.REFUSED)\n                        .setMessage(\"Another job is running.\");\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response;\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                // distribute result message both to origin session channel and request channel by CompositeResultDistributor\n                // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n\n            } catch (Throwable e) {\n                logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n                response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            // wait for job completed or timeout\n            Integer timeout = apiRequest.getExecTimeout();\n            if (timeout == null || timeout <= 0) {\n                timeout = DEFAULT_EXEC_TIMEOUT;\n            }\n            boolean timeExpired = !waitForJob(job, timeout);\n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            // packing results\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            response.setSessionId(session.getSessionId())\n                // .setConsumerId(consumerId)\n                .setBody(body);\n            return response;\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "168", "src_id": "M494", "code": "\n    private void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n        callback.callback(deep, isLast, prefix, node);\n        if (!isLeaf(node)) {\n            List<TraceNode> children = node.getChildren();\n            if (children == null) {\n                return;\n            }\n            final int size = children.size();\n            for (int index = 0; index < size; index++) {\n                final boolean isLastFlag = index == size - 1;\n                final String currentPrefix = isLast\n                    ? prefix + STEP_EMPTY_BOARD\n                    : prefix + STEP_HAS_BOARD;\n                recursive(\n                    deep + 1,\n                    isLastFlag,\n                    currentPrefix,\n                    children.get(index),\n                    callback\n                );\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "169", "src_id": "M474", "code": "\n    private static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n        if (parentClassLoader.getChildren() == null) {\n            return;\n        }\n        for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n            TreeElement child = new TreeElement(childClassLoader.getName());\n            parent.addChild(child);\n            renderSubtree(child, childClassLoader);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "170", "src_id": "M1671", "code": "\n    public void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n        if (frame instanceof CloseWebSocketFrame) {\n            closeOutboundChannel(ctx.channel());\n            ctx.close();\n            return;\n        }\n\n        Channel outboundChannel = channelMappings.get(ctx.channel());\n        if (outboundChannel == null || !outboundChannel.isActive()) {\n            connectToDestinationServer(ctx, frame);\n        } else {\n            forwardWebSocketFrame(frame, outboundChannel);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "171", "src_id": "M1691", "code": "\n    @Override\n    public void onError(Throwable t) {\n        logger.error(\"keep alive error: \" + t.getMessage());\n        t.printStackTrace();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "172", "src_id": "M1656", "code": "\n    @Override\n    public Map<String, String> findNativeAgent(String address) {\n        if (address == null || \"\".equals(address)) {\n            return null;\n        }\n\n        try {\n            ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n                if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                    connectedSemaphore.countDown();\n                }\n            });\n            connectedSemaphore.await();\n\n            List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n\n            Map<String, String> res = new ConcurrentHashMap<>(children.size());\n            for (String child : children) {\n                String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n                byte[] data = zooKeeper.getData(childPath, false, new Stat());\n                String dataStr = new String(data);\n\n                res.put(child, dataStr);\n            }\n\n            zooKeeper.close();\n            return res;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "173", "src_id": "M1668", "code": "\n    private FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n        OkHttpClient client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n\n        String url = \"http://\" + address + \"/api/native-agent\";\n\n        RequestBody requestBody = RequestBody.create(\n                request.content().toString(CharsetUtil.UTF_8),\n                MediaType.parse(\"application/json; charset=utf-8\")\n        );\n\n        Request okRequest = new Request.Builder()\n                .url(url)\n                .post(requestBody)\n                .build();\n\n        try {\n            Response response = client.newCall(okRequest).execute();\n\n            if (response.isSuccessful()) {\n                String responseBody = response.body().string();\n                DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(\n                        request.getProtocolVersion(),\n                        HttpResponseStatus.OK,\n                        Unpooled.copiedBuffer(responseBody, StandardCharsets.UTF_8)\n                );\n                // 设置跨域响应头\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\");\n\n                // 设置其他必要的头部\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, fullHttpResponse.content().readableBytes());\n                return fullHttpResponse;\n            } else {\n                return new DefaultFullHttpResponse(\n                        HttpVersion.HTTP_1_1,\n                        HttpResponseStatus.valueOf(response.code()),\n                        Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n                );\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1,\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                    Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n            );\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "174", "src_id": "M1714", "code": "\n    public static void main(String[] args) {\n        // Print welcome info\n        WelcomeUtil.printNativeAgentWelcomeMsg();\n\n        // Check And Find arthas path\n        logger.info(\"check arthas file path...\");\n        ArthasHomeHandler.findArthasHome();\n        logger.info(\"check arthas file path success\");\n\n        // Read bootstrap config\n        logger.info(\"read input config...\");\n        NativeAgentBootstrap nativeAgentBootstrap = new NativeAgentBootstrap();\n        CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n        CommandLine commandLine = cli.parse(Arrays.asList(args));\n        try {\n            CLIConfigurator.inject(commandLine, nativeAgentBootstrap);\n        } catch (Throwable e) {\n            logger.error(\"Missing startup parameter\");\n            e.printStackTrace();\n            System.out.println(usage(cli));\n            System.exit(1);\n        }\n        logger.info(\"read input config success\");\n\n        // Register native agent\n        try {\n            logger.info(\"register native agent ...\");\n            NativeAgentRegistryFactory nativeAgentRegistryFactory = NativeAgentRegistryFactory.getNativeAgentClientRegisterFactory();\n            NativeAgentRegistry nativeAgentRegistry = nativeAgentRegistryFactory.getServiceRegistration(nativeAgentBootstrap.getRegistrationType());\n            nativeAgentRegistry.registerNativeAgent(\n                    nativeAgentBootstrap.getRegistrationAddress(),\n                    nativeAgentBootstrap.getIp(),\n                    nativeAgentBootstrap.getHttpPortOrDefault() + \":\" + nativeAgentBootstrap.getWsPortOrDefault()\n            );\n            logger.info(\"register native agent success!\");\n        } catch (Exception e) {\n            logger.error(\"register native agent failed!\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n\n        // Start the websocket server\n        int wsPortOrDefault = nativeAgentBootstrap.getWsPortOrDefault();\n        Thread wsServerThread = new Thread(() -> {\n            logger.info(\"start the websocket server... ws port:\" + wsPortOrDefault);\n            try {\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n                try {\n                    ServerBootstrap b = new ServerBootstrap();\n                    b.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .handler(new LoggingHandler(LogLevel.INFO))\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                protected void initChannel(SocketChannel ch) {\n                                    ChannelPipeline p = ch.pipeline();\n                                    p.addLast(new HttpRequestDecoder());\n                                    p.addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                                    p.addLast(new HttpResponseEncoder());\n                                    p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                                    p.addLast(new ForwardClientSocketClientHandler());\n                                }\n                            });\n                    ChannelFuture f = b.bind(\"0.0.0.0\", wsPortOrDefault).sync();\n                    logger.info(\"start the websocket server success! ws port:\" + wsPortOrDefault);\n                    f.channel().closeFuture().sync();\n                } finally {\n                    logger.info(\"shutdown websocket server, ws port:{}\", wsPortOrDefault);\n                    bossGroup.shutdownGracefully();\n                    workerGroup.shutdownGracefully();\n                }\n            } catch (InterruptedException e) {\n                logger.error(\"failed to start  websocket server, ws port: {}\", wsPortOrDefault);\n                Thread.currentThread().interrupt();\n                e.printStackTrace();\n            }\n        });\n        wsServerThread.setName(\"native-agent-ws-server\");\n        wsServerThread.start();\n\n        // Start the Http server\n        int httpPortOrDefault = nativeAgentBootstrap.getHttpPortOrDefault();\n        logger.info(\"start the http server... http port:\" + httpPortOrDefault);\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n        NioEventLoopGroup workGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new HttpServerCodec());\n                            ch.pipeline().addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                            ch.pipeline().addLast(new HttpRequestHandler());\n                        }\n                    });\n            ChannelFuture f = b.bind(\"0.0.0.0\", httpPortOrDefault).sync();\n            logger.info(\"start the http server success, http port:\" + httpPortOrDefault);\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"failed to start http server, http port:\" + httpPortOrDefault);\n            e.printStackTrace();\n        } finally {\n            bossGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            logger.info(\"shutdown http server\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "175", "src_id": "M1677", "code": "\n    private Map<String, String> parseQueryString(String query) {\n        Map<String, String> params = new HashMap<>();\n        if (query != null) {\n            String[] pairs = query.split(\"&\");\n            for (String pair : pairs) {\n                int idx = pair.indexOf(\"=\");\n                try {\n                    String key = URLDecoder.decode(pair.substring(0, idx), \"UTF-8\");\n                    String value = URLDecoder.decode(pair.substring(idx + 1), \"UTF-8\");\n                    params.put(key, value);\n                } catch (UnsupportedEncodingException e) {\n                    // ignore\n                }\n            }\n        }\n        return params;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "176", "src_id": "M1675", "code": "\n    private void closeOutboundChannel(Channel inboundChannel) {\n        Channel outboundChannel = channelMappings.remove(inboundChannel);\n        if (outboundChannel != null) {\n            logger.info(\"Closing outbound channel\");\n            outboundChannel.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "177", "src_id": "M1738", "code": "\n    private ByteBuf readInputStream(InputStream is) throws IOException {\n        ByteBuf buffer = Unpooled.buffer();\n        byte[] tmp = new byte[1024];\n        int length;\n        while ((length = is.read(tmp)) != -1) {\n            buffer.writeBytes(tmp, 0, length);\n        }\n        is.close();\n        return buffer;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "178", "src_id": "M1665", "code": "\n    @Override\n    protected void initChannel(SocketChannel ch) {\n        ch.pipeline().addLast(new HttpServerCodec());\n        ch.pipeline().addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH));\n        ch.pipeline().addLast(new RequestHandler());\n        ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "179", "src_id": "M1661", "code": "\n    @Option(longName = \"agent-registration-type\", required = true)\n    @Description(\"agent registration type\")\n    public void setAgentRegistrationType(String agentRegistrationType) {\n        this.agentRegistrationType = agentRegistrationType;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "180", "src_id": "M308", "code": "\n    HashEntry<K, V> nextEntry() {\n        do {\n            if (nextEntry == null) {\n                throw new NoSuchElementException();\n            }\n            lastReturned = nextEntry;\n            currentKey = lastReturned.key();\n            advance();\n        } while (currentKey == null); // Skip GC'd keys\n        return lastReturned;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "181", "src_id": "M1284", "code": "\n    @AtInvoke(name = \"\", inline = true, whenComplete = false, excludes = \"java.**\")\n    public static void onInvoke(\n            @Binding.This Object target,\n            @Binding.Class Class<?> clazz,\n            @Binding.InvokeInfo String invokeInfo) {\n        SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "182", "src_id": "M947", "code": "\n    public void loggers(CommandProcess process) {\n        Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<ClassLoader, LoggerTypes>();\n\n        // 如果不指定 classloader，则打印所有 classloader 里的 logger 信息\n        for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n            String className = clazz.getName();\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            // if special classloader\n            if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) {\n                continue;\n            }\n\n            if (classLoader != null) {\n                LoggerTypes loggerTypes = classLoaderLoggerMap.get(classLoader);\n                if (loggerTypes == null) {\n                    loggerTypes = new LoggerTypes();\n                    classLoaderLoggerMap.put(classLoader, loggerTypes);\n                }\n                updateLoggerType(loggerTypes, classLoader, className);\n            }\n        }\n\n        for (Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n            ClassLoader classLoader = entry.getKey();\n            LoggerTypes loggerTypes = entry.getValue();\n\n            if (loggerTypes.contains(LoggerType.LOG4J)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4jHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n            if (loggerTypes.contains(LoggerType.LOGBACK)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, LogbackHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n            if (loggerTypes.contains(LoggerType.LOG4J2)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4j2Helper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n        }\n\n        process.end();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "183", "src_id": "M249", "code": "\n    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri)\n            throws URISyntaxException {\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n\n        String appName = null;\n        List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n        if (appNameList != null && !appNameList.isEmpty()) {\n            appName = appNameList.get(0);\n        }\n\n        // generate a random agent id\n        String id = null;\n        if (appName != null) {\n            // 如果有传 app name，则生成带 app name前缀的id，方便管理\n            id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n        } else {\n            id = RandomStringUtils.random(20, true, true).toUpperCase();\n        }\n\n        // agent传过来，则优先用 agent的\n        List<String> idList = parameters.get(URIConstans.ID);\n        if (idList != null && !idList.isEmpty()) {\n            id = idList.get(0);\n        }\n\n        String arthasVersion = null;\n        List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n        if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n            arthasVersion = arthasVersionList.get(0);\n        }\n\n        final String finalId = id;\n\n        // URI responseUri = new URI(\"response\", null, \"/\", \"method=\" + MethodConstants.AGENT_REGISTER + \"&id=\" + id, null);\n        URI responseUri = UriComponentsBuilder.newInstance()\n                .scheme(URIConstans.RESPONSE)\n                .path(\"/\")\n                .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n                .queryParam(URIConstans.ID, id)\n                .build()\n                .encode()\n                .toUri();\n\n        AgentInfo info = new AgentInfo();\n\n        // 前面可能有nginx代理\n        HttpHeaders headers = handshake.requestHeaders();\n        String host = HttpUtils.findClientIP(headers);\n\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n                info.setHost(inetSocketAddress.getHostString());\n                info.setPort(inetSocketAddress.getPort());\n            }\n        } else {\n            info.setHost(host);\n            Integer port = HttpUtils.findClientPort(headers);\n            if (port != null) {\n                info.setPort(port);\n            }\n        }\n\n        info.setChannelHandlerContext(ctx);\n        if (arthasVersion != null) {\n            info.setArthasVersion(arthasVersion);\n        }\n\n        tunnelServer.addAgent(id, info);\n        ctx.channel().closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {\n            @Override\n            public void operationComplete(Future<? super Void> future) throws Exception {\n                tunnelServer.removeAgent(finalId);\n            }\n        });\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "184", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect)\n            throws SSLException, URISyntaxException, InterruptedException {\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER);\n        queryEncoder.addParam(URIConstans.ARTHAS_VERSION, this.version);\n        if (appName != null) {\n            queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        }\n        if (id != null) {\n            queryEncoder.addParam(URIConstans.ID, id);\n        }\n        // ws://127.0.0.1:7777/ws?method=agentRegister\n        final URI agentRegisterURI = queryEncoder.toUri();\n\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = agentRegisterURI.getScheme() == null ? \"ws\" : agentRegisterURI.getScheme();\n        final String host = agentRegisterURI.getHost() == null ? \"127.0.0.1\" : agentRegisterURI.getHost();\n        final int port;\n        if (agentRegisterURI.getPort() == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else if (\"wss\".equalsIgnoreCase(scheme)) {\n                port = 443;\n            } else {\n                port = -1;\n            }\n        } else {\n            port = agentRegisterURI.getPort();\n        }\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\n                    \"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n        }\n\n        final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n        final SslContext sslCtx;\n        if (ssl) {\n            sslCtx = SslContextBuilder.forClient()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                    .build();\n        } else {\n            sslCtx = null;\n        }\n\n        WebSocketClientProtocolConfig clientProtocolConfig = WebSocketClientProtocolConfig.newBuilder()\n                .webSocketUri(agentRegisterURI)\n                .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH)\n                .build();\n\n        final WebSocketClientProtocolHandler websocketClientHandler =\n                new WebSocketClientProtocolHandler(clientProtocolConfig);\n        final TunnelClientSocketClientHandler handler =\n                new TunnelClientSocketClientHandler(TunnelClient.this);\n\n        Bootstrap bs = new Bootstrap();\n\n        bs.group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(host, port)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                                websocketClientHandler,\n                                new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                                handler\n                        );\n                    }\n                });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.cause() != null) {\n                        logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n                    }\n                }\n            });\n        }\n        connectFuture.sync();\n\n        return handler.registerFuture();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "185", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[] {\n            0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65,\n            0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x6d, 0x69, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74,\n            0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74,\n            0x20, 0x6c, 0x65, 0x74, 0x20, 0x6d, 0x79, 0x73, 0x65, 0x6c, 0x66, 0x0a, 0x43, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6d,\n            0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x73, 0x6f, 0x20, 0x6d, 0x75, 0x63, 0x68, 0x20, 0x6d, 0x69, 0x73,\n            0x65, 0x72, 0x79, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61,\n            0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x61, 0x79, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x59,\n            0x6f, 0x75, 0x20, 0x66, 0x65, 0x6c, 0x6c, 0x20, 0x73, 0x6f, 0x20, 0x68, 0x61, 0x72, 0x64, 0x0a, 0x0a, 0x49, 0x20,\n            0x76, 0x65, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x72, 0x64,\n            0x20, 0x77, 0x61, 0x79, 0x0a, 0x54, 0x6f, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x69,\n            0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x61, 0x72, 0x0a, 0x0a, 0x42, 0x65, 0x63,\n            0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72,\n            0x20, 0x73, 0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d,\n            0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75,\n            0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64,\n            0x20, 0x74, 0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66,\n            0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67,\n            0x65, 0x74, 0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20,\n            0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20,\n            0x74, 0x6f, 0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d,\n            0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f,\n            0x75, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n            0x6f, 0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x6c,\n            0x6f, 0x73, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x77, 0x61, 0x79, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x73,\n            0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72,\n            0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x74, 0x20, 0x6f, 0x75, 0x74, 0x0a,\n            0x49, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x72, 0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n            0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x20, 0x77,\n            0x65, 0x61, 0x6b, 0x6e, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x65, 0x79, 0x65,\n            0x73, 0x0a, 0x49, 0x20, 0x6d, 0x20, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6b,\n            0x65, 0x0a, 0x41, 0x20, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x2c, 0x20, 0x61, 0x20, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x20,\n            0x65, 0x76, 0x65, 0x72, 0x79, 0x64, 0x61, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66, 0x65,\n            0x0a, 0x4d, 0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x27, 0x74, 0x20, 0x70, 0x6f, 0x73,\n            0x73, 0x69, 0x62, 0x6c, 0x79, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x0a, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74,\n            0x20, 0x77, 0x61, 0x73, 0x6e, 0x27, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x77, 0x68, 0x6f, 0x6c, 0x65, 0x20, 0x74,\n            0x6f, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75,\n            0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x73,\n            0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74,\n            0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,\n            0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74,\n            0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65, 0x20,\n            0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65, 0x74,\n            0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f,\n            0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74, 0x6f,\n            0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d, 0x65, 0x2c,\n            0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f, 0x75, 0x6e,\n            0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75,\n            0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x77, 0x61, 0x74,\n            0x63, 0x68, 0x65, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x65, 0x0a, 0x49, 0x20, 0x68, 0x65, 0x61, 0x72,\n            0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x72, 0x79, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6e, 0x69, 0x67,\n            0x68, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x0a, 0x49, 0x20,\n            0x77, 0x61, 0x73, 0x20, 0x73, 0x6f, 0x20, 0x79, 0x6f, 0x75, 0x6e, 0x67, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x73, 0x68,\n            0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x62, 0x65, 0x74,\n            0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x65, 0x61, 0x6e, 0x20, 0x6f, 0x6e,\n            0x20, 0x6d, 0x65, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x6f, 0x75, 0x67,\n            0x68, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x59,\n            0x6f, 0x75, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x73, 0x61, 0x77, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x70, 0x61,\n            0x69, 0x6e, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x77, 0x20, 0x49, 0x20, 0x63, 0x72, 0x79, 0x20, 0x69, 0x6e,\n            0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,\n            0x6e, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x46, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20,\n            0x64, 0x61, 0x6d, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,\n            0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72,\n            0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65,\n            0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f,\n            0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,\n            0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65, 0x20, 0x73, 0x69,\n            0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x68,\n            0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a,\n            0x49, 0x20, 0x74, 0x72, 0x79, 0x20, 0x6d, 0x79, 0x20, 0x68, 0x61, 0x72, 0x64, 0x65, 0x73, 0x74, 0x20, 0x6a, 0x75,\n            0x73, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x6f, 0x72, 0x67, 0x65, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74,\n            0x68, 0x69, 0x6e, 0x67, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75,\n            0x0a, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74,\n            0x6f, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x20, 0x69,\n            0x6e, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20,\n            0x6d, 0x20, 0x61, 0x73, 0x68, 0x61, 0x6d, 0x65, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66,\n            0x65, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x73, 0x20, 0x65, 0x6d, 0x70, 0x74,\n            0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20,\n            0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20,\n            0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n            0x6f, 0x75, 0x0a, 0x2e, 0x2e, 0x2e, 0x0a, /*0x0a, 0x66, 0x6f, 0x72, 0x20, 0x6a, 0x75, 0x6c, 0x79, 0x0a, 0x0a,*/\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "186", "src_id": "M124", "code": "\n    @Override\n    public int read() throws IOException {\n        // Critical section because we're altering __bytesAvailable,\n        // __queueHead, and the contents of _queue in addition to\n        // testing value of __hasReachedEOF.\n        synchronized (__queue) {\n            while (true) {\n                if (__ioException != null) {\n                    IOException e = __ioException;\n                    __ioException = null;\n                    throw e;\n                }\n\n                if (__bytesAvailable == 0) {\n                    // Return EOF if at end of file\n                    if (__hasReachedEOF) {\n                        return EOF;\n                    }\n\n                    // Otherwise, we have to wait for queue to get something\n                    if (__threaded) {\n                        __queue.notify();\n                        try {\n                            __readIsWaiting = true;\n                            __queue.wait();\n                            __readIsWaiting = false;\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                        }\n                    } else {\n                        //__alreadyread = false;\n                        __readIsWaiting = true;\n                        int ch;\n                        boolean mayBlock = true; // block on the first read only\n\n                        do {\n                            try {\n                                if ((ch = __read(mayBlock)) < 0) { // must be EOF\n                                    if (ch != WOULD_BLOCK) {\n                                        return ch;\n                                    }\n                                }\n                            } catch (InterruptedIOException e) {\n                                synchronized (__queue) {\n                                    __ioException = e;\n                                    __queue.notifyAll();\n                                    try {\n                                        __queue.wait(100);\n                                    } catch (InterruptedException interrupted) {\n                                        // Ignored\n                                    }\n                                }\n                                return EOF;\n                            }\n\n                            try {\n                                if (ch != WOULD_BLOCK) {\n                                    __processChar(ch);\n                                }\n                            } catch (InterruptedException e) {\n                                if (__isClosed) {\n                                    return EOF;\n                                }\n                            }\n\n                            // Reads should not block on subsequent iterations. Potentially, this could happen if the\n                            // remaining buffered socket data consists entirely of Telnet command sequence and no \"user\" data.\n                            mayBlock = false;\n                        }\n                        // Continue reading as long as there is data available and the queue is not full.\n                        while (super.available() > 0 && __bytesAvailable < __queue.length - 1);\n\n                        __readIsWaiting = false;\n                    }\n                    continue;\n                } else {\n                    int ch = __queue[__queueHead];\n\n                    if (++__queueHead >= __queue.length) {\n                        __queueHead = 0;\n                    }\n                    --__bytesAvailable;\n\n                    // Need to explicitly notify() so available() works properly\n                    if (__bytesAvailable == 0 && __threaded) {\n                        __queue.notify();\n                    }\n\n                    return ch;\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "187", "src_id": "M786", "code": "\n    @Override\n    public void process(CommandProcess process) {\n        initTransformer();\n\n        RetransformModel retransformModel = new RetransformModel();\n        Instrumentation inst = process.session().getInstrumentation();\n\n        if (this.list) {\n            List<RetransformEntry> retransformEntryList = allRetransformEntries();\n            retransformModel.setRetransformEntries(retransformEntryList);\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.deleteAll) {\n            deleteAllRetransformEntry();\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.delete > 0) {\n            deleteRetransformEntry(this.delete);\n            process.end();\n            return;\n        } else if (this.classPattern != null) {\n            Set<Class<?>> searchClass = SearchUtils.searchClass(inst, classPattern, false, this.hashCode);\n            if (searchClass.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + classPattern);\n                return;\n            }\n            if (searchClass.size() > limit) {\n                process.end(\n                        -1,\n                        \"match classes size: \" + searchClass.size() + \", more than limit: \" + limit\n                                + \", It is recommended to use a more precise class pattern.\"\n                );\n            }\n            try {\n                inst.retransformClasses(searchClass.toArray(new Class[0]));\n                for (Class<?> clazz : searchClass) {\n                    retransformModel.addRetransformClass(clazz.getName());\n                }\n                process.appendResult(retransformModel);\n                process.end();\n                return;\n            } catch (Throwable e) {\n                String message = \"retransform error! \" + e.toString();\n                logger.error(message, e);\n                process.end(-1, message);\n                return;\n            }\n        }\n\n        for (String path : paths) {\n            File file = new File(path);\n            if (!file.exists()) {\n                process.end(-1, \"file does not exist, path:\" + path);\n                return;\n            }\n            if (!file.isFile()) {\n                process.end(-1, \"not a normal file, path:\" + path);\n                return;\n            }\n            if (file.length() >= MAX_FILE_SIZE) {\n                process.end(-1, \"file size: \" + file.length() + \" >= \" + MAX_FILE_SIZE + \", path: \" + path);\n                return;\n            }\n        }\n\n        Map<String, byte[]> bytesMap = new HashMap<String, byte[]>();\n        for (String path : paths) {\n            RandomAccessFile f = null;\n            try {\n                f = new RandomAccessFile(path, \"r\");\n                final byte[] bytes = new byte[(int) f.length()];\n                f.readFully(bytes);\n\n                final String clazzName = readClassName(bytes);\n\n                bytesMap.put(clazzName, bytes);\n\n            } catch (Exception e) {\n                logger.warn(\"load class file failed: \" + path, e);\n                process.end(-1, \"load class file failed: \" + path + \", error: \" + e);\n                return;\n            } finally {\n                if (f != null) {\n                    try {\n                        f.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        }\n\n        if (bytesMap.size() != paths.size()) {\n            process.end(-1, \"paths may contains same class name!\");\n            return;\n        }\n\n        List<RetransformEntry> retransformEntryList = new ArrayList<RetransformEntry>();\n        List<Class<?>> classList = new ArrayList<Class<?>>();\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (bytesMap.containsKey(clazz.getName())) {\n                if (hashCode == null && classLoaderClass != null) {\n                    List<ClassLoader> matchedClassLoaders = ClassLoaderUtils.getClassLoaderByClassName(inst, classLoaderClass);\n                    if (matchedClassLoaders.size() == 1) {\n                        hashCode = Integer.toHexString(matchedClassLoaders.get(0).hashCode());\n                    } else if (matchedClassLoaders.size() > 1) {\n                        Collection<ClassLoaderVO> classLoaderVOList = ClassUtils.createClassLoaderVOList(matchedClassLoaders);\n                        retransformModel.setClassLoaderClass(classLoaderClass)\n                                .setMatchedClassLoaders(classLoaderVOList);\n                        process.appendResult(retransformModel);\n                        process.end(\n                                -1,\n                                \"Found more than one classloader by class name, please specify classloader with '-c <classloader hash>'\"\n                        );\n                        return;\n                    } else {\n                        process.end(-1, \"Can not find classloader by class name: \" + classLoaderClass + \".\");\n                        return;\n                    }\n                }\n\n                ClassLoader classLoader = clazz.getClassLoader();\n                if (classLoader != null && hashCode != null\n                        && !Integer.toHexString(classLoader.hashCode()).equals(hashCode)) {\n                    continue;\n                }\n\n                RetransformEntry retransformEntry = new RetransformEntry(\n                        clazz.getName(),\n                        bytesMap.get(clazz.getName()),\n                        hashCode,\n                        classLoaderClass\n                );\n                retransformEntryList.add(retransformEntry);\n                classList.add(clazz);\n                retransformModel.addRetransformClass(clazz.getName());\n\n                logger.info(\"Try retransform class name: {}, ClassLoader: {}\", clazz.getName(), clazz.getClassLoader());\n            }\n        }\n\n        try {\n            if (retransformEntryList.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + bytesMap.keySet());\n                return;\n            }\n            addRetransformEntry(retransformEntryList);\n\n            inst.retransformClasses(classList.toArray(new Class[0]));\n\n            process.appendResult(retransformModel);\n            process.end();\n        } catch (Throwable e) {\n            String message = \"retransform error! \" + e.toString();\n            logger.error(message, e);\n            process.end(-1, message);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "188", "src_id": "M278", "code": "\n    V get(Object key, int hash) {\n        if (count != 0) { // read-volatile\n            HashEntry<K, V> e = getFirst(hash);\n            while (e != null) {\n                if (e.hash == hash && keyEq(key, e.key())) {\n                    Object opaque = e.valueRef;\n                    if (opaque != null) {\n                        return e.dereferenceValue(opaque);\n                    }\n                    return readValueUnderLock(e); // recheck\n                }\n                e = e.next;\n            }\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "189", "src_id": "M184", "code": "\n    @Override\n    protected void initChannel(LocalChannel ch) {\n        ChannelPipeline p = ch.pipeline();\n        p.addLast(\n                new HttpClientCodec(),\n                new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                new HttpProxyClientHandler(httpResponsePromise)\n        );\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "190", "src_id": "M1539", "code": "\n    @Override\n    public void onError(Throwable t) {\n        Status s = Status.fromThrowable(t);\n        sendResponse.writeError(s);\n        latch.countDown();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "191", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n        Map<String, String> map = new HashMap<>();\n        for (String key : trailer.keys()) {\n            if (EXCLUDED.contains(key.toLowerCase())) {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                map.put(key, new String(value));\n            } else {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                map.put(key, value);\n            }\n        }\n        return map;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "192", "src_id": "M1553", "code": "\n    public byte[] getPrefix(byte[] in, Type type) {\n        int len = in.length;\n        return new byte[] {\n            type.value,\n            (byte) ((len >> 24) & 0xff),\n            (byte) ((len >> 16) & 0xff),\n            (byte) ((len >> 8) & 0xff),\n            (byte) ((len >> 0) & 0xff),\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "193", "src_id": "M1538", "code": "\n    private Method getRpcMethod(Object stub, String rpcMethodName) {\n        for (Method m : stub.getClass().getMethods()) {\n            if (m.getName().equals(rpcMethodName)) {\n                return m;\n            }\n        }\n        throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "194", "src_id": "M1535", "code": "\n    private Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n        // pathInfo starts with \"/\". ignore that first char.\n        String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n        if (rpcClassAndMethodTokens.length != 2) {\n            throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n        }\n        String rpcClassName = rpcClassAndMethodTokens[0];\n        String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n        String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n        return new Pair<>(rpcClassName, rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "195", "src_id": "M1530", "code": "\n    @Override\n    public boolean isEndOfInput() throws Exception {\n        if (input.isEndOfInput()) {\n            // Only end of input after last HTTP chunk has been sent\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "196", "src_id": "M1643", "code": "\n    public void start() throws InterruptedException {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup work = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new NettyHttpInitializer(this.STATIC_LOCATION))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n\n            logger.info(\"start http server on port: {}\", port);\n            ChannelFuture future = serverBootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            work.shutdownGracefully();\n            boss.shutdownGracefully();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "197", "src_id": "M1614", "code": "\n    private boolean isExclude(Class<?> clazz) {\n        if (this.classNameExcludeMatcher != null) {\n            return classNameExcludeMatcher.matching(clazz.getName());\n        }\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "198", "src_id": "M1632", "code": "\n    public void parseRequestParams(WatchRequest watchRequest) {\n        this.classPattern = watchRequest.getClassPattern();\n        this.methodPattern = watchRequest.getMethodPattern();\n        if (StringUtils.isEmpty(watchRequest.getExpress())) {\n            this.express = \"{params, target, returnObj}\";\n        } else {\n            this.express = watchRequest.getExpress();\n        }\n        this.conditionExpress = watchRequest.getConditionExpress();\n        this.isBefore = watchRequest.getIsBefore();\n        this.isFinish = watchRequest.getIsFinish();\n        this.isException = watchRequest.getIsException();\n        this.isSuccess = watchRequest.getIsSuccess();\n        if (!watchRequest.getIsBefore() && !watchRequest.getIsFinish()\n                && !watchRequest.getIsException() && !watchRequest.getIsSuccess()) {\n            this.isFinish = true;\n        }\n        if (watchRequest.getExpand() <= 0) {\n            this.expand = 1;\n        } else if (watchRequest.getExpand() > MAX_EXPAND) {\n            this.expand = MAX_EXPAND;\n        } else {\n            this.expand = watchRequest.getExpand();\n        }\n        if (watchRequest.getSizeLimit() == 0) {\n            this.sizeLimit = 10 * 1024 * 1024;\n        } else {\n            this.sizeLimit = watchRequest.getSizeLimit();\n        }\n        this.isRegEx = watchRequest.getIsRegEx();\n        if (watchRequest.getNumberOfLimit() == 0) {\n            this.numberOfLimit = 100;\n        } else {\n            this.numberOfLimit = watchRequest.getNumberOfLimit();\n        }\n        if (watchRequest.getExcludeClassPattern().equals(\"\")) {\n            this.excludeClassPattern = null;\n        } else {\n            this.excludeClassPattern = watchRequest.getExcludeClassPattern();\n        }\n        this.listenerId = watchRequest.getListenerId();\n        this.verbose = watchRequest.getVerbose();\n        if (watchRequest.getMaxNumOfMatchedClass() == 0) {\n            this.maxNumOfMatchedClass = 50;\n        } else {\n            this.maxNumOfMatchedClass = watchRequest.getMaxNumOfMatchedClass();\n        }\n        this.jobId = watchRequest.getJobId();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "199", "src_id": "M1616", "code": "\n    public synchronized EnhancerAffect enhance(final Instrumentation inst, int maxNumOfMatchedClass) throws UnmodifiableClassException {\n        // 获取需要增强的类集合\n        this.matchingClasses = GlobalOptions.isDisableSubClass\n            ? SearchUtils.searchClass(inst, classNameMatcher)\n            : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n        if (matchingClasses.size() > maxNumOfMatchedClass) {\n            affect.setOverLimitMsg(\n                \"The number of matched classes is \" + matchingClasses.size() + \", greater than the limit value \"\n                + maxNumOfMatchedClass + \". Try to change the limit with option '-m <arg>'.\"\n            );\n            return affect;\n        }\n        // 过滤掉无法被增强的类\n        List<Pair<Class<?>, String>> filtedList = filter(matchingClasses);\n        if (!filtedList.isEmpty()) {\n            for (Pair<Class<?>, String> filted : filtedList) {\n                logger.info(\"ignore class: {}, reason: {}\", filted.getFirst().getName(), filted.getSecond());\n            }\n        }\n\n        logger.info(\"enhance matched classes: {}\", matchingClasses);\n\n        affect.setTransformer(this);\n\n        try {\n            DemoBootstrap.getRunningInstance().getTransformerManager().addTransformer(this, isTracing);\n\n            // 批量增强\n            if (GlobalOptions.isBatchReTransform) {\n                final int size = matchingClasses.size();\n                final Class<?>[] classArray = new Class<?>[size];\n                arraycopy(matchingClasses.toArray(), 0, classArray, 0, size);\n                if (classArray.length > 0) {\n                    inst.retransformClasses(classArray);\n                    logger.info(\"Success to batch transform classes: \" + Arrays.toString(classArray));\n                }\n            } else {\n                // for each 增强\n                for (Class<?> clazz : matchingClasses) {\n                    try {\n                        inst.retransformClasses(clazz);\n                        logger.info(\"Success to transform class: \" + clazz);\n                    } catch (Throwable t) {\n                        logger.warn(\"retransform {} failed.\", clazz, t);\n                        if (t instanceof UnmodifiableClassException) {\n                            throw (UnmodifiableClassException) t;\n                        } else if (t instanceof RuntimeException) {\n                            throw (RuntimeException) t;\n                        } else {\n                            throw new RuntimeException(t);\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n            affect.setThrowable(e);\n        }\n\n        return affect;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "200", "src_id": "M1579", "code": "\n    public static ComplexObject createComplexObject() {\n        // 创建一个 ComplexObject 对象\n        ComplexObject complexObject = new ComplexObject();\n\n        // 设置基本类型的值\n        complexObject.setId(1);\n        complexObject.setName(\"Complex Object\");\n        complexObject.setValue(3.14);\n\n        // 设置基本类型的数组\n        int[] numbers = {1, 2, 3, 4, 5};\n        complexObject.setNumbers(numbers);\n\n        Long[] longNumbers = {10086l, 10087l, 10088l, 10089l, 10090l, 10091l};\n        complexObject.setLongNumbers(longNumbers);\n\n        // 创建并设置嵌套对象\n        ComplexObject.NestedObject nestedObject = new ComplexObject.NestedObject();\n        nestedObject.setNestedId(10);\n        nestedObject.setNestedName(\"Nested Object\");\n        nestedObject.setFlag(true);\n        complexObject.setNestedObject(nestedObject);\n\n        List<String> stringList = new ArrayList<>();\n        stringList.add(\"foo\");\n        stringList.add(\"bar\");\n        stringList.add(\"baz\");\n        complexObject.setStringList(stringList);\n\n        Map<String, Integer> stringIntegerMap = new HashMap<>();\n        stringIntegerMap.put(\"one\", 1);\n        stringIntegerMap.put(\"two\", 2);\n        complexObject.setStringIntegerMap(stringIntegerMap);\n\n        complexObject.setDoubleArray(new Double[]{1.0, 2.0, 3.0});\n\n        complexObject.setComplexArray(null);\n\n        complexObject.setCollection(Arrays.asList(\"element1\", \"element2\"));\n\n        // 创建并设置复杂对象数组\n        ComplexObject[] complexArray = new ComplexObject[2];\n\n        ComplexObject complexObject1 = new ComplexObject();\n        complexObject1.setId(2);\n        complexObject1.setName(\"Complex Object 1\");\n        complexObject1.setValue(2.71);\n\n        ComplexObject complexObject2 = new ComplexObject();\n        complexObject2.setId(3);\n        complexObject2.setName(\"Complex Object 2\");\n        complexObject2.setValue(1.618);\n\n        complexArray[0] = complexObject1;\n        complexArray[1] = complexObject2;\n\n        complexObject.setComplexArray(complexArray);\n\n        // 创建并设置多维数组\n        int[][] multiDimensionalArray = {{1, 2, 3}, {4, 5, 6}};\n        complexObject.setMultiDimensionalArray(multiDimensionalArray);\n\n        // 设置数组中的基本元素数组\n        String[] stringArray = {\"Hello\", \"World\"};\n        complexObject.setStringArray(stringArray);\n\n        // 输出 ComplexObject 对象的信息\n        System.out.println(complexObject);\n\n        return complexObject;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "201", "src_id": "M1644", "code": "\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws URISyntaxException, IOException {\n        // 获取URI\n        String uri = new URI(request.uri()).getPath();\n        // 设置不支持favicon.ico文件\n        if (\"/favicon.ico\".equals(uri)) {\n            return;\n        }\n        if (\"/\".equals(uri)) {\n            uri = \"/index.html\";\n        }\n        // 根据路径地址构建文件\n        String path = Paths.get(this.STATIC_LOCATION, uri).toString();\n        File file = new File(path);\n        // 状态为1xx的话，继续请求\n        if (HttpUtil.is100ContinueExpected(request)) {\n            send100Continue(ctx);\n        }\n        // 当文件隐藏/不存在/是目录/非文件的时候，将资源指向NOT_FOUND\n        if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n            sendNotFound(ctx);\n            return;\n        }\n        final RandomAccessFile randomAccessFile;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n        } catch (FileNotFoundException e) {\n            sendNotFound(ctx);\n            throw new RuntimeException(e);\n        }\n        HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n\n        // 设置文件格式内容\n        if (path.endsWith(\".html\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=UTF-8\");\n        } else if (path.endsWith(\".js\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-javascript\");\n        } else if (path.endsWith(\".css\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/css; charset=UTF-8\");\n        } else {\n            MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap();\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, mimetypesFileTypeMap.getContentType(path));\n        }\n\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n\n        if (keepAlive) {\n            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, randomAccessFile.length());\n            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        }\n        ctx.write(response);\n\n        ChannelFuture sendFileFuture;\n        ChannelFuture lastContentFuture;\n        if (ctx.pipeline().get(SslHandler.class) == null) {\n            sendFileFuture = ctx.write(\n                new DefaultFileRegion(randomAccessFile.getChannel(), 0, randomAccessFile.length()),\n                ctx.newProgressivePromise()\n            );\n            // Write the end marker.\n            lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n        } else {\n            sendFileFuture = ctx.writeAndFlush(\n                new HttpChunkedInput(\n                    new ChunkedFile(randomAccessFile, 0, randomAccessFile.length(), 10 * 1024 * 1024)\n                ),\n                ctx.newProgressivePromise()\n            );\n            // HttpChunkedInput will write the end marker (LastHttpContent) for us.\n            lastContentFuture = sendFileFuture;\n        }\n\n        sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n            @Override\n            public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n                if (total < 0) { // total unknown\n                    logger.info(future.channel() + \" Transfer progress: \" + progress);\n                } else {\n                    logger.info(future.channel() + \" Transfer progress: \" + progress + \" / \" + total);\n                }\n            }\n\n            @Override\n            public void operationComplete(ChannelProgressiveFuture future) {\n                logger.info(future.channel() + \" Transfer complete.\");\n            }\n        });\n\n        // Decide whether to close the connection or not.\n        if (!HttpUtil.isKeepAlive(request)) {\n            // Close the connection when the whole content is written out.\n            lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "202", "src_id": "M1580", "code": "\n    @Override\n    public void query(ObjectQuery query, StreamObserver<ObjectQueryResult> responseObserver) {\n        if (vmTool == null) {\n            throw Status.UNAVAILABLE.withDescription(\"vmtool can not work\").asRuntimeException();\n        }\n        ArthasStreamObserver<ObjectQueryResult> arthasStreamObserver =\n            new ArthasStreamObserverImpl<>(responseObserver, null, grpcJobController);\n        String className = query.getClassName();\n        String classLoaderHash = query.getClassLoaderHash();\n        String classLoaderClass = query.getClassLoaderClass();\n        int limit = query.getLimit();\n        int depth = query.getDepth();\n        String express = query.getExpress();\n        String resultExpress = query.getResultExpress();\n\n        // 如果只传递了 class name 参数，则jvm 里可能有多个同名的 class，需要全部查找\n        if (isEmpty(classLoaderHash) && isEmpty(classLoaderClass)) {\n            List<Class<?>> foundClassList = new ArrayList<>();\n            for (Class<?> clazz : inst.getAllLoadedClasses()) {\n                if (clazz.getName().equals(className)) {\n                    foundClassList.add(clazz);\n                }\n            }\n\n            // 没找到\n            if (foundClassList.size() == 0) {\n                arthasStreamObserver.onNext(\n                    ObjectQueryResult.newBuilder().setSuccess(false)\n                        .setMessage(\"can not find class: \" + className).build()\n                );\n                arthasStreamObserver.onCompleted();\n                return;\n            } else if (foundClassList.size() > 1) {\n                String message = \"found more than one class: \" + className;\n                arthasStreamObserver.onNext(\n                    ObjectQueryResult.newBuilder().setSuccess(false).setMessage(message).build()\n                );\n                arthasStreamObserver.onCompleted();\n                return;\n            } else { // 找到了指定的 类\n                Object[] instances = vmTool.getInstances(foundClassList.get(0), limit);\n                Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n                // 这里尝试使用express\n                Object value = null;\n                if (!isEmpty(express)) {\n                    Express unpooledExpress = ExpressFactory.unpooledExpress(foundClassList.get(0).getClassLoader());\n                    try {\n                        value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n                    } catch (ExpressException e) {\n                        logger.warn(\"ognl: failed execute express: \" + express, e);\n                    }\n                }\n                if (value != null && !isEmpty(resultExpress)) {\n                    try {\n                        value = ExpressFactory.threadLocalExpress(value)\n                            .bind(Constants.COST_VARIABLE, 0.0)\n                            .get(resultExpress);\n                    } catch (ExpressException e) {\n                        logger.warn(\"ognl: failed execute result express: \" + express, e);\n                    }\n                }\n                JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n                builder.addObjects(javaObject);\n                arthasStreamObserver.onNext(builder.build());\n                arthasStreamObserver.onCompleted();\n                return;\n            }\n        }\n\n        // 有指定 classloader hash 或者 classloader className\n\n        Class<?> foundClass = null;\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (!clazz.getName().equals(className)) {\n                continue;\n            }\n\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            if (classLoader == null) {\n                continue;\n            }\n\n            if (!isEmpty(classLoaderHash)) {\n                String hex = Integer.toHexString(classLoader.hashCode());\n                if (classLoaderHash.equals(hex)) {\n                    foundClass = clazz;\n                    break;\n                }\n            }\n\n            if (!isEmpty(classLoaderClass) && classLoaderClass.equals(classLoader.getClass().getName())) {\n                foundClass = clazz;\n                break;\n            }\n        }\n        // 没找到类\n        if (foundClass == null) {\n            arthasStreamObserver.onNext(\n                ObjectQueryResult.newBuilder().setSuccess(false)\n                    .setMessage(\"can not find class: \" + className).build()\n            );\n            arthasStreamObserver.onCompleted();\n            return;\n        }\n\n        Object[] instances = vmTool.getInstances(foundClass, limit);\n        Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n\n        Object value = null;\n        if (!isEmpty(express)) {\n            Express unpooledExpress = ExpressFactory.unpooledExpress(foundClass.getClassLoader());\n            try {\n                value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n            } catch (ExpressException e) {\n                logger.warn(\"ognl: failed execute express: \" + express, e);\n            }\n        }\n        if (value != null && !isEmpty(resultExpress)) {\n            try {\n                value = ExpressFactory.threadLocalExpress(value)\n                    .bind(Constants.COST_VARIABLE, 0.0)\n                    .get(resultExpress);\n            } catch (ExpressException e) {\n                logger.warn(\"ognl: failed execute result express: \" + express, e);\n            }\n        }\n        JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n        builder.addObjects(javaObject);\n        arthasStreamObserver.onNext(builder.build());\n        arthasStreamObserver.onCompleted();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "203", "src_id": "M1566", "code": "\n    public GrpcResultViewResolver registerView(GrpcResultView view) {\n        Class modelClass = getModelClass(view);\n        if (modelClass == null) {\n            throw new NullPointerException(\"model class is null\");\n        }\n        return this.registerView(modelClass, view);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "204", "src_id": "M1613", "code": "\n    private List<Pair<Class<?>, String>> filter(Set<Class<?>> classes) {\n        List<Pair<Class<?>, String>> filteredClasses = new ArrayList<Pair<Class<?>, String>>();\n        final Iterator<Class<?>> it = classes.iterator();\n        while (it.hasNext()) {\n            final Class<?> clazz = it.next();\n            boolean removeFlag = false;\n            if (clazz == null) {\n                removeFlag = true;\n            }\n//            else if (isSelf(clazz)) {\n//                filteredClasses.add(new Pair<Class<?>, String>(clazz, \"class loaded by arthas itself\"));\n//                removeFlag = true;\n//            }\n            else if (isUnsafeClass(clazz)) {\n                filteredClasses.add(new Pair<Class<?>, String>(\n                    clazz,\n                    \"class loaded by Bootstrap Classloader, try to execute `options unsafe true`\"\n                ));\n                removeFlag = true;\n            } else if (isExclude(clazz)) {\n                filteredClasses.add(new Pair<Class<?>, String>(clazz, \"class is excluded\"));\n                removeFlag = true;\n            } else {\n                Pair<Boolean, String> unsupportedResult = isUnsupportedClass(clazz);\n                if (unsupportedResult.getFirst()) {\n                    filteredClasses.add(new Pair<Class<?>, String>(clazz, unsupportedResult.getSecond()));\n                    removeFlag = true;\n                }\n            }\n            if (removeFlag) {\n                it.remove();\n            }\n        }\n        return filteredClasses;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "205", "src_id": "M1594", "code": "\n    @Override\n    public void atInvokeException(Class<?> clazz, String invokeInfo, Object target, Throwable throwable) {\n        ClassLoader classLoader = clazz.getClassLoader();\n        String[] info = StringUtils.splitInvokeInfo(invokeInfo);\n        String owner = info[0];\n        String methodName = info[1];\n        String methodDesc = info[2];\n\n        List<AdviceListener> listeners =\n            com.taobao.arthas.grpcweb.grpc.service.advisor.AdviceListenerManager\n                .queryTraceAdviceListeners(classLoader, clazz.getName(), owner, methodName, methodDesc);\n\n        if (listeners != null) {\n            for (AdviceListener adviceListener : listeners) {\n                try {\n                    if (skipAdviceListener(adviceListener)) {\n                        continue;\n                    }\n                    final InvokeTraceable listener = (InvokeTraceable) adviceListener;\n                    listener.invokeThrowTracing(classLoader, owner, methodName, methodDesc, Integer.parseInt(info[3]));\n                } catch (Throwable e) {\n                    logger.error(\"class: {}, invokeInfo: {}\", clazz.getName(), invokeInfo, e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "206", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "207", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "208", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "209", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "210", "src_id": "M1105", "code": "\n    @Override\n    public void onSuspend(Job job) {\n        if (!job.isRunInBackground()) {\n            resetAndReadLine();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "211", "src_id": "M1106", "code": "\n    private void resetAndReadLine() {\n        // reset stdin handler to echo handler\n        // shell.term().stdinHandler(null);\n        shell.setForegroundJob(null);\n        shell.readline();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "212", "src_id": "M504", "code": "\n    private void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n        for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n            String objectName = entry.getKey();\n            List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n            TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n            table.row(true, \"OBJECT_NAME\", objectName);\n            table.row(true, label(\"NAME\").style(Decoration.bold.bold()),\n                    label(\"VALUE\").style(Decoration.bold.bold()));\n\n            for (MBeanAttributeVO attributeVO : attributeVOList) {\n                String attributeName = attributeVO.getName();\n                String valueStr;\n                if (attributeVO.getError() != null) {\n                    valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n                } else {\n                    // convert array to list\n                    // TODO support all array type\n                    Object value = attributeVO.getValue();\n                    if (value instanceof String[]) {\n                        value = Arrays.asList((String[]) value);\n                    } else if (value instanceof Integer[]) {\n                        value = Arrays.asList((Integer[]) value);\n                    } else if (value instanceof Long[]) {\n                        value = Arrays.asList((Long[]) value);\n                    } else if (value instanceof int[]) {\n                        value = convertArrayToList((int[]) value);\n                    } else if (value instanceof long[]) {\n                        value = convertArrayToList((long[]) value);\n                    }\n                    // to string\n                    valueStr = String.valueOf(value);\n                }\n                table.row(attributeName, valueStr);\n            }\n            process.write(RenderUtil.render(table, process.width()));\n            process.write(\"\\n\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "213", "src_id": "M1157", "code": "\n    private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n        DefaultFullHttpResponse fullResp = null;\n        InputStream in = null;\n        try {\n            URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n            if (res != null) {\n                fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n                in = res.openStream();\n                byte[] tmp = new byte[256];\n                for (int l = 0; l != -1; l = in.read(tmp)) {\n                    fullResp.content().writeBytes(tmp, 0, l);\n                }\n                int li = path.lastIndexOf('.');\n                if (li != -1 && li != path.length() - 1) {\n                    String ext = path.substring(li + 1);\n                    String contentType;\n                    if (\"html\".equals(ext)) {\n                        contentType = \"text/html\";\n                    } else if (\"js\".equals(ext)) {\n                        contentType = \"application/javascript\";\n                    } else if (\"css\".equals(ext)) {\n                        contentType = \"text/css\";\n                    } else {\n                        contentType = null;\n                    }\n\n                    if (contentType != null) {\n                        fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                    }\n                }\n            }\n        } finally {\n            IOUtils.close(in);\n        }\n        return fullResp;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "214", "src_id": "M381", "code": "\n    @Override\n    public List<ResultModel> pollResults() {\n        try {\n            lastAccessTime = System.currentTimeMillis();\n            long accessTime = lastAccessTime;\n            if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                polling = true;\n                sendingItemCount = 0;\n                long firstResultTime = 0;\n                // sending delay: time elapsed after firstResultTime\n                long sendingDelay = 0;\n                // waiting time: time elapsed after access\n                long waitingTime = 0;\n                List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n                while (!closed\n                        && sendingResults.size() < resultBatchSizeLimit\n                        && sendingDelay < 100\n                        && waitingTime < pollTimeLimit) {\n                    ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                    if (aResult != null) {\n                        sendingResults.add(aResult);\n                        // 是否为第一次获取到数据\n                        if (firstResultTime == 0) {\n                            firstResultTime = System.currentTimeMillis();\n                        }\n                        // 判断是否需要立即发送出去\n                        if (shouldFlush(sendingResults, aResult)) {\n                            break;\n                        }\n                    } else {\n                        if (firstResultTime > 0) {\n                            // 获取到部分数据后，队列已经取完，计算发送延时时间\n                            sendingDelay = System.currentTimeMillis() - firstResultTime;\n                        }\n                        // 计算总共等待时间，长轮询最大等待时间\n                        waitingTime = System.currentTimeMillis() - accessTime;\n                    }\n                }\n\n                // resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n                }\n                return sendingResults;\n            }\n        } catch (InterruptedException e) {\n            // e.printStackTrace();\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lastAccessTime = System.currentTimeMillis();\n                polling = false;\n                lock.unlock();\n            }\n        }\n        return Collections.emptyList();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "215", "src_id": "M519", "code": "\n    @Override\n    public void draw(CommandProcess process, DashboardModel result) {\n        int width = process.width();\n        int height = process.height();\n\n        // 上半部分放thread top。下半部分再切分为田字格，其中上面两格放memory, gc的信息。下面两格放tomcat,\n        // runtime的信息\n        int totalHeight = height - 1;\n        int threadTopHeight;\n        if (totalHeight <= 24) {\n            // 总高度较小时取1/2\n            threadTopHeight = totalHeight / 2;\n        } else {\n            // 总高度较大时取1/3，但不少于上面的值(24/2=12)\n            threadTopHeight = totalHeight / 3;\n            if (threadTopHeight < 12) {\n                threadTopHeight = 12;\n            }\n        }\n        int lowerHalf = totalHeight - threadTopHeight;\n\n        // Memory至少保留8行, 显示metaspace信息\n        int memoryInfoHeight = lowerHalf / 2;\n        if (memoryInfoHeight < 8) {\n            memoryInfoHeight = Math.min(8, lowerHalf);\n        }\n\n        // runtime\n        TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n        // tomcat\n        TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n        int runtimeInfoHeight = Math.max(runtimeInfoTable.getRows().size(), tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size());\n        if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n            // 如果runtimeInfo高度有剩余，则增大MemoryInfo的高度\n            memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n        } else {\n            runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n        }\n\n        // 如果MemoryInfo高度有剩余，则增大ThreadHeight\n        int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n        memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n        threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n        String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n        String memoryAndGc = drawMemoryInfoAndGcInfo(result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n        String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n\n        process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "216", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                    .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                    .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.classLoader)))\n                    .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                    .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.additivity)))\n                    .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                            label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                            label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash),\n                            label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target),\n                                label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking),\n                                label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef),\n                                label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "217", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = false;\n        if (session.get(ONETIME_SESSION_KEY) != null) {\n            oneTimeAccess = true;\n        }\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse();\n            response.setSessionId(session.getSessionId())\n                    .setBody(body);\n\n            if (!session.tryLock()) {\n                response.setState(ApiState.REFUSED)\n                        .setMessage(\"Another command is executing.\");\n                return response;\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    response.setState(ApiState.REFUSED)\n                            .setMessage(\"Another job is running.\");\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response;\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                // distribute result message both to origin session channel and request channel by CompositeResultDistributor\n                // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n\n            } catch (Throwable e) {\n                logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n                response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            // wait for job completed or timeout\n            Integer timeout = apiRequest.getExecTimeout();\n            if (timeout == null || timeout <= 0) {\n                timeout = DEFAULT_EXEC_TIMEOUT;\n            }\n            boolean timeExpired = !waitForJob(job, timeout);\n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            // packing results\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            response.setSessionId(session.getSessionId())\n                    // .setConsumerId(consumerId)\n                    .setBody(body);\n            return response;\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "218", "src_id": "M494", "code": "\n    private void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n        callback.callback(deep, isLast, prefix, node);\n        if (!isLeaf(node)) {\n            List<TraceNode> children = node.getChildren();\n            if (children == null) {\n                return;\n            }\n            final int size = children.size();\n            for (int index = 0; index < size; index++) {\n                final boolean isLastFlag = index == size - 1;\n                final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n                recursive(\n                        deep + 1,\n                        isLastFlag,\n                        currentPrefix,\n                        children.get(index),\n                        callback\n                );\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "219", "src_id": "M474", "code": "\n    private static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n        if (parentClassLoader.getChildren() == null) {\n            return;\n        }\n        for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n            TreeElement child = new TreeElement(childClassLoader.getName());\n            parent.addChild(child);\n            renderSubtree(child, childClassLoader);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "220", "src_id": "M1539", "code": "\n    @Override\n    public void onError(Throwable t)\n    {\n        Status s = Status.fromThrowable(t);\n        sendResponse.writeError(s);\n        latch.countDown();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "221", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer)\n    {\n        Map<String, String> map = new HashMap<>();\n        for (String key : trailer.keys())\n        {\n            if (EXCLUDED.contains(key.toLowerCase()))\n            {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX))\n            {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                map.put(key, new String(value));\n            }\n            else\n            {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                map.put(key, value);\n            }\n        }\n        return map;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "222", "src_id": "M1553", "code": "\n    public byte[] getPrefix(byte[] in, Type type)\n    {\n        int len = in.length;\n        return new byte[] {\n            type.value,\n            (byte) ((len >> 24) & 0xff),\n            (byte) ((len >> 16) & 0xff),\n            (byte) ((len >> 8) & 0xff),\n            (byte) ((len >> 0) & 0xff),\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "223", "src_id": "M1538", "code": "\n    private Method getRpcMethod(Object stub, String rpcMethodName)\n    {\n        for (Method m : stub.getClass().getMethods())\n        {\n            if (m.getName().equals(rpcMethodName))\n            {\n                return m;\n            }\n        }\n        throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "224", "src_id": "M1535", "code": "\n    private Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException\n    {\n        // pathInfo starts with \"/\". ignore that first char.\n        String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n        if (rpcClassAndMethodTokens.length != 2)\n        {\n            throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n        }\n\n        String rpcClassName = rpcClassAndMethodTokens[0];\n        String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n        String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n        return new Pair<>(rpcClassName, rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "225", "src_id": "M1530", "code": "\n    @Override\n    public boolean isEndOfInput() throws Exception\n    {\n        if (input.isEndOfInput())\n        {\n            // Only end of input after last HTTP chunk has been sent\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "226", "src_id": "M308", "code": "\n    HashEntry<K, V> nextEntry() {\n        do {\n            if (nextEntry == null) {\n                throw new NoSuchElementException();\n            }\n\n            lastReturned = nextEntry;\n            currentKey = lastReturned.key();\n            advance();\n        } while (currentKey == null); // Skip GC'd keys\n\n        return lastReturned;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "227", "src_id": "M1284", "code": "\n    @AtInvoke(name = \"\", inline = true, whenComplete = false, excludes = \"java.**\")\n    public static void onInvoke(@Binding.This Object target, @Binding.Class Class<?> clazz,\n                               @Binding.InvokeInfo String invokeInfo) {\n        SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "228", "src_id": "M947", "code": "\n    public void loggers(CommandProcess process) {\n        Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<>();\n\n        // 如果不指定 classloader，则打印所有 classloader 里的 logger 信息\n        for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n            String className = clazz.getName();\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            // if special classloader\n            if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) {\n                continue;\n            }\n\n            if (classLoader != null) {\n                LoggerTypes loggerTypes = classLoaderLoggerMap.get(classLoader);\n                if (loggerTypes == null) {\n                    loggerTypes = new LoggerTypes();\n                    classLoaderLoggerMap.put(classLoader, loggerTypes);\n                }\n                updateLoggerType(loggerTypes, classLoader, className);\n            }\n        }\n\n        for (Map.Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n            ClassLoader classLoader = entry.getKey();\n            LoggerTypes loggerTypes = entry.getValue();\n\n            if (loggerTypes.contains(LoggerType.LOG4J)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4jHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n\n            if (loggerTypes.contains(LoggerType.LOGBACK)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, LogbackHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n\n            if (loggerTypes.contains(LoggerType.LOG4J2)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4j2Helper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n        }\n\n        process.end();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "229", "src_id": "M249", "code": "\n    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) throws URISyntaxException {\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n\n        String appName = null;\n        List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n        if (appNameList != null && !appNameList.isEmpty()) {\n            appName = appNameList.get(0);\n        }\n\n        // generate a random agent id\n        String id;\n        if (appName != null) {\n            // 如果有传 app name，则生成带 app name前缀的id，方便管理\n            id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n        } else {\n            id = RandomStringUtils.random(20, true, true).toUpperCase();\n        }\n        // agent传过来，则优先用 agent的\n        List<String> idList = parameters.get(URIConstans.ID);\n        if (idList != null && !idList.isEmpty()) {\n            id = idList.get(0);\n        }\n\n        String arthasVersion = null;\n        List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n        if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n            arthasVersion = arthasVersionList.get(0);\n        }\n\n        final String finalId = id;\n\n        URI responseUri = UriComponentsBuilder.newInstance()\n                .scheme(URIConstans.RESPONSE)\n                .path(\"/\")\n                .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n                .queryParam(URIConstans.ID, id)\n                .build()\n                .encode()\n                .toUri();\n\n        AgentInfo info = new AgentInfo();\n\n        // 前面可能有nginx代理\n        HttpHeaders headers = handshake.requestHeaders();\n        String host = HttpUtils.findClientIP(headers);\n\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n                info.setHost(inetSocketAddress.getHostString());\n                info.setPort(inetSocketAddress.getPort());\n            }\n        } else {\n            info.setHost(host);\n            Integer port = HttpUtils.findClientPort(headers);\n            if (port != null) {\n                info.setPort(port);\n            }\n        }\n\n        info.setChannelHandlerContext(ctx);\n        if (arthasVersion != null) {\n            info.setArthasVersion(arthasVersion);\n        }\n\n        tunnelServer.addAgent(id, info);\n        ctx.channel().closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {\n            @Override\n            public void operationComplete(Future<? super Void> future) throws Exception {\n                tunnelServer.removeAgent(finalId);\n            }\n        });\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "230", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect) throws SSLException, URISyntaxException, InterruptedException {\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER);\n        queryEncoder.addParam(URIConstans.ARTHAS_VERSION, this.version);\n        if (appName != null) {\n            queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        }\n        if (id != null) {\n            queryEncoder.addParam(URIConstans.ID, id);\n        }\n        // ws://127.0.0.1:7777/ws?method=agentRegister\n        final URI agentRegisterURI = queryEncoder.toUri();\n\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = agentRegisterURI.getScheme() == null ? \"ws\" : agentRegisterURI.getScheme();\n        final String host = agentRegisterURI.getHost() == null ? \"127.0.0.1\" : agentRegisterURI.getHost();\n        final int port;\n        if (agentRegisterURI.getPort() == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else if (\"wss\".equalsIgnoreCase(scheme)) {\n                port = 443;\n            } else {\n                port = -1;\n            }\n        } else {\n            port = agentRegisterURI.getPort();\n        }\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n        }\n\n        final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n        final SslContext sslCtx;\n        if (ssl) {\n            sslCtx = SslContextBuilder.forClient()\n                    .trustManager(InsecureTrustManagerFactory.INSTANCE)\n                    .build();\n        } else {\n            sslCtx = null;\n        }\n\n        WebSocketClientProtocolConfig clientProtocolConfig = WebSocketClientProtocolConfig.newBuilder()\n                .webSocketUri(agentRegisterURI)\n                .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH)\n                .build();\n\n        final WebSocketClientProtocolHandler websocketClientHandler =\n                new WebSocketClientProtocolHandler(clientProtocolConfig);\n        final TunnelClientSocketClientHandler handler =\n                new TunnelClientSocketClientHandler(TunnelClient.this);\n\n        Bootstrap bs = new Bootstrap();\n\n        bs.group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(host, port)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        p.addLast(\n                                new HttpClientCodec(),\n                                new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                                websocketClientHandler,\n                                new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                                handler\n                        );\n                    }\n                });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.cause() != null) {\n                        logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n                    }\n                }\n            });\n        }\n        connectFuture.sync();\n\n        return handler.registerFuture();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "231", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[] {\n                0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65,\n                0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x6d, 0x69, 0x73, 0x74, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74,\n                0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74,\n                0x20, 0x6c, 0x65, 0x74, 0x20, 0x6d, 0x79, 0x73, 0x65, 0x6c, 0x66, 0x0a, 0x43, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6d,\n                0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x73, 0x6f, 0x20, 0x6d, 0x75, 0x63, 0x68, 0x20, 0x6d, 0x69, 0x73,\n                0x65, 0x72, 0x79, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61,\n                0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x61, 0x79, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x59,\n                0x6f, 0x75, 0x20, 0x66, 0x65, 0x6c, 0x6c, 0x20, 0x73, 0x6f, 0x20, 0x68, 0x61, 0x72, 0x64, 0x0a, 0x0a, 0x49, 0x20,\n                0x76, 0x65, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x72, 0x64,\n                0x20, 0x77, 0x61, 0x79, 0x0a, 0x54, 0x6f, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x69,\n                0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x61, 0x72, 0x0a, 0x0a, 0x42, 0x65, 0x63,\n                0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72,\n                0x20, 0x73, 0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d,\n                0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75,\n                0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64,\n                0x20, 0x74, 0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66,\n                0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67,\n                0x65, 0x74, 0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20,\n                0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20,\n                0x74, 0x6f, 0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d,\n                0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f,\n                0x75, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n                0x6f, 0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x6c,\n                0x6f, 0x73, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x77, 0x61, 0x79, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x73,\n                0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72,\n                0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x74, 0x20, 0x6f, 0x75, 0x74, 0x0a,\n                0x49, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x72, 0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n                0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x20, 0x77,\n                0x65, 0x61, 0x6b, 0x6e, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x65, 0x79, 0x65,\n                0x73, 0x0a, 0x49, 0x20, 0x6d, 0x20, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6b,\n                0x65, 0x0a, 0x41, 0x20, 0x73, 0x6d, 0x69, 0x6c, 0x65, 0x2c, 0x20, 0x61, 0x20, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x20,\n                0x65, 0x76, 0x65, 0x72, 0x79, 0x64, 0x61, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66, 0x65,\n                0x0a, 0x4d, 0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x27, 0x74, 0x20, 0x70, 0x6f, 0x73,\n                0x73, 0x69, 0x62, 0x6c, 0x79, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x0a, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74,\n                0x20, 0x77, 0x61, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x77, 0x68, 0x6f, 0x6c, 0x65, 0x20,\n                0x74, 0x6f, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61,\n                0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20,\n                0x73, 0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20,\n                0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n                0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20,\n                0x74, 0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65,\n                0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65,\n                0x74, 0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n                0x6f, 0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74,\n                0x6f, 0x20, 0x74, 0x72, 0x75, 0x73, 0x74, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d, 0x65,\n                0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f, 0x75,\n                0x6e, 0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f,\n                0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x77, 0x61,\n                0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x65, 0x0a, 0x49, 0x20, 0x68, 0x65, 0x61,\n                0x72, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x72, 0x79, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6e, 0x69,\n                0x67, 0x68, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x0a, 0x49,\n                0x20, 0x77, 0x61, 0x73, 0x20, 0x73, 0x6f, 0x20, 0x79, 0x6f, 0x75, 0x6e, 0x67, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x73,\n                0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x20, 0x62, 0x65,\n                0x74, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x65, 0x61, 0x6e, 0x20, 0x6f,\n                0x6e, 0x20, 0x6d, 0x65, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x6f, 0x75,\n                0x67, 0x68, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a,\n                0x59, 0x6f, 0x75, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x73, 0x61, 0x77, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x70,\n                0x61, 0x69, 0x6e, 0x0a, 0x41, 0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x77, 0x20, 0x49, 0x20, 0x63, 0x72, 0x79, 0x20, 0x69,\n                0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65,\n                0x20, 0x6e, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x46, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65,\n                0x20, 0x64, 0x61, 0x6d, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n                0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x73, 0x74,\n                0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68,\n                0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20,\n                0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f,\n                0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65, 0x20, 0x73,\n                0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65, 0x74, 0x20,\n                0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75,\n                0x0a, 0x49, 0x20, 0x74, 0x72, 0x79, 0x20, 0x6d, 0x79, 0x20, 0x68, 0x61, 0x72, 0x64, 0x65, 0x73, 0x74, 0x20, 0x6a,\n                0x75, 0x73, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x6f, 0x72, 0x67, 0x65, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79,\n                0x74, 0x68, 0x69, 0x6e, 0x67, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f,\n                0x75, 0x0a, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x68, 0x6f, 0x77, 0x20,\n                0x74, 0x6f, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x20,\n                0x69, 0x6e, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49,\n                0x20, 0x6d, 0x20, 0x61, 0x73, 0x68, 0x61, 0x6d, 0x65, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69,\n                0x66, 0x65, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x73, 0x20, 0x65, 0x6d, 0x70,\n                0x74, 0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49,\n                0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,\n                0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20,\n                0x79, 0x6f, 0x75, 0x0a, 0x2e, 0x2e, 0x2e, 0x0a, /*0x0a, 0x66, 0x6f, 0x72, 0x20, 0x6a, 0x75, 0x6c, 0x79, 0x0a, 0x0a,*/\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "232", "src_id": "M124", "code": "\n    @Override\n    public int read() throws IOException {\n        // Critical section because we're altering __bytesAvailable,\n        // __queueHead, and the contents of _queue in addition to\n        // testing value of __hasReachedEOF.\n        synchronized (__queue) {\n            while (true) {\n                if (__ioException != null) {\n                    IOException e = __ioException;\n                    __ioException = null;\n                    throw e;\n                }\n\n                if (__bytesAvailable == 0) {\n                    // Return EOF if at end of file\n                    if (__hasReachedEOF) {\n                        return EOF;\n                    }\n\n                    // Otherwise, we have to wait for queue to get something\n                    if (__threaded) {\n                        __queue.notify();\n                        try {\n                            __readIsWaiting = true;\n                            __queue.wait();\n                            __readIsWaiting = false;\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                        }\n                    } else {\n                        //__alreadyread = false;\n                        __readIsWaiting = true;\n                        int ch;\n                        boolean mayBlock = true; // block on the first read only\n\n                        do {\n                            try {\n                                if ((ch = __read(mayBlock)) < 0) { // must be EOF\n                                    if (ch != WOULD_BLOCK) {\n                                        return ch;\n                                    }\n                                }\n                            } catch (InterruptedIOException e) {\n                                synchronized (__queue) {\n                                    __ioException = e;\n                                    __queue.notifyAll();\n                                    try {\n                                        __queue.wait(100);\n                                    } catch (InterruptedException interrupted) {\n                                        // Ignored\n                                    }\n                                }\n                                return EOF;\n                            }\n\n                            try {\n                                if (ch != WOULD_BLOCK) {\n                                    __processChar(ch);\n                                }\n                            } catch (InterruptedException e) {\n                                if (__isClosed) {\n                                    return EOF;\n                                }\n                            }\n\n                            // Reads should not block on subsequent iterations. Potentially, this could happen if the\n                            // remaining buffered socket data consists entirely of Telnet command sequence and no \"user\" data.\n                            mayBlock = false;\n\n                        }\n                        // Continue reading as long as there is data available and the queue is not full.\n                        while (super.available() > 0 && __bytesAvailable < __queue.length - 1);\n\n                        __readIsWaiting = false;\n                    }\n                    continue;\n                } else {\n                    int ch = __queue[__queueHead];\n\n                    if (++__queueHead >= __queue.length) {\n                        __queueHead = 0;\n                    }\n\n                    --__bytesAvailable;\n\n                    // Need to explicitly notify() so available() works properly\n                    if (__bytesAvailable == 0 && __threaded) {\n                        __queue.notify();\n                    }\n\n                    return ch;\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "233", "src_id": "M786", "code": "\n    @Override\n    public void process(CommandProcess process) {\n        initTransformer();\n\n        RetransformModel retransformModel = new RetransformModel();\n        Instrumentation inst = process.session().getInstrumentation();\n\n        if (this.list) {\n            List<RetransformEntry> retransformEntryList = allRetransformEntries();\n            retransformModel.setRetransformEntries(retransformEntryList);\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.deleteAll) {\n            deleteAllRetransformEntry();\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } else if (this.delete > 0) {\n            deleteRetransformEntry(this.delete);\n            process.end();\n            return;\n        } else if (this.classPattern != null) {\n            Set<Class<?>> searchClass = SearchUtils.searchClass(inst, classPattern, false, this.hashCode);\n            if (searchClass.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + classPattern);\n                return;\n            }\n\n            if (searchClass.size() > limit) {\n                process.end(-1, \"match classes size: \" + searchClass.size() + \", more than limit: \" + limit\n                        + \", It is recommended to use a more precise class pattern.\");\n            }\n            try {\n                inst.retransformClasses(searchClass.toArray(new Class[0]));\n                for (Class<?> clazz : searchClass) {\n                    retransformModel.addRetransformClass(clazz.getName());\n                }\n                process.appendResult(retransformModel);\n                process.end();\n                return;\n            } catch (Throwable e) {\n                String message = \"retransform error! \" + e.toString();\n                logger.error(message, e);\n                process.end(-1, message);\n                return;\n            }\n        }\n\n        for (String path : paths) {\n            File file = new File(path);\n            if (!file.exists()) {\n                process.end(-1, \"file does not exist, path:\" + path);\n                return;\n            }\n            if (!file.isFile()) {\n                process.end(-1, \"not a normal file, path:\" + path);\n                return;\n            }\n            if (file.length() >= MAX_FILE_SIZE) {\n                process.end(-1, \"file size: \" + file.length() + \" >= \" + MAX_FILE_SIZE + \", path: \" + path);\n                return;\n            }\n        }\n\n        Map<String, byte[]> bytesMap = new HashMap<>();\n        for (String path : paths) {\n            RandomAccessFile f = null;\n            try {\n                f = new RandomAccessFile(path, \"r\");\n                final byte[] bytes = new byte[(int) f.length()];\n                f.readFully(bytes);\n\n                final String clazzName = readClassName(bytes);\n\n                bytesMap.put(clazzName, bytes);\n\n            } catch (Exception e) {\n                logger.warn(\"load class file failed: \" + path, e);\n                process.end(-1, \"load class file failed: \" + path + \", error: \" + e);\n                return;\n            } finally {\n                if (f != null) {\n                    try {\n                        f.close();\n                    } catch (IOException e) {\n                        // ignore\n                    }\n                }\n            }\n        }\n\n        if (bytesMap.size() != paths.size()) {\n            process.end(-1, \"paths may contains same class name!\");\n            return;\n        }\n\n        List<RetransformEntry> retransformEntryList = new ArrayList<>();\n        List<Class<?>> classList = new ArrayList<>();\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (bytesMap.containsKey(clazz.getName())) {\n\n                if (hashCode == null && classLoaderClass != null) {\n                    List<ClassLoader> matchedClassLoaders = ClassLoaderUtils.getClassLoaderByClassName(inst,\n                            classLoaderClass);\n                    if (matchedClassLoaders.size() == 1) {\n                        hashCode = Integer.toHexString(matchedClassLoaders.get(0).hashCode());\n                    } else if (matchedClassLoaders.size() > 1) {\n                        Collection<ClassLoaderVO> classLoaderVOList = ClassUtils\n                                .createClassLoaderVOList(matchedClassLoaders);\n                        retransformModel.setClassLoaderClass(classLoaderClass)\n                                .setMatchedClassLoaders(classLoaderVOList);\n                        process.appendResult(retransformModel);\n                        process.end(-1,\n                                \"Found more than one classloader by class name, please specify classloader with '-c <classloader hash>'\");\n                        return;\n                    } else {\n                        process.end(-1, \"Can not find classloader by class name: \" + classLoaderClass + \".\");\n                        return;\n                    }\n                }\n\n                ClassLoader classLoader = clazz.getClassLoader();\n                if (classLoader != null && hashCode != null\n                        && !Integer.toHexString(classLoader.hashCode()).equals(hashCode)) {\n                    continue;\n                }\n\n                RetransformEntry retransformEntry = new RetransformEntry(clazz.getName(), bytesMap.get(clazz.getName()),\n                        hashCode, classLoaderClass);\n                retransformEntryList.add(retransformEntry);\n                classList.add(clazz);\n                retransformModel.addRetransformClass(clazz.getName());\n\n                logger.info(\"Try retransform class name: {}, ClassLoader: {}\", clazz.getName(), clazz.getClassLoader());\n            }\n        }\n\n        try {\n            if (retransformEntryList.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + bytesMap.keySet());\n                return;\n            }\n            addRetransformEntry(retransformEntryList);\n\n            inst.retransformClasses(classList.toArray(new Class[0]));\n\n            process.appendResult(retransformModel);\n            process.end();\n        } catch (Throwable e) {\n            String message = \"retransform error! \" + e.toString();\n            logger.error(message, e);\n            process.end(-1, message);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "234", "src_id": "M278", "code": "\n    V get(Object key, int hash) {\n        if (count != 0) { // read-volatile\n            HashEntry<K, V> e = getFirst(hash);\n            while (e != null) {\n                if (e.hash == hash && keyEq(key, e.key())) {\n                    Object opaque = e.valueRef;\n                    if (opaque != null) {\n                        return e.dereferenceValue(opaque);\n                    }\n                    return readValueUnderLock(e); // recheck\n                }\n                e = e.next;\n            }\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "235", "src_id": "M184", "code": "\n    @Override\n    protected void initChannel(LocalChannel ch) {\n        ChannelPipeline p = ch.pipeline();\n        p.addLast(\n                new HttpClientCodec(),\n                new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                new HttpProxyClientHandler(httpResponsePromise)\n        );\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "236", "src_id": "M1643", "code": "\n    public void start() throws InterruptedException {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup work = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new NettyHttpInitializer(this.STATIC_LOCATION))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n            logger.info(\"start http server on port: {}\", port);\n            ChannelFuture future = serverBootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            work.shutdownGracefully();\n            boss.shutdownGracefully();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "237", "src_id": "M1614", "code": "\n    private boolean isExclude(Class<?> clazz) {\n        if (this.classNameExcludeMatcher != null) {\n            return classNameExcludeMatcher.matching(clazz.getName());\n        }\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "238", "src_id": "M1632", "code": "\n    public void parseRequestParams(WatchRequest watchRequest) {\n        this.classPattern = watchRequest.getClassPattern();\n        this.methodPattern = watchRequest.getMethodPattern();\n        if (StringUtils.isEmpty(watchRequest.getExpress())) {\n            this.express = \"{params, target, returnObj}\";\n        } else {\n            this.express = watchRequest.getExpress();\n        }\n        this.conditionExpress = watchRequest.getConditionExpress();\n        this.isBefore = watchRequest.getIsBefore();\n        this.isFinish = watchRequest.getIsFinish();\n        this.isException = watchRequest.getIsException();\n        this.isSuccess = watchRequest.getIsSuccess();\n        if (!watchRequest.getIsBefore() && !watchRequest.getIsFinish()\n                && !watchRequest.getIsException() && !watchRequest.getIsSuccess()) {\n            this.isFinish = true;\n        }\n        if (watchRequest.getExpand() <= 0) {\n            this.expand = 1;\n        } else if (watchRequest.getExpand() > MAX_EXPAND) {\n            this.expand = MAX_EXPAND;\n        } else {\n            this.expand = watchRequest.getExpand();\n        }\n        if (watchRequest.getSizeLimit() == 0) {\n            this.sizeLimit = 10 * 1024 * 1024;\n        } else {\n            this.sizeLimit = watchRequest.getSizeLimit();\n        }\n        this.isRegEx = watchRequest.getIsRegEx();\n        if (watchRequest.getNumberOfLimit() == 0) {\n            this.numberOfLimit = 100;\n        } else {\n            this.numberOfLimit = watchRequest.getNumberOfLimit();\n        }\n        if (watchRequest.getExcludeClassPattern().equals(\"\")) {\n            this.excludeClassPattern = null;\n        } else {\n            this.excludeClassPattern = watchRequest.getExcludeClassPattern();\n        }\n        this.listenerId = watchRequest.getListenerId();\n        this.verbose = watchRequest.getVerbose();\n        if (watchRequest.getMaxNumOfMatchedClass() == 0) {\n            this.maxNumOfMatchedClass = 50;\n        } else {\n            this.maxNumOfMatchedClass = watchRequest.getMaxNumOfMatchedClass();\n        }\n        this.jobId = watchRequest.getJobId();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "239", "src_id": "M1616", "code": "\n    public synchronized EnhancerAffect enhance(final Instrumentation inst, int maxNumOfMatchedClass)\n            throws UnmodifiableClassException {\n        // 获取需要增强的类集合\n        this.matchingClasses = GlobalOptions.isDisableSubClass\n                ? SearchUtils.searchClass(inst, classNameMatcher)\n                : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n        if (matchingClasses.size() > maxNumOfMatchedClass) {\n            affect.setOverLimitMsg(\"The number of matched classes is \" + matchingClasses.size()\n                    + \", greater than the limit value \" + maxNumOfMatchedClass\n                    + \". Try to change the limit with option '-m <arg>'.\");\n            return affect;\n        }\n        // 过滤掉无法被增强的类\n        List<Pair<Class<?>, String>> filtedList = filter(matchingClasses);\n        if (!filtedList.isEmpty()) {\n            for (Pair<Class<?>, String> filted : filtedList) {\n                logger.info(\"ignore class: {}, reason: {}\", filted.getFirst().getName(), filted.getSecond());\n            }\n        }\n\n        logger.info(\"enhance matched classes: {}\", matchingClasses);\n\n        affect.setTransformer(this);\n\n        try {\n            DemoBootstrap.getRunningInstance().getTransformerManager().addTransformer(this, isTracing);\n\n            // 批量增强\n            if (GlobalOptions.isBatchReTransform) {\n                final int size = matchingClasses.size();\n                final Class<?>[] classArray = new Class<?>[size];\n                arraycopy(matchingClasses.toArray(), 0, classArray, 0, size);\n                if (classArray.length > 0) {\n                    inst.retransformClasses(classArray);\n                    logger.info(\"Success to batch transform classes: \" + Arrays.toString(classArray));\n                }\n            } else {\n                // for each 增强\n                for (Class<?> clazz : matchingClasses) {\n                    try {\n                        inst.retransformClasses(clazz);\n                        logger.info(\"Success to transform class: \" + clazz);\n                    } catch (Throwable t) {\n                        logger.warn(\"retransform {} failed.\", clazz, t);\n                        if (t instanceof UnmodifiableClassException) {\n                            throw (UnmodifiableClassException) t;\n                        } else if (t instanceof RuntimeException) {\n                            throw (RuntimeException) t;\n                        } else {\n                            throw new RuntimeException(t);\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n            affect.setThrowable(e);\n        }\n\n        return affect;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "240", "src_id": "M1579", "code": "\n    public static ComplexObject createComplexObject() {\n        // 创建一个 ComplexObject 对象\n        ComplexObject complexObject = new ComplexObject();\n\n        // 设置基本类型的值\n        complexObject.setId(1);\n        complexObject.setName(\"Complex Object\");\n        complexObject.setValue(3.14);\n\n        // 设置基本类型的数组\n        int[] numbers = {1, 2, 3, 4, 5};\n        complexObject.setNumbers(numbers);\n\n        Long[] longNumbers = {10086L, 10087L, 10088L, 10089L, 10090L, 10091L};\n        complexObject.setLongNumbers(longNumbers);\n\n        // 创建并设置嵌套对象\n        ComplexObject.NestedObject nestedObject = new ComplexObject.NestedObject();\n        nestedObject.setNestedId(10);\n        nestedObject.setNestedName(\"Nested Object\");\n        nestedObject.setFlag(true);\n        complexObject.setNestedObject(nestedObject);\n\n        List<String> stringList = new ArrayList<>();\n        stringList.add(\"foo\");\n        stringList.add(\"bar\");\n        stringList.add(\"baz\");\n        complexObject.setStringList(stringList);\n\n        Map<String, Integer> stringIntegerMap = new HashMap<>();\n        stringIntegerMap.put(\"one\", 1);\n        stringIntegerMap.put(\"two\", 2);\n        complexObject.setStringIntegerMap(stringIntegerMap);\n\n        complexObject.setDoubleArray(new Double[]{1.0, 2.0, 3.0});\n\n        complexObject.setComplexArray(null);\n\n        complexObject.setCollection(Arrays.asList(\"element1\", \"element2\"));\n\n        // 创建并设置复杂对象数组\n        ComplexObject[] complexArray = new ComplexObject[2];\n\n        ComplexObject complexObject1 = new ComplexObject();\n        complexObject1.setId(2);\n        complexObject1.setName(\"Complex Object 1\");\n        complexObject1.setValue(2.71);\n\n        ComplexObject complexObject2 = new ComplexObject();\n        complexObject2.setId(3);\n        complexObject2.setName(\"Complex Object 2\");\n        complexObject2.setValue(1.618);\n\n        complexArray[0] = complexObject1;\n        complexArray[1] = complexObject2;\n\n        complexObject.setComplexArray(complexArray);\n\n        // 创建并设置多维数组\n        int[][] multiDimensionalArray = {{1, 2, 3}, {4, 5, 6}};\n        complexObject.setMultiDimensionalArray(multiDimensionalArray);\n\n        // 设置数组中的基本元素数组\n        String[] stringArray = {\"Hello\", \"World\"};\n        complexObject.setStringArray(stringArray);\n\n        // 输出 ComplexObject 对象的信息\n        System.out.println(complexObject);\n\n        return complexObject;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "241", "src_id": "M1644", "code": "\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request)\n            throws URISyntaxException, IOException {\n        // 获取URI\n        String uri = new URI(request.uri()).getPath();\n        // 设置不支持favicon.ico文件\n        if (\"/favicon.ico\".equals(uri)) {\n            return;\n        }\n        if (\"/\".equals(uri)) {\n            uri = \"/index.html\";\n        }\n        // 根据路径地址构建文件\n        String path = Paths.get(this.STATIC_LOCATION, uri).toString();\n        File file = new File(path);\n        // 状态为1xx的话，继续请求\n        if (HttpUtil.is100ContinueExpected(request)) {\n            send100Continue(ctx);\n        }\n        // 当文件隐藏/不存在/是目录/非文件的时候，将资源指向NOT_FOUND\n        if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n            sendNotFound(ctx);\n            return;\n        }\n        final RandomAccessFile randomAccessFile;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n        } catch (FileNotFoundException e) {\n            sendNotFound(ctx);\n            throw new RuntimeException(e);\n        }\n        HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n\n        // 设置文件格式内容\n        if (path.endsWith(\".html\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=UTF-8\");\n        } else if (path.endsWith(\".js\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-javascript\");\n        } else if (path.endsWith(\".css\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/css; charset=UTF-8\");\n        } else {\n            MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap();\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, mimetypesFileTypeMap.getContentType(path));\n        }\n\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n\n        if (keepAlive) {\n            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, randomAccessFile.length());\n            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        }\n        ctx.write(response);\n\n        ChannelFuture sendFileFuture;\n        ChannelFuture lastContentFuture;\n        if (ctx.pipeline().get(SslHandler.class) == null) {\n            sendFileFuture =\n                ctx.write(new DefaultFileRegion(randomAccessFile.getChannel(), 0, randomAccessFile.length()), ctx.newProgressivePromise());\n            // Write the end marker.\n            lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n        } else {\n            sendFileFuture =\n                ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(randomAccessFile, 0, randomAccessFile.length(), 10 * 1024 * 1024)),\n                    ctx.newProgressivePromise());\n            // HttpChunkedInput will write the end marker (LastHttpContent) for us.\n            lastContentFuture = sendFileFuture;\n        }\n\n        sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n            @Override\n            public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n                if (total < 0) { // total unknown\n                    logger.info(future.channel() + \" Transfer progress: \" + progress);\n                } else {\n                    logger.info(future.channel() + \" Transfer progress: \" + progress + \" / \" + total);\n                }\n            }\n\n            @Override\n            public void operationComplete(ChannelProgressiveFuture future) {\n                logger.info(future.channel() + \" Transfer complete.\");\n            }\n        });\n\n        // Decide whether to close the connection or not.\n        if (!HttpUtil.isKeepAlive(request)) {\n            // Close the connection when the whole content is written out.\n            lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "242", "src_id": "M1580", "code": "\n    @Override\n    public void query(ObjectQuery query, StreamObserver<ObjectQueryResult> responseObserver) {\n        if (vmTool == null) {\n            throw Status.UNAVAILABLE.withDescription(\"vmtool can not work\").asRuntimeException();\n        }\n        ArthasStreamObserver<ObjectQueryResult> arthasStreamObserver =\n            new ArthasStreamObserverImpl<>(responseObserver, null, grpcJobController);\n        String className = query.getClassName();\n        String classLoaderHash = query.getClassLoaderHash();\n        String classLoaderClass = query.getClassLoaderClass();\n        int limit = query.getLimit();\n        int depth = query.getDepth();\n        String express = query.getExpress();\n        String resultExpress = query.getResultExpress();\n\n        // 如果只传递了 class name 参数，则jvm 里可能有多个同名的 class，需要全部查找\n        if (isEmpty(classLoaderHash) && isEmpty(classLoaderClass)) {\n            List<Class<?>> foundClassList = new ArrayList<>();\n            for (Class<?> clazz : inst.getAllLoadedClasses()) {\n                if (clazz.getName().equals(className)) {\n                    foundClassList.add(clazz);\n                }\n            }\n\n            // 没找到\n            if (foundClassList.size() == 0) {\n                arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n                    .setMessage(\"can not find class: \" + className).build());\n                arthasStreamObserver.onCompleted();\n                return;\n            } else if (foundClassList.size() > 1) {\n                String message = \"found more than one class: \" + className;\n                arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n                    .setMessage(message).build());\n                arthasStreamObserver.onCompleted();\n                return;\n            } else { // 找到了指定的 类\n                Object[] instances = vmTool.getInstances(foundClassList.get(0), limit);\n                Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n                /**\n                 *  这里尝试使用express\n                 */\n                Object value = null;\n                if (!isEmpty(express)) {\n                    Express unpooledExpress = ExpressFactory.unpooledExpress(foundClassList.get(0).getClassLoader());\n                    try {\n                        value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n                    } catch (ExpressException e) {\n                        logger.warn(\"ognl: failed execute express: \" + express, e);\n                    }\n                }\n                if (value != null && !isEmpty(resultExpress)) {\n                    try {\n                        value = ExpressFactory.threadLocalExpress(value)\n                            .bind(Constants.COST_VARIABLE, 0.0).get(resultExpress);\n                    } catch (ExpressException e) {\n                        logger.warn(\"ognl: failed execute result express: \" + express, e);\n                    }\n                }\n                JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n                builder.addObjects(javaObject);\n                arthasStreamObserver.onNext(builder.build());\n                arthasStreamObserver.onCompleted();\n                return;\n            }\n        }\n\n        // 有指定 classloader hash 或者 classloader className\n\n        Class<?> foundClass = null;\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (!clazz.getName().equals(className)) {\n                continue;\n            }\n\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            if (classLoader == null) {\n                continue;\n            }\n\n            if (!isEmpty(classLoaderHash)) {\n                String hex = Integer.toHexString(classLoader.hashCode());\n                if (classLoaderHash.equals(hex)) {\n                    foundClass = clazz;\n                    break;\n                }\n            }\n\n            if (!isEmpty(classLoaderClass) && classLoaderClass.equals(classLoader.getClass().getName())) {\n                foundClass = clazz;\n                break;\n            }\n        }\n        // 没找到类\n        if (foundClass == null) {\n            arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n                .setMessage(\"can not find class: \" + className).build());\n            arthasStreamObserver.onCompleted();\n            return;\n        }\n\n        Object[] instances = vmTool.getInstances(foundClass, limit);\n        Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n        //        for (Object obj : instances) {\n        //            JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(obj, depth);\n        //            builder.addObjects(javaObject);\n        //        }\n\n        Object value = null;\n        if (!isEmpty(express)) {\n            Express unpooledExpress = ExpressFactory.unpooledExpress(foundClass.getClassLoader());\n            try {\n                value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n            } catch (ExpressException e) {\n                logger.warn(\"ognl: failed execute express: \" + express, e);\n            }\n        }\n        if (value != null && !isEmpty(resultExpress)) {\n            try {\n                value = ExpressFactory.threadLocalExpress(value)\n                    .bind(Constants.COST_VARIABLE, 0.0).get(resultExpress);\n            } catch (ExpressException e) {\n                logger.warn(\"ognl: failed execute result express: \" + express, e);\n            }\n        }\n        JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n        builder.addObjects(javaObject);\n        arthasStreamObserver.onNext(builder.build());\n        arthasStreamObserver.onCompleted();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "243", "src_id": "M1566", "code": "\n    public GrpcResultViewResolver registerView(GrpcResultView view) {\n        Class modelClass = getModelClass(view);\n        if (modelClass == null) {\n            throw new NullPointerException(\"model class is null\");\n        }\n        return this.registerView(modelClass, view);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "244", "src_id": "M1613", "code": "\n    private List<Pair<Class<?>, String>> filter(Set<Class<?>> classes) {\n        List<Pair<Class<?>, String>> filteredClasses = new ArrayList<Pair<Class<?>, String>>();\n        final Iterator<Class<?>> it = classes.iterator();\n        while (it.hasNext()) {\n            final Class<?> clazz = it.next();\n            boolean removeFlag = false;\n            if (clazz == null) {\n                removeFlag = true;\n            }\n            //            else if (isSelf(clazz)) {\n            //                filteredClasses.add(new Pair<Class<?>, String>(clazz, \"class loaded by arthas itself\"));\n            //                removeFlag = true;\n            //            }\n            else if (isUnsafeClass(clazz)) {\n                filteredClasses.add(new Pair<Class<?>, String>(clazz,\n                    \"class loaded by Bootstrap Classloader, try to execute `options unsafe true`\"));\n                removeFlag = true;\n            } else if (isExclude(clazz)) {\n                filteredClasses.add(new Pair<Class<?>, String>(clazz, \"class is excluded\"));\n                removeFlag = true;\n            } else {\n                Pair<Boolean, String> unsupportedResult = isUnsupportedClass(clazz);\n                if (unsupportedResult.getFirst()) {\n                    filteredClasses.add(new Pair<Class<?>, String>(clazz, unsupportedResult.getSecond()));\n                    removeFlag = true;\n                }\n            }\n            if (removeFlag) {\n                it.remove();\n            }\n        }\n        return filteredClasses;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "245", "src_id": "M1594", "code": "\n    @Override\n    public void atInvokeException(Class<?> clazz, String invokeInfo, Object target, Throwable throwable) {\n        ClassLoader classLoader = clazz.getClassLoader();\n        String[] info = StringUtils.splitInvokeInfo(invokeInfo);\n        String owner = info[0];\n        String methodName = info[1];\n        String methodDesc = info[2];\n\n        List<AdviceListener> listeners =\n            com.taobao.arthas.grpcweb.grpc.service.advisor.AdviceListenerManager.queryTraceAdviceListeners(\n                classLoader, clazz.getName(), owner, methodName, methodDesc);\n\n        if (listeners != null) {\n            for (AdviceListener adviceListener : listeners) {\n                try {\n                    if (skipAdviceListener(adviceListener)) {\n                        continue;\n                    }\n                    final InvokeTraceable listener = (InvokeTraceable) adviceListener;\n                    listener.invokeThrowTracing(classLoader, owner, methodName, methodDesc, Integer.parseInt(info[3]));\n                } catch (Throwable e) {\n                    logger.error(\"class: {}, invokeInfo: {}\", clazz.getName(), invokeInfo, e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "246", "src_id": "M742", "code": "\n    @Override\n    public void complete(Completion completion) {\n        int argumentIndex = CompletionUtils.detectArgumentIndex(completion);\n\n        if (argumentIndex == 1) {\n            if (!completeBeanName(completion)) {\n                super.complete(completion);\n            }\n            return;\n        } else if (argumentIndex == 2) {\n            if (!completeAttributeName(completion)) {\n                super.complete(completion);\n            }\n            return;\n        }\n\n        super.complete(completion);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "247", "src_id": "M1452", "code": "\n    public static String retrievePreviousArg(List<CliToken> tokens, String lastToken) {\n        if (StringUtils.isBlank(lastToken) && tokens.size() > 2) {\n            // tokens = { \" \", \"CLASS_NAME\", \" \"}\n            return tokens.get(tokens.size() - 2).value();\n        } else if (tokens.size() > 3) {\n            // tokens = { \" \", \"CLASS_NAME\", \" \", \"PARTIAL_METHOD_NAME\"}\n            return tokens.get(tokens.size() - 3).value();\n        }\n\n        return Constants.EMPTY_STRING;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "248", "src_id": "M747", "code": "\n    @Override\n    public void handle(Void event) {\n        timer.cancel();\n        super.handle(event);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "249", "src_id": "M744", "code": "\n    private boolean completeAttributeName(Completion completion) {\n        List<CliToken> tokens = completion.lineTokens();\n        String lastToken = TokenUtils.getLast(tokens).value();\n\n        if (StringUtils.isBlank(lastToken)) {\n            lastToken = \"\";\n        }\n\n        MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();\n        String beanName = TokenUtils.retrievePreviousArg(tokens, lastToken);\n        Set<ObjectName> objectNames = null;\n\n        try {\n            objectNames = platformMBeanServer.queryNames(new ObjectName(beanName), null);\n        } catch (MalformedObjectNameException e) {\n            logger.warn(\"queryNames error\", e);\n        }\n\n        if (objectNames == null || objectNames.size() == 0) {\n            return false;\n        }\n\n        try {\n            MBeanInfo mBeanInfo = platformMBeanServer.getMBeanInfo(objectNames.iterator().next());\n            List<String> attributeNames = new ArrayList<String>();\n            MBeanAttributeInfo[] attributes = mBeanInfo.getAttributes();\n\n            for (MBeanAttributeInfo attribute : attributes) {\n                if (StringUtils.isBlank(lastToken)) {\n                    attributeNames.add(attribute.getName());\n                } else if (attribute.getName().startsWith(lastToken)) {\n                    attributeNames.add(attribute.getName());\n                }\n            }\n\n            return CompletionUtils.complete(completion, attributeNames);\n        } catch (Throwable e) {\n            logger.warn(\"getMBeanInfo error\", e);\n        }\n\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "250", "src_id": "M1539", "code": "\n    @Override\n    public void onError(Throwable t) {\n        Status s = Status.fromThrowable(t);\n        sendResponse.writeError(s);\n        latch.countDown();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "251", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n        Map<String, String> map = new HashMap<>();\n        for (String key : trailer.keys()) {\n            if (EXCLUDED.contains(key.toLowerCase())) {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                map.put(key, new String(value));\n            } else {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                map.put(key, value);\n            }\n        }\n        return map;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "252", "src_id": "M1553", "code": "\n    public byte[] getPrefix(byte[] in, Type type) {\n        int len = in.length;\n        return new byte[] {\n                type.value,\n                (byte) ((len >> 24) & 0xff),\n                (byte) ((len >> 16) & 0xff),\n                (byte) ((len >> 8) & 0xff),\n                (byte) ((len >> 0) & 0xff),\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "253", "src_id": "M1538", "code": "\n    private Method getRpcMethod(Object stub, String rpcMethodName) {\n        for (Method m : stub.getClass().getMethods()) {\n            if (m.getName().equals(rpcMethodName)) {\n                return m;\n            }\n        }\n        throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "254", "src_id": "M1535", "code": "\n    private Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n        // pathInfo starts with \"/\". ignore that first char.\n        String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n        if (rpcClassAndMethodTokens.length != 2) {\n            throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n        }\n        String rpcClassName = rpcClassAndMethodTokens[0];\n        String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n        String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n        return new Pair<>(rpcClassName, rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "255", "src_id": "M1530", "code": "\n    @Override\n    public boolean isEndOfInput() throws Exception {\n        if (input.isEndOfInput()) {\n            // Only end of input after last HTTP chunk has been sent\n            return true;\n        }\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "256", "src_id": "M1539", "code": "\n    @Override\n    public void onError(Throwable t) {\n        Status s = Status.fromThrowable(t);\n        sendResponse.writeError(s);\n        latch.countDown();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "257", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n        Map<String, String> map = new HashMap<>();\n        for (String key : trailer.keys()) {\n            if (EXCLUDED.contains(key.toLowerCase())) {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                map.put(key, new String(value));\n            } else {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                map.put(key, value);\n            }\n        }\n        return map;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "258", "src_id": "M1553", "code": "\n    public byte[] getPrefix(byte[] in, Type type) {\n        int len = in.length;\n        return new byte[] {\n            type.value,\n            (byte) ((len >> 24) & 0xff),\n            (byte) ((len >> 16) & 0xff),\n            (byte) ((len >> 8) & 0xff),\n            (byte) ((len >> 0) & 0xff),\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "259", "src_id": "M1538", "code": "\n    private Method getRpcMethod(Object stub, String rpcMethodName) {\n        for (Method m : stub.getClass().getMethods()) {\n            if (m.getName().equals(rpcMethodName)) {\n                return m;\n            }\n        }\n        throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "260", "src_id": "M1535", "code": "\n    private Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n        // pathInfo starts with \"/\". ignore that first char.\n        String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n        if (rpcClassAndMethodTokens.length != 2) {\n            throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n        }\n        String rpcClassName = rpcClassAndMethodTokens[0];\n        String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n        String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n        return new Pair<>(rpcClassName, rpcMethodName);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "261", "src_id": "M1530", "code": "\n    @Override\n    public boolean isEndOfInput() throws Exception {\n        if (input.isEndOfInput()) {\n            // Only end of input after last HTTP chunk has been sent\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "262", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "263", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "264", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "265", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "266", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "267", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "268", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "269", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "270", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "271", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "272", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "273", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "274", "src_id": "M1643", "code": "\n    public void start() throws InterruptedException {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup work = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new NettyHttpInitializer(this.STATIC_LOCATION))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n            logger.info(\"start http server on port: {}\", port);\n            ChannelFuture future = serverBootstrap.bind(port).sync();\n            future.channel().closeFuture().sync();\n        } finally {\n            work.shutdownGracefully();\n            boss.shutdownGracefully();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "275", "src_id": "M1614", "code": "\n    private boolean isExclude(Class<?> clazz) {\n        if (this.classNameExcludeMatcher != null) {\n            return classNameExcludeMatcher.matching(clazz.getName());\n        } else {\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "276", "src_id": "M1632", "code": "\n    public void parseRequestParams(WatchRequest watchRequest) {\n        this.classPattern = watchRequest.getClassPattern();\n        this.methodPattern = watchRequest.getMethodPattern();\n        if (StringUtils.isEmpty(watchRequest.getExpress())) {\n            this.express = \"{params, target, returnObj}\";\n        } else {\n            this.express = watchRequest.getExpress();\n        }\n        this.conditionExpress = watchRequest.getConditionExpress();\n        this.isBefore = watchRequest.getIsBefore();\n        this.isFinish = watchRequest.getIsFinish();\n        this.isException = watchRequest.getIsException();\n        this.isSuccess = watchRequest.getIsSuccess();\n\n        if (!watchRequest.getIsBefore() && !watchRequest.getIsFinish() && !watchRequest.getIsException() && !watchRequest.getIsSuccess()) {\n            this.isFinish = true;\n        }\n\n        if (watchRequest.getExpand() <= 0) {\n            this.expand = 1;\n        } else if (watchRequest.getExpand() > MAX_EXPAND) {\n            this.expand = MAX_EXPAND;\n        } else {\n            this.expand = watchRequest.getExpand();\n        }\n\n        if (watchRequest.getSizeLimit() == 0) {\n            this.sizeLimit = 10 * 1024 * 1024;\n        } else {\n            this.sizeLimit = watchRequest.getSizeLimit();\n        }\n\n        this.isRegEx = watchRequest.getIsRegEx();\n\n        if (watchRequest.getNumberOfLimit() == 0) {\n            this.numberOfLimit = 100;\n        } else {\n            this.numberOfLimit = watchRequest.getNumberOfLimit();\n        }\n\n        if (\"\".equals(watchRequest.getExcludeClassPattern())) {\n            this.excludeClassPattern = null;\n        } else {\n            this.excludeClassPattern = watchRequest.getExcludeClassPattern();\n        }\n\n        this.listenerId = watchRequest.getListenerId();\n        this.verbose = watchRequest.getVerbose();\n\n        if (watchRequest.getMaxNumOfMatchedClass() == 0) {\n            this.maxNumOfMatchedClass = 50;\n        } else {\n            this.maxNumOfMatchedClass = watchRequest.getMaxNumOfMatchedClass();\n        }\n        this.jobId = watchRequest.getJobId();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "277", "src_id": "M1616", "code": "\n    public synchronized EnhancerAffect enhance(final Instrumentation inst, int maxNumOfMatchedClass) throws UnmodifiableClassException {\n        // 获取需要增强的类集合\n        this.matchingClasses = GlobalOptions.isDisableSubClass\n            ? SearchUtils.searchClass(inst, classNameMatcher)\n            : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n        if (matchingClasses.size() > maxNumOfMatchedClass) {\n            affect.setOverLimitMsg(\"The number of matched classes is \" + matchingClasses.size() + \", greater than the limit value \" + maxNumOfMatchedClass + \". Try to change the limit with option '-m <arg>'.\");\n            return affect;\n        }\n\n        // 过滤掉无法被增强的类\n        List<Pair<Class<?>, String>> filtedList = filter(matchingClasses);\n        if (!filtedList.isEmpty()) {\n            for (Pair<Class<?>, String> filted : filtedList) {\n                logger.info(\"ignore class: {}, reason: {}\", filted.getFirst().getName(), filted.getSecond());\n            }\n        }\n\n        logger.info(\"enhance matched classes: {}\", matchingClasses);\n\n        affect.setTransformer(this);\n\n        try {\n            DemoBootstrap.getRunningInstance().getTransformerManager().addTransformer(this, isTracing);\n\n            // 批量增强\n            if (GlobalOptions.isBatchReTransform) {\n                final int size = matchingClasses.size();\n                final Class<?>[] classArray = new Class<?>[size];\n                arraycopy(matchingClasses.toArray(), 0, classArray, 0, size);\n                if (classArray.length > 0) {\n                    inst.retransformClasses(classArray);\n                    logger.info(\"Success to batch transform classes: \" + Arrays.toString(classArray));\n                }\n            } else {\n                // for each 增强\n                for (Class<?> clazz : matchingClasses) {\n                    try {\n                        inst.retransformClasses(clazz);\n                        logger.info(\"Success to transform class: \" + clazz);\n                    } catch (Throwable t) {\n                        logger.warn(\"retransform {} failed.\", clazz, t);\n                        if (t instanceof UnmodifiableClassException) {\n                            throw (UnmodifiableClassException) t;\n                        } else if (t instanceof RuntimeException) {\n                            throw (RuntimeException) t;\n                        } else {\n                            throw new RuntimeException(t);\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n            affect.setThrowable(e);\n        }\n\n        return affect;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "278", "src_id": "M1579", "code": "\n    public static ComplexObject createComplexObject() {\n        // 创建一个 ComplexObject 对象\n        ComplexObject complexObject = new ComplexObject();\n\n        // 设置基本类型的值\n        complexObject.setId(1);\n        complexObject.setName(\"Complex Object\");\n        complexObject.setValue(3.14);\n\n        // 设置基本类型的数组\n        int[] numbers = {1, 2, 3, 4, 5};\n        complexObject.setNumbers(numbers);\n\n        Long[] longNumbers = {10086l, 10087l, 10088l, 10089l, 10090l, 10091l};\n        complexObject.setLongNumbers(longNumbers);\n\n        // 创建并设置嵌套对象\n        ComplexObject.NestedObject nestedObject = new ComplexObject.NestedObject();\n        nestedObject.setNestedId(10);\n        nestedObject.setNestedName(\"Nested Object\");\n        nestedObject.setFlag(true);\n        complexObject.setNestedObject(nestedObject);\n\n        List<String> stringList = new ArrayList<String>();\n        stringList.add(\"foo\");\n        stringList.add(\"bar\");\n        stringList.add(\"baz\");\n        complexObject.setStringList(stringList);\n\n        Map<String, Integer> stringIntegerMap = new HashMap<String, Integer>();\n        stringIntegerMap.put(\"one\", 1);\n        stringIntegerMap.put(\"two\", 2);\n        complexObject.setStringIntegerMap(stringIntegerMap);\n\n        complexObject.setDoubleArray(new Double[]{1.0, 2.0, 3.0});\n        complexObject.setComplexArray(null);\n        complexObject.setCollection(Arrays.asList(\"element1\", \"element2\"));\n\n        // 创建并设置复杂对象数组\n        ComplexObject[] complexArray = new ComplexObject[2];\n\n        ComplexObject complexObject1 = new ComplexObject();\n        complexObject1.setId(2);\n        complexObject1.setName(\"Complex Object 1\");\n        complexObject1.setValue(2.71);\n\n        ComplexObject complexObject2 = new ComplexObject();\n        complexObject2.setId(3);\n        complexObject2.setName(\"Complex Object 2\");\n        complexObject2.setValue(1.618);\n\n        complexArray[0] = complexObject1;\n        complexArray[1] = complexObject2;\n\n        complexObject.setComplexArray(complexArray);\n\n        // 创建并设置多维数组\n        int[][] multiDimensionalArray = {{1, 2, 3}, {4, 5, 6}};\n        complexObject.setMultiDimensionalArray(multiDimensionalArray);\n\n        // 设置数组中的基本元素数组\n        String[] stringArray = {\"Hello\", \"World\"};\n        complexObject.setStringArray(stringArray);\n\n        // 输出 ComplexObject 对象的信息\n        System.out.println(complexObject);\n\n        return complexObject;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "279", "src_id": "M1644", "code": "\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws URISyntaxException, IOException {\n        // 获取URI\n        String uri = new URI(request.uri()).getPath();\n        // 设置不支持favicon.ico文件\n        if (\"/favicon.ico\".equals(uri)) {\n            return;\n        }\n        if (\"/\".equals(uri)) {\n            uri = \"/index.html\";\n        }\n        // 根据路径地址构建文件\n        String path = Paths.get(this.STATIC_LOCATION, uri).toString();\n        File file = new File(path);\n        // 状态为1xx的话，继续请求\n        if (HttpUtil.is100ContinueExpected(request)) {\n            send100Continue(ctx);\n        }\n        // 当文件隐藏/不存在/是目录/非文件的时候，将资源指向NOT_FOUND\n        if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n            sendNotFound(ctx);\n            return;\n        }\n        final RandomAccessFile randomAccessFile;\n        try {\n            randomAccessFile = new RandomAccessFile(file, \"r\");\n        } catch (FileNotFoundException e) {\n            sendNotFound(ctx);\n            throw new RuntimeException(e);\n        }\n        HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n\n        // 设置文件格式内容\n        if (path.endsWith(\".html\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=UTF-8\");\n        } else if (path.endsWith(\".js\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-javascript\");\n        } else if (path.endsWith(\".css\")) {\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/css; charset=UTF-8\");\n        } else {\n            MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap();\n            response.headers().set(HttpHeaderNames.CONTENT_TYPE, mimetypesFileTypeMap.getContentType(path));\n        }\n\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n\n        if (keepAlive) {\n            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, randomAccessFile.length());\n            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        }\n        ctx.write(response);\n\n        ChannelFuture sendFileFuture;\n        ChannelFuture lastContentFuture;\n        if (ctx.pipeline().get(SslHandler.class) == null) {\n            sendFileFuture = ctx.write(new DefaultFileRegion(randomAccessFile.getChannel(), 0, randomAccessFile.length()), ctx.newProgressivePromise());\n            // Write the end marker.\n            lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n        } else {\n            sendFileFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(randomAccessFile, 0, randomAccessFile.length(), 10 * 1024 * 1024)), ctx.newProgressivePromise());\n            // HttpChunkedInput will write the end marker (LastHttpContent) for us.\n            lastContentFuture = sendFileFuture;\n        }\n\n        sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n            @Override\n            public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n                if (total < 0) {\n                    logger.info(future.channel() + \" Transfer progress: \" + progress);\n                } else {\n                    logger.info(future.channel() + \" Transfer progress: \" + progress + \" / \" + total);\n                }\n            }\n\n            @Override\n            public void operationComplete(ChannelProgressiveFuture future) {\n                logger.info(future.channel() + \" Transfer complete.\");\n            }\n        });\n\n        // Decide whether to close the connection or not.\n        if (!HttpUtil.isKeepAlive(request)) {\n            // Close the connection when the whole content is written out.\n            lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "280", "src_id": "M1580", "code": "\n    @Override\n    public void query(ObjectQuery query, StreamObserver<ObjectQueryResult> responseObserver) {\n        if (vmTool == null) {\n            throw Status.UNAVAILABLE.withDescription(\"vmtool can not work\").asRuntimeException();\n        }\n        ArthasStreamObserver<ObjectQueryResult> arthasStreamObserver = new ArthasStreamObserverImpl<ObjectQueryResult>(responseObserver, null, grpcJobController);\n        String className = query.getClassName();\n        String classLoaderHash = query.getClassLoaderHash();\n        String classLoaderClass = query.getClassLoaderClass();\n        int limit = query.getLimit();\n        int depth = query.getDepth();\n        String express = query.getExpress();\n        String resultExpress = query.getResultExpress();\n\n        // 如果只传递了 class name 参数，则jvm 里可能有多个同名的 class，需要全部查找\n        if (isEmpty(classLoaderHash) && isEmpty(classLoaderClass)) {\n            List<Class<?>> foundClassList = new ArrayList<Class<?>>();\n            for (Class<?> clazz : inst.getAllLoadedClasses()) {\n                if (clazz.getName().equals(className)) {\n                    foundClassList.add(clazz);\n                }\n            }\n\n            // 没找到\n            if (foundClassList.size() == 0) {\n                arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false).setMessage(\"can not find class: \" + className).build());\n                arthasStreamObserver.onCompleted();\n                return;\n            } else if (foundClassList.size() > 1) {\n                String message = \"found more than one class: \" + className;\n                arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false).setMessage(message).build());\n                arthasStreamObserver.onCompleted();\n                return;\n            } else {\n                Object[] instances = vmTool.getInstances(foundClassList.get(0), limit);\n                Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n                Object value = null;\n                if (!isEmpty(express)) {\n                    Express unpooledExpress = ExpressFactory.unpooledExpress(foundClassList.get(0).getClassLoader());\n                    try {\n                        value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n                    } catch (ExpressException e) {\n                        logger.warn(\"ognl: failed execute express: \" + express, e);\n                    }\n                }\n                if (value != null && !isEmpty(resultExpress)) {\n                    try {\n                        value = ExpressFactory.threadLocalExpress(value).bind(Constants.COST_VARIABLE, 0.0).get(resultExpress);\n                    } catch (ExpressException e) {\n                        logger.warn(\"ognl: failed execute result express: \" + express, e);\n                    }\n                }\n                JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n                builder.addObjects(javaObject);\n                arthasStreamObserver.onNext(builder.build());\n                arthasStreamObserver.onCompleted();\n                return;\n            }\n        }\n\n        // 有指定 classloader hash 或者 classloader className\n\n        Class<?> foundClass = null;\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (!clazz.getName().equals(className)) {\n                continue;\n            }\n\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            if (classLoader == null) {\n                continue;\n            }\n\n            if (!isEmpty(classLoaderHash)) {\n                String hex = Integer.toHexString(classLoader.hashCode());\n                if (classLoaderHash.equals(hex)) {\n                    foundClass = clazz;\n                    break;\n                }\n            }\n\n            if (!isEmpty(classLoaderClass) && classLoaderClass.equals(classLoader.getClass().getName())) {\n                foundClass = clazz;\n                break;\n            }\n        }\n        // 没找到类\n        if (foundClass == null) {\n            arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false).setMessage(\"can not find class: \" + className).build());\n            arthasStreamObserver.onCompleted();\n            return;\n        }\n\n        Object[] instances = vmTool.getInstances(foundClass, limit);\n        Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n\n        Object value = null;\n        if (!isEmpty(express)) {\n            Express unpooledExpress = ExpressFactory.unpooledExpress(foundClass.getClassLoader());\n            try {\n                value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n            } catch (ExpressException e) {\n                logger.warn(\"ognl: failed execute express: \" + express, e);\n            }\n        }\n        if (value != null && !isEmpty(resultExpress)) {\n            try {\n                value = ExpressFactory.threadLocalExpress(value).bind(Constants.COST_VARIABLE, 0.0).get(resultExpress);\n            } catch (ExpressException e) {\n                logger.warn(\"ognl: failed execute result express: \" + express, e);\n            }\n        }\n        JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n        builder.addObjects(javaObject);\n        arthasStreamObserver.onNext(builder.build());\n        arthasStreamObserver.onCompleted();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "281", "src_id": "M1566", "code": "\n    public GrpcResultViewResolver registerView(GrpcResultView view) {\n        Class modelClass = getModelClass(view);\n        if (modelClass == null) {\n            throw new NullPointerException(\"model class is null\");\n        } else {\n            return this.registerView(modelClass, view);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "282", "src_id": "M1613", "code": "\n    private List<Pair<Class<?>, String>> filter(Set<Class<?>> classes) {\n        List<Pair<Class<?>, String>> filteredClasses = new ArrayList<Pair<Class<?>, String>>();\n        final Iterator<Class<?>> it = classes.iterator();\n        while (it.hasNext()) {\n            final Class<?> clazz = it.next();\n            boolean removeFlag = false;\n            if (clazz == null) {\n                removeFlag = true;\n            } else if (isUnsafeClass(clazz)) {\n                filteredClasses.add(new Pair<Class<?>, String>(clazz, \"class loaded by Bootstrap Classloader, try to execute `options unsafe true`\"));\n                removeFlag = true;\n            } else if (isExclude(clazz)) {\n                filteredClasses.add(new Pair<Class<?>, String>(clazz, \"class is excluded\"));\n                removeFlag = true;\n            } else {\n                Pair<Boolean, String> unsupportedResult = isUnsupportedClass(clazz);\n                if (unsupportedResult.getFirst()) {\n                    filteredClasses.add(new Pair<Class<?>, String>(clazz, unsupportedResult.getSecond()));\n                    removeFlag = true;\n                }\n            }\n            if (removeFlag) {\n                it.remove();\n            }\n        }\n        return filteredClasses;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "283", "src_id": "M1594", "code": "\n    @Override\n    public void atInvokeException(Class<?> clazz, String invokeInfo, Object target, Throwable throwable) {\n        ClassLoader classLoader = clazz.getClassLoader();\n        String[] info = StringUtils.splitInvokeInfo(invokeInfo);\n        String owner = info[0];\n        String methodName = info[1];\n        String methodDesc = info[2];\n\n        List<AdviceListener> listeners = com.taobao.arthas.grpcweb.grpc.service.advisor.AdviceListenerManager.queryTraceAdviceListeners(classLoader, clazz.getName(), owner, methodName, methodDesc);\n\n        if (listeners != null) {\n            for (AdviceListener adviceListener : listeners) {\n                try {\n                    if (skipAdviceListener(adviceListener)) {\n                        continue;\n                    }\n                    final InvokeTraceable listener = (InvokeTraceable) adviceListener;\n                    listener.invokeThrowTracing(classLoader, owner, methodName, methodDesc, Integer.parseInt(info[3]));\n                } catch (Throwable e) {\n                    logger.error(\"class: {}, invokeInfo: {}\", clazz.getName(), invokeInfo, e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}

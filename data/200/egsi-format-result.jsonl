{"project_name": "jedis", "pair_id": "152", "src_id": "M890", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) {\n        return true;\n\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n\n    }\n\n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "153", "src_id": "M903", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) {\n        return true;\n\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n\n    }\n\n\n    TSCreateParams that = (TSCreateParams) o;\n\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "154", "src_id": "M907", "code": "@Override\n\npublic int hashCode() {\n\n    int result = Boolean.hashCode(latest);\n\n    result = 31 * result + Boolean.hashCode(withLabels);\n\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n\n    return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "201", "src_id": "M580", "code": "@Override\n\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "202", "src_id": "M237", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    BaseSetExParams setParams = (BaseSetExParams) o;\n\n    return Objects.equals(expiration, setParams.expiration) \n    && Objects.equals(expirationValue, setParams.expirationValue);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "203", "src_id": "M227", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    HSetExParams setParams = (HSetExParams) o;\n\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "204", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n\n    try {\n\n        byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n\n        byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n\n\n        Token newToken = pendingTokenRef.getAndSet(token);\n\n        if (newToken == null) {\n            commandSync.lock();\n\n            try {\n\n                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n\n                resultHandler.add(this.authResultHandler);\n\n            }\n            finally {\n                pendingTokenRef.set(null);\n\n                commandSync.unlock();\n\n            }\n        }\n    } catch (Exception e) {\n\n        logger.error(\"Error while re-authenticating connection\", e);\n\n        client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n\n    }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "205", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n\n    if (listener != null) {\n        this.listener = listener;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "206", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n\n    byte[] resp = (byte[]) reply;\n\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n        onPong(null);\n\n    } else {\n        onPong(encode(resp));\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "207", "src_id": "M581", "code": "@Override\n\npublic List<String> hgetdel(String key, String... fields) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "26", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n\n    if (!inclusive) {\n        sb.append(\"(\");\n\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n\n    } else if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n\n        } else {\n            sb.append(n);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "27", "src_id": "M1292", "code": "@Override\n\npublic String toString() {\n\n    StringBuilder sb = new StringBuilder();\n\n    sb.append('[');\n\n    appendFrom(sb, inclusiveMin);\n\n    sb.append(' ');\n\n    appendTo(sb, inclusiveMax);\n\n    sb.append(']');\n\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "28", "src_id": "M1290", "code": "@Override\n\npublic String toString(Parenthesize parenMode) {\n\n    StringBuilder sb = new StringBuilder();\n\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n\n    }\n    for (Node n : children) {\n\n        sj.add(n.toString(parenMode));\n\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n\n    }\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "72", "src_id": "M890", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) {\n        return true;\n\n    }\n\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n\n    }\n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "73", "src_id": "M903", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) {\n        return true;\n\n    }\n\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "74", "src_id": "M907", "code": "@Override\n\npublic int hashCode() {\n\n    int result = Boolean.hashCode(latest);\n\n    result = 31 * result + Boolean.hashCode(withLabels);\n\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n\n    return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "94", "src_id": "M284", "code": "@Override\n\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "95", "src_id": "M792", "code": "@Override\n\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "96", "src_id": "M727", "code": "@Override\n\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n\n        checkIsInMultiOrPipeline();\n\n        connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n\n        return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "97", "src_id": "M728", "code": "@Override\n\npublic List<String> commandGetKeys(String... command) {\n\n        checkIsInMultiOrPipeline();\n\n        connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n\n        return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "98", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n\n        this.byBox = true;\n\n        this.width = width;\n\n        this.height = height;\n\n        this.unit = unit;\n\n        return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "99", "src_id": "M732", "code": "@Override\n\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n\n        checkIsInMultiOrPipeline();\n\n        CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n\n        connection.sendCommand(args);\n\n        return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "100", "src_id": "M712", "code": "@Override\n\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "101", "src_id": "M551", "code": "@Override\n\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "102", "src_id": "M844", "code": "@Override\n\npublic List<Object> functionListBinary() {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.functionListBinary());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "103", "src_id": "M298", "code": "@Override\n\npublic long sintercard(int limit, byte[]... keys) {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.sintercard(limit, keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "1", "src_id": "M127", "code": "private void build() {\n    // check build state to prevent recursion\n    if (building) {\n        return;\n\n    }\n\n    building = true;\n\n    try {\n\n        if (data != null) {\n            if (data instanceof JedisDataException) {\n                exception = (JedisDataException) data;\n\n            } else {\n                response = builder.build(data);\n\n            }\n        }\n\n        data = null;\n\n    }\n    finally {\n        building = false;\n\n        built = true;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "2", "src_id": "M1184", "code": "@Override\n\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n\n    ensureFill();\n\n\n\n    final int length = Math.min(limit - count, len);\n\n    System.arraycopy(buf, count, b, off, length);\n\n    count += length;\n\n    return length;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "3", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n\n    String host = getMasterAddrByNameResult.get(0);\n\n\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n\n\n    return new HostAndPort(host, port);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "4", "src_id": "M1154", "code": "public String getElement() {\n\n    if (null != element) {\n        return SafeEncoder.encode(element);\n\n    } else {\n        return null;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "5", "src_id": "M937", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (o == null) return false;\n\n\n    if (o == this) return true;\n\n\n    if (!(o instanceof GeoCoordinate)) return false;\n\n\n    GeoCoordinate that = (GeoCoordinate) o;\n\n\n    if (Double.compare(that.longitude, longitude) != 0) return false;\n\n\n    return Double.compare(that.latitude, latitude) == 0;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "6", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\n\npublic List<byte[]> getBinaryMultiBulkReply() {\n\n    flush();\n\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "121", "src_id": "M580", "code": "@Override\n\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "122", "src_id": "M237", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    BaseSetExParams setParams = (BaseSetExParams) o;\n\n    return Objects.equals(expiration, setParams.expiration) \n    && Objects.equals(expirationValue, setParams.expirationValue);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "123", "src_id": "M227", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    HSetExParams setParams = (HSetExParams) o;\n\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "124", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n\n    try {\n\n        byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n\n        byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n\n        Token newToken = pendingTokenRef.getAndSet(token);\n\n        if (newToken == null) {\n            commandSync.lock();\n\n            try {\n\n                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n\n                resultHandler.add(this.authResultHandler);\n\n            }\n            finally {\n                pendingTokenRef.set(null);\n\n                commandSync.unlock();\n\n            }\n        }\n    } catch (Exception e) {\n\n        logger.error(\"Error while re-authenticating connection\", e);\n\n        client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n\n    }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "125", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n\n    if (listener != null) {\n        this.listener = listener;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "126", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n\n    byte[] resp = (byte[]) reply;\n\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n        onPong(null);\n\n    } else {\n        onPong(encode(resp));\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "127", "src_id": "M581", "code": "@Override\n\npublic List<String> hgetdel(String key, String... fields) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "42", "src_id": "M1177", "code": "public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource != null) {\n        try {\n\n            resource.close();\n\n        } catch (Exception e) {\n        // ignored\n        }\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "43", "src_id": "M620", "code": "@Override\n\npublic Set<String> sinter(final String... keys) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.sinter(keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "44", "src_id": "M50", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic Map<byte[], byte[]> build(Object data) {\n\n    final List<Object> list = (List<Object>) data;\n\n    if (list.isEmpty()) return Collections.emptyMap();\n\n\n\n    if (list.get(0) instanceof KeyValue) {\n        final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n\n        final Iterator iterator = list.iterator();\n\n\n        while (iterator.hasNext()) {\n\n            KeyValue kv = (KeyValue) iterator.next();\n\n            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n\n        }\n\n\n        return map;\n\n    } else {\n        final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n\n        final Iterator iterator = list.iterator();\n\n\n        while (iterator.hasNext()) {\n\n            map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n\n        }\n\n\n        return map;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "45", "src_id": "M933", "code": "@Deprecated\n\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n\n    Builder builder = builder();\n\n    builder.protocol(copy.getRedisProtocol());\n\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n\n    if (credentialsProvider != null) {\n        builder.credentialsProvider(credentialsProvider);\n\n    } else {\n        builder.user(copy.getUser());\n\n        builder.password(copy.getPassword());\n\n    }\n\n\n    builder.database(copy.getDatabase());\n\n    builder.clientName(copy.getClientName());\n\n\n    builder.ssl(copy.isSsl());\n\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n\n    builder.sslParameters(copy.getSslParameters());\n\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n\n    builder.sslOptions(copy.getSslOptions());\n\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n        builder.readOnlyForRedisClusterReplicas();\n\n    }\n\n\n    builder.authXManager(copy.getAuthXManager());\n\n\n\n    return builder.build();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "46", "src_id": "M1146", "code": "private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n\n\n    JedisRedirectionException redirect = null;\n\n\n    int consecutiveConnectionFailures = 0;\n\n\n    Exception lastException = null;\n\n\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n\n        Connection connection = null;\n\n        try {\n\n            if (redirect != null) {\n                connection = provider.getConnection(redirect.getTargetNode());\n\n                if (redirect instanceof JedisAskDataException) {\n                    // TODO: Pipeline asking with the original command to make it faster....\n                    connection.executeCommand(Protocol.Command.ASKING);\n\n                }\n            } else {\n                connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                : provider.getConnection(commandObject.getArguments());\n\n            }\n\n\n            return execute(connection, commandObject);\n\n\n        } catch (JedisClusterOperationException jnrcne) {\n\n            throw jnrcne;\n\n        } catch (JedisConnectionException jce) {\n\n            lastException = jce;\n\n            ++consecutiveConnectionFailures;\n\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n\n            boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n\n            if (reset) {\n                consecutiveConnectionFailures = 0;\n\n                redirect = null;\n\n            }\n        } catch (JedisRedirectionException jre) {\n            // avoid updating lastException if it is a connection exception\n            if (lastException == null || lastException instanceof JedisRedirectionException) {\n                lastException = jre;\n\n            }\n\n            log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n\n            consecutiveConnectionFailures = 0;\n\n            redirect = jre;\n            // if MOVED redirection occurred,\n            if (jre instanceof JedisMovedDataException) {\n                // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                provider.renewSlotCache(connection);\n\n            }\n        }\n        finally {\n            IOUtils.closeQuietly(connection);\n\n        }\n        if (Instant.now().isAfter(deadline)) {\n            throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n\n        }\n    }\n\n\n\n    JedisClusterOperationException maxAttemptsException\n    = new JedisClusterOperationException(\"No more cluster attempts left.\");\n\n    maxAttemptsException.addSuppressed(lastException);\n\n\n    throw maxAttemptsException;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "47", "src_id": "M884", "code": "@Override\n\npublic void addParams(CommandArguments args) {\n\n\n    if (filters == null) {\n        throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n\n    }\n\n\n    if (fromTimestamp == null) {\n        args.add(MINUS);\n\n    } else {\n        args.add(toByteArray(fromTimestamp));\n\n    }\n\n\n    if (toTimestamp == null) {\n        args.add(PLUS);\n\n    } else {\n        args.add(toByteArray(toTimestamp));\n\n    }\n\n\n    if (latest) {\n        args.add(LATEST);\n\n    }\n\n\n    if (filterByTimestamps != null) {\n        args.add(FILTER_BY_TS);\n\n        for (long ts : filterByTimestamps) {\n\n            args.add(toByteArray(ts));\n\n        }\n\n    }\n\n\n    if (filterByValues != null) {\n        args.add(FILTER_BY_VALUE);\n\n        for (double value : filterByValues) {\n\n            args.add(toByteArray(value));\n\n        }\n\n    }\n\n\n    if (withLabels) {\n        args.add(WITHLABELS);\n\n    } else if (selectedLabels != null) {\n            args.add(SELECTED_LABELS);\n\n            for (String label : selectedLabels) {\n\n                args.add(label);\n\n            }\n\n        }\n\n\n\n    if (count != null) {\n        args.add(COUNT).add(toByteArray(count));\n\n    }\n\n\n    if (aggregationType != null) {\n\n        if (align != null) {\n            args.add(ALIGN).add(align);\n\n        }\n\n\n        args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n\n        if (bucketTimestamp != null) {\n            args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n\n        }\n\n\n        if (empty) {\n            args.add(EMPTY);\n\n        }\n    }\n\n\n    args.add(FILTER);\n\n    for (String filter : filters) {\n\n        args.add(filter);\n\n    }\n\n\n\n    if (groupByLabel != null && groupByReduce != null) {\n        args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "48", "src_id": "M502", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "49", "src_id": "M416", "code": "@Override\n\npublic List<byte[]> aclLogBinary() {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(ACL, LOG);\n\n\n    return connection.getBinaryMultiBulkReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "50", "src_id": "M390", "code": "@Override\n\npublic Long objectFreq(final byte[] key) {\n\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n\n\n    return connection.getIntegerReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "51", "src_id": "M231", "code": "public GeoRadiusStoreParam storeDist(String key) {\n\n    if (key != null) {\n        this.storeDist = true;\n\n        this.key = key;\n\n    }\n    return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "225", "src_id": "M107", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic List<Map.Entry<byte[], List<StreamEntryBinary>>>build(Object data) {\n\n    if (data==null) return null;\n\n\n    List list=(List) data;\n\n    if (list.isEmpty()) return Collections.emptyList();\n\n\n\n\n    if (list.get(0)instanceofKeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv->new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary>>>result=new ArrayList<>(list.size());\n\n        for (Object anObj : list) {\n\n            List<Object> streamObj=(List<Object>) anObj;\n\n            byte[] streamKey=BINARY.build(streamObj.get(0));\n\n            List<StreamEntryBinary> streamEntries=STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n\n            result.add(KeyValue.of(streamKey, streamEntries));\n\n        }\n\n        return result;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "226", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\nbyte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\nMap<byte[], StreamEntryID> streams) {\n\n    CommandArguments args=commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>>entrySet=streams.entrySet();\n\n    entrySet.forEach(entry->args.key(entry.getKey()));\n\n    entrySet.forEach(entry->args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "227", "src_id": "M1172", "code": "@Override\n\npublic boolean equals(Object other) {\n\n    if (other==null) return false;\n\n\n    if (other==this) return true;\n\n\n    if (!(otherinstanceofByteArrayWrapper)) return false;\n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "228", "src_id": "M154", "code": "@Override\n\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "229", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args=commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>>entrySet=streams.entrySet();\n\n    entrySet.forEach(entry->args.key(entry.getKey()));\n\n    entrySet.forEach(entry->args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "230", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>>xreadBinary(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args=commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>>entrySet=streams.entrySet();\n\n    entrySet.forEach(entry->args.key(entry.getKey()));\n\n    entrySet.forEach(entry->args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "231", "src_id": "M152", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "178", "src_id": "M233", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    XAutoClaimParams that = (XAutoClaimParams) o;\n\n    return Objects.equals(count, that.count);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "179", "src_id": "M1104", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    return Arrays.equals(raw, ((Raw) o).raw);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "180", "src_id": "M260", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ZAddParams that = (ZAddParams) o;\n\n    return change == that.change && existence == that.existence && comparison == that.comparison;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "181", "src_id": "M234", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ClientKillParams that = (ClientKillParams) o;\n\n    return Objects.equals(params, that.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "182", "src_id": "M256", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n\n    return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "183", "src_id": "M238", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    MigrateParams that = (MigrateParams) o;\n\n    return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "184", "src_id": "M229", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ZParams zParams = (ZParams) o;\n\n    return Objects.equals(params, zParams.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "155", "src_id": "M127", "code": "private void build() {\n    // check build state to prevent recursion\n    if (building) {\n        return;\n\n    }\n\n\n    building = true;\n\n    try {\n\n        if (data != null) {\n            if (data instanceof JedisDataException) {\n                exception = (JedisDataException) data;\n\n            } else {\n                response = builder.build(data);\n\n            }\n        }\n\n\n        data = null;\n\n    }\n    finally {\n        building = false;\n\n        built = true;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "156", "src_id": "M1184", "code": "@Override\n\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n\n    ensureFill();\n\n\n\n    final int length = Math.min(limit - count, len);\n\n    System.arraycopy(buf, count, b, off, length);\n\n    count += length;\n\n    return length;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "157", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n\n    String host = getMasterAddrByNameResult.get(0);\n\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n\n\n    return new HostAndPort(host, port);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "158", "src_id": "M1154", "code": "public String getElement() {\n\n    if (null != element) {\n        return SafeEncoder.encode(element);\n\n    } else {\n        return null;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "159", "src_id": "M937", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (o == null) return false;\n\n\n    if (o == this) return true;\n\n\n    if (!(o instanceof GeoCoordinate)) return false;\n\n\n    GeoCoordinate that = (GeoCoordinate) o;\n\n\n    if (Double.compare(that.longitude, longitude) != 0) return false;\n\n\n    return Double.compare(that.latitude, latitude) == 0;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "160", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\n\npublic List<byte[]> getBinaryMultiBulkReply() {\n\n    flush();\n\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "104", "src_id": "M890", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) {\n        return true;\n\n    }\n    if (o==null||getClass()!=o.getClass()) {\n        return false;\n\n    }\n\n\n    TSArithByParams<?> that=(TSArithByParams<?>) o;\n\n    return ignore==that.ignore&&ignoreMaxTimediff==that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff)==0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding==that.encoding&&Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy==that.duplicatePolicy&&Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "105", "src_id": "M903", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) {\n        return true;\n\n    }\n    if (o==null||getClass()!=o.getClass()) {\n        return false;\n\n    }\n\n\n    TSCreateParams that=(TSCreateParams) o;\n\n    return ignore==that.ignore&&ignoreMaxTimediff==that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff)==0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding==that.encoding&&Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy==that.duplicatePolicy&&Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "106", "src_id": "M907", "code": "@Override\n\npublic int hashCode() {\n\n    int result=Boolean.hashCode(latest);\n\n    result=31*result+Boolean.hashCode(withLabels);\n\n    result=31*result+Arrays.hashCode(selectedLabels);\n\n\n    return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "208", "src_id": "M890", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) {\n        return true;\n\n    }\n\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n\n    }\n\n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "209", "src_id": "M903", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) {\n        return true;\n\n    }\n\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n\n    }\n\n\n    TSCreateParams that = (TSCreateParams) o;\n\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "210", "src_id": "M907", "code": "@Override\n\npublic int hashCode() {\n\n    int result = Boolean.hashCode(latest);\n\n    result = 31 * result + Boolean.hashCode(withLabels);\n\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n\n\n    return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "29", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n\n    if (!inclusive) {\n        sb.append(\"(\");\n\n    }\n\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n\n    } else if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n\n        } else {\n            sb.append(n);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "30", "src_id": "M1292", "code": "@Override\n\npublic String toString() {\n\n    StringBuilder sb = new StringBuilder();\n\n    sb.append('[');\n\n    appendFrom(sb, inclusiveMin);\n\n    sb.append(' ');\n\n    appendTo(sb, inclusiveMax);\n\n    sb.append(']');\n\n\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "31", "src_id": "M1290", "code": "@Override\n\npublic String toString(Parenthesize parenMode) {\n\n    StringBuilder sb = new StringBuilder();\n\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n\n    }\n    for (Node n : children) {\n\n        sj.add(n.toString(parenMode));\n\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n\n    }\n\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "75", "src_id": "M127", "code": "private void build() {\n    // check build state to prevent recursion\n    if (building) {\n        return;\n\n    }\n\n\n    building = true;\n\n    try {\n\n        if (data != null) {\n            if (data instanceof JedisDataException) {\n                exception = (JedisDataException) data;\n\n            } else {\n                response = builder.build(data);\n\n            }\n        }\n\n\n        data = null;\n\n    }\n    finally {\n        building = false;\n\n        built = true;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "76", "src_id": "M1184", "code": "@Override\n\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n\n    ensureFill();\n\n\n\n    final int length = Math.min(limit - count, len);\n\n    System.arraycopy(buf, count, b, off, length);\n\n    count += length;\n\n    return length;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "77", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n\n    String host = getMasterAddrByNameResult.get(0);\n\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n\n    return new HostAndPort(host, port);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "78", "src_id": "M1154", "code": "public String getElement() {\n\n    if (null != element) {\n        return SafeEncoder.encode(element);\n\n    } else {\n        return null;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "79", "src_id": "M937", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (o == null) return false;\n\n\n    if (o == this) return true;\n\n\n    if (!(o instanceof GeoCoordinate)) return false;\n\n\n\n\n    GeoCoordinate that = (GeoCoordinate) o;\n\n\n\n    if (Double.compare(that.longitude, longitude) != 0) return false;\n\n\n    return Double.compare(that.latitude, latitude) == 0;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "80", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\n\npublic List<byte[]> getBinaryMultiBulkReply() {\n\n    flush();\n\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "7", "src_id": "M127", "code": "private void build() {\n        // check build state to prevent recursion\n        if (building) {\n                return;\n\n        }\n\n\n        building = true;\n\n        try {\n\n                if (data != null) {\n                        if (data instanceof JedisDataException) {\n                                exception = (JedisDataException) data;\n\n                        } else {\n                                response = builder.build(data);\n\n                        }\n                }\n\n\n                data = null;\n\n        }\n        finally {\n                building = false;\n\n                built = true;\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "8", "src_id": "M1184", "code": "@Override\n\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n\n        ensureFill();\n\n\n\n        final int length = Math.min(limit - count, len);\n\n        System.arraycopy(buf, count, b, off, length);\n\n        count += length;\n\n        return length;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "9", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n\n        String host = getMasterAddrByNameResult.get(0);\n\n\n        int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n\n\n        return new HostAndPort(host, port);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "10", "src_id": "M1154", "code": "public String getElement() {\n\n        if (null != element) {\n                return SafeEncoder.encode(element);\n\n        } else {\n                return null;\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "11", "src_id": "M937", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (o == null) return false;\n\n\n        if (o == this) return true;\n\n\n        if (!(o instanceof GeoCoordinate)) return false;\n\n\n\n        GeoCoordinate that = (GeoCoordinate) o;\n\n\n        if (Double.compare(that.longitude, longitude) != 0) return false;\n\n\n        return Double.compare(that.latitude, latitude) == 0;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "12", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\n\npublic List<byte[]> getBinaryMultiBulkReply() {\n\n        flush();\n\n        return (List<byte[]>) readProtocolWithCheckingBroken();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "52", "src_id": "M284", "code": "@Override\n\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "53", "src_id": "M792", "code": "@Override\n\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "54", "src_id": "M727", "code": "@Override\n\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "55", "src_id": "M728", "code": "@Override\n\npublic List<String> commandGetKeys(String... command) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "56", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n\n    this.byBox = true;\n\n    this.width = width;\n\n    this.height = height;\n\n    this.unit = unit;\n\n    return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "57", "src_id": "M732", "code": "@Override\n\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n\n    checkIsInMultiOrPipeline();\n\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n\n    connection.sendCommand(args);\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "58", "src_id": "M712", "code": "@Override\n\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "59", "src_id": "M551", "code": "@Override\n\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "60", "src_id": "M844", "code": "@Override\n\npublic List<Object> functionListBinary() {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.functionListBinary());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "61", "src_id": "M298", "code": "@Override\n\npublic long sintercard(int limit, byte[]... keys) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "128", "src_id": "M107", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n\n    if (data == null) return null;\n\n\n    List list = (List) data;\n\n    if (list.isEmpty()) return Collections.emptyList();\n\n\n\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n\n        for (Object anObj : list) {\n\n            List<Object> streamObj = (List<Object>) anObj;\n\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n\n            result.add(KeyValue.of(streamKey, streamEntries));\n\n        }\n\n\n        return result;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "129", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\nbyte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\nMap<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "130", "src_id": "M1172", "code": "@Override\n\npublic boolean equals(Object other) {\n\n    if (other == null) return false;\n\n\n    if (other == this) return true;\n\n\n    if (!(other instanceof ByteArrayWrapper)) return false;\n\n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "131", "src_id": "M154", "code": "@Override\n\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "132", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "133", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "134", "src_id": "M152", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "232", "src_id": "M777", "code": "@Override\n\npublic List<Map<String, Object>> clusterLinks() {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n\n    return connection.getObjectMultiBulkReply().stream()\n    .map(BuilderFactory.ENCODED_OBJECT_MAP::build).collect(Collectors.toList());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "233", "src_id": "M779", "code": "@Override\n\npublic String clusterDelSlotsRange(int... ranges) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(CLUSTER,\n    joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));\n\n    return connection.getStatusCodeReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "234", "src_id": "M818", "code": "@Override\n\npublic Map<String, Object> memoryStats() {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(MEMORY, STATS);\n\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "161", "src_id": "M284", "code": "@Override\n\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "162", "src_id": "M792", "code": "@Override\n\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "163", "src_id": "M727", "code": "@Override\n\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "164", "src_id": "M728", "code": "@Override\n\npublic List<String> commandGetKeys(String... command) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "165", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n\n    this.byBox = true;\n\n    this.width = width;\n\n    this.height = height;\n\n    this.unit = unit;\n\n    return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "166", "src_id": "M732", "code": "@Override\n\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n\n    checkIsInMultiOrPipeline();\n\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n\n    connection.sendCommand(args);\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "167", "src_id": "M712", "code": "@Override\n\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "168", "src_id": "M551", "code": "@Override\n\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "169", "src_id": "M844", "code": "@Override\n\npublic List<Object> functionListBinary() {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.functionListBinary());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "170", "src_id": "M298", "code": "@Override\n\npublic long sintercard(int limit, byte[]... keys) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "185", "src_id": "M890", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) {\n        return true;\n\n    }\n\n    if (o==null||getClass()!=o.getClass()) {\n        return false;\n\n    }\n\n\n    TSArithByParams<?> that=(TSArithByParams<?>) o;\n\n    return ignore==that.ignore&&ignoreMaxTimediff==that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff)==0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding==that.encoding&&Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy==that.duplicatePolicy&&Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "186", "src_id": "M903", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) {\n        return true;\n\n    }\n\n    if (o==null||getClass()!=o.getClass()) {\n        return false;\n\n    }\n\n\n    TSCreateParams that=(TSCreateParams) o;\n\n    return ignore==that.ignore&&ignoreMaxTimediff==that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff)==0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding==that.encoding&&Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy==that.duplicatePolicy&&Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "187", "src_id": "M907", "code": "@Override\n\npublic int hashCode() {\n\n    int result=Boolean.hashCode(latest);\n\n    result=31*result+Boolean.hashCode(withLabels);\n\n    result=31*result+Arrays.hashCode(selectedLabels);\n\n    return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "211", "src_id": "M580", "code": "@Override\n\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "212", "src_id": "M237", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    BaseSetExParams setParams = (BaseSetExParams) o;\n\n    return Objects.equals(expiration, setParams.expiration) \n    && Objects.equals(expirationValue, setParams.expirationValue);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "213", "src_id": "M227", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    HSetExParams setParams = (HSetExParams) o;\n\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "214", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n\n    try {\n\n        byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n\n        byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n\n\n        Token newToken = pendingTokenRef.getAndSet(token);\n\n        if (newToken == null) {\n            commandSync.lock();\n\n            try {\n\n                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n\n                resultHandler.add(this.authResultHandler);\n\n            }\n            finally {\n                pendingTokenRef.set(null);\n\n                commandSync.unlock();\n\n            }\n        }\n    } catch (Exception e) {\n\n        logger.error(\"Error while re-authenticating connection\", e);\n\n        client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n\n    }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "215", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n\n    if (listener != null) {\n        this.listener = listener;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "216", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n\n    byte[] resp = (byte[]) reply;\n\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n        onPong(null);\n\n    } else {\n        onPong(encode(resp));\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "217", "src_id": "M581", "code": "@Override\n\npublic List<String> hgetdel(String key, String... fields) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "107", "src_id": "M107", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n\n    if (data == null) return null;\n\n\n    List list = (List) data;\n\n    if (list.isEmpty()) return Collections.emptyList();\n\n\n\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n\n\n        for (Object anObj : list) {\n\n            List<Object> streamObj = (List<Object>) anObj;\n\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n\n            result.add(KeyValue.of(streamKey, streamEntries));\n\n        }\n\n        return result;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "108", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\nbyte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\nMap<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "109", "src_id": "M1172", "code": "@Override\n\npublic boolean equals(Object other) {\n\n    if (other == null) return false;\n\n\n    if (other == this) return true;\n\n\n    if (!(other instanceof ByteArrayWrapper)) return false;\n\n\n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "110", "src_id": "M154", "code": "@Override\n\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "111", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "112", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "113", "src_id": "M152", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "81", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n\n    if (!inclusive) {\n        sb.append(\"(\");\n\n    }\n\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n\n    } else if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n\n        } else {\n            sb.append(n);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "82", "src_id": "M1292", "code": "@Override\n\npublic String toString() {\n\n    StringBuilder sb = new StringBuilder();\n\n    sb.append('[');\n\n    appendFrom(sb, inclusiveMin);\n\n    sb.append(' ');\n\n    appendTo(sb, inclusiveMax);\n\n    sb.append(']');\n\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "83", "src_id": "M1290", "code": "@Override\n\npublic String toString(Parenthesize parenMode) {\n\n    StringBuilder sb = new StringBuilder();\n\n\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n\n    }\n    for (Node n : children) {\n\n        sj.add(n.toString(parenMode));\n\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n\n    }\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "135", "src_id": "M233", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    XAutoClaimParams that = (XAutoClaimParams) o;\n\n    return Objects.equals(count, that.count);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "136", "src_id": "M1104", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    return Arrays.equals(raw, ((Raw) o).raw);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "137", "src_id": "M260", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ZAddParams that = (ZAddParams) o;\n\n    return change == that.change && existence == that.existence && comparison == that.comparison;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "138", "src_id": "M234", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ClientKillParams that = (ClientKillParams) o;\n\n    return Objects.equals(params, that.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "139", "src_id": "M256", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n\n    return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "140", "src_id": "M238", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    MigrateParams that = (MigrateParams) o;\n\n    return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "141", "src_id": "M229", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this == o) return true;\n\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n\n    ZParams zParams = (ZParams) o;\n\n    return Objects.equals(params, zParams.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "32", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n\n    if (!inclusive) {\n        sb.append(\"(\");\n\n    }\n\n    if (n==Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n\n    } else if (n==Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n\n        } else {\n            sb.append(n);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "33", "src_id": "M1292", "code": "@Override\n\npublic String toString() {\n\n    StringBuilder sb=new StringBuilder();\n\n    sb.append('[');\n\n    appendFrom(sb, inclusiveMin);\n\n    sb.append(' ');\n\n    appendTo(sb, inclusiveMax);\n\n    sb.append(']');\n\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "34", "src_id": "M1290", "code": "@Override\n\npublic String toString(Parenthesize parenMode) {\n\n    StringBuilder sb=new StringBuilder();\n\n    StringJoiner sj=new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n\n    }\n    for (Node n : children) {\n\n        sj.add(n.toString(parenMode));\n\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n\n    }\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "13", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n\n    if (!inclusive) {\n        sb.append(\"(\");\n\n    }\n\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n\n    } else if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n\n        } else {\n            sb.append(n);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "14", "src_id": "M1292", "code": "@Override\n\npublic String toString() {\n\n    StringBuilder sb = new StringBuilder();\n\n    sb.append('[');\n\n    appendFrom(sb, inclusiveMin);\n\n    sb.append(' ');\n\n    appendTo(sb, inclusiveMax);\n\n    sb.append(']');\n\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "15", "src_id": "M1290", "code": "@Override\n\npublic String toString(Parenthesize parenMode) {\n\n    StringBuilder sb = new StringBuilder();\n\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n\n    }\n    for (Node n : children) {\n\n        sj.add(n.toString(parenMode));\n\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n\n    }\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "235", "src_id": "M233", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        XAutoClaimParams that = (XAutoClaimParams) o;\n\n        return Objects.equals(count, that.count);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "236", "src_id": "M1104", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n        return Arrays.equals(raw, ((Raw) o).raw);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "237", "src_id": "M260", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        ZAddParams that = (ZAddParams) o;\n\n        return change == that.change && existence == that.existence && comparison == that.comparison;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "238", "src_id": "M234", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        ClientKillParams that = (ClientKillParams) o;\n\n        return Objects.equals(params, that.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "239", "src_id": "M256", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        ModuleLoadExParams that = (ModuleLoadExParams) o;\n\n        return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "240", "src_id": "M238", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        MigrateParams that = (MigrateParams) o;\n\n        return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "241", "src_id": "M229", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        ZParams zParams = (ZParams) o;\n\n        return Objects.equals(params, zParams.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "62", "src_id": "M107", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n\n    if (data == null) return null;\n\n\n\n    List list = (List) data;\n\n\n    if (list.isEmpty()) return Collections.emptyList();\n\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n\n        for (Object anObj : list) {\n\n            List<Object> streamObj = (List<Object>) anObj;\n\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n\n\n            result.add(KeyValue.of(streamKey, streamEntries));\n\n        }\n\n\n        return result;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "63", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\nbyte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\nMap<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n\n\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "64", "src_id": "M1172", "code": "@Override\n\npublic boolean equals(Object other) {\n\n    if (other == null) return false;\n\n    if (other == this) return true;\n\n    if (!(other instanceof ByteArrayWrapper)) return false;\n\n\n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "65", "src_id": "M154", "code": "@Override\n\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "66", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n\n\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "67", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n\n\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "68", "src_id": "M152", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "171", "src_id": "M580", "code": "@Override\n\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "172", "src_id": "M237", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        BaseSetExParams setParams = (BaseSetExParams) o;\n\n        return Objects.equals(expiration, setParams.expiration) \n        && Objects.equals(expirationValue, setParams.expirationValue);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "173", "src_id": "M227", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) return true;\n\n\n        if (o == null || getClass() != o.getClass()) return false;\n\n\n\n        HSetExParams setParams = (HSetExParams) o;\n\n        return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "174", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n\n        try {\n\n                byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n\n                byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n\n                Token newToken = pendingTokenRef.getAndSet(token);\n\n                if (newToken == null) {\n                        commandSync.lock();\n\n                        try {\n\n                                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n\n                                resultHandler.add(this.authResultHandler);\n\n                        }\n                        finally {\n                                pendingTokenRef.set(null);\n\n                                commandSync.unlock();\n\n                        }\n                }\n        } catch (Exception e) {\n\n                logger.error(\"Error while re-authenticating connection\", e);\n\n                client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "175", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n\n        if (listener != null) {\n                this.listener = listener;\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "176", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n\n        byte[] resp = (byte[]) reply;\n\n        if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n                onPong(null);\n\n        } else {\n                onPong(encode(resp));\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "177", "src_id": "M581", "code": "@Override\n\npublic List<String> hgetdel(String key, String... fields) {\n\n        checkIsInMultiOrPipeline();\n\n        return connection.executeCommand(commandObjects.hgetdel(key, fields));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "188", "src_id": "M1177", "code": "public static void closeQuietly(AutoCloseable resource) {\n        // It's same thing as Apache Commons - IOUtils.closeQuietly()\n        if (resource != null) {\n                try {\n\n                        resource.close();\n\n                } catch (Exception e) {\n                // ignored\n                }\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "189", "src_id": "M620", "code": "@Override\n\npublic Set<String> sinter(final String... keys) {\n\n        checkIsInMultiOrPipeline();\n\n\n        return connection.executeCommand(commandObjects.sinter(keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "190", "src_id": "M50", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic Map<byte[], byte[]> build(Object data) {\n\n        final List<Object> list = (List<Object>) data;\n\n        if (list.isEmpty()) return Collections.emptyMap();\n\n\n\n        if (list.get(0) instanceof KeyValue) {\n                final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n                final Iterator iterator = list.iterator();\n\n                while (iterator.hasNext()) {\n\n                        KeyValue kv = (KeyValue) iterator.next();\n\n                        map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n\n                }\n\n                return map;\n\n        } else {\n                final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n                final Iterator iterator = list.iterator();\n\n                while (iterator.hasNext()) {\n\n                        map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n\n                }\n\n                return map;\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "191", "src_id": "M933", "code": "@Deprecated\n\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n\n        Builder builder = builder();\n\n        builder.protocol(copy.getRedisProtocol());\n\n        builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n\n        builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n\n        builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n\n\n        Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n\n        if (credentialsProvider != null) {\n                builder.credentialsProvider(credentialsProvider);\n\n        } else {\n                builder.user(copy.getUser());\n\n                builder.password(copy.getPassword());\n\n        }\n\n\n        builder.database(copy.getDatabase());\n\n        builder.clientName(copy.getClientName());\n\n\n        builder.ssl(copy.isSsl());\n\n        builder.sslSocketFactory(copy.getSslSocketFactory());\n\n        builder.sslParameters(copy.getSslParameters());\n\n        builder.hostnameVerifier(copy.getHostnameVerifier());\n\n        builder.sslOptions(copy.getSslOptions());\n\n        builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n\n        builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n\n        if (copy.isReadOnlyForRedisClusterReplicas()) {\n                builder.readOnlyForRedisClusterReplicas();\n\n        }\n\n\n        builder.authXManager(copy.getAuthXManager());\n\n\n\n        return builder.build();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "192", "src_id": "M1146", "code": "private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n\n        JedisRedirectionException redirect = null;\n\n        int consecutiveConnectionFailures = 0;\n\n        Exception lastException = null;\n\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n\n                Connection connection = null;\n\n                try {\n\n                        if (redirect != null) {\n                                connection = provider.getConnection(redirect.getTargetNode());\n\n                                if (redirect instanceof JedisAskDataException) {\n                                        // TODO: Pipeline asking with the original command to make it faster....\n                                        connection.executeCommand(Protocol.Command.ASKING);\n\n                                }\n                        } else {\n                                connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                                : provider.getConnection(commandObject.getArguments());\n\n                        }\n\n\n                        return execute(connection, commandObject);\n\n\n                } catch (JedisClusterOperationException jnrcne) {\n\n                        throw jnrcne;\n\n                } catch (JedisConnectionException jce) {\n\n                        lastException = jce;\n\n                        ++consecutiveConnectionFailures;\n\n                        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n                        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n\n                        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n\n                        if (reset) {\n                                consecutiveConnectionFailures = 0;\n\n                                redirect = null;\n\n                        }\n                } catch (JedisRedirectionException jre) {\n                        // avoid updating lastException if it is a connection exception\n                        if (lastException == null || lastException instanceof JedisRedirectionException) {\n                                lastException = jre;\n\n                        }\n\n                        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n\n                        consecutiveConnectionFailures = 0;\n\n                        redirect = jre;\n                        // if MOVED redirection occurred,\n                        if (jre instanceof JedisMovedDataException) {\n                                // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                                provider.renewSlotCache(connection);\n\n                        }\n                }\n                finally {\n                        IOUtils.closeQuietly(connection);\n\n                }\n                if (Instant.now().isAfter(deadline)) {\n                        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n\n                }\n        }\n\n\n\n        JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n\n        maxAttemptsException.addSuppressed(lastException);\n\n\n        throw maxAttemptsException;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "193", "src_id": "M884", "code": "@Override\n\npublic void addParams(CommandArguments args) {\n\n\n        if (filters == null) {\n                throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n\n        }\n\n\n        if (fromTimestamp == null) {\n                args.add(MINUS);\n\n        } else {\n                args.add(toByteArray(fromTimestamp));\n\n        }\n\n\n        if (toTimestamp == null) {\n                args.add(PLUS);\n\n        } else {\n                args.add(toByteArray(toTimestamp));\n\n        }\n\n\n        if (latest) {\n                args.add(LATEST);\n\n        }\n\n\n        if (filterByTimestamps != null) {\n                args.add(FILTER_BY_TS);\n\n                for (long ts : filterByTimestamps) {\n\n                        args.add(toByteArray(ts));\n\n                }\n\n        }\n\n\n        if (filterByValues != null) {\n                args.add(FILTER_BY_VALUE);\n\n                for (double value : filterByValues) {\n\n                        args.add(toByteArray(value));\n\n                }\n\n        }\n\n\n        if (withLabels) {\n                args.add(WITHLABELS);\n\n        } else if (selectedLabels != null) {\n                        args.add(SELECTED_LABELS);\n\n                        for (String label : selectedLabels) {\n\n                                args.add(label);\n\n                        }\n\n                }\n\n\n\n        if (count != null) {\n                args.add(COUNT).add(toByteArray(count));\n\n        }\n\n\n        if (aggregationType != null) {\n\n                if (align != null) {\n                        args.add(ALIGN).add(align);\n\n                }\n\n\n                args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n\n                if (bucketTimestamp != null) {\n                        args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n\n                }\n\n\n                if (empty) {\n                        args.add(EMPTY);\n\n                }\n        }\n\n\n        args.add(FILTER);\n\n        for (String filter : filters) {\n\n                args.add(filter);\n\n        }\n\n\n\n        if (groupByLabel != null && groupByReduce != null) {\n                args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "194", "src_id": "M502", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n\n        checkIsInMultiOrPipeline();\n\n\n        return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "195", "src_id": "M416", "code": "@Override\n\npublic List<byte[]> aclLogBinary() {\n\n        checkIsInMultiOrPipeline();\n\n        connection.sendCommand(ACL, LOG);\n\n\n        return connection.getBinaryMultiBulkReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "196", "src_id": "M390", "code": "@Override\n\npublic Long objectFreq(final byte[] key) {\n\n        connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n\n\n        return connection.getIntegerReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "197", "src_id": "M231", "code": "public GeoRadiusStoreParam storeDist(String key) {\n\n        if (key != null) {\n                this.storeDist = true;\n\n                this.key = key;\n\n        }\n        return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "218", "src_id": "M233", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) return true;\n\n\n    if (o==null||getClass()!=o.getClass()) return false;\n\n\n    XAutoClaimParams that=(XAutoClaimParams) o;\n\n    return Objects.equals(count, that.count);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "219", "src_id": "M1104", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) return true;\n\n\n    if (o==null||getClass()!=o.getClass()) return false;\n\n\n    return Arrays.equals(raw, ((Raw) o).raw);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "220", "src_id": "M260", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) return true;\n\n\n    if (o==null||getClass()!=o.getClass()) return false;\n\n\n    ZAddParams that=(ZAddParams) o;\n\n    return change==that.change&&existence==that.existence&&comparison==that.comparison;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "221", "src_id": "M234", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) return true;\n\n\n    if (o==null||getClass()!=o.getClass()) return false;\n\n\n    ClientKillParams that=(ClientKillParams) o;\n\n    return Objects.equals(params, that.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "222", "src_id": "M256", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) return true;\n\n\n    if (o==null||getClass()!=o.getClass()) return false;\n\n\n    ModuleLoadExParams that=(ModuleLoadExParams) o;\n\n    return Objects.equals(configs, that.configs)&&Objects.equals(args, that.args);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "223", "src_id": "M238", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) return true;\n\n\n    if (o==null||getClass()!=o.getClass()) return false;\n\n\n    MigrateParams that=(MigrateParams) o;\n\n    return copy==that.copy&&replace==that.replace&&Objects.equals(username, that.username)&&Objects.equals(password, that.password);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "224", "src_id": "M229", "code": "@Override\n\npublic boolean equals(Object o) {\n\n    if (this==o) return true;\n\n\n    if (o==null||getClass()!=o.getClass()) return false;\n\n\n    ZParams zParams=(ZParams) o;\n\n    return Objects.equals(params, zParams.params);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "84", "src_id": "M284", "code": "@Override\n\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "85", "src_id": "M792", "code": "@Override\n\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "86", "src_id": "M727", "code": "@Override\n\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "87", "src_id": "M728", "code": "@Override\n\npublic List<String> commandGetKeys(String... command) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "88", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n\n    this.byBox = true;\n\n    this.width = width;\n\n    this.height = height;\n\n    this.unit = unit;\n\n    return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "89", "src_id": "M732", "code": "@Override\n\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n\n    checkIsInMultiOrPipeline();\n\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n\n    connection.sendCommand(args);\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "90", "src_id": "M712", "code": "@Override\n\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "91", "src_id": "M551", "code": "@Override\n\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "92", "src_id": "M844", "code": "@Override\n\npublic List<Object> functionListBinary() {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.functionListBinary());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "93", "src_id": "M298", "code": "@Override\n\npublic long sintercard(int limit, byte[]... keys) {\n\n    checkIsInMultiOrPipeline();\n\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "114", "src_id": "M107", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n\n    if (data == null) return null;\n\n\n    List list = (List) data;\n\n    if (list.isEmpty()) return Collections.emptyList();\n\n\n\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n\n        for (Object anObj : list) {\n\n            List<Object> streamObj = (List<Object>) anObj;\n\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n\n            result.add(KeyValue.of(streamKey, streamEntries));\n\n        }\n\n        return result;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "115", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\nbyte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\nMap<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "116", "src_id": "M1172", "code": "@Override\n\npublic boolean equals(Object other) {\n\n    if (other == null) return false;\n\n\n    if (other == this) return true;\n\n\n    if (!(other instanceof ByteArrayWrapper)) return false;\n\n\n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "117", "src_id": "M154", "code": "@Override\n\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "118", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "119", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "120", "src_id": "M152", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "142", "src_id": "M1177", "code": "public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource!=null) {\n        try {\n\n            resource.close();\n\n        } catch (Exception e) {\n        // ignored\n        }\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "143", "src_id": "M620", "code": "@Override\n\npublic Set<String> sinter(final String... keys) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.sinter(keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "144", "src_id": "M50", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic Map<byte[], byte[]> build(Object data) {\n\n    final List<Object> list=(List<Object>) data;\n\n    if (list.isEmpty()) return Collections.emptyMap();\n\n\n\n    if (list.get(0)instanceofKeyValue) {\n        final Map<byte[], byte[]> map=new JedisByteHashMap();\n\n        final Iterator iterator=list.iterator();\n\n        while (iterator.hasNext()) {\n\n            KeyValue kv=(KeyValue) iterator.next();\n\n            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n\n        }\n\n        return map;\n\n    } else {\n        final Map<byte[], byte[]> map=new JedisByteHashMap();\n\n        final Iterator iterator=list.iterator();\n\n        while (iterator.hasNext()) {\n\n            map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n\n        }\n\n        return map;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "145", "src_id": "M933", "code": "@Deprecated\n\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n\n    Builder builder=builder();\n\n    builder.protocol(copy.getRedisProtocol());\n\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n\n\n    Supplier<RedisCredentials> credentialsProvider=copy.getCredentialsProvider();\n\n    if (credentialsProvider!=null) {\n        builder.credentialsProvider(credentialsProvider);\n\n    } else {\n        builder.user(copy.getUser());\n\n        builder.password(copy.getPassword());\n\n    }\n\n\n    builder.database(copy.getDatabase());\n\n    builder.clientName(copy.getClientName());\n\n\n    builder.ssl(copy.isSsl());\n\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n\n    builder.sslParameters(copy.getSslParameters());\n\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n\n    builder.sslOptions(copy.getSslOptions());\n\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n        builder.readOnlyForRedisClusterReplicas();\n\n    }\n\n\n    builder.authXManager(copy.getAuthXManager());\n\n\n\n    return builder.build();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "146", "src_id": "M1146", "code": "private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n\n    Instant deadline=Instant.now().plus(maxTotalRetriesDuration);\n\n\n    JedisRedirectionException redirect=null;\n\n    int consecutiveConnectionFailures=0;\n\n    Exception lastException=null;\n\n    for (int attemptsLeft=this.maxAttempts; attemptsLeft>0; attemptsLeft--) {\n\n        Connection connection=null;\n\n        try {\n\n            if (redirect!=null) {\n                connection=provider.getConnection(redirect.getTargetNode());\n\n                if (redirectinstanceofJedisAskDataException) {\n                    // TODO: Pipeline asking with the original command to make it faster....\n                    connection.executeCommand(Protocol.Command.ASKING);\n\n                }\n            } else {\n                connection=toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                : provider.getConnection(commandObject.getArguments());\n\n            }\n\n\n            return execute(connection, commandObject);\n\n\n        } catch (JedisClusterOperationException jnrcne) {\n\n            throw jnrcne;\n\n        } catch (JedisConnectionException jce) {\n\n            lastException=jce;\n\n            ++consecutiveConnectionFailures;\n\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n\n            boolean reset=handleConnectionProblem(attemptsLeft-1, consecutiveConnectionFailures, deadline);\n\n            if (reset) {\n                consecutiveConnectionFailures=0;\n\n                redirect=null;\n\n            }\n        } catch (JedisRedirectionException jre) {\n            // avoid updating lastException if it is a connection exception\n            if (lastException==null||lastExceptioninstanceofJedisRedirectionException) {\n                lastException=jre;\n\n            }\n\n            log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n\n            consecutiveConnectionFailures=0;\n\n            redirect=jre;\n            // if MOVED redirection occurred,\n            if (jreinstanceofJedisMovedDataException) {\n                // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                provider.renewSlotCache(connection);\n\n            }\n        }\n        finally {\n            IOUtils.closeQuietly(connection);\n\n        }\n        if (Instant.now().isAfter(deadline)) {\n            throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n\n        }\n    }\n\n\n\n    JedisClusterOperationException maxAttemptsException\n    =new JedisClusterOperationException(\"No more cluster attempts left.\");\n\n    maxAttemptsException.addSuppressed(lastException);\n\n\n    throw maxAttemptsException;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "147", "src_id": "M884", "code": "@Override\n\npublic void addParams(CommandArguments args) {\n\n\n    if (filters==null) {\n        throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n\n    }\n\n\n    if (fromTimestamp==null) {\n        args.add(MINUS);\n\n    } else {\n        args.add(toByteArray(fromTimestamp));\n\n    }\n\n\n    if (toTimestamp==null) {\n        args.add(PLUS);\n\n    } else {\n        args.add(toByteArray(toTimestamp));\n\n    }\n\n\n    if (latest) {\n        args.add(LATEST);\n\n    }\n\n\n    if (filterByTimestamps!=null) {\n        args.add(FILTER_BY_TS);\n\n        for (long ts : filterByTimestamps) {\n\n            args.add(toByteArray(ts));\n\n        }\n\n    }\n\n\n    if (filterByValues!=null) {\n        args.add(FILTER_BY_VALUE);\n\n        for (double value : filterByValues) {\n\n            args.add(toByteArray(value));\n\n        }\n\n    }\n\n\n    if (withLabels) {\n        args.add(WITHLABELS);\n\n    } else if (selectedLabels!=null) {\n            args.add(SELECTED_LABELS);\n\n            for (String label : selectedLabels) {\n\n                args.add(label);\n\n            }\n\n        }\n\n\n\n    if (count!=null) {\n        args.add(COUNT).add(toByteArray(count));\n\n    }\n\n\n    if (aggregationType!=null) {\n\n        if (align!=null) {\n            args.add(ALIGN).add(align);\n\n        }\n\n\n        args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n\n        if (bucketTimestamp!=null) {\n            args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n\n        }\n\n\n        if (empty) {\n            args.add(EMPTY);\n\n        }\n    }\n\n\n    args.add(FILTER);\n\n    for (String filter : filters) {\n\n        args.add(filter);\n\n    }\n\n\n\n    if (groupByLabel!=null&&groupByReduce!=null) {\n        args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "148", "src_id": "M502", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "149", "src_id": "M416", "code": "@Override\n\npublic List<byte[]> aclLogBinary() {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(ACL, LOG);\n\n\n    return connection.getBinaryMultiBulkReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "150", "src_id": "M390", "code": "@Override\n\npublic Long objectFreq(final byte[] key) {\n\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n\n\n    return connection.getIntegerReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "151", "src_id": "M231", "code": "public GeoRadiusStoreParam storeDist(String key) {\n\n    if (key!=null) {\n        this.storeDist=true;\n\n        this.key=key;\n\n    }\n    return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "35", "src_id": "M107", "code": "@Override\n\n@SuppressWarnings(\"unchecked\")\n\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n\n    if (data == null) return null;\n\n\n    List list = (List) data;\n\n\n    if (list.isEmpty()) return Collections.emptyList();\n\n\n\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n\n        for (Object anObj : list) {\n\n            List<Object> streamObj = (List<Object>) anObj;\n\n\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n\n\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n\n            result.add(KeyValue.of(streamKey, streamEntries));\n\n        }\n\n        return result;\n\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "36", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\nbyte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\nMap<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "37", "src_id": "M1172", "code": "@Override\n\npublic boolean equals(Object other) {\n\n    if (other == null) return false;\n\n\n    if (other == this) return true;\n\n\n    if (!(other instanceof ByteArrayWrapper)) return false;\n\n\n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "38", "src_id": "M154", "code": "@Override\n\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "39", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "40", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "41", "src_id": "M152", "code": "@Deprecated\n\n@Override\n\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "242", "src_id": "M890", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) {\n                return true;\n\n        }\n        if (o == null || getClass() != o.getClass()) {\n                return false;\n\n        }\n\n\n\n        TSArithByParams<?> that = (TSArithByParams<?>) o;\n\n        return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n        Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n        Objects.equals(timestamp, that.timestamp) &&\n        Objects.equals(retentionPeriod, that.retentionPeriod) &&\n        encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n        duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "243", "src_id": "M903", "code": "@Override\n\npublic boolean equals(Object o) {\n\n        if (this == o) {\n                return true;\n\n        }\n        if (o == null || getClass() != o.getClass()) {\n                return false;\n\n        }\n\n\n\n        TSCreateParams that = (TSCreateParams) o;\n\n        return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n        Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n        Objects.equals(retentionPeriod, that.retentionPeriod) &&\n        encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n        duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "244", "src_id": "M907", "code": "@Override\n\npublic int hashCode() {\n\n        int result = Boolean.hashCode(latest);\n\n        result = 31 * result + Boolean.hashCode(withLabels);\n\n        result = 31 * result + Arrays.hashCode(selectedLabels);\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "69", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n\n    if (!inclusive) {\n        sb.append(\"(\");\n\n    }\n    if (n==Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n\n    } else if (n==Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n\n        } else {\n            sb.append(n);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "70", "src_id": "M1292", "code": "@Override\n\npublic String toString() {\n\n    StringBuilder sb=new StringBuilder();\n\n    sb.append('[');\n\n    appendFrom(sb, inclusiveMin);\n\n    sb.append(' ');\n\n    appendTo(sb, inclusiveMax);\n\n    sb.append(']');\n\n\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "71", "src_id": "M1290", "code": "@Override\n\npublic String toString(Parenthesize parenMode) {\n\n    StringBuilder sb=new StringBuilder();\n\n    StringJoiner sj=new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n\n    }\n    for (Node n : children) {\n\n        sj.add(n.toString(parenMode));\n\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n\n    }\n    return sb.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "198", "src_id": "M777", "code": "@Override\n\npublic List<Map<String, Object>> clusterLinks() {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n\n    return connection.getObjectMultiBulkReply().stream()\n    .map(BuilderFactory.ENCODED_OBJECT_MAP::build).collect(Collectors.toList());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "199", "src_id": "M779", "code": "@Override\n\npublic String clusterDelSlotsRange(int... ranges) {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(CLUSTER,\n    joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));\n\n    return connection.getStatusCodeReply();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "200", "src_id": "M818", "code": "@Override\n\npublic Map<String, Object> memoryStats() {\n\n    checkIsInMultiOrPipeline();\n\n    connection.sendCommand(MEMORY, STATS);\n\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "16", "src_id": "M284", "code": "@Override\n\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "17", "src_id": "M792", "code": "@Override\n\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "18", "src_id": "M727", "code": "@Override\n\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n\n    checkIsInMultiOrPipeline();\n\n\n\n\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n\n\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "19", "src_id": "M728", "code": "@Override\n\npublic List<String> commandGetKeys(String... command) {\n\n    checkIsInMultiOrPipeline();\n\n\n\n\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "20", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n\n    this.byBox = true;\n\n\n    this.width = width;\n\n\n    this.height = height;\n\n\n    this.unit = unit;\n\n\n    return this;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "21", "src_id": "M732", "code": "@Override\n\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n\n    checkIsInMultiOrPipeline();\n\n\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n\n\n    connection.sendCommand(args);\n\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "22", "src_id": "M712", "code": "@Override\n\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "23", "src_id": "M551", "code": "@Override\n\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "24", "src_id": "M844", "code": "@Override\n\npublic List<Object> functionListBinary() {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.functionListBinary());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "25", "src_id": "M298", "code": "@Override\n\npublic long sintercard(int limit, byte[]... keys) {\n\n    checkIsInMultiOrPipeline();\n\n\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "182", "src_id": "M697", "code": "@Nullable\n\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\nDetailAST bound, int neededTokenType) {\n\n\n        DetailAST match=null;\n\n\n        DetailAST iteratedBranch=shiftToNextTraversedBranch(startingBranch, bound);\n\n\n        while (iteratedBranch!=null) {\n\n                if (iteratedBranch.getType()==neededTokenType) {\n                        match=iteratedBranch;\n\n                        break;\n\n                }\n\n\n                iteratedBranch=shiftToNextTraversedBranch(iteratedBranch, bound);\n\n        }\n\n\n\n        return match;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "183", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n\n        DetailAST previousSibling=parentToken.getPreviousSibling();\n\n        for (DetailAST astNode=previousSibling; astNode!=null;\n        astNode=astNode.getLastChild()) {\n\n                previousSibling=astNode;\n\n        }\n\n\n\n        return token.getLineNo()!=previousSibling.getLineNo();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "184", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n\n        final DetailAST branchLeadingToReassignedVar=getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents=new ArrayList<>();\n\n\n        for (DetailAST expressionBranch=branchLeadingToReassignedVar;\n        expressionBranch!=null;\n        expressionBranch=traverseUntilNeededBranchType(expressionBranch,\n        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n\n                final DetailAST assignToken=getMatchedAssignToken(expressionBranch);\n\n\n                if (assignToken!=null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n                }\n\n        }\n\n\n\n        return reassignedVariableIdents;\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "128", "src_id": "M347", "code": "@Override\n\npublic void visitToken(DetailAST ast) {\n\n            switch (ast.getType()) {\n\n                        case TokenTypes.IDENT:\n                                    if (collect) {\n                                                processIdent(ast);\n\n                                    }\n                                    break;\n\n                        case TokenTypes.IMPORT:\n                                    processImport(ast);\n                                    break;\n\n                        case TokenTypes.STATIC_IMPORT:\n                                    processStaticImport(ast);\n                                    break;\n\n                        case TokenTypes.OBJBLOCK:\n                        case TokenTypes.SLIST:\n                                    currentFrame = currentFrame.push();\n                                    break;\n\n                        default:\n                                    collect = true;\n                                    if (processJavadoc) {\n                                                collectReferencesFromJavadoc(ast);\n\n                                    }\n                                    break;\n            }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "129", "src_id": "M394", "code": "@Override\n\npublic int[] getRequiredJavadocTokens() {\n\n            return new int[] {\n\n            JavadocTokenTypes.TEXT,\n            };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "130", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n\n            DetailAST result;\n\n\n            if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                        result = node.getPreviousSibling();\n\n            }\n            else if (isInPatternDefinition(node)) {\n                                    result = node.getFirstChild();\n\n                        }\n                        else {\n                                    result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n\n                        }\n\n            while (result.getLastChild() != null) {\n\n                        result = result.getLastChild();\n\n            }\n\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "30", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n\n        final Pattern result;\n\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n\n        }\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "31", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "86", "src_id": "M37", "code": "private ModuleType getModuleType() {\n\n        final String simpleModuleName=getModuleSimpleName();\n\n\n        final ModuleType result;\n\n\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n                result=ModuleType.FILEFILTER;\n\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n                        result=ModuleType.FILTER;\n\n                }\n                else {\n                        result=ModuleType.CHECK;\n\n                }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "87", "src_id": "M28", "code": "private void scrapeContent(DetailNode ast) {\n\n        if (ast.getType()==JavadocTokenTypes.PARAGRAPH) {\n                if (isParentText(ast)) {\n                        parentSectionStartIdx=getParentIndexOf(ast);\n\n                        moduleDetails.setParent(getParentText(ast));\n\n                }\n                else if (isViolationMessagesText(ast)) {\n                                scrapingViolationMessageList=true;\n\n                        }\n                        else if (exampleSectionStartIdx==-1\n                                &&isExamplesText(ast)) {\n                                        exampleSectionStartIdx=getParentIndexOf(ast);\n\n                                }\n\n\n        }\n        else if (ast.getType()==JavadocTokenTypes.LI) {\n                        if (isPropertyList(ast)) {\n                                if (propertySectionStartIdx==-1) {\n                                        propertySectionStartIdx=getParentIndexOf(ast);\n\n                                }\n                                moduleDetails.addToProperties(createProperties(ast));\n\n                        }\n                        else if (scrapingViolationMessageList) {\n                                        moduleDetails.addToViolationMessages(getViolationMessages(ast));\n\n                                }\n\n                }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "88", "src_id": "M27", "code": "@Override\n\npublic void beginJavadocTree(DetailNode rootAst) {\n\n        if (isTopLevelClassJavadoc()) {\n                moduleDetails=new ModuleDetails();\n\n                toScan=false;\n\n                scrapingViolationMessageList=false;\n\n                propertySectionStartIdx=-1;\n\n                exampleSectionStartIdx=-1;\n\n                parentSectionStartIdx=-1;\n\n\n\n                String moduleName=getModuleSimpleName();\n\n\n                final String checkModuleExtension=\"Check\";\n\n\n                if (moduleName.endsWith(checkModuleExtension)) {\n                        moduleName=moduleName\n                        .substring(0, moduleName.length()-checkModuleExtension.length());\n\n                }\n                moduleDetails.setName(moduleName);\n\n                moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n\n                moduleDetails.setModuleType(getModuleType());\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "89", "src_id": "M35", "code": "private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\nPattern pattern) {\n\n        return Arrays.stream(node.getChildren())\n        .filter(child->pattern.matcher(child.getText()).matches())\n        .findFirst();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "165", "src_id": "M697", "code": "@Nullable\n\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\nDetailAST bound, int neededTokenType) {\n\n\n        DetailAST match = null;\n\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n\n\n        while (iteratedBranch != null) {\n\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n\n                        break;\n\n                }\n\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n\n        }\n\n\n\n        return match;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "166", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n\n\n        for (DetailAST astNode = previousSibling; astNode != null;\n        astNode = astNode.getLastChild()) {\n\n                previousSibling = astNode;\n\n        }\n\n\n\n        return token.getLineNo() != previousSibling.getLineNo();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "167", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n                }\n\n        }\n\n\n\n        return reassignedVariableIdents;\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "71", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n\n        return entry.getLastLine()>line\n        ||entry.getLastLine()==line&&entry\n        .getLastColumn()>=column;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "72", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n\n        final DetailAST modifiers=classDef.findFirstToken(TokenTypes.MODIFIERS);\n\n        return classDef.getType()!=TokenTypes.ENUM_DEF\n        &&modifiers.findFirstToken(TokenTypes.FINAL)==null\n        &&hasDefaultOrExplicitNonPrivateCtor(classDef);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "73", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n\n        DetailAST vertex=ast;\n\n        final Set<DetailAST> result=new HashSet<>();\n\n        final Deque<DetailAST> stack=new ArrayDeque<>();\n\n        while (vertex!=null||!stack.isEmpty()) {\n\n                if (!stack.isEmpty()) {\n                        vertex=stack.pop();\n\n                }\n                while (vertex!=null) {\n\n                        if (vertex.getType()==tokenType) {\n                                result.add(vertex);\n\n                        }\n                        if (vertex.getNextSibling()!=null) {\n                                stack.push(vertex.getNextSibling());\n\n                        }\n                        vertex=vertex.getFirstChild();\n\n                }\n\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "74", "src_id": "M504", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n        return new int[] {\n\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "75", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n\n        final String fileName=Paths.get(fileNameWithExtension).toString();\n\n        final int dotIndex=fileName.lastIndexOf('.');\n\n        final String extension;\n\n\n        if (dotIndex==-1) {\n                extension=\"\";\n\n        }\n        else {\n                extension=fileName.substring(dotIndex+1);\n\n        }\n\n        return extension;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "76", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\nint endLineNumber) {\n\n        DetailAST vertex=ast;\n\n        final Set<DetailAST> result=new HashSet<>();\n\n        final Deque<DetailAST> stack=new ArrayDeque<>();\n\n        while (vertex!=null||!stack.isEmpty()) {\n\n                if (!stack.isEmpty()) {\n                        vertex=stack.pop();\n\n                }\n                while (vertex!=null) {\n\n                        if (isAstSimilar(token, vertex)\n                        &&vertex.getLineNo()<=endLineNumber) {\n                                result.add(vertex);\n\n                        }\n                        if (vertex.getNextSibling()!=null) {\n                                stack.push(vertex.getNextSibling());\n\n                        }\n                        vertex=vertex.getFirstChild();\n\n                }\n\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "77", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n\n        DetailAST searchAST=ast;\n\n        while (searchAST.getType()!=TokenTypes.CLASS_DEF\n        &&searchAST.getType()!=TokenTypes.ENUM_DEF) {\n\n                searchAST=searchAST.getParent();\n\n        }\n\n\n        return searchAST;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "78", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n\n        final DetailAST exprStartIdent=fieldDef.findFirstToken(TokenTypes.IDENT);\n\n        final Set<DetailAST> exprIdents=getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n\n        boolean forwardReference=false;\n\n        for (DetailAST ident : exprIdents) {\n\n                if (classFieldNames.contains(ident.getText())) {\n                        forwardReference=true;\n\n                        break;\n\n                }\n        }\n\n\n        return forwardReference;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "149", "src_id": "M347", "code": "@Override\n\npublic void visitToken(DetailAST ast) {\n\n        switch (ast.getType()) {\n\n                case TokenTypes.IDENT:\n                        if (collect) {\n                                processIdent(ast);\n\n                        }\n                        break;\n\n                case TokenTypes.IMPORT:\n                        processImport(ast);\n                        break;\n\n                case TokenTypes.STATIC_IMPORT:\n                        processStaticImport(ast);\n                        break;\n\n                case TokenTypes.OBJBLOCK:\n                case TokenTypes.SLIST:\n                        currentFrame = currentFrame.push();\n                        break;\n\n                default:\n                        collect = true;\n                        if (processJavadoc) {\n                                collectReferencesFromJavadoc(ast);\n\n                        }\n                        break;\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "150", "src_id": "M394", "code": "@Override\n\npublic int[] getRequiredJavadocTokens() {\n\n        return new int[] {\n\n        JavadocTokenTypes.TEXT,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "151", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n\n        DetailAST result;\n\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                result = node.getPreviousSibling();\n\n        }\n        else if (isInPatternDefinition(node)) {\n                        result = node.getFirstChild();\n\n                }\n                else {\n                        result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n\n                }\n\n        while (result.getLastChild() != null) {\n\n                result = result.getLastChild();\n\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "1", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n\n            return entry.getLastLine() > line\n            || entry.getLastLine() == line && entry\n            .getLastColumn() >= column;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "2", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n\n            final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n\n            return classDef.getType() != TokenTypes.ENUM_DEF\n            && modifiers.findFirstToken(TokenTypes.FINAL) == null\n            && hasDefaultOrExplicitNonPrivateCtor(classDef);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "3", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n\n            DetailAST vertex = ast;\n\n\n            final Set<DetailAST> result = new HashSet<>();\n\n\n            final Deque<DetailAST> stack = new ArrayDeque<>();\n\n            while (vertex != null || !stack.isEmpty()) {\n\n                        if (!stack.isEmpty()) {\n                                    vertex = stack.pop();\n\n                        }\n                        while (vertex != null) {\n\n                                    if (vertex.getType() == tokenType) {\n                                                result.add(vertex);\n\n                                    }\n                                    if (vertex.getNextSibling() != null) {\n                                                stack.push(vertex.getNextSibling());\n\n                                    }\n                                    vertex = vertex.getFirstChild();\n\n                        }\n\n            }\n\n\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "4", "src_id": "M504", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n            return new int[] {\n\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n            };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "5", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n\n            final String fileName = Paths.get(fileNameWithExtension).toString();\n\n\n            final int dotIndex = fileName.lastIndexOf('.');\n\n\n            final String extension;\n\n            if (dotIndex == -1) {\n                        extension = \"\";\n\n            }\n            else {\n                        extension = fileName.substring(dotIndex + 1);\n\n            }\n            return extension;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "6", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\nint endLineNumber) {\n\n            DetailAST vertex = ast;\n\n\n            final Set<DetailAST> result = new HashSet<>();\n\n\n            final Deque<DetailAST> stack = new ArrayDeque<>();\n\n            while (vertex != null || !stack.isEmpty()) {\n\n                        if (!stack.isEmpty()) {\n                                    vertex = stack.pop();\n\n                        }\n                        while (vertex != null) {\n\n                                    if (isAstSimilar(token, vertex)\n                                    && vertex.getLineNo() <= endLineNumber) {\n                                                result.add(vertex);\n\n                                    }\n                                    if (vertex.getNextSibling() != null) {\n                                                stack.push(vertex.getNextSibling());\n\n                                    }\n                                    vertex = vertex.getFirstChild();\n\n                        }\n\n            }\n\n\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "7", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n\n            DetailAST searchAST = ast;\n\n            while (searchAST.getType() != TokenTypes.CLASS_DEF\n            && searchAST.getType() != TokenTypes.ENUM_DEF) {\n\n                        searchAST = searchAST.getParent();\n\n            }\n\n\n            return searchAST;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "8", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n\n            final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n\n\n            final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n\n\n            boolean forwardReference = false;\n\n            for (DetailAST ident : exprIdents) {\n\n                        if (classFieldNames.contains(ident.getText())) {\n                                    forwardReference = true;\n\n                                    break;\n\n                        }\n            }\n\n\n            return forwardReference;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "103", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return CommonUtil.createPattern(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "104", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return SeverityLevel.getInstance(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "105", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n\n        registerIntegralTypes(cub);\n\n        registerCustomTypes(cub);\n\n\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "106", "src_id": "M4", "code": "@Override\n\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n\n        configuration = config;\n\n\n\n        final String[] attributes = config.getPropertyNames();\n\n\n        for (final String key : attributes) {\n\n                final String value = config.getProperty(key);\n\n\n                tryCopyProperty(key, value, true);\n\n        }\n\n\n\n        finishLocalSetup();\n\n\n\n        final Configuration[] childConfigs = config.getChildren();\n\n        for (final Configuration childConfig : childConfigs) {\n\n                setupChild(childConfig);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "107", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n\n\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n                final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n\n                annotationString = FullIdent.createFullIdent(dotNode).getText();\n\n        }\n        else {\n                annotationString = identNode.getText();\n\n        }\n\n\n        return annotationString;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "46", "src_id": "M79", "code": "private static Stream<?> getValuesStream(Object value) {\n\n        final Stream<?> valuesStream;\n\n        if (value instanceof Collection) {\n                final Collection<?> collection = (Collection<?>) value;\n\n                valuesStream = collection.stream();\n\n        }\n        else {\n                final Object[] array = (Object[]) value;\n\n                valuesStream = Arrays.stream(array);\n\n        }\n\n        return valuesStream;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "47", "src_id": "M103", "code": "@Override\n\npublic void body() {\n\n        write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding + \"\\\"?>\");\n\n\n\n\n        writeEOL();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "48", "src_id": "M72", "code": "private static DetailNode getSinceJavadocTag(DetailNode javadoc) {\n\n        final DetailNode[] children = javadoc.getChildren();\n\n\n\n        DetailNode javadocTagWithSince = null;\n\n        for (final DetailNode child : children) {\n\n                if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                        final DetailNode sinceNode = JavadocUtil.findFirstToken(\n                        child, JavadocTokenTypes.SINCE_LITERAL);\n\n                        if (sinceNode != null) {\n                                javadocTagWithSince = child;\n\n                                break;\n\n                        }\n                }\n        }\n\n\n        return javadocTagWithSince;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "49", "src_id": "M46", "code": "private static String getLinkToParentModule(String parentModule, String moduleName)\nthrows MacroExecutionException {\n\n        final Path templatePath = SiteUtil.getTemplatePath(moduleName);\n\n        if (templatePath == null) {\n                throw new MacroExecutionException(\n                String.format(Locale.ROOT, \"Could not find template for %s\", moduleName));\n\n        }\n        final Path templatePathParent = templatePath.getParent();\n\n        if (templatePathParent == null) {\n                throw new MacroExecutionException(\"Failed to get parent path for \" + templatePath);\n\n        }\n\n        return templatePathParent\n        .relativize(Path.of(\"src\", \"site/xdoc\", \"config.xml\"))\n        .toString()\n        .replace(\".xml\", \".html\")\n        .replace('\\\\', '/')\n        + \"#\" + parentModule;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "50", "src_id": "M78", "code": "private static String getStringArrayPropertyValue(String propertyName, Object value) {\n\n        String result;\n\n        if (value == null) {\n                result = \"\";\n\n        }\n        else {\n                try (Stream<?> valuesStream = getValuesStream(value)) {\n\n                        result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(COMMA_SPACE));\n\n                }\n\n        }\n\n\n        if (result.isEmpty()) {\n                if (FILE_EXTENSIONS.equals(propertyName)) {\n                        result = \"all files\";\n\n                }\n                else {\n                        result = CURLY_BRACKETS;\n\n                }\n        }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "51", "src_id": "M114", "code": "private static void createListItem(XdocSink sink, Class<?> clss, String messageKey) {\n\n        final String messageKeyUrl = constructMessageKeyUrl(clss, messageKey);\n\n        final String indentLevel10 = SiteUtil.getNewlineAndIndentSpaces(10);\n\n        final String indentLevel12 = SiteUtil.getNewlineAndIndentSpaces(12);\n\n        final String indentLevel14 = SiteUtil.getNewlineAndIndentSpaces(14);\n        // Place the <li>.\n\n        sink.rawText(indentLevel10);\n        // This is a hack to prevent a newline from being inserted by the default sink.\n        // Once we get rid of the custom parser, we can remove this.\n        // until https://github.com/checkstyle/checkstyle/issues/13426\n\n\n\n        sink.setInsertNewline(false);\n\n\n\n\n        sink.listItem();\n\n\n\n\n        sink.setInsertNewline(true);\n\n        // Place an <a>.\n\n\n\n        sink.rawText(indentLevel12);\n\n\n\n\n        sink.link(messageKeyUrl);\n        // Further indent the text.\n\n\n\n        sink.rawText(indentLevel14);\n\n\n\n\n        sink.rawText(messageKey);\n\n        // Place closing </a> and </li> tags.\n\n\n\n        sink.rawText(indentLevel12);\n\n\n\n\n        sink.link_();\n\n\n\n\n        sink.rawText(indentLevel10);\n\n\n\n\n        sink.listItem_();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "52", "src_id": "M58", "code": "private static Set<Field> getCheckMessageKeys(Class<?> module)\nthrows MacroExecutionException {\n\n        try {\n\n                final Set<Field> checkstyleMessages = new HashSet<>();\n\n                // get all fields from current class\n\n\n                final Field[] fields = module.getDeclaredFields();\n\n\n                for (Field field : fields) {\n\n                        if (field.getName().startsWith(\"MSG_\")) {\n                                checkstyleMessages.add(field);\n\n                        }\n                }\n\n                // deep scan class through hierarchy\n\n                final Class<?> superModule = module.getSuperclass();\n\n\n                if (superModule != null) {\n                        checkstyleMessages.addAll(getCheckMessageKeys(superModule));\n\n                }\n\n                // special cases that require additional classes\n\n                if (module == RegexpMultilineCheck.class) {\n                        checkstyleMessages.addAll(getCheckMessageKeys(Class\n                        .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.MultilineDetector\")));\n\n                }\n                else if (module == RegexpSinglelineCheck.class\n                        || module == RegexpSinglelineJavaCheck.class) {\n                                checkstyleMessages.addAll(getCheckMessageKeys(Class\n                                .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.SinglelineDetector\")));\n\n                        }\n\n\n\n                return checkstyleMessages;\n\n        }\n\n        catch (ClassNotFoundException exc) {\n\n                final String message = String.format(Locale.ROOT, \"Couldn't find class: %s\",\n                module.getName());\n\n                throw new MacroExecutionException(message, exc);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "53", "src_id": "M68", "code": "private static Set<String> getNonExplicitProperties(\nObject instance, Class<?> clss) {\n\n        final Set<String> result = new TreeSet<>();\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n\n\n\n\n                final int[] acceptableTokens = check.getAcceptableTokens();\n\n                Arrays.sort(acceptableTokens);\n\n\n                final int[] defaultTokens = check.getDefaultTokens();\n\n                Arrays.sort(defaultTokens);\n\n\n                final int[] requiredTokens = check.getRequiredTokens();\n\n                Arrays.sort(requiredTokens);\n\n\n\n                if (!Arrays.equals(acceptableTokens, defaultTokens)\n                || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                        result.add(TOKENS);\n\n                }\n        }\n\n\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n                result.add(\"violateExecutionOnNonTightHtml\");\n\n\n\n                final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n\n                Arrays.sort(acceptableJavadocTokens);\n\n\n                final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n\n                Arrays.sort(defaultJavadocTokens);\n\n\n                final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n\n                Arrays.sort(requiredJavadocTokens);\n\n\n\n                if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                        result.add(JAVADOC_TOKENS);\n\n                }\n        }\n\n\n\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n                result.add(FILE_EXTENSIONS);\n\n        }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "54", "src_id": "M65", "code": "private static void processModule(String moduleName, Path modulePath)\nthrows MacroExecutionException {\n\n        if (!Files.isRegularFile(modulePath)) {\n                final String message = String.format(Locale.ROOT,\n                \"File %s is not a file. Please check the 'modulePath' property.\", modulePath);\n\n                throw new MacroExecutionException(message);\n\n        }\n        ClassAndPropertiesSettersJavadocScraper.initialize(moduleName);\n\n\n        final Checker checker = new Checker();\n\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n\n\n        final DefaultConfiguration scraperCheckConfig =\n        new DefaultConfiguration(\n        ClassAndPropertiesSettersJavadocScraper.class.getName());\n\n        final DefaultConfiguration defaultConfiguration =\n        new DefaultConfiguration(\"configuration\");\n\n        final DefaultConfiguration treeWalkerConfig =\n        new DefaultConfiguration(TreeWalker.class.getName());\n\n        defaultConfiguration.addProperty(CHARSET, StandardCharsets.UTF_8.name());\n\n\n\n\n        defaultConfiguration.addChild(treeWalkerConfig);\n\n\n\n\n        treeWalkerConfig.addChild(scraperCheckConfig);\n\n        try {\n\n                checker.configure(defaultConfiguration);\n\n\n                final List<File> filesToProcess = List.of(modulePath.toFile());\n\n                checker.process(filesToProcess);\n\n\n\n\n                checker.destroy();\n\n        }\n\n        catch (CheckstyleException checkstyleException) {\n\n                final String message = String.format(Locale.ROOT, \"Failed processing %s\", moduleName);\n\n                throw new MacroExecutionException(message, checkstyleException);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "55", "src_id": "M110", "code": "private static DetailAST getParentAst(DetailAST ast, int type) {\n\n        DetailAST node = ast.getParent();\n\n\n\n        while (node != null && node.getType() != type) {\n\n                node = node.getParent();\n\n        }\n\n\n\n        return node;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "185", "src_id": "M310", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n        return new int[] {\n\n        TokenTypes.CTOR_DEF,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.EXPR,\n        TokenTypes.LAND,\n        TokenTypes.BAND,\n        TokenTypes.LOR,\n        TokenTypes.BOR,\n        TokenTypes.BXOR,\n        TokenTypes.COMPACT_CTOR_DEF,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "186", "src_id": "M200", "code": "public static boolean matchesFileExtension(File file, String... fileExtensions) {\n\n        boolean result=false;\n\n        if (fileExtensions==null||fileExtensions.length==0) {\n                result=true;\n\n        }\n        else {\n                // normalize extensions so all of them have a leading dot\n                final String[] withDotExtensions=new String[fileExtensions.length];\n\n                for (int i=0; i<fileExtensions.length; i++) {\n\n                        final String extension=fileExtensions[i];\n\n                        if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                                withDotExtensions[i]=extension;\n\n                        }\n                        else {\n                                withDotExtensions[i]=EXTENSION_SEPARATOR+extension;\n\n                        }\n                }\n\n\n                final String fileName=file.getName();\n\n                for (final String fileExtension : withDotExtensions) {\n\n                        if (fileName.endsWith(fileExtension)) {\n                                result=true;\n\n                                break;\n\n                        }\n                }\n\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "187", "src_id": "M201", "code": "public static int lengthMinusTrailingWhitespace(String line) {\n\n        int len=line.length();\n\n        for (int i=len-1; i>=0; i--) {\n\n                if (!Character.isWhitespace(line.charAt(i))) {\n                        break;\n\n                }\n                len--;\n\n        }\n\n        return len;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "188", "src_id": "M255", "code": "private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n\n        boolean result=false;\n\n        final List<DetailAST> methodAnnotationsList=getMethodAnnotationsList(methodDef);\n\n        for (DetailAST annotationNode : methodAnnotationsList) {\n\n                if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                        result=true;\n\n                        break;\n\n                }\n        }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "189", "src_id": "M689", "code": "@Override\n\npublic int[] getRequiredTokens() {\n\n        return new int[] {\n\n        TokenTypes.ASSIGN,            // '='\n        TokenTypes.DIV_ASSIGN,        // \"/=\"\n        TokenTypes.PLUS_ASSIGN,       // \"+=\"\n        TokenTypes.MINUS_ASSIGN,      // \"-=\"\n        TokenTypes.STAR_ASSIGN,       // \"*=\"\n        TokenTypes.MOD_ASSIGN,        // \"%=\"\n        TokenTypes.SR_ASSIGN,         // \">>=\"\n        TokenTypes.BSR_ASSIGN,        // \">>>=\"\n        TokenTypes.SL_ASSIGN,         // \"<<=\"\n        TokenTypes.BXOR_ASSIGN,       // \"^=\"\n        TokenTypes.BOR_ASSIGN,        // \"|=\"\n        TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "168", "src_id": "M624", "code": "private static boolean hasLiteralNull(DetailAST caseAST) {\n\n            return Optional.ofNullable(caseAST.findFirstToken(TokenTypes.EXPR))\n            .map(exp -> exp.findFirstToken(TokenTypes.LITERAL_NULL))\n            .isPresent();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "169", "src_id": "M253", "code": "private void checkUnnamedVariables(DetailAST ast) {\n\n            if (jdkVersion >= JDK_22 && isUnnamedVariable(ast)) {\n                        checkForRedundantModifier(ast, TokenTypes.FINAL);\n\n            }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "170", "src_id": "M638", "code": "@Override\n\npublic void leaveToken(DetailAST ast) {\n\n            if (ast.getType() == TokenTypes.LITERAL_CATCH) {\n                        final Optional<CatchParameterDetails> unusedCatchParameter =\n                        Optional.ofNullable(catchParameters.peek())\n                        .filter(parameter -> !parameter.isUsed())\n                        .filter(parameter -> !\"_\".equals(parameter.getName()));\n\n\n                        unusedCatchParameter.ifPresent(parameter -> {\n                                    log(parameter.getParameterDefinition(),\n                                    MSG_UNUSED_CATCH_PARAMETER,\n                                    parameter.getName());\n\n                        });\n\n                        catchParameters.pop();\n\n            }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "171", "src_id": "M626", "code": "private static boolean hasStringCaseLabel(DetailAST caseAST) {\n\n            DetailAST curNode = caseAST;\n\n\n            boolean hasStringCaseLabel = false;\n\n\n            boolean exitCaseLabelExpression = false;\n\n            while (!exitCaseLabelExpression) {\n\n                        DetailAST toVisit = curNode.getFirstChild();\n\n\n                        if (curNode.getType() == TokenTypes.STRING_LITERAL) {\n                                    hasStringCaseLabel = true;\n\n                                    break;\n\n                        }\n                        while (toVisit == null) {\n\n                                    toVisit = curNode.getNextSibling();\n\n                                    curNode = curNode.getParent();\n\n                        }\n\n                        curNode = toVisit;\n\n                        exitCaseLabelExpression = TokenUtil.isOfType(curNode, TokenTypes.COLON,\n                        TokenTypes.LAMBDA);\n\n            }\n\n            return hasStringCaseLabel;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "172", "src_id": "M673", "code": "private static boolean isLambdaParameterIdentifierCandidate(DetailAST identifierAst) {\n            // we should ignore the ident if it is in the lambda parameters declaration\n            final boolean isLambdaParameterDeclaration =\n            identifierAst.getParent().getType() == TokenTypes.LAMBDA\n            || identifierAst.getParent().getType() == TokenTypes.PARAMETER_DEF;\n\n\n            return !isLambdaParameterDeclaration\n            && (hasValidParentToken(identifierAst) || isMethodInvocation(identifierAst));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "173", "src_id": "M251", "code": "public void setJdkVersion(String jdkVersion) {\n\n            final String singleVersionNumber;\n\n            if (jdkVersion.startsWith(\"1.\")) {\n                        singleVersionNumber = jdkVersion.substring(2);\n\n            }\n            else {\n                        singleVersionNumber = jdkVersion;\n\n            }\n\n\n            this.jdkVersion = Integer.parseInt(singleVersionNumber);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "174", "src_id": "M675", "code": "private static boolean isLeftHandOfAssignment(DetailAST identAst) {\n\n            final DetailAST parent = identAst.getParent();\n\n            return parent.getType() == TokenTypes.ASSIGN\n            && !identAst.equals(parent.getLastChild());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "131", "src_id": "M697", "code": "@Nullable\n\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\nDetailAST bound, int neededTokenType) {\n\n\n        DetailAST match = null;\n\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n\n        while (iteratedBranch != null) {\n\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n\n                        break;\n\n                }\n\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n\n        }\n\n\n\n        return match;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "132", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n\n        for (DetailAST astNode = previousSibling; astNode != null;\n        astNode = astNode.getLastChild()) {\n\n                previousSibling = astNode;\n\n        }\n\n\n\n        return token.getLineNo() != previousSibling.getLineNo();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "133", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n                }\n\n        }\n\n\n\n        return reassignedVariableIdents;\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "32", "src_id": "M597", "code": "private void checkTypeDefinition(DetailAST ast) {\n\n        if (!ScopeUtil.isOuterMostType(ast)&&isSemicolon(ast.getNextSibling())) {\n                log(ast.getNextSibling(), MSG_SEMI);\n\n        }\n\n        final DetailAST firstMember =\n        ast.findFirstToken(TokenTypes.OBJBLOCK).getFirstChild().getNextSibling();\n\n        if (isSemicolon(firstMember)&&!ScopeUtil.isInEnumBlock(firstMember)) {\n                log(firstMember, MSG_SEMI);\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "33", "src_id": "M655", "code": "private void checkLambda(DetailAST ast, DetailAST currentStatement) {\n\n        int countOfSemiInCurrentLambda=countOfSemiInLambda.pop();\n\n        countOfSemiInCurrentLambda++;\n\n        countOfSemiInLambda.push(countOfSemiInCurrentLambda);\n\n        if (!inForHeader&&countOfSemiInCurrentLambda>1\n        &&isOnTheSameLine(currentStatement,\n        lastStatementEnd, forStatementEnd,\n        lambdaStatementEnd)) {\n                log(ast, MSG_KEY);\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "34", "src_id": "M587", "code": "@Override\n\npublic void visitToken(DetailAST ast) {\n\n        final DetailAST enumBlock=ast.findFirstToken(TokenTypes.OBJBLOCK);\n\n        final DetailAST semicolon=enumBlock.findFirstToken(TokenTypes.SEMI);\n\n        if (semicolon!=null&&isEndOfEnumerationAfter(semicolon)) {\n                log(semicolon, MSG_SEMI);\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "35", "src_id": "M202", "code": "public static InputSource sourceFromFilename(String filename) throws CheckstyleException {\n        // figure out if this is a File or a URL\n        final URI uri=getUriByFilename(filename);\n\n        return new InputSource(uri.toASCIIString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "36", "src_id": "M633", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n        return new int[] {\n\n        TokenTypes.CLASS_DEF,\n        TokenTypes.INTERFACE_DEF,\n        TokenTypes.ENUM_DEF,\n        TokenTypes.ANNOTATION_DEF,\n        TokenTypes.RECORD_DEF,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "37", "src_id": "M285", "code": "private static void addSuppressions(List<String> values, DetailAST targetAST) {\n        // get text range of target\n        final int firstLine=targetAST.getLineNo();\n\n        final int firstColumn=targetAST.getColumnNo();\n\n        final DetailAST nextAST=targetAST.getNextSibling();\n\n        final int lastLine;\n\n        final int lastColumn;\n\n        if (nextAST==null) {\n                lastLine=Integer.MAX_VALUE;\n\n                lastColumn=Integer.MAX_VALUE;\n\n        }\n        else {\n                lastLine=nextAST.getLineNo();\n\n                lastColumn=nextAST.getColumnNo();\n\n        }\n\n\n        final List<Entry> entries=ENTRIES.get();\n\n        for (String value : values) {\n                // strip off the checkstyle-only prefix if present\n                final String checkName=removeCheckstylePrefixIfExists(value);\n\n                entries.add(new Entry(checkName, firstLine, firstColumn,\n                lastLine, lastColumn));\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "38", "src_id": "M276", "code": "@Override\n\npublic void visitToken(DetailAST ast) {\n\n        if (ast.getParent().getType()!=TokenTypes.SWITCH_RULE) {\n                final int length=getLength(ast);\n\n                if (length>max) {\n                        log(ast, MSG_KEY, length, max);\n\n                }\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "39", "src_id": "M279", "code": "private static int getFirstNodeLineNumber(DetailAST lambdaBody) {\n\n        DetailAST node=lambdaBody;\n\n        int result;\n\n        do {\n\n                result=node.getLineNo();\n\n                node=node.getFirstChild();\n\n        } while (node!=null);\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "79", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n\n        final Pattern result;\n\n\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n\n        }\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "80", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "90", "src_id": "M37", "code": "private ModuleType getModuleType() {\n\n        final String simpleModuleName = getModuleSimpleName();\n\n        final ModuleType result;\n\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n                result = ModuleType.FILEFILTER;\n\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n                        result = ModuleType.FILTER;\n\n                }\n                else {\n                        result = ModuleType.CHECK;\n\n                }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "91", "src_id": "M28", "code": "private void scrapeContent(DetailNode ast) {\n\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n                if (isParentText(ast)) {\n                        parentSectionStartIdx = getParentIndexOf(ast);\n\n                        moduleDetails.setParent(getParentText(ast));\n\n                }\n                else if (isViolationMessagesText(ast)) {\n                                scrapingViolationMessageList = true;\n\n                        }\n                        else if (exampleSectionStartIdx == -1\n                                && isExamplesText(ast)) {\n                                        exampleSectionStartIdx = getParentIndexOf(ast);\n\n                                }\n\n\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n                        if (isPropertyList(ast)) {\n                                if (propertySectionStartIdx == -1) {\n                                        propertySectionStartIdx = getParentIndexOf(ast);\n\n                                }\n                                moduleDetails.addToProperties(createProperties(ast));\n\n                        }\n                        else if (scrapingViolationMessageList) {\n                                        moduleDetails.addToViolationMessages(getViolationMessages(ast));\n\n                                }\n\n                }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "92", "src_id": "M27", "code": "@Override\n\npublic void beginJavadocTree(DetailNode rootAst) {\n\n        if (isTopLevelClassJavadoc()) {\n                moduleDetails = new ModuleDetails();\n\n                toScan = false;\n\n                scrapingViolationMessageList = false;\n\n                propertySectionStartIdx = -1;\n\n                exampleSectionStartIdx = -1;\n\n                parentSectionStartIdx = -1;\n\n\n\n                String moduleName = getModuleSimpleName();\n\n                final String checkModuleExtension = \"Check\";\n\n                if (moduleName.endsWith(checkModuleExtension)) {\n                        moduleName = moduleName\n                        .substring(0, moduleName.length() - checkModuleExtension.length());\n\n                }\n                moduleDetails.setName(moduleName);\n\n                moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n\n                moduleDetails.setModuleType(getModuleType());\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "93", "src_id": "M35", "code": "private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\nPattern pattern) {\n\n        return Arrays.stream(node.getChildren())\n        .filter(child -> pattern.matcher(child.getText()).matches())\n        .findFirst();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "152", "src_id": "M310", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n        return new int[] {\n\n        TokenTypes.CTOR_DEF,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.EXPR,\n        TokenTypes.LAND,\n        TokenTypes.BAND,\n        TokenTypes.LOR,\n        TokenTypes.BOR,\n        TokenTypes.BXOR,\n        TokenTypes.COMPACT_CTOR_DEF,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "153", "src_id": "M200", "code": "public static boolean matchesFileExtension(File file, String... fileExtensions) {\n\n        boolean result=false;\n\n        if (fileExtensions==null||fileExtensions.length==0) {\n                result=true;\n\n        }\n        else {\n                // normalize extensions so all of them have a leading dot\n                final String[] withDotExtensions=new String[fileExtensions.length];\n\n\n                for (int i=0; i<fileExtensions.length; i++) {\n\n                        final String extension=fileExtensions[i];\n\n\n                        if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                                withDotExtensions[i]=extension;\n\n                        }\n                        else {\n                                withDotExtensions[i]=EXTENSION_SEPARATOR+extension;\n\n                        }\n                }\n\n\n\n                final String fileName=file.getName();\n\n\n                for (final String fileExtension : withDotExtensions) {\n\n                        if (fileName.endsWith(fileExtension)) {\n                                result=true;\n\n                                break;\n\n                        }\n                }\n\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "154", "src_id": "M201", "code": "public static int lengthMinusTrailingWhitespace(String line) {\n\n        int len=line.length();\n\n        for (int i=len-1; i>=0; i--) {\n\n                if (!Character.isWhitespace(line.charAt(i))) {\n                        break;\n\n                }\n                len--;\n\n        }\n\n        return len;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "155", "src_id": "M255", "code": "private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n\n        boolean result=false;\n\n        final List<DetailAST> methodAnnotationsList=getMethodAnnotationsList(methodDef);\n\n\n        for (DetailAST annotationNode : methodAnnotationsList) {\n\n                if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                        result=true;\n\n                        break;\n\n                }\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "156", "src_id": "M689", "code": "@Override\n\npublic int[] getRequiredTokens() {\n\n        return new int[] {\n\n        TokenTypes.ASSIGN,            // '='\n        TokenTypes.DIV_ASSIGN,        // \"/=\"\n        TokenTypes.PLUS_ASSIGN,       // \"+=\"\n        TokenTypes.MINUS_ASSIGN,      // \"-=\"\n        TokenTypes.STAR_ASSIGN,       // \"*=\"\n        TokenTypes.MOD_ASSIGN,        // \"%=\"\n        TokenTypes.SR_ASSIGN,         // \">>=\"\n        TokenTypes.BSR_ASSIGN,        // \">>>=\"\n        TokenTypes.SL_ASSIGN,         // \"<<=\"\n        TokenTypes.BXOR_ASSIGN,       // \"^=\"\n        TokenTypes.BOR_ASSIGN,        // \"|=\"\n        TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "56", "src_id": "M697", "code": "@Nullable\n\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\nDetailAST bound, int neededTokenType) {\n\n\n        DetailAST match = null;\n\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n\n\n        while (iteratedBranch != null) {\n\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n\n                        break;\n\n                }\n\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n\n        }\n\n\n\n        return match;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "57", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n\n\n        for (DetailAST astNode = previousSibling; astNode != null;\n        astNode = astNode.getLastChild()) {\n\n                previousSibling = astNode;\n\n        }\n\n\n\n        return token.getLineNo() != previousSibling.getLineNo();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "58", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n                }\n\n        }\n\n\n\n        return reassignedVariableIdents;\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "9", "src_id": "M855", "code": "@Override\n\npublic DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n\n        final DetailAstImpl bop=create(ctx.bop);\n\n        bop.addChild(visit(ctx.expr()));\n\n        bop.addChild(create(ctx.LITERAL_THIS()));\n\n\n        return bop;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "10", "src_id": "M770", "code": "@Override\n\npublic DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n\n        final DetailAstImpl interfaceExtends=create(ctx.EXTENDS_CLAUSE());\n\n        interfaceExtends.addChild(visit(ctx.typeList()));\n\n\n        return interfaceExtends;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "11", "src_id": "M854", "code": "@Override\n\npublic DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n\n        final DetailAstImpl lambda=create(ctx.LAMBDA());\n\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n\n\n        final JavaLanguageParser.BlockContext blockContext=ctx.block();\n\n\n        final DetailAstImpl rightHandLambdaChild;\n\n\n        if (blockContext!=null) {\n                rightHandLambdaChild=visit(blockContext);\n\n        }\n        else {\n                // Lambda expression child is built the same way that we build\n                // the initial expression node in visitExpression, i.e. with\n                // an imaginary EXPR node. This results in nested EXPR nodes\n                // in the AST.\n                rightHandLambdaChild=buildExpressionNode(ctx.expr());\n\n        }\n        lambda.addChild(rightHandLambdaChild);\n\n\n        return lambda;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "12", "src_id": "M779", "code": "@Override\n\npublic DetailAstImpl visitInterfaceMethodDeclaration(\nJavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n\n        final DetailAstImpl methodDef=createImaginary(TokenTypes.METHOD_DEF);\n\n        methodDef.addChild(createModifiers(ctx.mods));\n\n        // Process all children except C style array declarators and modifiers\n\n        final List<ParseTree> children=ctx.children\n        .stream()\n        .filter(child->!(childinstanceofJavaLanguageParser.ArrayDeclaratorContext))\n        .collect(Collectors.toUnmodifiableList());\n\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n\n        final DetailAstImpl typeAst=(DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n\n        ctx.cStyleArrDec.forEach(child->typeAst.addChild(visit(child)));\n\n\n\n        return methodDef;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "13", "src_id": "M839", "code": "@Override\n\npublic DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n\n        final DetailAstImpl dummyRoot=new DetailAstImpl();\n\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n\n        if (ctx.forInit()==null) {\n                final DetailAstImpl imaginaryForInitParent =\n                createImaginary(TokenTypes.FOR_INIT);\n\n                dummyRoot.addChild(imaginaryForInitParent);\n\n        }\n        else {\n                dummyRoot.addChild(visit(ctx.forInit()));\n\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n\n\n        final DetailAstImpl forCondParent=createImaginary(TokenTypes.FOR_CONDITION);\n\n        forCondParent.addChild(visit(ctx.forCond));\n\n        dummyRoot.addChild(forCondParent);\n\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n\n\n        final DetailAstImpl forItParent=createImaginary(TokenTypes.FOR_ITERATOR);\n\n        forItParent.addChild(visit(ctx.forUpdate));\n\n        dummyRoot.addChild(forItParent);\n\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n\n\n        return dummyRoot.getFirstChild();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "14", "src_id": "M228", "code": "private static Map.Entry<Integer, Integer> countLinesColumns(\nString text, int initialLinesCnt, int initialColumnsCnt) {\n\n        int lines=initialLinesCnt;\n\n\n        int columns=initialColumnsCnt;\n\n\n        boolean foundCr=false;\n\n        for (char c : text.toCharArray()) {\n\n                if (c=='\\n') {\n                        foundCr=false;\n\n                        lines++;\n\n                        columns=0;\n\n                }\n                else {\n                        if (foundCr) {\n                                foundCr=false;\n\n                                lines++;\n\n                                columns=0;\n\n                        }\n                        if (c=='\\r') {\n                                foundCr=true;\n\n                        }\n                        columns++;\n\n                }\n        }\n\n        if (foundCr) {\n                lines++;\n\n                columns=0;\n\n        }\n\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "15", "src_id": "M212", "code": "public static Properties getResolvedProperties(Properties properties)\nthrows CheckstyleException {\n\n        final Set<String> unresolvedPropertyNames =\n        new HashSet<>(properties.stringPropertyNames());\n\n\n        Iterator<String> unresolvedPropertyIterator=unresolvedPropertyNames.iterator();\n\n\n        final Map<Object, Object> comparisonProperties=new Properties();\n\n\n\n        while (unresolvedPropertyIterator.hasNext()) {\n\n                final String propertyName=unresolvedPropertyIterator.next();\n\n\n                String propertyValue=properties.getProperty(propertyName);\n\n\n                final Matcher matcher=PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n\n\n                while (matcher.find()) {\n\n                        final String propertyVariableExpression=matcher.group();\n\n\n                        final String unresolvedPropertyName =\n                        getPropertyNameFromExpression(propertyVariableExpression);\n\n\n\n                        final String resolvedPropertyValue =\n                        properties.getProperty(unresolvedPropertyName);\n\n\n\n                        if (resolvedPropertyValue!=null) {\n                                propertyValue=propertyValue.replace(propertyVariableExpression,\n                                resolvedPropertyValue);\n\n                                properties.setProperty(propertyName, propertyValue);\n\n                        }\n                }\n\n\n                if (allChainedPropertiesAreResolved(propertyValue)) {\n                        unresolvedPropertyIterator.remove();\n\n                }\n\n\n                if (!unresolvedPropertyIterator.hasNext()) {\n\n                        if (comparisonProperties.equals(properties)) {\n                                // At this point, we will have not resolved any properties in two iterations,\n                                // so unresolvable properties exist.\n                                throw new CheckstyleException(UNDEFINED_PROPERTY_MESSAGE\n                                +unresolvedPropertyNames);\n\n                        }\n                        comparisonProperties.putAll(properties);\n\n                        unresolvedPropertyIterator=unresolvedPropertyNames.iterator();\n\n                }\n\n        }\n\n\n        return properties;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "16", "src_id": "M794", "code": "@Override\n\npublic DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n\n        final DetailAstImpl annotations;\n\n\n\n        if (!ctx.createImaginaryNode&&ctx.anno.isEmpty()) {\n                // There are no annotations, and we don't want to create the empty node\n                annotations=null;\n\n        }\n        else {\n                // There are annotations, or we just want the empty node\n                annotations=createImaginary(TokenTypes.ANNOTATIONS);\n\n                processChildren(annotations, ctx.anno);\n\n        }\n\n\n        return annotations;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "17", "src_id": "M764", "code": "@Override\n\npublic DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n\n        final DetailAstImpl typeParameter=createImaginary(TokenTypes.TYPE_PARAMETER);\n\n        processChildren(typeParameter, ctx.children);\n\n\n        return typeParameter;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "18", "src_id": "M492", "code": "private void checkYield() {\n\n        final DetailAST yieldKey=getMainAst();\n\n\n        final int columnNo=expandedTabsColumnNo(yieldKey);\n\n\n        if (isOnStartOfLine(yieldKey)&&!getIndent().isAcceptable(columnNo)) {\n                logError(yieldKey, \"\", columnNo);\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "108", "src_id": "M697", "code": "@Nullable\n\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\nDetailAST bound, int neededTokenType) {\n\n\n        DetailAST match = null;\n\n\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n\n\n        while (iteratedBranch != null) {\n\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n\n                        break;\n\n                }\n\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n\n        }\n\n\n\n        return match;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "109", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n\n\n        for (DetailAST astNode = previousSibling; astNode != null;\n        astNode = astNode.getLastChild()) {\n\n                previousSibling = astNode;\n\n        }\n\n\n\n        return token.getLineNo() != previousSibling.getLineNo();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "110", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n                }\n\n        }\n\n\n\n        return reassignedVariableIdents;\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "190", "src_id": "M310", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n            return new int[] {\n\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n            };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "191", "src_id": "M200", "code": "public static boolean matchesFileExtension(File file, String... fileExtensions) {\n\n            boolean result = false;\n\n\n            if (fileExtensions == null || fileExtensions.length == 0) {\n                        result = true;\n\n            }\n            else {\n                        // normalize extensions so all of them have a leading dot\n                        final String[] withDotExtensions = new String[fileExtensions.length];\n\n                        for (int i = 0; i < fileExtensions.length; i++) {\n\n                                    final String extension = fileExtensions[i];\n\n                                    if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                                                withDotExtensions[i] = extension;\n\n                                    }\n                                    else {\n                                                withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n\n                                    }\n                        }\n\n\n\n                        final String fileName = file.getName();\n\n                        for (final String fileExtension : withDotExtensions) {\n\n                                    if (fileName.endsWith(fileExtension)) {\n                                                result = true;\n\n                                                break;\n\n                                    }\n                        }\n\n            }\n\n\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "192", "src_id": "M201", "code": "public static int lengthMinusTrailingWhitespace(String line) {\n\n            int len = line.length();\n\n            for (int i = len - 1; i >= 0; i--) {\n\n                        if (!Character.isWhitespace(line.charAt(i))) {\n                                    break;\n\n                        }\n                        len--;\n\n            }\n\n            return len;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "193", "src_id": "M255", "code": "private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n\n            boolean result = false;\n\n\n            final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n\n            for (DetailAST annotationNode : methodAnnotationsList) {\n\n                        if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                                    result = true;\n\n                                    break;\n\n                        }\n            }\n\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "194", "src_id": "M689", "code": "@Override\n\npublic int[] getRequiredTokens() {\n\n            return new int[] {\n\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n            };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "175", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n\n        final Pattern result;\n\n\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n\n        }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "176", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "94", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n\n        final Pattern result;\n\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n\n        }\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "95", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "81", "src_id": "M646", "code": "private static List<DetailAST> getChildList(DetailAST ast) {\n\n            final List<DetailAST> children = new ArrayList<>();\n\n\n            DetailAST child = ast.findFirstToken(TokenTypes.OBJBLOCK).getFirstChild();\n\n            while (child != null) {\n\n                        children.add(child);\n\n                        child = child.getNextSibling();\n\n            }\n\n            return children;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "82", "src_id": "M373", "code": "private void checkParagraphTag(DetailNode tag) {\n\n            if (!isNestedParagraph(tag)) {\n                        final DetailNode newLine = getNearestEmptyLine(tag);\n\n\n                        if (isFirstParagraph(tag)) {\n                                    log(tag.getLineNumber(), tag.getColumnNumber(), MSG_REDUNDANT_PARAGRAPH);\n\n                        }\n                        else if (newLine == null || tag.getLineNumber() - newLine.getLineNumber() != 1) {\n                                                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_LINE_BEFORE);\n\n                                    }\n\n\n\n                        final String blockTagName = findFollowedBlockTagName(tag);\n\n\n                        if (blockTagName != null) {\n                                    log(tag.getLineNumber(), tag.getColumnNumber(),\n                                    MSG_PRECEDED_BLOCK_TAG, blockTagName);\n\n                        }\n\n\n                        if (!allowNewlineParagraph && isImmediatelyFollowedByNewLine(tag)) {\n                                    log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n\n                        }\n\n                        if (isImmediatelyFollowedByText(tag)) {\n                                    log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n\n                        }\n            }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "83", "src_id": "M406", "code": "@Override\n\npublic void finishJavadocTree(DetailNode rootAst) {\n            // this method checks the alignment of closing javadoc tag.\n            final DetailAST javadocEndToken = getBlockCommentAst().getLastChild();\n\n\n            final String lastLine = fileLines[javadocEndToken.getLineNo() - 1];\n\n\n            final Optional<Integer> endingBlockColumnNumber = getAsteriskColumnNumber(lastLine);\n\n\n            endingBlockColumnNumber\n            .map(columnNumber -> expandedTabs(lastLine, columnNumber))\n            .filter(columnNumber -> {\n                        return !hasValidAlignment(expectedColumnNumberTabsExpanded, columnNumber);\n\n            })\n            .ifPresent(columnNumber -> {\n                        logViolation(javadocEndToken.getLineNo(),\n                        columnNumber,\n                        expectedColumnNumberTabsExpanded);\n\n            });\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "134", "src_id": "M502", "code": "private int expandedTabsColumnNo(DetailAST ast) {\n\n        final String line =\n        indentCheck.getLine(ast.getLineNo()-1);\n\n\n\n        return CommonUtil.lengthExpandedTabs(line, ast.getColumnNo(),\n        indentCheck.getIndentationTabWidth());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "135", "src_id": "M455", "code": "@Override\n\npublic void init() {\n\n        if (fileNamePattern==null&&folderPattern==null) {\n                fileNamePattern=CommonUtil.createPattern(\"\\\\s\");\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "136", "src_id": "M456", "code": "@Override\n\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n\n        final String fileName=getFileName(file);\n\n        final String folderPath=getFolderPath(file);\n\n\n        if (isMatchFolder(folderPath)&&isMatchFile(fileName)) {\n                log();\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "137", "src_id": "M165", "code": "private AxisIterator getPrecedingSiblingsIterator() {\n\n        final AxisIterator result;\n\n        if (indexAmongSiblings==0) {\n                result=EmptyIterator.ofNodes();\n\n        }\n        else {\n                result=new ReverseListIterator(getPrecedingSiblings());\n\n        }\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "138", "src_id": "M750", "code": "private static String convertUpperCamelToUpperUnderscore(String text) {\n\n        final StringBuilder result=new StringBuilder(20);\n\n        boolean first=true;\n\n        for (char letter : text.toCharArray()) {\n\n                if (!first&&Character.isUpperCase(letter)) {\n                        result.append('_');\n\n                }\n                result.append(Character.toUpperCase(letter));\n\n                first=false;\n\n        }\n\n\n        return result.toString();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "139", "src_id": "M346", "code": "@Override\n\nprotected boolean matchesExactly(String pkg, String fileName) {\n\n        final boolean result;\n\n        if (fileName==null) {\n                result=false;\n\n        }\n        else if (regex) {\n                        result=patternForExactMatch.matcher(fileName).matches();\n\n                }\n                else {\n                        result=name.equals(fileName);\n\n                }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "140", "src_id": "M706", "code": "@Override\n\npublic void beginTree(DetailAST rootAST) {\n\n        frames=new HashMap<>();\n\n        current.clear();\n\n\n        final Deque<AbstractFrame> frameStack=new LinkedList<>();\n\n        DetailAST curNode=rootAST;\n\n        while (curNode!=null) {\n\n                collectDeclarations(frameStack, curNode);\n\n                DetailAST toVisit=curNode.getFirstChild();\n\n                while (curNode!=null&&toVisit==null) {\n\n                        endCollectingDeclarations(frameStack, curNode);\n\n                        toVisit=curNode.getNextSibling();\n\n                        curNode=curNode.getParent();\n\n                }\n\n                curNode=toVisit;\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "141", "src_id": "M308", "code": "@Override\n\npublic void leaveToken(DetailAST ast) {\n\n        switch (ast.getType()) {\n\n                case TokenTypes.CTOR_DEF:\n                case TokenTypes.METHOD_DEF:\n                case TokenTypes.INSTANCE_INIT:\n                case TokenTypes.STATIC_INIT:\n                case TokenTypes.COMPACT_CTOR_DEF:\n                        leaveMethodDef(ast);\n                        break;\n\n                default:\n                        break;\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "142", "src_id": "M167", "code": "private AttributeNode getAttributeNode() {\n\n        if (attributeNode==ATTRIBUTE_NODE_UNINITIALIZED) {\n                attributeNode=createAttributeNode();\n\n        }\n        return attributeNode;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "143", "src_id": "M398", "code": "@Override\n\npublic int[] getDefaultTokens() {\n\n        return new int[] {\n\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "59", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n\n        return entry.getLastLine() > line\n        || entry.getLastLine() == line && entry\n        .getLastColumn() >= column;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "60", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n\n        return classDef.getType() != TokenTypes.ENUM_DEF\n        && modifiers.findFirstToken(TokenTypes.FINAL) == null\n        && hasDefaultOrExplicitNonPrivateCtor(classDef);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "61", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n\n        DetailAST vertex = ast;\n\n        final Set<DetailAST> result = new HashSet<>();\n\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n\n                }\n                while (vertex != null) {\n\n                        if (vertex.getType() == tokenType) {\n                                result.add(vertex);\n\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n\n                        }\n                        vertex = vertex.getFirstChild();\n\n                }\n\n        }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "62", "src_id": "M504", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n        return new int[] {\n\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "63", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n\n        final int dotIndex = fileName.lastIndexOf('.');\n\n        final String extension;\n\n        if (dotIndex == -1) {\n                extension = \"\";\n\n        }\n        else {\n                extension = fileName.substring(dotIndex + 1);\n\n        }\n        return extension;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "64", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\nint endLineNumber) {\n\n        DetailAST vertex = ast;\n\n        final Set<DetailAST> result = new HashSet<>();\n\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n\n                }\n                while (vertex != null) {\n\n                        if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                                result.add(vertex);\n\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n\n                        }\n                        vertex = vertex.getFirstChild();\n\n                }\n\n        }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "65", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n\n        DetailAST searchAST = ast;\n\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n        && searchAST.getType() != TokenTypes.ENUM_DEF) {\n\n                searchAST = searchAST.getParent();\n\n        }\n\n        return searchAST;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "66", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n\n        boolean forwardReference = false;\n\n        for (DetailAST ident : exprIdents) {\n\n                if (classFieldNames.contains(ident.getText())) {\n                        forwardReference = true;\n\n                        break;\n\n                }\n        }\n\n        return forwardReference;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "40", "src_id": "M697", "code": "@Nullable\n\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\nDetailAST bound, int neededTokenType) {\n\n\n            DetailAST match = null;\n\n\n            DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n\n            while (iteratedBranch != null) {\n\n                        if (iteratedBranch.getType() == neededTokenType) {\n                                    match = iteratedBranch;\n\n                                    break;\n\n                        }\n\n\n                        iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n\n            }\n\n\n\n            return match;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "41", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n\n            DetailAST previousSibling = parentToken.getPreviousSibling();\n\n            for (DetailAST astNode = previousSibling; astNode != null;\n            astNode = astNode.getLastChild()) {\n\n                        previousSibling = astNode;\n\n            }\n\n\n\n            return token.getLineNo() != previousSibling.getLineNo();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "42", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n\n            final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n            final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n\n            for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n            expressionBranch != null;\n            expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n            branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n\n                        final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n\n                        if (assignToken != null) {\n                                    reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n                        }\n\n            }\n\n\n\n            return reassignedVariableIdents;\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "157", "src_id": "M347", "code": "@Override\n\npublic void visitToken(DetailAST ast) {\n\n        switch (ast.getType()) {\n\n                case TokenTypes.IDENT:\n                        if (collect) {\n                                processIdent(ast);\n\n                        }\n                        break;\n\n                case TokenTypes.IMPORT:\n                        processImport(ast);\n                        break;\n\n                case TokenTypes.STATIC_IMPORT:\n                        processStaticImport(ast);\n                        break;\n\n                case TokenTypes.OBJBLOCK:\n                case TokenTypes.SLIST:\n                        currentFrame = currentFrame.push();\n                        break;\n\n                default:\n                        collect = true;\n                        if (processJavadoc) {\n                                collectReferencesFromJavadoc(ast);\n\n                        }\n                        break;\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "158", "src_id": "M394", "code": "@Override\n\npublic int[] getRequiredJavadocTokens() {\n\n        return new int[] {\n\n        JavadocTokenTypes.TEXT,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "159", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n\n        DetailAST result;\n\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                result = node.getPreviousSibling();\n\n        }\n        else if (isInPatternDefinition(node)) {\n                        result = node.getFirstChild();\n\n                }\n                else {\n                        result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n\n                }\n\n        while (result.getLastChild() != null) {\n\n                result = result.getLastChild();\n\n        }\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "19", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n\n        return entry.getLastLine() > line\n        || entry.getLastLine() == line && entry\n        .getLastColumn() >= column;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "20", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n\n        return classDef.getType() != TokenTypes.ENUM_DEF\n        && modifiers.findFirstToken(TokenTypes.FINAL) == null\n        && hasDefaultOrExplicitNonPrivateCtor(classDef);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "21", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n\n        DetailAST vertex = ast;\n\n\n        final Set<DetailAST> result = new HashSet<>();\n\n\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n\n                }\n                while (vertex != null) {\n\n                        if (vertex.getType() == tokenType) {\n                                result.add(vertex);\n\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n\n                        }\n                        vertex = vertex.getFirstChild();\n\n                }\n\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "22", "src_id": "M504", "code": "@Override\n\npublic int[] getAcceptableTokens() {\n\n        return new int[] {\n\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "23", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n\n\n        final int dotIndex = fileName.lastIndexOf('.');\n\n\n        final String extension;\n\n        if (dotIndex == -1) {\n                extension = \"\";\n\n        }\n        else {\n                extension = fileName.substring(dotIndex + 1);\n\n        }\n\n        return extension;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "24", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\nint endLineNumber) {\n\n        DetailAST vertex = ast;\n\n\n        final Set<DetailAST> result = new HashSet<>();\n\n\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n\n                }\n                while (vertex != null) {\n\n                        if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                                result.add(vertex);\n\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n\n                        }\n                        vertex = vertex.getFirstChild();\n\n                }\n\n        }\n\n\n        return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "25", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n\n        DetailAST searchAST = ast;\n\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n        && searchAST.getType() != TokenTypes.ENUM_DEF) {\n\n                searchAST = searchAST.getParent();\n\n        }\n\n\n        return searchAST;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "26", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n\n\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n\n\n        boolean forwardReference = false;\n\n        for (DetailAST ident : exprIdents) {\n\n                if (classFieldNames.contains(ident.getText())) {\n                        forwardReference = true;\n\n                        break;\n\n                }\n        }\n\n\n        return forwardReference;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "111", "src_id": "M855", "code": "@Override\n\npublic DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n\n        final DetailAstImpl bop = create(ctx.bop);\n\n        bop.addChild(visit(ctx.expr()));\n\n        bop.addChild(create(ctx.LITERAL_THIS()));\n\n\n        return bop;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "112", "src_id": "M770", "code": "@Override\n\npublic DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n\n        final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n\n        interfaceExtends.addChild(visit(ctx.typeList()));\n\n\n        return interfaceExtends;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "113", "src_id": "M854", "code": "@Override\n\npublic DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n\n        final DetailAstImpl lambda = create(ctx.LAMBDA());\n\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n\n\n        final JavaLanguageParser.BlockContext blockContext = ctx.block();\n\n\n        final DetailAstImpl rightHandLambdaChild;\n\n        if (blockContext != null) {\n                rightHandLambdaChild = visit(blockContext);\n\n        }\n        else {\n                // Lambda expression child is built the same way that we build\n                // the initial expression node in visitExpression, i.e. with\n                // an imaginary EXPR node. This results in nested EXPR nodes\n                // in the AST.\n                rightHandLambdaChild = buildExpressionNode(ctx.expr());\n\n        }\n        lambda.addChild(rightHandLambdaChild);\n\n\n        return lambda;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "114", "src_id": "M779", "code": "@Override\n\npublic DetailAstImpl visitInterfaceMethodDeclaration(\nJavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n\n        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n\n        methodDef.addChild(createModifiers(ctx.mods));\n\n        // Process all children except C style array declarators and modifiers\n\n        final List<ParseTree> children = ctx.children\n        .stream()\n        .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n        .collect(Collectors.toUnmodifiableList());\n\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n\n        final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n\n        ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n\n\n        return methodDef;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "115", "src_id": "M839", "code": "@Override\n\npublic DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n\n        final DetailAstImpl dummyRoot = new DetailAstImpl();\n\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n\n\n        if (ctx.forInit() == null) {\n                final DetailAstImpl imaginaryForInitParent =\n                createImaginary(TokenTypes.FOR_INIT);\n\n                dummyRoot.addChild(imaginaryForInitParent);\n\n        }\n        else {\n                dummyRoot.addChild(visit(ctx.forInit()));\n\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n\n\n        final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n\n        forCondParent.addChild(visit(ctx.forCond));\n\n        dummyRoot.addChild(forCondParent);\n\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n\n\n        final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n\n        forItParent.addChild(visit(ctx.forUpdate));\n\n        dummyRoot.addChild(forItParent);\n\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n\n\n        return dummyRoot.getFirstChild();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "116", "src_id": "M228", "code": "private static Map.Entry<Integer, Integer> countLinesColumns(\nString text, int initialLinesCnt, int initialColumnsCnt) {\n\n        int lines = initialLinesCnt;\n\n\n        int columns = initialColumnsCnt;\n\n\n        boolean foundCr = false;\n\n        for (char c : text.toCharArray()) {\n\n                if (c == '\\n') {\n                        foundCr = false;\n\n                        lines++;\n\n                        columns = 0;\n\n                }\n                else {\n                        if (foundCr) {\n                                foundCr = false;\n\n                                lines++;\n\n                                columns = 0;\n\n                        }\n                        if (c == '\\r') {\n                                foundCr = true;\n\n                        }\n                        columns++;\n\n                }\n        }\n\n        if (foundCr) {\n                lines++;\n\n                columns = 0;\n\n        }\n\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "117", "src_id": "M212", "code": "public static Properties getResolvedProperties(Properties properties)\nthrows CheckstyleException {\n\n        final Set<String> unresolvedPropertyNames =\n        new HashSet<>(properties.stringPropertyNames());\n\n\n        Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n\n\n        final Map<Object, Object> comparisonProperties = new Properties();\n\n\n\n        while (unresolvedPropertyIterator.hasNext()) {\n\n                final String propertyName = unresolvedPropertyIterator.next();\n\n\n                String propertyValue = properties.getProperty(propertyName);\n\n\n                final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n\n\n                while (matcher.find()) {\n\n                        final String propertyVariableExpression = matcher.group();\n\n\n                        final String unresolvedPropertyName =\n                        getPropertyNameFromExpression(propertyVariableExpression);\n\n\n\n                        final String resolvedPropertyValue =\n                        properties.getProperty(unresolvedPropertyName);\n\n\n                        if (resolvedPropertyValue != null) {\n                                propertyValue = propertyValue.replace(propertyVariableExpression,\n                                resolvedPropertyValue);\n\n                                properties.setProperty(propertyName, propertyValue);\n\n                        }\n                }\n\n\n                if (allChainedPropertiesAreResolved(propertyValue)) {\n                        unresolvedPropertyIterator.remove();\n\n                }\n\n\n                if (!unresolvedPropertyIterator.hasNext()) {\n\n                        if (comparisonProperties.equals(properties)) {\n                                // At this point, we will have not resolved any properties in two iterations,\n                                // so unresolvable properties exist.\n                                throw new CheckstyleException(UNDEFINED_PROPERTY_MESSAGE\n                                + unresolvedPropertyNames);\n\n                        }\n                        comparisonProperties.putAll(properties);\n\n                        unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n\n                }\n\n        }\n\n        return properties;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "118", "src_id": "M794", "code": "@Override\n\npublic DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n\n        final DetailAstImpl annotations;\n\n\n        if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n                // There are no annotations, and we don't want to create the empty node\n                annotations = null;\n\n        }\n        else {\n                // There are annotations, or we just want the empty node\n                annotations = createImaginary(TokenTypes.ANNOTATIONS);\n\n                processChildren(annotations, ctx.anno);\n\n        }\n\n\n        return annotations;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "119", "src_id": "M764", "code": "@Override\n\npublic DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n\n        final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n\n        processChildren(typeParameter, ctx.children);\n\n\n        return typeParameter;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "120", "src_id": "M492", "code": "private void checkYield() {\n\n        final DetailAST yieldKey = getMainAst();\n\n\n        final int columnNo = expandedTabsColumnNo(yieldKey);\n\n        if (isOnStartOfLine(yieldKey) && !getIndent().isAcceptable(columnNo)) {\n                logError(yieldKey, \"\", columnNo);\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "177", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n            return CommonUtil.createPattern(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "178", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n            return SeverityLevel.getInstance(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "179", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n\n            final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n\n            registerIntegralTypes(cub);\n\n            registerCustomTypes(cub);\n\n\n\n            return new BeanUtilsBean(cub, new PropertyUtilsBean());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "180", "src_id": "M4", "code": "@Override\n\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n\n            configuration = config;\n\n\n            final String[] attributes = config.getPropertyNames();\n\n\n            for (final String key : attributes) {\n\n                        final String value = config.getProperty(key);\n\n\n                        tryCopyProperty(key, value, true);\n\n            }\n\n\n\n            finishLocalSetup();\n\n\n            final Configuration[] childConfigs = config.getChildren();\n\n            for (final Configuration childConfig : childConfigs) {\n\n                        setupChild(childConfig);\n\n            }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "181", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n\n            final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n\n\n            final String annotationString;\n\n            // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n\n            if (identNode == null) {\n                        final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n\n                        annotationString = FullIdent.createFullIdent(dotNode).getText();\n\n            }\n            else {\n                        annotationString = identNode.getText();\n\n            }\n\n\n            return annotationString;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "195", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return CommonUtil.createPattern(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "196", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return SeverityLevel.getInstance(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "197", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n\n        registerIntegralTypes(cub);\n\n        registerCustomTypes(cub);\n\n\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "198", "src_id": "M4", "code": "@Override\n\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n\n        configuration = config;\n\n\n\n        final String[] attributes = config.getPropertyNames();\n\n\n        for (final String key : attributes) {\n\n                final String value = config.getProperty(key);\n\n\n                tryCopyProperty(key, value, true);\n\n        }\n\n\n\n        finishLocalSetup();\n\n\n\n        final Configuration[] childConfigs = config.getChildren();\n\n        for (final Configuration childConfig : childConfigs) {\n\n                setupChild(childConfig);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "199", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n\n\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n\n        if (identNode == null) {\n                final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n\n                annotationString = FullIdent.createFullIdent(dotNode).getText();\n\n        }\n        else {\n                annotationString = identNode.getText();\n\n        }\n\n\n        return annotationString;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "84", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n\n            final Pattern result;\n\n            if (line.isEmpty()) {\n                        result = BLANK_LINE;\n\n            }\n            else {\n                        result = Pattern.compile(validateRegex(line));\n\n            }\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "85", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n\n            return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "96", "src_id": "M601", "code": "@Override\n\npublic void beginTree(DetailAST root) {\n\n            variables.clear();\n\n            typeDeclarations.clear();\n\n            typeDeclAstToTypeDeclDesc.clear();\n\n            anonInnerAstToTypeDeclDesc.clear();\n\n            anonInnerClassHolders.clear();\n\n            packageName = null;\n\n            depth = 0;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "97", "src_id": "M600", "code": "@Override\n\npublic int[] getDefaultTokens() {\n\n            return new int[] {\n\n            TokenTypes.DOT,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.IDENT,\n            TokenTypes.SLIST,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.OBJBLOCK,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.STATIC_INIT,\n            TokenTypes.INSTANCE_INIT,\n            TokenTypes.COMPILATION_UNIT,\n            TokenTypes.LAMBDA,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n            };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "98", "src_id": "M615", "code": "private void iterateOverBlockContainingLocalAnonInnerClass(\nDetailAST ast, Deque<VariableDesc> variablesStack) {\n\n            DetailAST currNode = ast;\n\n\n            while (currNode != null) {\n\n                        customVisitToken(currNode, variablesStack);\n\n                        DetailAST toVisit = currNode.getFirstChild();\n\n\n                        while (currNode != ast && toVisit == null) {\n\n                                    customLeaveToken(currNode, variablesStack);\n\n                                    toVisit = currNode.getNextSibling();\n\n                                    currNode = currNode.getParent();\n\n                        }\n\n                        currNode = toVisit;\n\n            }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "99", "src_id": "M383", "code": "private static void extractInlineTagContent(DetailNode node,\nStringBuilder customTagContent) {\n\n            final DetailNode[] children = node.getChildren();\n\n            if (children.length == 0) {\n                        customTagContent.append(node.getText());\n\n            }\n            else {\n                        for (DetailNode child : children) {\n\n                                    if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                                                extractInlineTagContent(child, customTagContent);\n\n                                    }\n                        }\n\n            }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "100", "src_id": "M593", "code": "private void visitLambdaParameters(DetailAST ast) {\n\n            if (ast.getType() == TokenTypes.IDENT) {\n                        parameterNames.add(ast.getText());\n\n            }\n            else {\n                        visitParameters(ast);\n\n            }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "101", "src_id": "M175", "code": "@Override\n\npublic void auditFinished(AuditEvent event) {\n\n            errorWriter.flush();\n\n            if (closeErrorWriter) {\n                        errorWriter.close();\n\n            }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "102", "src_id": "M603", "code": "@Override\n\npublic void leaveToken(DetailAST ast) {\n\n            if (TokenUtil.isOfType(ast, SCOPES)) {\n                        logViolations(ast, variables);\n\n            }\n            else if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n                                    leaveCompilationUnit();\n\n                        }\n                        else if (isNonLocalTypeDeclaration(ast)) {\n                                                depth--;\n\n                                                typeDeclarations.pop();\n\n                                    }\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "144", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return CommonUtil.createPattern(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "145", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return SeverityLevel.getInstance(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "146", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n\n\n        registerIntegralTypes(cub);\n\n        registerCustomTypes(cub);\n\n\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "147", "src_id": "M4", "code": "@Override\n\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n\n        configuration = config;\n\n\n\n        final String[] attributes = config.getPropertyNames();\n\n\n        for (final String key : attributes) {\n\n                final String value = config.getProperty(key);\n\n\n\n                tryCopyProperty(key, value, true);\n\n        }\n\n\n\n        finishLocalSetup();\n\n\n\n        final Configuration[] childConfigs = config.getChildren();\n\n        for (final Configuration childConfig : childConfigs) {\n\n                setupChild(childConfig);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "148", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n                final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n\n\n                annotationString = FullIdent.createFullIdent(dotNode).getText();\n\n        }\n        else {\n                annotationString = identNode.getText();\n\n        }\n\n\n        return annotationString;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "67", "src_id": "M37", "code": "private ModuleType getModuleType() {\n\n            final String simpleModuleName = getModuleSimpleName();\n\n\n            final ModuleType result;\n\n            if (simpleModuleName.endsWith(\"FileFilter\")) {\n                        result = ModuleType.FILEFILTER;\n\n            }\n            else if (simpleModuleName.endsWith(\"Filter\")) {\n                                    result = ModuleType.FILTER;\n\n                        }\n                        else {\n                                    result = ModuleType.CHECK;\n\n                        }\n\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "68", "src_id": "M28", "code": "private void scrapeContent(DetailNode ast) {\n\n            if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n                        if (isParentText(ast)) {\n                                    parentSectionStartIdx = getParentIndexOf(ast);\n\n                                    moduleDetails.setParent(getParentText(ast));\n\n                        }\n                        else if (isViolationMessagesText(ast)) {\n                                                scrapingViolationMessageList = true;\n\n                                    }\n                                    else if (exampleSectionStartIdx == -1\n                                                && isExamplesText(ast)) {\n                                                            exampleSectionStartIdx = getParentIndexOf(ast);\n\n                                                }\n\n\n            }\n            else if (ast.getType() == JavadocTokenTypes.LI) {\n                                    if (isPropertyList(ast)) {\n                                                if (propertySectionStartIdx == -1) {\n                                                            propertySectionStartIdx = getParentIndexOf(ast);\n\n                                                }\n                                                moduleDetails.addToProperties(createProperties(ast));\n\n                                    }\n                                    else if (scrapingViolationMessageList) {\n                                                            moduleDetails.addToViolationMessages(getViolationMessages(ast));\n\n                                                }\n\n                        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "69", "src_id": "M27", "code": "@Override\n\npublic void beginJavadocTree(DetailNode rootAst) {\n\n            if (isTopLevelClassJavadoc()) {\n                        moduleDetails = new ModuleDetails();\n\n                        toScan = false;\n\n                        scrapingViolationMessageList = false;\n\n                        propertySectionStartIdx = -1;\n\n                        exampleSectionStartIdx = -1;\n\n                        parentSectionStartIdx = -1;\n\n\n\n                        String moduleName = getModuleSimpleName();\n\n                        final String checkModuleExtension = \"Check\";\n\n                        if (moduleName.endsWith(checkModuleExtension)) {\n                                    moduleName = moduleName\n                                    .substring(0, moduleName.length() - checkModuleExtension.length());\n\n                        }\n\n                        moduleDetails.setName(moduleName);\n\n                        moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n\n                        moduleDetails.setModuleType(getModuleType());\n\n            }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "70", "src_id": "M35", "code": "private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\nPattern pattern) {\n\n            return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "160", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return CommonUtil.createPattern(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "161", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n\n@Override\n\npublic Object convert(Class type, Object value) {\n\n        return SeverityLevel.getInstance(value.toString());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "162", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n\n        final ConvertUtilsBean cub=new ConvertUtilsBean();\n\n\n        registerIntegralTypes(cub);\n\n\n        registerCustomTypes(cub);\n\n\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "163", "src_id": "M4", "code": "@Override\n\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n\n        configuration=config;\n\n\n        final String[] attributes=config.getPropertyNames();\n\n\n        for (final String key : attributes) {\n\n                final String value=config.getProperty(key);\n\n\n                tryCopyProperty(key, value, true);\n\n        }\n\n\n\n        finishLocalSetup();\n\n\n        final Configuration[] childConfigs=config.getChildren();\n\n        for (final Configuration childConfig : childConfigs) {\n\n                setupChild(childConfig);\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "164", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n\n        final DetailAST identNode=annotationNode.findFirstToken(TokenTypes.IDENT);\n\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode==null) {\n                final DetailAST dotNode=annotationNode.findFirstToken(TokenTypes.DOT);\n\n                annotationString=FullIdent.createFullIdent(dotNode).getText();\n\n        }\n        else {\n                annotationString=identNode.getText();\n\n        }\n\n\n        return annotationString;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "43", "src_id": "M347", "code": "@Override\n\npublic void visitToken(DetailAST ast) {\n\n            switch (ast.getType()) {\n\n                        case TokenTypes.IDENT:\n                                    if (collect) {\n                                                processIdent(ast);\n\n                                    }\n                                    break;\n\n                        case TokenTypes.IMPORT:\n                                    processImport(ast);\n                                    break;\n\n                        case TokenTypes.STATIC_IMPORT:\n                                    processStaticImport(ast);\n                                    break;\n\n                        case TokenTypes.OBJBLOCK:\n                        case TokenTypes.SLIST:\n                                    currentFrame = currentFrame.push();\n                                    break;\n\n                        default:\n                                    collect = true;\n                                    if (processJavadoc) {\n                                                collectReferencesFromJavadoc(ast);\n\n                                    }\n                                    break;\n            }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "44", "src_id": "M394", "code": "@Override\n\npublic int[] getRequiredJavadocTokens() {\n\n            return new int[] {\n\n            JavadocTokenTypes.TEXT,\n            };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "45", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n\n            DetailAST result;\n\n            if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                        result = node.getPreviousSibling();\n\n            }\n            else if (isInPatternDefinition(node)) {\n                                    result = node.getFirstChild();\n\n                        }\n                        else {\n                                    result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n\n                        }\n\n            while (result.getLastChild() != null) {\n\n                        result = result.getLastChild();\n\n            }\n\n\n            return result;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "27", "src_id": "M697", "code": "@Nullable\n\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\nDetailAST bound, int neededTokenType) {\n\n\n        DetailAST match = null;\n\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n\n        while (iteratedBranch != null) {\n\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n\n                        break;\n\n                }\n\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n\n        }\n\n\n\n        return match;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "28", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n\n        for (DetailAST astNode = previousSibling; astNode != null;\n        astNode = astNode.getLastChild()) {\n\n                previousSibling = astNode;\n\n        }\n\n\n\n        return token.getLineNo() != previousSibling.getLineNo();\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "29", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n                }\n\n        }\n\n\n\n        return reassignedVariableIdents;\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "121", "src_id": "M601", "code": "@Override\n\npublic void beginTree(DetailAST root) {\n\n        variables.clear();\n\n        typeDeclarations.clear();\n\n        typeDeclAstToTypeDeclDesc.clear();\n\n        anonInnerAstToTypeDeclDesc.clear();\n\n        anonInnerClassHolders.clear();\n\n        packageName=null;\n\n        depth=0;\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "122", "src_id": "M600", "code": "@Override\n\npublic int[] getDefaultTokens() {\n\n        return new int[] {\n\n        TokenTypes.DOT,\n        TokenTypes.VARIABLE_DEF,\n        TokenTypes.IDENT,\n        TokenTypes.SLIST,\n        TokenTypes.LITERAL_FOR,\n        TokenTypes.OBJBLOCK,\n        TokenTypes.CLASS_DEF,\n        TokenTypes.INTERFACE_DEF,\n        TokenTypes.ANNOTATION_DEF,\n        TokenTypes.PACKAGE_DEF,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.CTOR_DEF,\n        TokenTypes.STATIC_INIT,\n        TokenTypes.INSTANCE_INIT,\n        TokenTypes.COMPILATION_UNIT,\n        TokenTypes.LAMBDA,\n        TokenTypes.ENUM_DEF,\n        TokenTypes.RECORD_DEF,\n        TokenTypes.COMPACT_CTOR_DEF,\n        };\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "123", "src_id": "M615", "code": "private void iterateOverBlockContainingLocalAnonInnerClass(\nDetailAST ast, Deque<VariableDesc> variablesStack) {\n\n        DetailAST currNode=ast;\n\n        while (currNode!=null) {\n\n                customVisitToken(currNode, variablesStack);\n\n                DetailAST toVisit=currNode.getFirstChild();\n\n                while (currNode!=ast&&toVisit==null) {\n\n                        customLeaveToken(currNode, variablesStack);\n\n                        toVisit=currNode.getNextSibling();\n\n                        currNode=currNode.getParent();\n\n                }\n\n                currNode=toVisit;\n\n        }\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "124", "src_id": "M383", "code": "private static void extractInlineTagContent(DetailNode node,\nStringBuilder customTagContent) {\n\n        final DetailNode[] children=node.getChildren();\n\n        if (children.length==0) {\n                customTagContent.append(node.getText());\n\n        }\n        else {\n                for (DetailNode child : children) {\n\n                        if (child.getType()!=JavadocTokenTypes.LEADING_ASTERISK) {\n                                extractInlineTagContent(child, customTagContent);\n\n                        }\n                }\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "125", "src_id": "M593", "code": "private void visitLambdaParameters(DetailAST ast) {\n\n        if (ast.getType()==TokenTypes.IDENT) {\n                parameterNames.add(ast.getText());\n\n        }\n        else {\n                visitParameters(ast);\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "126", "src_id": "M175", "code": "@Override\n\npublic void auditFinished(AuditEvent event) {\n\n        errorWriter.flush();\n\n        if (closeErrorWriter) {\n                errorWriter.close();\n\n        }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "127", "src_id": "M603", "code": "@Override\n\npublic void leaveToken(DetailAST ast) {\n\n        if (TokenUtil.isOfType(ast, SCOPES)) {\n                logViolations(ast, variables);\n\n        }\n        else if (ast.getType()==TokenTypes.COMPILATION_UNIT) {\n                        leaveCompilationUnit();\n\n                }\n                else if (isNonLocalTypeDeclaration(ast)) {\n                                depth--;\n\n                                typeDeclarations.pop();\n\n                        }\n\n\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": true}

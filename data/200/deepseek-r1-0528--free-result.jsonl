{"project_name": "jedis", "pair_id": "1", "src_id": "M127", "code": "\nprivate void build() {\n  // check build state to prevent recursion\n  if (building) {\n    return;\n  }\n\n  building = true;\n  try {\n    if (data != null) {\n      if (data instanceof JedisDataException) {\n        exception = (JedisDataException) data;\n      } else {\n        response = builder.build(data);\n      }\n    }\n\n    data = null;\n  } finally {\n    building = false;\n    built = true;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "2", "src_id": "M1184", "code": "\n@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n  ensureFill();\n  \n  int length = Math.min(limit - count, len);\n  System.arraycopy(buf, count, b, off, length);\n  count += length;\n  return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "3", "src_id": "M1128", "code": "\nprivate HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n  String host = getMasterAddrByNameResult.get(0);\n  int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n  return new HostAndPort(host, port);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "4", "src_id": "M1154", "code": "\npublic String getElement() {\n  if (element != null) {\n    return SafeEncoder.encode(element);\n  }\n  return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "5", "src_id": "M937", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (!(o instanceof GeoCoordinate)) return false;\n  \n  GeoCoordinate that = (GeoCoordinate) o;\n  return Double.compare(that.longitude, longitude) == 0 \n      && Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "6", "src_id": "M1073", "code": "\n@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n  flush();\n  return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "7", "src_id": "M127", "code": "\nprivate void build() {\n  // check build state to prevent recursion\n  if (building) return;\n\n  building = true;\n  try {\n    if (data != null) {\n      if (data instanceof JedisDataException) {\n        exception = (JedisDataException) data;\n      } else {\n        response = builder.build(data);\n      }\n    }\n\n    data = null;\n  } finally {\n    building = false;\n    built = true;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "8", "src_id": "M1184", "code": "\n@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n  ensureFill();\n\n  final int length = Math.min(limit - count, len);\n  System.arraycopy(buf, count, b, off, length);\n  count += length;\n  return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "9", "src_id": "M1128", "code": "\nprivate HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n  String host = getMasterAddrByNameResult.get(0);\n  int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n  return new HostAndPort(host, port);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "10", "src_id": "M1154", "code": "\npublic String getElement() {\n  if (element != null) return SafeEncoder.encode(element);\n  else return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "11", "src_id": "M937", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (o == null) return false;\n  if (o == this) return true;\n  if (!(o instanceof GeoCoordinate)) return false;\n\n  GeoCoordinate that = (GeoCoordinate) o;\n\n  if (Double.compare(that.longitude, longitude) != 0) return false;\n  return Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "12", "src_id": "M1073", "code": "\n@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n  flush();\n  return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "13", "src_id": "M1291", "code": "\nprivate static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n  if (!inclusive) {\n    sb.append('(');\n  }\n  if (n == Double.NEGATIVE_INFINITY) {\n    sb.append(\"-inf\");\n  } else if (n == Double.POSITIVE_INFINITY) {\n    sb.append(\"inf\");\n  } else {\n    sb.append(n);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "14", "src_id": "M1292", "code": "\n@Override\npublic String toString() {\n  StringBuilder sb = new StringBuilder();\n  sb.append('[');\n  appendFrom(sb, inclusiveMin);\n  sb.append(' ');\n  appendTo(sb, inclusiveMax);\n  sb.append(']');\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "15", "src_id": "M1290", "code": "\n@Override\npublic String toString(Parenthesize parenMode) {\n  StringBuilder sb = new StringBuilder();\n  StringJoiner sj = new StringJoiner(getJoinString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append('(');\n  }\n  for (Node n : children) {\n    sj.add(n.toString(parenMode));\n  }\n  sb.append(sj);\n  if (shouldParenthesize(parenMode)) {\n    sb.append(')');\n  }\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "26", "src_id": "M1291", "code": "\nprivate static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n  if (!inclusive) {\n    sb.append(\"(\");\n  }\n  if (n == Double.NEGATIVE_INFINITY) {\n    sb.append(\"-inf\");\n  } else if (n == Double.POSITIVE_INFINITY) {\n    sb.append(\"inf\");\n  } else {\n    sb.append(n);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "27", "src_id": "M1292", "code": "\n@Override\npublic String toString() {\n  StringBuilder sb = new StringBuilder();\n  sb.append('[');\n  appendFrom(sb, inclusiveMin);\n  sb.append(' ');\n  appendTo(sb, inclusiveMax);\n  sb.append(']');\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "28", "src_id": "M1290", "code": "\n@Override\npublic String toString(Parenthesize parenMode) {\n  StringBuilder sb = new StringBuilder();\n  StringJoiner sj = new StringJoiner(getJoinString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append('(');\n  }\n  for (Node n : children) {\n    sj.add(n.toString(parenMode));\n  }\n  sb.append(sj.toString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append(')');\n  }\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "29", "src_id": "M1291", "code": "\nprivate static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n  if (!inclusive) {\n    sb.append(\"(\");\n  }\n  if (n == Double.NEGATIVE_INFINITY) {\n    sb.append(\"-inf\");\n  } else if (n == Double.POSITIVE_INFINITY) {\n    sb.append(\"inf\");\n  } else {\n    sb.append(n);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "30", "src_id": "M1292", "code": "\n@Override\npublic String toString() {\n  final StringBuilder sb = new StringBuilder();\n  sb.append('[');\n  appendFrom(sb, inclusiveMin);\n  sb.append(' ');\n  appendTo(sb, inclusiveMax);\n  sb.append(']');\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "31", "src_id": "M1290", "code": "\n@Override\npublic String toString(Parenthesize parenMode) {\n  final StringBuilder sb = new StringBuilder();\n  final StringJoiner sj = new StringJoiner(getJoinString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append('(');\n  }\n  for (Node n : children) {\n    sj.add(n.toString(parenMode));\n  }\n  sb.append(sj.toString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append(')');\n  }\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "32", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append('(');\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "33", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "34", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "35", "src_id": "M107", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n  if (data == null) return null;\n  List list = (List) data;\n  if (list.isEmpty()) return Collections.emptyList();\n\n  if (list.get(0) instanceof KeyValue) {\n    return ((List<KeyValue>) list).stream()\n            .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n                STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n            .collect(Collectors.toList());\n  } else {\n    List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n    for (Object anObj : list) {\n      List<Object> streamObj = (List<Object>) anObj;\n      byte[] streamKey = BINARY.build(streamObj.get(0));\n      List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n      result.add(KeyValue.of(streamKey, streamEntries));\n    }\n    return result;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "36", "src_id": "M1012", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n        byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n        Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n            .add(GROUP).add(groupName).add(consumer)\n            .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "37", "src_id": "M1172", "code": "\n@Override\npublic boolean equals(Object o) {\n    if (o == null) return false;\n    if (o == this) return true;\n    if (!(o instanceof ByteArrayWrapper)) return false;\n\n    return Arrays.equals(data, ((ByteArrayWrapper) o).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "38", "src_id": "M154", "code": "\n@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n    Map<byte[], StreamEntryID> streams) {\n  return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "39", "src_id": "M1010", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n        XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "40", "src_id": "M1009", "code": "\npublic final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n        XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n  CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n  Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "41", "src_id": "M152", "code": "\n@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n  XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n  return executeCommand(\n      commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "42", "src_id": "M1177", "code": "\npublic static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource != null) {\n        try {\n            resource.close();\n        } catch (Exception e) {\n            // ignored\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "43", "src_id": "M620", "code": "\n@Override\npublic Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "44", "src_id": "M50", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<byte[], byte[]> build(Object data) {\n    List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        Map<byte[], byte[]> map = new JedisByteHashMap<>();\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        Map<byte[], byte[]> map = new JedisByteHashMap<>();\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "45", "src_id": "M933", "code": "\n@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n    if (credentialsProvider != null) {\n        builder.credentialsProvider(credentialsProvider);\n    } else {\n        builder.user(copy.getUser());\n        builder.password(copy.getPassword());\n    }\n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n        builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "46", "src_id": "M1146", "code": "\nprivate <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n        Connection connection = null;\n        try {\n            if (redirect != null) {\n                connection = provider.getConnection(redirect.getTargetNode());\n                if (redirect instanceof JedisAskDataException) {\n                    // TODO: Pipeline asking with the original command to make it faster....\n                    connection.executeCommand(Protocol.Command.ASKING);\n                }\n            } else {\n                connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                    : provider.getConnection(commandObject.getArguments());\n            }\n\n            return execute(connection, commandObject);\n\n        } catch (JedisClusterOperationException jnrcne) {\n            throw jnrcne;\n        } catch (JedisConnectionException jce) {\n            lastException = jce;\n            ++consecutiveConnectionFailures;\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n            boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n            if (reset) {\n                consecutiveConnectionFailures = 0;\n                redirect = null;\n            }\n        } catch (JedisRedirectionException jre) {\n            // avoid updating lastException if it is a connection exception\n            if (lastException == null || lastException instanceof JedisRedirectionException) {\n                lastException = jre;\n            }\n            log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n            consecutiveConnectionFailures = 0;\n            redirect = jre;\n            // if MOVED redirection occurred,\n            if (jre instanceof JedisMovedDataException) {\n                // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                provider.renewSlotCache(connection);\n            }\n        } finally {\n            IOUtils.closeQuietly(connection);\n        }\n        if (Instant.now().isAfter(deadline)) {\n            throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n        }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "47", "src_id": "M884", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n\n    if (filters == null) {\n        throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n    }\n\n    if (fromTimestamp == null) {\n        args.add(MINUS);\n    } else {\n        args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n        args.add(PLUS);\n    } else {\n        args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n        args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n        args.add(FILTER_BY_TS);\n        for (long ts : filterByTimestamps) {\n            args.add(toByteArray(ts));\n        }\n    }\n\n    if (filterByValues != null) {\n        args.add(FILTER_BY_VALUE);\n        for (double value : filterByValues) {\n            args.add(toByteArray(value));\n        }\n    }\n\n    if (withLabels) {\n        args.add(WITHLABELS);\n    } else if (selectedLabels != null) {\n        args.add(SELECTED_LABELS);\n        for (String label : selectedLabels) {\n            args.add(label);\n        }\n    }\n\n    if (count != null) {\n        args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n\n        if (align != null) {\n            args.add(ALIGN).add(align);\n        }\n\n        args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n        if (bucketTimestamp != null) {\n            args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n        }\n\n        if (empty) {\n            args.add(EMPTY);\n        }\n    }\n\n    args.add(FILTER);\n    for (String filter : filters) {\n        args.add(filter);\n    }\n\n    if (groupByLabel != null && groupByReduce != null) {\n        args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "48", "src_id": "M502", "code": "\n@Deprecated\n@Override\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "49", "src_id": "M416", "code": "\n@Override\npublic List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "50", "src_id": "M390", "code": "\n@Override\npublic Long objectFreq(final byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "51", "src_id": "M231", "code": "\npublic GeoRadiusStoreParam storeDist(String key) {\n    if (key != null) {\n        this.storeDist = true;\n        this.key = key;\n    }\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "52", "src_id": "M284", "code": "\n@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "53", "src_id": "M792", "code": "\n@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "54", "src_id": "M727", "code": "\n@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n  return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "55", "src_id": "M728", "code": "\n@Override\npublic List<String> commandGetKeys(String... command) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "56", "src_id": "M245", "code": "\npublic GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n  this.byBox = true;\n  this.width = width;\n  this.height = height;\n  this.unit = unit;\n  return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "57", "src_id": "M732", "code": "\n@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n  checkIsInMultiOrPipeline();\n  CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n  connection.sendCommand(args);\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "58", "src_id": "M712", "code": "\n@Override\npublic LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "59", "src_id": "M551", "code": "\n@Override\npublic long pexpire(String key, long milliseconds, ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "60", "src_id": "M844", "code": "\n@Override\npublic List<Object> functionListBinary() {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "61", "src_id": "M298", "code": "\n@Override\npublic long sintercard(int limit, byte[]... keys) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "69", "src_id": "M1291", "code": "\nprivate static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n  if (!inclusive) {\n    sb.append(\"(\");\n  }\n  if (n == Double.NEGATIVE_INFINITY) {\n    sb.append(\"-inf\");\n  } else if (n == Double.POSITIVE_INFINITY) {\n    sb.append(\"inf\");\n  } else {\n    sb.append(n);\n  }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "70", "src_id": "M1292", "code": "\n@Override\npublic String toString() {\n  StringBuilder sb = new StringBuilder();\n  sb.append('[');\n  appendFrom(sb, inclusiveMin);\n  sb.append(' ');\n  appendTo(sb, inclusiveMax);\n  sb.append(']');\n  return sb.toString();\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "71", "src_id": "M1290", "code": "\n@Override\npublic String toString(Parenthesize parenMode) {\n  StringBuilder sb = new StringBuilder();\n  StringJoiner sj = new StringJoiner(getJoinString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append('(');\n  }\n  for (Node n : children) {\n    sj.add(n.toString(parenMode));\n  }\n  sb.append(sj.toString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append(')');\n  }\n  return sb.toString();\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "72", "src_id": "M890", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  TSArithByParams<?> that = (TSArithByParams<?>) o;\n  return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n      Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n      Objects.equals(timestamp, that.timestamp) &&\n      Objects.equals(retentionPeriod, that.retentionPeriod) &&\n      encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n      duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "73", "src_id": "M903", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  TSCreateParams that = (TSCreateParams) o;\n  return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n      Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n      Objects.equals(retentionPeriod, that.retentionPeriod) &&\n      encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n      duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "74", "src_id": "M907", "code": "\n@Override\npublic int hashCode() {\n  int result = Boolean.hashCode(latest);\n  result = 31 * result + Boolean.hashCode(withLabels);\n  result = 31 * result + Arrays.hashCode(selectedLabels);\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "75", "src_id": "M127", "code": "\nprivate void build() {\n  // check build state to prevent recursion\n  if (building) {\n    return;\n  }\n\n  building = true;\n  try {\n    if (data != null) {\n      if (data instanceof JedisDataException) {\n        exception = (JedisDataException) data;\n      } else {\n        response = builder.build(data);\n      }\n    }\n\n    data = null;\n  } finally {\n    building = false;\n    built = true;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "76", "src_id": "M1184", "code": "\n@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n  ensureFill();\n\n  final int length = Math.min(limit - count, len);\n  System.arraycopy(buf, count, b, off, length);\n  count += length;\n  return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "77", "src_id": "M1128", "code": "\nprivate HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n  String host = getMasterAddrByNameResult.get(0);\n  int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n  return new HostAndPort(host, port);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "78", "src_id": "M1154", "code": "\npublic String getElement() {\n  if (element != null) {\n    return SafeEncoder.encode(element);\n  } else {\n    return null;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "79", "src_id": "M937", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  GeoCoordinate that = (GeoCoordinate) o;\n\n  return Double.compare(that.longitude, longitude) == 0 \n      && Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "80", "src_id": "M1073", "code": "\n@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n  flush();\n  return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "81", "src_id": "M1291", "code": "\nprivate static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n  if (!inclusive) {\n    sb.append(\"(\");\n  }\n  if (n == Double.NEGATIVE_INFINITY) {\n    sb.append(\"-inf\");\n  } else if (n == Double.POSITIVE_INFINITY) {\n    sb.append(\"inf\");\n  } else {\n    sb.append(n);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "82", "src_id": "M1292", "code": "\n@Override\npublic String toString() {\n  StringBuilder sb = new StringBuilder();\n  sb.append('[');\n  appendFrom(sb, inclusiveMin);\n  sb.append(' ');\n  appendTo(sb, inclusiveMax);\n  sb.append(']');\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "83", "src_id": "M1290", "code": "\n@Override\npublic String toString(Parenthesize parenMode) {\n  StringBuilder sb = new StringBuilder();\n  StringJoiner sj = new StringJoiner(getJoinString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append('(');\n  }\n  for (Node n : children) {\n    sj.add(n.toString(parenMode));\n  }\n  sb.append(sj.toString());\n  if (shouldParenthesize(parenMode)) {\n    sb.append(')');\n  }\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "94", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(\n      byte[] key, \n      long unixTime, \n      ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "95", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(\n      String key, \n      String member, \n      double width, \n      double height, \n      GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "96", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "97", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "98", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(\n      double width, \n      double height, \n      GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "99", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "100", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(\n      final String keyA, \n      final String keyB, \n      final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "101", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(\n      final String key, \n      final long milliseconds, \n      final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "102", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "103", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, \n      byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "107", "src_id": "M107", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    \n    List<?> rawData = (List<?>) data;\n    if (rawData.isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    if (rawData.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) rawData).stream()\n                .map(kv -> new KeyValue<>(\n                        BINARY.build(kv.getKey()),\n                        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())\n                ))\n                .collect(Collectors.toList());\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(rawData.size());\n        for (Object rawEntry : rawData) {\n            List<?> entryList = (List<?>) rawEntry;\n            byte[] streamKey = BINARY.build(entryList.get(0));\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(entryList.get(1));\n            result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "108", "src_id": "M1012", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n        byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n        Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n            .add(GROUP).add(groupName).add(consumer)\n            .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entries = streams.entrySet();\n    entries.forEach(entry -> args.key(entry.getKey()));\n    entries.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "109", "src_id": "M1172", "code": "\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ByteArrayWrapper that = (ByteArrayWrapper) o;\n    return Arrays.equals(data, that.data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "110", "src_id": "M154", "code": "\n@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\n        XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "111", "src_id": "M1010", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n        XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entries = streams.entrySet();\n    entries.forEach(entry -> args.key(entry.getKey()));\n    entries.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "112", "src_id": "M1009", "code": "\npublic final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n        XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entries = streams.entrySet();\n    entries.forEach(entry -> args.key(entry.getKey()));\n    entries.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "113", "src_id": "M152", "code": "\n@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n        XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n            commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "114", "src_id": "M107", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n  if (data == null) {\n    return null;\n  }\n  List list = (List) data;\n  if (list.isEmpty()) {\n    return Collections.emptyList();\n  }\n\n  if (list.get(0) instanceof KeyValue) {\n    return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n            STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n  } else {\n    List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n    for (Object anObj : list) {\n      List<Object> streamObj = (List<Object>) anObj;\n      byte[] streamKey = BINARY.build(streamObj.get(0));\n      List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n      result.add(KeyValue.of(streamKey, streamEntries));\n    }\n    return result;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "115", "src_id": "M1012", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n    byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n    Map<byte[], StreamEntryID> streams) {\n  CommandArguments args = commandArguments(XREADGROUP)\n      .add(GROUP).add(groupName).add(consumer)\n      .addParams(xReadGroupParams).add(STREAMS);\n  Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "116", "src_id": "M1172", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (o == null) {\n    return false;\n  }\n  if (o == this) {\n    return true;\n  }\n  if (!(o instanceof ByteArrayWrapper)) {\n    return false;\n  }\n\n  ByteArrayWrapper that = (ByteArrayWrapper) o;\n  return Arrays.equals(data, that.data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "117", "src_id": "M154", "code": "\n@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n    Map<byte[], StreamEntryID> streams) {\n  return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "118", "src_id": "M1010", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n  CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n  Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "119", "src_id": "M1009", "code": "\npublic final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n  CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n  Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "120", "src_id": "M152", "code": "\n@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n    XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n  return executeCommand(\n      commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "128", "src_id": "M107", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n  if (data == null) {\n    return null;\n  }\n  final List list = (List) data;\n  if (list.isEmpty()) {\n    return Collections.emptyList();\n  }\n\n  if (list.get(0) instanceof KeyValue) {\n    return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(\n            BINARY.build(kv.getKey()),\n            STREAM_ENTRY_BINARY_LIST.build(kv.getValue())\n        ))\n        .collect(Collectors.toList());\n  } else {\n    final List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n    for (final Object anObj : list) {\n      final List<Object> streamObj = (List<Object>) anObj;\n      final byte[] streamKey = BINARY.build(streamObj.get(0));\n      final List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n      result.add(KeyValue.of(streamKey, streamEntries));\n    }\n    return result;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "129", "src_id": "M1012", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n    byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n    Map<byte[], StreamEntryID> streams) {\n  final CommandArguments args = commandArguments(XREADGROUP)\n      .add(GROUP).add(groupName).add(consumer)\n      .addParams(xReadGroupParams).add(STREAMS);\n  final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "130", "src_id": "M1172", "code": "\n@Override\npublic boolean equals(Object other) {\n  if (other == null) {\n    return false;\n  }\n  if (other == this) {\n    return true;\n  }\n  if (!(other instanceof ByteArrayWrapper)) {\n    return false;\n  }\n  return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "131", "src_id": "M154", "code": "\n@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n    Map<byte[], StreamEntryID> streams) {\n  return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "132", "src_id": "M1010", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n  final CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n  final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "133", "src_id": "M1009", "code": "\npublic final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n  final CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n  final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "134", "src_id": "M152", "code": "\n@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n    XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n  return executeCommand(\n      commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "135", "src_id": "M233", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  XAutoClaimParams that = (XAutoClaimParams) o;\n  return Objects.equals(count, that.count);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "136", "src_id": "M1104", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  Raw that = (Raw) o;\n  return Arrays.equals(raw, that.raw);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "137", "src_id": "M260", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  ZAddParams that = (ZAddParams) o;\n  return change == that.change \n      && existence == that.existence \n      && comparison == that.comparison;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "138", "src_id": "M234", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  ClientKillParams that = (ClientKillParams) o;\n  return Objects.equals(params, that.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "139", "src_id": "M256", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  ModuleLoadExParams that = (ModuleLoadExParams) o;\n  return Objects.equals(configs, that.configs) \n      && Objects.equals(args, that.args);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "140", "src_id": "M238", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  MigrateParams that = (MigrateParams) o;\n  return copy == that.copy \n      && replace == that.replace \n      && Objects.equals(username, that.username) \n      && Objects.equals(password, that.password);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "141", "src_id": "M229", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  ZParams zParams = (ZParams) o;\n  return Objects.equals(params, zParams.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "152", "src_id": "M890", "code": "\n@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore \n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "153", "src_id": "M903", "code": "\n@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore \n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "154", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "161", "src_id": "M284", "code": "\n@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "162", "src_id": "M792", "code": "\n@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "163", "src_id": "M727", "code": "\n@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n  return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "164", "src_id": "M728", "code": "\n@Override\npublic List<String> commandGetKeys(String... command) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "165", "src_id": "M245", "code": "\npublic GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n  this.byBox = true;\n  this.width = width;\n  this.height = height;\n  this.unit = unit;\n  return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "166", "src_id": "M732", "code": "\n@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n  checkIsInMultiOrPipeline();\n  CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n  connection.sendCommand(args);\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "167", "src_id": "M712", "code": "\n@Override\npublic LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "168", "src_id": "M551", "code": "\n@Override\npublic long pexpire(String key, long milliseconds, ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "169", "src_id": "M844", "code": "\n@Override\npublic List<Object> functionListBinary() {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "170", "src_id": "M298", "code": "\n@Override\npublic long sintercard(int limit, byte[]... keys) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "171", "src_id": "M580", "code": "\n@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "172", "src_id": "M237", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  BaseSetExParams setParams = (BaseSetExParams) o;\n  return Objects.equals(expiration, setParams.expiration) \n      && Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "173", "src_id": "M227", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (o == null || getClass() != o.getClass()) return false;\n  HSetExParams setParams = (HSetExParams) o;\n  return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "174", "src_id": "M868", "code": "\nprivate void safeReAuthenticate(Token token) {\n  try {\n    byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n    byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n    Token newToken = pendingTokenRef.getAndSet(token);\n    if (newToken == null) {\n      commandSync.lock();\n      try {\n        sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n        resultHandler.add(this.authResultHandler);\n      } finally {\n        pendingTokenRef.set(null);\n        commandSync.unlock();\n      }\n    }\n  } catch (Exception e) {\n    logger.error(\"Error while re-authenticating connection\", e);\n    client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "175", "src_id": "M957", "code": "\npublic void setListener(AuthXEventListener listener) {\n  if (listener != null) {\n    this.listener = listener;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "176", "src_id": "M960", "code": "\nprivate void processPingReply(Object reply) {\n  byte[] resp = (byte[]) reply;\n  if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n    onPong(null);\n  } else {\n    onPong(encode(resp));\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "177", "src_id": "M581", "code": "\n@Override\npublic List<String> hgetdel(String key, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "185", "src_id": "M890", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (o == this) {\n    return true;\n  }\n\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  TSArithByParams<?> that = (TSArithByParams<?>) o;\n  return ignore == that.ignore \n      && ignoreMaxTimediff == that.ignoreMaxTimediff \n      && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n      && Objects.equals(timestamp, that.timestamp) \n      && Objects.equals(retentionPeriod, that.retentionPeriod) \n      && encoding == that.encoding \n      && Objects.equals(chunkSize, that.chunkSize) \n      && duplicatePolicy == that.duplicatePolicy \n      && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "186", "src_id": "M903", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (o == this) {\n    return true;\n  }\n\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  TSCreateParams that = (TCreateParams) o;\n  return ignore == that.ignore \n      && ignoreMaxTimediff == that.ignoreMaxTimediff \n      && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n      && Objects.equals(retentionPeriod, that.retentionPeriod) \n      && encoding == that.encoding \n      && Objects.equals(chunkSize, that.chunkSize) \n      && duplicatePolicy == that.duplicatePolicy \n      && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "187", "src_id": "M907", "code": "\n@Override\npublic int hashCode() {\n  int result = Boolean.hashCode(latest);\n  result = 31 * result + Boolean.hashCode(withLabels);\n  result = 31 * result + Arrays.hashCode(selectedLabels);\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "188", "src_id": "M1177", "code": "\npublic static void closeQuietly(AutoCloseable resource) {\n  if (resource != null) {\n    try {\n      resource.close();\n    } catch (Exception e) {\n      // ignored\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "189", "src_id": "M620", "code": "\n@Override\npublic Set<String> sinter(String... keys) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.sinter(keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "190", "src_id": "M50", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<byte[], byte[]> build(Object data) {\n  List<Object> list = (List<Object>) data;\n  if (list.isEmpty()) return Collections.emptyMap();\n\n  if (list.get(0) instanceof KeyValue) {\n    Map<byte[], byte[]> map = new JedisByteHashMap();\n    ((List<KeyValue>) list).forEach(kv -> \n        map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue())));\n    return map;\n  } else {\n    Map<byte[], byte[]> map = new JedisByteHashMap();\n    Iterator iterator = list.iterator();\n    while (iterator.hasNext()) {\n      map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n    }\n    return map;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "191", "src_id": "M933", "code": "\n@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n  Builder builder = builder();\n  builder.protocol(copy.getRedisProtocol());\n  builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n  builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n  builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n  Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n  if (credentialsProvider != null) {\n    builder.credentialsProvider(credentialsProvider);\n  } else {\n    builder.user(copy.getUser());\n    builder.password(copy.getPassword());\n  }\n\n  builder.database(copy.getDatabase());\n  builder.clientName(copy.getClientName());\n\n  builder.ssl(copy.isSsl());\n  builder.sslSocketFactory(copy.getSslSocketFactory());\n  builder.sslParameters(copy.getSslParameters());\n  builder.hostnameVerifier(copy.getHostnameVerifier());\n  builder.sslOptions(copy.getSslOptions());\n  builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n  builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n  if (copy.isReadOnlyForRedisClusterReplicas()) {\n    builder.readOnlyForRedisClusterReplicas();\n  }\n\n  builder.authXManager(copy.getAuthXManager());\n\n  return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "192", "src_id": "M1146", "code": "\nprivate <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n  Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n  JedisRedirectionException redirect = null;\n  int consecutiveConnectionFailures = 0;\n  Exception lastException = null;\n  for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n    Connection connection = null;\n    try {\n      if (redirect != null) {\n        connection = provider.getConnection(redirect.getTargetNode());\n        if (redirect instanceof JedisAskDataException) {\n          connection.executeCommand(Protocol.Command.ASKING);\n        }\n      } else {\n        connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n            : provider.getConnection(commandObject.getArguments());\n      }\n\n      return execute(connection, commandObject);\n\n    } catch (JedisClusterOperationException jnrcne) {\n      throw jnrcne;\n    } catch (JedisConnectionException jce) {\n      lastException = jce;\n      ++consecutiveConnectionFailures;\n      log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n      boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n      if (reset) {\n        consecutiveConnectionFailures = 0;\n        redirect = null;\n      }\n    } catch (JedisRedirectionException jre) {\n      if (lastException == null || lastException instanceof JedisRedirectionException) {\n        lastException = jre;\n      }\n      log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n      consecutiveConnectionFailures = 0;\n      redirect = jre;\n      if (jre instanceof JedisMovedDataException) {\n        provider.renewSlotCache(connection);\n      }\n    } finally {\n      IOUtils.closeQuietly(connection);\n    }\n    if (Instant.now().isAfter(deadline)) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n    }\n  }\n\n  JedisClusterOperationException maxAttemptsException\n      = new JedisClusterOperationException(\"No more cluster attempts left.\");\n  maxAttemptsException.addSuppressed(lastException);\n  throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "193", "src_id": "M884", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n  if (filters == null) {\n    throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n  }\n\n  if (fromTimestamp == null) {\n    args.add(MINUS);\n  } else {\n    args.add(toByteArray(fromTimestamp));\n  }\n\n  if (toTimestamp == null) {\n    args.add(PLUS);\n  } else {\n    args.add(toByteArray(toTimestamp));\n  }\n\n  if (latest) {\n    args.add(LATEST);\n  }\n\n  if (filterByTimestamps != null) {\n    args.add(FILTER_BY_TS);\n    for (long ts : filterByTimestamps) {\n      args.add(toByteArray(ts));\n    }\n  }\n\n  if (filterByValues != null) {\n    args.add(FILTER_BY_VALUE);\n    for (double value : filterByValues) {\n      args.add(toByteArray(value));\n    }\n  }\n\n  if (withLabels) {\n    args.add(WITHLABELS);\n  } else if (selectedLabels != null) {\n    args.add(SELECTED_LABELS);\n    for (String label : selectedLabels) {\n      args.add(label);\n    }\n  }\n\n  if (count != null) {\n    args.add(COUNT).add(toByteArray(count));\n  }\n\n  if (aggregationType != null) {\n    if (align != null) {\n      args.add(ALIGN).add(align);\n    }\n\n    args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n    if (bucketTimestamp != null) {\n      args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n    }\n\n    if (empty) {\n      args.add(EMPTY);\n    }\n  }\n\n  args.add(FILTER);\n  for (String filter : filters) {\n    args.add(filter);\n  }\n\n  if (groupByLabel != null && groupByReduce != null) {\n    args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "194", "src_id": "M502", "code": "\n@Deprecated\n@Override\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "195", "src_id": "M416", "code": "\n@Override\npublic List<byte[]> aclLogBinary() {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(ACL, LOG);\n  return connection.getBinaryMultiBulkReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "196", "src_id": "M390", "code": "\n@Override\npublic Long objectFreq(byte[] key) {\n  connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n  return connection.getIntegerReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "197", "src_id": "M231", "code": "\npublic GeoRadiusStoreParam storeDist(String key) {\n  if (key != null) {\n    this.storeDist = true;\n    this.key = key;\n  }\n  return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "198", "src_id": "M777", "code": "\n@Override\npublic List<Map<String, Object>> clusterLinks() {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n  List<Object> replies = connection.getObjectMultiBulkReply();\n  List<Map<String, Object>> result = new ArrayList<>();\n  for (Object reply : replies) {\n    result.add(BuilderFactory.ENCODED_OBJECT_MAP.build(reply));\n  }\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "199", "src_id": "M779", "code": "\n@Override\npublic String clusterDelSlotsRange(int... ranges) {\n  checkIsInMultiOrPipeline();\n  String subCommand = ClusterKeyword.DELSLOTSRANGE.getRaw();\n  String joinedRanges = joinParameters(ranges);\n  String fullCommand = joinParameters(subCommand, joinedRanges);\n  connection.sendCommand(CLUSTER, fullCommand);\n  return connection.getStatusCodeReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "200", "src_id": "M818", "code": "\n@Override\npublic Map<String, Object> memoryStats() {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(MEMORY, STATS);\n  Object response = connection.getOne();\n  return BuilderFactory.ENCODED_OBJECT_MAP.build(response);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "201", "src_id": "M580", "code": "\n@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "202", "src_id": "M237", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  BaseSetExParams setParams = (BaseSetExParams) o;\n  return Objects.equals(expiration, setParams.expiration) &&\n      Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "203", "src_id": "M227", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  HSetExParams setParams = (HSetExParams) o;\n  return Objects.equals(existance, setParams.existance) &&\n      super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "204", "src_id": "M868", "code": "\nprivate void safeReAuthenticate(Token token) {\n  try {\n    byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n    byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n    Token newToken = pendingTokenRef.getAndSet(token);\n    if (newToken == null) {\n      commandSync.lock();\n      try {\n        sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n        resultHandler.add(this.authResultHandler);\n      } finally {\n        pendingTokenRef.set(null);\n        commandSync.unlock();\n      }\n    }\n  } catch (Exception e) {\n    logger.error(\"Error while re-authenticating connection\", e);\n    client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "205", "src_id": "M957", "code": "\npublic void setListener(AuthXEventListener listener) {\n  if (listener != null) {\n    this.listener = listener;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "206", "src_id": "M960", "code": "\nprivate void processPingReply(Object reply) {\n  byte[] resp = (byte[]) reply;\n  if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n    onPong(null);\n  } else {\n    onPong(encode(resp));\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "207", "src_id": "M581", "code": "\n@Override\npublic List<String> hgetdel(String key, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "208", "src_id": "M890", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  final TSArithByParams<?> that = (TSArithByParams<?>) o;\n  return ignore == that.ignore \n    && ignoreMaxTimediff == that.ignoreMaxTimediff \n    && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 \n    && Objects.equals(timestamp, that.timestamp) \n    && Objects.equals(retentionPeriod, that.retentionPeriod) \n    && encoding == that.encoding \n    && Objects.equals(chunkSize, that.chunkSize) \n    && duplicatePolicy == that.duplicatePolicy \n    && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "209", "src_id": "M903", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  final TSCreateParams that = (TSCreateParams) o;\n  return ignore == that.ignore \n    && ignoreMaxTimediff == that.ignoreMaxTimediff \n    && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 \n    && Objects.equals(retentionPeriod, that.retentionPeriod) \n    && encoding == that.encoding \n    && Objects.equals(chunkSize, that.chunkSize) \n    && duplicatePolicy == that.duplicatePolicy \n    && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "210", "src_id": "M907", "code": "\n@Override\npublic int hashCode() {\n  int result = Boolean.hashCode(latest);\n  result = 31 * result + Boolean.hashCode(withLabels);\n  result = 31 * result + Arrays.hashCode(selectedLabels);\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "211", "src_id": "M580", "code": "\n@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "212", "src_id": "M237", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  BaseSetExParams setParams = (BaseSetExParams) o;\n  return Objects.equals(expiration, setParams.expiration) &&\n      Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "213", "src_id": "M227", "code": "\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance) &&\n        super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "214", "src_id": "M868", "code": "\nprivate void safeReAuthenticate(Token token) {\n  try {\n    byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n    byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n    Token newToken = pendingTokenRef.getAndSet(token);\n    if (newToken == null) {\n      commandSync.lock();\n      try {\n        sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n        resultHandler.add(this.authResultHandler);\n      } finally {\n        pendingTokenRef.set(null);\n        commandSync.unlock();\n      }\n    }\n  } catch (Exception e) {\n    logger.error(\"Error while re-authenticating connection\", e);\n    client.getAuthXManager()\n        .getListener()\n        .onConnectionAuthenticationError(e);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "215", "src_id": "M957", "code": "\npublic void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n        this.listener = listener;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "216", "src_id": "M960", "code": "\nprivate void processPingReply(Object reply) {\n  byte[] resp = (byte[]) reply;\n  if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n    onPong(null);\n  } else {\n    onPong(encode(resp));\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "217", "src_id": "M581", "code": "\n@Override\npublic List<String> hgetdel(String key, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "16", "src_id": "M284", "code": "\n@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "17", "src_id": "M792", "code": "\n@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "18", "src_id": "M727", "code": "\n@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n  return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "19", "src_id": "M728", "code": "\n@Override\npublic List<String> commandGetKeys(String... command) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "20", "src_id": "M245", "code": "\npublic GeoSearchParam byBox(double width, double height, GeoUnit unit){\n  this.byBox = true;\n  this.width = width;\n  this.height = height;\n  this.unit = unit;\n  return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "21", "src_id": "M732", "code": "\n@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n  checkIsInMultiOrPipeline();\n  CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n  connection.sendCommand(args);\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "22", "src_id": "M712", "code": "\n@Override\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "23", "src_id": "M551", "code": "\n@Override\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "24", "src_id": "M844", "code": "\n@Override\npublic List<Object> functionListBinary() {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "25", "src_id": "M298", "code": "\n@Override\npublic long sintercard(int limit, byte[]... keys) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "62", "src_id": "M107", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n  if (data == null) return null;\n  final List list = (List) data;\n  if (list.isEmpty()) return Collections.emptyList();\n\n  if (list.get(0) instanceof KeyValue) {\n    return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(\n            BINARY.build(kv.getKey()),\n            STREAM_ENTRY_BINARY_LIST.build(kv.getValue())\n        ))\n        .collect(Collectors.toList());\n  } else {\n    final List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n    for (Object anObj : list) {\n      final List<Object> streamObj = (List<Object>) anObj;\n      final byte[] streamKey = BINARY.build(streamObj.get(0));\n      final List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n      result.add(KeyValue.of(streamKey, streamEntries));\n    }\n    return result;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "63", "src_id": "M1012", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n    byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n    Map<byte[], StreamEntryID> streams) {\n\n  final CommandArguments args = commandArguments(XREADGROUP)\n      .add(GROUP)\n      .add(groupName)\n      .add(consumer)\n      .addParams(xReadGroupParams)\n      .add(STREAMS);\n\n  final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "64", "src_id": "M1172", "code": "\n@Override\npublic boolean equals(Object other) {\n  if (other == null) return false;\n  if (other == this) return true;\n  if (!(other instanceof ByteArrayWrapper)) return false;\n\n  return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "65", "src_id": "M154", "code": "\n@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n    Map<byte[], StreamEntryID> streams) {\n\n  return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "66", "src_id": "M1010", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n  final CommandArguments args = commandArguments(XREAD)\n      .addParams(xReadParams)\n      .add(STREAMS);\n\n  final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "67", "src_id": "M1009", "code": "\npublic final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n  final CommandArguments args = commandArguments(XREAD)\n      .addParams(xReadParams)\n      .add(STREAMS);\n\n  final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "68", "src_id": "M152", "code": "\n@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n    XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n  return executeCommand(\n      commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "84", "src_id": "M284", "code": "\n@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "85", "src_id": "M792", "code": "\n@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "86", "src_id": "M727", "code": "\n@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n  return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "87", "src_id": "M728", "code": "\n@Override\npublic List<String> commandGetKeys(String... command) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "88", "src_id": "M245", "code": "\npublic GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n  this.byBox = true;\n  this.width = width;\n  this.height = height;\n  this.unit = unit;\n  return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "89", "src_id": "M732", "code": "\n@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n  checkIsInMultiOrPipeline();\n  CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n  connection.sendCommand(args);\n  return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "90", "src_id": "M712", "code": "\n@Override\npublic LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "91", "src_id": "M551", "code": "\n@Override\npublic long pexpire(String key, long milliseconds, ExpiryOption expiryOption) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "92", "src_id": "M844", "code": "\n@Override\npublic List<Object> functionListBinary() {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "93", "src_id": "M298", "code": "\n@Override\npublic long sintercard(int limit, byte[]... keys) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "104", "src_id": "M890", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  TSArithByParams<?> that = (TSArithByParams<?>) o;\n  return ignore == that.ignore \n      && ignoreMaxTimediff == that.ignoreMaxTimediff\n      && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n      && Objects.equals(timestamp, that.timestamp)\n      && Objects.equals(retentionPeriod, that.retentionPeriod)\n      && encoding == that.encoding\n      && Objects.equals(chunkSize, that.chunkSize)\n      && duplicatePolicy == that.duplicatePolicy\n      && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "105", "src_id": "M903", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  TSCreateParams that = (TSCreateParams) o;\n  return ignore == that.ignore \n      && ignoreMaxTimediff == that.ignoreMaxTimediff\n      && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n      && Objects.equals(retentionPeriod, that.retentionPeriod)\n      && encoding == that.encoding\n      && Objects.equals(chunkSize, that.chunkSize)\n      && duplicatePolicy == that.duplicatePolicy\n      && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "106", "src_id": "M907", "code": "\n@Override\npublic int hashCode() {\n  int result = Boolean.hashCode(latest);\n  result = 31 * result + Boolean.hashCode(withLabels);\n  result = 31 * result + Arrays.hashCode(selectedLabels);\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "121", "src_id": "M580", "code": "\n@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "122", "src_id": "M237", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  BaseSetExParams setParams = (BaseSetExParams) o;\n  return Objects.equals(expiration, setParams.expiration) \n    && Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "123", "src_id": "M227", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  HSetExParams setParams = (HSetExParams) o;\n  return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "124", "src_id": "M868", "code": "\nprivate void safeReAuthenticate(Token token) {\n  try {\n    byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n    byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n    Token newToken = pendingTokenRef.getAndSet(token);\n    if (newToken == null) {\n      commandSync.lock();\n      try {\n        sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n        resultHandler.add(this.authResultHandler);\n      } finally {\n        pendingTokenRef.set(null);\n        commandSync.unlock();\n      }\n    }\n  } catch (Exception e) {\n    logger.error(\"Error while re-authenticating connection\", e);\n    client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "125", "src_id": "M957", "code": "\npublic void setListener(AuthXEventListener listener) {\n  if (listener != null) {\n    this.listener = listener;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "126", "src_id": "M960", "code": "\nprivate void processPingReply(Object reply) {\n  byte[] resp = (byte[]) reply;\n  if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n    onPong(null);\n  } else {\n    onPong(encode(resp));\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "127", "src_id": "M581", "code": "\n@Override\npublic List<String> hgetdel(String key, String... fields) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "142", "src_id": "M1177", "code": "\npublic static void closeQuietly(AutoCloseable resource) {\n  if (resource != null) {\n    try {\n      resource.close();\n    } catch (Exception e) {\n      // ignored\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "143", "src_id": "M620", "code": "\n@Override\npublic Set<String> sinter(final String... keys) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.sinter(keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "144", "src_id": "M50", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<byte[], byte[]> build(Object data) {\n  final List<Object> list = (List<Object>) data;\n  if (list.isEmpty()) {\n    return Collections.emptyMap();\n  }\n\n  if (list.get(0) instanceof KeyValue) {\n    final Map<byte[], byte[]> map = new JedisByteHashMap<>();\n    for (Object obj : list) {\n      KeyValue kv = (KeyValue) obj;\n      map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n    }\n    return map;\n  } else {\n    final Map<byte[], byte[]> map = new JedisByteHashMap<>();\n    final Iterator<Object> iterator = list.iterator();\n    while (iterator.hasNext()) {\n      map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n    }\n    return map;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "145", "src_id": "M933", "code": "\n@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n  Builder builder = builder();\n  builder.protocol(copy.getRedisProtocol());\n  builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n  builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n  builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n  Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n  if (credentialsProvider != null) {\n    builder.credentialsProvider(credentialsProvider);\n  } else {\n    builder.user(copy.getUser());\n    builder.password(copy.getPassword());\n  }\n\n  builder.database(copy.getDatabase());\n  builder.clientName(copy.getClientName());\n\n  builder.ssl(copy.isSsl());\n  builder.sslSocketFactory(copy.getSslSocketFactory());\n  builder.sslParameters(copy.getSslParameters());\n  builder.hostnameVerifier(copy.getHostnameVerifier());\n  builder.sslOptions(copy.getSslOptions());\n  builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n  builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n  if (copy.isReadOnlyForRedisClusterReplicas()) {\n    builder.readOnlyForRedisClusterReplicas();\n  }\n\n  builder.authXManager(copy.getAuthXManager());\n\n  return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "146", "src_id": "M1146", "code": "\nprivate <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n  Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n  JedisRedirectionException redirect = null;\n  int consecutiveConnectionFailures = 0;\n  Exception lastException = null;\n  for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n    Connection connection = null;\n    try {\n      if (redirect != null) {\n        connection = provider.getConnection(redirect.getTargetNode());\n        if (redirect instanceof JedisAskDataException) {\n          connection.executeCommand(Protocol.Command.ASKING);\n        }\n      } else {\n        connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n            : provider.getConnection(commandObject.getArguments());\n      }\n\n      return execute(connection, commandObject);\n\n    } catch (JedisClusterOperationException jnrcne) {\n      throw jnrcne;\n    } catch (JedisConnectionException jce) {\n      lastException = jce;\n      ++consecutiveConnectionFailures;\n      log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n      boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n      if (reset) {\n        consecutiveConnectionFailures = 0;\n        redirect = null;\n      }\n    } catch (JedisRedirectionException jre) {\n      if (lastException == null || lastException instanceof JedisRedirectionException) {\n        lastException = jre;\n      }\n      log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n      consecutiveConnectionFailures = 0;\n      redirect = jre;\n      if (jre instanceof JedisMovedDataException) {\n        provider.renewSlotCache(connection);\n      }\n    } finally {\n      IOUtils.closeQuietly(connection);\n    }\n    if (Instant.now().isAfter(deadline)) {\n      throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n    }\n  }\n\n  JedisClusterOperationException maxAttemptsException\n      = new JedisClusterOperationException(\"No more cluster attempts left.\");\n  maxAttemptsException.addSuppressed(lastException);\n  throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "147", "src_id": "M884", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n  if (filters == null) {\n    throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n  }\n\n  if (fromTimestamp == null) {\n    args.add(MINUS);\n  } else {\n    args.add(toByteArray(fromTimestamp));\n  }\n\n  if (toTimestamp == null) {\n    args.add(PLUS);\n  } else {\n    args.add(toByteArray(toTimestamp));\n  }\n\n  if (latest) {\n    args.add(LATEST);\n  }\n\n  if (filterByTimestamps != null) {\n    args.add(FILTER_BY_TS);\n    for (long ts : filterByTimestamps) {\n      args.add(toByteArray(ts));\n    }\n  }\n\n  if (filterByValues != null) {\n    args.add(FILTER_BY_VALUE);\n    for (double value : filterByValues) {\n      args.add(toByteArray(value));\n    }\n  }\n\n  if (withLabels) {\n    args.add(WITHLABELS);\n  } else if (selectedLabels != null) {\n    args.add(SELECTED_LABELS);\n    for (String label : selectedLabels) {\n      args.add(label);\n    }\n  }\n\n  if (count != null) {\n    args.add(COUNT).add(toByteArray(count));\n  }\n\n  if (aggregationType != null) {\n    if (align != null) {\n      args.add(ALIGN).add(align);\n    }\n\n    args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n    if (bucketTimestamp != null) {\n      args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n    }\n\n    if (empty) {\n      args.add(EMPTY);\n    }\n  }\n\n  args.add(FILTER);\n  for (String filter : filters) {\n    args.add(filter);\n  }\n\n  if (groupByLabel != null && groupByReduce != null) {\n    args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "148", "src_id": "M502", "code": "\n@Deprecated\n@Override\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n  checkIsInMultiOrPipeline();\n  return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "149", "src_id": "M416", "code": "\n@Override\npublic List<byte[]> aclLogBinary() {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(ACL, LOG);\n  return connection.getBinaryMultiBulkReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "150", "src_id": "M390", "code": "\n@Override\npublic Long objectFreq(final byte[] key) {\n  connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n  return connection.getIntegerReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "151", "src_id": "M231", "code": "\npublic GeoRadiusStoreParam storeDist(String key) {\n  if (key != null) {\n    this.storeDist = true;\n    this.key = key;\n  }\n  return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "155", "src_id": "M127", "code": "\nprivate void build() {\n  if (building) {\n    return;\n  }\n\n  building = true;\n  try {\n    if (data != null) {\n      if (data instanceof JedisDataException) {\n        exception = (JedisDataException) data;\n      } else {\n        response = builder.build(data);\n      }\n    }\n\n    data = null;\n  } finally {\n    building = false;\n    built = true;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "156", "src_id": "M1184", "code": "\n@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n  ensureFill();\n\n  final int length = Math.min(limit - count, len);\n  System.arraycopy(buf, count, b, off, length);\n  count += length;\n  return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "157", "src_id": "M1128", "code": "\nprivate HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n  return new HostAndPort(getMasterAddrByNameResult.get(0),\n                         Integer.parseInt(getMasterAddrByNameResult.get(1)));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "158", "src_id": "M1154", "code": "\npublic String getElement() {\n  if (element != null) {\n    return SafeEncoder.encode(element);\n  }\n  return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "159", "src_id": "M937", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (o == null) {\n    return false;\n  }\n  if (o == this) {\n    return true;\n  }\n  if (!(o instanceof GeoCoordinate)) {\n    return false;\n  }\n\n  GeoCoordinate that = (GeoCoordinate) o;\n\n  if (Double.compare(that.longitude, longitude) != 0) {\n    return false;\n  }\n  return Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "160", "src_id": "M1073", "code": "\n@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n  flush();\n  return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "178", "src_id": "M233", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  XAutoClaimParams that = (XAutoClaimParams) o;\n  return Objects.equals(count, that.count);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "179", "src_id": "M1104", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  return Arrays.equals(raw, ((Raw) o).raw);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "180", "src_id": "M260", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ZAddParams that = (ZAddParams) o;\n  return change == that.change && existence == that.existence && comparison == that.comparison;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "181", "src_id": "M234", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ClientKillParams that = (ClientKillParams) o;\n  return Objects.equals(params, that.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "182", "src_id": "M256", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ModuleLoadExParams that = (ModuleLoadExParams) o;\n  return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "183", "src_id": "M238", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  MigrateParams that = (MigrateParams) o;\n  return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "184", "src_id": "M229", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ZParams zParams = (ZParams) o;\n  return Objects.equals(params, zParams.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "218", "src_id": "M233", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  XAutoClaimParams that = (XAutoClaimParams) o;\n  return Objects.equals(count, that.count);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "219", "src_id": "M1104", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  return Arrays.equals(raw, ((Raw) o).raw);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "220", "src_id": "M260", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ZAddParams that = (ZAddParams) o;\n  return change == that.change \n      && existence == that.existence \n      && comparison == that.comparison;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "221", "src_id": "M234", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ClientKillParams that = (ClientKillParams) o;\n  return Objects.equals(params, that.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "222", "src_id": "M256", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ModuleLoadExParams that = (ModuleLoadExParams) o;\n  return Objects.equals(configs, that.configs) \n      && Objects.equals(args, that.args);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "223", "src_id": "M238", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  MigrateParams that = (MigrateParams) o;\n  return copy == that.copy \n      && replace == that.replace \n      && Objects.equals(username, that.username) \n      && Objects.equals(password, that.password);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "224", "src_id": "M229", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n  ZParams zParams = (ZParams) o;\n  return Objects.equals(params, zParams.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "225", "src_id": "M107", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n  if (data == null) return null;\n  List list = (List) data;\n  if (list.isEmpty()) return Collections.emptyList();\n\n  if (list.get(0) instanceof KeyValue) {\n    return ((List<KeyValue>) list).stream()\n      .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n          STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n      .collect(Collectors.toList());\n  } else {\n    List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n    for (Object anObj : list) {\n      List<Object> streamObj = (List<Object>) anObj;\n      byte[] streamKey = BINARY.build(streamObj.get(0));\n      List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n      result.add(KeyValue.of(streamKey, streamEntries));\n    }\n    return result;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "226", "src_id": "M1012", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n    byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n    Map<byte[], StreamEntryID> streams) {\n  CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n  Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "227", "src_id": "M1172", "code": "\n@Override\npublic boolean equals(Object other) {\n  if (other == null) {\n    return false;\n  }\n  if (other == this) {\n    return true;\n  }\n  if (!(other instanceof ByteArrayWrapper)) {\n    return false;\n  }\n  ByteArrayWrapper that = (ByteArrayWrapper) other;\n  return Arrays.equals(data, that.data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "228", "src_id": "M154", "code": "\n@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n    Map<byte[], StreamEntryID> streams) {\n  return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "229", "src_id": "M1010", "code": "\npublic final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n  CommandArguments args = commandArguments(XREAD)\n    .addParams(xReadParams)\n    .add(STREAMS);\n  Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "230", "src_id": "M1009", "code": "\npublic final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n    XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n  CommandArguments args = commandArguments(XREAD)\n    .addParams(xReadParams)\n    .add(STREAMS);\n  Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n  entrySet.forEach(entry -> args.key(entry.getKey()));\n  entrySet.forEach(entry -> args.add(entry.getValue()));\n  return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "231", "src_id": "M152", "code": "\n@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n    XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n  return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "232", "src_id": "M777", "code": "\n@Override\npublic List<Map<String, Object>> clusterLinks() {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n  return connection.getObjectMultiBulkReply().stream()\n          .map(BuilderFactory.ENCODED_OBJECT_MAP::build)\n          .collect(Collectors.toList());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "233", "src_id": "M779", "code": "\n@Override\npublic String clusterDelSlotsRange(int... ranges) {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(CLUSTER,\n          joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));\n  return connection.getStatusCodeReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "234", "src_id": "M818", "code": "\n@Override\npublic Map<String, Object> memoryStats() {\n  checkIsInMultiOrPipeline();\n  connection.sendCommand(MEMORY, STATS);\n  return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "235", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    XAutoClaimParams xAutoClaimParams = (XAutoClaimParams) o;\n    return Objects.equals(count, xAutoClaimParams.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "236", "src_id": "M1104", "code": "\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      Raw other = (Raw) o;\n      return Arrays.equals(raw, other.raw);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "237", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ZAddParams zAddParams = (ZAddParams) o;\n    return change == zAddParams.change \n        && existence == zAddParams.existence \n        && comparison == zAddParams.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "238", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ClientKillParams clientKillParams = (ClientKillParams) o;\n    return Objects.equals(params, clientKillParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "239", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ModuleLoadExParams moduleLoadExParams = (ModuleLoadExParams) o;\n    return Objects.equals(configs, moduleLoadExParams.configs) \n        && Objects.equals(args, moduleLoadExParams.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "240", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    MigrateParams migrateParams = (MigrateParams) o;\n    return copy == migrateParams.copy \n        && replace == migrateParams.replace \n        && Objects.equals(username, migrateParams.username) \n        && Objects.equals(password, migrateParams.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "241", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "242", "src_id": "M890", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  TSArithByParams<?> that = (TSArithByParams<?>) o;\n  return ignore == that.ignore\n      && ignoreMaxTimediff == that.ignoreMaxTimediff\n      && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n      && Objects.equals(timestamp, that.timestamp)\n      && Objects.equals(retentionPeriod, that.retentionPeriod)\n      && encoding == that.encoding\n      && Objects.equals(chunkSize, that.chunkSize)\n      && duplicatePolicy == that.duplicatePolicy\n      && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "243", "src_id": "M903", "code": "\n@Override\npublic boolean equals(Object o) {\n  if (this == o) {\n    return true;\n  }\n  if (o == null || getClass() != o.getClass()) {\n    return false;\n  }\n\n  TSCreateParams that = (TSCreateParams) o;\n  return ignore == that.ignore\n      && ignoreMaxTimediff == that.ignoreMaxTimediff\n      && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n      && Objects.equals(retentionPeriod, that.retentionPeriod)\n      && encoding == that.encoding\n      && Objects.equals(chunkSize, that.chunkSize)\n      && duplicatePolicy == that.duplicatePolicy\n      && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "244", "src_id": "M907", "code": "\n@Override\npublic int hashCode() {\n  int result = Boolean.hashCode(latest);\n  result = 31 * result + Boolean.hashCode(withLabels);\n  result = 31 * result + Arrays.hashCode(selectedLabels);\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "1", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n                || entry.getLastLine() == line\n                && entry.getLastColumn() >= column;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "2", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n                && modifiers.findFirstToken(TokenTypes.FINAL) == null\n                && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "3", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "4", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "5", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "6", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "7", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n                && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n        return searchAST;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "8", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n        return forwardReference;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "9", "src_id": "M855", "code": "\n@Override\npublic DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n    final DetailAstImpl bop = create(ctx.bop);\n    bop.addChild(visit(ctx.expr()));\n    bop.addChild(create(ctx.LITERAL_THIS()));\n    return bop;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "10", "src_id": "M770", "code": "\n@Override\npublic DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n    final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n    interfaceExtends.addChild(visit(ctx.typeList()));\n    return interfaceExtends;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "11", "src_id": "M854", "code": "\n@Override\npublic DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n    final DetailAstImpl lambda = create(ctx.LAMBDA());\n    lambda.addChild(visit(ctx.lambdaParameters()));\n\n    final JavaLanguageParser.BlockContext blockContext = ctx.block();\n    final DetailAstImpl rightHandLambdaChild;\n    if (blockContext != null) {\n        rightHandLambdaChild = visit(blockContext);\n    }\n    else {\n        rightHandLambdaChild = buildExpressionNode(ctx.expr());\n    }\n    lambda.addChild(rightHandLambdaChild);\n    return lambda;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "12", "src_id": "M779", "code": "\n@Override\npublic DetailAstImpl visitInterfaceMethodDeclaration(\n        JavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n    final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n    methodDef.addChild(createModifiers(ctx.mods));\n\n    final List<ParseTree> children = ctx.children\n            .stream()\n            .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n            .collect(Collectors.toUnmodifiableList());\n    processChildren(methodDef, children);\n\n    final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n    ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n    return methodDef;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "13", "src_id": "M839", "code": "\n@Override\npublic DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n    final DetailAstImpl dummyRoot = new DetailAstImpl();\n    dummyRoot.addChild(create(ctx.LPAREN()));\n\n    dummyRoot.addChild(ctx.forInit() == null\n        ? createImaginary(TokenTypes.FOR_INIT)\n        : visit(ctx.forInit()));\n\n    dummyRoot.addChild(create(ctx.SEMI(0)));\n\n    final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n    forCondParent.addChild(visit(ctx.forCond));\n    dummyRoot.addChild(forCondParent);\n    dummyRoot.addChild(create(ctx.SEMI(1)));\n\n    final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n    forItParent.addChild(visit(ctx.forUpdate));\n    dummyRoot.addChild(forItParent);\n\n    dummyRoot.addChild(create(ctx.RPAREN()));\n\n    return dummyRoot.getFirstChild();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "14", "src_id": "M228", "code": "\nprivate static Map.Entry<Integer, Integer> countLinesColumns(\n    String text, int initialLinesCnt, int initialColumnsCnt) {\n    int lines = initialLinesCnt;\n    int columns = initialColumnsCnt;\n    boolean foundCr = false;\n    for (char c : text.toCharArray()) {\n        if (c == '\\n') {\n            foundCr = false;\n            lines++;\n            columns = 0;\n        }\n        else {\n            if (foundCr) {\n                foundCr = false;\n                lines++;\n                columns = 0;\n            }\n            if (c == '\\r') {\n                foundCr = true;\n            }\n            columns++;\n        }\n    }\n    if (foundCr) {\n        lines++;\n        columns = 0;\n    }\n    return new AbstractMap.SimpleEntry<>(lines, columns);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "15", "src_id": "M212", "code": "\npublic static Properties getResolvedProperties(Properties properties)\n        throws CheckstyleException {\n    final Set<String> unresolvedPropertyNames =\n        new HashSet<>(properties.stringPropertyNames());\n    final Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n    final Map<Object, Object> comparisonProperties = new Properties();\n\n    while (unresolvedPropertyIterator.hasNext()) {\n        final String propertyName = unresolvedPropertyIterator.next();\n        String propertyValue = properties.getProperty(propertyName);\n        final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n        while (matcher.find()) {\n            final String propertyVariableExpression = matcher.group();\n            final String unresolvedPropertyName =\n                getPropertyNameFromExpression(propertyVariableExpression);\n\n            final String resolvedPropertyValue =\n                properties.getProperty(unresolvedPropertyName);\n\n            if (resolvedPropertyValue != null) {\n                propertyValue = propertyValue.replace(propertyVariableExpression,\n                    resolvedPropertyValue);\n                properties.setProperty(propertyName, propertyValue);\n            }\n        }\n\n        if (allChainedPropertiesAreResolved(propertyValue)) {\n            unresolvedPropertyIterator.remove();\n        }\n\n        if (!unresolvedPropertyIterator.hasNext()) {\n            if (comparisonProperties.equals(properties)) {\n                throw new CheckstyleException(UNDEFINED_PROPERTY_MESSAGE\n                    + unresolvedPropertyNames);\n            }\n            comparisonProperties.putAll(properties);\n            unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n        }\n    }\n    return properties;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "16", "src_id": "M794", "code": "\n@Override\npublic DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n    if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n        return null;\n    }\n\n    final DetailAstImpl annotations = createImaginary(TokenTypes.ANNOTATIONS);\n    processChildren(annotations, ctx.anno);\n    return annotations;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "17", "src_id": "M764", "code": "\n@Override\npublic DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n    final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n    processChildren(typeParameter, ctx.children);\n    return typeParameter;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "18", "src_id": "M492", "code": "\nprivate void checkYield() {\n    final DetailAST yieldKey = getMainAst();\n    final int columnNo = expandedTabsColumnNo(yieldKey);\n    if (isOnStartOfLine(yieldKey) && !getIndent().isAcceptable(columnNo)) {\n        logError(yieldKey, \"\", columnNo);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "19", "src_id": "M284", "code": "\nprivate static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n    return entry.getLastLine() > line\n            || entry.getLastLine() == line && entry.getLastColumn() >= column;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "20", "src_id": "M294", "code": "\nprivate static boolean canBeSubclassed(DetailAST classDef) {\n    final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n    return classDef.getType() != TokenTypes.ENUM_DEF\n            && modifiers.findFirstToken(TokenTypes.FINAL) == null\n            && hasDefaultOrExplicitNonPrivateCtor(classDef);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "21", "src_id": "M714", "code": "\nprivate static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n    DetailAST vertex = ast;\n    final Set<DetailAST> result = new HashSet<>();\n    final Deque<DetailAST> stack = new ArrayDeque<>();\n    while (vertex != null || !stack.isEmpty()) {\n        if (!stack.isEmpty()) {\n            vertex = stack.pop();\n        }\n        while (vertex != null) {\n            if (vertex.getType() == tokenType) {\n                result.add(vertex);\n            }\n            if (vertex.getNextSibling() != null) {\n                stack.push(vertex.getNextSibling());\n            }\n            vertex = vertex.getFirstChild();\n        }\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "22", "src_id": "M504", "code": "\n@Override\npublic int[] getAcceptableTokens() {\n    return new int[] {\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "23", "src_id": "M207", "code": "\npublic static String getFileExtension(String fileNameWithExtension) {\n    final String fileName = Paths.get(fileNameWithExtension).toString();\n    final int dotIndex = fileName.lastIndexOf('.');\n    final String extension;\n    if (dotIndex == -1) {\n        extension = \"\";\n    }\n    else {\n        extension = fileName.substring(dotIndex + 1);\n    }\n    return extension;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "24", "src_id": "M716", "code": "\nprivate static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(\n        DetailAST ast, DetailAST token, int endLineNumber) {\n    DetailAST vertex = ast;\n    final Set<DetailAST> result = new HashSet<>();\n    final Deque<DetailAST> stack = new ArrayDeque<>();\n    while (vertex != null || !stack.isEmpty()) {\n        if (!stack.isEmpty()) {\n            vertex = stack.pop();\n        }\n        while (vertex != null) {\n            if (isAstSimilar(token, vertex)\n                    && vertex.getLineNo() <= endLineNumber) {\n                result.add(vertex);\n            }\n            if (vertex.getNextSibling() != null) {\n                stack.push(vertex.getNextSibling());\n            }\n            vertex = vertex.getFirstChild();\n        }\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "25", "src_id": "M293", "code": "\nprivate static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n    DetailAST searchAST = ast;\n    while (searchAST.getType() != TokenTypes.CLASS_DEF\n            && searchAST.getType() != TokenTypes.ENUM_DEF) {\n        searchAST = searchAST.getParent();\n    }\n    return searchAST;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "26", "src_id": "M704", "code": "\nprivate boolean isForwardReference(DetailAST fieldDef) {\n    final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n    final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n    boolean forwardReference = false;\n    for (DetailAST ident : exprIdents) {\n        if (classFieldNames.contains(ident.getText())) {\n            forwardReference = true;\n            break;\n        }\n    }\n    return forwardReference;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "27", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n        for (DetailAST currentBranch = shiftToNextTraversedBranch(startingBranch, bound);\n             currentBranch != null;\n             currentBranch = shiftToNextTraversedBranch(currentBranch, bound)) {\n            if (currentBranch.getType() == neededTokenType) {\n                return currentBranch;\n            }\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "28", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n            DetailAST parentToken) {\n        DetailAST lastNode = parentToken.getPreviousSibling();\n        if (lastNode != null) {\n            while (lastNode.getLastChild() != null) {\n                lastNode = lastNode.getLastChild();\n            }\n        }\n        return token.getLineNo() != lastNode.getLineNo();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "29", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n             expressionBranch != null;\n             expressionBranch = traverseUntilNeededBranchType(\n                 expressionBranch, branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n        return reassignedVariableIdents;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "30", "src_id": "M485", "code": "\n        private static Pattern createPatternFromLine(String line) {\n            final Pattern result;\n            if (line.isEmpty()) {\n                result = BLANK_LINE;\n            }\n            else {\n                result = Pattern.compile(validateRegex(line));\n            }\n            return result;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "31", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "32", "src_id": "M597", "code": "\n    private void checkTypeDefinition(DetailAST ast) {\n        final DetailAST nextSibling = ast.getNextSibling();\n        if (!ScopeUtil.isOuterMostType(ast) && isSemicolon(nextSibling)) {\n            log(nextSibling, MSG_SEMI);\n        }\n\n        final DetailAST firstMember = ast.findFirstToken(TokenTypes.OBJBLOCK)\n            .getFirstChild()\n            .getNextSibling();\n        if (isSemicolon(firstMember) && !ScopeUtil.isInEnumBlock(firstMember)) {\n            log(firstMember, MSG_SEMI);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "33", "src_id": "M655", "code": "\n    private void checkLambda(DetailAST ast, DetailAST currentStatement) {\n        int countOfSemiInCurrentLambda = countOfSemiInLambda.pop();\n        countOfSemiInCurrentLambda++;\n        countOfSemiInLambda.push(countOfSemiInCurrentLambda);\n        \n        if (!inForHeader\n            && countOfSemiInCurrentLambda > 1\n            && isOnTheSameLine(currentStatement, lastStatementEnd,\n                forStatementEnd, lambdaStatementEnd)) {\n            log(ast, MSG_KEY);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "34", "src_id": "M587", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST enumBlock = ast.findFirstToken(TokenTypes.OBJBLOCK);\n        final DetailAST semicolon = enumBlock.findFirstToken(TokenTypes.SEMI);\n        if (semicolon == null || !isEndOfEnumerationAfter(semicolon)) {\n            return;\n        }\n        log(semicolon, MSG_SEMI);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "35", "src_id": "M202", "code": "\n    public static InputSource sourceFromFilename(String filename) throws CheckstyleException {\n        final URI uri = getUriByFilename(filename);\n        return new InputSource(uri.toASCIIString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "36", "src_id": "M633", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.RECORD_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "37", "src_id": "M285", "code": "\n    private static void addSuppressions(List<String> values, DetailAST targetAST) {\n        final int firstLine = targetAST.getLineNo();\n        final int firstColumn = targetAST.getColumnNo();\n        final DetailAST nextAST = targetAST.getNextSibling();\n        final int lastLine;\n        final int lastColumn;\n        if (nextAST == null) {\n            lastLine = Integer.MAX_VALUE;\n            lastColumn = Integer.MAX_VALUE;\n        }\n        else {\n            lastLine = nextAST.getLineNo();\n            lastColumn = nextAST.getColumnNo();\n        }\n\n        final List<Entry> entries = ENTRIES.get();\n        for (String value : values) {\n            final String checkName = removeCheckstylePrefixIfExists(value);\n            entries.add(new Entry(checkName, firstLine, firstColumn,\n                lastLine, lastColumn));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "38", "src_id": "M276", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        if (ast.getParent().getType() == TokenTypes.SWITCH_RULE) {\n            return;\n        }\n\n        final int length = getLength(ast);\n        if (length > max) {\n            log(ast, MSG_KEY, length, max);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "39", "src_id": "M279", "code": "\n    private static int getFirstNodeLineNumber(DetailAST lambdaBody) {\n        DetailAST currentNode = lambdaBody;\n        int lineNumber;\n        do {\n            lineNumber = currentNode.getLineNo();\n            currentNode = currentNode.getFirstChild();\n        } while (currentNode != null);\n        return lineNumber;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "40", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n                              DetailAST bound, int neededTokenType) {\n        DetailAST result = null;\n        DetailAST current = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (current != null) {\n            if (current.getType() == neededTokenType) {\n                result = current;\n                break;\n            }\n            current = shiftToNextTraversedBranch(current, bound);\n        }\n\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "41", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n                                                            DetailAST parentToken) {\n        DetailAST lastNode = parentToken.getPreviousSibling();\n        DetailAST current = lastNode;\n\n        while (current != null) {\n            lastNode = current;\n            current = current.getLastChild();\n        }\n\n        return token.getLineNo() != lastNode.getLineNo();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "42", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branch = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> result = new ArrayList<>();\n\n        for (DetailAST exprBranch = branch;\n             exprBranch != null;\n             exprBranch = traverseUntilNeededBranchType(exprBranch,\n                 branch, TokenTypes.EXPR)) {\n\n            final DetailAST assignToken = getMatchedAssignToken(exprBranch);\n            if (assignToken != null) {\n                result.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "43", "src_id": "M347", "code": "\n@Override\npublic void visitToken(final DetailAST ast) {\n    switch (ast.getType()) {\n        case TokenTypes.IDENT:\n            if (collect) {\n                processIdent(ast);\n            }\n            break;\n        case TokenTypes.IMPORT:\n            processImport(ast);\n            break;\n        case TokenTypes.STATIC_IMPORT:\n            processStaticImport(ast);\n            break;\n        case TokenTypes.OBJBLOCK:\n        case TokenTypes.SLIST:\n            currentFrame = currentFrame.push();\n            break;\n        default:\n            collect = true;\n            if (processJavadoc) {\n                collectReferencesFromJavadoc(ast);\n            }\n            break;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "44", "src_id": "M394", "code": "\n@Override\npublic int[] getRequiredJavadocTokens() {\n    return new int[] {\n        JavadocTokenTypes.TEXT,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "45", "src_id": "M571", "code": "\nprivate static DetailAST getLeftNode(final DetailAST node) {\n    DetailAST result;\n    if (node.getFirstChild() == null || isAssignToVariable(node)) {\n        result = node.getPreviousSibling();\n    }\n    else if (isInPatternDefinition(node)) {\n        result = node.getFirstChild();\n    }\n    else {\n        result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n    }\n    while (result.getLastChild() != null) {\n        result = result.getLastChild();\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "46", "src_id": "M79", "code": "\nprivate static Stream<?> getValuesStream(Object value) {\n    return value instanceof Collection\n            ? ((Collection<?>) value).stream()\n            : Arrays.stream((Object[]) value);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "47", "src_id": "M103", "code": "\n@Override\npublic void body() {\n    write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding + \"\\\"?>\");\n    writeEOL();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "48", "src_id": "M72", "code": "\nprivate static DetailNode getSinceJavadocTag(DetailNode javadoc) {\n    for (DetailNode child : javadoc.getChildren()) {\n        if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n            final DetailNode sinceNode = JavadocUtil.findFirstToken(\n                    child, JavadocTokenTypes.SINCE_LITERAL);\n            if (sinceNode != null) {\n                return child;\n            }\n        }\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "49", "src_id": "M46", "code": "\nprivate static String getLinkToParentModule(String parentModule, String moduleName)\n        throws MacroExecutionException {\n    final Path templatePath = SiteUtil.getTemplatePath(moduleName);\n    if (templatePath == null) {\n        throw new MacroExecutionException(\n                String.format(Locale.ROOT, \"Could not find template for %s\", moduleName));\n    }\n    final Path templatePathParent = templatePath.getParent();\n    if (templatePathParent == null) {\n        throw new MacroExecutionException(\"Failed to get parent path for \" + templatePath);\n    }\n    return templatePathParent\n            .relativize(Path.of(\"src\", \"site/xdoc\", \"config.xml\"))\n            .toString()\n            .replace(\".xml\", \".html\")\n            .replace('\\\\', '/')\n            + \"#\" + parentModule;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "50", "src_id": "M78", "code": "\nprivate static String getStringArrayPropertyValue(String propertyName, Object value) {\n    String result = \"\";\n    if (value != null) {\n        try (Stream<?> valuesStream = getValuesStream(value)) {\n            result = valuesStream\n                .map(String.class::cast)\n                .sorted()\n                .collect(Collectors.joining(COMMA_SPACE));\n        }\n    }\n    if (result.isEmpty()) {\n        result = FILE_EXTENSIONS.equals(propertyName)\n                ? \"all files\"\n                : CURLY_BRACKETS;\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "51", "src_id": "M114", "code": "\nprivate static void createListItem(XdocSink sink, Class<?> clss, String messageKey) {\n    final String messageKeyUrl = constructMessageKeyUrl(clss, messageKey);\n    final String indentLevel10 = SiteUtil.getNewlineAndIndentSpaces(10);\n    final String indentLevel12 = SiteUtil.getNewlineAndIndentSpaces(12);\n    final String indentLevel14 = SiteUtil.getNewlineAndIndentSpaces(14);\n    sink.rawText(indentLevel10);\n    sink.setInsertNewline(false);\n    sink.listItem();\n    sink.setInsertNewline(true);\n    sink.rawText(indentLevel12);\n    sink.link(messageKeyUrl);\n    sink.rawText(indentLevel14);\n    sink.rawText(messageKey);\n    sink.rawText(indentLevel12);\n    sink.link_();\n    sink.rawText(indentLevel10);\n    sink.listItem_();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "52", "src_id": "M58", "code": "\nprivate static Set<Field> getCheckMessageKeys(Class<?> module)\n        throws MacroExecutionException {\n    try {\n        final Set<Field> checkstyleMessages = Arrays.stream(module.getDeclaredFields())\n                .filter(field -> field.getName().startsWith(\"MSG_\"))\n                .collect(Collectors.toSet());\n        final Class<?> superModule = module.getSuperclass();\n        if (superModule != null) {\n            checkstyleMessages.addAll(getCheckMessageKeys(superModule));\n        }\n        if (module == RegexpMultilineCheck.class) {\n            checkstyleMessages.addAll(getCheckMessageKeys(Class\n                .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.MultilineDetector\")));\n        }\n        else if (module == RegexpSinglelineCheck.class\n                || module == RegexpSinglelineJavaCheck.class) {\n            checkstyleMessages.addAll(getCheckMessageKeys(Class\n                .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.SinglelineDetector\")));\n        }\n        return checkstyleMessages;\n    }\n    catch (ClassNotFoundException exc) {\n        final String message = String.format(Locale.ROOT, \"Couldn't find class: %s\",\n                module.getName());\n        throw new MacroExecutionException(message, exc);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "53", "src_id": "M68", "code": "\nprivate static Set<String> getNonExplicitProperties(\n        Object instance, Class<?> clss) {\n    final Set<String> result = new TreeSet<>();\n    if (AbstractCheck.class.isAssignableFrom(clss)) {\n        final AbstractCheck check = (AbstractCheck) instance;\n        final int[] acceptableTokens = check.getAcceptableTokens();\n        Arrays.sort(acceptableTokens);\n        final int[] defaultTokens = check.getDefaultTokens();\n        Arrays.sort(defaultTokens);\n        final int[] requiredTokens = check.getRequiredTokens();\n        Arrays.sort(requiredTokens);\n        if (!Arrays.equals(acceptableTokens, defaultTokens)\n                || !Arrays.equals(acceptableTokens, requiredTokens)) {\n            result.add(TOKENS);\n        }\n    }\n    if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n        final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n        result.add(\"violateExecutionOnNonTightHtml\");\n        final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n        Arrays.sort(acceptableJavadocTokens);\n        final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n        Arrays.sort(defaultJavadocTokens);\n        final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n        Arrays.sort(requiredJavadocTokens);\n        if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n            result.add(JAVADOC_TOKENS);\n        }\n    }\n    if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n        result.add(FILE_EXTENSIONS);\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "54", "src_id": "M65", "code": "\nprivate static void processModule(String moduleName, Path modulePath)\n        throws MacroExecutionException {\n    if (!Files.isRegularFile(modulePath)) {\n        final String message = String.format(Locale.ROOT,\n                \"File %s is not a file. Please check the 'modulePath' property.\", modulePath);\n        throw new MacroExecutionException(message);\n    }\n    ClassAndPropertiesSettersJavadocScraper.initialize(moduleName);\n    final Checker checker = new Checker();\n    checker.setModuleClassLoader(Checker.class.getClassLoader());\n    final DefaultConfiguration scraperCheckConfig =\n                    new DefaultConfiguration(\n                            ClassAndPropertiesSettersJavadocScraper.class.getName());\n    final DefaultConfiguration defaultConfiguration =\n            new DefaultConfiguration(\"configuration\");\n    final DefaultConfiguration treeWalkerConfig =\n            new DefaultConfiguration(TreeWalker.class.getName());\n    defaultConfiguration.addProperty(CHARSET, StandardCharsets.UTF_8.name());\n    defaultConfiguration.addChild(treeWalkerConfig);\n    treeWalkerConfig.addChild(scraperCheckConfig);\n    try {\n        checker.configure(defaultConfiguration);\n        final List<File> filesToProcess = List.of(modulePath.toFile());\n        checker.process(filesToProcess);\n        checker.destroy();\n    }\n    catch (CheckstyleException checkstyleException) {\n        final String message = String.format(Locale.ROOT, \"Failed processing %s\", moduleName);\n        throw new MacroExecutionException(message, checkstyleException);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "55", "src_id": "M110", "code": "\nprivate static DetailAST getParentAst(DetailAST ast, int type) {\n    for (DetailAST node = ast.getParent(); node != null; node = node.getParent()) {\n        if (node.getType() == type) {\n            return node;\n        }\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "56", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "57", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n            DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        DetailAST astNode = previousSibling;\n        while (astNode != null) {\n            previousSibling = astNode;\n            astNode = astNode.getLastChild();\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "58", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "59", "src_id": "M284", "code": "\nprivate static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n    return entry.getLastLine() > line\n        || entry.getLastLine() == line && entry\n            .getLastColumn() >= column;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "60", "src_id": "M294", "code": "\nprivate static boolean canBeSubclassed(DetailAST classDef) {\n    final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n    return classDef.getType() != TokenTypes.ENUM_DEF\n        && modifiers.findFirstToken(TokenTypes.FINAL) == null\n        && hasDefaultOrExplicitNonPrivateCtor(classDef);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "61", "src_id": "M714", "code": "\nprivate static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n    DetailAST vertex = ast;\n    final Set<DetailAST> result = new HashSet<>();\n    final Deque<DetailAST> stack = new ArrayDeque<>();\n    while (vertex != null || !stack.isEmpty()) {\n        if (!stack.isEmpty()) {\n            vertex = stack.pop();\n        }\n        while (vertex != null) {\n            if (vertex.getType() == tokenType) {\n                result.add(vertex);\n            }\n            if (vertex.getNextSibling() != null) {\n                stack.push(vertex.getNextSibling());\n            }\n            vertex = vertex.getFirstChild();\n        }\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "62", "src_id": "M504", "code": "\n@Override\npublic int[] getAcceptableTokens() {\n    return new int[] {\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "63", "src_id": "M207", "code": "\npublic static String getFileExtension(String fileNameWithExtension) {\n    final String fileName = Paths.get(fileNameWithExtension).toString();\n    final int dotIndex = fileName.lastIndexOf('.');\n    final String extension;\n    if (dotIndex == -1) {\n        extension = \"\";\n    }\n    else {\n        extension = fileName.substring(dotIndex + 1);\n    }\n    return extension;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "64", "src_id": "M716", "code": "\nprivate static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\n                                                                 int endLineNumber) {\n    DetailAST vertex = ast;\n    final Set<DetailAST> result = new HashSet<>();\n    final Deque<DetailAST> stack = new ArrayDeque<>();\n    while (vertex != null || !stack.isEmpty()) {\n        if (!stack.isEmpty()) {\n            vertex = stack.pop();\n        }\n        while (vertex != null) {\n            if (isAstSimilar(token, vertex)\n                    && vertex.getLineNo() <= endLineNumber) {\n                result.add(vertex);\n            }\n            if (vertex.getNextSibling() != null) {\n                stack.push(vertex.getNextSibling());\n            }\n            vertex = vertex.getFirstChild();\n        }\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "65", "src_id": "M293", "code": "\nprivate static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n    DetailAST searchAST = ast;\n    while (searchAST.getType() != TokenTypes.CLASS_DEF\n           && searchAST.getType() != TokenTypes.ENUM_DEF) {\n        searchAST = searchAST.getParent();\n    }\n    return searchAST;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "66", "src_id": "M704", "code": "\nprivate boolean isForwardReference(DetailAST fieldDef) {\n    final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n    final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n    return exprIdents.stream()\n        .map(DetailAST::getText)\n        .anyMatch(classFieldNames::contains);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "67", "src_id": "M37", "code": "\nprivate ModuleType getModuleType() {\n    final String simpleModuleName = getModuleSimpleName();\n    ModuleType result = ModuleType.CHECK;\n\n    if (simpleModuleName.endsWith(\"FileFilter\")) {\n        result = ModuleType.FILEFILTER;\n    }\n    else if (simpleModuleName.endsWith(\"Filter\")) {\n        result = ModuleType.FILTER;\n    }\n\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "68", "src_id": "M28", "code": "\nprivate void scrapeContent(DetailNode ast) {\n    if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n        if (isParentText(ast)) {\n            parentSectionStartIdx = getParentIndexOf(ast);\n            moduleDetails.setParent(getParentText(ast));\n        }\n        else if (isViolationMessagesText(ast)) {\n            scrapingViolationMessageList = true;\n        }\n        else if (exampleSectionStartIdx == -1\n                && isExamplesText(ast)) {\n            exampleSectionStartIdx = getParentIndexOf(ast);\n        }\n    }\n    else if (ast.getType() == JavadocTokenTypes.LI) {\n        if (isPropertyList(ast)) {\n            if (propertySectionStartIdx == -1) {\n                propertySectionStartIdx = getParentIndexOf(ast);\n            }\n            moduleDetails.addToProperties(createProperties(ast));\n        }\n        else if (scrapingViolationMessageList) {\n            moduleDetails.addToViolationMessages(getViolationMessages(ast));\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "69", "src_id": "M27", "code": "\n@Override\npublic void beginJavadocTree(DetailNode rootAst) {\n    if (isTopLevelClassJavadoc()) {\n        moduleDetails = new ModuleDetails();\n        toScan = false;\n        scrapingViolationMessageList = false;\n        propertySectionStartIdx = -1;\n        exampleSectionStartIdx = -1;\n        parentSectionStartIdx = -1;\n\n        final String simpleName = getModuleSimpleName();\n        final String checkModuleExtension = \"Check\";\n        final String moduleName;\n\n        if (simpleName.endsWith(checkModuleExtension)) {\n            moduleName = simpleName.substring(0,\n                    simpleName.length() - checkModuleExtension.length());\n        }\n        else {\n            moduleName = simpleName;\n        }\n\n        moduleDetails.setName(moduleName);\n        moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n        moduleDetails.setModuleType(getModuleType());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "70", "src_id": "M35", "code": "\nprivate static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                Pattern pattern) {\n    return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "71", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n            || entry.getLastLine() == line && entry\n                .getLastColumn() >= column;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "72", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n            && modifiers.findFirstToken(TokenTypes.FINAL) == null\n            && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "73", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "74", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "75", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension = dotIndex == -1\n            ? \"\"\n            : fileName.substring(dotIndex + 1);\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "76", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                    && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "77", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n            && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "78", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        return exprIdents.stream()\n            .anyMatch(ident -> classFieldNames.contains(ident.getText()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "79", "src_id": "M485", "code": "\n        private static Pattern createPatternFromLine(String line) {\n            if (line.isEmpty()) {\n                return BLANK_LINE;\n            }\n            return Pattern.compile(validateRegex(line));\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "80", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "81", "src_id": "M646", "code": "\n    private static List<DetailAST> getChildList(DetailAST ast) {\n        final List<DetailAST> children = new ArrayList<>();\n        DetailAST child = ast.findFirstToken(TokenTypes.OBJBLOCK).getFirstChild();\n        while (child != null) {\n            children.add(child);\n            child = child.getNextSibling();\n        }\n        return children;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "82", "src_id": "M373", "code": "\n    private void checkParagraphTag(DetailNode tag) {\n        if (!isNestedParagraph(tag)) {\n            final DetailNode newLine = getNearestEmptyLine(tag);\n            if (isFirstParagraph(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_REDUNDANT_PARAGRAPH);\n            } else if (newLine == null || tag.getLineNumber() - newLine.getLineNumber() != 1) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_LINE_BEFORE);\n            }\n\n            final String blockTagName = findFollowedBlockTagName(tag);\n            if (blockTagName != null) {\n                log(tag.getLineNumber(), tag.getColumnNumber(),\n                        MSG_PRECEDED_BLOCK_TAG, blockTagName);\n            }\n\n            if (!allowNewlineParagraph && isImmediatelyFollowedByNewLine(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n            }\n            if (isImmediatelyFollowedByText(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "83", "src_id": "M406", "code": "\n    @Override\n    public void finishJavadocTree(DetailNode rootAst) {\n        // this method checks the alignment of closing javadoc tag.\n        final DetailAST javadocEndToken = getBlockCommentAst().getLastChild();\n        final String lastLine = fileLines[javadocEndToken.getLineNo() - 1];\n        final Optional<Integer> endingBlockColumnNumber = getAsteriskColumnNumber(lastLine);\n\n        endingBlockColumnNumber\n                .map(columnNumber -> expandedTabs(lastLine, columnNumber))\n                .filter(columnNumber -> \n                    !hasValidAlignment(expectedColumnNumberTabsExpanded, columnNumber))\n                .ifPresent(columnNumber -> logViolation(\n                    javadocEndToken.getLineNo(),\n                    columnNumber,\n                    expectedColumnNumberTabsExpanded\n                ));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "84", "src_id": "M485", "code": "\n        private static Pattern createPatternFromLine(String line) {\n            final Pattern result;\n            if (line.isEmpty()) {\n                result = BLANK_LINE;\n            }\n            else {\n                result = Pattern.compile(validateRegex(line));\n            }\n            return result;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "85", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "86", "src_id": "M37", "code": "\nprivate ModuleType getModuleType() {\n    final String simpleModuleName = getModuleSimpleName();\n\n    if (simpleModuleName.endsWith(\"FileFilter\")) {\n        return ModuleType.FILEFILTER;\n    }\n    if (simpleModuleName.endsWith(\"Filter\")) {\n        return ModuleType.FILTER;\n    }\n    return ModuleType.CHECK;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "87", "src_id": "M28", "code": "\nprivate void scrapeContent(DetailNode ast) {\n    if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n        if (isParentText(ast)) {\n            parentSectionStartIdx = getParentIndexOf(ast);\n            moduleDetails.setParent(getParentText(ast));\n        }\n        else if (isViolationMessagesText(ast)) {\n            scrapingViolationMessageList = true;\n        }\n        else if (exampleSectionStartIdx == -1\n                && isExamplesText(ast)) {\n            exampleSectionStartIdx = getParentIndexOf(ast);\n        }\n    }\n    else if (ast.getType() == JavadocTokenTypes.LI) {\n        if (isPropertyList(ast)) {\n            if (propertySectionStartIdx == -1) {\n                propertySectionStartIdx = getParentIndexOf(ast);\n            }\n            moduleDetails.addToProperties(createProperties(ast));\n        }\n        else if (scrapingViolationMessageList) {\n            moduleDetails.addToViolationMessages(getViolationMessages(ast));\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "88", "src_id": "M27", "code": "\n@Override\npublic void beginJavadocTree(DetailNode rootAst) {\n    if (!isTopLevelClassJavadoc()) {\n        return;\n    }\n\n    moduleDetails = new ModuleDetails();\n    toScan = false;\n    scrapingViolationMessageList = false;\n    propertySectionStartIdx = -1;\n    exampleSectionStartIdx = -1;\n    parentSectionStartIdx = -1;\n\n    String moduleName = getModuleSimpleName();\n    final String checkModuleExtension = \"Check\";\n    if (moduleName.endsWith(checkModuleExtension)) {\n        moduleName = moduleName\n                .substring(0, moduleName.length() - checkModuleExtension.length());\n    }\n    moduleDetails.setName(moduleName);\n    moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n    moduleDetails.setModuleType(getModuleType());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "89", "src_id": "M35", "code": "\nprivate static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                Pattern pattern) {\n    return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "90", "src_id": "M37", "code": "\n    private ModuleType getModuleType() {\n        String simpleModuleName = getModuleSimpleName();\n        ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "91", "src_id": "M28", "code": "\n    private void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "92", "src_id": "M27", "code": "\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            String moduleName = getModuleSimpleName();\n            String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName\n                    .substring(0, moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "93", "src_id": "M35", "code": "\n    private static Optional<DetailNode> getFirstChildOfMatchingText(\n            DetailNode node, Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "94", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        Pattern result = BLANK_LINE;\n        if (!line.isEmpty()) {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "95", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "96", "src_id": "M601", "code": "\n@Override\npublic void beginTree(DetailAST root) {\n    variables.clear();\n    typeDeclarations.clear();\n    typeDeclAstToTypeDeclDesc.clear();\n    anonInnerAstToTypeDeclDesc.clear();\n    anonInnerClassHolders.clear();\n    packageName = null;\n    depth = 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "97", "src_id": "M600", "code": "\n@Override\npublic int[] getDefaultTokens() {\n    return new int[] {\n        TokenTypes.DOT,\n        TokenTypes.VARIABLE_DEF,\n        TokenTypes.IDENT,\n        TokenTypes.SLIST,\n        TokenTypes.LITERAL_FOR,\n        TokenTypes.OBJBLOCK,\n        TokenTypes.CLASS_DEF,\n        TokenTypes.INTERFACE_DEF,\n        TokenTypes.ANNOTATION_DEF,\n        TokenTypes.PACKAGE_DEF,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.CTOR_DEF,\n        TokenTypes.STATIC_INIT,\n        TokenTypes.INSTANCE_INIT,\n        TokenTypes.COMPILATION_UNIT,\n        TokenTypes.LAMBDA,\n        TokenTypes.ENUM_DEF,\n        TokenTypes.RECORD_DEF,\n        TokenTypes.COMPACT_CTOR_DEF,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "98", "src_id": "M615", "code": "\nprivate void iterateOverBlockContainingLocalAnonInnerClass(\n        DetailAST ast, Deque<VariableDesc> variablesStack) {\n    DetailAST currNode = ast;\n    while (currNode != null) {\n        customVisitToken(currNode, variablesStack);\n        DetailAST toVisit = currNode.getFirstChild();\n        while (currNode != ast && toVisit == null) {\n            customLeaveToken(currNode, variablesStack);\n            toVisit = currNode.getNextSibling();\n            currNode = currNode.getParent();\n        }\n        currNode = toVisit;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "99", "src_id": "M383", "code": "\nprivate static void extractInlineTagContent(DetailNode node,\n    StringBuilder customTagContent) {\n    final DetailNode[] children = node.getChildren();\n    if (children.length == 0) {\n        customTagContent.append(node.getText());\n    }\n    else {\n        for (DetailNode child : children) {\n            if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                extractInlineTagContent(child, customTagContent);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "100", "src_id": "M593", "code": "\nprivate void visitLambdaParameters(DetailAST ast) {\n    if (ast.getType() == TokenTypes.IDENT) {\n        parameterNames.add(ast.getText());\n    }\n    else {\n        visitParameters(ast);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "101", "src_id": "M175", "code": "\n@Override\npublic void auditFinished(AuditEvent event) {\n    errorWriter.flush();\n    if (closeErrorWriter) {\n        errorWriter.close();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "102", "src_id": "M603", "code": "\n@Override\npublic void leaveToken(DetailAST ast) {\n    if (TokenUtil.isOfType(ast, SCOPES)) {\n        logViolations(ast, variables);\n    }\n    else if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n        leaveCompilationUnit();\n    }\n    else if (isNonLocalTypeDeclaration(ast)) {\n        depth--;\n        typeDeclarations.pop();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "103", "src_id": "M8", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            return CommonUtil.createPattern(value.toString());\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "104", "src_id": "M10", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            return SeverityLevel.getInstance(value.toString());\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "105", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "106", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config)\n            throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "107", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n\n        return annotationString;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "108", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n\n        for (DetailAST branch = shiftToNextTraversedBranch(startingBranch, bound);\n             branch != null;\n             branch = shiftToNextTraversedBranch(branch, bound)) {\n\n            if (branch.getType() == neededTokenType) {\n                return branch;\n            }\n        }\n\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "109", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n                                                           DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        DetailAST node = previousSibling;\n        while (node != null) {\n            previousSibling = node;\n            node = node.getLastChild();\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "110", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST branch = branchLeadingToReassignedVar;\n             branch != null;\n             branch = traverseUntilNeededBranchType(branch,\n                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n            final DetailAST assignToken = getMatchedAssignToken(branch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "111", "src_id": "M855", "code": "\n@Override\npublic DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n    final DetailAstImpl bop = create(ctx.bop);\n    bop.addChild(visit(ctx.expr()));\n    bop.addChild(create(ctx.LITERAL_THIS()));\n    return bop;\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "112", "src_id": "M770", "code": "\n@Override\npublic DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n    final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n    interfaceExtends.addChild(visit(ctx.typeList()));\n    return interfaceExtends;\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "113", "src_id": "M854", "code": "\n@Override\npublic DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n    final DetailAstImpl lambda = create(ctx.LAMBDA());\n    lambda.addChild(visit(ctx.lambdaParameters()));\n\n    final JavaLanguageParser.BlockContext blockContext = ctx.block();\n    final DetailAstImpl rightHandLambdaChild;\n    if (blockContext != null) {\n        rightHandLambdaChild = visit(blockContext);\n    }\n    else {\n        // Lambda expression child is built the same way that we build\n        // the initial expression node in visitExpression, i.e. with\n        // an imaginary EXPR node. This results in nested EXPR nodes\n        // in the AST.\n        rightHandLambdaChild = buildExpressionNode(ctx.expr());\n    }\n    lambda.addChild(rightHandLambdaChild);\n    return lambda;\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "114", "src_id": "M779", "code": "\n@Override\npublic DetailAstImpl visitInterfaceMethodDeclaration(\n        JavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n    final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n    methodDef.addChild(createModifiers(ctx.mods));\n\n    // Process all children except C style array declarators and modifiers\n    final List<ParseTree> children = ctx.children\n        .stream()\n        .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n        .collect(Collectors.toUnmodifiableList());\n    processChildren(methodDef, children);\n\n    // We add C style array declarator brackets to TYPE ast\n    final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n    ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n    return methodDef;\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "115", "src_id": "M839", "code": "\n@Override\npublic DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n    final DetailAstImpl dummyRoot = new DetailAstImpl();\n    dummyRoot.addChild(create(ctx.LPAREN()));\n\n    if (ctx.forInit() == null) {\n        final DetailAstImpl imaginaryForInitParent =\n            createImaginary(TokenTypes.FOR_INIT);\n        dummyRoot.addChild(imaginaryForInitParent);\n    }\n    else {\n        dummyRoot.addChild(visit(ctx.forInit()));\n    }\n\n    dummyRoot.addChild(create(ctx.SEMI(0)));\n\n    final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n    forCondParent.addChild(visit(ctx.forCond));\n    dummyRoot.addChild(forCondParent);\n    dummyRoot.addChild(create(ctx.SEMI(1)));\n\n    final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n    forItParent.addChild(visit(ctx.forUpdate));\n    dummyRoot.addChild(forItParent);\n\n    dummyRoot.addChild(create(ctx.RPAREN()));\n\n    return dummyRoot.getFirstChild();\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "116", "src_id": "M228", "code": "\nprivate static Map.Entry<Integer, Integer> countLinesColumns(\n    String text, int initialLinesCnt, int initialColumnsCnt) {\n    int lines = initialLinesCnt;\n    int columns = initialColumnsCnt;\n    boolean foundCr = false;\n    for (char c : text.toCharArray()) {\n        if (c == '\\n') {\n            foundCr = false;\n            lines++;\n            columns = 0;\n        }\n        else {\n            if (foundCr) {\n                foundCr = false;\n                lines++;\n                columns = 0;\n            }\n            if (c == '\\r') {\n                foundCr = true;\n            }\n            columns++;\n        }\n    }\n    if (foundCr) {\n        lines++;\n        columns = 0;\n    }\n    return new AbstractMap.SimpleEntry<>(lines, columns);\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "117", "src_id": "M212", "code": "\npublic static Properties getResolvedProperties(Properties properties)\n        throws CheckstyleException {\n    final Set<String> unresolvedPropertyNames =\n        new HashSet<>(properties.stringPropertyNames());\n    Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n    final Map<Object, Object> comparisonProperties = new Properties();\n\n    while (unresolvedPropertyIterator.hasNext()) {\n        final String propertyName = unresolvedPropertyIterator.next();\n        String propertyValue = properties.getProperty(propertyName);\n        final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n        while (matcher.find()) {\n            final String propertyVariableExpression = matcher.group();\n            final String unresolvedPropertyName =\n                getPropertyNameFromExpression(propertyVariableExpression);\n\n            final String resolvedPropertyValue =\n                properties.getProperty(unresolvedPropertyName);\n\n            if (resolvedPropertyValue != null) {\n                propertyValue = propertyValue.replace(propertyVariableExpression,\n                    resolvedPropertyValue);\n                properties.setProperty(propertyName, propertyValue);\n            }\n        }\n\n        if (allChainedPropertiesAreResolved(propertyValue)) {\n            unresolvedPropertyIterator.remove();\n        }\n\n        if (!unresolvedPropertyIterator.hasNext()) {\n\n            if (comparisonProperties.equals(properties)) {\n                // At this point, we will have not resolved any properties in two iterations,\n                // so unresolvable properties exist.\n                throw new CheckstyleException(UNDEFINED_PROPERTY_MESSAGE\n                    + unresolvedPropertyNames);\n            }\n            comparisonProperties.putAll(properties);\n            unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n        }\n\n    }\n    return properties;\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "118", "src_id": "M794", "code": "\n@Override\npublic DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n    final DetailAstImpl annotations;\n\n    if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n        // There are no annotations, and we don't want to create the empty node\n        annotations = null;\n    }\n    else {\n        // There are annotations, or we just want the empty node\n        annotations = createImaginary(TokenTypes.ANNOTATIONS);\n        processChildren(annotations, ctx.anno);\n    }\n\n    return annotations;\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "119", "src_id": "M764", "code": "\n@Override\npublic DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n    final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n    processChildren(typeParameter, ctx.children);\n    return typeParameter;\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "120", "src_id": "M492", "code": "\nprivate void checkYield() {\n    final DetailAST yieldKey = getMainAst();\n    final int columnNo = expandedTabsColumnNo(yieldKey);\n    if (isOnStartOfLine(yieldKey) && !getIndent().isAcceptable(columnNo)) {\n        logError(yieldKey, \"\", columnNo);\n    }\n}\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "121", "src_id": "M601", "code": "\n@Override\npublic void beginTree(DetailAST root) {\n    variables.clear();\n    typeDeclarations.clear();\n    typeDeclAstToTypeDeclDesc.clear();\n    anonInnerAstToTypeDeclDesc.clear();\n    anonInnerClassHolders.clear();\n    packageName = null;\n    depth = 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "122", "src_id": "M600", "code": "\n@Override\npublic int[] getDefaultTokens() {\n    return new int[] {\n        TokenTypes.DOT,\n        TokenTypes.VARIABLE_DEF,\n        TokenTypes.IDENT,\n        TokenTypes.SLIST,\n        TokenTypes.LITERAL_FOR,\n        TokenTypes.OBJBLOCK,\n        TokenTypes.CLASS_DEF,\n        TokenTypes.INTERFACE_DEF,\n        TokenTypes.ANNOTATION_DEF,\n        TokenTypes.PACKAGE_DEF,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.CTOR_DEF,\n        TokenTypes.STATIC_INIT,\n        TokenTypes.INSTANCE_INIT,\n        TokenTypes.COMPILATION_UNIT,\n        TokenTypes.LAMBDA,\n        TokenTypes.ENUM_DEF,\n        TokenTypes.RECORD_DEF,\n        TokenTypes.COMPACT_CTOR_DEF,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "123", "src_id": "M615", "code": "\nprivate void iterateOverBlockContainingLocalAnonInnerClass(\n        DetailAST ast, Deque<VariableDesc> variablesStack) {\n    DetailAST currNode = ast;\n    while (currNode != null) {\n        customVisitToken(currNode, variablesStack);\n        DetailAST toVisit = currNode.getFirstChild();\n        while (currNode != ast && toVisit == null) {\n            customLeaveToken(currNode, variablesStack);\n            toVisit = currNode.getNextSibling();\n            currNode = currNode.getParent();\n        }\n        currNode = toVisit;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "124", "src_id": "M383", "code": "\nprivate static void extractInlineTagContent(DetailNode node,\n        StringBuilder customTagContent) {\n    final DetailNode[] children = node.getChildren();\n    if (children.length == 0) {\n        customTagContent.append(node.getText());\n    }\n    else {\n        for (DetailNode child : children) {\n            if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                extractInlineTagContent(child, customTagContent);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "125", "src_id": "M593", "code": "\nprivate void visitLambdaParameters(DetailAST ast) {\n    if (ast.getType() == TokenTypes.IDENT) {\n        parameterNames.add(ast.getText());\n    }\n    else {\n        visitParameters(ast);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "126", "src_id": "M175", "code": "\n@Override\npublic void auditFinished(AuditEvent event) {\n    errorWriter.flush();\n    if (closeErrorWriter) {\n        errorWriter.close();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "127", "src_id": "M603", "code": "\n@Override\npublic void leaveToken(DetailAST ast) {\n    if (TokenUtil.isOfType(ast, SCOPES)) {\n        logViolations(ast, variables);\n    }\n    else if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n        leaveCompilationUnit();\n    }\n    else if (isNonLocalTypeDeclaration(ast)) {\n        depth--;\n        typeDeclarations.pop();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "128", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "129", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "130", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "131", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n\n        for (DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n             iteratedBranch != null;\n             iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound)) {\n\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n        }\n\n        return match;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "132", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n                                                           DetailAST parentToken) {\n        DetailAST node = parentToken.getPreviousSibling();\n        if (node != null) {\n            while (node.getLastChild() != null) {\n                node = node.getLastChild();\n            }\n        }\n        return token.getLineNo() != node.getLineNo();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "133", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar; expressionBranch != null;\n             expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "134", "src_id": "M502", "code": "\nprivate int expandedTabsColumnNo(DetailAST ast) {\n    final String line = indentCheck.getLine(ast.getLineNo() - 1);\n\n    return CommonUtil.lengthExpandedTabs(line,\n                                        ast.getColumnNo(),\n                                        indentCheck.getIndentationTabWidth());\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "135", "src_id": "M455", "code": "\n@Override\npublic void init() {\n    if (fileNamePattern == null && folderPattern == null) {\n        fileNamePattern = CommonUtil.createPattern(\"\\\\s\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "136", "src_id": "M456", "code": "\n@Override\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n    final String fileName = getFileName(file);\n    final String folderPath = getFolderPath(file);\n\n    if (isMatchFolder(folderPath) && isMatchFile(fileName)) {\n        log();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "137", "src_id": "M165", "code": "\nprivate AxisIterator getPrecedingSiblingsIterator() {\n    final AxisIterator result;\n    if (indexAmongSiblings == 0) {\n        result = EmptyIterator.ofNodes();\n    }\n    else {\n        result = new ReverseListIterator(getPrecedingSiblings());\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "138", "src_id": "M750", "code": "\nprivate static String convertUpperCamelToUpperUnderscore(String text) {\n    final StringBuilder result = new StringBuilder(20);\n    boolean first = true;\n    for (char letter : text.toCharArray()) {\n        if (!first && Character.isUpperCase(letter)) {\n            result.append('_');\n        }\n        result.append(Character.toUpperCase(letter));\n        first = false;\n    }\n    return result.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "139", "src_id": "M346", "code": "\n@Override\nprotected boolean matchesExactly(String pkg, String fileName) {\n    final boolean result;\n    if (fileName == null) {\n        result = false;\n    }\n    else if (regex) {\n        result = patternForExactMatch.matcher(fileName).matches();\n    }\n    else {\n        result = name.equals(fileName);\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "140", "src_id": "M706", "code": "\n@Override\npublic void beginTree(DetailAST rootAST) {\n    frames = new HashMap<>();\n    current.clear();\n\n    final Deque<AbstractFrame> frameStack = new LinkedList<>();\n    DetailAST curNode = rootAST;\n    while (curNode != null) {\n        collectDeclarations(frameStack, curNode);\n        DetailAST toVisit = curNode.getFirstChild();\n        while (curNode != null && toVisit == null) {\n            endCollectingDeclarations(frameStack, curNode);\n            toVisit = curNode.getNextSibling();\n            curNode = curNode.getParent();\n        }\n        curNode = toVisit;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "141", "src_id": "M308", "code": "\n@Override\npublic void leaveToken(DetailAST ast) {\n    switch (ast.getType()) {\n        case TokenTypes.CTOR_DEF:\n        case TokenTypes.METHOD_DEF:\n        case TokenTypes.INSTANCE_INIT:\n        case TokenTypes.STATIC_INIT:\n        case TokenTypes.COMPACT_CTOR_DEF:\n            leaveMethodDef(ast);\n            break;\n        default:\n            break;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "142", "src_id": "M167", "code": "\nprivate AttributeNode getAttributeNode() {\n    if (attributeNode == ATTRIBUTE_NODE_UNINITIALIZED) {\n        attributeNode = createAttributeNode();\n    }\n    return attributeNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "143", "src_id": "M398", "code": "\n@Override\npublic int[] getDefaultTokens() {\n    return new int[] {\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "144", "src_id": "M8", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            return CommonUtil.createPattern(value.toString());\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "145", "src_id": "M10", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            return SeverityLevel.getInstance(value.toString());\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "146", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "147", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config)\n            throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "148", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "149", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "150", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "151", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n        return result;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "152", "src_id": "M310", "code": "\n@Override\npublic int[] getAcceptableTokens() {\n    return new int[] {\n        TokenTypes.CTOR_DEF,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.EXPR,\n        TokenTypes.LAND,\n        TokenTypes.BAND,\n        TokenTypes.LOR,\n        TokenTypes.BOR,\n        TokenTypes.BXOR,\n        TokenTypes.COMPACT_CTOR_DEF,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "153", "src_id": "M200", "code": "\npublic static boolean matchesFileExtension(File file, String... fileExtensions) {\n    if (fileExtensions == null || fileExtensions.length == 0) {\n        return true;\n    }\n\n    final String[] withDotExtensions = new String[fileExtensions.length];\n    for (int i = 0; i < fileExtensions.length; i++) {\n        final String extension = fileExtensions[i];\n        if (extension.startsWith(EXTENSION_SEPARATOR)) {\n            withDotExtensions[i] = extension;\n        }\n        else {\n            withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n        }\n    }\n\n    final String fileName = file.getName();\n    for (final String fileExtension : withDotExtensions) {\n        if (fileName.endsWith(fileExtension)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "154", "src_id": "M201", "code": "\npublic static int lengthMinusTrailingWhitespace(String line) {\n    for (int i = line.length() - 1; i >= 0; i--) {\n        if (!Character.isWhitespace(line.charAt(i))) {\n            return i + 1;\n        }\n    }\n    return 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "155", "src_id": "M255", "code": "\nprivate static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n    final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n    for (DetailAST annotationNode : methodAnnotationsList) {\n        if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n            return true;\n        }\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "156", "src_id": "M689", "code": "\n@Override\npublic int[] getRequiredTokens() {\n    return new int[] {\n        TokenTypes.ASSIGN,            // '='\n        TokenTypes.DIV_ASSIGN,        // \"/=\"\n        TokenTypes.PLUS_ASSIGN,       // \"+=\"\n        TokenTypes.MINUS_ASSIGN,      // \"-=\"\n        TokenTypes.STAR_ASSIGN,       // \"*=\"\n        TokenTypes.MOD_ASSIGN,        // \"%=\"\n        TokenTypes.SR_ASSIGN,         // \">>=\"\n        TokenTypes.BSR_ASSIGN,        // \">>>=\"\n        TokenTypes.SL_ASSIGN,         // \"<<=\"\n        TokenTypes.BXOR_ASSIGN,       // \"^=\"\n        TokenTypes.BOR_ASSIGN,        // \"|=\"\n        TokenTypes.BAND_ASSIGN,       // \"&=\"\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "157", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "158", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "159", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null\n            || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "160", "src_id": "M8", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            return CommonUtil.createPattern(value.toString());\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "161", "src_id": "M10", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            return SeverityLevel.getInstance(value.toString());\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "162", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "163", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config)\n            throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (String key : attributes) {\n            final String value = config.getProperty(key);\n\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "164", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "165", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                return iteratedBranch;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "166", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n            DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "167", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                    branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "168", "src_id": "M624", "code": "\nprivate static boolean hasLiteralNull(DetailAST caseAST) {\n    return Optional.ofNullable(caseAST.findFirstToken(TokenTypes.EXPR))\n            .map(exp -> exp.findFirstToken(TokenTypes.LITERAL_NULL))\n            .isPresent();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "169", "src_id": "M253", "code": "\nprivate void checkUnnamedVariables(DetailAST ast) {\n    if (jdkVersion >= JDK_22 && isUnnamedVariable(ast)) {\n        checkForRedundantModifier(ast, TokenTypes.FINAL);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "170", "src_id": "M638", "code": "\n@Override\npublic void leaveToken(DetailAST ast) {\n    if (ast.getType() == TokenTypes.LITERAL_CATCH) {\n        final Optional<CatchParameterDetails> unusedCatchParameter =\n                Optional.ofNullable(catchParameters.peek())\n                        .filter(parameter -> !parameter.isUsed())\n                        .filter(parameter -> !\"_\".equals(parameter.getName()));\n\n        unusedCatchParameter.ifPresent(parameter -> {\n            log(parameter.getParameterDefinition(),\n                    MSG_UNUSED_CATCH_PARAMETER,\n                    parameter.getName());\n        });\n        catchParameters.pop();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "171", "src_id": "M626", "code": "\nprivate static boolean hasStringCaseLabel(DetailAST caseAST) {\n    DetailAST curNode = caseAST;\n    boolean hasStringCaseLabel = false;\n    boolean exitCaseLabelExpression = false;\n    while (!exitCaseLabelExpression) {\n        DetailAST toVisit = curNode.getFirstChild();\n        if (curNode.getType() == TokenTypes.STRING_LITERAL) {\n            hasStringCaseLabel = true;\n            break;\n        }\n        while (toVisit == null) {\n            toVisit = curNode.getNextSibling();\n            curNode = curNode.getParent();\n        }\n        curNode = toVisit;\n        exitCaseLabelExpression = TokenUtil.isOfType(\n                curNode, TokenTypes.COLON, TokenTypes.LAMBDA);\n    }\n    return hasStringCaseLabel;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "172", "src_id": "M673", "code": "\nprivate static boolean isLambdaParameterIdentifierCandidate(DetailAST identifierAst) {\n    final boolean isLambdaParameterDeclaration =\n            identifierAst.getParent().getType() == TokenTypes.LAMBDA\n                || identifierAst.getParent().getType() == TokenTypes.PARAMETER_DEF;\n\n    return !isLambdaParameterDeclaration\n            && (hasValidParentToken(identifierAst)\n                || isMethodInvocation(identifierAst));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "173", "src_id": "M251", "code": "\npublic void setJdkVersion(String jdkVersion) {\n    final String singleVersionNumber;\n    if (jdkVersion.startsWith(\"1.\")) {\n        singleVersionNumber = jdkVersion.substring(2);\n    }\n    else {\n        singleVersionNumber = jdkVersion;\n    }\n\n    this.jdkVersion = Integer.parseInt(singleVersionNumber);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "174", "src_id": "M675", "code": "\nprivate static boolean isLeftHandOfAssignment(DetailAST identAst) {\n    final DetailAST parent = identAst.getParent();\n    return parent.getType() == TokenTypes.ASSIGN\n            && !identAst.equals(parent.getLastChild());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "175", "src_id": "M485", "code": "\nprivate static Pattern createPatternFromLine(String line) {\n    if (line.isEmpty()) {\n        return BLANK_LINE;\n    }\n    return Pattern.compile(validateRegex(line));\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "176", "src_id": "M478", "code": "\npublic String getConfiguredHeaderPaths() {\n    return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "177", "src_id": "M8", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(final Class type, final Object value) {\n            return CommonUtil.createPattern(value.toString());\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "178", "src_id": "M10", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(final Class type, final Object value) {\n            return SeverityLevel.getInstance(value.toString());\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "179", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "180", "src_id": "M4", "code": "\n    @Override\n    public final void configure(final Configuration config)\n            throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "181", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            return FullIdent.createFullIdent(dotNode).getText();\n        }\n        return identNode.getText();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "182", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n\n        for (DetailAST branch = shiftToNextTraversedBranch(startingBranch, bound);\n             branch != null;\n             branch = shiftToNextTraversedBranch(branch, bound)) {\n\n            if (branch.getType() == neededTokenType) {\n                return branch;\n            }\n        }\n\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "183", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n                                                           DetailAST parentToken) {\n        DetailAST current = parentToken.getPreviousSibling();\n        DetailAST lastNode = current;\n        while (current != null) {\n            lastNode = current;\n            current = current.getLastChild();\n        }\n\n        return token.getLineNo() != lastNode.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "184", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n             expressionBranch != null;\n             expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                     branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "185", "src_id": "M310", "code": "\n@Override\npublic int[] getAcceptableTokens() {\n    return new int[] {\n        TokenTypes.CTOR_DEF,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.EXPR,\n        TokenTypes.LAND,\n        TokenTypes.BAND,\n        TokenTypes.LOR,\n        TokenTypes.BOR,\n        TokenTypes.BXOR,\n        TokenTypes.COMPACT_CTOR_DEF,\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "186", "src_id": "M200", "code": "\npublic static boolean matchesFileExtension(final File file, final String... fileExtensions) {\n    if (fileExtensions == null || fileExtensions.length == 0) {\n        return true;\n    }\n    final String[] withDotExtensions = new String[fileExtensions.length];\n    for (int i = 0; i < fileExtensions.length; i++) {\n        final String extension = fileExtensions[i];\n        if (extension.startsWith(EXTENSION_SEPARATOR)) {\n            withDotExtensions[i] = extension;\n        }\n        else {\n            withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n        }\n    }\n    final String fileName = file.getName();\n    for (final String fileExtension : withDotExtensions) {\n        if (fileName.endsWith(fileExtension)) {\n            return true;\n        }\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "187", "src_id": "M201", "code": "\npublic static int lengthMinusTrailingWhitespace(final String line) {\n    int len = line.length();\n    for (int i = len - 1; i >= 0; i--) {\n        if (!Character.isWhitespace(line.charAt(i))) {\n            break;\n        }\n        len--;\n    }\n    return len;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "188", "src_id": "M255", "code": "\nprivate static boolean isAnnotatedWithSafeVarargs(final DetailAST methodDef) {\n    final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n    for (final DetailAST annotationNode : methodAnnotationsList) {\n        if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n            return true;\n        }\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "189", "src_id": "M689", "code": "\n@Override\npublic int[] getRequiredTokens() {\n    return new int[] {\n        TokenTypes.ASSIGN,            // '='\n        TokenTypes.DIV_ASSIGN,        // \"/=\"\n        TokenTypes.PLUS_ASSIGN,       // \"+=\"\n        TokenTypes.MINUS_ASSIGN,      // \"-=\"\n        TokenTypes.STAR_ASSIGN,       // \"*=\"\n        TokenTypes.MOD_ASSIGN,        // \"%=\"\n        TokenTypes.SR_ASSIGN,         // \">>=\"\n        TokenTypes.BSR_ASSIGN,        // \">>>=\"\n        TokenTypes.SL_ASSIGN,         // \"<<=\"\n        TokenTypes.BXOR_ASSIGN,       // \"^=\"\n        TokenTypes.BOR_ASSIGN,        // \"|=\"\n        TokenTypes.BAND_ASSIGN,       // \"&=\"\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "190", "src_id": "M310", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "191", "src_id": "M200", "code": "\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            return true;\n        }\n        final String fileName = file.getName();\n        for (final String extension : fileExtensions) {\n            final String normalizedExtension = extension.startsWith(EXTENSION_SEPARATOR)\n                    ? extension\n                    : EXTENSION_SEPARATOR + extension;\n            if (fileName.endsWith(normalizedExtension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "192", "src_id": "M201", "code": "\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int i = line.length() - 1;\n        while (i >= 0 && Character.isWhitespace(line.charAt(i))) {\n            i--;\n        }\n        return i + 1;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "193", "src_id": "M255", "code": "\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        return getMethodAnnotationsList(methodDef).stream()\n                .anyMatch(annotationNode -> \n                    \"SafeVarargs\".equals(annotationNode.getLastChild().getText()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "194", "src_id": "M689", "code": "\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "195", "src_id": "M8", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            final Object result = CommonUtil.createPattern(value.toString());\n            return result;\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "196", "src_id": "M10", "code": "\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Object convert(Class type, Object value) {\n            final Object result = SeverityLevel.getInstance(value.toString());\n            return result;\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "197", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        final BeanUtilsBean result = new BeanUtilsBean(cub, new PropertyUtilsBean());\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "198", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config)\n            throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "199", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String result;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            result = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            result = identNode.getText();\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "1", "src_id": "M604", "code": "\nprivate String outputFileExt() {\n    String fileExt = \"\";\n    if (format == null) {\n        fileExt = \"html\";\n    } else if (format.startsWith(\"flat\") || format.startsWith(\"traces\") \n                || format.equals(\"collapsed\")) {\n        fileExt = \"txt\";\n    } else if (format.equals(\"flamegraph\") || format.equals(\"tree\")) {\n        fileExt = \"html\";\n    } else if (format.equals(\"jfr\")) {\n        fileExt = \"jfr\";\n    } else {\n        // illegal -o option makes async-profiler use flat\n        fileExt = \"txt\";\n    }\n    return fileExt;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "2", "src_id": "M579", "code": "\n@Option(longName = \"lock\")\n@Description(\"lock profiling threshold in nanoseconds\")\npublic void setLock(String lock) {\n    this.lock = lock;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "3", "src_id": "M585", "code": "\n@Option(longName = \"cstack\")\n@Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\npublic void setCstack(String cstack) {\n    this.cstack = cstack;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "4", "src_id": "M601", "code": "\n@Option(longName = \"timeout\")\n@Description(\"automatically stop profiler at TIME (absolute or relative)\")\npublic void setTimeout(String timeout) {\n    this.timeout = timeout;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "5", "src_id": "M592", "code": "\n@Option(longName = \"end\")\n@Description(\"automatically stop profiling when the specified native function is executed\")\npublic void setEnd(String end) {\n    this.end = end;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "6", "src_id": "M1751", "code": "\n            @Override\n            public void onNext(GrpcRequest<ArthasUnittest.ArthasUnittestRequest> req) {\n                try {\n                    byte[] bytes = req.readData();\n                    while (bytes != null && bytes.length != 0) {\n                        ArthasUnittest.ArthasUnittestRequest request = ArthasUnittest.ArthasUnittestRequest.parseFrom(bytes);\n                        sum.addAndGet(request.getNum());\n                        bytes = req.readData();\n                    }\n                } catch (InvalidProtocolBufferException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "7", "src_id": "M1772", "code": "\n    public void writeResponseData(Object response) {\n        byte[] encode = null;\n        try {\n            if (ArthasGrpc.ErrorRes.class.equals(clazz)) {\n                encode = ((ArthasGrpc.ErrorRes) response).toByteArray();\n            } else {\n                MethodHandle methodHandle = GrpcDispatcher.responseToByteArrayMap.get(\n                    GrpcDispatcher.generateGrpcMethodKey(service, method)\n                );\n                encode = (byte[]) methodHandle.invoke(response);\n            }\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n        this.byteData = ByteUtil.newByteBuf();\n        this.byteData.writeBoolean(false);\n        this.byteData.writeInt(encode.length);\n        this.byteData.writeBytes(encode);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "8", "src_id": "M1766", "code": "\n    private void handleResetStream(Http2ResetFrame resetFrame, ChannelHandlerContext ctx) {\n        int id = resetFrame.stream().id();\n        System.out.println(\"handleResetStream\");\n        dataBuffer.remove(id);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "9", "src_id": "M1769", "code": "\n    public synchronized byte[] readData() {\n        if (byteData.readableBytes() == 0) {\n            return null;\n        }\n        boolean compressed = byteData.readBoolean();\n        int length = byteData.readInt();\n        byte[] bytes = new byte[length];\n        byteData.readBytes(bytes);\n        return bytes;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "10", "src_id": "M1784", "code": "\n                        @Override\n                        public void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(Http2FrameCodecBuilder.forServer().build());\n                            ch.pipeline().addLast(new Http2Handler(grpcDispatcher, grpcExecutorFactory));\n                        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "11", "src_id": "M1752", "code": "\n            @Override\n            public void onCompleted() {\n                ArthasUnittest.ArthasUnittestResponse response = ArthasUnittest.ArthasUnittestResponse.newBuilder()\n                        .setNum(sum.get())\n                        .build();\n                GrpcResponse<ArthasUnittest.ArthasUnittestResponse> grpcResponse = new GrpcResponse<>();\n                grpcResponse.setService(\"arthas.grpc.unittest.ArthasUnittestService\");\n                grpcResponse.setMethod(\"clientStreamSum\");\n                grpcResponse.writeResponseData(response);\n                observer.onNext(grpcResponse);\n                observer.onCompleted();\n            }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "12", "src_id": "M1768", "code": "\n    public void writeData(ByteBuf byteBuf) {\n        byte[] bytes = ByteUtil.getBytes(byteBuf);\n        if (bytes.length == 0) {\n            return;\n        }\n        byte[] decompressedData = decompressGzip(bytes);\n        if (decompressedData == null) {\n            return;\n        }\n        byteData.writeBytes(ByteUtil.newByteBuf(decompressedData));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "13", "src_id": "M1756", "code": "\n    public void loadGrpcService(String grpcServicePackageName) {\n        List<Class<?>> classes = ReflectUtil.findClasses(Optional.ofNullable(grpcServicePackageName).orElse(DEFAULT_GRPC_SERVICE_PACKAGE_NAME));\n        for (Class<?> clazz : classes) {\n            if (clazz.isAnnotationPresent(GrpcService.class)) {\n                try {\n                    GrpcService grpcService = clazz.getAnnotation(GrpcService.class);\n                    Object instance = clazz.getDeclaredConstructor().newInstance();\n                    MethodHandles.Lookup lookup = MethodHandles.lookup();\n                    Method[] declaredMethods = clazz.getDeclaredMethods();\n                    for (Method method : declaredMethods) {\n                        if (method.isAnnotationPresent(GrpcMethod.class)) {\n                            GrpcMethod grpcMethod = method.getAnnotation(GrpcMethod.class);\n                            MethodHandle grpcInvoke = lookup.unreflect(method);\n                            String grpcMethodKey = generateGrpcMethodKey(grpcService.value(), grpcMethod.value());\n                            grpcInvokeTypeMap.put(grpcMethodKey, grpcMethod.grpcType());\n                            grpcInvokeMap.put(grpcMethodKey, grpcInvoke.bindTo(instance));\n\n                            Class<?> requestClass = null;\n                            Class<?> responseClass = null;\n                            if (GrpcInvokeTypeEnum.UNARY.equals(grpcMethod.grpcType())) {\n                                requestClass = grpcInvoke.type().parameterType(1);\n                                responseClass = grpcInvoke.type().returnType();\n                            } else if (GrpcInvokeTypeEnum.CLIENT_STREAM.equals(grpcMethod.grpcType()) || GrpcInvokeTypeEnum.BI_STREAM.equals(grpcMethod.grpcType())) {\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                requestClass = getInnerGenericClass(method.getGenericReturnType());\n                            } else if (GrpcInvokeTypeEnum.SERVER_STREAM.equals(grpcMethod.grpcType())) {\n                                requestClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[1]);\n                            }\n                            MethodHandle requestParseFrom = lookup.findStatic(requestClass, \"parseFrom\", MethodType.methodType(requestClass, byte[].class));\n                            MethodHandle responseParseFrom = lookup.findStatic(responseClass, \"parseFrom\", MethodType.methodType(responseClass, byte[].class));\n                            MethodHandle requestToByteArray = lookup.findVirtual(requestClass, \"toByteArray\", MethodType.methodType(byte[].class));\n                            MethodHandle responseToByteArray = lookup.findVirtual(responseClass, \"toByteArray\", MethodType.methodType(byte[].class));\n                            requestParseFromMap.put(grpcMethodKey, requestParseFrom);\n                            responseParseFromMap.put(grpcMethodKey, responseParseFrom);\n                            requestToByteArrayMap.put(grpcMethodKey, requestToByteArray);\n                            responseToByteArrayMap.put(grpcMethodKey, responseToByteArray);\n                        }\n                    }\n                } catch (Throwable e) {\n                    logger.error(\"GrpcDispatcher loadGrpcService error.\", e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "14", "src_id": "M1105", "code": "\n@Override\npublic void onSuspend(Job job) {\n    if (!job.isRunInBackground()) {\n        resetAndReadLine();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "15", "src_id": "M1106", "code": "\nprivate void resetAndReadLine() {\n    // Reset stdin handler to echo handler\n    // shell.term().stdinHandler(null);\n    shell.setForegroundJob(null);\n    shell.readline();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "16", "src_id": "M504", "code": "\nprivate void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n    for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n        String objectName = entry.getKey();\n        List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n        TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n        table.row(true, \"OBJECT_NAME\", objectName);\n        table.row(true, label(\"NAME\").style(Decoration.bold.bold()), \n                label(\"VALUE\").style(Decoration.bold.bold()));\n\n        for (MBeanAttributeVO attributeVO : attributeVOList) {\n            String attributeName = attributeVO.getName();\n            String valueStr;\n            if (attributeVO.getError() != null) {\n                valueStr = RenderUtil.render(new LabelElement(attributeVO.getError())\n                        .style(Decoration.bold_off.fg(Color.red)));\n            } else {\n                Object value = attributeVO.getValue();\n                if (value instanceof String[]) {\n                    value = Arrays.asList((String[]) value);\n                } else if (value instanceof Integer[]) {\n                    value = Arrays.asList((Integer[]) value);\n                } else if (value instanceof Long[]) {\n                    value = Arrays.asList((Long[]) value);\n                } else if (value instanceof int[]) {\n                    value = convertArrayToList((int[]) value);\n                } else if (value instanceof long[]) {\n                    value = convertArrayToList((long[]) value);\n                }\n                valueStr = String.valueOf(value);\n            }\n            table.row(attributeName, valueStr);\n        }\n        process.write(RenderUtil.render(table, process.width()));\n        process.write(\"\\n\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "17", "src_id": "M1157", "code": "\nprivate HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n    DefaultFullHttpResponse fullResp = null;\n    InputStream in = null;\n    try {\n        URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n        if (res != null) {\n            fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n            in = res.openStream();\n            byte[] tmp = new byte[256];\n            for (int l = 0; l != -1; l = in.read(tmp)) {\n                fullResp.content().writeBytes(tmp, 0, l);\n            }\n            int li = path.lastIndexOf('.');\n            if (li != -1 && li != path.length() - 1) {\n                String ext = path.substring(li + 1);\n                String contentType;\n                if (\"html\".equals(ext)) {\n                    contentType = \"text/html\";\n                } else if (\"js\".equals(ext)) {\n                    contentType = \"application/javascript\";\n                } else if (\"css\".equals(ext)) {\n                    contentType = \"text/css\";\n                } else {\n                    contentType = null;\n                }\n\n                if (contentType != null) {\n                    fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                }\n            }\n        }\n    } finally {\n        IOUtils.close(in);\n    }\n    return fullResp;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "18", "src_id": "M381", "code": "\n@Override\npublic List<ResultModel> pollResults() {\n    try {\n        lastAccessTime = System.currentTimeMillis();\n        long accessTime = lastAccessTime;\n        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n            polling = true;\n            sendingItemCount = 0;\n            long firstResultTime = 0;\n            long sendingDelay = 0;\n            long waitingTime = 0;\n            List<ResultModel> sendingResults = new ArrayList<>(resultBatchSizeLimit);\n\n            while (!closed \n                    && sendingResults.size() < resultBatchSizeLimit \n                    && sendingDelay < 100 \n                    && waitingTime < pollTimeLimit) {\n                ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (aResult != null) {\n                    sendingResults.add(aResult);\n                    if (firstResultTime == 0) {\n                        firstResultTime = System.currentTimeMillis();\n                    }\n                    if (shouldFlush(sendingResults, aResult)) {\n                        break;\n                    }\n                } else {\n                    if (firstResultTime > 0) {\n                        sendingDelay = System.currentTimeMillis() - firstResultTime;\n                    }\n                    waitingTime = System.currentTimeMillis() - accessTime;\n                }\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"pollResults: \" + sendingResults.size() + \", results: \" + JSON.toJSONString(sendingResults));\n            }\n            return sendingResults;\n        }\n    } catch (InterruptedException e) {\n        // Handle interruption\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lastAccessTime = System.currentTimeMillis();\n            polling = false;\n            lock.unlock();\n        }\n    }\n    return Collections.emptyList();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "19", "src_id": "M519", "code": "\n@Override\npublic void draw(CommandProcess process, DashboardModel result) {\n    int width = process.width();\n    int height = process.height();\n\n    int totalHeight = height - 1;\n    int threadTopHeight;\n    if (totalHeight <= 24) {\n        threadTopHeight = totalHeight / 2;\n    } else {\n        threadTopHeight = totalHeight / 3;\n        threadTopHeight = threadTopHeight < 12 ? 12 : threadTopHeight;\n    }\n    int lowerHalf = totalHeight - threadTopHeight;\n\n    int memoryInfoHeight = lowerHalf / 2;\n    if (memoryInfoHeight < 8) {\n        memoryInfoHeight = Math.min(8, lowerHalf);\n    }\n\n    TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n    TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n    int runtimeInfoHeight = Math.max(runtimeInfoTable.getRows().size(), \n            tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size());\n\n    if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n        memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n    } else {\n        runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n    }\n\n    memoryInfoHeight = Math.min(memoryInfoHeight, getMemoryInfoHeight(result.getMemoryInfo()));\n    threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n    String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n    String memoryAndGc = drawMemoryInfoAndGcInfo(result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n    String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n\n    process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "20", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n             .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n             .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n             .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n             .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), \n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), \n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity)))\n             .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)))\n                             .row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()))\n                             .row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)))\n                             .row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "21", "src_id": "M1130", "code": "\nprivate ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n    boolean oneTimeAccess = session.get(ONETIME_SESSION_KEY) != null;\n\n    try {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<>();\n        body.put(\"command\", commandLine);\n\n        ApiResponse response = new ApiResponse()\n                .setSessionId(session.getSessionId())\n                .setBody(body);\n\n        if (!session.tryLock()) {\n            return response.setState(ApiState.REFUSED)\n                           .setMessage(\"Another command is executing.\");\n        }\n\n        int lock = session.getLock();\n        PackingResultDistributor packingResultDistributor = null;\n        Job job = null;\n        try {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                return response.setState(ApiState.REFUSED)\n                               .setMessage(\"Another job is running.\");\n            }\n\n            packingResultDistributor = new PackingResultDistributorImpl(session);\n            job = createJob(commandLine, session, packingResultDistributor);\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n            job.run();\n        } catch (Throwable e) {\n            logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n            return response.setState(ApiState.FAILED)\n                           .setMessage(\"Exec command failed:\" + e.getMessage());\n        } finally {\n            if (session.getLock() == lock) {\n                session.unLock();\n            }\n        }\n\n        Integer timeout = apiRequest.getExecTimeout();\n        timeout = (timeout == null || timeout <= 0) ? DEFAULT_EXEC_TIMEOUT : timeout;\n        boolean timeExpired = !waitForJob(job, timeout);\n\n        if (timeExpired) {\n            job.interrupt();\n            response.setState(ApiState.INTERRUPTED)\n                   .setMessage(\"The job is exceeded time limit, force interrupt\");\n        } else {\n            response.setState(ApiState.SUCCEEDED);\n        }\n\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        body.put(\"timeExpired\", timeExpired);\n        if (timeExpired) {\n            body.put(\"timeout\", timeout);\n        }\n        body.put(\"results\", packingResultDistributor.getResults());\n\n        return response.setSessionId(session.getSessionId())\n                      .setBody(body);\n    } finally {\n        if (oneTimeAccess) {\n            sessionManager.removeSession(session.getSessionId());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "22", "src_id": "M494", "code": "\nprivate void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n    callback.callback(deep, isLast, prefix, node);\n    if (!isLeaf(node)) {\n        List<TraceNode> children = node.getChildren();\n        if (children == null) return;\n\n        int size = children.size();\n        for (int index = 0; index < size; index++) {\n            boolean isLastFlag = index == size - 1;\n            String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n            recursive(\n                deep + 1,\n                isLastFlag,\n                currentPrefix,\n                children.get(index),\n                callback\n            );\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "23", "src_id": "M474", "code": "\nprivate static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n    if (parentClassLoader.getChildren() == null) return;\n    \n    for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n        TreeElement child = new TreeElement(childClassLoader.getName());\n        parent.addChild(child);\n        renderSubtree(child, childClassLoader);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "24", "src_id": "M604", "code": "\nprivate String outputFileExt() {\n    if (this.format == null) {\n        return \"html\";\n    } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n            || this.format.equals(\"collapsed\")) {\n        return \"txt\";\n    } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n        return \"html\";\n    } else if (this.format.equals(\"jfr\")) {\n        return \"jfr\";\n    } else {\n        // illegal -o option makes async-profiler use flat\n        return \"txt\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "25", "src_id": "M579", "code": "\n@Option(longName = \"lock\")\n@Description(\"lock profiling threshold in nanoseconds\")\npublic void setLock(String lock) {\n    this.lock = lock;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "26", "src_id": "M585", "code": "\n@Option(longName = \"cstack\")\n@Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\npublic void setCstack(String cstack) {\n    this.cstack = cstack;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "27", "src_id": "M601", "code": "\n@Option(longName = \"timeout\")\n@Description(\"automatically stop profiler at TIME (absolute or relative)\")\npublic void setTimeout(String timeout) {\n    this.timeout = timeout;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "28", "src_id": "M592", "code": "\n@Option(longName = \"end\")\n@Description(\"automatically stop profiling when the specified native function is executed\")\npublic void setEnd(String end) {\n    this.end = end;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "29", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        if (this.format == null) {\n            return \"html\";\n        }\n        if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n                || this.format.equals(\"collapsed\")) {\n            return \"txt\";\n        }\n        if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n            return \"html\";\n        }\n        if (this.format.equals(\"jfr\")) {\n            return \"jfr\";\n        }\n        // Illegal -o option defaults to txt\n        return \"txt\";\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "30", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "31", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "32", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "33", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "34", "src_id": "M604", "code": "\nprivate String outputFileExt() {\n    String fileExt;\n    if (this.format == null) {\n        fileExt = \"html\";\n    } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n                || this.format.equals(\"collapsed\")) {\n        fileExt = \"txt\";\n    } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n        fileExt = \"html\";\n    } else if (this.format.equals(\"jfr\")) {\n        fileExt = \"jfr\";\n    } else {\n        // illegal -o option makes async-profiler use flat\n        fileExt = \"txt\";\n    }\n    return fileExt;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "35", "src_id": "M579", "code": "\n@Option(longName = \"lock\")\n@Description(\"lock profiling threshold in nanoseconds\")\npublic void setLock(String lock) {\n    this.lock = lock;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "36", "src_id": "M585", "code": "\n@Option(longName = \"cstack\")\n@Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\npublic void setCstack(String cstack) {\n    this.cstack = cstack;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "37", "src_id": "M601", "code": "\n@Option(longName = \"timeout\")\n@Description(\"automatically stop profiler at TIME (absolute or relative)\")\npublic void setTimeout(String timeout) {\n    this.timeout = timeout;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "38", "src_id": "M592", "code": "\n@Option(longName = \"end\")\n@Description(\"automatically stop profiling when the specified native function is executed\")\npublic void setEnd(String end) {\n    this.end = end;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "39", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        if (this.format == null) {\n            return \"html\";\n        }\n        if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n                || this.format.equals(\"collapsed\")) {\n            return \"txt\";\n        }\n        if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n            return \"html\";\n        }\n        if (this.format.equals(\"jfr\")) {\n            return \"jfr\";\n        }\n        // illegal -o option makes async-profiler use flat\n        return \"txt\";\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "40", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "41", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "42", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "43", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "60", "src_id": "M1751", "code": "\n    @Override\n    public void onNext(GrpcRequest<ArthasUnittest.ArthasUnittestRequest> req) {\n        try {\n            byte[] bytes = req.readData();\n            while (bytes != null && bytes.length != 0) {\n                ArthasUnittest.ArthasUnittestRequest request = ArthasUnittest.ArthasUnittestRequest.parseFrom(bytes);\n                sum.addAndGet(request.getNum());\n                bytes = req.readData();\n            }\n        } catch (InvalidProtocolBufferException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "61", "src_id": "M1772", "code": "\n    public void writeResponseData(Object response) {\n        byte[] encode = null;\n        try {\n            if (ArthasGrpc.ErrorRes.class.equals(clazz)) {\n                encode = ((ArthasGrpc.ErrorRes) response).toByteArray();\n            } else {\n                encode = (byte[]) GrpcDispatcher.responseToByteArrayMap\n                        .get(GrpcDispatcher.generateGrpcMethodKey(service, method))\n                        .invoke(response);\n            }\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n        this.byteData = ByteUtil.newByteBuf();\n        this.byteData.writeBoolean(false);\n        this.byteData.writeInt(encode.length);\n        this.byteData.writeBytes(encode);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "62", "src_id": "M1766", "code": "\n    private void handleResetStream(Http2ResetFrame resetFrame, ChannelHandlerContext ctx) {\n        int id = resetFrame.stream().id();\n        System.out.println(\"handleResetStream\");\n        dataBuffer.remove(id);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "63", "src_id": "M1769", "code": "\n    public synchronized byte[] readData() {\n        if (byteData.readableBytes() == 0) {\n            return null;\n        }\n        boolean compressed = byteData.readBoolean();\n        int length = byteData.readInt();\n        byte[] bytes = new byte[length];\n        byteData.readBytes(bytes);\n        return bytes;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "64", "src_id": "M1784", "code": "\n    @Override\n    public void initChannel(SocketChannel ch) {\n        ch.pipeline().addLast(Http2FrameCodecBuilder.forServer().build());\n        ch.pipeline().addLast(new Http2Handler(grpcDispatcher, grpcExecutorFactory));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "65", "src_id": "M1752", "code": "\n    @Override\n    public void onCompleted() {\n        ArthasUnittest.ArthasUnittestResponse response = ArthasUnittest.ArthasUnittestResponse.newBuilder()\n                .setNum(sum.get())\n                .build();\n        GrpcResponse<ArthasUnittest.ArthasUnittestResponse> grpcResponse = new GrpcResponse<>();\n        grpcResponse.setService(\"arthas.grpc.unittest.ArthasUnittestService\");\n        grpcResponse.setMethod(\"clientStreamSum\");\n        grpcResponse.writeResponseData(response);\n        observer.onNext(grpcResponse);\n        observer.onCompleted();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "66", "src_id": "M1768", "code": "\n    public void writeData(ByteBuf byteBuf) {\n        byte[] bytes = ByteUtil.getBytes(byteBuf);\n        if (bytes.length == 0) {\n            return;\n        }\n        byte[] decompressedData = decompressGzip(bytes);\n        if (decompressedData == null) {\n            return;\n        }\n        byteData.writeBytes(ByteUtil.newByteBuf(decompressedData));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "67", "src_id": "M1756", "code": "\n    public void loadGrpcService(String grpcServicePackageName) {\n        List<Class<?>> classes = ReflectUtil.findClasses(\n                Optional.ofNullable(grpcServicePackageName).orElse(DEFAULT_GRPC_SERVICE_PACKAGE_NAME));\n        for (Class<?> clazz : classes) {\n            if (clazz.isAnnotationPresent(GrpcService.class)) {\n                try {\n                    GrpcService grpcService = clazz.getAnnotation(GrpcService.class);\n                    Object instance = clazz.getDeclaredConstructor().newInstance();\n                    MethodHandles.Lookup lookup = MethodHandles.lookup();\n                    Method[] declaredMethods = clazz.getDeclaredMethods();\n                    for (Method method : declaredMethods) {\n                        if (method.isAnnotationPresent(GrpcMethod.class)) {\n                            GrpcMethod grpcMethod = method.getAnnotation(GrpcMethod.class);\n                            MethodHandle grpcInvoke = lookup.unreflect(method);\n                            String grpcMethodKey = generateGrpcMethodKey(\n                                    grpcService.value(), grpcMethod.value());\n                            grpcInvokeTypeMap.put(grpcMethodKey, grpcMethod.grpcType());\n                            grpcInvokeMap.put(grpcMethodKey, grpcInvoke.bindTo(instance));\n\n                            Class<?> requestClass = null;\n                            Class<?> responseClass = null;\n                            if (GrpcInvokeTypeEnum.UNARY.equals(grpcMethod.grpcType())) {\n                                requestClass = grpcInvoke.type().parameterType(1);\n                                responseClass = grpcInvoke.type().returnType();\n                            } else if (GrpcInvokeTypeEnum.CLIENT_STREAM.equals(grpcMethod.grpcType())\n                                    || GrpcInvokeTypeEnum.BI_STREAM.equals(grpcMethod.grpcType())) {\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                requestClass = getInnerGenericClass(method.getGenericReturnType());\n                            } else if (GrpcInvokeTypeEnum.SERVER_STREAM.equals(grpcMethod.grpcType())) {\n                                requestClass = getInnerGenericClass(method.getGenericParameterTypes()[0]);\n                                responseClass = getInnerGenericClass(method.getGenericParameterTypes()[1]);\n                            }\n                            MethodHandle requestParseFrom = lookup.findStatic(\n                                    requestClass, \"parseFrom\", MethodType.methodType(requestClass, byte[].class));\n                            MethodHandle responseParseFrom = lookup.findStatic(\n                                    responseClass, \"parseFrom\", MethodType.methodType(responseClass, byte[].class));\n                            MethodHandle requestToByteArray = lookup.findVirtual(\n                                    requestClass, \"toByteArray\", MethodType.methodType(byte[].class));\n                            MethodHandle responseToByteArray = lookup.findVirtual(\n                                    responseClass, \"toByteArray\", MethodType.methodType(byte[].class));\n\n                            requestParseFromMap.put(grpcMethodKey, requestParseFrom);\n                            responseParseFromMap.put(grpcMethodKey, responseParseFrom);\n                            requestToByteArrayMap.put(grpcMethodKey, requestToByteArray);\n                            responseToByteArrayMap.put(grpcMethodKey, responseToByteArray);\n                        }\n                    }\n                } catch (Throwable e) {\n                    logger.error(\"GrpcDispatcher loadGrpcService error.\", e);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "68", "src_id": "M308", "code": "\n        HashEntry<K, V> nextEntry() {\n            do {\n                if (nextEntry == null) {\n                    throw new NoSuchElementException();\n                }\n\n                lastReturned = nextEntry;\n                currentKey = lastReturned.key();\n                advance();\n            } while (currentKey == null); // Skip GC'd keys\n\n            return lastReturned;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "69", "src_id": "M1284", "code": "\n        @AtInvoke(name = \"\", inline = true, whenComplete = false, excludes = \"java.**\")\n        public static void onInvoke(@Binding.This Object target, @Binding.Class Class<?> clazz,\n                @Binding.InvokeInfo String invokeInfo) {\n            SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "70", "src_id": "M947", "code": "\n    public void loggers(CommandProcess process) {\n        Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<>();\n\n        for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n            String className = clazz.getName();\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) {\n                continue;\n            }\n\n            if (classLoader != null) {\n                LoggerTypes loggerTypes = classLoaderLoggerMap.get(classLoader);\n                if (loggerTypes == null) {\n                    loggerTypes = new LoggerTypes();\n                    classLoaderLoggerMap.put(classLoader, loggerTypes);\n                }\n                updateLoggerType(loggerTypes, classLoader, className);\n            }\n        }\n\n        for (Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n            ClassLoader classLoader = entry.getKey();\n            LoggerTypes loggerTypes = entry.getValue();\n\n            if (loggerTypes.contains(LoggerType.LOG4J)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4jHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n            if (loggerTypes.contains(LoggerType.LOGBACK)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, LogbackHelper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n            if (loggerTypes.contains(LoggerType.LOG4J2)) {\n                Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4j2Helper.class);\n                process.appendResult(new LoggerModel(loggerInfoMap));\n            }\n        }\n\n        process.end();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "71", "src_id": "M249", "code": "\n    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) throws URISyntaxException {\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n\n        String appName = null;\n        List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n        if (appNameList != null && !appNameList.isEmpty()) {\n            appName = appNameList.get(0);\n        }\n\n        String id = null;\n        if (appName != null) {\n            id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n        } else {\n            id = RandomStringUtils.random(20, true, true).toUpperCase();\n        }\n\n        List<String> idList = parameters.get(URIConstans.ID);\n        if (idList != null && !idList.isEmpty()) {\n            id = idList.get(0);\n        }\n\n        String arthasVersion = null;\n        List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n        if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n            arthasVersion = arthasVersionList.get(0);\n        }\n\n        final String finalId = id;\n\n        URI responseUri = UriComponentsBuilder.newInstance()\n                .scheme(URIConstans.RESPONSE)\n                .path(\"/\")\n                .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n                .queryParam(URIConstans.ID, id)\n                .build()\n                .encode()\n                .toUri();\n\n        AgentInfo info = new AgentInfo();\n        HttpHeaders headers = handshake.requestHeaders();\n        String host = HttpUtils.findClientIP(headers);\n\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n                info.setHost(inetSocketAddress.getHostString());\n                info.setPort(inetSocketAddress.getPort());\n            }\n        } else {\n            info.setHost(host);\n            Integer port = HttpUtils.findClientPort(headers);\n            if (port != null) {\n                info.setPort(port);\n            }\n        }\n\n        info.setChannelHandlerContext(ctx);\n        if (arthasVersion != null) {\n            info.setArthasVersion(arthasVersion);\n        }\n\n        tunnelServer.addAgent(id, info);\n        ctx.channel().closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {\n            @Override\n            public void operationComplete(Future<? super Void> future) throws Exception {\n                tunnelServer.removeAgent(finalId);\n            }\n        });\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "72", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect) throws SSLException, URISyntaxException, InterruptedException {\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER);\n        queryEncoder.addParam(URIConstans.ARTHAS_VERSION, this.version);\n        if (appName != null) {\n            queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        }\n        if (id != null) {\n            queryEncoder.addParam(URIConstans.ID, id);\n        }\n\n        final URI agentRegisterURI = queryEncoder.toUri();\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = agentRegisterURI.getScheme() == null ? \"ws\" : agentRegisterURI.getScheme();\n        final String host = agentRegisterURI.getHost() == null ? \"127.0.0.1\" : agentRegisterURI.getHost();\n        final int port;\n        if (agentRegisterURI.getPort() == -1) {\n            port = \"ws\".equalsIgnoreCase(scheme) ? 80 : 443;\n        } else {\n            port = agentRegisterURI.getPort();\n        }\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n        }\n\n        final SslContext sslCtx = \"wss\".equalsIgnoreCase(scheme)\n                ? SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build()\n                : null;\n\n        WebSocketClientProtocolConfig clientProtocolConfig = WebSocketClientProtocolConfig.newBuilder()\n                .webSocketUri(agentRegisterURI)\n                .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH)\n                .build();\n\n        WebSocketClientProtocolHandler websocketClientHandler = new WebSocketClientProtocolHandler(clientProtocolConfig);\n        TunnelClientSocketClientHandler handler = new TunnelClientSocketClientHandler(TunnelClient.this);\n\n        Bootstrap bs = new Bootstrap();\n        bs.group(eventLoopGroup)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n                .option(ChannelOption.TCP_NODELAY, true)\n                .channel(NioSocketChannel.class)\n                .remoteAddress(host, port)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ChannelPipeline p = ch.pipeline();\n                        if (sslCtx != null) {\n                            p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                        }\n                        p.addLast(\n                            new HttpClientCodec(),\n                            new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                            websocketClientHandler,\n                            new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                            handler\n                        );\n                    }\n                });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.cause() != null) {\n                        logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n                    }\n                }\n            });\n        }\n        connectFuture.sync();\n\n        return handler.registerFuture();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "73", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[] {\n            0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65,\n            // ... (remaining byte array elements remain unchanged)\n        };\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "74", "src_id": "M124", "code": "\n    @Override\n    public int read() throws IOException {\n        synchronized (__queue) {\n            while (true) {\n                if (__ioException != null) {\n                    IOException e = __ioException;\n                    __ioException = null;\n                    throw e;\n                }\n\n                if (__bytesAvailable == 0) {\n                    if (__hasReachedEOF) {\n                        return EOF;\n                    }\n\n                    if (__threaded) {\n                        __queue.notify();\n                        try {\n                            __readIsWaiting = true;\n                            __queue.wait();\n                            __readIsWaiting = false;\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                        }\n                    } else {\n                        __readIsWaiting = true;\n                        int ch;\n                        boolean mayBlock = true;\n\n                        do {\n                            try {\n                                if ((ch = __read(mayBlock)) < 0) {\n                                    if (ch != WOULD_BLOCK) {\n                                        return ch;\n                                    }\n                                }\n                            } catch (InterruptedIOException e) {\n                                synchronized (__queue) {\n                                    __ioException = e;\n                                    __queue.notifyAll();\n                                    try {\n                                        __queue.wait(100);\n                                    } catch (InterruptedException interrupted) {\n                                    }\n                                }\n                                return EOF;\n                            }\n\n                            try {\n                                if (ch != WOULD_BLOCK) {\n                                    __processChar(ch);\n                                }\n                            } catch (InterruptedException e) {\n                                if (__isClosed) {\n                                    return EOF;\n                                }\n                            }\n                            mayBlock = false;\n                        } while (super.available() > 0 && __bytesAvailable < __queue.length - 1);\n\n                        __readIsWaiting = false;\n                    }\n                    continue;\n                } else {\n                    int ch = __queue[__queueHead];\n                    if (++__queueHead >= __queue.length) {\n                        __queueHead = 0;\n                    }\n\n                    --__bytesAvailable;\n                    if (__bytesAvailable == 0 && __threaded) {\n                        __queue.notify();\n                    }\n\n                    return ch;\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "75", "src_id": "M786", "code": "\n    @Override\n    public void process(CommandProcess process) {\n        initTransformer();\n        RetransformModel retransformModel = new RetransformModel();\n        Instrumentation inst = process.session().getInstrumentation();\n\n        if (this.list) {\n            retransformModel.setRetransformEntries(allRetransformEntries());\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        }\n\n        if (this.deleteAll) {\n            deleteAllRetransformEntry();\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        }\n\n        if (this.delete > 0) {\n            deleteRetransformEntry(this.delete);\n            process.end();\n            return;\n        }\n\n        if (this.classPattern != null) {\n            Set<Class<?>> searchClass = SearchUtils.searchClass(inst, classPattern, false, this.hashCode);\n            if (searchClass.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + classPattern);\n                return;\n            }\n\n            if (searchClass.size() > limit) {\n                process.end(-1, \"match classes size: \" + searchClass.size() + \", more than limit: \" + limit\n                        + \", use more precise class pattern\");\n                return;\n            }\n\n            try {\n                inst.retransformClasses(searchClass.toArray(new Class[0]));\n                searchClass.forEach(clazz -> retransformModel.addRetransformClass(clazz.getName()));\n                process.appendResult(retransformModel);\n                process.end();\n            } catch (Throwable e) {\n                String message = \"retransform error! \" + e;\n                logger.error(message, e);\n                process.end(-1, message);\n            }\n            return;\n        }\n\n        Map<String, byte[]> bytesMap = new HashMap<>();\n        for (String path : paths) {\n            File file = new File(path);\n            if (!validateFile(process, file)) return;\n\n            try (RandomAccessFile f = new RandomAccessFile(path, \"r\")) {\n                byte[] bytes = new byte[(int) f.length()];\n                f.readFully(bytes);\n                bytesMap.put(readClassName(bytes), bytes);\n            } catch (Exception e) {\n                logger.warn(\"load class file failed: {}\", path, e);\n                process.end(-1, \"load class file failed: \" + path + \", error: \" + e);\n                return;\n            }\n        }\n\n        if (bytesMap.size() != paths.size()) {\n            process.end(-1, \"paths contain duplicate class names\");\n            return;\n        }\n\n        List<RetransformEntry> retransformEntryList = new ArrayList<>();\n        List<Class<?>> classList = new ArrayList<>();\n\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (bytesMap.containsKey(clazz.getName())) {\n                handleClassLoaderMatching(process, retransformModel, clazz);\n                \n                ClassLoader classLoader = clazz.getClassLoader();\n                if (classLoader != null && hashCode != null\n                        && !Integer.toHexString(classLoader.hashCode()).equals(hashCode)) {\n                    continue;\n                }\n\n                retransformEntryList.add(new RetransformEntry(\n                    clazz.getName(),\n                    bytesMap.get(clazz.getName()),\n                    hashCode,\n                    classLoaderClass\n                ));\n                classList.add(clazz);\n                retransformModel.addRetransformClass(clazz.getName());\n                logger.info(\"Retransform class: {}, ClassLoader: {}\", clazz.getName(), clazz.getClassLoader());\n            }\n        }\n\n        try {\n            if (retransformEntryList.isEmpty()) {\n                process.end(-1, \"Classes not loaded: \" + bytesMap.keySet());\n                return;\n            }\n            addRetransformEntry(retransformEntryList);\n            inst.retransformClasses(classList.toArray(new Class[0]));\n            process.appendResult(retransformModel);\n            process.end();\n        } catch (Throwable e) {\n            String message = \"retransform error! \" + e;\n            logger.error(message, e);\n            process.end(-1, message);\n        }\n    }\n\n    private boolean validateFile(CommandProcess process, File file) {\n        if (!file.exists()) {\n            process.end(-1, \"file does not exist: \" + file.getPath());\n            return false;\n        }\n        if (!file.isFile()) {\n            process.end(-1, \"not a file: \" + file.getPath());\n            return false;\n        }\n        if (file.length() >= MAX_FILE_SIZE) {\n            process.end(-1, \"file too large: \" + file.getPath());\n            return false;\n        }\n        return true;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "76", "src_id": "M278", "code": "\n        V get(Object key, int hash) {\n            if (count != 0) { // read-volatile\n                HashEntry<K, V> e = getFirst(hash);\n                while (e != null) {\n                    if (e.hash == hash && keyEq(key, e.key())) {\n                        Object opaque = e.valueRef;\n                        if (opaque != null) {\n                            return e.dereferenceValue(opaque);\n                        }\n                        return readValueUnderLock(e);\n                    }\n                    e = e.next;\n                }\n            }\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "77", "src_id": "M184", "code": "\n                @Override\n                protected void initChannel(LocalChannel ch) {\n                    ChannelPipeline p = ch.pipeline();\n                    p.addLast(\n                        new HttpClientCodec(),\n                        new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                        new HttpProxyClientHandler(httpResponsePromise)\n                    );\n                }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "78", "src_id": "M1671", "code": "\npublic void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n    if (frame instanceof CloseWebSocketFrame) {\n        closeOutboundChannel(ctx.channel());\n        ctx.close();\n        return;\n    }\n\n    Channel outboundChannel = channelMappings.get(ctx.channel());\n    if (outboundChannel == null || !outboundChannel.isActive()) {\n        connectToDestinationServer(ctx, frame);\n    } else {\n        forwardWebSocketFrame(frame, outboundChannel);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "79", "src_id": "M1691", "code": "\n@Override\npublic void onError(Throwable t) {\n    logger().error(\"keep alive error\", t);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "80", "src_id": "M1656", "code": "\n@Override\npublic Map<String, String> findNativeAgent(String address) {\n    if (address == null || address.isEmpty()) {\n        return null;\n    }\n\n    try {\n        ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n            if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                connectedSemaphore.countDown();\n            }\n        });\n        connectedSemaphore.await();\n\n        List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n        Map<String, String> result = new ConcurrentHashMap<>(children.size());\n\n        for (String child : children) {\n            String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n            byte[] data = zooKeeper.getData(childPath, false, new Stat());\n            result.put(child, new String(data));\n        }\n\n        zooKeeper.close();\n        return result;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "81", "src_id": "M1668", "code": "\nprivate FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n    OkHttpClient client = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .build();\n\n    RequestBody body = RequestBody.create(\n        request.content().toString(CharsetUtil.UTF_8),\n        MediaType.parse(\"application/json; charset=utf-8\")\n    );\n\n    Request okRequest = new Request.Builder()\n        .url(\"http://\" + address + \"/api/native-agent\")\n        .post(body)\n        .build();\n\n    try {\n        Response response = client.newCall(okRequest).execute();\n\n        if (response.isSuccessful()) {\n            DefaultFullHttpResponse httpResponse = new DefaultFullHttpResponse(\n                request.getProtocolVersion(),\n                HttpResponseStatus.OK,\n                Unpooled.copiedBuffer(response.body().string(), StandardCharsets.UTF_8)\n            );\n\n            httpResponse.headers()\n                .set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\")\n                .set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\")\n                .set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\")\n                .set(HttpHeaderNames.CONTENT_TYPE, \"application/json\")\n                .set(HttpHeaderNames.CONTENT_LENGTH, httpResponse.content().readableBytes());\n\n            return httpResponse;\n        } else {\n            return new DefaultFullHttpResponse(\n                HttpVersion.HTTP_1_1,\n                HttpResponseStatus.valueOf(response.code()),\n                Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n            );\n        }\n    } catch (IOException e) {\n        logger().error(\"Error forwarding request\", e);\n        return new DefaultFullHttpResponse(\n            HttpVersion.HTTP_1_1,\n            HttpResponseStatus.INTERNAL_SERVER_ERROR,\n            Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "82", "src_id": "M1714", "code": "\npublic static void main(String[] args) {\n    WelcomeUtil.printNativeAgentWelcomeMsg();\n\n    logger().info(\"check arthas file path...\");\n    ArthasHomeHandler.findArthasHome();\n    logger().info(\"check arthas file path success\");\n\n    NativeAgentBootstrap bootstrap = new NativeAgentBootstrap();\n    CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n    CommandLine commandLine = cli.parse(Arrays.asList(args));\n    \n    try {\n        CLIConfigurator.inject(commandLine, bootstrap);\n    } catch (Throwable e) {\n        logger().error(\"Missing startup parameter\", e);\n        System.out.println(usage(cli));\n        System.exit(1);\n    }\n    logger().info(\"read input config success\");\n\n    try {\n        logger().info(\"register native agent...\");\n        NativeAgentRegistry registry = NativeAgentRegistryFactory\n            .getNativeAgentClientRegisterFactory()\n            .getServiceRegistration(bootstrap.getRegistrationType());\n        registry.registerNativeAgent(\n            bootstrap.getRegistrationAddress(),\n            bootstrap.getIp(),\n            bootstrap.getHttpPortOrDefault() + \":\" + bootstrap.getWsPortOrDefault()\n        );\n        logger().info(\"register native agent success!\");\n    } catch (Exception e) {\n        logger().error(\"register native agent failed\", e);\n        System.exit(1);\n    }\n\n    int wsPort = bootstrap.getWsPortOrDefault();\n    Thread wsServerThread = new Thread(() -> {\n        logger().info(\"start websocket server on port: {}\", wsPort);\n        try {\n            EventLoopGroup bossGroup = new NioEventLoopGroup();\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n            \n            try {\n                ServerBootstrap b = new ServerBootstrap()\n                    .group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline()\n                                .addLast(new HttpRequestDecoder())\n                                .addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH))\n                                .addLast(new HttpResponseEncoder())\n                                .addLast(new WebSocketServerProtocolHandler(\"/ws\"))\n                                .addLast(new ForwardClientSocketClientHandler());\n                        }\n                    });\n                \n                b.bind(\"0.0.0.0\", wsPort).sync().channel().closeFuture().sync();\n                logger().info(\"websocket server started on port: {}\", wsPort);\n            } finally {\n                bossGroup.shutdownGracefully();\n                workerGroup.shutdownGracefully();\n                logger().info(\"websocket server shutdown on port: {}\", wsPort);\n            }\n        } catch (InterruptedException e) {\n            logger().error(\"websocket server interrupted on port: {}\", wsPort, e);\n            Thread.currentThread().interrupt();\n        }\n    }, \"native-agent-ws-server\");\n    wsServerThread.start();\n\n    int httpPort = bootstrap.getHttpPortOrDefault();\n    logger().info(\"start http server on port: {}\", httpPort);\n    \n    EventLoopGroup httpBossGroup = new NioEventLoopGroup();\n    EventLoopGroup httpWorkerGroup = new NioEventLoopGroup();\n    \n    try {\n        ServerBootstrap b = new ServerBootstrap()\n            .group(httpBossGroup, httpWorkerGroup)\n            .channel(NioServerSocketChannel.class)\n            .handler(new LoggingHandler(LogLevel.INFO))\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) {\n                    ch.pipeline()\n                        .addLast(new HttpServerCodec())\n                        .addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH))\n                        .addLast(new HttpRequestHandler());\n                }\n            });\n        \n        b.bind(\"0.0.0.0\", httpPort).sync().channel().closeFuture().sync();\n        logger().info(\"http server started on port: {}\", httpPort);\n    } catch (Exception e) {\n        logger().error(\"failed to start http server on port: {}\", httpPort, e);\n    } finally {\n        httpBossGroup.shutdownGracefully();\n        httpWorkerGroup.shutdownGracefully();\n        logger().info(\"http server shutdown\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "83", "src_id": "M1677", "code": "\nprivate Map<String, String> parseQueryString(String query) {\n    Map<String, String> params = new HashMap<>();\n    if (query != null) {\n        for (String pair : query.split(\"&\")) {\n            int idx = pair.indexOf(\"=\");\n            try {\n                String key = URLDecoder.decode(pair.substring(0, idx), StandardCharsets.UTF_8.name());\n                String value = URLDecoder.decode(pair.substring(idx + 1), StandardCharsets.UTF_8.name());\n                params.put(key, value);\n            } catch (UnsupportedEncodingException e) {\n                // ignored\n            }\n        }\n    }\n    return params;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "84", "src_id": "M1675", "code": "\nprivate void closeOutboundChannel(Channel inboundChannel) {\n    Channel outboundChannel = channelMappings.remove(inboundChannel);\n    if (outboundChannel != null) {\n        logger().info(\"Closing outbound channel\");\n        outboundChannel.close();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "85", "src_id": "M1738", "code": "\nprivate ByteBuf readInputStream(InputStream is) throws IOException {\n    ByteBuf buffer = Unpooled.buffer();\n    byte[] tmp = new byte[1024];\n    int length;\n    while ((length = is.read(tmp)) != -1) {\n        buffer.writeBytes(tmp, 0, length);\n    }\n    is.close();\n    return buffer;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "86", "src_id": "M1665", "code": "\n@Override\nprotected void initChannel(SocketChannel ch) {\n    ch.pipeline()\n        .addLast(new HttpServerCodec())\n        .addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH))\n        .addLast(new RequestHandler())\n        .addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "87", "src_id": "M1661", "code": "\n@Option(longName = \"agent-registration-type\", required = true)\n@Description(\"agent registration type\")\npublic void setAgentRegistrationType(String agentRegistrationType) {\n    this.agentRegistrationType = agentRegistrationType;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "88", "src_id": "M604", "code": "\nprivate String outputFileExt() {\n    if (this.format == null) {\n        return \"html\";\n    } else if (this.format.startsWith(\"flat\") || this.format.startsWith(\"traces\") \n                || this.format.equals(\"collapsed\")) {\n        return \"txt\";\n    } else if (this.format.equals(\"flamegraph\") || this.format.equals(\"tree\")) {\n        return \"html\";\n    } else if (this.format.equals(\"jfr\")) {\n        return \"jfr\";\n    } else {\n        // Fallback to txt for illegal -o option\n        return \"txt\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "89", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "90", "src_id": "M585", "code": "\n    @Option(longName = \"cstack\")\n    @Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\n    public void setCstack(String cstack) {\n        this.cstack = cstack;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "91", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "92", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "93", "src_id": "M1105", "code": "\n@Override\npublic void onSuspend(Job job) {\n    if (!job.isRunInBackground()) {\n        resetAndReadLine();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "94", "src_id": "M1106", "code": "\nprivate void resetAndReadLine() {\n    //reset stdin handler to echo handler\n    //shell.term().stdinHandler(null);\n    shell.setForegroundJob(null);\n    shell.readline();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "95", "src_id": "M504", "code": "\nprivate void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n    for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n        final String objectName = entry.getKey();\n        final List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n        final TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n        table.row(true, \"OBJECT_NAME\", objectName);\n        table.row(true, label(\"NAME\").style(Decoration.bold.bold()), \n                 label(\"VALUE\").style(Decoration.bold.bold()));\n\n        for (final MBeanAttributeVO attributeVO : attributeVOList) {\n            final String attributeName = attributeVO.getName();\n            final String valueStr;\n            if (attributeVO.getError() != null) {\n                valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n            } else {\n                Object value = attributeVO.getValue();\n                if (value instanceof String[]) {\n                    value = Arrays.asList((String[]) value);\n                } else if (value instanceof Integer[]) {\n                    value = Arrays.asList((Integer[]) value);\n                } else if (value instanceof Long[]) {\n                    value = Arrays.asList((Long[]) value);\n                } else if (value instanceof int[]) {\n                    value = convertArrayToList((int[]) value);\n                } else if (value instanceof long[]) {\n                    value = convertArrayToList((long[]) value);\n                }\n                valueStr = String.valueOf(value);\n            }\n            table.row(attributeName, valueStr);\n        }\n        process.write(RenderUtil.render(table, process.width()));\n        process.write(\"\\n\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "96", "src_id": "M1157", "code": "\nprivate HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n    DefaultFullHttpResponse fullResp = null;\n    final URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n    if (res != null) {\n        fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n        try (InputStream in = res.openStream()) {\n            final byte[] tmp = new byte[256];\n            int l;\n            while ((l = in.read(tmp)) != -1) {\n                fullResp.content().writeBytes(tmp, 0, l);\n            }\n        }\n        final int li = path.lastIndexOf('.');\n        if (li != -1 && li != path.length() - 1) {\n            final String ext = path.substring(li + 1);\n            final String contentType;\n            if (\"html\".equals(ext)) {\n                contentType = \"text/html\";\n            } else if (\"js\".equals(ext)) {\n                contentType = \"application/javascript\";\n            } else if (\"css\".equals(ext)) {\n                contentType = \"text/css\";\n            } else {\n                contentType = null;\n            }\n            if (contentType != null) {\n                fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n            }\n        }\n    }\n    return fullResp;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "97", "src_id": "M381", "code": "\n@Override\npublic List<ResultModel> pollResults() {\n    try {\n        lastAccessTime = System.currentTimeMillis();\n        final long accessTime = lastAccessTime;\n        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n            polling = true;\n            sendingItemCount = 0;\n            long firstResultTime = 0;\n            long sendingDelay = 0;\n            long waitingTime = 0;\n            final List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n            while (!closed && sendingResults.size() < resultBatchSizeLimit && \n                   sendingDelay < 100 && waitingTime < pollTimeLimit) {\n                final ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (aResult != null) {\n                    sendingResults.add(aResult);\n                    if (firstResultTime == 0) {\n                        firstResultTime = System.currentTimeMillis();\n                    }\n                    if (shouldFlush(sendingResults, aResult)) {\n                        break;\n                    }\n                } else {\n                    if (firstResultTime > 0) {\n                        sendingDelay = System.currentTimeMillis() - firstResultTime;\n                    }\n                    waitingTime = System.currentTimeMillis() - accessTime;\n                }\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n            }\n            return sendingResults;\n        }\n    } catch (InterruptedException e) {\n        //e.printStackTrace();\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lastAccessTime = System.currentTimeMillis();\n            polling = false;\n            lock.unlock();\n        }\n    }\n    return Collections.emptyList();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "98", "src_id": "M519", "code": "\n@Override\npublic void draw(CommandProcess process, DashboardModel result) {\n    final int width = process.width();\n    final int height = process.height();\n    final int totalHeight = height - 1;\n    int threadTopHeight;\n    if (totalHeight <= 24) {\n        threadTopHeight = totalHeight / 2;\n    } else {\n        threadTopHeight = totalHeight / 3;\n        if (threadTopHeight < 12) {\n            threadTopHeight = 12;\n        }\n    }\n    final int lowerHalf = totalHeight - threadTopHeight;\n    int memoryInfoHeight = lowerHalf / 2;\n    if (memoryInfoHeight < 8) {\n        memoryInfoHeight = Math.min(8, lowerHalf);\n    }\n    final TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n    final TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n    int runtimeInfoHeight = Math.max(runtimeInfoTable.getRows().size(), \n                                    tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size());\n    if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n        memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n    } else {\n        runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n    }\n    final int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n    memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n    threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n    final String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n    final String memoryAndGc = drawMemoryInfoAndGcInfo(result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n    final String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n    process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "99", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    final StringBuilder sb = new StringBuilder(8192);\n    for (final Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        final Map<String, Object> info = entry.getValue();\n        final TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        final TableElement appendersTable = new TableElement().rightCellPadding(1);\n        final Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n             .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n             .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n             .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n             .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), \n                     label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), \n                     label(\"\" + info.get(LoggerHelper.config)));\n        }\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), \n                 label(\"\" + info.get(LoggerHelper.additivity)))\n             .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), \n                 label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        final List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n            for (final Map<String, Object> appenderInfo : appenders) {\n                final Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), \n                                 label(\"\" + appenderInfo.get(LoggerHelper.name)))\n                             .row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()))\n                             .row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)))\n                             .row(label(LoggerHelper.classLoaderHash), \n                                 label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), \n                                     label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target), \n                                     label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking), \n                                     label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef), \n                                     label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "100", "src_id": "M1130", "code": "\nprivate ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n    final boolean oneTimeAccess = session.get(ONETIME_SESSION_KEY) != null;\n    try {\n        final String commandLine = apiRequest.getCommand();\n        final Map<String, Object> body = new TreeMap<String, Object>();\n        body.put(\"command\", commandLine);\n        final ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n\n        final int lock = session.getLock();\n        PackingResultDistributor packingResultDistributor = null;\n        Job job = null;\n        try {\n            final Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n            packingResultDistributor = new PackingResultDistributorImpl(session);\n            job = this.createJob(commandLine, session, packingResultDistributor);\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n            job.run();\n        } catch (Throwable e) {\n            logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n            return response;\n        } finally {\n            if (session.getLock() == lock) {\n                session.unLock();\n            }\n        }\n\n        Integer timeout = apiRequest.getExecTimeout();\n        if (timeout == null || timeout <= 0) {\n            timeout = DEFAULT_EXEC_TIMEOUT;\n        }\n        final boolean timeExpired = !waitForJob(job, timeout);\n        if (timeExpired) {\n            logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n            job.interrupt();\n            response.setState(ApiState.INTERRUPTED)\n                    .setMessage(\"The job is exceeded time limit, force interrupt\");\n        } else {\n            response.setState(ApiState.SUCCEEDED);\n        }\n\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        body.put(\"timeExpired\", timeExpired);\n        if (timeExpired) {\n            body.put(\"timeout\", timeout);\n        }\n        body.put(\"results\", packingResultDistributor.getResults());\n        response.setSessionId(session.getSessionId()).setBody(body);\n        return response;\n    } finally {\n        if (oneTimeAccess) {\n            sessionManager.removeSession(session.getSessionId());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "101", "src_id": "M494", "code": "\nprivate void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n    callback.callback(deep, isLast, prefix, node);\n    if (!isLeaf(node)) {\n        final List<TraceNode> children = node.getChildren();\n        if (children == null) {\n            return;\n        }\n        final int size = children.size();\n        for (int index = 0; index < size; index++) {\n            final boolean isLastFlag = index == size - 1;\n            final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n            recursive(deep + 1, isLastFlag, currentPrefix, children.get(index), callback);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "102", "src_id": "M474", "code": "\nprivate static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n    if (parentClassLoader.getChildren() == null) {\n        return;\n    }\n    for (final ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n        final TreeElement child = new TreeElement(childClassLoader.getName());\n        parent.addChild(child);\n        renderSubtree(child, childClassLoader);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "103", "src_id": "M1671", "code": "\n    public void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n        if (frame instanceof CloseWebSocketFrame) {\n            closeOutboundChannel(ctx.channel());\n            ctx.close();\n            return;\n        }\n\n        Channel outboundChannel = channelMappings.get(ctx.channel());\n        if (outboundChannel == null || !outboundChannel.isActive()) {\n            connectToDestinationServer(ctx, frame);\n        } else {\n            forwardWebSocketFrame(frame, outboundChannel);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "104", "src_id": "M1691", "code": "\n            @Override\n            public void onError(Throwable t) {\n                logger.error(\"keep alive error: {}\", t.getMessage(), t);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "105", "src_id": "M1656", "code": "\n    @Override\n    public Map<String, String> findNativeAgent(String address) {\n        if (address == null || \"\".equals(address)) {\n            return null;\n        }\n\n        try {\n            ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n                if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                    connectedSemaphore.countDown();\n                }\n            });\n            connectedSemaphore.await();\n\n            List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n\n            Map<String, String> res = new ConcurrentHashMap<>(children.size());\n            for (String child : children) {\n                String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n                byte[] data = zooKeeper.getData(childPath, false, new Stat());\n                String dataStr = new String(data);\n\n                res.put(child, dataStr);\n            }\n\n            zooKeeper.close();\n            return res;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "106", "src_id": "M1668", "code": "\n    private FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n        OkHttpClient client = new OkHttpClient.Builder()\n                .connectTimeout(10, TimeUnit.SECONDS)\n                .readTimeout(30, TimeUnit.SECONDS)\n                .writeTimeout(30, TimeUnit.SECONDS)\n                .build();\n\n        String url = \"http://\" + address + \"/api/native-agent\";\n\n        RequestBody requestBody = RequestBody.create(\n                request.content().toString(CharsetUtil.UTF_8),\n                MediaType.parse(\"application/json; charset=utf-8\")\n        );\n\n        Request okRequest = new Request.Builder()\n                .url(url)\n                .post(requestBody)\n                .build();\n\n        try {\n            Response response = client.newCall(okRequest).execute();\n\n            if (response.isSuccessful()) {\n                String responseBody = response.body().string();\n                DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(\n                        request.getProtocolVersion(),\n                        HttpResponseStatus.OK,\n                        Unpooled.copiedBuffer(responseBody, StandardCharsets.UTF_8)\n                );\n                // Set CORS headers\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\");\n                fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\");\n\n                // Set other necessary headers\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n                fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, fullHttpResponse.content().readableBytes());\n                return fullHttpResponse;\n            } else {\n                return new DefaultFullHttpResponse(\n                        HttpVersion.HTTP_1_1,\n                        HttpResponseStatus.valueOf(response.code()),\n                        Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n                );\n            }\n        } catch (IOException e) {\n            logger.error(\"Error forwarding request: {}\", e.getMessage(), e);\n            return new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1,\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                    Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n            );\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "107", "src_id": "M1714", "code": "\n    public static void main(String[] args) {\n        WelcomeUtil.printNativeAgentWelcomeMsg();\n\n        logger.info(\"check arthas file path...\");\n        ArthasHomeHandler.findArthasHome();\n        logger.info(\"check arthas file path success\");\n\n        logger.info(\"read input config...\");\n        NativeAgentBootstrap nativeAgentBootstrap = new NativeAgentBootstrap();\n        CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n        CommandLine commandLine = cli.parse(Arrays.asList(args));\n        try {\n            CLIConfigurator.inject(commandLine, nativeAgentBootstrap);\n        } catch (Throwable e) {\n            logger.error(\"Missing startup parameter\", e);\n            System.out.println(usage(cli));\n            System.exit(1);\n        }\n        logger.info(\"read input config success\");\n\n        try {\n            logger.info(\"register native agent ...\");\n            NativeAgentRegistryFactory nativeAgentRegistryFactory = NativeAgentRegistryFactory.getNativeAgentClientRegisterFactory();\n            NativeAgentRegistry nativeAgentRegistry = nativeAgentRegistryFactory.getServiceRegistration(nativeAgentBootstrap.getRegistrationType());\n            nativeAgentRegistry.registerNativeAgent(nativeAgentBootstrap.getRegistrationAddress(),\n                    nativeAgentBootstrap.getIp(),\n                    nativeAgentBootstrap.getHttpPortOrDefault() + \":\" + nativeAgentBootstrap.getWsPortOrDefault());\n            logger.info(\"register native agent success!\");\n        } catch (Exception e) {\n            logger.error(\"register native agent failed!\", e);\n            System.exit(1);\n        }\n\n        int wsPortOrDefault = nativeAgentBootstrap.getWsPortOrDefault();\n        Thread wsServerThread = new Thread(() -> {\n            logger.info(\"start the websocket server... ws port: {}\", wsPortOrDefault);\n            try {\n                EventLoopGroup bossGroup = new NioEventLoopGroup();\n                EventLoopGroup workerGroup = new NioEventLoopGroup();\n                try {\n                    ServerBootstrap b = new ServerBootstrap();\n                    b.group(bossGroup, workerGroup)\n                            .channel(NioServerSocketChannel.class)\n                            .handler(new LoggingHandler(LogLevel.INFO))\n                            .childHandler(new ChannelInitializer<SocketChannel>() {\n                                @Override\n                                protected void initChannel(SocketChannel ch) {\n                                    ChannelPipeline p = ch.pipeline();\n                                    p.addLast(new HttpRequestDecoder());\n                                    p.addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                                    p.addLast(new HttpResponseEncoder());\n                                    p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                                    p.addLast(new ForwardClientSocketClientHandler());\n                                }\n                            });\n                    ChannelFuture f = b.bind(\"0.0.0.0\", wsPortOrDefault).sync();\n                    logger.info(\"start the websocket server success! ws port: {}\", wsPortOrDefault);\n                    f.channel().closeFuture().sync();\n                } finally {\n                    logger.info(\"shutdown websocket server, ws port: {}\", wsPortOrDefault);\n                    bossGroup.shutdownGracefully();\n                    workerGroup.shutdownGracefully();\n                }\n            } catch (InterruptedException e) {\n                logger.error(\"failed to start websocket server, ws port: {}\", wsPortOrDefault, e);\n                Thread.currentThread().interrupt();\n            }\n        });\n        wsServerThread.setName(\"native-agent-ws-server\");\n        wsServerThread.start();\n\n        int httpPortOrDefault = nativeAgentBootstrap.getHttpPortOrDefault();\n        logger.info(\"start the http server... http port: {}\", httpPortOrDefault);\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n        NioEventLoopGroup workGroup = new NioEventLoopGroup();\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup, workGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new HttpServerCodec());\n                            ch.pipeline().addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                            ch.pipeline().addLast(new HttpRequestHandler());\n                        }\n                    });\n            ChannelFuture f = b.bind(\"0.0.0.0\", httpPortOrDefault).sync();\n            logger.info(\"start the http server success, http port: {}\", httpPortOrDefault);\n            f.channel().closeFuture().sync();\n        } catch (Exception e) {\n            logger.error(\"failed to start http server, http port: {}\", httpPortOrDefault, e);\n        } finally {\n            bossGroup.shutdownGracefully();\n            workGroup.shutdownGracefully();\n            logger.info(\"shutdown http server\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "108", "src_id": "M1677", "code": "\n    private Map<String, String> parseQueryString(String query) {\n        Map<String, String> params = new HashMap<>();\n        if (query != null) {\n            String[] pairs = query.split(\"&\");\n            for (String pair : pairs) {\n                int idx = pair.indexOf(\"=\");\n                try {\n                    String key = URLDecoder.decode(pair.substring(0, idx), \"UTF-8\");\n                    String value = URLDecoder.decode(pair.substring(idx + 1), \"UTF-8\");\n                    params.put(key, value);\n                } catch (UnsupportedEncodingException e) {\n                    // Handle exception\n                }\n            }\n        }\n        return params;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "109", "src_id": "M1675", "code": "\n    private void closeOutboundChannel(Channel inboundChannel) {\n        Channel outboundChannel = channelMappings.remove(inboundChannel);\n        if (outboundChannel != null) {\n            logger.info(\"Closing outbound channel\");\n            outboundChannel.close();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "110", "src_id": "M1738", "code": "\n    private ByteBuf readInputStream(InputStream is) throws IOException {\n        ByteBuf buffer = Unpooled.buffer();\n        byte[] tmp = new byte[1024];\n        int length;\n        while ((length = is.read(tmp)) != -1) {\n            buffer.writeBytes(tmp, 0, length);\n        }\n        is.close();\n        return buffer;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "111", "src_id": "M1665", "code": "\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ch.pipeline().addLast(new HttpServerCodec());\n                            ch.pipeline().addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH));\n                            ch.pipeline().addLast(new RequestHandler());\n                            ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "112", "src_id": "M1661", "code": "\n    @Option(longName = \"agent-registration-type\", required = true)\n    @Description(\"agent registration type\")\n    public void setAgentRegistrationType(String agentRegistrationType) {\n        this.agentRegistrationType = agentRegistrationType;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "113", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "114", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "115", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "116", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "117", "src_id": "M1105", "code": "\n@Override\npublic void onSuspend(Job job) {\n    if (!job.isRunInBackground()) {\n        resetAndReadLine();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "118", "src_id": "M1106", "code": "\nprivate void resetAndReadLine() {\n    // reset stdin handler to echo handler\n    // shell.term().stdinHandler(null);\n    shell.setForegroundJob(null);\n    shell.readline();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "119", "src_id": "M504", "code": "\nprivate void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n    for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n        String objectName = entry.getKey();\n        List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n        TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n        table.row(true, \"OBJECT_NAME\", objectName);\n        table.row(true, label(\"NAME\").style(Decoration.bold.bold()),\n                label(\"VALUE\").style(Decoration.bold.bold()));\n\n        for (MBeanAttributeVO attributeVO : attributeVOList) {\n            String attributeName = attributeVO.getName();\n            String valueStr;\n            if (attributeVO.getError() != null) {\n                valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n            } else {\n                // convert array to list\n                // TODO support all array type\n                Object value = attributeVO.getValue();\n                if (value instanceof String[]) {\n                    value = Arrays.asList((String[]) value);\n                } else if (value instanceof Integer[]) {\n                    value = Arrays.asList((Integer[]) value);\n                } else if (value instanceof Long[]) {\n                    value = Arrays.asList((Long[]) value);\n                } else if (value instanceof int[]) {\n                    value = convertArrayToList((int[]) value);\n                } else if (value instanceof long[]) {\n                    value = convertArrayToList((long[]) value);\n                }\n                // to string\n                valueStr = String.valueOf(value);\n            }\n            table.row(attributeName, valueStr);\n        }\n        process.write(RenderUtil.render(table, process.width()));\n        process.write(\"\\n\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "120", "src_id": "M1157", "code": "\nprivate HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n    DefaultFullHttpResponse fullResp = null;\n    InputStream in = null;\n    try {\n        URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n        if (res != null) {\n            fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n            in = res.openStream();\n            byte[] tmp = new byte[256];\n            for (int l = 0; l != -1; l = in.read(tmp)) {\n                fullResp.content().writeBytes(tmp, 0, l);\n            }\n            int li = path.lastIndexOf('.');\n            if (li != -1 && li != path.length() - 1) {\n                String ext = path.substring(li + 1);\n                String contentType;\n                if (\"html\".equals(ext)) {\n                    contentType = \"text/html\";\n                } else if (\"js\".equals(ext)) {\n                    contentType = \"application/javascript\";\n                } else if (\"css\".equals(ext)) {\n                    contentType = \"text/css\";\n                } else {\n                    contentType = null;\n                }\n\n                if (contentType != null) {\n                    fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                }\n            }\n        }\n    } finally {\n        IOUtils.close(in);\n    }\n    return fullResp;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "121", "src_id": "M381", "code": "\n@Override\npublic List<ResultModel> pollResults() {\n    try {\n        lastAccessTime = System.currentTimeMillis();\n        long accessTime = lastAccessTime;\n        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n            polling = true;\n            sendingItemCount = 0;\n            long firstResultTime = 0;\n            // sending delay: time elapsed after firstResultTime\n            long sendingDelay = 0;\n            // waiting time: time elapsed after access\n            long waitingTime = 0;\n            List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n            while (!closed\n                    && sendingResults.size() < resultBatchSizeLimit\n                    && sendingDelay < 100\n                    && waitingTime < pollTimeLimit) {\n                ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (aResult != null) {\n                    sendingResults.add(aResult);\n                    // 是否为第一次获取到数据\n                    if (firstResultTime == 0) {\n                        firstResultTime = System.currentTimeMillis();\n                    }\n                    // 判断是否需要立即发送出去\n                    if (shouldFlush(sendingResults, aResult)) {\n                        break;\n                    }\n                } else {\n                    if (firstResultTime > 0) {\n                        // 获取到部分数据后，队列已经取完，计算发送延时时间\n                        sendingDelay = System.currentTimeMillis() - firstResultTime;\n                    }\n                    // 计算总共等待时间，长轮询最大等待时间\n                    waitingTime = System.currentTimeMillis() - accessTime;\n                }\n            }\n\n            // resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n            }\n            return sendingResults;\n        }\n    } catch (InterruptedException e) {\n        // e.printStackTrace();\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lastAccessTime = System.currentTimeMillis();\n            polling = false;\n            lock.unlock();\n        }\n    }\n    return Collections.emptyList();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "122", "src_id": "M519", "code": "\n@Override\npublic void draw(CommandProcess process, DashboardModel result) {\n    int width = process.width();\n    int height = process.height();\n\n    // 上半部分放thread top。下半部分再切分为田字格，其中上面两格放memory, gc的信息。下面两格放tomcat,\n    // runtime的信息\n    int totalHeight = height - 1;\n    int threadTopHeight;\n    if (totalHeight <= 24) {\n        // 总高度较小时取1/2\n        threadTopHeight = totalHeight / 2;\n    } else {\n        // 总高度较大时取1/3，但不少于上面的值(24/2=12)\n        threadTopHeight = totalHeight / 3;\n        if (threadTopHeight < 12) {\n            threadTopHeight = 12;\n        }\n    }\n    int lowerHalf = totalHeight - threadTopHeight;\n\n    // Memory至少保留8行, 显示metaspace信息\n    int memoryInfoHeight = lowerHalf / 2;\n    if (memoryInfoHeight < 8) {\n        memoryInfoHeight = Math.min(8, lowerHalf);\n    }\n\n    // runtime\n    TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n    // tomcat\n    TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n    int runtimeInfoHeight = Math.max(runtimeInfoTable.getRows().size(), tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size());\n    if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n        // 如果runtimeInfo高度有剩余，则增大MemoryInfo的高度\n        memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n    } else {\n        runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n    }\n\n    // 如果MemoryInfo高度有剩余，则增大ThreadHeight\n    int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n    memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n    threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n    String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n    String memoryAndGc = drawMemoryInfoAndGcInfo(result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n    String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n\n    process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "123", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoader)))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.level)));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.additivity)))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                        label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                appendersTable.row(label(LoggerHelper.classLoaderHash),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target),\n                            label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking),\n                            label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef),\n                            label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "124", "src_id": "M1130", "code": "\nprivate ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n    boolean oneTimeAccess = false;\n    if (session.get(ONETIME_SESSION_KEY) != null) {\n        oneTimeAccess = true;\n    }\n\n    try {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<String, Object>();\n        body.put(\"command\", commandLine);\n\n        ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId())\n                .setBody(body);\n\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED)\n                    .setMessage(\"Another command is executing.\");\n            return response;\n        }\n\n        int lock = session.getLock();\n        PackingResultDistributor packingResultDistributor = null;\n        Job job = null;\n        try {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED)\n                        .setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n\n            packingResultDistributor = new PackingResultDistributorImpl(session);\n            // distribute result message both to origin session channel and request channel by CompositeResultDistributor\n            // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n            job = this.createJob(commandLine, session, packingResultDistributor);\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n            job.run();\n\n        } catch (Throwable e) {\n            logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n            return response;\n        } finally {\n            if (session.getLock() == lock) {\n                session.unLock();\n            }\n        }\n\n        // wait for job completed or timeout\n        Integer timeout = apiRequest.getExecTimeout();\n        if (timeout == null || timeout <= 0) {\n            timeout = DEFAULT_EXEC_TIMEOUT;\n        }\n        boolean timeExpired = !waitForJob(job, timeout);\n        if (timeExpired) {\n            logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n            job.interrupt();\n            response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n        } else {\n            response.setState(ApiState.SUCCEEDED);\n        }\n\n        // packing results\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        body.put(\"timeExpired\", timeExpired);\n        if (timeExpired) {\n            body.put(\"timeout\", timeout);\n        }\n        body.put(\"results\", packingResultDistributor.getResults());\n\n        response.setSessionId(session.getSessionId())\n                // .setConsumerId(consumerId)\n                .setBody(body);\n        return response;\n    } finally {\n        if (oneTimeAccess) {\n            sessionManager.removeSession(session.getSessionId());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "125", "src_id": "M494", "code": "\nprivate void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n    callback.callback(deep, isLast, prefix, node);\n    if (!isLeaf(node)) {\n        List<TraceNode> children = node.getChildren();\n        if (children == null) {\n            return;\n        }\n        final int size = children.size();\n        for (int index = 0; index < size; index++) {\n            final boolean isLastFlag = index == size - 1;\n            final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n            recursive(\n                    deep + 1,\n                    isLastFlag,\n                    currentPrefix,\n                    children.get(index),\n                    callback\n            );\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "126", "src_id": "M474", "code": "\nprivate static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n    if (parentClassLoader.getChildren() == null) {\n        return;\n    }\n    for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n        TreeElement child = new TreeElement(childClassLoader.getName());\n        parent.addChild(child);\n        renderSubtree(child, childClassLoader);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "127", "src_id": "M604", "code": "\n    private String outputFileExt() {\n        if (format == null) {\n            return \"html\";\n        } else if (format.startsWith(\"flat\") || format.startsWith(\"traces\") \n                || format.equals(\"collapsed\")) {\n            return \"txt\";\n        } else if (format.equals(\"flamegraph\") || format.equals(\"tree\")) {\n            return \"html\";\n        } else if (format.equals(\"jfr\")) {\n            return \"jfr\";\n        } else { // illegal -o option makes async-profiler use flat\n            return \"txt\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "128", "src_id": "M579", "code": "\n    @Option(longName = \"lock\")\n    @Description(\"lock profiling threshold in nanoseconds\")\n    public void setLock(String lock) {\n        this.lock = lock;\n    }\n\n\n    @Argument(index = 0, argName = \"cmd\", required = true)\n    @Description(\"command name (start status stop dump)\")\n    public void setCmd(String cmd) {\n        this.cmd = cmd;\n    }\n\n\n    @Option(shortName = \"d\", longName = \"delay\")\n    @Description(\"Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h. (NANOTIME, 0)\")\n    public void setDelay(String delay) {\n        this.delay = delay;\n    }\n\n\n    @Option(longName = \"duration\")\n    @Description(\"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s. (NANOTIME, 0)\")\n    public void setDuration(String duration) {\n        this.duration = duration;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "129", "src_id": "M585", "code": "\n@Option(longName = \"cstack\")\n@Description(\"how to traverse C stack: fp|dwarf|lbr|no\")\npublic void setCstack(String cstack) {\n    this.cstack = cstack;\n}\n\n\n@Override\npublic void process(CommandProcess process) {\n    if (\"start\".equals(cmd)) {\n        Configuration c = null;\n        try {\n            if (getSettings() == null) setSettings(\"default\");\n            c = Configuration.getConfiguration(settings);\n        } catch (Throwable e) {\n            process.end(-1, \"Could not start recording, not able to read settings.\");\n        }\n        Recording r = new Recording(c);\n\n        if (getFilename() != null) {\n            try {\n                r.setDestination(Paths.get(getFilename()));\n            } catch (IOException e) {\n                r.close();\n                process.end(-1, \"Could not start recording, not able to write to file \" + getFilename() + e.getMessage());\n            }\n        }\n\n        if (getMaxSize() != null) {\n            try {\n                r.setMaxSize(parseSize(getMaxSize()));\n            } catch (Exception e) {\n                process.end(-1, e.getMessage());\n            }\n        }\n\n        if (getMaxAge() != null) {\n            try {\n                r.setMaxAge(Duration.ofNanos(parseTimespan(getMaxAge())));\n            } catch (Exception e) {\n                process.end(-1, e.getMessage());\n            }\n        }\n\n        if (isDumpOnExit() != false) {\n            r.setDumpOnExit(isDumpOnExit().booleanValue());\n        }\n\n        if (getDuration() != null) {\n            try {\n                r.setDuration(Duration.ofNanos(parseTimespan(getDuration())));\n            } catch (Exception e) {\n                process.end(-1, e.getMessage());\n            }\n        }\n\n        r.setName(getName() == null ? \"Recording-\" + r.getId() : getName());\n\n        long id = r.getId();\n        recordings.put(id, r);\n\n        if (getDelay() != null) {\n            try {\n                r.scheduleStart(Duration.ofNanos(parseTimespan(getDelay())));\n                result.setJfrOutput(\"Recording \" + id + \" scheduled to start in \" + getDelay());\n            } catch (Exception e) {\n                process.end(-1, e.getMessage());\n            }\n        } else {\n            r.start();\n            result.setJfrOutput(\"Started recording \" + id + \".\");\n        }\n\n        if (duration == null && maxAge == null && maxSize == null) {\n            result.setJfrOutput(\" No limit specified, using maxsize=250MB as default.\");\n            r.setMaxSize(250 * 1024L * 1024L);\n        }\n\n        if (filename != null && duration != null) {\n            result.setJfrOutput(\" The result will be written to:\\n\" + filename);\n        }\n    } else if (\"status\".equals(cmd)) {\n        if (getRecording() != null) {\n            Recording r = recordings.get(getRecording());\n            if (r == null) process.end(-1, \"Recording not exist.\");\n            printRecording(r);\n        } else {\n            List<Recording> recordingList = state != null ? findRecordingByState(state) : new ArrayList<>(recordings.values());\n            if (recordingList.isEmpty()) {\n                process.end(-1, \"No available recordings.\\n Use jfr start to start a recording.\\n\");\n            } else {\n                for (Recording recording : recordingList) printRecording(recording);\n            }\n        }\n    } else if (\"dump\".equals(cmd)) {\n        if (recordings.isEmpty()) process.end(-1, \"No recordings to dump. Use jfr start to start a recording.\");\n        if (getRecording() != null) {\n            Recording r = recordings.get(getRecording());\n            if (r == null) process.end(-1, \"Recording not exist.\");\n            if (getFilename() == null) {\n                try {\n                    setFilename(outputFile());\n                } catch (IOException e) {\n                    process.end(-1, e.getMessage());\n                }\n            }\n            try {\n                r.dump(Paths.get(getFilename()));\n                result.setJfrOutput(\"Dump recording \" + r.getId() + \", The result will be written to:\\n\" + getFilename());\n            } catch (IOException e) {\n                process.end(-1, \"Could not dump. \" + e.getMessage());\n            }\n        } else {\n            process.end(-1, \"Failed to dump. Please input recording id.\");\n        }\n    } else if (\"stop\".equals(cmd)) {\n        if (recordings.isEmpty()) process.end(-1, \"No recordings to stop. Use jfr start to start a recording.\");\n        if (getRecording() != null) {\n            Recording r = recordings.remove(getRecording());\n            if (r == null) process.end(-1, \"Recording not exist.\");\n            if (r.getState().toString().matches(\"CLOSED|STOPPED\")) {\n                process.end(-1, \"Failed to stop recording, state cannot be closed/stopped.\");\n            }\n            if (getFilename() == null) {\n                try {\n                    setFilename(outputFile());\n                } catch (IOException e) {\n                    process.end(-1, e.getMessage());\n                }\n            }\n            try {\n                r.setDestination(Paths.get(getFilename()));\n                r.stop();\n                result.setJfrOutput(\"Stop recording \" + r.getId() + \", The result will be written to:\\n\" + getFilename());\n                r.close();\n            } catch (IOException e) {\n                process.end(-1, \"Failed to stop \" + r.getName() + \". Could not set destination for \" + filename + \": \" + e.getMessage());\n            }\n        } else {\n            process.end(-1, \"Failed to stop. Please input recording id.\");\n        }\n    } else {\n        process.end(-1, \"Invalid jfr command. Valid commands: start, status, stop, dump.\");\n    }\n    process.appendResult(result);\n    process.end();\n}\n\n\n@Argument(index = 0, argName = \"cmd\", required = true)\n@Description(\"command name (start status stop dump)\")\npublic void setCmd(String cmd) {\n    this.cmd = cmd;\n}\n\n\n@Option(shortName = \"d\", longName = \"delay\")\n@Description(\"Delay recording start with (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 5h. (NANOTIME, 0)\")\npublic void setDelay(String delay) {\n    this.delay = delay;\n}\n\n\n@Option(longName = \"duration\")\n@Description(\"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s. (NANOTIME, 0)\")\npublic void setDuration(String duration) {\n    this.duration = duration;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "130", "src_id": "M601", "code": "\n    @Option(longName = \"timeout\")\n    @Description(\"automatically stop profiler at TIME (absolute or relative)\")\n    public void setTimeout(String timeout) {\n        this.timeout = timeout;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "131", "src_id": "M592", "code": "\n    @Option(longName = \"end\")\n    @Description(\"automatically stop profiling when the specified native function is executed\")\n    public void setEnd(String end) {\n        this.end = end;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "132", "src_id": "M1671", "code": "\npublic void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n    if (frame instanceof CloseWebSocketFrame) {\n        closeOutboundChannel(ctx.channel());\n        ctx.close();\n        return;\n    }\n\n    Channel outboundChannel = channelMappings.get(ctx.channel());\n    if (outboundChannel == null || !outboundChannel.isActive()) {\n        connectToDestinationServer(ctx, frame);\n    } else {\n        forwardWebSocketFrame(frame, outboundChannel);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "133", "src_id": "M1691", "code": "\n@Override\npublic void onError(Throwable t) {\n    logger.error(\"keep alive error: \" + t.getMessage());\n    t.printStackTrace();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "134", "src_id": "M1656", "code": "\n@Override\npublic Map<String, String> findNativeAgent(String address) {\n    if (address == null || \"\".equals(address)) {\n        return null;\n    }\n\n    // Wait for connection to be established\n    try {\n        ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n            if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n                connectedSemaphore.countDown();\n            }\n        });\n        connectedSemaphore.await();\n\n        // Gets a list of all children of the parent node\n        List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n\n        // Get the data of the child node\n        Map<String, String> res = new ConcurrentHashMap<>(children.size());\n        for (String child : children) {\n            String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n            byte[] data = zooKeeper.getData(childPath, false, new Stat());\n            String dataStr = new String(data);\n\n            res.put(child, dataStr);\n        }\n\n        zooKeeper.close();\n        return res;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "135", "src_id": "M1668", "code": "\nprivate FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n    OkHttpClient client = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .build();\n\n    String url = \"http://\" + address + \"/api/native-agent\";\n\n    RequestBody requestBody = RequestBody.create(\n            request.content().toString(CharsetUtil.UTF_8),\n            MediaType.parse(\"application/json; charset=utf-8\")\n    );\n\n    Request okRequest = new Request.Builder()\n            .url(url)\n            .post(requestBody)\n            .build();\n\n    try {\n        Response response = client.newCall(okRequest).execute();\n\n        if (response.isSuccessful()) {\n            String responseBody = response.body().string();\n            DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(\n                    request.getProtocolVersion(),\n                    HttpResponseStatus.OK,\n                    Unpooled.copiedBuffer(responseBody, StandardCharsets.UTF_8)\n            );\n            // Set CORS headers\n            fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\");\n            fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\");\n            fullHttpResponse.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\");\n\n            // Set other necessary headers\n            fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/json\");\n            fullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, fullHttpResponse.content().readableBytes());\n            return fullHttpResponse;\n        } else {\n            return new DefaultFullHttpResponse(\n                    HttpVersion.HTTP_1_1,\n                    HttpResponseStatus.valueOf(response.code()),\n                    Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n            );\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        return new DefaultFullHttpResponse(\n                HttpVersion.HTTP_1_1,\n                HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "136", "src_id": "M1714", "code": "\npublic static void main(String[] args) {\n    WelcomeUtil.printNativeAgentWelcomeMsg();\n\n    logger.info(\"check arthas file path...\");\n    ArthasHomeHandler.findArthasHome();\n    logger.info(\"check arthas file path success\");\n\n    logger.info(\"read input config...\");\n    NativeAgentBootstrap nativeAgentBootstrap = new NativeAgentBootstrap();\n    CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n    CommandLine commandLine = cli.parse(Arrays.asList(args));\n    try {\n        CLIConfigurator.inject(commandLine, nativeAgentBootstrap);\n    } catch (Throwable e) {\n        logger.error(\"Missing startup parameter\");\n        e.printStackTrace();\n        System.out.println(usage(cli));\n        System.exit(1);\n    }\n    logger.info(\"read input config success\");\n\n    try {\n        logger.info(\"register native agent ...\");\n        NativeAgentRegistryFactory nativeAgentRegistryFactory = NativeAgentRegistryFactory.getNativeAgentClientRegisterFactory();\n        NativeAgentRegistry nativeAgentRegistry = nativeAgentRegistryFactory.getServiceRegistration(nativeAgentBootstrap.getRegistrationType());\n        nativeAgentRegistry.registerNativeAgent(nativeAgentBootstrap.getRegistrationAddress()\n                , nativeAgentBootstrap.getIp()\n                , nativeAgentBootstrap.getHttpPortOrDefault() + \":\" + nativeAgentBootstrap.getWsPortOrDefault());\n        logger.info(\"register native agent success!\");\n    } catch (Exception e) {\n        logger.error(\"register native agent failed!\");\n        e.printStackTrace();\n        System.exit(1);\n    }\n\n    int wsPortOrDefault = nativeAgentBootstrap.getWsPortOrDefault();\n    Thread wsServerThread = new Thread(() -> {\n        logger.info(\"start the websocket server... ws port:\" + wsPortOrDefault);\n        try {\n            EventLoopGroup bossGroup = new NioEventLoopGroup();\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n            try {\n                ServerBootstrap b = new ServerBootstrap();\n                b.group(bossGroup, workerGroup)\n                        .channel(NioServerSocketChannel.class)\n                        .handler(new LoggingHandler(LogLevel.INFO))\n                        .childHandler(new ChannelInitializer<SocketChannel>() {\n                            @Override\n                            protected void initChannel(SocketChannel ch) {\n                                ChannelPipeline p = ch.pipeline();\n                                p.addLast(new HttpRequestDecoder());\n                                p.addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                                p.addLast(new HttpResponseEncoder());\n                                p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                                p.addLast(new ForwardClientSocketClientHandler());\n                            }\n                        });\n                ChannelFuture f = b.bind(\"0.0.0.0\", wsPortOrDefault).sync();\n                logger.info(\"start the websocket server success! ws port:\" + wsPortOrDefault);\n                f.channel().closeFuture().sync();\n            } finally {\n                logger.info(\"shutdown websocket server, ws port:{}\", wsPortOrDefault);\n                bossGroup.shutdownGracefully();\n                workerGroup.shutdownGracefully();\n            }\n        } catch (InterruptedException e) {\n            logger.error(\"failed to start websocket server, ws port: {}\", wsPortOrDefault);\n            Thread.currentThread().interrupt();\n            e.printStackTrace();\n        }\n    });\n    wsServerThread.setName(\"native-agent-ws-server\");\n    wsServerThread.start();\n\n    int httpPortOrDefault = nativeAgentBootstrap.getHttpPortOrDefault();\n    logger.info(\"start the http server... http port:\" + httpPortOrDefault);\n    NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n    NioEventLoopGroup workGroup = new NioEventLoopGroup();\n    try {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workGroup)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel.INFO))\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) {\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        ch.pipeline().addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                        ch.pipeline().addLast(new HttpRequestHandler());\n                    }\n                });\n        ChannelFuture f = b.bind(\"0.0.0.0\", httpPortOrDefault).sync();\n        logger.info(\"start the http server success, http port:\" + httpPortOrDefault);\n        f.channel().closeFuture().sync();\n    } catch (Exception e) {\n        logger.error(\"failed to start http server, http port:\" + httpPortOrDefault);\n        e.printStackTrace();\n    } finally {\n        bossGroup.shutdownGracefully();\n        workGroup.shutdownGracefully();\n        logger.info(\"shutdown http server\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "137", "src_id": "M1677", "code": "\nprivate Map<String, String> parseQueryString(String query) {\n    Map<String, String> params = new HashMap<>();\n    if (query != null) {\n        String[] pairs = query.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            try {\n                String key = URLDecoder.decode(pair.substring(0, idx), \"UTF-8\");\n                String value = URLDecoder.decode(pair.substring(idx + 1), \"UTF-8\");\n                params.put(key, value);\n            } catch (UnsupportedEncodingException e) {\n                // Handle exception\n            }\n        }\n    }\n    return params;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "138", "src_id": "M1675", "code": "\nprivate void closeOutboundChannel(Channel inboundChannel) {\n    Channel outboundChannel = channelMappings.remove(inboundChannel);\n    if (outboundChannel != null) {\n        logger.info(\"Closing outbound channel\");\n        outboundChannel.close();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "139", "src_id": "M1738", "code": "\nprivate ByteBuf readInputStream(InputStream is) throws IOException {\n    ByteBuf buffer = Unpooled.buffer();\n    byte[] tmp = new byte[1024];\n    int length;\n    while ((length = is.read(tmp)) != -1) {\n        buffer.writeBytes(tmp, 0, length);\n    }\n    is.close();\n    return buffer;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "140", "src_id": "M1665", "code": "\n@Override\nprotected void initChannel(SocketChannel ch) {\n    ch.pipeline().addLast(new HttpServerCodec());\n    ch.pipeline().addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH));\n    ch.pipeline().addLast(new RequestHandler());\n    ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "141", "src_id": "M1661", "code": "\n@Option(longName = \"agent-registration-type\", required = true)\n@Description(\"agent registration type\")\npublic void setAgentRegistrationType(String agentRegistrationType) {\n    this.agentRegistrationType = agentRegistrationType;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "142", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "143", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "144", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "145", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "146", "src_id": "M742", "code": "\n@Override\npublic void complete(Completion completion) {\n    int argumentIndex = CompletionUtils.detectArgumentIndex(completion);\n    if (argumentIndex == 1) {\n        if (!completeBeanName(completion)) {\n            super.complete(completion);\n        }\n        return;\n    }\n    if (argumentIndex == 2) {\n        if (!completeAttributeName(completion)) {\n            super.complete(completion);\n        }\n        return;\n    }\n    super.complete(completion);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "147", "src_id": "M1452", "code": "\npublic static String retrievePreviousArg(List<CliToken> tokens, String lastToken) {\n    if (StringUtils.isBlank(lastToken) && tokens.size() > 2) {\n        return tokens.get(tokens.size() - 2).value();\n    }\n    if (tokens.size() > 3) {\n        return tokens.get(tokens.size() - 3).value();\n    }\n    return Constants.EMPTY_STRING;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "148", "src_id": "M747", "code": "\n@Override\npublic void handle(Void event) {\n    timer.cancel();\n    super.handle(event);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "149", "src_id": "M744", "code": "\nprivate boolean completeAttributeName(Completion completion) {\n    List<CliToken> tokens = completion.lineTokens();\n    String lastToken = TokenUtils.getLast(tokens).value();\n\n    if (StringUtils.isBlank(lastToken)) {\n        lastToken = \"\";\n    }\n\n    MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();\n    String beanName = TokenUtils.retrievePreviousArg(tokens, lastToken);\n    Set<ObjectName> objectNames = null;\n    try {\n        objectNames = platformMBeanServer.queryNames(new ObjectName(beanName), null);\n    } catch (MalformedObjectNameException e) {\n        logger.warn(\"queryNames error\", e);\n    }\n    if (objectNames == null || objectNames.isEmpty()) {\n        return false;\n    }\n    try {\n        MBeanInfo mBeanInfo = platformMBeanServer.getMBeanInfo(objectNames.iterator().next());\n        List<String> attributeNames = new ArrayList<>();\n        MBeanAttributeInfo[] attributes = mBeanInfo.getAttributes();\n        for (MBeanAttributeInfo attribute : attributes) {\n            if (StringUtils.isBlank(lastToken) || attribute.getName().startsWith(lastToken)) {\n                attributeNames.add(attribute.getName());\n            }\n        }\n        return CompletionUtils.complete(completion, attributeNames);\n    } catch (Throwable e) {\n        logger.warn(\"getMBeanInfo error\", e);\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "150", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String value) {\n        maxAge = value;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "151", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String value) {\n        state = value;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "152", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String value) {\n        settings = value;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "153", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String value) {\n        filename = value;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "170", "src_id": "M1671", "code": "\npublic void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {\n    if (frame instanceof CloseWebSocketFrame) {\n        closeOutboundChannel(ctx.channel());\n        ctx.close();\n        return;\n    }\n\n    Channel outboundChannel = channelMappings.get(ctx.channel());\n    if (outboundChannel == null || !outboundChannel.isActive()) {\n        connectToDestinationServer(ctx, frame);\n    } else {\n        forwardWebSocketFrame(frame, outboundChannel);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "171", "src_id": "M1691", "code": "\n@Override\npublic void onError(Throwable t) {\n    logger.error(\"keep alive error: \", t);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "172", "src_id": "M1656", "code": "\n@Override\npublic Map<String, String> findNativeAgent(String address) {\n    if (address == null || address.isEmpty()) {\n        return null;\n    }\n\n    try (ZooKeeper zooKeeper = new ZooKeeper(address, SESSION_TIMEOUT, event -> {\n        if (event.getState() == Watcher.Event.KeeperState.SyncConnected) {\n            connectedSemaphore.countDown();\n        }\n    })) {\n        connectedSemaphore.await();\n        List<String> children = zooKeeper.getChildren(NativeAgentConstants.NATIVE_AGENT_KEY, false);\n        Map<String, String> res = new ConcurrentHashMap<>(children.size());\n        for (String child : children) {\n            String childPath = NativeAgentConstants.NATIVE_AGENT_KEY + \"/\" + child;\n            byte[] data = zooKeeper.getData(childPath, false, new Stat());\n            res.put(child, new String(data));\n        }\n        return res;\n    } catch (Exception e) {\n        throw new IllegalStateException(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "173", "src_id": "M1668", "code": "\nprivate FullHttpResponse forwardRequest(FullHttpRequest request, String address) {\n    OkHttpClient client = new OkHttpClient.Builder()\n        .connectTimeout(10, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .writeTimeout(30, TimeUnit.SECONDS)\n        .build();\n\n    String url = \"http://\" + address + \"/api/native-agent\";\n    RequestBody requestBody = RequestBody.create(\n        request.content().toString(CharsetUtil.UTF_8),\n        MediaType.parse(\"application/json; charset=utf-8\")\n    );\n\n    Request okRequest = new Request.Builder()\n        .url(url)\n        .post(requestBody)\n        .build();\n\n    try {\n        Response response = client.newCall(okRequest).execute();\n        if (response.isSuccessful()) {\n            String responseBody = response.body().string();\n            DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(\n                request.getProtocolVersion(),\n                HttpResponseStatus.OK,\n                Unpooled.copiedBuffer(responseBody, StandardCharsets.UTF_8)\n            );\n            fullHttpResponse.headers()\n                .set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, \"*\")\n                .set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, \"GET, POST, PUT, DELETE, OPTIONS\")\n                .set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, \"X-Requested-With, Content-Type, Authorization\")\n                .set(HttpHeaderNames.CONTENT_TYPE, \"application/json\")\n                .set(HttpHeaderNames.CONTENT_LENGTH, fullHttpResponse.content().readableBytes());\n            return fullHttpResponse;\n        } else {\n            return new DefaultFullHttpResponse(\n                HttpVersion.HTTP_1_1,\n                HttpResponseStatus.valueOf(response.code()),\n                Unpooled.copiedBuffer(\"Error: \" + response.message(), CharsetUtil.UTF_8)\n            );\n        }\n    } catch (IOException e) {\n        logger.error(\"Error forwarding request\", e);\n        return new DefaultFullHttpResponse(\n            HttpVersion.HTTP_1_1,\n            HttpResponseStatus.INTERNAL_SERVER_ERROR,\n            Unpooled.copiedBuffer(\"Error forwarding request: \" + e.getMessage(), CharsetUtil.UTF_8)\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "174", "src_id": "M1714", "code": "\npublic static void main(String[] args) {\n    WelcomeUtil.printNativeAgentWelcomeMsg();\n    logger.info(\"check arthas file path...\");\n    ArthasHomeHandler.findArthasHome();\n    logger.info(\"check arthas file path success\");\n\n    logger.info(\"read input config...\");\n    NativeAgentBootstrap nativeAgentBootstrap = new NativeAgentBootstrap();\n    CLI cli = CLIConfigurator.define(NativeAgentBootstrap.class);\n    CommandLine commandLine = cli.parse(Arrays.asList(args));\n    try {\n        CLIConfigurator.inject(commandLine, nativeAgentBootstrap);\n    } catch (Throwable e) {\n        logger.error(\"Missing startup parameter\", e);\n        System.out.println(usage(cli));\n        System.exit(1);\n    }\n    logger.info(\"read input config success\");\n\n    try {\n        logger.info(\"register native agent ...\");\n        NativeAgentRegistryFactory nativeAgentRegistryFactory = NativeAgentRegistryFactory.getNativeAgentClientRegisterFactory();\n        NativeAgentRegistry nativeAgentRegistry = nativeAgentRegistryFactory.getServiceRegistration(nativeAgentBootstrap.getRegistrationType());\n        nativeAgentRegistry.registerNativeAgent(\n            nativeAgentBootstrap.getRegistrationAddress(),\n            nativeAgentBootstrap.getIp(),\n            nativeAgentBootstrap.getHttpPortOrDefault() + \":\" + nativeAgentBootstrap.getWsPortOrDefault()\n        );\n        logger.info(\"register native agent success!\");\n    } catch (Exception e) {\n        logger.error(\"register native agent failed!\", e);\n        System.exit(1);\n    }\n\n    int wsPortOrDefault = nativeAgentBootstrap.getWsPortOrDefault();\n    Thread wsServerThread = new Thread(() -> {\n        logger.info(\"start the websocket server... ws port:{}\", wsPortOrDefault);\n        try {\n            EventLoopGroup bossGroup = new NioEventLoopGroup();\n            EventLoopGroup workerGroup = new NioEventLoopGroup();\n            try {\n                ServerBootstrap b = new ServerBootstrap();\n                b.group(bossGroup, workerGroup)\n                    .channel(NioServerSocketChannel.class)\n                    .handler(new LoggingHandler(LogLevel.INFO))\n                    .childHandler(new ChannelInitializer<SocketChannel>() {\n                        @Override\n                        protected void initChannel(SocketChannel ch) {\n                            ChannelPipeline p = ch.pipeline();\n                            p.addLast(new HttpRequestDecoder());\n                            p.addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                            p.addLast(new HttpResponseEncoder());\n                            p.addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n                            p.addLast(new ForwardClientSocketClientHandler());\n                        }\n                    });\n                ChannelFuture f = b.bind(\"0.0.0.0\", wsPortOrDefault).sync();\n                logger.info(\"start the websocket server success! ws port:{}\", wsPortOrDefault);\n                f.channel().closeFuture().sync();\n            } finally {\n                logger.info(\"shutdown websocket server, ws port:{}\", wsPortOrDefault);\n                bossGroup.shutdownGracefully();\n                workerGroup.shutdownGracefully();\n            }\n        } catch (InterruptedException e) {\n            logger.error(\"failed to start websocket server, ws port: {}\", wsPortOrDefault, e);\n            Thread.currentThread().interrupt();\n        }\n    });\n    wsServerThread.setName(\"native-agent-ws-server\");\n    wsServerThread.start();\n\n    int httpPortOrDefault = nativeAgentBootstrap.getHttpPortOrDefault();\n    logger.info(\"start the http server... http port:{}\", httpPortOrDefault);\n    NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n    NioEventLoopGroup workGroup = new NioEventLoopGroup();\n    try {\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workGroup)\n            .channel(NioServerSocketChannel.class)\n            .handler(new LoggingHandler(LogLevel.INFO))\n            .childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) {\n                    ch.pipeline().addLast(new HttpServerCodec());\n                    ch.pipeline().addLast(new HttpObjectAggregator(MAX_HTTP_CONTENT_LENGTH));\n                    ch.pipeline().addLast(new HttpRequestHandler());\n                }\n            });\n        ChannelFuture f = b.bind(\"0.0.0.0\", httpPortOrDefault).sync();\n        logger.info(\"start the http server success, http port:{}\", httpPortOrDefault);\n        f.channel().closeFuture().sync();\n    } catch (Exception e) {\n        logger.error(\"failed to start http server, http port:{}\", httpPortOrDefault, e);\n    } finally {\n        bossGroup.shutdownGracefully();\n        workGroup.shutdownGracefully();\n        logger.info(\"shutdown http server\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "175", "src_id": "M1677", "code": "\nprivate Map<String, String> parseQueryString(String query) {\n    Map<String, String> params = new HashMap<>();\n    if (query != null) {\n        String[] pairs = query.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            try {\n                String key = URLDecoder.decode(pair.substring(0, idx), \"UTF-8\");\n                String value = URLDecoder.decode(pair.substring(idx + 1), \"UTF-8\");\n                params.put(key, value);\n            } catch (UnsupportedEncodingException e) {\n                // ignore\n            }\n        }\n    }\n    return params;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "176", "src_id": "M1675", "code": "\nprivate void closeOutboundChannel(Channel inboundChannel) {\n    Channel outboundChannel = channelMappings.remove(inboundChannel);\n    if (outboundChannel != null) {\n        logger.info(\"Closing outbound channel\");\n        outboundChannel.close();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "177", "src_id": "M1738", "code": "\nprivate ByteBuf readInputStream(InputStream is) throws IOException {\n    ByteBuf buffer = Unpooled.buffer();\n    byte[] tmp = new byte[1024];\n    try (InputStream input = is) {\n        int length;\n        while ((length = input.read(tmp)) != -1) {\n            buffer.writeBytes(tmp, 0, length);\n        }\n    }\n    return buffer;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "178", "src_id": "M1665", "code": "\n@Override\nprotected void initChannel(SocketChannel ch) {\n    ch.pipeline().addLast(new HttpServerCodec());\n    ch.pipeline().addLast(new HttpObjectAggregator(NativeAgentConstants.MAX_HTTP_CONTENT_LENGTH));\n    ch.pipeline().addLast(new RequestHandler());\n    ch.pipeline().addLast(new WebSocketServerProtocolHandler(\"/ws\"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "179", "src_id": "M1661", "code": "\n@Option(longName = \"agent-registration-type\", required = true)\n@Description(\"agent registration type\")\npublic void setAgentRegistrationType(String agentRegistrationType) {\n    this.agentRegistrationType = agentRegistrationType;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "180", "src_id": "M308", "code": "\n        HashEntry<K, V> nextEntry() {\n            do {\n                if (nextEntry == null) throw new NoSuchElementException();\n                lastReturned = nextEntry;\n                currentKey = lastReturned.key();\n                advance();\n            } while (currentKey == null);\n            return lastReturned;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "181", "src_id": "M1284", "code": "\n        @AtInvoke(name = \"\", inline = true, whenComplete = false, excludes = \"java.**\")\n        public static void onInvoke(@Binding.This Object target, @Binding.Class Class<?> clazz,\n                @Binding.InvokeInfo String invokeInfo) {\n            SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "182", "src_id": "M947", "code": "\n    public void loggers(CommandProcess process) {\n        Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<>();\n        for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n            String className = clazz.getName();\n            ClassLoader classLoader = clazz.getClassLoader();\n            if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) continue;\n            if (classLoader == null) continue;\n            LoggerTypes loggerTypes = classLoaderLoggerMap.get(classLoader);\n            if (loggerTypes == null) {\n                loggerTypes = new LoggerTypes();\n                classLoaderLoggerMap.put(classLoader, loggerTypes);\n            }\n            updateLoggerType(loggerTypes, classLoader, className);\n        }\n\n        for (Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n            ClassLoader classLoader = entry.getKey();\n            LoggerTypes loggerTypes = entry.getValue();\n            if (loggerTypes.contains(LoggerType.LOG4J)) \n                process.appendResult(new LoggerModel(loggerInfo(classLoader, Log4jHelper.class)));\n            if (loggerTypes.contains(LoggerType.LOGBACK)) \n                process.appendResult(new LoggerModel(loggerInfo(classLoader, LogbackHelper.class)));\n            if (loggerTypes.contains(LoggerType.LOG4J2)) \n                process.appendResult(new LoggerModel(loggerInfo(classLoader, Log4j2Helper.class)));\n        }\n        process.end();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "183", "src_id": "M249", "code": "\n    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) \n            throws URISyntaxException {\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n        String appName = null;\n        List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n        if (appNameList != null && !appNameList.isEmpty()) appName = appNameList.get(0);\n\n        String id;\n        if (appName != null) id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n        else id = RandomStringUtils.random(20, true, true).toUpperCase();\n        List<String> idList = parameters.get(URIConstans.ID);\n        if (idList != null && !idList.isEmpty()) id = idList.get(0);\n\n        String arthasVersion = null;\n        List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n        if (arthasVersionList != null && !arthasVersionList.isEmpty()) arthasVersion = arthasVersionList.get(0);\n\n        final String finalId = id;\n        URI responseUri = UriComponentsBuilder.newInstance().scheme(URIConstans.RESPONSE).path(\"/\")\n                .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n                .queryParam(URIConstans.ID, id).build().encode().toUri();\n\n        AgentInfo info = new AgentInfo();\n        HttpHeaders headers = handshake.requestHeaders();\n        String host = HttpUtils.findClientIP(headers);\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inet = (InetSocketAddress) remoteAddress;\n                info.setHost(inet.getHostString());\n                info.setPort(inet.getPort());\n            }\n        } else {\n            info.setHost(host);\n            Integer port = HttpUtils.findClientPort(headers);\n            if (port != null) info.setPort(port);\n        }\n\n        info.setChannelHandlerContext(ctx);\n        if (arthasVersion != null) info.setArthasVersion(arthasVersion);\n\n        tunnelServer.addAgent(id, info);\n        ctx.channel().closeFuture().addListener(future -> tunnelServer.removeAgent(finalId));\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "184", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect) throws SSLException, URISyntaxException, InterruptedException {\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER);\n        queryEncoder.addParam(URIConstans.ARTHAS_VERSION, this.version);\n        if (appName != null) queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        if (id != null) queryEncoder.addParam(URIConstans.ID, id);\n        final URI agentRegisterURI = queryEncoder.toUri();\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = agentRegisterURI.getScheme() == null ? \"ws\" : agentRegisterURI.getScheme();\n        final String host = agentRegisterURI.getHost() == null ? \"127.0.0.1\" : agentRegisterURI.getHost();\n        final int port = agentRegisterURI.getPort() == -1 ? \n            (\"ws\".equalsIgnoreCase(scheme) ? 80 : \"wss\".equalsIgnoreCase(scheme) ? 443 : -1) : \n            agentRegisterURI.getPort();\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) \n            throw new IllegalArgumentException(\"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n\n        final boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n        final SslContext sslCtx = ssl ? \n            SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build() : \n            null;\n\n        WebSocketClientProtocolConfig config = WebSocketClientProtocolConfig.newBuilder()\n            .webSocketUri(agentRegisterURI)\n            .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH).build();\n        final TunnelClientSocketClientHandler handler = new TunnelClientSocketClientHandler(TunnelClient.this);\n\n        Bootstrap bs = new Bootstrap();\n        bs.group(eventLoopGroup)\n            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n            .option(ChannelOption.TCP_NODELAY, true)\n            .channel(NioSocketChannel.class)\n            .remoteAddress(host, port)\n            .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                    p.addLast(\n                        new HttpClientCodec(), \n                        new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                        new WebSocketClientProtocolHandler(config),\n                        new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                        handler\n                    );\n                }\n            });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(future -> {\n                if (future.cause() != null) \n                    logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n            });\n        }\n        connectFuture.sync();\n        return handler.registerFuture();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "185", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[]{\n            0x49,0x20,0x77,0x69,0x6c,0x6c,0x20,0x6e,0x6f,0x74,0x20,0x6d,0x61,0x6b,0x65,0x20,0x74,0x68,0x65,\n            // ... (preserved byte array content) ...\n            0x2e,0x2e,0x2e,0x0a,/*0x0a,0x66,0x6f,0x72,0x20,0x6a,0x75,0x6c,0x79,0x0a,0x0a,*/\n        };\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "186", "src_id": "M124", "code": "\n    @Override\n    public int read() throws IOException {\n        synchronized (__queue) {\n            while (true) {\n                if (__ioException != null) {\n                    IOException e = __ioException;\n                    __ioException = null;\n                    throw e;\n                }\n                if (__bytesAvailable == 0) {\n                    if (__hasReachedEOF) return EOF;\n                    if (__threaded) {\n                        __queue.notify();\n                        try {\n                            __readIsWaiting = true;\n                            __queue.wait();\n                            __readIsWaiting = false;\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                        }\n                    } else {\n                        __readIsWaiting = true;\n                        int ch;\n                        boolean mayBlock = true;\n                        do {\n                            try {\n                                if ((ch = __read(mayBlock)) < 0 && ch != WOULD_BLOCK) return ch;\n                            } catch (InterruptedIOException e) {\n                                synchronized (__queue) {\n                                    __ioException = e;\n                                    __queue.notifyAll();\n                                    try { __queue.wait(100); } catch (InterruptedException ie) { /* ignore */ }\n                                }\n                                return EOF;\n                            }\n                            try {\n                                if (ch != WOULD_BLOCK) __processChar(ch);\n                            } catch (InterruptedException e) {\n                                if (__isClosed) return EOF;\n                            }\n                            mayBlock = false;\n                        } while (super.available() > 0 && __bytesAvailable < __queue.length - 1);\n                        __readIsWaiting = false;\n                    }\n                    continue;\n                }\n                int ch = __queue[__queueHead];\n                if (++__queueHead >= __queue.length) __queueHead = 0;\n                --__bytesAvailable;\n                if (__bytesAvailable == 0 && __threaded) __queue.notify();\n                return ch;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "187", "src_id": "M786", "code": "\n    @Override\n    public void process(CommandProcess process) {\n        initTransformer();\n        RetransformModel retransformModel = new RetransformModel();\n        Instrumentation inst = process.session().getInstrumentation();\n\n        if (this.list) {\n            retransformModel.setRetransformEntries(allRetransformEntries());\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } \n        if (this.deleteAll) {\n            deleteAllRetransformEntry();\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } \n        if (this.delete > 0) {\n            deleteRetransformEntry(this.delete);\n            process.end();\n            return;\n        } \n        if (this.classPattern != null) {\n            Set<Class<?>> searchClass = SearchUtils.searchClass(inst, classPattern, false, this.hashCode);\n            if (searchClass.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + classPattern);\n                return;\n            }\n            if (searchClass.size() > limit) {\n                process.end(-1, \"match classes size: \" + searchClass.size() + \", more than limit: \" + limit);\n                return;\n            }\n            try {\n                inst.retransformClasses(searchClass.toArray(new Class[0]));\n                for (Class<?> clazz : searchClass) retransformModel.addRetransformClass(clazz.getName());\n                process.appendResult(retransformModel);\n                process.end();\n                return;\n            } catch (Throwable e) {\n                String message = \"retransform error! \" + e;\n                logger.error(message, e);\n                process.end(-1, message);\n                return;\n            }\n        }\n\n        for (String path : paths) {\n            File file = new File(path);\n            if (!file.exists()) { process.end(-1, \"file does not exist, path:\" + path); return; }\n            if (!file.isFile()) { process.end(-1, \"not a normal file, path:\" + path); return; }\n            if (file.length() >= MAX_FILE_SIZE) { \n                process.end(-1, \"file size: \" + file.length() + \" >= \" + MAX_FILE_SIZE + \", path: \" + path); \n                return;\n            }\n        }\n\n        Map<String, byte[]> bytesMap = new HashMap<>();\n        for (String path : paths) {\n            try (RandomAccessFile f = new RandomAccessFile(path, \"r\")) {\n                byte[] bytes = new byte[(int) f.length()];\n                f.readFully(bytes);\n                bytesMap.put(readClassName(bytes), bytes);\n            } catch (Exception e) {\n                logger.warn(\"load class file failed: \" + path, e);\n                process.end(-1, \"load class file failed: \" + path + \", error: \" + e);\n                return;\n            }\n        }\n\n        if (bytesMap.size() != paths.size()) {\n            process.end(-1, \"paths may contains same class name!\");\n            return;\n        }\n\n        List<RetransformEntry> retransformEntryList = new ArrayList<>();\n        List<Class<?>> classList = new ArrayList<>();\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (!bytesMap.containsKey(clazz.getName())) continue;\n            if (hashCode == null && classLoaderClass != null) {\n                List<ClassLoader> matchedClassLoaders = ClassLoaderUtils.getClassLoaderByClassName(inst, classLoaderClass);\n                if (matchedClassLoaders.size() == 1) {\n                    hashCode = Integer.toHexString(matchedClassLoaders.get(0).hashCode());\n                } else if (matchedClassLoaders.size() > 1) {\n                    retransformModel\n                        .setClassLoaderClass(classLoaderClass)\n                        .setMatchedClassLoaders(ClassUtils.createClassLoaderVOList(matchedClassLoaders));\n                    process.appendResult(retransformModel);\n                    process.end(-1, \"Found more than one classloader by class name, specify with '-c <classloader hash>'\");\n                    return;\n                } else {\n                    process.end(-1, \"Can not find classloader by class name: \" + classLoaderClass + \".\");\n                    return;\n                }\n            }\n            ClassLoader classLoader = clazz.getClassLoader();\n            if (classLoader != null && hashCode != null && \n                !Integer.toHexString(classLoader.hashCode()).equals(hashCode)) continue;\n\n            retransformEntryList.add(new RetransformEntry(clazz.getName(), bytesMap.get(clazz.getName()), \n                    hashCode, classLoaderClass));\n            classList.add(clazz);\n            retransformModel.addRetransformClass(clazz.getName());\n        }\n\n        try {\n            if (retransformEntryList.isEmpty()) {\n                process.end(-1, \"These classes are not found in the JVM: \" + bytesMap.keySet());\n                return;\n            }\n            addRetransformEntry(retransformEntryList);\n            inst.retransformClasses(classList.toArray(new Class[0]));\n            process.appendResult(retransformModel);\n            process.end();\n        } catch (Throwable e) {\n            String message = \"retransform error! \" + e;\n            logger.error(message, e);\n            process.end(-1, message);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "188", "src_id": "M278", "code": "\n        V get(Object key, int hash) {\n            if (count != 0) {\n                for (HashEntry<K, V> e = getFirst(hash); e != null; e = e.next) {\n                    if (e.hash == hash && keyEq(key, e.key())) {\n                        Object opaque = e.valueRef;\n                        if (opaque != null) return e.dereferenceValue(opaque);\n                        return readValueUnderLock(e);\n                    }\n                }\n            }\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "189", "src_id": "M184", "code": "\n                @Override\n                protected void initChannel(LocalChannel ch) {\n                    ch.pipeline().addLast(\n                        new HttpClientCodec(), \n                        new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                        new HttpProxyClientHandler(httpResponsePromise)\n                    );\n                }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "190", "src_id": "M1539", "code": "\n@Override\npublic void onError(Throwable t) {\n    Status s = Status.fromThrowable(t);\n    sendResponse.writeError(s);\n    latch.countDown();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "191", "src_id": "M1555", "code": "\nstatic Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n    Map<String, String> map = new HashMap<>();\n    for (String key : trailer.keys()) {\n        if (EXCLUDED.contains(key.toLowerCase())) {\n            continue;\n        }\n        if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n            // TODO allow any object type here\n            byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n            map.put(key, new String(value));\n        } else {\n            String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n            map.put(key, value);\n        }\n    }\n    return map;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "192", "src_id": "M1553", "code": "\npublic byte[] getPrefix(byte[] in, Type type) {\n    int len = in.length;\n    return new byte[] {\n        type.value,\n        (byte) ((len >> 24) & 0xff),\n        (byte) ((len >> 16) & 0xff),\n        (byte) ((len >> 8) & 0xff),\n        (byte) ((len >> 0) & 0xff),\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "193", "src_id": "M1538", "code": "\nprivate Method getRpcMethod(Object stub, String rpcMethodName) {\n    for (Method m : stub.getClass().getMethods()) {\n        if (m.getName().equals(rpcMethodName)) {\n            return m;\n        }\n    }\n    throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "194", "src_id": "M1535", "code": "\nprivate Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n    // pathInfo starts with \"/\". ignore that first char.\n    String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n    if (rpcClassAndMethodTokens.length != 2) {\n        throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n    }\n\n    String rpcClassName = rpcClassAndMethodTokens[0];\n    String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n    String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n    return new Pair<>(rpcClassName, rpcMethodName);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "195", "src_id": "M1530", "code": "\n@Override\npublic boolean isEndOfInput() throws Exception {\n    if (input.isEndOfInput()) {\n        // Only end of input after last HTTP chunk has been sent\n        return true;\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "196", "src_id": "M1643", "code": "\npublic void start() throws InterruptedException {\n    NioEventLoopGroup boss = new NioEventLoopGroup(1);\n    NioEventLoopGroup work = new NioEventLoopGroup();\n    try {\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(boss, work)\n            .channel(NioServerSocketChannel.class)\n            .childHandler(new NettyHttpInitializer(STATIC_LOCATION))\n            .option(ChannelOption.SO_BACKLOG, 128)\n            .childOption(ChannelOption.SO_KEEPALIVE, true);\n        logger.info(\"start http server on port: {}\", port);\n        ChannelFuture future = serverBootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    } finally {\n        work.shutdownGracefully();\n        boss.shutdownGracefully();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "197", "src_id": "M1614", "code": "\nprivate boolean isExclude(Class<?> cls) {\n    if (classNameExcludeMatcher != null) {\n        return classNameExcludeMatcher.matching(cls.getName());\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "198", "src_id": "M1632", "code": "\npublic void parseRequestParams(WatchRequest watchRequest) {\n    this.classPattern = watchRequest.getClassPattern();\n    this.methodPattern = watchRequest.getMethodPattern();\n    if (StringUtils.isEmpty(watchRequest.getExpress())) {\n        this.express = \"{params, target, returnObj}\";\n    } else {\n        this.express = watchRequest.getExpress();\n    }\n    this.conditionExpress = watchRequest.getConditionExpress();\n    this.isBefore = watchRequest.getIsBefore();\n    this.isFinish = watchRequest.getIsFinish();\n    this.isException = watchRequest.getIsException();\n    this.isSuccess = watchRequest.getIsSuccess();\n    if (!watchRequest.getIsBefore() && !watchRequest.getIsFinish() && !watchRequest.getIsException() && !watchRequest.getIsSuccess()) {\n        this.isFinish = true;\n    }\n    if (watchRequest.getExpand() <= 0) {\n        this.expand = 1;\n    } else if (watchRequest.getExpand() > MAX_EXPAND) {\n        this.expand = MAX_EXPAND;\n    } else {\n        this.expand = watchRequest.getExpand();\n    }\n    if (watchRequest.getSizeLimit() == 0) {\n        this.sizeLimit = 10 * 1024 * 1024;\n    } else {\n        this.sizeLimit = watchRequest.getSizeLimit();\n    }\n    this.isRegEx = watchRequest.getIsRegEx();\n    if (watchRequest.getNumberOfLimit() == 0) {\n        this.numberOfLimit = 100;\n    } else {\n        this.numberOfLimit = watchRequest.getNumberOfLimit();\n    }\n    if (watchRequest.getExcludeClassPattern().equals(\"\")) {\n        this.excludeClassPattern = null;\n    } else {\n        this.excludeClassPattern = watchRequest.getExcludeClassPattern();\n    }\n    this.listenerId = watchRequest.getListenerId();\n    this.verbose = watchRequest.getVerbose();\n    if (watchRequest.getMaxNumOfMatchedClass() == 0) {\n        this.maxNumOfMatchedClass = 50;\n    } else {\n        this.maxNumOfMatchedClass = watchRequest.getMaxNumOfMatchedClass();\n    }\n    this.jobId = watchRequest.getJobId();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "199", "src_id": "M1616", "code": "\npublic synchronized EnhancerAffect enhance(final Instrumentation inst, int maxNumOfMatchedClass) throws UnmodifiableClassException {\n    this.matchingClasses = GlobalOptions.isDisableSubClass\n        ? SearchUtils.searchClass(inst, classNameMatcher)\n        : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n    if (matchingClasses.size() > maxNumOfMatchedClass) {\n        affect.setOverLimitMsg(\"The number of matched classes is \" + matchingClasses.size() + \", greater than the limit value \" + maxNumOfMatchedClass + \". Try to change the limit with option '-m <arg>'.\");\n        return affect;\n    }\n\n    List<Pair<Class<?>, String>> filteredList = filter(matchingClasses);\n    if (!filteredList.isEmpty()) {\n        for (Pair<Class<?>, String> filtered : filteredList) {\n            logger.info(\"ignore class: {}, reason: {}\", filtered.getFirst().getName(), filtered.getSecond());\n        }\n    }\n\n    logger.info(\"enhance matched classes: {}\", matchingClasses);\n    affect.setTransformer(this);\n\n    try {\n        DemoBootstrap.getRunningInstance().getTransformerManager().addTransformer(this, isTracing);\n\n        if (GlobalOptions.isBatchReTransform) {\n            final int size = matchingClasses.size();\n            final Class<?>[] classArray = new Class<?>[size];\n            arraycopy(matchingClasses.toArray(), 0, classArray, 0, size);\n            if (classArray.length > 0) {\n                inst.retransformClasses(classArray);\n                logger.info(\"Success to batch transform classes: \" + Arrays.toString(classArray));\n            }\n        } else {\n            for (Class<?> cls : matchingClasses) {\n                try {\n                    inst.retransformClasses(cls);\n                    logger.info(\"Success to transform class: \" + cls);\n                } catch (Throwable t) {\n                    logger.warn(\"retransform {} failed.\", cls, t);\n                    if (t instanceof UnmodifiableClassException) {\n                        throw (UnmodifiableClassException) t;\n                    } else if (t instanceof RuntimeException) {\n                        throw (RuntimeException) t;\n                    } else {\n                        throw new RuntimeException(t);\n                    }\n                }\n            }\n        }\n    } catch (Throwable e) {\n        logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n        affect.setThrowable(e);\n    }\n\n    return affect;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "200", "src_id": "M1579", "code": "\npublic static ComplexObject createComplexObject() {\n    ComplexObject complexObject = new ComplexObject();\n\n    complexObject.setId(1);\n    complexObject.setName(\"Complex Object\");\n    complexObject.setValue(3.14);\n\n    int[] numbers = {1, 2, 3, 4, 5};\n    complexObject.setNumbers(numbers);\n\n    Long[] longNumbers = {10086L, 10087L, 10088L, 10089L, 10090L, 10091L};\n    complexObject.setLongNumbers(longNumbers);\n\n    ComplexObject.NestedObject nestedObject = new ComplexObject.NestedObject();\n    nestedObject.setNestedId(10);\n    nestedObject.setNestedName(\"Nested Object\");\n    nestedObject.setFlag(true);\n    complexObject.setNestedObject(nestedObject);\n\n    List<String> stringList = new ArrayList<>();\n    stringList.add(\"foo\");\n    stringList.add(\"bar\");\n    stringList.add(\"baz\");\n    complexObject.setStringList(stringList);\n\n    Map<String, Integer> stringIntegerMap = new HashMap<>();\n    stringIntegerMap.put(\"one\", 1);\n    stringIntegerMap.put(\"two\", 2);\n    complexObject.setStringIntegerMap(stringIntegerMap);\n\n    complexObject.setDoubleArray(new Double[]{1.0, 2.0, 3.0});\n    complexObject.setComplexArray(null);\n    complexObject.setCollection(Arrays.asList(\"element1\", \"element2\"));\n\n    ComplexObject[] complexArray = new ComplexObject[2];\n    ComplexObject complexObject1 = new ComplexObject();\n    complexObject1.setId(2);\n    complexObject1.setName(\"Complex Object 1\");\n    complexObject1.setValue(2.71);\n\n    ComplexObject complexObject2 = new ComplexObject();\n    complexObject2.setId(3);\n    complexObject2.setName(\"Complex Object 2\");\n    complexObject2.setValue(1.618);\n\n    complexArray[0] = complexObject1;\n    complexArray[1] = complexObject2;\n    complexObject.setComplexArray(complexArray);\n\n    int[][] multiDimensionalArray = {{1, 2, 3}, {4, 5, 6}};\n    complexObject.setMultiDimensionalArray(multiDimensionalArray);\n\n    String[] stringArray = {\"Hello\", \"World\"};\n    complexObject.setStringArray(stringArray);\n\n    System.out.println(complexObject);\n    return complexObject;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "201", "src_id": "M1644", "code": "\n@Override\nprotected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws URISyntaxException, IOException {\n    String uri = new URI(request.uri()).getPath();\n    if (\"/favicon.ico\".equals(uri)) {\n        return;\n    }\n    if (\"/\".equals(uri)) {\n        uri = \"/index.html\";\n    }\n\n    String path = Paths.get(STATIC_LOCATION, uri).toString();\n    File file = new File(path);\n\n    if (HttpUtil.is100ContinueExpected(request)) {\n        send100Continue(ctx);\n    }\n\n    if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n        sendNotFound(ctx);\n        return;\n    }\n\n    final RandomAccessFile randomAccessFile;\n    try {\n        randomAccessFile = new RandomAccessFile(file, \"r\");\n    } catch (FileNotFoundException e) {\n        sendNotFound(ctx);\n        throw new RuntimeException(e);\n    }\n\n    HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n\n    if (path.endsWith(\".html\")) {\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=UTF-8\");\n    } else if (path.endsWith(\".js\")) {\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-javascript\");\n    } else if (path.endsWith(\".css\")) {\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/css; charset=UTF-8\");\n    } else {\n        MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap();\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, mimetypesFileTypeMap.getContentType(path));\n    }\n\n    boolean keepAlive = HttpUtil.isKeepAlive(request);\n    if (keepAlive) {\n        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, randomAccessFile.length());\n        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n    }\n    ctx.write(response);\n\n    ChannelFuture sendFileFuture;\n    ChannelFuture lastContentFuture;\n    if (ctx.pipeline().get(SslHandler.class) == null) {\n        sendFileFuture = ctx.write(new DefaultFileRegion(randomAccessFile.getChannel(), 0, randomAccessFile.length()), ctx.newProgressivePromise());\n        lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n    } else {\n        sendFileFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(randomAccessFile, 0, randomAccessFile.length(), 10 * 1024 * 1024)),\n            ctx.newProgressivePromise());\n        lastContentFuture = sendFileFuture;\n    }\n\n    sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n        @Override\n        public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n            if (total < 0) {\n                logger.info(future.channel() + \" Transfer progress: \" + progress);\n            } else {\n                logger.info(future.channel() + \" Transfer progress: \" + progress + \" / \" + total);\n            }\n        }\n\n        @Override\n        public void operationComplete(ChannelProgressiveFuture future) {\n            logger.info(future.channel() + \" Transfer complete.\");\n        }\n    });\n\n    if (!HttpUtil.isKeepAlive(request)) {\n        lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "202", "src_id": "M1580", "code": "\n@Override\npublic void query(ObjectQuery query, StreamObserver<ObjectQueryResult> responseObserver) {\n    if (vmTool == null) {\n        throw Status.UNAVAILABLE.withDescription(\"vmtool can not work\").asRuntimeException();\n    }\n    ArthasStreamObserver<ObjectQueryResult> arthasStreamObserver = new ArthasStreamObserverImpl<>(responseObserver, null, grpcJobController);\n    String className = query.getClassName();\n    String classLoaderHash = query.getClassLoaderHash();\n    String classLoaderClass = query.getClassLoaderClass();\n    int limit = query.getLimit();\n    int depth = query.getDepth();\n    String express = query.getExpress();\n    String resultExpress = query.getResultExpress();\n\n    if (isEmpty(classLoaderHash) && isEmpty(classLoaderClass)) {\n        List<Class<?>> foundClassList = new ArrayList<>();\n        for (Class<?> cls : inst.getAllLoadedClasses()) {\n            if (cls.getName().equals(className)) {\n                foundClassList.add(cls);\n            }\n        }\n\n        if (foundClassList.isEmpty()) {\n            arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n                .setMessage(\"can not find class: \" + className).build());\n            arthasStreamObserver.onCompleted();\n            return;\n        } else if (foundClassList.size() > 1) {\n            String message = \"found more than one class: \" + className;\n            arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false).setMessage(message).build());\n            arthasStreamObserver.onCompleted();\n            return;\n        } else {\n            Object[] instances = vmTool.getInstances(foundClassList.get(0), limit);\n            Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n            \n            Object value = null;\n            if (!isEmpty(express)) {\n                Express unpooledExpress = ExpressFactory.unpooledExpress(foundClassList.get(0).getClassLoader());\n                try {\n                    value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n                } catch (ExpressException e) {\n                    logger.warn(\"ognl: failed execute express: \" + express, e);\n                }\n            }\n            if (value != null && !isEmpty(resultExpress)) {\n                try {\n                    value = ExpressFactory.threadLocalExpress(value).bind(Constants.COST_VARIABLE, 0.0).get(resultExpress);\n                } catch (ExpressException e) {\n                    logger.warn(\"ognl: failed execute result express: \" + express, e);\n                }\n            }\n            JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n            builder.addObjects(javaObject);\n            arthasStreamObserver.onNext(builder.build());\n            arthasStreamObserver.onCompleted();\n            return;\n        }\n    }\n\n    Class<?> foundClass = null;\n    for (Class<?> cls : inst.getAllLoadedClasses()) {\n        if (!cls.getName().equals(className)) {\n            continue;\n        }\n\n        ClassLoader classLoader = cls.getClassLoader();\n        if (classLoader == null) {\n            continue;\n        }\n\n        if (!isEmpty(classLoaderHash)) {\n            String hex = Integer.toHexString(classLoader.hashCode());\n            if (classLoaderHash.equals(hex)) {\n                foundClass = cls;\n                break;\n            }\n        }\n\n        if (!isEmpty(classLoaderClass) && classLoaderClass.equals(classLoader.getClass().getName())) {\n            foundClass = cls;\n            break;\n        }\n    }\n\n    if (foundClass == null) {\n        arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n            .setMessage(\"can not find class: \" + className).build());\n        arthasStreamObserver.onCompleted();\n        return;\n    }\n\n    Object[] instances = vmTool.getInstances(foundClass, limit);\n    Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n    \n    Object value = null;\n    if (!isEmpty(express)) {\n        Express unpooledExpress = ExpressFactory.unpooledExpress(foundClass.getClassLoader());\n        try {\n            value = unpooledExpress.bind(new InstancesWrapper(instances)).get(express);\n        } catch (ExpressException e) {\n            logger.warn(\"ognl: failed execute express: \" + express, e);\n        }\n    }\n    if (value != null && !isEmpty(resultExpress)) {\n        try {\n            value = ExpressFactory.threadLocalExpress(value).bind(Constants.COST_VARIABLE, 0.0).get(resultExpress);\n        } catch (ExpressException e) {\n            logger.warn(\"ognl: failed execute result express: \" + express, e);\n        }\n    }\n    JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, depth);\n    builder.addObjects(javaObject);\n    arthasStreamObserver.onNext(builder.build());\n    arthasStreamObserver.onCompleted();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "203", "src_id": "M1566", "code": "\npublic GrpcResultViewResolver registerView(GrpcResultView view) {\n    Class cls = getModelClass(view);\n    if (cls == null) {\n        throw new NullPointerException(\"model class is null\");\n    }\n    return registerView(cls, view);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "204", "src_id": "M1613", "code": "\nprivate List<Pair<Class<?>, String>> filter(Set<Class<?>> classes) {\n    List<Pair<Class<?>, String>> filteredClasses = new ArrayList<Pair<Class<?>, String>>();\n    final Iterator<Class<?>> it = classes.iterator();\n    while (it.hasNext()) {\n        final Class<?> cls = it.next();\n        boolean removeFlag = false;\n        if (null == cls) {\n            removeFlag = true;\n        } else if (isUnsafeClass(cls)) {\n            filteredClasses.add(new Pair<Class<?>, String>(cls, \"class loaded by Bootstrap Classloader, try to execute `options unsafe true`\"));\n            removeFlag = true;\n        } else if (isExclude(cls)) {\n            filteredClasses.add(new Pair<Class<?>, String>(cls, \"class is excluded\"));\n            removeFlag = true;\n        } else {\n            Pair<Boolean, String> unsupportedResult = isUnsupportedClass(cls);\n            if (unsupportedResult.getFirst()) {\n                filteredClasses.add(new Pair<Class<?>, String>(cls, unsupportedResult.getSecond()));\n                removeFlag = true;\n            }\n        }\n        if (removeFlag) {\n            it.remove();\n        }\n    }\n    return filteredClasses;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "205", "src_id": "M1594", "code": "\n@Override\npublic void atInvokeException(Class<?> cls, String invokeInfo, Object target, Throwable throwable) {\n    ClassLoader classLoader = cls.getClassLoader();\n    String[] info = StringUtils.splitInvokeInfo(invokeInfo);\n    String owner = info[0];\n    String methodName = info[1];\n    String methodDesc = info[2];\n\n    List<AdviceListener> listeners = com.taobao.arthas.grpcweb.grpc.service.advisor.AdviceListenerManager.queryTraceAdviceListeners(classLoader, cls.getName(),\n        owner, methodName, methodDesc);\n\n    if (listeners != null) {\n        for (AdviceListener adviceListener : listeners) {\n            try {\n                if (skipAdviceListener(adviceListener)) {\n                    continue;\n                }\n                final InvokeTraceable listener = (InvokeTraceable) adviceListener;\n                listener.invokeThrowTracing(classLoader, owner, methodName, methodDesc, Integer.parseInt(info[3]));\n            } catch (Throwable e) {\n                logger.error(\"class: {}, invokeInfo: {}\", cls.getName(), invokeInfo, e);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "206", "src_id": "M917", "code": "\n@Option(longName = \"maxage\")\n@Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\npublic void setMaxAge(String maxAge) {\n    this.maxAge = maxAge;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "207", "src_id": "M920", "code": "\n@Option(longName = \"state\")\n@Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\npublic void setState(String state) {\n    this.state = state;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "208", "src_id": "M912", "code": "\n@Option(shortName = \"s\", longName = \"settings\")\n@Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING , default)\")\npublic void setSettings(String settings) {\n    this.settings = settings;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "209", "src_id": "M916", "code": "\n@Option(shortName = \"f\", longName = \"filename\")\n@Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\npublic void setFilename(String filename) {\n    this.filename = filename;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "220", "src_id": "M1539", "code": "\n@Override\npublic void onError(Throwable t) {\n    Status s = Status.fromThrowable(t);\n    sendResponse.writeError(s);\n    latch.countDown();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "221", "src_id": "M1555", "code": "\nstatic Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n    Map<String, String> map = new HashMap<>();\n    for (String key : trailer.keys()) {\n        if (EXCLUDED.contains(key.toLowerCase())) {\n            continue;\n        }\n        if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n            // TODO allow any object type here\n            byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n            map.put(key, new String(value));\n        } else {\n            String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n            map.put(key, value);\n        }\n    }\n    return map;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "222", "src_id": "M1553", "code": "\npublic byte[] getPrefix(byte[] in, Type type) {\n    int len = in.length;\n    return new byte[] {\n        type.value,\n        (byte) ((len >> 24) & 0xff),\n        (byte) ((len >> 16) & 0xff),\n        (byte) ((len >> 8) & 0xff),\n        (byte) ((len >> 0) & 0xff),\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "223", "src_id": "M1538", "code": "\nprivate Method getRpcMethod(Object stub, String rpcMethodName) {\n    for (Method m : stub.getClass().getMethods()) {\n        if (m.getName().equals(rpcMethodName)) {\n            return m;\n        }\n    }\n    throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "224", "src_id": "M1535", "code": "\nprivate Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n    // pathInfo starts with \"/\". ignore that first char.\n    String[] rpcClassAndMethodTokens = pathInfo.substring(1).split(\"/\");\n    if (rpcClassAndMethodTokens.length != 2) {\n        throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n    }\n\n    String rpcClassName = rpcClassAndMethodTokens[0];\n    String rpcMethodNameRecvd = rpcClassAndMethodTokens[1];\n    String rpcMethodName = rpcMethodNameRecvd.substring(0, 1).toLowerCase() + rpcMethodNameRecvd.substring(1);\n    return new Pair<>(rpcClassName, rpcMethodName);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "225", "src_id": "M1530", "code": "\n@Override\npublic boolean isEndOfInput() throws Exception {\n    if (input.isEndOfInput()) {\n        // Only end of input after last HTTP chunk has been sent\n        return true;\n    } else {\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "226", "src_id": "M308", "code": "\n        HashEntry<K, V> nextEntry() {\n            do {\n                if (nextEntry == null) {\n                    throw new NoSuchElementException();\n                }\n                lastReturned = nextEntry;\n                currentKey = lastReturned.key();\n                advance();\n            } while (currentKey == null); // Skip GC'd keys\n            return lastReturned;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "227", "src_id": "M1284", "code": "\n        @AtInvoke(\n            name = \"\",\n            inline = true,\n            whenComplete = false,\n            excludes = \"java.**\"\n        )\n        public static void onInvoke(\n            @Binding.This Object target,\n            @Binding.Class Class<?> clazz,\n            @Binding.InvokeInfo String invokeInfo\n        ) {\n            SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "228", "src_id": "M947", "code": "\n    public void loggers(CommandProcess process) {\n        Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<>();\n\n        for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n            String className = clazz.getName();\n            ClassLoader classLoader = clazz.getClassLoader();\n\n            if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) {\n                continue;\n            }\n\n            if (classLoader != null) {\n                LoggerTypes loggerTypes = classLoaderLoggerMap.computeIfAbsent(classLoader, k -> new LoggerTypes());\n                updateLoggerType(loggerTypes, classLoader, className);\n            }\n        }\n\n        for (Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n            ClassLoader classLoader = entry.getKey();\n            LoggerTypes loggerTypes = entry.getValue();\n\n            if (loggerTypes.contains(LoggerType.LOG4J)) {\n                process.appendResult(new LoggerModel(loggerInfo(classLoader, Log4jHelper.class)));\n            }\n            if (loggerTypes.contains(LoggerType.LOGBACK)) {\n                process.appendResult(new LoggerModel(loggerInfo(classLoader, LogbackHelper.class)));\n            }\n            if (loggerTypes.contains(LoggerType.LOG4J2)) {\n                process.appendResult(new LoggerModel(loggerInfo(classLoader, Log4j2Helper.class)));\n            }\n        }\n\n        process.end();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "229", "src_id": "M249", "code": "\n    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) throws URISyntaxException {\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n\n        String appName = parameters.getOrDefault(URIConstans.APP_NAME, Collections.emptyList())\n                                  .stream()\n                                  .findFirst()\n                                  .orElse(null);\n\n        String id = appName != null \n            ? appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase()\n            : RandomStringUtils.random(20, true, true).toUpperCase();\n\n        id = parameters.getOrDefault(URIConstans.ID, Collections.emptyList())\n                       .stream()\n                       .findFirst()\n                       .orElse(id);\n\n        String arthasVersion = parameters.getOrDefault(URIConstans.ARTHAS_VERSION, Collections.emptyList())\n                                         .stream()\n                                         .findFirst()\n                                         .orElse(null);\n\n        URI responseUri = UriComponentsBuilder.newInstance()\n            .scheme(URIConstans.RESPONSE)\n            .path(\"/\")\n            .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n            .queryParam(URIConstans.ID, id)\n            .build()\n            .encode()\n            .toUri();\n\n        AgentInfo info = new AgentInfo();\n        String host = HttpUtils.findClientIP(handshake.requestHeaders());\n\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inet = (InetSocketAddress) remoteAddress;\n                info.setHost(inet.getHostString());\n                info.setPort(inet.getPort());\n            }\n        } else {\n            info.setHost(host);\n            Optional.ofNullable(HttpUtils.findClientPort(handshake.requestHeaders()))\n                   .ifPresent(info::setPort);\n        }\n\n        info.setChannelHandlerContext(ctx);\n        Optional.ofNullable(arthasVersion).ifPresent(info::setArthasVersion);\n\n        tunnelServer.addAgent(id, info);\n        ctx.channel().closeFuture().addListener((GenericFutureListener<Future<? super Void>>) future -> \n            tunnelServer.removeAgent(id)\n        );\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "230", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect) throws SSLException, URISyntaxException, InterruptedException {\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n                   .addParam(URIConstans.ARTHAS_VERSION, this.version);\n        \n        if (appName != null) queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        if (id != null) queryEncoder.addParam(URIConstans.ID, id);\n\n        final URI agentRegisterURI = queryEncoder.toUri();\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = Optional.ofNullable(agentRegisterURI.getScheme()).orElse(\"ws\");\n        String host = Optional.ofNullable(agentRegisterURI.getHost()).orElse(\"127.0.0.1\");\n        int port = agentRegisterURI.getPort() != -1 ? agentRegisterURI.getPort() :\n            \"wss\".equalsIgnoreCase(scheme) ? 443 : 80;\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n        }\n\n        SslContext sslCtx = \"wss\".equalsIgnoreCase(scheme)\n            ? SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build()\n            : null;\n\n        WebSocketClientProtocolHandler websocketClientHandler = new WebSocketClientProtocolHandler(\n            WebSocketClientProtocolConfig.newBuilder()\n                .webSocketUri(agentRegisterURI)\n                .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH)\n                .build()\n        );\n\n        Bootstrap bs = new Bootstrap();\n        bs.group(eventLoopGroup)\n            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n            .option(ChannelOption.TCP_NODELAY, true)\n            .channel(NioSocketChannel.class)\n            .remoteAddress(host, port)\n            .handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) {\n                    ChannelPipeline p = ch.pipeline();\n                    if (sslCtx != null) {\n                        p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                    }\n                    p.addLast(\n                        new HttpClientCodec(),\n                        new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                        websocketClientHandler,\n                        new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                        new TunnelClientSocketClientHandler(TunnelClient.this)\n                    );\n                }\n            });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(future -> {\n                if (future.cause() != null) {\n                    logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n                }\n            });\n        }\n        return connectFuture.sync();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "231", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[]{\n            0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x65,\n            // ... (remaining byte array elements unchanged)\n            0x2e, 0x2e, 0x2e, 0x0a\n        };\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "232", "src_id": "M124", "code": "\n    @Override\n    public int read() throws IOException {\n        synchronized (__queue) {\n            while (true) {\n                if (__ioException != null) {\n                    IOException e = __ioException;\n                    __ioException = null;\n                    throw e;\n                }\n\n                if (__bytesAvailable == 0) {\n                    if (__hasReachedEOF) return EOF;\n                    \n                    if (__threaded) {\n                        __queue.notify();\n                        try {\n                            __readIsWaiting = true;\n                            __queue.wait();\n                            __readIsWaiting = false;\n                        } catch (InterruptedException e) {\n                            throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                        }\n                    } else {\n                        __readIsWaiting = true;\n                        try {\n                            int ch;\n                            do {\n                                ch = __read(true);\n                                if (ch < 0 && ch != WOULD_BLOCK) return ch;\n                                if (ch != WOULD_BLOCK) __processChar(ch);\n                            } while (super.available() > 0 && __bytesAvailable < __queue.length - 1);\n                        } finally {\n                            __readIsWaiting = false;\n                        }\n                    }\n                    continue;\n                }\n\n                int ch = __queue[__queueHead];\n                __queueHead = (__queueHead + 1) % __queue.length;\n                __bytesAvailable--;\n                \n                if (__bytesAvailable == 0 && __threaded) {\n                    __queue.notify();\n                }\n                return ch;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "233", "src_id": "M786", "code": "\n    @Override\n    public void process(CommandProcess process) {\n        initTransformer();\n        Instrumentation inst = process.session().getInstrumentation();\n        RetransformModel retransformModel = new RetransformModel();\n\n        if (this.list) {\n            retransformModel.setRetransformEntries(allRetransformEntries());\n            process.appendResult(retransformModel).end();\n            return;\n        }\n        if (this.deleteAll) {\n            deleteAllRetransformEntry();\n            process.appendResult(retransformModel).end();\n            return;\n        }\n        if (this.delete > 0) {\n            deleteRetransformEntry(this.delete);\n            process.end();\n            return;\n        }\n        if (this.classPattern != null) {\n            Set<Class<?>> classes = SearchUtils.searchClass(inst, classPattern, false, this.hashCode);\n            if (classes.isEmpty()) {\n                process.end(-1, \"Classes not found: \" + classPattern);\n                return;\n            }\n            if (classes.size() > limit) {\n                process.end(-1, \"Matched \" + classes.size() + \" classes exceeds limit \" + limit);\n                return;\n            }\n            try {\n                inst.retransformClasses(classes.toArray(new Class[0]));\n                classes.forEach(c -> retransformModel.addRetransformClass(c.getName()));\n                process.appendResult(retransformModel).end();\n            } catch (Throwable e) {\n                process.end(-1, \"Retransform error: \" + e);\n            }\n            return;\n        }\n\n        Map<String, byte[]> bytesMap = new HashMap<>();\n        for (String path : paths) {\n            try (RandomAccessFile f = new RandomAccessFile(path, \"r\")) {\n                byte[] bytes = new byte[(int) f.length()];\n                f.readFully(bytes);\n                bytesMap.put(readClassName(bytes), bytes);\n            } catch (Exception e) {\n                process.end(-1, \"File error: \" + path + \" - \" + e);\n                return;\n            }\n        }\n\n        List<Class<?>> classList = new ArrayList<>();\n        List<RetransformEntry> entries = new ArrayList<>();\n        \n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (!bytesMap.containsKey(clazz.getName())) continue;\n\n            if (hashCode == null && classLoaderClass != null) {\n                List<ClassLoader> loaders = ClassLoaderUtils.getClassLoaderByClassName(inst, classLoaderClass);\n                if (loaders.size() != 1) {\n                    retransformModel.setClassLoaderClass(classLoaderClass)\n                                   .setMatchedClassLoaders(ClassUtils.createClassLoaderVOList(loaders));\n                    process.appendResult(retransformModel)\n                          .end(-1, loaders.isEmpty() ? \"No classloader found\" : \"Ambiguous classloader\");\n                    return;\n                }\n                hashCode = Integer.toHexString(loaders.get(0).hashCode());\n            }\n\n            ClassLoader loader = clazz.getClassLoader();\n            if (loader != null && hashCode != null && \n                !Integer.toHexString(loader.hashCode()).equals(hashCode)) continue;\n\n            entries.add(new RetransformEntry(clazz.getName(), bytesMap.get(clazz.getName()), \n                                           hashCode, classLoaderClass));\n            classList.add(clazz);\n            retransformModel.addRetransformClass(clazz.getName());\n        }\n\n        try {\n            if (entries.isEmpty()) {\n                process.end(-1, \"Classes not loaded: \" + bytesMap.keySet());\n                return;\n            }\n            addRetransformEntry(entries);\n            inst.retransformClasses(classList.toArray(new Class[0]));\n            process.appendResult(retransformModel).end();\n        } catch (Throwable e) {\n            process.end(-1, \"Retransform failed: \" + e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "234", "src_id": "M278", "code": "\n        V get(Object key, int hash) {\n            if (count != 0) {\n                for (HashEntry<K, V> e = getFirst(hash); e != null; e = e.next) {\n                    if (e.hash == hash && keyEq(key, e.key())) {\n                        Object valueRef = e.valueRef;\n                        if (valueRef != null) return e.dereferenceValue(valueRef);\n                        return readValueUnderLock(e);\n                    }\n                }\n            }\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "235", "src_id": "M184", "code": "\n                @Override\n                protected void initChannel(LocalChannel ch) {\n                    ch.pipeline().addLast(\n                        new HttpClientCodec(),\n                        new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                        new HttpProxyClientHandler(httpResponsePromise)\n                    );\n                }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "236", "src_id": "M1643", "code": "\npublic void start() throws InterruptedException {\n    NioEventLoopGroup boss = new NioEventLoopGroup(1);\n    NioEventLoopGroup work = new NioEventLoopGroup();\n    try {\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new NettyHttpInitializer(STATIC_LOCATION))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n        logger.info(\"start http server on port: {}\", port);\n        ChannelFuture future = serverBootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    } finally {\n        work.shutdownGracefully();\n        boss.shutdownGracefully();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "237", "src_id": "M1614", "code": "\nprivate boolean isExclude(Class<?> clazz) {\n    return classNameExcludeMatcher != null \n        ? classNameExcludeMatcher.matching(clazz.getName())\n        : false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "238", "src_id": "M1632", "code": "\npublic void parseRequestParams(WatchRequest watchRequest) {\n    classPattern = watchRequest.getClassPattern();\n    methodPattern = watchRequest.getMethodPattern();\n    express = StringUtils.isEmpty(watchRequest.getExpress()) \n        ? \"{params, target, returnObj}\" \n        : watchRequest.getExpress();\n    conditionExpress = watchRequest.getConditionExpress();\n    isBefore = watchRequest.getIsBefore();\n    isFinish = watchRequest.getIsFinish();\n    isException = watchRequest.getIsException();\n    isSuccess = watchRequest.getIsSuccess();\n    \n    if (!isBefore && !isFinish && !isException && !isSuccess) {\n        isFinish = true;\n    }\n    \n    expand = watchRequest.getExpand() <= 0 ? 1 \n        : watchRequest.getExpand() > MAX_EXPAND ? MAX_EXPAND \n        : watchRequest.getExpand();\n        \n    sizeLimit = watchRequest.getSizeLimit() == 0 \n        ? 10 * 1024 * 1024 \n        : watchRequest.getSizeLimit();\n        \n    isRegEx = watchRequest.getIsRegEx();\n    \n    numberOfLimit = watchRequest.getNumberOfLimit() == 0 \n        ? 100 \n        : watchRequest.getNumberOfLimit();\n        \n    excludeClassPattern = StringUtils.isEmpty(watchRequest.getExcludeClassPattern()) \n        ? null \n        : watchRequest.getExcludeClassPattern();\n        \n    listenerId = watchRequest.getListenerId();\n    verbose = watchRequest.getVerbose();\n    \n    maxNumOfMatchedClass = watchRequest.getMaxNumOfMatchedClass() == 0 \n        ? 50 \n        : watchRequest.getMaxNumOfMatchedClass();\n        \n    jobId = watchRequest.getJobId();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "239", "src_id": "M1616", "code": "\npublic synchronized EnhancerAffect enhance(Instrumentation inst, int maxNumOfMatchedClass) throws UnmodifiableClassException {\n    matchingClasses = GlobalOptions.isDisableSubClass\n        ? SearchUtils.searchClass(inst, classNameMatcher)\n        : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n    if (matchingClasses.size() > maxNumOfMatchedClass) {\n        affect.setOverLimitMsg(\"The number of matched classes is \" + matchingClasses.size() \n            + \", greater than the limit value \" + maxNumOfMatchedClass \n            + \". Try to change the limit with option '-m <arg>'.\");\n        return affect;\n    }\n\n    List<Pair<Class<?>, String>> filtedList = filter(matchingClasses);\n    for (Pair<Class<?>, String> filted : filtedList) {\n        logger.info(\"ignore class: {}, reason: {}\", filted.getFirst().getName(), filted.getSecond());\n    }\n\n    logger.info(\"enhance matched classes: {}\", matchingClasses);\n    affect.setTransformer(this);\n\n    try {\n        DemoBootstrap.getRunningInstance().getTransformerManager().addTransformer(this, isTracing);\n\n        if (GlobalOptions.isBatchReTransform) {\n            Class<?>[] classArray = matchingClasses.toArray(new Class<?>[0]);\n            if (classArray.length > 0) {\n                inst.retransformClasses(classArray);\n                logger.info(\"Success to batch transform classes: {}\", Arrays.toString(classArray));\n            }\n        } else {\n            for (Class<?> clazz : matchingClasses) {\n                try {\n                    inst.retransformClasses(clazz);\n                    logger.info(\"Success to transform class: {}\", clazz);\n                } catch (Throwable t) {\n                    logger.warn(\"retransform {} failed.\", clazz, t);\n                    if (t instanceof UnmodifiableClassException) {\n                        throw (UnmodifiableClassException) t;\n                    }\n                    throw new RuntimeException(t);\n                }\n            }\n        }\n    } catch (Throwable e) {\n        logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n        affect.setThrowable(e);\n    }\n    return affect;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "240", "src_id": "M1579", "code": "\npublic static ComplexObject createComplexObject() {\n    ComplexObject complexObject = new ComplexObject();\n    complexObject.setId(1);\n    complexObject.setName(\"Complex Object\");\n    complexObject.setValue(3.14);\n\n    complexObject.setNumbers(new int[]{1, 2, 3, 4, 5});\n    complexObject.setLongNumbers(new Long[]{10086L, 10087L, 10088L, 10089L, 10090L, 10091L});\n\n    ComplexObject.NestedObject nestedObject = new ComplexObject.NestedObject();\n    nestedObject.setNestedId(10);\n    nestedObject.setNestedName(\"Nested Object\");\n    nestedObject.setFlag(true);\n    complexObject.setNestedObject(nestedObject);\n\n    complexObject.setStringList(new ArrayList<>(Arrays.asList(\"foo\", \"bar\", \"baz\")));\n    complexObject.setStringIntegerMap(new HashMap<String, Integer>() {{\n        put(\"one\", 1);\n        put(\"two\", 2);\n    }});\n    complexObject.setDoubleArray(new Double[]{1.0, 2.0, 3.0});\n\n    ComplexObject[] complexArray = new ComplexObject[2];\n    ComplexObject obj1 = new ComplexObject();\n    obj1.setId(2);\n    obj1.setName(\"Complex Object 1\");\n    obj1.setValue(2.71);\n\n    ComplexObject obj2 = new ComplexObject();\n    obj2.setId(3);\n    obj2.setName(\"Complex Object 2\");\n    obj2.setValue(1.618);\n\n    complexArray[0] = obj1;\n    complexArray[1] = obj2;\n    complexObject.setComplexArray(complexArray);\n\n    complexObject.setMultiDimensionalArray(new int[][]{{1, 2, 3}, {4, 5, 6}});\n    complexObject.setStringArray(new String[]{\"Hello\", \"World\"});\n\n    return complexObject;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "241", "src_id": "M1644", "code": "\n@Override\nprotected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws URISyntaxException, IOException {\n    String uri = new URI(request.uri()).getPath();\n    if (\"/favicon.ico\".equals(uri)) return;\n    if (\"/\".equals(uri)) uri = \"/index.html\";\n    \n    String path = Paths.get(STATIC_LOCATION, uri).toString();\n    File file = new File(path);\n    \n    if (HttpUtil.is100ContinueExpected(request)) {\n        send100Continue(ctx);\n    }\n    \n    if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n        sendNotFound(ctx);\n        return;\n    }\n\n    try (RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\")) {\n        HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n        String contentType = \"text/plain\";\n        if (path.endsWith(\".html\")) {\n            contentType = \"text/html; charset=UTF-8\";\n        } else if (path.endsWith(\".js\")) {\n            contentType = \"application/x-javascript\";\n        } else if (path.endsWith(\".css\")) {\n            contentType = \"text/css; charset=UTF-8\";\n        } else {\n            contentType = new MimetypesFileTypeMap().getContentType(path);\n        }\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n\n        boolean keepAlive = HttpUtil.isKeepAlive(request);\n        if (keepAlive) {\n            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, randomAccessFile.length());\n            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n        }\n\n        ctx.write(response);\n        ChannelFuture sendFileFuture;\n        if (ctx.pipeline().get(SslHandler.class) == null) {\n            sendFileFuture = ctx.write(new DefaultFileRegion(randomAccessFile.getChannel(), 0, randomAccessFile.length()), ctx.newProgressivePromise());\n            ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n        } else {\n            sendFileFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(randomAccessFile, 0, randomAccessFile.length(), 10 * 1024 * 1024)),\n                    ctx.newProgressivePromise());\n        }\n\n        sendFileFuture.addListener((ChannelProgressiveFutureListener) future -> {\n            if (future.isSuccess()) {\n                logger.info(\"{} Transfer complete.\", future.channel());\n            }\n        });\n\n        if (!keepAlive) {\n            sendFileFuture.addListener(ChannelFutureListener.CLOSE);\n        }\n    } catch (FileNotFoundException e) {\n        sendNotFound(ctx);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "242", "src_id": "M1580", "code": "\n@Override\npublic void query(ObjectQuery query, StreamObserver<ObjectQueryResult> responseObserver) {\n    if (vmTool == null) {\n        throw Status.UNAVAILABLE.withDescription(\"vmtool unavailable\").asRuntimeException();\n    }\n    \n    ArthasStreamObserver<ObjectQueryResult> arthasStreamObserver = new ArthasStreamObserverImpl<>(responseObserver, null, grpcJobController);\n    String className = query.getClassName();\n    String classLoaderHash = query.getClassLoaderHash();\n    String classLoaderClass = query.getClassLoaderClass();\n    \n    if (isEmpty(classLoaderHash) && isEmpty(classLoaderClass)) {\n        List<Class<?>> foundClassList = Arrays.stream(inst.getAllLoadedClasses())\n            .filter(clazz -> clazz.getName().equals(className))\n            .collect(Collectors.toList());\n\n        if (foundClassList.isEmpty()) {\n            arthasStreamObserver.onNext(buildErrorResult(\"Class not found: \" + className));\n            return;\n        } else if (foundClassList.size() > 1) {\n            arthasStreamObserver.onNext(buildErrorResult(\"Multiple classes found: \" + className));\n            return;\n        }\n        \n        processClassInstances(foundClassList.get(0), query, arthasStreamObserver);\n        return;\n    }\n\n    Class<?> foundClass = findClassWithLoader(className, classLoaderHash, classLoaderClass);\n    if (foundClass == null) {\n        arthasStreamObserver.onNext(buildErrorResult(\"Class not found: \" + className));\n        return;\n    }\n\n    processClassInstances(foundClass, query, arthasStreamObserver);\n}\n\nprivate ObjectQueryResult.Builder buildErrorResult(String message) {\n    return ObjectQueryResult.newBuilder().setSuccess(false).setMessage(message);\n}\n\nprivate void processClassInstances(Class<?> clazz, ObjectQuery query, ArthasStreamObserver<ObjectQueryResult> observer) {\n    Object[] instances = vmTool.getInstances(clazz, query.getLimit());\n    Object value = processExpressions(clazz, instances, query.getExpress(), query.getResultExpress());\n    JavaObject javaObject = JavaObjectConverter.toJavaObjectWithExpand(value, query.getDepth());\n    observer.onNext(ObjectQueryResult.newBuilder().setSuccess(true).addObjects(javaObject).build());\n    observer.onCompleted();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "243", "src_id": "M1566", "code": "\npublic GrpcResultViewResolver registerView(GrpcResultView view) {\n    Class modelClass = getModelClass(view);\n    if (modelClass == null) {\n        throw new NullPointerException(\"Model class required\");\n    }\n    return registerView(modelClass, view);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "244", "src_id": "M1613", "code": "\nprivate List<Pair<Class<?>, String>> filter(Set<Class<?>> classes) {\n    List<Pair<Class<?>, String>> filteredClasses = new ArrayList<>();\n    Iterator<Class<?>> it = classes.iterator();\n    while (it.hasNext()) {\n        Class<?> clazz = it.next();\n        boolean removeFlag = false;\n        String reason = null;\n        \n        if (clazz == null) {\n            reason = \"null class\";\n        } else if (isUnsafeClass(clazz)) {\n            reason = \"bootstrap classloader class\";\n        } else if (isExclude(clazz)) {\n            reason = \"excluded class\";\n        } else {\n            Pair<Boolean, String> result = isUnsupportedClass(clazz);\n            if (result.getFirst()) {\n                reason = result.getSecond();\n            }\n        }\n        \n        if (reason != null) {\n            filteredClasses.add(Pair.of(clazz, reason));\n            it.remove();\n        }\n    }\n    return filteredClasses;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "245", "src_id": "M1594", "code": "\n@Override\npublic void atInvokeException(Class<?> clazz, String invokeInfo, Object target, Throwable throwable) {\n    ClassLoader classLoader = clazz.getClassLoader();\n    String[] info = StringUtils.splitInvokeInfo(invokeInfo);\n    List<AdviceListener> listeners = AdviceListenerManager.queryTraceAdviceListeners(\n        classLoader, clazz.getName(), info[0], info[1], info[2]);\n\n    for (AdviceListener listener : listeners) {\n        try {\n            if (skipAdviceListener(listener)) continue;\n            ((InvokeTraceable) listener).invokeThrowTracing(\n                classLoader, info[0], info[1], info[2], Integer.parseInt(info[3]));\n        } catch (Throwable e) {\n            logger.error(\"Error handling invoke exception for class: {}\", clazz.getName(), e);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "246", "src_id": "M742", "code": "\n    @Override\n    public void complete(Completion completion) {\n        int argumentIndex = CompletionUtils.detectArgumentIndex(completion);\n        if (argumentIndex == 1) {\n            if (!completeBeanName(completion)) {\n                super.complete(completion);\n            }\n            return;\n        } else if (argumentIndex == 2) {\n            if (!completeAttributeName(completion)) {\n                super.complete(completion);\n            }\n            return;\n        }\n        super.complete(completion);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "247", "src_id": "M1452", "code": "\n    public static String retrievePreviousArg(List<CliToken> tokens, String lastToken) {\n        if (StringUtils.isBlank(lastToken) && tokens.size() > 2) {\n            // tokens = { \" \", \"CLASS_NAME\", \" \"}\n            return tokens.get(tokens.size() - 2).value();\n        } else if (tokens.size() > 3) {\n            // tokens = { \" \", \"CLASS_NAME\", \" \", \"PARTIAL_METHOD_NAME\"}\n            return tokens.get(tokens.size() - 3).value();\n        } else {\n            return Constants.EMPTY_STRING;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "248", "src_id": "M747", "code": "\n        @Override\n        public void handle(Void event) {\n            timer.cancel();\n            super.handle(event);\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "249", "src_id": "M744", "code": "\n    private boolean completeAttributeName(Completion completion) {\n        List<CliToken> tokens = completion.lineTokens();\n        String lastToken = TokenUtils.getLast(tokens).value();\n\n        if (StringUtils.isBlank(lastToken)) {\n            lastToken = \"\";\n        }\n\n        MBeanServer platformMBeanServer = ManagementFactory.getPlatformMBeanServer();\n        String beanName = TokenUtils.retrievePreviousArg(tokens, lastToken);\n        Set<ObjectName> objectNames = null;\n        try {\n            objectNames = platformMBeanServer.queryNames(new ObjectName(beanName), null);\n        } catch (MalformedObjectNameException e) {\n            logger.warn(\"queryNames error\", e);\n        }\n        if (objectNames == null || objectNames.size() == 0) {\n            return false;\n        }\n        try {\n            MBeanInfo mBeanInfo = platformMBeanServer.getMBeanInfo(objectNames.iterator().next());\n            List<String> attributeNames = new ArrayList<String>();\n            MBeanAttributeInfo[] attributes = mBeanInfo.getAttributes();\n            for (MBeanAttributeInfo attribute : attributes) {\n                if (StringUtils.isBlank(lastToken)) {\n                    attributeNames.add(attribute.getName());\n                } else if (attribute.getName().startsWith(lastToken)) {\n                    attributeNames.add(attribute.getName());\n                }\n            }\n            return CompletionUtils.complete(completion, attributeNames);\n        } catch (Throwable e) {\n            logger.warn(\"getMBeanInfo error\", e);\n        }\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "262", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, \" +\n            \"(h)ours, or (d)ays, e.g. 60m, or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "263", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "264", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. \" +\n            \"See JRE_HOME/lib/jfr (STRING , default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "265", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "266", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m (default: NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "267", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"query recordings by state (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "268", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"settings file(s), e.g. profile or default (STRING, default). See JRE_HOME/lib/jfr\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "269", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"resulting recording filename, e.g. /tmp/MyRecording.jfr\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "270", "src_id": "M917", "code": "\n    @Option(longName = \"maxage\")\n    @Description(\"Maximum time to keep recorded data (on disk) in (s)econds, \" +\n            \"(m)inutes, (h)ours, or (d)ays, e.g. 60m, \" +\n            \"or default for no limit (NANOTIME, 0)\")\n    public void setMaxAge(String maxAge) {\n        this.maxAge = maxAge;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "271", "src_id": "M920", "code": "\n    @Option(longName = \"state\")\n    @Description(\"Query recordings by sate (new, delay, running, stopped, closed)\")\n    public void setState(String state) {\n        this.state = state;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "272", "src_id": "M912", "code": "\n    @Option(shortName = \"s\", longName = \"settings\")\n    @Description(\"Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr \" +\n            \"(STRING, default)\")\n    public void setSettings(String settings) {\n        this.settings = settings;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "273", "src_id": "M916", "code": "\n    @Option(shortName = \"f\", longName = \"filename\")\n    @Description(\"Resulting recording filename, e.g. /tmp/MyRecording.jfr.\")\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "274", "src_id": "M1643", "code": "\npublic void start() throws InterruptedException {\n    NioEventLoopGroup boss = new NioEventLoopGroup(1);\n    NioEventLoopGroup work = new NioEventLoopGroup();\n    try {\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n        serverBootstrap.group(boss, work)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new NettyHttpInitializer(STATIC_LOCATION))\n                .option(ChannelOption.SO_BACKLOG, 128)\n                .childOption(ChannelOption.SO_KEEPALIVE, true);\n        logger.info(\"start http server on port: {}\", port);\n        ChannelFuture future = serverBootstrap.bind(port).sync();\n        future.channel().closeFuture().sync();\n    } finally {\n        work.shutdownGracefully();\n        boss.shutdownGracefully();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "275", "src_id": "M1614", "code": "\nprivate boolean isExclude(Class<?> clazz) {\n    if (classNameExcludeMatcher != null) {\n        return classNameExcludeMatcher.matching(clazz.getName());\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "276", "src_id": "M1632", "code": "\npublic void parseRequestParams(WatchRequest watchRequest) {\n    classPattern = watchRequest.getClassPattern();\n    methodPattern = watchRequest.getMethodPattern();\n    if (StringUtils.isEmpty(watchRequest.getExpress())) {\n        express = \"{params, target, returnObj}\";\n    } else {\n        express = watchRequest.getExpress();\n    }\n    conditionExpress = watchRequest.getConditionExpress();\n    isBefore = watchRequest.getIsBefore();\n    isFinish = watchRequest.getIsFinish();\n    isException = watchRequest.getIsException();\n    isSuccess = watchRequest.getIsSuccess();\n    if (!watchRequest.getIsBefore() && !watchRequest.getIsFinish() && !watchRequest.getIsException() && !watchRequest.getIsSuccess()) {\n        isFinish = true;\n    }\n    if (watchRequest.getExpand() <= 0) {\n        expand = 1;\n    } else if (watchRequest.getExpand() > MAX_EXPAND) {\n        expand = MAX_EXPAND;\n    } else {\n        expand = watchRequest.getExpand();\n    }\n    if (watchRequest.getSizeLimit() == 0) {\n        sizeLimit = 10 * 1024 * 1024;\n    } else {\n        sizeLimit = watchRequest.getSizeLimit();\n    }\n    isRegEx = watchRequest.getIsRegEx();\n    if (watchRequest.getNumberOfLimit() == 0) {\n        numberOfLimit = 100;\n    } else {\n        numberOfLimit = watchRequest.getNumberOfLimit();\n    }\n    if (watchRequest.getExcludeClassPattern().isEmpty()) {\n        excludeClassPattern = null;\n    } else {\n        excludeClassPattern = watchRequest.getExcludeClassPattern();\n    }\n    listenerId = watchRequest.getListenerId();\n    verbose = watchRequest.getVerbose();\n    if (watchRequest.getMaxNumOfMatchedClass() == 0) {\n        maxNumOfMatchedClass = 50;\n    } else {\n        maxNumOfMatchedClass = watchRequest.getMaxNumOfMatchedClass();\n    }\n    jobId = watchRequest.getJobId();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "277", "src_id": "M1616", "code": "\npublic synchronized EnhancerAffect enhance(Instrumentation inst, int maxNumOfMatchedClass) throws UnmodifiableClassException {\n    matchingClasses = GlobalOptions.isDisableSubClass\n            ? SearchUtils.searchClass(inst, classNameMatcher)\n            : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n    if (matchingClasses.size() > maxNumOfMatchedClass) {\n        affect.setOverLimitMsg(\"The number of matched classes is \" + matchingClasses.size() + \", greater than limit \" + maxNumOfMatchedClass + \". Try option '-m <arg>'.\");\n        return affect;\n    }\n\n    List<Pair<Class<?>, String>> filtedList = filter(matchingClasses);\n    if (!filtedList.isEmpty()) {\n        for (Pair<Class<?>, String> filted : filtedList) {\n            logger.info(\"ignore class: {}, reason: {}\", filted.getFirst().getName(), filted.getSecond());\n        }\n    }\n\n    logger.info(\"enhance matched classes: {}\", matchingClasses);\n    affect.setTransformer(this);\n\n    try {\n        DemoBootstrap.getRunningInstance().getTransformerManager().addTransformer(this, isTracing);\n\n        if (GlobalOptions.isBatchReTransform) {\n            int size = matchingClasses.size();\n            Class<?>[] classArray = new Class<?>[size];\n            arraycopy(matchingClasses.toArray(), 0, classArray, 0, size);\n            if (classArray.length > 0) {\n                inst.retransformClasses(classArray);\n                logger.info(\"Success to batch transform classes: \" + Arrays.toString(classArray));\n            }\n        } else {\n            for (Class<?> clazz : matchingClasses) {\n                try {\n                    inst.retransformClasses(clazz);\n                    logger.info(\"Success to transform class: \" + clazz);\n                } catch (Throwable t) {\n                    logger.warn(\"retransform {} failed.\", clazz, t);\n                    if (t instanceof UnmodifiableClassException) {\n                        throw (UnmodifiableClassException) t;\n                    } else if (t instanceof RuntimeException) {\n                        throw (RuntimeException) t;\n                    } else {\n                        throw new RuntimeException(t);\n                    }\n                }\n            }\n        }\n    } catch (Throwable e) {\n        logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n        affect.setThrowable(e);\n    }\n\n    return affect;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "278", "src_id": "M1579", "code": "\npublic static ComplexObject createComplexObject() {\n    ComplexObject complexObject = new ComplexObject();\n\n    complexObject.setId(1);\n    complexObject.setName(\"Complex Object\");\n    complexObject.setValue(3.14);\n\n    int[] numbers = {1, 2, 3, 4, 5};\n    complexObject.setNumbers(numbers);\n\n    Long[] longNumbers = {10086L, 10087L, 10088L, 10089L, 10090L, 10091L};\n    complexObject.setLongNumbers(longNumbers);\n\n    ComplexObject.NestedObject nestedObject = new ComplexObject.NestedObject();\n    nestedObject.setNestedId(10);\n    nestedObject.setNestedName(\"Nested Object\");\n    nestedObject.setFlag(true);\n    complexObject.setNestedObject(nestedObject);\n\n    List<String> stringList = new ArrayList<>();\n    stringList.add(\"foo\");\n    stringList.add(\"bar\");\n    stringList.add(\"baz\");\n    complexObject.setStringList(stringList);\n\n    Map<String, Integer> stringIntegerMap = new HashMap<>();\n    stringIntegerMap.put(\"one\", 1);\n    stringIntegerMap.put(\"two\", 2);\n    complexObject.setStringIntegerMap(stringIntegerMap);\n\n    complexObject.setDoubleArray(new Double[]{1.0, 2.0, 3.0});\n    complexObject.setComplexArray(null);\n    complexObject.setCollection(Arrays.asList(\"element1\", \"element2\"));\n\n    ComplexObject[] complexArray = new ComplexObject[2];\n    ComplexObject complexObject1 = new ComplexObject();\n    complexObject1.setId(2);\n    complexObject1.setName(\"Complex Object 1\");\n    complexObject1.setValue(2.71);\n\n    ComplexObject complexObject2 = new ComplexObject();\n    complexObject2.setId(3);\n    complexObject2.setName(\"Complex Object 2\");\n    complexObject2.setValue(1.618);\n\n    complexArray[0] = complexObject1;\n    complexArray[1] = complexObject2;\n    complexObject.setComplexArray(complexArray);\n\n    int[][] multiDimensionalArray = {{1, 2, 3}, {4, 5, 6}};\n    complexObject.setMultiDimensionalArray(multiDimensionalArray);\n\n    String[] stringArray = {\"Hello\", \"World\"};\n    complexObject.setStringArray(stringArray);\n\n    System.out.println(complexObject);\n    return complexObject;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "279", "src_id": "M1644", "code": "\n@Override\nprotected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws URISyntaxException, IOException {\n    String uri = new URI(request.uri()).getPath();\n    if (\"/favicon.ico\".equals(uri)) {\n        return;\n    }\n    if (\"/\".equals(uri)) {\n        uri = \"/index.html\";\n    }\n\n    String path = Paths.get(STATIC_LOCATION, uri).toString();\n    File file = new File(path);\n\n    if (HttpUtil.is100ContinueExpected(request)) {\n        send100Continue(ctx);\n    }\n\n    if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n        sendNotFound(ctx);\n        return;\n    }\n\n    final RandomAccessFile randomAccessFile;\n    try {\n        randomAccessFile = new RandomAccessFile(file, \"r\");\n    } catch (FileNotFoundException e) {\n        sendNotFound(ctx);\n        throw new RuntimeException(e);\n    }\n\n    HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n\n    if (path.endsWith(\".html\")) {\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=UTF-8\");\n    } else if (path.endsWith(\".js\")) {\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"application/x-javascript\");\n    } else if (path.endsWith(\".css\")) {\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/css; charset=UTF-8\");\n    } else {\n        MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap();\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, mimetypesFileTypeMap.getContentType(path));\n    }\n\n    boolean keepAlive = HttpUtil.isKeepAlive(request);\n    if (keepAlive) {\n        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, randomAccessFile.length());\n        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n    }\n    ctx.write(response);\n\n    ChannelFuture sendFileFuture;\n    ChannelFuture lastContentFuture;\n    if (ctx.pipeline().get(SslHandler.class) == null) {\n        sendFileFuture = ctx.write(new DefaultFileRegion(randomAccessFile.getChannel(), 0, randomAccessFile.length()), ctx.newProgressivePromise());\n        lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n    } else {\n        sendFileFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(randomAccessFile, 0, randomAccessFile.length(), 10 * 1024 * 1024)),\n                ctx.newProgressivePromise());\n        lastContentFuture = sendFileFuture;\n    }\n\n    sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n        @Override\n        public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n            if (total < 0) {\n                logger.info(\"{} Transfer progress: {}\", future.channel(), progress);\n            } else {\n                logger.info(\"{} Transfer progress: {} / {}\", future.channel(), progress, total);\n            }\n        }\n\n        @Override\n        public void operationComplete(ChannelProgressiveFuture future) {\n            logger.info(\"{} Transfer complete.\", future.channel());\n        }\n    });\n\n    if (!keepAlive) {\n        lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "280", "src_id": "M1580", "code": "\n@Override\npublic void query(ObjectQuery query, StreamObserver<ObjectQueryResult> responseObserver) {\n    if (vmTool == null) {\n        throw Status.UNAVAILABLE.withDescription(\"vmtool unavailable\").asRuntimeException();\n    }\n    \n    ArthasStreamObserver<ObjectQueryResult> arthasStreamObserver = new ArthasStreamObserverImpl<>(responseObserver, null, grpcJobController);\n    String className = query.getClassName();\n    String classLoaderHash = query.getClassLoaderHash();\n    String classLoaderClass = query.getClassLoaderClass();\n    int limit = query.getLimit();\n    int depth = query.getDepth();\n    String express = query.getExpress();\n    String resultExpress = query.getResultExpress();\n\n    if (isEmpty(classLoaderHash) && isEmpty(classLoaderClass)) {\n        List<Class<?>> foundClassList = new ArrayList<>();\n        for (Class<?> clazz : inst.getAllLoadedClasses()) {\n            if (clazz.getName().equals(className)) {\n                foundClassList.add(clazz);\n            }\n        }\n\n        if (foundClassList.isEmpty()) {\n            arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n                    .setMessage(\"Class not found: \" + className).build());\n            arthasStreamObserver.onCompleted();\n            return;\n        } else if (foundClassList.size() > 1) {\n            arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n                    .setMessage(\"Multiple classes found: \" + className).build());\n            arthasStreamObserver.onCompleted();\n            return;\n        } else {\n            Object[] instances = vmTool.getInstances(foundClassList.get(0), limit);\n            Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n            \n            Object value = null;\n            if (!isEmpty(express)) {\n                try {\n                    value = ExpressFactory.unpooledExpress(foundClassList.get(0).getClassLoader())\n                            .bind(new InstancesWrapper(instances))\n                            .get(express);\n                } catch (ExpressException e) {\n                    logger.warn(\"OGNL error: {}\", express, e);\n                }\n            }\n            \n            if (value != null && !isEmpty(resultExpress)) {\n                try {\n                    value = ExpressFactory.threadLocalExpress(value)\n                            .bind(Constants.COST_VARIABLE, 0.0)\n                            .get(resultExpress);\n                } catch (ExpressException e) {\n                    logger.warn(\"OGNL error: {}\", resultExpress, e);\n                }\n            }\n            \n            builder.addObjects(JavaObjectConverter.toJavaObjectWithExpand(value, depth));\n            arthasStreamObserver.onNext(builder.build());\n            arthasStreamObserver.onCompleted();\n            return;\n        }\n    }\n\n    Class<?> foundClass = null;\n    for (Class<?> clazz : inst.getAllLoadedClasses()) {\n        if (!clazz.getName().equals(className)) continue;\n\n        ClassLoader classLoader = clazz.getClassLoader();\n        if (classLoader == null) continue;\n\n        if (!isEmpty(classLoaderHash)) {\n            String hex = Integer.toHexString(classLoader.hashCode());\n            if (classLoaderHash.equals(hex)) {\n                foundClass = clazz;\n                break;\n            }\n        }\n\n        if (!isEmpty(classLoaderClass) && classLoaderClass.equals(classLoader.getClass().getName())) {\n            foundClass = clazz;\n            break;\n        }\n    }\n\n    if (foundClass == null) {\n        arthasStreamObserver.onNext(ObjectQueryResult.newBuilder().setSuccess(false)\n                .setMessage(\"Class not found: \" + className).build());\n        arthasStreamObserver.onCompleted();\n        return;\n    }\n\n    Object[] instances = vmTool.getInstances(foundClass, limit);\n    Builder builder = ObjectQueryResult.newBuilder().setSuccess(true);\n\n    Object value = null;\n    if (!isEmpty(express)) {\n        try {\n            value = ExpressFactory.unpooledExpress(foundClass.getClassLoader())\n                    .bind(new InstancesWrapper(instances))\n                    .get(express);\n        } catch (ExpressException e) {\n            logger.warn(\"OGNL error: {}\", express, e);\n        }\n    }\n\n    if (value != null && !isEmpty(resultExpress)) {\n        try {\n            value = ExpressFactory.threadLocalExpress(value)\n                    .bind(Constants.COST_VARIABLE, 0.0)\n                    .get(resultExpress);\n        } catch (ExpressException e) {\n            logger.warn(\"OGNL error: {}\", resultExpress, e);\n        }\n    }\n\n    builder.addObjects(JavaObjectConverter.toJavaObjectWithExpand(value, depth));\n    arthasStreamObserver.onNext(builder.build());\n    arthasStreamObserver.onCompleted();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "281", "src_id": "M1566", "code": "\npublic GrpcResultViewResolver registerView(GrpcResultView view) {\n    Class modelClass = getModelClass(view);\n    if (modelClass == null) {\n        throw new NullPointerException(\"model class is null\");\n    }\n    return registerView(modelClass, view);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "282", "src_id": "M1613", "code": "\nprivate List<Pair<Class<?>, String>> filter(Set<Class<?>> classes) {\n    List<Pair<Class<?>, String>> filteredClasses = new ArrayList<>();\n    Iterator<Class<?>> it = classes.iterator();\n    while (it.hasNext()) {\n        Class<?> clazz = it.next();\n        boolean removeFlag = false;\n        if (clazz == null) {\n            removeFlag = true;\n        } else if (isUnsafeClass(clazz)) {\n            filteredClasses.add(Pair.of(clazz, \"Bootstrap classloader class, try `options unsafe true`\"));\n            removeFlag = true;\n        } else if (isExclude(clazz)) {\n            filteredClasses.add(Pair.of(clazz, \"Excluded class\"));\n            removeFlag = true;\n        } else {\n            Pair<Boolean, String> unsupportedResult = isUnsupportedClass(clazz);\n            if (unsupportedResult.getFirst()) {\n                filteredClasses.add(Pair.of(clazz, unsupportedResult.getSecond()));\n                removeFlag = true;\n            }\n        }\n        if (removeFlag) {\n            it.remove();\n        }\n    }\n    return filteredClasses;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "283", "src_id": "M1594", "code": "\n@Override\npublic void atInvokeException(Class<?> clazz, String invokeInfo, Object target, Throwable throwable) {\n    ClassLoader classLoader = clazz.getClassLoader();\n    String[] info = StringUtils.splitInvokeInfo(invokeInfo);\n    String owner = info[0];\n    String methodName = info[1];\n    String methodDesc = info[2];\n\n    List<AdviceListener> listeners = AdviceListenerManager.queryTraceAdviceListeners(\n            classLoader, clazz.getName(), owner, methodName, methodDesc);\n\n    if (listeners != null) {\n        for (AdviceListener adviceListener : listeners) {\n            if (skipAdviceListener(adviceListener)) continue;\n            try {\n                ((InvokeTraceable) adviceListener).invokeThrowTracing(\n                        classLoader, owner, methodName, methodDesc, Integer.parseInt(info[3]));\n            } catch (Throwable e) {\n                logger.error(\"Error handling invoke exception: {} {}\", clazz.getName(), invokeInfo, e);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "160", "src_id": "M1105", "code": "\n    @Override\n    public void onSuspend(Job job) {\n        if (!job.isRunInBackground()) {\n            resetAndReadLine();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "161", "src_id": "M1106", "code": "\n        private void resetAndReadLine() {\n            // reset stdin handler to echo handler\n            // shell.term().stdinHandler(null);\n            shell.setForegroundJob(null);\n            shell.readline();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "162", "src_id": "M504", "code": "\n    private void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n        for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n            String objectName = entry.getKey();\n            List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n            TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n            table.row(true, \"OBJECT_NAME\", objectName);\n            table.row(true, label(\"NAME\").style(Decoration.bold.bold()),\n                    label(\"VALUE\").style(Decoration.bold.bold()));\n\n            for (MBeanAttributeVO attributeVO : attributeVOList) {\n                String attributeName = attributeVO.getName();\n                String valueStr;\n                if (attributeVO.getError() != null) {\n                    valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n                } else {\n                    // convert array to list\n                    // TODO: support all array types\n                    Object value = attributeVO.getValue();\n                    if (value instanceof String[]) {\n                        value = Arrays.asList((String[]) value);\n                    } else if (value instanceof Integer[]) {\n                        value = Arrays.asList((Integer[]) value);\n                    } else if (value instanceof Long[]) {\n                        value = Arrays.asList((Long[]) value);\n                    } else if (value instanceof int[]) {\n                        value = convertArrayToList((int[]) value);\n                    } else if (value instanceof long[]) {\n                        value = convertArrayToList((long[]) value);\n                    }\n                    // to string\n                    valueStr = String.valueOf(value);\n                }\n                table.row(attributeName, valueStr);\n            }\n            process.write(RenderUtil.render(table, process.width()));\n            process.write(\"\\n\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "163", "src_id": "M1157", "code": "\nprivate HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n    DefaultFullHttpResponse fullResp = null;\n    InputStream in = null;\n    try {\n        URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n        if (res != null) {\n            fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n            in = res.openStream();\n            byte[] buffer = new byte[256];\n            for (int bytesRead; (bytesRead = in.read(buffer)) != -1; ) {\n                fullResp.content().writeBytes(buffer, 0, bytesRead);\n            }\n            int extensionIndex = path.lastIndexOf('.');\n            if (extensionIndex != -1 && extensionIndex != path.length() - 1) {\n                String ext = path.substring(extensionIndex + 1);\n                String contentType;\n                if (\"html\".equals(ext)) {\n                    contentType = \"text/html\";\n                } else if (\"js\".equals(ext)) {\n                    contentType = \"application/javascript\";\n                } else if (\"css\".equals(ext)) {\n                    contentType = \"text/css\";\n                } else {\n                    contentType = null;\n                }\n                if (contentType != null) {\n                    fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                }\n            }\n        }\n    } finally {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n    return fullResp;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "arthas", "pair_id": "164", "src_id": "M381", "code": "\n@Override\npublic List<ResultModel> pollResults() {\n    try {\n        lastAccessTime = System.currentTimeMillis();\n        long accessTime = lastAccessTime;\n        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n            polling = true;\n            sendingItemCount = 0;\n            long firstResultTime = 0;\n            // sending delay: time elapsed after firstResultTime\n            long sendingDelay = 0;\n            // waiting time: time elapsed after access\n            long waitingTime = 0;\n            List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n\n            while (!closed\n                    && sendingResults.size() < resultBatchSizeLimit\n                    && sendingDelay < 100\n                    && waitingTime < pollTimeLimit) {\n                ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (aResult != null) {\n                    sendingResults.add(aResult);\n                    //是否为第一次获取到数据\n                    if (firstResultTime == 0) {\n                        firstResultTime = System.currentTimeMillis();\n                    }\n                    //判断是否需要立即发送出去\n                    if (shouldFlush(sendingResults, aResult)) {\n                        break;\n                    }\n                } else {\n                    if (firstResultTime > 0) {\n                        //获取到部分数据后，队列已经取完，计算发送延时时间\n                        sendingDelay = System.currentTimeMillis() - firstResultTime;\n                    }\n                    //计算总共等待时间，长轮询最大等待时间\n                    waitingTime = System.currentTimeMillis() - accessTime;\n                }\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n            }\n            return sendingResults;\n        }\n    } catch (InterruptedException e) {\n        // e.printStackTrace();\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lastAccessTime = System.currentTimeMillis();\n            polling = false;\n            lock.unlock();\n        }\n    }\n    return Collections.emptyList();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "165", "src_id": "M519", "code": "\n@Override\npublic void draw(CommandProcess process, DashboardModel result) {\n    int width = process.width();\n    int height = process.height();\n\n    // 上半部分放thread top。下半部分再切分为田字格，其中上面两格放memory, gc的信息。下面两格放tomcat,\n    // runtime的信息\n    int totalHeight = height - 1;\n    int threadTopHeight;\n    if (totalHeight <= 24) {\n        //总高度较小时取1/2\n        threadTopHeight = totalHeight / 2;\n    } else {\n        //总高度较大时取1/3，但不少于上面的值(24/2=12)\n        threadTopHeight = totalHeight / 3;\n        if (threadTopHeight < 12) {\n            threadTopHeight = 12;\n        }\n    }\n    int lowerHalf = totalHeight - threadTopHeight;\n\n    //Memory至少保留8行, 显示metaspace信息\n    int memoryInfoHeight = lowerHalf / 2;\n    if (memoryInfoHeight < 8) {\n        memoryInfoHeight = Math.min(8, lowerHalf);\n    }\n\n    //runtime\n    TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n    //tomcat\n    TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n    int runtimeInfoHeight = Math.max(runtimeInfoTable.getRows().size(), \n            tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size());\n    if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n        //如果runtimeInfo高度有剩余，则增大MemoryInfo的高度\n        memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n    } else {\n        runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n    }\n\n    //如果MemoryInfo高度有剩余，则增大ThreadHeight\n    int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n    memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n    threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n    String threadInfo = ViewRenderUtil.drawThreadInfo(\n            result.getThreads(), width, threadTopHeight);\n    String memoryAndGc = drawMemoryInfoAndGcInfo(\n            result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight);\n    String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(\n            runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight);\n\n    process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "166", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10)\n            .leftCellPadding(1)\n            .rightCellPadding(1);\n        \n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n\n        table.row(\n                label(LoggerHelper.name).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.name))\n            )\n            .row(\n                label(LoggerHelper.clazz).style(Decoration.bold.bold()),\n                label(clazz.getName())\n            )\n            .row(\n                label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.classLoader))\n            )\n            .row(\n                label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.classLoaderHash))\n            )\n            .row(\n                label(LoggerHelper.level).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.level))\n            );\n\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(\n                    label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel))\n                );\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(\n                    label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config))\n                );\n        }\n\n        table.row(\n                label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.additivity))\n            )\n            .row(\n                label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.codeSource))\n            );\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                appendersTable.row(\n                        label(LoggerHelper.name).style(Decoration.bold.bold()),\n                        label(\"\" + appenderInfo.get(LoggerHelper.name))\n                    )\n                    .row(\n                        label(LoggerHelper.clazz),\n                        label(appenderClass.getName())\n                    )\n                    .row(\n                        label(LoggerHelper.classLoader),\n                        label(\"\" + info.get(LoggerHelper.classLoader))\n                    )\n                    .row(\n                        label(LoggerHelper.classLoaderHash),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash))\n                    );\n\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(\n                            label(LoggerHelper.file),\n                            label(\"\" + appenderInfo.get(LoggerHelper.file))\n                        );\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(\n                            label(LoggerHelper.target),\n                            label(\"\" + appenderInfo.get(LoggerHelper.target))\n                        );\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(\n                            label(LoggerHelper.blocking),\n                            label(\"\" + appenderInfo.get(LoggerHelper.blocking))\n                        );\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(\n                            label(LoggerHelper.appenderRef),\n                            label(\"\" + appenderInfo.get(LoggerHelper.appenderRef))\n                        );\n                }\n            }\n\n            table.row(\n                    label(\"appenders\").style(Decoration.bold.bold()),\n                    appendersTable\n                );\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "167", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = session.get(ONETIME_SESSION_KEY) != null;\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse()\n                .setSessionId(session.getSessionId())\n                .setBody(body);\n\n            if (!session.tryLock()) {\n                return response\n                    .setState(ApiState.REFUSED)\n                    .setMessage(\"Another command is executing.\");\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response\n                        .setState(ApiState.REFUSED)\n                        .setMessage(\"Another job is running.\");\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n\n            } catch (Throwable e) {\n                logger.error(\"Exec command failed: {}, command: {}\", e.getMessage(), commandLine, e);\n                return response\n                    .setState(ApiState.FAILED)\n                    .setMessage(\"Exec command failed:\" + e.getMessage());\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            Integer timeout = apiRequest.getExecTimeout() != null && apiRequest.getExecTimeout() > 0 \n                ? apiRequest.getExecTimeout() \n                : DEFAULT_EXEC_TIMEOUT;\n            boolean timeExpired = !waitForJob(job, timeout);\n\n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED)\n                    .setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            return response\n                .setSessionId(session.getSessionId())\n                .setBody(body);\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "168", "src_id": "M494", "code": "\n    private void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n        callback.callback(deep, isLast, prefix, node);\n        if (!isLeaf(node)) {\n            List<TraceNode> children = node.getChildren();\n            if (children == null) {\n                return;\n            }\n            final int size = children.size();\n            for (int index = 0; index < size; index++) {\n                final boolean isLastFlag = index == size - 1;\n                final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n                recursive(\n                        deep + 1,\n                        isLastFlag,\n                        currentPrefix,\n                        children.get(index),\n                        callback);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "169", "src_id": "M474", "code": "\nprivate static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n    if (parentClassLoader.getChildren() == null) {\n        return;\n    }\n    for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n        TreeElement child = new TreeElement(childClassLoader.getName());\n        parent.addChild(child);\n        renderSubtree(child, childClassLoader);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "55", "src_id": "M970", "code": "\n    private static byte[] $$() {\n        return new byte[]{\n            0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20,\n            0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x6d, 0x69, 0x73, 0x74, 0x61, 0x6b, 0x65,\n            0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64, 0x69, 0x64, 0x0a, 0x49,\n            0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 极x65, 0x74, 0x20, 0x6d, 0x79,\n            0x73, 0x65, 0x6c, 0x66, 0x0a, 0x43, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x68, 0x65,\n            0x61, 0x72, 0x74, 0x20, 0x73, 0x6f, 0x20, 0x6d, 0x75, 0x63, 0x68, 0x20, 0x6d, 0x69, 0x73, 0x65,\n            0x72, 0x79, 0x0a, 0x49, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x极x6e, 0x6f, 0x74, 0x20, 0x62, 0x72, 0x65,\n            0x61, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x61, 0x79, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x64,\n            0x69, 0x64, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x66, 0x65, 0x6c, 0x6c, 0x20, 0x73, 0x6f, 0x20, 0x68,\n            0x61, 0x72, 0x64, 0x0a, 0x0a, 0x49, 0x20, 0x76, 0x65, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65,\n            0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20, 0x77, 0x61, 0x79, 0x0a, 0x54,\n            0x6f, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x69, 0x74, 0x20, 0x67,\n            0x65, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x61, 0x72, 0x0a, 0x0a, 0x42, 0x65, 0x63,\n            0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65,\n            0x76, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61,\n            0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77,\n            0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n            0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c, 0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,\n            0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65,\n            0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74,\n            0x20, 0x67, 0x65, 0x74, 0x20, 0x68, 0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n            0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6极, 0x75, 0x0a, 0x49, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x20,\n            0x69, 0x74, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x75, 0x73, 0x74,\n            0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d, 0x65, 0x2c, 0x20, 0x62, 0x75,\n            0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x72, 0x6f, 0x75, 0x6e,\n            0x64, 0x20, 0x6d, 0x65, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20,\n            0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a,\n            0x0a, 0x49, 0x20, 0x6c, 0x6f, 0x73, 0x65, 0x20, 0x6d, 0x79, 0x20, 0x77, 0x61, 0x79, 0x0a, 0x41,\n            0x6e, 0x64, 0x20, 0x69, 0x74, 0x20, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x6f, 0x6f, 0x20,\n            0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x79, 0x6f, 0x75, 0x20,\n            0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x74, 0x20, 0x6f, 0x75, 0x74, 0x0a, 0x49, 0x20, 0x63,\n            0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x72, 0x79, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73,\n            0x65, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,\n            0x73, 0x20, 0x77, 0x65, 0x61, 0x6b, 0x6e, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f,\n            0x75, 0x72, 0x20, 0x65, 0x79, 0x65, 0x73, 0x0a, 0x49, 0x20, 0x6d, 0x20, 0x66, 0x6f, 0x72, 0x63,\n            0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x6b, 0x65, 0x0a, 0x41, 0x20, 0x73, 0x6d, 0x69,\n            0x6c, 0x65, 0x2c, 0x20, 0x61, 0x20, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x20, 0x65, 0x76, 0x65, 0x72,\n            0x79, 0x64, 0x61, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66, 0x65, 0x0a,\n            0x4d, 0x79, 0x20, 0x68, 0x65, 0x61, 0x72, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x27, 0x74, 0x20, 0x70,\n            0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x79, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x0a, 0x57, 0x68,\n            0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x65, 0x76, 0x65,\n            0x6e, 0x20, 0x77, 0x68, 0x6f, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x73,极 0x74, 0x61, 0x72, 0x74,\n            0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f,\n            0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x73, 0x74,\n            0x72, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d,\n            0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x77, 0x61, 0x6c, 0x6b, 0x0a, 0x42, 0x65,\n            0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6c,\n            0x65, 0x61, 0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6f,\n            0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x66, 0x65, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20,\n            0x73, 0x6f, 0x20, 0x49, 0x20, 0x64, 0x6f, 0x6e, 0x20, 0x74, 0x20, 0x67, 0x65, 0x74, 0x20, 0x68,\n            0x75, 0x72, 0x74, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n            0x6f, 0x75, 0x0a, 0x49, 0x20, 0x74, 0x72, 0x79, 0x20, 0x6d, 0x79, 0x20, 0x68, 0x61, 0x72, 0x64,\n            0x65, 0x73, 0x74, 0x20, 0x6a, 0x75, 0x73, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x6f, 0x72, 0x67,\n            0x65, 0x74, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x0a, 0x42, 0x65,\n            0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x64,\n            0x6f, 0x6e, 0x20, 0x74, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74, 0x6f,\n            0x20, 0x6c, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x65, 0x6c, 0x73, 0x65,\n            0x20, 0x69, 0x6e, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79,\n            0x6f, 0x75, 0x0a, 0x49, 0x20, 0x6d, 0x20, 0x61, 0x73, 0x68, 0x61, 0x6d, 0x65, 0x64, 0x20, 0x6f,\n            0x66, 0x20, 0x6d, 0x79, 0x20, 0x6c, 0x69, 0x66, 0x65, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73,\n            0x65, 0x20, 0x69, 0x74, 0x20, 0x73, 0x20, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x0a, 0x42, 0x65, 0x63,\n            0x61, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x49, 0x20, 0x61, 0x6d,\n            0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x0a, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65,\n            0x20, 0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x42, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20,\n            0x6f, 0x66, 0x20, 0x79, 0x6f, 0x75, 0x0a, 0x2e, 0x2e, 0x2e, 0x0a, /*0x0a, 0x66, 0x6f, 0x72, 0x20, 0x6a, 0x75, 0x6c, 0x79, 0x0a, 0x0a,*/\n        };\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "211", "src_id": "M1106", "code": "\n    private void resetAndReadLine() {\n        // reset stdin handler to echo handler\n        // shell.term().stdinHandler(null);\n        shell.setForegroundJob(null);\n        shell.readline();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "255", "src_id": "M1530", "code": "\n    @Override\n    public boolean isEndOfInput() throws Exception {\n        if (input.isEndOfInput()) {\n            // Only end of input after last HTTP chunk has been sent\n            return true;\n        }\n        return false;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "256", "src_id": "M1539", "code": "\n    @Override\n    public void onError(Throwable t) {\n        Status s = Status.fromThrowable(t);\n        sendResponse.writeError(s);\n        latch.countDown();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "257", "src_id": "M1555", "code": "\nstatic Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n    Map<String, String> map = new HashMap<>();\n    for (String key : trailer.keys()) {\n        if (EXCLUDED.contains(key.toLowerCase())) {\n            continue;\n        }\n        if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n            // TODO allow any object type here\n            byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n            map.put(key, new String(value));\n        } else {\n            String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n            map.put(key, value);\n        }\n    }\n    return map;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "258", "src_id": "M1553", "code": "\npublic byte[] getPrefix(byte[] in, Type type) {\n    int len = in.length;\n    return new byte[] {\n        type.value,\n        (byte) ((len >> 24) & 0xff),\n        (byte) ((len >> 16) & 0xff),\n        (byte) ((len >> 8) & 0xff),\n        (byte) ((len >> 0) & 0xff),\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "259", "src_id": "M1538", "code": "\n    private Method getRpcMethod(Object stub, String rpcMethodName) {\n        for (Method method : stub.getClass().getMethods()) {\n            if (method.getName().equals(rpcMethodName)) {\n                return method;\n            }\n        }\n        throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n    }\n\n\n    @Override\n    public void process(CommandProcess process) {\n\n        if (\"start\".equals(cmd)) {\n            Configuration configuration = null;\n            try {\n                if (getSettings() == null) {\n                    setSettings(\"default\");\n                }\n                configuration = Configuration.getConfiguration(settings);\n            } catch (Throwable e) {\n                process.end(-1, \"Could not start recording, not able to read settings\");\n            }\n            Recording r = new Recording(configuration);\n\n            if (getFilename() != null) {\n                try {\n                    r.setDestination(Paths.get(getFilename()));\n                } catch (IOException e) {\n                    r.close();\n                    process.end(-1, \"Could not start recording, not able to write to file \" + getFilename() + e.getMessage());\n                }\n            }\n\n            if (getMaxSize() != null) {\n                try {\n                    r.setMaxSize(parseSize(getMaxSize()));\n                } catch (Exception e) {\n                    process.end(-1, e.getMessage());\n                }\n            }\n\n            if (getMaxAge() != null) {\n                try {\n                    r.setMaxAge(Duration.ofNanos(parseTimespan(getMaxAge())));\n                } catch (Exception e) {\n                    process.end(-1, e.getMessage());\n                }\n            }\n\n            if (isDumpOnExit() != false) {\n                r.setDumpOnExit(isDumpOnExit().booleanValue());\n            }\n\n            if (getDuration() != null) {\n                try {\n                    r.setDuration(Duration.ofNanos(parseTimespan(getDuration())));\n                } catch (Exception e) {\n                    process.end(-1, e.getMessage());\n                }\n            }\n\n            if (getName() == null) {\n                r.setName(\"Recording-\" + r.getId());\n            } else {\n                r.setName(getName());\n            }\n\n            long id = r.getId();\n            recordings.put(id, r);\n\n            if (getDelay() != null) {\n                try {\n                    r.scheduleStart(Duration.ofNanos(parseTimespan(getDelay())));\n                } catch (Exception e) {\n                    process.end(-1, e.getMessage());\n                }\n                result.setJfrOutput(\"Recording \" + r.getId() + \" scheduled to start in \" + getDelay());\n            } else {\n                r.start();\n                result.setJfrOutput(\"Started recording \" + r.getId() + \".\");\n            }\n\n            if (duration == null && maxAge == null && maxSize == null) {\n                result.setJfrOutput(\" No limit specified, using maxsize=250MB as default.\");\n                r.setMaxSize(250 * 1024L * 1024L);\n            }\n\n            if (filename != null && duration != null) {\n                result.setJfrOutput(\" The result will be written to:\\n\" + filename);\n            }\n        } else if (\"status\".equals(cmd)) {\n            if (getRecording() != null) {\n                Recording r = recordings.get(getRecording());\n                if (r == null) {\n                    process.end(-1, \"recording not exit\");\n                }\n                printRecording(r);\n            } else {\n                List<Recording> recordingList;\n                if (state != null) {\n                    recordingList = findRecordingByState(state);\n                } else {\n                    recordingList = new ArrayList<Recording>(recordings.values());\n                }\n                if (recordingList.isEmpty()) {\n                    process.end(-1, \"No available recordings.\\n Use jfr start to start a recording.\\n\");\n                } else {\n                    for (Recording recording : recordingList) {\n                        printRecording(recording);\n                    }\n                }\n            }\n        } else if (\"dump\".equals(cmd)) {\n            if (recordings.isEmpty()) {\n                process.end(-1, \"No recordings to dump. Use jfr start to start a recording.\");\n            }\n            if (getRecording() != null) {\n                Recording r = recordings.get(getRecording());\n                if (r == null) {\n                    process.end(-1, \"recording not exit\");\n                }\n                if (getFilename() == null) {\n                    try {\n                        setFilename(outputFile());\n                    } catch (IOException e) {\n                        process.end(-1, e.getMessage());\n                    }\n                }\n\n                try {\n                    r.dump(Paths.get(getFilename()));\n                } catch (IOException e) {\n                    process.end(-1, \"Could not to dump. \" + e.getMessage());\n                }\n                result.setJfrOutput(\"Dump recording \" + r.getId() + \", The result will be written to:\\n\" + getFilename());\n            } else {\n                process.end(-1, \"Failed to dump. Please input recording id\");\n            }\n\n        } else if (\"stop\".equals(cmd)) {\n            if (recordings.isEmpty()) {\n                process.end(-1, \"No recordings to stop. Use jfr start to start a recording.\");\n            }\n            if (getRecording() != null) {\n                Recording r = recordings.remove(getRecording());\n                if (r == null) {\n                    process.end(-1, \"recording not exit\");\n                }\n                if (\"CLOSED\".equals(r.getState().toString()) || \"STOPPED\".equals(r.getState().toString())) {\n                    process.end(-1, \"Failed to stop recording, state can not be closed/stopped\");\n                }\n                if (getFilename() == null) {\n                    try {\n                        setFilename(outputFile());\n                    } catch (IOException e) {\n                        process.end(-1, e.getMessage());\n                    }\n                }\n                try {\n                    r.setDestination(Paths.get(getFilename()));\n                } catch (IOException e) {\n                    process.end(-1, \"Failed to stop \" + r.getName() + \". Could not set destination for \" + filename + \"to file\" + e.getMessage());\n                }\n\n                r.stop();\n                result.setJfrOutput(\"Stop recording \" + r.getId() + \", The result will be written to:\\n\" + getFilename());\n                r.close();\n            } else {\n                process.end(-1, \"Failed to stop. please input recording id\");\n            }\n        } else {\n            process.end(-1, \"Please input correct jfr command (start status stop dump)\");\n        }\n\n        process.appendResult(result);\n        process.end();\n    }\n\n\n    @Argument(index = 0, argName = \"cmd\", required = true)\n    @Description(\"command name (start status stop dump)\")\n    public void setCmd(String cmd) {\n        this.cmd = cmd;\n    }\n\n\n    @Option(shortName = \"d\", longName = \"delay\")\n    @Description(\"Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h. (NANOTIME, 0)\")\n    public void setDelay(String delay) {\n        this.delay = delay;\n    }\n\n\n    @Option(longName = \"duration\")\n    @Description(\"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s. (NANOTIME, 0)\")\n    public void setDuration(String duration) {\n        this.duration = duration;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "260", "src_id": "M1535", "code": "\n    private Pair<String, String> extractComponents(String path) throws IllegalArgumentException {\n        String[] parts = path.substring(1).split(\"/\");\n        if (parts.length != 2) {\n            throw new IllegalArgumentException(\"Invalid path format: \" + path);\n        }\n\n        String className = parts[0];\n        String methodName = parts[1].substring(0, 1).toLowerCase() + parts[1].substring(1);\n        return new Pair<>(className, methodName);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "49", "src_id": "M1530", "code": "\n@Override\npublic boolean isEndOfInput() throws Exception {\n    if (input.isEndOfInput()) {\n        // Only end of input after last HTTP chunk has been sent\n        return true;\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "arthas", "pair_id": "50", "src_id": "M308", "code": "\n    HashEntry<K, V> nextEntry() {\n        do {\n            if (nextEntry == null) {\n                throw new NoSuchElementException();\n            }\n\n            lastReturned = nextEntry;\n            currentKey = lastReturned.key();\n            advance();\n        } while (currentKey == null); // Skip GC'd keys\n\n        return lastReturned;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "51", "src_id": "M1284", "code": "\n@AtInvoke(name = \"\", inline = true, whenComplete = false, excludes = \"java.**\")\npublic static void onInvoke(\n        @Binding.This Object target,\n        @Binding.Class Class<?> clazz,\n        @Binding.InvokeInfo String invokeInfo) {\n    SpyAPI.atBeforeInvoke(clazz, invokeInfo, target);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "52", "src_id": "M947", "code": "\npublic void loggers(CommandProcess process) {\n    Map<ClassLoader, LoggerTypes> classLoaderLoggerMap = new LinkedHashMap<ClassLoader, LoggerTypes>();\n\n    // 如果不指定 classloader，则打印所有 classloader 里的 logger 信息\n    for (Class<?> clazz : process.session().getInstrumentation().getAllLoadedClasses()) {\n        String className = clazz.getName();\n        ClassLoader classLoader = clazz.getClassLoader();\n\n        // if special classloader\n        if (this.hashCode != null && !this.hashCode.equals(StringUtils.classLoaderHash(clazz))) {\n            continue;\n        }\n\n        if (classLoader != null) {\n            LoggerTypes loggerTypes = classLoaderLoggerMap.get(classLoader);\n            if (loggerTypes == null) {\n                loggerTypes = new LoggerTypes();\n                classLoaderLoggerMap.put(classLoader, loggerTypes);\n            }\n            updateLoggerType(loggerTypes, classLoader, className);\n        }\n    }\n\n    for (Entry<ClassLoader, LoggerTypes> entry : classLoaderLoggerMap.entrySet()) {\n        ClassLoader classLoader = entry.getKey();\n        LoggerTypes loggerTypes = entry.getValue();\n\n        if (loggerTypes.contains(LoggerType.LOG4J)) {\n            Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4jHelper.class);\n            process.appendResult(new LoggerModel(loggerInfoMap));\n        }\n\n        if (loggerTypes.contains(LoggerType.LOGBACK)) {\n            Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, LogbackHelper.class);\n            process.appendResult(new LoggerModel(loggerInfoMap));\n        }\n\n        if (loggerTypes.contains(LoggerType.LOG4J2)) {\n            Map<String, Map<String, Object>> loggerInfoMap = loggerInfo(classLoader, Log4j2Helper.class);\n            process.appendResult(new LoggerModel(loggerInfoMap));\n        }\n    }\n\n    process.end();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "53", "src_id": "M249", "code": "\nprivate void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) throws URISyntaxException {\n    QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n    Map<String, List<String>> parameters = queryDecoder.parameters();\n\n    String appName = null;\n    List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n    if (appNameList != null && !appNameList.isEmpty()) {\n        appName = appNameList.get(0);\n    }\n\n    String id = null;\n    if (appName != null) {\n        id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n    } else {\n        id = RandomStringUtils.random(20, true, true).toUpperCase();\n    }\n    List<String> idList = parameters.get(URIConstans.ID);\n    if (idList != null && !idList.isEmpty()) {\n        id = idList.get(0);\n    }\n\n    String arthasVersion = null;\n    List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n    if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n        arthasVersion = arthasVersionList.get(0);\n    }\n\n    final String finalId = id;\n\n    URI responseUri = UriComponentsBuilder.newInstance().scheme(URIConstans.RESPONSE).path(\"/\")\n            .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER).queryParam(URIConstans.ID, id).build()\n            .encode().toUri();\n\n    AgentInfo info = new AgentInfo();\n\n    HttpHeaders headers = handshake.requestHeaders();\n    String host = HttpUtils.findClientIP(headers);\n\n    if (host == null) {\n        SocketAddress remoteAddress = ctx.channel().remoteAddress();\n        if (remoteAddress instanceof InetSocketAddress) {\n            InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n            info.setHost(inetSocketAddress.getHostString());\n            info.setPort(inetSocketAddress.getPort());\n        }\n    } else {\n        info.setHost(host);\n        Integer port = HttpUtils.findClientPort(headers);\n        if (port != null) {\n            info.setPort(port);\n        }\n    }\n\n    info.setChannelHandlerContext(ctx);\n    if (arthasVersion != null) {\n        info.setArthasVersion(arthasVersion);\n    }\n\n    tunnelServer.addAgent(id, info);\n    ctx.channel().closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {\n        @Override\n        public void operationComplete(Future<? super Void> future) throws Exception {\n            tunnelServer.removeAgent(finalId);\n        }\n\n    });\n\n    ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "54", "src_id": "M200", "code": "\n    public ChannelFuture connect(boolean reconnect) throws SSLException, URISyntaxException, InterruptedException {\n        QueryStringEncoder queryEncoder = new QueryStringEncoder(this.tunnelServerUrl);\n        queryEncoder.addParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER);\n        queryEncoder.addParam(URIConstans.ARTHAS_VERSION, this.version);\n        if (appName != null) {\n            queryEncoder.addParam(URIConstans.APP_NAME, appName);\n        }\n        if (id != null) {\n            queryEncoder.addParam(URIConstans.ID, id);\n        }\n        // ws://127.0.0.1:7777/ws?method=agentRegister\n        URI agentRegisterURI = queryEncoder.toUri();\n\n        logger.info(\"Try to register arthas agent, uri: {}\", agentRegisterURI);\n\n        String scheme = agentRegisterURI.getScheme() == null ? \"ws\" : agentRegisterURI.getScheme();\n        String host = agentRegisterURI.getHost() == null ? \"127.0.0.1\" : agentRegisterURI.getHost();\n        int port;\n        if (agentRegisterURI.getPort() == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else if (\"wss\".equalsIgnoreCase(scheme)) {\n                port = 443;\n            } else {\n                port = -1;\n            }\n        } else {\n            port = agentRegisterURI.getPort();\n        }\n\n        if (!\"ws\".equalsIgnoreCase(scheme) && !\"wss\".equalsIgnoreCase(scheme)) {\n            throw new IllegalArgumentException(\"Only WS(S) is supported. tunnelServerUrl: \" + tunnelServerUrl);\n        }\n\n        boolean ssl = \"wss\".equalsIgnoreCase(scheme);\n        SslContext sslCtx;\n        if (ssl) {\n            sslCtx = SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n        } else {\n            sslCtx = null;\n        }\n\n        WebSocketClientProtocolConfig clientProtocolConfig = WebSocketClientProtocolConfig.newBuilder()\n            .webSocketUri(agentRegisterURI)\n            .maxFramePayloadLength(ArthasConstants.MAX_HTTP_CONTENT_LENGTH)\n            .build();\n\n        WebSocketClientProtocolHandler websocketClientHandler = new WebSocketClientProtocolHandler(\n            clientProtocolConfig);\n        TunnelClientSocketClientHandler handler = new TunnelClientSocketClientHandler(TunnelClient.this);\n\n        Bootstrap bs = new Bootstrap();\n        bs.group(eventLoopGroup);\n        bs.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n        bs.option(ChannelOption.TCP_NODELAY, true);\n        bs.channel(NioSocketChannel.class);\n        bs.remoteAddress(host, port);\n        bs.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) {\n                ChannelPipeline p = ch.pipeline();\n                if (sslCtx != null) {\n                    p.addLast(sslCtx.newHandler(ch.alloc(), host, port));\n                }\n\n                p.addLast(\n                    new HttpClientCodec(),\n                    new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                    websocketClientHandler,\n                    new IdleStateHandler(0, 0, ArthasConstants.WEBSOCKET_IDLE_SECONDS),\n                    handler\n                );\n            }\n        });\n\n        ChannelFuture connectFuture = bs.connect();\n        if (reconnect) {\n            connectFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    if (future.cause() != null) {\n                        logger.error(\"connect to tunnel server error, uri: {}\", tunnelServerUrl, future.cause());\n                    }\n                }\n            });\n        }\n        connectFuture.sync();\n\n        return handler.registerFuture();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "56", "src_id": "M124", "code": "\n@Override\npublic int read() throws IOException {\n    // Critical section because we're altering __bytesAvailable,\n    // __queueHead, and the contents of _queue in addition to\n    // testing value of __hasReachedEOF.\n    synchronized (__queue) {\n        while (true) {\n            if (__ioException != null) {\n                IOException e;\n                e = __ioException;\n                __ioException = null;\n                throw e;\n            }\n\n            if (__bytesAvailable == 0) {\n                // Return EOF if at end of file\n                if (__hasReachedEOF) {\n                    return EOF;\n                }\n\n                // Otherwise, we have to wait for queue to get something\n                if (__threaded) {\n                    __queue.notify();\n                    try {\n                        __readIsWaiting = true;\n                        __queue.wait();\n                        __readIsWaiting = false;\n                    } catch (InterruptedException e) {\n                        throw new InterruptedIOException(\"Fatal thread interruption during read.\");\n                    }\n                } else {\n                    //__alreadyread = false;\n                    __readIsWaiting = true;\n                    int ch;\n                    boolean mayBlock = true;    // block on the first read only\n\n                    do {\n                        try {\n                            if ((ch = __read(mayBlock)) < 0) { // must be EOF\n                                if (ch != WOULD_BLOCK) {\n                                    return (ch);\n                                }\n                            }\n                        } catch (InterruptedIOException e) {\n                            synchronized (__queue) {\n                                __ioException = e;\n                                __queue.notifyAll();\n                                try {\n                                    __queue.wait(100);\n                                } catch (InterruptedException interrupted) {\n                                    // Ignored\n                                }\n                            }\n                            return EOF;\n                        }\n\n                        try {\n                            if (ch != WOULD_BLOCK) {\n                                __processChar(ch);\n                            }\n                        } catch (InterruptedException e) {\n                            if (__isClosed) {\n                                return EOF;\n                            }\n                        }\n\n                        // Reads should not block on subsequent iterations. Potentially, this could happen if the\n                        // remaining buffered socket data consists entirely of Telnet command sequence and no \"user\" data.\n                        mayBlock = false;\n\n                    } while (super.available() > 0 && __bytesAvailable < __queue.length - 1); // Continue reading as long as there is data available and the queue is not full.\n\n                    __readIsWaiting = false;\n                }\n                continue;\n            } else {\n                int ch;\n\n                ch = __queue[__queueHead];\n\n                if (++__queueHead >= __queue.length) {\n                    __queueHead = 0;\n                }\n\n                --__bytesAvailable;\n\n                // Need to explicitly notify() so available() works properly\n                if (__bytesAvailable == 0 && __threaded) {\n                    __queue.notify();\n                }\n\n                return ch;\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "57", "src_id": "M786", "code": "\n@Override\npublic void process(CommandProcess process) {\n    initTransformer();\n\n    RetransformModel retransformModel = new RetransformModel();\n    Instrumentation inst = process.session().getInstrumentation();\n\n    if (list) {\n        List<RetransformEntry> retransformEntryList = allRetransformEntries();\n        retransformModel.setRetransformEntries(retransformEntryList);\n        process.appendResult(retransformModel);\n        process.end();\n        return;\n    } else if (deleteAll) {\n        deleteAllRetransformEntry();\n        process.appendResult(retransformModel);\n        process.end();\n        return;\n    } else if (delete > 0) {\n        deleteRetransformEntry(delete);\n        process.end();\n        return;\n    } else if (classPattern != null) {\n        Set<Class<?>> searchClass = SearchUtils.searchClass(inst, classPattern, false, hashCode);\n        if (searchClass.isEmpty()) {\n            process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + classPattern);\n            return;\n        }\n\n        if (searchClass.size() > limit) {\n            process.end(-1, \"match classes size: \" + searchClass.size() + \", more than limit: \" + limit\n                    + \", It is recommended to use a more precise class pattern.\");\n        }\n        try {\n            inst.retransformClasses(searchClass.toArray(new Class[0]));\n            for (Class<?> clazz : searchClass) {\n                retransformModel.addRetransformClass(clazz.getName());\n            }\n            process.appendResult(retransformModel);\n            process.end();\n            return;\n        } catch (Throwable e) {\n            String message = \"retransform error! \" + e.toString();\n            logger.error(message, e);\n            process.end(-1, message);\n            return;\n        }\n    }\n\n    for (String path : paths) {\n        File file = new File(path);\n        if (!file.exists()) {\n            process.end(-1, \"file does not exist, path:\" + path);\n            return;\n        }\n        if (!file.isFile()) {\n            process.end(-1, \"not a normal file, path:\" + path);\n            return;\n        }\n        if (file.length() >= MAX_FILE_SIZE) {\n            process.end(-1, \"file size: \" + file.length() + \" >= \" + MAX_FILE_SIZE + \", path: \" + path);\n            return;\n        }\n    }\n\n    Map<String, byte[]> bytesMap = new HashMap<String, byte[]>();\n    for (String path : paths) {\n        RandomAccessFile f = null;\n        try {\n            f = new RandomAccessFile(path, \"r\");\n            final byte[] bytes = new byte[(int) f.length()];\n            f.readFully(bytes);\n\n            final String clazzName = readClassName(bytes);\n\n            bytesMap.put(clazzName, bytes);\n\n        } catch (Exception e) {\n            logger.warn(\"load class file failed: \" + path, e);\n            process.end(-1, \"load class file failed: \" + path + \", error: \" + e);\n            return;\n        } finally {\n            if (f != null) {\n                try {\n                    f.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    if (bytesMap.size() != paths.size()) {\n        process.end(-1, \"paths may contains same class name!\");\n        return;\n    }\n\n    List<RetransformEntry> retransformEntryList = new ArrayList<RetransformEntry>();\n\n    List<Class<?>> classList = new ArrayList<Class<?>>();\n\n    for (Class<?> clazz : inst.getAllLoadedClasses()) {\n        if (bytesMap.containsKey(clazz.getName())) {\n\n            if (hashCode == null && classLoaderClass != null) {\n                List<ClassLoader> matchedClassLoaders = ClassLoaderUtils.getClassLoaderByClassName(inst,\n                        classLoaderClass);\n                if (matchedClassLoaders.size() == 1) {\n                    hashCode = Integer.toHexString(matchedClassLoaders.get(0).hashCode());\n                } else if (matchedClassLoaders.size() > 1) {\n                    Collection<ClassLoaderVO> classLoaderVOList = ClassUtils\n                            .createClassLoaderVOList(matchedClassLoaders);\n                    retransformModel.setClassLoaderClass(classLoaderClass)\n                            .setMatchedClassLoaders(classLoaderVOList);\n                    process.appendResult(retransformModel);\n                    process.end(-1,\n                            \"Found more than one classloader by class name, please specify classloader with '-c <classloader hash>'\");\n                    return;\n                } else {\n                    process.end(-1, \"Can not find classloader by class name: \" + classLoaderClass + \".\");\n                    return;\n                }\n            }\n\n            ClassLoader classLoader = clazz.getClassLoader();\n            if (classLoader != null && hashCode != null\n                    && !Integer.toHexString(classLoader.hashCode()).equals(hashCode)) {\n                continue;\n            }\n\n            RetransformEntry retransformEntry = new RetransformEntry(clazz.getName(), bytesMap.get(clazz.getName()),\n                    hashCode, classLoaderClass);\n            retransformEntryList.add(retransformEntry);\n            classList.add(clazz);\n            retransformModel.addRetransformClass(clazz.getName());\n\n            logger.info(\"Try retransform class name: {}, ClassLoader: {}\", clazz.getName(), clazz.getClassLoader());\n        }\n    }\n\n    try {\n        if (retransformEntryList.isEmpty()) {\n            process.end(-1, \"These classes are not found in the JVM and may not be loaded: \" + bytesMap.keySet());\n            return;\n        }\n        addRetransformEntry(retransformEntryList);\n\n        inst.retransformClasses(classList.toArray(new Class[0]));\n\n        process.appendResult(retransformModel);\n        process.end();\n    } catch (Throwable e) {\n        String message = \"retransform error! \" + e.toString();\n        logger.error(message, e);\n        process.end(-1, message);\n    }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "58", "src_id": "M278", "code": "\nV get(Object key, int hash) {\n    if (count != 0) { // read-volatile\n        HashEntry<K, V> e = getFirst(hash);\n        while (e != null) {\n            if (e.hash == hash && keyEq(key, e.key())) {\n                Object opaque = e.valueRef;\n                if (opaque != null) {\n                    return e.dereferenceValue(opaque);\n                }\n\n                return readValueUnderLock(e); // recheck\n            }\n            e = e.next;\n        }\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "59", "src_id": "M184", "code": "\n@Override\nprotected void initChannel(LocalChannel ch) {\n    ChannelPipeline p = ch.pipeline();\n    p.addLast(\n        new HttpClientCodec(),\n        new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n        new HttpProxyClientHandler(httpResponsePromise)\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "44", "src_id": "M1539", "code": "\n        @Override\n        public void onError(Throwable t) {\n            Status status = Status.fromThrowable(t);\n            sendResponse.writeError(status);\n            latch.countDown();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "45", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n        Map<String, String> map = new HashMap<>();\n        for (String key : trailer.keys()) {\n            if (EXCLUDED.contains(key.toLowerCase())) {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                map.put(key, new String(value));\n            } else {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                map.put(key, value);\n            }\n        }\n        return map;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "46", "src_id": "M1553", "code": "\npublic byte[] getPrefix(byte[] in, Type type) {\n    int len = in.length;\n    return new byte[] {\n        type.value,\n        (byte) ((len >> 24) & 0xff),\n        (byte) ((len >> 16) & 0xff),\n        (byte) ((len >> 8) & 0xff),\n        (byte) ((len >> 0) & 0xff),\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "47", "src_id": "M1538", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "48", "src_id": "M1535", "code": "\n    private Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n        // Process path info starting from first character\n        String[] pathSegments = pathInfo.substring(1).split(\"/\");\n        if (pathSegments.length != 2) {\n            throw new IllegalArgumentException(\"Invalid path format: \" + pathInfo);\n        }\n\n        String className = pathSegments[0];\n        String methodNameRaw = pathSegments[1];\n        String methodName = methodNameRaw.substring(0, 1).toLowerCase() + methodNameRaw.substring(1);\n        \n        return new Pair<>(className, methodName);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "210", "src_id": "M1105", "code": "\n@Override\npublic void onSuspend(Job job) {\n    if (!job.isRunInBackground()) {\n        resetAndReadLine();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "212", "src_id": "M504", "code": "\nprivate void drawMBeanAttributes(CommandProcess process, Map<String, List<MBeanAttributeVO>> mbeanAttributeMap) {\n    for (Map.Entry<String, List<MBeanAttributeVO>> entry : mbeanAttributeMap.entrySet()) {\n        String objectName = entry.getKey();\n        List<MBeanAttributeVO> attributeVOList = entry.getValue();\n\n        TableElement table = new TableElement().leftCellPadding(1).rightCellPadding(1);\n        table.row(true, \"OBJECT_NAME\", objectName);\n        table.row(true, label(\"NAME\").style(Decoration.bold.bold()), label(\"VALUE\").style(Decoration.bold.bold()));\n\n        for (MBeanAttributeVO attributeVO : attributeVOList) {\n            String attributeName = attributeVO.getName();\n            String valueStr;\n            if (attributeVO.getError() != null) {\n                valueStr = RenderUtil.render(new LabelElement(attributeVO.getError()).style(Decoration.bold_off.fg(Color.red)));\n            } else {\n                // TODO support all array type\n                Object value = attributeVO.getValue();\n                if (value instanceof String[]) {\n                    value = Arrays.asList((String[]) value);\n                } else if (value instanceof Integer[]) {\n                    value = Arrays.asList((Integer[]) value);\n                } else if (value instanceof Long[]) {\n                    value = Arrays.asList((Long[]) value);\n                } else if (value instanceof int[]) {\n                    value = convertArrayToList((int[]) value);\n                } else if (value instanceof long[]) {\n                    value = convertArrayToList((long[]) value);\n                }\n                valueStr = String.valueOf(value);\n            }\n            table.row(attributeName, valueStr);\n        }\n        process.write(RenderUtil.render(table, process.width()));\n        process.write(\"\\n\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "213", "src_id": "M1157", "code": "\n    private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n        URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n        if (res == null) {\n            return null;\n        }\n\n        DefaultFullHttpResponse fullResp = new DefaultFullHttpResponse(\n            request.protocolVersion(), HttpResponseStatus.OK\n        );\n        \n        try (InputStream in = res.openStream()) {\n            byte[] buffer = new byte[256];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                fullResp.content().writeBytes(buffer, 0, bytesRead);\n            }\n        }\n\n        int lastDotIndex = path.lastIndexOf('.');\n        if (lastDotIndex != -1 && lastDotIndex != path.length() - 1) {\n            String extension = path.substring(lastDotIndex + 1);\n            Optional<String> contentType = Optional.empty();\n            \n            if (\"html\".equals(extension)) {\n                contentType = Optional.of(\"text/html\");\n            } else if (\"js\".equals(extension)) {\n                contentType = Optional.of(\"application/javascript\");\n            } else if (\"css\".equals(extension)) {\n                contentType = Optional.of(\"text/css\");\n            }\n            \n            contentType.ifPresent(ct -> \n                fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, ct)\n            );\n        }\n\n        return fullResp;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "214", "src_id": "M381", "code": "\n    @Override\n    public List<ResultModel> pollResults() {\n        try {\n            lastAccessTime = System.currentTimeMillis();\n            long accessTime = lastAccessTime;\n            if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                polling = true;\n                sendingItemCount = 0;\n                long firstResultTime = 0; // Time of first result\n                long sendingDelay = 0;    // Elapsed since first result\n                long waitingTime = 0;     // Elapsed since access\n                List<ResultModel> sendingResults = new ArrayList<>(resultBatchSizeLimit);\n\n                while (!closed\n                       && sendingResults.size() < resultBatchSizeLimit\n                       && sendingDelay < 100\n                       && waitingTime < pollTimeLimit) {\n                    ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                    if (aResult != null) {\n                        sendingResults.add(aResult);\n                        if (firstResultTime == 0) {\n                            firstResultTime = System.currentTimeMillis();\n                        }\n                        if (shouldFlush(sendingResults, aResult)) {\n                            break;\n                        }\n                    } else {\n                        if (firstResultTime > 0) {\n                            sendingDelay = System.currentTimeMillis() - firstResultTime;\n                        }\n                        waitingTime = System.currentTimeMillis() - accessTime;\n                    }\n                }\n\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n                }\n                return sendingResults;\n            }\n        } catch (InterruptedException e) {\n            // Ignore interruption\n        } finally {\n            if (lock.isHeldByCurrentThread()) {\n                lastAccessTime = System.currentTimeMillis();\n                polling = false;\n                lock.unlock();\n            }\n        }\n        return Collections.emptyList();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "215", "src_id": "M519", "code": "\n@Override\npublic void draw(CommandProcess process, DashboardModel result) {\n    int width = process.width();\n    int height = process.height();\n\n    // Top half for thread top, bottom half divided into grid: \n    // top two grids for memory/GC info, bottom two for tomcat/runtime\n    int totalHeight = height - 1;\n    int threadTopHeight = totalHeight <= 24 ? \n                          totalHeight / 2 : \n                          Math.max(totalHeight / 3, 12);\n    int lowerHalf = totalHeight - threadTopHeight;\n\n    // Reserve at least 8 lines for metaspace\n    int memoryInfoHeight = Math.max(lowerHalf / 2, Math.min(8, lowerHalf));\n\n    TableElement runtimeInfoTable = drawRuntimeInfo(result.getRuntimeInfo());\n    TableElement tomcatInfoTable = drawTomcatInfo(result.getTomcatInfo());\n    int runtimeInfoHeight = Math.max(\n        runtimeInfoTable.getRows().size(), \n        tomcatInfoTable == null ? 0 : tomcatInfoTable.getRows().size()\n    );\n\n    // Adjust heights based on available space\n    if (runtimeInfoHeight < lowerHalf - memoryInfoHeight) {\n        memoryInfoHeight = lowerHalf - runtimeInfoHeight;\n    } else {\n        runtimeInfoHeight = lowerHalf - memoryInfoHeight;\n    }\n\n    int maxMemoryInfoHeight = getMemoryInfoHeight(result.getMemoryInfo());\n    memoryInfoHeight = Math.min(memoryInfoHeight, maxMemoryInfoHeight);\n    threadTopHeight = totalHeight - memoryInfoHeight - runtimeInfoHeight;\n\n    String threadInfo = ViewRenderUtil.drawThreadInfo(result.getThreads(), width, threadTopHeight);\n    String memoryAndGc = drawMemoryInfoAndGcInfo(\n        result.getMemoryInfo(), result.getGcInfos(), width, memoryInfoHeight\n    );\n    String runTimeAndTomcat = drawRuntimeInfoAndTomcatInfo(\n        runtimeInfoTable, tomcatInfoTable, width, runtimeInfoHeight\n    );\n\n    process.write(threadInfo + memoryAndGc + runTimeAndTomcat);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "216", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoader)))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.level)));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.additivity)))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                        label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                appendersTable.row(label(LoggerHelper.classLoaderHash),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target),\n                            label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking),\n                            label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef),\n                            label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "217", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = session.get(ONETIME_SESSION_KEY) != null;\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse()\n                .setSessionId(session.getSessionId())\n                .setBody(body);\n\n            if (!session.tryLock()) {\n                return response\n                    .setState(ApiState.REFUSED)\n                    .setMessage(\"Another command is executing.\");\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response\n                        .setState(ApiState.REFUSED)\n                        .setMessage(\"Another job is running.\");\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n\n            } catch (Throwable e) {\n                logger.error(\"Exec command failed: {}, command: {}\", e.getMessage(), commandLine, e);\n                return response\n                    .setState(ApiState.FAILED)\n                    .setMessage(\"Exec command failed:\" + e.getMessage());\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            Integer timeout = Optional.ofNullable(apiRequest.getExecTimeout())\n                .filter(t -> t > 0)\n                .orElse(DEFAULT_EXEC_TIMEOUT);\n            boolean timeExpired = !waitForJob(job, timeout);\n            \n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED)\n                    .setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            return response\n                .setSessionId(session.getSessionId())\n                .setBody(body);\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "218", "src_id": "M494", "code": "\n   public Http2Headers getEndHeader() {\n       Http2Headers endHeader = new DefaultHttp2Headers().status(\"200\");\n       // ...\n   }\n   \n\n   public void execute(GrpcRequest request, Http2DataFrame frame, ChannelHandlerContext context)\n   \n\n   ArthasUnittest.ArthasUnittestResponse.Builder builder = ArthasUnittest.ArthasUnittestResponse.newBuilder();\n   \n\n   ch.pipeline().addLast(new ChannelInitializer<SocketChannel>() {\n       @Override\n       public void initChannel(SocketChannel ch) {\n           // ...\n       }\n   });\n   \n\n   grpcExecutorFactory.getExecutor(grpcRequest.getGrpcType()).execute(grpcRequest, dataFrame, ctx);\n   \n\n   context.writeAndFlush(new DefaultHttp2HeadersFrame(res.getEndHeader()).stream(frame.stream()));\n   \n\nprivate void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n    callback.callback(deep, isLast, prefix, node);\n    if (!isLeaf(node)) {\n        List<TraceNode> children = node.getChildren();\n        if (children == null) {\n            return;\n        }\n        final int size = children.size();\n        for (int index = 0; index < size; index++) {\n            final boolean isLastFlag = index == size - 1;\n            final String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n            recursive(\n                    deep + 1,\n                    isLastFlag,\n                    currentPrefix,\n                    children.get(index),\n                    callback\n            );\n        }\n    }\n}\n\n\nrecursive(\n    deep + 1,\n    isLastFlag,\n    currentPrefix,\n    children.get(index),\n    callback\n);\n\n\nb.group(bossGroup, workerGroup)\n    .channel(NioServerSocketChannel.class)\n    .option(ChannelOption.SO_BACKLOG, 1024)\n    .childHandler(new ChannelInitializer<SocketChannel>() {\n        // ...\n    });\n\n\npublic void execute(GrpcRequest request, Http2DataFrame frame, ChannelHandlerContext context) throws Throwable {\n    StreamObserver<GrpcResponse> responseObserver = new StreamObserver<GrpcResponse>() {\n        // ...\n        @Override\n        public void onNext(GrpcResponse res) {\n            context.writeAndFlush(new DefaultHttp2HeadersFrame(res.getEndHeader()).stream(frame.stream()));\n        }\n        // ...\n    };\n    // ...\n}\n\n\nb.group(bossGroup, workerGroup)\n    .channel(NioServerSocketChannel.class)\n    .option(ChannelOption.SO_BACKLOG, 1024)\n    .childHandler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        public void initChannel(SocketChannel ch) {\n            // ...\n        }\n    });\n\n\nrecursive(\n        deep + 1,\n        isLastFlag,\n        currentPrefix,\n        children.get(index),\n        callback\n);\n\n\nprivate void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n    callback.callback(deep, isLast, prefix, node);\n    if (!isLeaf(node)) {\n        List<TraceNode> children = node.getChildren();\n        if (children == null) {\n            return;\n        }\n        int size = children.size();\n        for (int index = 0; index < size; index++) {\n            boolean isLastFlag = index == size - 1;\n            String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n            recursive(\n                deep + 1,\n                isLastFlag,\n                currentPrefix,\n                children.get(index),\n                callback\n            );\n        }\n    }\n}\n\n\nprivate void recursive(int deep, boolean isLast, String prefix, TraceNode node, Callback callback) {\n    callback.callback(deep, isLast, prefix, node);\n    if (!isLeaf(node)) {\n        List<TraceNode> children = node.getChildren();\n        if (children == null) {\n            return;\n        }\n        int size = children.size();\n        for (int index = 0; index < size; index++) {\n            boolean isLastFlag = index == size - 1;\n            String currentPrefix = isLast ? prefix + STEP_EMPTY_BOARD : prefix + STEP_HAS_BOARD;\n            recursive(\n                deep + 1,\n                isLastFlag,\n                currentPrefix,\n                children.get(index),\n                callback\n            );\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "219", "src_id": "M474", "code": "\n   public Http2Headers getEndHeader() {\n       Http2Headers endHeader = new DefaultHttp2Headers().status(\"200\");\n   \n\n   if (headersFrame.headers().get(HEADER_PATH).toString()) {\n   \n\n   ArthasUnittest.ArthasUnittestResponse.Builder builder = ArthasUnittest.ArthasUnittestResponse.newBuilder();\n   \n\nprivate static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n    if (parentClassLoader.getChildren() == null){\n        return;\n    }\n    for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n        TreeElement child = new TreeElement(childClassLoader.getName());\n        parent.addChild(child);\n        renderSubtree(child, childClassLoader);\n    }\n}\n\n\nif (AbstractGrpcExecutor.class.equals(clazz) || GrpcExecutor.class.equals(clazz)) {\n\n\nfor (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n\n\nGrpcRequest grpcRequest = dataBuffer.get(streamId);\n\n\npublic static Class<?> getInnerGenericClass(Type type) {\n\n\n    if (parentClassLoader.getChildren() == null){\n\n\n    if (parentClassLoader.getChildren() == null) {\n\n\nfor (Class<?> clazz : classes) {\n\n\nArthasUnittest.ArthasUnittestResponse.Builder builder = ArthasUnittest.ArthasUnittestResponse.newBuilder();\n\n\nTreeElement child = new TreeElement(childClassLoader.getName());\n\n\nif (type instanceof Class<?>) {\n\n\n    private static void renderSubtree(TreeElement parent, ClassLoaderVO parentClassLoader) {\n        if (parentClassLoader.getChildren() == null) {\n            return;\n        }\n        for (ClassLoaderVO childClassLoader : parentClassLoader.getChildren()) {\n            TreeElement child = new TreeElement(childClassLoader.getName());\n            parent.addChild(child);\n            renderSubtree(child, childClassLoader);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "250", "src_id": "M1539", "code": "\n        @Override\n        public void onError(Throwable t) {\n            Status status = Status.fromThrowable(t);\n            sendResponse.writeError(status);\n            latch.countDown();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "251", "src_id": "M1555", "code": "\n    static Map<String, String> getHttpHeadersFromMetadata(Metadata trailer) {\n        Map<String, String> headers = new HashMap<>();\n        for (String key : trailer.keys()) {\n            if (EXCLUDED.contains(key.toLowerCase())) {\n                continue;\n            }\n            if (key.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n                // TODO allow any object type here\n                byte[] value = trailer.get(Metadata.Key.of(key, Metadata.BINARY_BYTE_MARSHALLER));\n                headers.put(key, new String(value));\n            } else {\n                String value = trailer.get(Metadata.Key.of(key, Metadata.ASCII_STRING_MARSHALLER));\n                headers.put(key, value);\n            }\n        }\n        return headers;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "252", "src_id": "M1553", "code": "\npublic byte[] getPrefix(byte[] in, Type type) {\n    int len = in.length;\n    return new byte[] {\n            type.value,\n            (byte) ((len >> 24) & 0xff),\n            (byte) ((len >> 16) & 0xff),\n            (byte) ((len >> 8) & 0xff),\n            (byte) ((len >> 0) & 0xff),\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "253", "src_id": "M1538", "code": "\nprivate Method getRpcMethod(Object stub, String rpcMethodName) {\n    for (Method m : stub.getClass().getMethods()) {\n        if (m.getName().equals(rpcMethodName)) {\n            return m;\n        }\n    }\n    throw new IllegalArgumentException(\"Couldn't find rpcmethod: \" + rpcMethodName);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "254", "src_id": "M1535", "code": "\nprivate Pair<String, String> getClassAndMethod(String pathInfo) throws IllegalArgumentException {\n    String[] tokens = pathInfo.substring(1).split(\"/\");\n    if (tokens.length != 2) {\n        throw new IllegalArgumentException(\"incorrect pathinfo: \" + pathInfo);\n    }\n\n    String className = tokens[0];\n    String methodName = tokens[1];\n    methodName = Character.toLowerCase(methodName.charAt(0)) + methodName.substring(1);\n    return new Pair<>(className, methodName);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "arthas", "pair_id": "261", "src_id": "M1530", "code": "\n@Override\npublic boolean isEndOfInput() throws Exception {\n    return input.isEndOfInput();\n}\n\n\n@Argument(index = 0, argName = \"cmd\", required = true)\n@Description(\"command name (start status stop dump)\")\npublic void setCmd(String cmd) {\n    this.cmd = cmd;\n}\n\n\n@Option(shortName = \"d\", longName = \"delay\")\n@Description(\"Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h. (NANOTIME, 0)\")\npublic void setDelay(String delay) {\n    this.delay = delay;\n}\n\n\n@Option(longName = \"duration\")\n@Description(\"Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s. (NANOTIME, 0)\")\npublic void setDuration(String duration) {\n    this.duration = duration;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}

{"project_name": "jedis", "pair_id": "1", "src_id": "M127", "code": "\n  private void build() {\n    // check build state to prevent recursion\n    if (building) {\n      return;\n    }\n    building = true;\n    try {\n      if (data != null) {\n        if (data instanceof JedisDataException) {\n          exception = (JedisDataException) data;\n        } else {\n          response = builder.build(data);\n        }\n      }\n      data = null;\n    } finally {\n      building = false;\n      built = true;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "2", "src_id": "M1184", "code": "\n  @Override\n  public int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "3", "src_id": "M1128", "code": "\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "4", "src_id": "M1154", "code": "\n  public String getElement() {\n    if (element != null) {\n      return SafeEncoder.encode(element);\n    }\n    return null;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "5", "src_id": "M937", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      GeoCoordinate that = (GeoCoordinate) o;\n      return Double.compare(that.longitude, longitude) == 0\n          && Double.compare(that.latitude, latitude) == 0;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "6", "src_id": "M1073", "code": "\n  @SuppressWarnings(\"unchecked\")\n  public List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "7", "src_id": "M127", "code": "\n  private void build() {\n      // check build state to prevent recursion\n      if (building) {\n          return;\n      }\n\n      building = true;\n      try {\n          if (data != null) {\n              if (data instanceof JedisDataException) {\n                  exception = (JedisDataException) data;\n              } else {\n                  response = builder.build(data);\n              }\n          }\n          data = null;\n      } finally {\n          building = false;\n          built = true;\n      }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "8", "src_id": "M1184", "code": "\n  @Override\n  public int read(byte[] b, int off, int len) throws JedisConnectionException {\n      ensureFill();\n\n      final int length = Math.min(limit - count, len);\n      System.arraycopy(buf, count, b, off, length);\n      count += length;\n      return length;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "9", "src_id": "M1128", "code": "\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n      String host = getMasterAddrByNameResult.get(0);\n      int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n      return new HostAndPort(host, port);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "10", "src_id": "M1154", "code": "\n  public String getElement() {\n      if (element != null) {\n          return SafeEncoder.encode(element);\n      }\n      return null;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "11", "src_id": "M937", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (o == null) {\n            return false;\n        }\n        if (o == this) {\n            return true;\n        }\n        if (!(o instanceof GeoCoordinate)) {\n            return false;\n        }\n        GeoCoordinate that = (GeoCoordinate) o;\n        if (Double.compare(that.longitude, longitude) != 0) {\n            return false;\n        }\n        return Double.compare(that.latitude, latitude) == 0;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "12", "src_id": "M1073", "code": "\n  @SuppressWarnings(\"unchecked\")\n  public List<byte[]> getBinaryMultiBulkReply() {\n      flush();\n      return (List<byte[]>) readProtocolWithCheckingBroken();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "13", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "14", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "15", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "16", "src_id": "M284", "code": "\n    @Override\n    public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n    }\n\n\n    public final CommandObject<SearchResult> ftSearch(String indexName, Query query) {\n      return new CommandObject<>(\n          checkAndRoundRobinSearchCommand(SearchCommand.SEARCH, indexName)\n              .addParams(query.dialectOptional(searchDialect.get())),\n          getSearchResultBuilder(\n              null,\n              () -> new SearchResultBuilder(!query.getNoContent(), query.getWithScores(), true)\n          )\n      );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "17", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n\n  public final CommandObject<SearchResult> ftSearch(String indexName, Query query) {\n    return new CommandObject<>(\n        checkAndRoundRobinSearchCommand(SearchCommand.SEARCH, indexName)\n            .addParams(query.dialectOptional(searchDialect.get())),\n        getSearchResultBuilder(\n            null,\n            () -> new SearchResultBuilder(!query.getNoContent(), query.getWithScores(), true)\n        )\n    );\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "18", "src_id": "M727", "code": "\n    @Override\n    public Map<String, CommandDocument> commandDocs(String... commands) {\n        checkIsInMultiOrPipeline();\n        connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n        return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n    }\n\n\n\n    public final CommandObject<SearchResult> ftSearch(String indexName, Query query) {\n        return new CommandObject<>(\n            checkAndRoundRobinSearchCommand(SearchCommand.SEARCH, indexName)\n                .addParams(query.dialectOptional(searchDialect.get())),\n            getSearchResultBuilder(\n                null,\n                () -> new SearchResultBuilder(!query.getNoContent(), query.getWithScores(), true)\n            )\n        );\n    }\n\n\n\n    @Override\n    public void addParams(CommandArguments args) {\n        if (noContent) {\n            args.add(NOCONTENT);\n        }\n        if (verbatim) {\n            args.add(VERBATIM);\n        }\n        if (noStopwords) {\n            args.add(NOSTOPWORDS);\n        }\n        if (withScores) {\n            args.add(WITHSCORES);\n        }\n\n        if (!filters.isEmpty()) {\n            filters.forEach(filter -> filter.addParams(args));\n        }\n\n        if (inKeys != null && !inKeys.isEmpty()) {\n            args.add(INKEYS).add(inKeys.size()).addObjects(inKeys);\n        }\n\n        if (inFields != null && !inFields.isEmpty()) {\n            args.add(INFIELDS).add(inFields.size()).addObjects(inFields);\n        }\n\n        if (returnFieldsNames != null && !returnFieldsNames.isEmpty()) {\n            args.add(RETURN);\n            LazyRawable returnCountObject = new LazyRawable();\n            args.add(returnCountObject); // holding a place for setting the total count later.\n            int returnCount = 0;\n            for (FieldName fn : returnFieldsNames) {\n                returnCount += fn.addCommandArguments(args);\n            }\n            returnCountObject.setRaw(Protocol.toByteArray(returnCount));\n        }\n\n        if (summarizeParams != null) {\n            args.addParams(summarizeParams);\n        } else if (summarize) {\n            args.add(SUMMARIZE);\n        }\n\n        if (highlightParams != null) {\n            args.addParams(highlightParams);\n        } else if (highlight) {\n            args.add(HIGHLIGHT);\n        }\n\n        if (slop != null) {\n            args.add(SLOP).add(slop);\n        }\n\n        if (timeout != null) {\n            args.add(TIMEOUT).add(timeout);\n        }\n\n        if (inOrder) {\n            args.add(INORDER);\n        }\n\n        if (language != null) {\n            args.add(LANGUAGE).add(language);\n        }\n\n        if (expander != null) {\n            args.add(EXPANDER).add(expander);\n        }\n\n        if (scorer != null) {\n            args.add(SCORER).add(scorer);\n        }\n\n        // if (explainScore) {\n        //     args.add(EXPLAINSCORE);\n        // }\n\n        if (sortBy != null) {\n            args.add(SORTBY).add(sortBy);\n            if (sortOrder != null) {\n                args.add(sortOrder);\n            }\n        }\n\n        if (limit != null) {\n            args.add(LIMIT).add(limit[0]).add(limit[1]);\n        }\n\n        if (params != null && !params.isEmpty()) {\n            args.add(PARAMS).add(params.size() << 1);\n            params.entrySet().forEach(entry -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n\n        if (dialect != null) {\n            args.add(DIALECT).add(dialect);\n        }\n    }\n\n\n\n    @Override\n    public void addParams(CommandArguments args) {\n        if (to != null) {\n            args.add(Keyword.TO).add(to.getHost()).add(to.getPort());\n        }\n\n        if (force) {\n            if (to == null || timeout == null) {\n                throw new IllegalArgumentException(\"FAILOVER with force option requires both a timeout and target HOST and IP.\");\n            }\n            args.add(Keyword.FORCE);\n        }\n\n        if (timeout != null) {\n            args.add(Keyword.TIMEOUT).add(timeout);\n        }\n    }\n\n\n\n    @Override\n    public final List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"EXEC without MULTI\");\n        }\n\n        try (Connection connection = failoverProvider.getConnection()) {\n\n            commands.forEach(command -> connection.sendCommand(command.getKey()));\n            // following connection.getMany(int) flushes anyway, so no flush here.\n\n            // ignore QUEUED (or ERROR)\n            connection.getMany(commands.size());\n\n            // remove extra response builders\n            for (int idx = 0; idx < extraCommandCount.get(); ++idx) {\n                commands.poll();\n            }\n\n            connection.sendCommand(EXEC);\n\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                commands.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size() - extraCommandCount.get());\n            for (Object rawReply : unformatted) {\n                try {\n                    Response<?> response = commands.poll().getValue();\n                    response.set(rawReply);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n\n        } finally {\n            inMulti = false;\n            inWatch = false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "19", "src_id": "M728", "code": "\n    @Override\n    public List<String> commandGetKeys(String... command) {\n        checkIsInMultiOrPipeline();\n        connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n        return BuilderFactory.STRING_LIST.build(connection.getOne());\n    }\n\n\n    public final CommandObject<SearchResult> ftSearch(String indexName, Query query) {\n        return new CommandObject<>(\n            checkAndRoundRobinSearchCommand(SearchCommand.SEARCH, indexName)\n                .addParams(query.dialectOptional(searchDialect.get())),\n            getSearchResultBuilder(\n                null,\n                () -> new SearchResultBuilder(!query.getNoContent(), query.getWithScores(), true)\n            )\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "20", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "21", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n\n    CommandArguments args = new CommandArguments(COMMAND)\n        .add(LIST)\n        .addParams(filterByParams);\n\n    connection.sendCommand(args);\n\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "22", "src_id": "M712", "code": "\n    @Override\n    public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "23", "src_id": "M551", "code": "\n    @Override\n    public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n    }\n\n\n\n    public final CommandObject<SearchResult> ftSearch(String indexName, Query query) {\n      return new CommandObject<>(checkAndRoundRobinSearchCommand(SearchCommand.SEARCH, indexName)\n          .addParams(query.dialectOptional(searchDialect.get())),\n          getSearchResultBuilder(null, () -> new SearchResultBuilder(!query.getNoContent(),\n              query.getWithScores(), true)));\n    }\n\n\n\n    @Override\n    public void addParams(CommandArguments args) {\n\n      if (noContent) {\n        args.add(NOCONTENT);\n      }\n      if (verbatim) {\n        args.add(VERBATIM);\n      }\n      if (noStopwords) {\n        args.add(NOSTOPWORDS);\n      }\n      if (withScores) {\n        args.add(WITHSCORES);\n      }\n\n      if (!filters.isEmpty()) {\n        filters.forEach(filter -> filter.addParams(args));\n      }\n\n      if (inKeys != null && !inKeys.isEmpty()) {\n        args.add(INKEYS).add(inKeys.size()).addObjects(inKeys);\n      }\n\n      if (inFields != null && !inFields.isEmpty()) {\n        args.add(INFIELDS).add(inFields.size()).addObjects(inFields);\n      }\n\n      if (returnFieldsNames != null && !returnFieldsNames.isEmpty()) {\n        args.add(RETURN);\n        LazyRawable returnCountObject = new LazyRawable();\n        args.add(returnCountObject); // holding a place for setting the total count later.\n        int returnCount = 0;\n        for (FieldName fn : returnFieldsNames) {\n          returnCount += fn.addCommandArguments(args);\n        }\n        returnCountObject.setRaw(Protocol.toByteArray(returnCount));\n      }\n\n      if (summarizeParams != null) {\n        args.addParams(summarizeParams);\n      } else if (summarize) {\n        args.add(SUMMARIZE);\n      }\n\n      if (highlightParams != null) {\n        args.addParams(highlightParams);\n      } else if (highlight) {\n        args.add(HIGHLIGHT);\n      }\n\n      if (slop != null) {\n        args.add(SLOP).add(slop);\n      }\n\n      if (timeout != null) {\n        args.add(TIMEOUT).add(timeout);\n      }\n\n      if (inOrder) {\n        args.add(INORDER);\n      }\n\n      if (language != null) {\n        args.add(LANGUAGE).add(language);\n      }\n\n      if (expander != null) {\n        args.add(EXPANDER).add(expander);\n      }\n\n      if (scorer != null) {\n        args.add(SCORER).add(scorer);\n      }\n\n  //    if (explainScore) {\n  //      args.add(EXPLAINSCORE);\n  //    }\n\n      if (sortBy != null) {\n        args.add(SORTBY).add(sortBy);\n        if (sortOrder != null) {\n          args.add(sortOrder);\n        }\n      }\n\n      if (limit != null) {\n        args.add(LIMIT).add(limit[0]).add(limit[1]);\n      }\n\n      if (params != null && !params.isEmpty()) {\n        args.add(PARAMS).add(params.size() << 1);\n        params.entrySet().forEach(entry -> args.add(entry.getKey()).add(entry.getValue()));\n      }\n\n      if (dialect != null) {\n        args.add(DIALECT).add(dialect);\n      }\n    }\n\n\n\n    @Override\n    public void addParams(CommandArguments args) {\n\n      if (to != null) {\n        args.add(Keyword.TO).add(to.getHost()).add(to.getPort());\n      }\n\n      if (force) {\n        if (to == null || timeout == null) {\n          throw new IllegalArgumentException(\n              \"FAILOVER with force option requires both a timeout and target HOST and IP.\");\n        }\n        args.add(Keyword.FORCE);\n      }\n\n      if (timeout != null) {\n        args.add(Keyword.TIMEOUT).add(timeout);\n      }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "24", "src_id": "M844", "code": "\n    @Override\n    public List<Object> functionListBinary() {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.functionListBinary());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "25", "src_id": "M298", "code": "\n    @Override\n    public long sintercard(int limit, byte[]... keys) {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.sintercard(limit, keys));\n    }\n\n\n    public final CommandObject<SearchResult> ftSearch(String indexName, Query query) {\n      return new CommandObject<>(\n          checkAndRoundRobinSearchCommand(SearchCommand.SEARCH, indexName)\n              .addParams(query.dialectOptional(searchDialect.get())),\n          getSearchResultBuilder(\n              null,\n              () -> new SearchResultBuilder(!query.getNoContent(), query.getWithScores(), true)\n          )\n      );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "26", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "27", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "28", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "29", "src_id": "M1291", "code": "\n  private static void appendNum(final StringBuilder sb, final double n, final boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "30", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    final StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "31", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    final StringBuilder sb = new StringBuilder();\n    final StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "32", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "33", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "34", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "35", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) {\n      return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(\n              BINARY.build(kv.getKey()),\n              STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (Object anObj : list) {\n        List<Object> streamObj = (List<Object>) anObj;\n        byte[] streamKey = BINARY.build(streamObj.get(0));\n        List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "36", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "37", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object other) {\n    if (this == other) return true;\n    if (other == null || getClass() != other.getClass()) return false;\n    ByteArrayWrapper that = (ByteArrayWrapper) other;\n    return Arrays.equals(data, that.data);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "38", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "39", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "40", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD)\n        .addParams(xReadParams)\n        .add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "41", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "42", "src_id": "M1177", "code": "\n  public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource == null) {\n      return;\n    }\n\n    try {\n      resource.close();\n    } catch (Exception e) {\n      // ignored\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "43", "src_id": "M620", "code": "\n  @Override\n  public Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "44", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n        List<Object> list = (List<Object>) data;\n\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        Map<byte[], byte[]> map = new JedisByteHashMap();\n\n        if (list.get(0) instanceof KeyValue) {\n            Iterator<?> iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n        } else {\n            Iterator<?> iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n        }\n\n        return map;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "45", "src_id": "M933", "code": "\n  @Deprecated\n  public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n    if (credentialsProvider != null) {\n      builder.credentialsProvider(credentialsProvider);\n    } else {\n      builder.user(copy.getUser());\n      builder.password(copy.getPassword());\n    }\n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n      builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "46", "src_id": "M1146", "code": "\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            // TODO: Pipeline asking with the original command to make it faster....\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica\n              ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        consecutiveConnectionFailures++;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n\n        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        // avoid updating lastException if it is a connection exception\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        // if MOVED redirection occurred,\n        if (jre instanceof JedisMovedDataException) {\n          // it rebuilds cluster's slot cache recommended by Redis cluster specification\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException =\n        new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "47", "src_id": "M884", "code": "\n  @Override\n  public void addParams(CommandArguments args) {\n    if (filters == null) {\n      throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n    }\n\n    if (fromTimestamp == null) {\n      args.add(MINUS);\n    } else {\n      args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n      args.add(PLUS);\n    } else {\n      args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n      args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n      args.add(FILTER_BY_TS);\n      for (long ts : filterByTimestamps) {\n        args.add(toByteArray(ts));\n      }\n    }\n\n    if (filterByValues != null) {\n      args.add(FILTER_BY_VALUE);\n      for (double value : filterByValues) {\n        args.add(toByteArray(value));\n      }\n    }\n\n    if (withLabels) {\n      args.add(WITHLABELS);\n    } else if (selectedLabels != null) {\n      args.add(SELECTED_LABELS);\n      for (String label : selectedLabels) {\n        args.add(label);\n      }\n    }\n\n    if (count != null) {\n      args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n      if (align != null) {\n        args.add(ALIGN).add(align);\n      }\n\n      args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n      if (bucketTimestamp != null) {\n        args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n      }\n\n      if (empty) {\n        args.add(EMPTY);\n      }\n    }\n\n    args.add(FILTER);\n    for (String filter : filters) {\n      args.add(filter);\n    }\n\n    if (groupByLabel != null && groupByReduce != null) {\n      args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "48", "src_id": "M502", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "49", "src_id": "M416", "code": "\n  @Override\n  public List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "50", "src_id": "M390", "code": "\n  @Override\n  public Long objectFreq(byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "51", "src_id": "M231", "code": "\n  public GeoRadiusStoreParam storeDist(String key) {\n    if (key != null) {\n      this.storeDist = true;\n      this.key = key;\n    }\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "52", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "53", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "54", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "55", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "56", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "57", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND)\n        .add(LIST)\n        .addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "58", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "59", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "60", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "61", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "62", "src_id": "M107", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n      if (data == null) {\n        return null;\n      }\n      List list = (List) data;\n      if (list.isEmpty()) {\n        return Collections.emptyList();\n      }\n\n      if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n            .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n                STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n            .collect(Collectors.toList());\n      } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n        for (Object anObj : list) {\n          List<Object> streamObj = (List<Object>) anObj;\n          byte[] streamKey = BINARY.build(streamObj.get(0));\n          List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n          result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "63", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n\n  private static Constructor findConstructorWithCacheable(Class customCacheType) {\n    return Arrays.stream(customCacheType.getConstructors())\n        .filter(ctor -> Arrays.equals(ctor.getParameterTypes(),\n            new Class[] { int.class, EvictionPolicy.class, Cacheable.class }))\n        .findFirst().orElse(null);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "64", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object other) {\n    if (other == null) return false;\n    if (other == this) return true;\n    if (!(other instanceof ByteArrayWrapper)) return false;\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n  }\n\n\n  private static Constructor findConstructorWithCacheable(Class customCacheType) {\n    return Arrays.stream(customCacheType.getConstructors())\n        .filter(ctor -> Arrays.equals(ctor.getParameterTypes(),\n            new Class[] { int.class, EvictionPolicy.class, Cacheable.class }))\n        .findFirst().orElse(null);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "65", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n      Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "66", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "67", "src_id": "M1009", "code": "\n  @Override\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREAD)\n        .addParams(xReadParams)\n        .add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "68", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n      XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "69", "src_id": "M1291", "code": "\n    private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n      if (!inclusive) {\n        sb.append(\"(\");\n      }\n      if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n      } else if (n == Double.POSITIVE_INFINITY) {\n        sb.append(\"inf\");\n      } else {\n        sb.append(n);\n      }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "70", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "71", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n\n    sb.append(sj.toString());\n\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "72", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "73", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "74", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n      int result = Boolean.hashCode(latest);\n      result = 31 * result + Boolean.hashCode(withLabels);\n      result = 31 * result + Arrays.hashCode(selectedLabels);\n      return result;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "75", "src_id": "M127", "code": "\n  private void build() {\n    // check build state to prevent recursion\n    if (building) {\n      return;\n    }\n\n    building = true;\n    try {\n      if (data != null) {\n        if (data instanceof JedisDataException) {\n          exception = (JedisDataException) data;\n        } else {\n          response = builder.build(data);\n        }\n      }\n      data = null;\n    } finally {\n      building = false;\n      built = true;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "76", "src_id": "M1184", "code": "\n  @Override\n  public int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n\n    int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "77", "src_id": "M1128", "code": "\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n    return new HostAndPort(host, port);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "78", "src_id": "M1154", "code": "\n  public String getElement() {\n    if (element != null) {\n      return SafeEncoder.encode(element);\n    }\n    return null;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "79", "src_id": "M937", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    GeoCoordinate that = (GeoCoordinate) o;\n    return Double.compare(longitude, that.longitude) == 0 &&\n        Double.compare(latitude, that.latitude) == 0;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "80", "src_id": "M1073", "code": "\n  @SuppressWarnings(\"unchecked\")\n  public List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "81", "src_id": "M1291", "code": "\n  private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n      sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n      sb.append(\"-inf\");\n    } else if (n == Double.POSITIVE_INFINITY) {\n      sb.append(\"inf\");\n    } else {\n      sb.append(n);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "82", "src_id": "M1292", "code": "\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "83", "src_id": "M1290", "code": "\n  @Override\n  public String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append('(');\n    }\n    for (Node n : children) {\n      sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n      sb.append(')');\n    }\n    return sb.toString();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "84", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "85", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "86", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "87", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "88", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "89", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "90", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "91", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "92", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "93", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "94", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "95", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "96", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n      checkIsInMultiOrPipeline();\n      connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n      return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "97", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.commandGetKeys(command));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "98", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n      this.byBox = true;\n      this.width = width;\n      this.height = height;\n      this.unit = unit;\n      return this;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "99", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND)\n        .add(LIST)\n        .addParams(filterByParams);\n    return connection.executeCommand(commandObjects.commandListFilterBy(args));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "100", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(String keyA, String keyB, LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "101", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(String key, long milliseconds, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "102", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n      checkIsInMultiOrPipeline();\n      return connection.executeCommand(commandObjects.functionListBinary());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "103", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "104", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "105", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "106", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "107", "src_id": "M107", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n\n        List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyList();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            return ((List<KeyValue>) list).stream()\n                    .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n                            STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n                    .collect(Collectors.toList());\n        } else {\n            List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n            for (Object anObj : list) {\n                List<Object> streamObj = (List<Object>) anObj;\n                byte[] streamKey = BINARY.build(streamObj.get(0));\n                List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n                result.add(KeyValue.of(streamKey, streamEntries));\n            }\n            return result;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "108", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "109", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ByteArrayWrapper that = (ByteArrayWrapper) o;\n    return Arrays.equals(data, that.data);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "110", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n      Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "111", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "112", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD)\n        .addParams(xReadParams)\n        .add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "113", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n                                 XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "114", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) {\n      return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n              STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (Object anObj : list) {\n        List<Object> streamObj = (List<Object>) anObj;\n        byte[] streamKey = BINARY.build(streamObj.get(0));\n        List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "115", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "116", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    ByteArrayWrapper that = (ByteArrayWrapper) o;\n    return Arrays.equals(data, that.data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "117", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n      Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "118", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "119", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "120", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(\n      byte[] groupName,\n      byte[] consumer,\n      XReadGroupParams xReadGroupParams,\n      Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "121", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(String key, HGetExParams params, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "122", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    final BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration)\n        && Objects.equals(expirationValue, setParams.expirationValue);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "123", "src_id": "M227", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance)\n        && super.equals((BaseSetExParams) o);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "124", "src_id": "M868", "code": "\n  private void safeReAuthenticate(final Token token) {\n    try {\n      final byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n      final byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n      final Token newToken = pendingTokenRef.getAndSet(token);\n      if (newToken == null) {\n        commandSync.lock();\n        try {\n          sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n          resultHandler.add(this.authResultHandler);\n        } finally {\n          pendingTokenRef.set(null);\n          commandSync.unlock();\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error while re-authenticating connection\", e);\n      client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "125", "src_id": "M957", "code": "\n  public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n      this.listener = listener;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "126", "src_id": "M960", "code": "\n  private void processPingReply(final Object reply) {\n    final byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n      onPong(null);\n    } else {\n      onPong(encode(resp));\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "127", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(String key, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "128", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(final Object data) {\n    if (data == null) {\n      return null;\n    }\n\n    final List<?> list = (List<?>) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()), STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      final List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (final Object anObj : list) {\n        final List<Object> streamObj = (List<Object>) anObj;\n        final byte[] streamKey = BINARY.build(streamObj.get(0));\n        final List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n\n\n  @Override\n  public List<GeoCoordinate> build(final Object data) {\n    if (data == null) {\n      return null;\n    }\n    return interpretGeoposResult((List<Object>) data);\n  }\n\n\n\n  private List<Integer> getAssignedSlotArray(final List<Object> slotInfo) {\n    final List<Integer> slotNums = new ArrayList<>();\n    for (int slot = ((Long) slotInfo.get(0)).intValue(); slot <= ((Long) slotInfo.get(1)).intValue(); slot++) {\n      slotNums.add(slot);\n    }\n    return slotNums;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "129", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    for (Map.Entry<byte[], StreamEntryID> entry : entrySet) {\n      args.key(entry.getKey());\n    }\n    for (Map.Entry<byte[], StreamEntryID> entry : entrySet) {\n      args.add(entry.getValue());\n    }\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "130", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(final Object other) {\n    if (other == null) {\n      return false;\n    }\n    if (other == this) {\n      return true;\n    }\n    if (!(other instanceof ByteArrayWrapper)) {\n      return false;\n    }\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "131", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(final XReadParams xReadParams,\n      final Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "132", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n\n    final CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    final Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n\n    for (Map.Entry<byte[], StreamEntryID> entry : entrySet) {\n      args.key(entry.getKey());\n    }\n    for (Map.Entry<byte[], StreamEntryID> entry : entrySet) {\n      args.add(entry.getValue());\n    }\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "133", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    for (Map.Entry<byte[], StreamEntryID> entry : entrySet) {\n      args.key(entry.getKey());\n    }\n    for (Map.Entry<byte[], StreamEntryID> entry : entrySet) {\n      args.add(entry.getValue());\n    }\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "134", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(final byte[] groupName, final byte[] consumer,\n      final XReadGroupParams xReadGroupParams, final Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "135", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "136", "src_id": "M1104", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "137", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change\n        && existence == that.existence\n        && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "138", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "139", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs)\n        && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "140", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy\n        && replace == that.replace\n        && Objects.equals(username, that.username)\n        && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "141", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "142", "src_id": "M1177", "code": "\n  public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource != null) {\n      try {\n        resource.close();\n      } catch (Exception e) {\n        // ignored\n      }\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "143", "src_id": "M620", "code": "\n  @Override\n  public Set<String> sinter(String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "144", "src_id": "M50", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public Map<byte[], byte[]> build(Object data) {\n    List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n      return Collections.emptyMap();\n    }\n\n    Map<byte[], byte[]> map = new JedisByteHashMap();\n    Iterator iterator = list.iterator();\n\n    if (list.get(0) instanceof KeyValue) {\n      while (iterator.hasNext()) {\n        KeyValue kv = (KeyValue) iterator.next();\n        map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n      }\n    } else {\n      while (iterator.hasNext()) {\n        map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n      }\n    }\n    return map;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "145", "src_id": "M933", "code": "\n  @Deprecated\n  public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n    if (credentialsProvider != null) {\n      builder.credentialsProvider(credentialsProvider);\n    } else {\n      builder.user(copy.getUser());\n      builder.password(copy.getPassword());\n    }\n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n      builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "146", "src_id": "M1146", "code": "\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n      Connection connection = null;\n      try {\n        if (redirect != null) {\n          connection = provider.getConnection(redirect.getTargetNode());\n          if (redirect instanceof JedisAskDataException) {\n            // TODO: Pipeline asking with the original command to make it faster....\n            connection.executeCommand(Protocol.Command.ASKING);\n          }\n        } else {\n          connection = toReplica\n              ? provider.getReplicaConnection(commandObject.getArguments())\n              : provider.getConnection(commandObject.getArguments());\n        }\n\n        return execute(connection, commandObject);\n\n      } catch (JedisClusterOperationException jnrcne) {\n        throw jnrcne;\n      } catch (JedisConnectionException jce) {\n        lastException = jce;\n        consecutiveConnectionFailures++;\n        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n        if (reset) {\n          consecutiveConnectionFailures = 0;\n          redirect = null;\n        }\n      } catch (JedisRedirectionException jre) {\n        // avoid updating lastException if it is a connection exception\n        if (lastException == null || lastException instanceof JedisRedirectionException) {\n          lastException = jre;\n        }\n        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n        consecutiveConnectionFailures = 0;\n        redirect = jre;\n        // if MOVED redirection occurred,\n        if (jre instanceof JedisMovedDataException) {\n          // it rebuilds cluster's slot cache recommended by Redis cluster specification\n          provider.renewSlotCache(connection);\n        }\n      } finally {\n        IOUtils.closeQuietly(connection);\n      }\n      if (Instant.now().isAfter(deadline)) {\n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n      }\n    }\n\n    JedisClusterOperationException maxAttemptsException =\n        new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "147", "src_id": "M884", "code": "\n  @Override\n  public void addParams(CommandArguments args) {\n    if (filters == null) {\n      throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n    }\n\n    if (fromTimestamp == null) {\n      args.add(MINUS);\n    } else {\n      args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n      args.add(PLUS);\n    } else {\n      args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n      args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n      args.add(FILTER_BY_TS);\n      for (long ts : filterByTimestamps) {\n        args.add(toByteArray(ts));\n      }\n    }\n\n    if (filterByValues != null) {\n      args.add(FILTER_BY_VALUE);\n      for (double value : filterByValues) {\n        args.add(toByteArray(value));\n      }\n    }\n\n    if (withLabels) {\n      args.add(WITHLABELS);\n    } else if (selectedLabels != null) {\n      args.add(SELECTED_LABELS);\n      for (String label : selectedLabels) {\n        args.add(label);\n      }\n    }\n\n    if (count != null) {\n      args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n      if (align != null) {\n        args.add(ALIGN).add(align);\n      }\n\n      args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n      if (bucketTimestamp != null) {\n        args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n      }\n\n      if (empty) {\n        args.add(EMPTY);\n      }\n    }\n\n    args.add(FILTER);\n    for (String filter : filters) {\n      args.add(filter);\n    }\n\n    if (groupByLabel != null && groupByReduce != null) {\n      args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "148", "src_id": "M502", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "149", "src_id": "M416", "code": "\n  @Override\n  public List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "150", "src_id": "M390", "code": "\n  @Override\n  public Long objectFreq(byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "151", "src_id": "M231", "code": "\n  public GeoRadiusStoreParam storeDist(String key) {\n    if (key != null) {\n      this.storeDist = true;\n      this.key = key;\n    }\n    return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "152", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "153", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "154", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "155", "src_id": "M127", "code": "\n  private void build() {\n    // check build state to prevent recursion\n    if (building) {\n      return;\n    }\n    building = true;\n    try {\n      if (data != null) {\n        if (data instanceof JedisDataException) {\n          exception = (JedisDataException) data;\n        } else {\n          response = builder.build(data);\n        }\n      }\n      data = null;\n    } finally {\n      building = false;\n      built = true;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "156", "src_id": "M1184", "code": "\n  @Override\n  public int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "157", "src_id": "M1128", "code": "\n  private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n    return new HostAndPort(host, port);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "158", "src_id": "M1154", "code": "\n  public String getElement() {\n    if (element != null) {\n      return SafeEncoder.encode(element);\n    }\n    return null;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "159", "src_id": "M937", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (o == null) {\n      return false;\n    }\n    if (o == this) {\n      return true;\n    }\n    if (!(o instanceof GeoCoordinate)) {\n      return false;\n    }\n    GeoCoordinate that = (GeoCoordinate) o;\n    if (Double.compare(that.longitude, longitude) != 0) {\n      return false;\n    }\n    return Double.compare(that.latitude, latitude) == 0;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "160", "src_id": "M1073", "code": "\n  @SuppressWarnings(\"unchecked\")\n  public List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "161", "src_id": "M284", "code": "\n  @Override\n  public long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(\n        commandObjects.expireAt(key, unixTime, expiryOption)\n    );\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "162", "src_id": "M792", "code": "\n  @Override\n  public List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "163", "src_id": "M727", "code": "\n  @Override\n  public Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "164", "src_id": "M728", "code": "\n  @Override\n  public List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "165", "src_id": "M245", "code": "\n  public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "166", "src_id": "M732", "code": "\n  @Override\n  public List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND)\n        .add(LIST)\n        .addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "167", "src_id": "M712", "code": "\n  @Override\n  public LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "168", "src_id": "M551", "code": "\n  @Override\n  public long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "169", "src_id": "M844", "code": "\n  @Override\n  public List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "170", "src_id": "M298", "code": "\n  @Override\n  public long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "171", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(String key, HGetExParams params, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "172", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      BaseSetExParams setParams = (BaseSetExParams) o;\n      return Objects.equals(expiration, setParams.expiration)\n              && Objects.equals(expirationValue, setParams.expirationValue);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "173", "src_id": "M227", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance)\n        && super.equals((BaseSetExParams) o);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "174", "src_id": "M868", "code": "\n  private void safeReAuthenticate(Token token) {\n      try {\n          byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n          byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n          Token newToken = pendingTokenRef.getAndSet(token);\n          if (newToken == null) {\n              commandSync.lock();\n              try {\n                  sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n                  resultHandler.add(this.authResultHandler);\n              } finally {\n                  pendingTokenRef.set(null);\n                  commandSync.unlock();\n              }\n          }\n      } catch (Exception e) {\n          logger.error(\"Error while re-authenticating connection\", e);\n          client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n      }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "175", "src_id": "M957", "code": "\n  public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n      this.listener = listener;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "176", "src_id": "M960", "code": "\n    private void processPingReply(Object reply) {\n        byte[] resp = (byte[]) reply;\n        if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n            onPong(null);\n        } else {\n            onPong(encode(resp));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "177", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(String key, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "178", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "179", "src_id": "M1104", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "180", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change\n        && existence == that.existence\n        && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "181", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "182", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs)\n        && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "183", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy\n        && replace == that.replace\n        && Objects.equals(username, that.username)\n        && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "184", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "185", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n      return false;\n    }\n    TSArithByParams<?> that = (TSArithByParams<?>) obj;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "186", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n\n    if (!(obj instanceof TSCreateParams)) {\n      return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) obj;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "187", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "188", "src_id": "M1177", "code": "\n  public static void closeQuietly(AutoCloseable resource) {\n      // It's same thing as Apache Commons - IOUtils.closeQuietly()\n      if (resource != null) {\n          try {\n              resource.close();\n          } catch (Exception e) {\n              // ignored\n          }\n      }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "189", "src_id": "M620", "code": "\n  @Override\n  public Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "190", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) return Collections.emptyMap();\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator<?> iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator<?> iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "191", "src_id": "M933", "code": "\n  @Deprecated\n  public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n      Builder builder = builder();\n      builder.protocol(copy.getRedisProtocol());\n      builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n      builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n      builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n      Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n      if (credentialsProvider != null) {\n          builder.credentialsProvider(credentialsProvider);\n      } else {\n          builder.user(copy.getUser());\n          builder.password(copy.getPassword());\n      }\n\n      builder.database(copy.getDatabase());\n      builder.clientName(copy.getClientName());\n\n      builder.ssl(copy.isSsl());\n      builder.sslSocketFactory(copy.getSslSocketFactory());\n      builder.sslParameters(copy.getSslParameters());\n      builder.hostnameVerifier(copy.getHostnameVerifier());\n      builder.sslOptions(copy.getSslOptions());\n      builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n      builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n      if (copy.isReadOnlyForRedisClusterReplicas()) {\n          builder.readOnlyForRedisClusterReplicas();\n      }\n\n      builder.authXManager(copy.getAuthXManager());\n\n      return builder.build();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "192", "src_id": "M1146", "code": "\n  private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n      Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n      JedisRedirectionException redirect = null;\n      int consecutiveConnectionFailures = 0;\n      Exception lastException = null;\n      for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n          Connection connection = null;\n          try {\n              if (redirect != null) {\n                  connection = provider.getConnection(redirect.getTargetNode());\n                  if (redirect instanceof JedisAskDataException) {\n                      // TODO: Pipeline asking with the original command to make it faster....\n                      connection.executeCommand(Protocol.Command.ASKING);\n                  }\n              } else {\n                  connection = toReplica\n                      ? provider.getReplicaConnection(commandObject.getArguments())\n                      : provider.getConnection(commandObject.getArguments());\n              }\n\n              return execute(connection, commandObject);\n\n          } catch (JedisClusterOperationException jnrcne) {\n              throw jnrcne;\n          } catch (JedisConnectionException jce) {\n              lastException = jce;\n              ++consecutiveConnectionFailures;\n              log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n              // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n              boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n              if (reset) {\n                  consecutiveConnectionFailures = 0;\n                  redirect = null;\n              }\n          } catch (JedisRedirectionException jre) {\n              // avoid updating lastException if it is a connection exception\n              if (lastException == null || lastException instanceof JedisRedirectionException) {\n                  lastException = jre;\n              }\n              log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n              consecutiveConnectionFailures = 0;\n              redirect = jre;\n              // if MOVED redirection occurred,\n              if (jre instanceof JedisMovedDataException) {\n                  // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                  provider.renewSlotCache(connection);\n              }\n          } finally {\n              IOUtils.closeQuietly(connection);\n          }\n          if (Instant.now().isAfter(deadline)) {\n              throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n          }\n      }\n\n      JedisClusterOperationException maxAttemptsException =\n          new JedisClusterOperationException(\"No more cluster attempts left.\");\n      maxAttemptsException.addSuppressed(lastException);\n      throw maxAttemptsException;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "193", "src_id": "M884", "code": "\n  @Override\n  public void addParams(CommandArguments args) {\n      if (filters == null) {\n          throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n      }\n\n      if (fromTimestamp == null) {\n          args.add(MINUS);\n      } else {\n          args.add(toByteArray(fromTimestamp));\n      }\n\n      if (toTimestamp == null) {\n          args.add(PLUS);\n      } else {\n          args.add(toByteArray(toTimestamp));\n      }\n\n      if (latest) {\n          args.add(LATEST);\n      }\n\n      if (filterByTimestamps != null) {\n          args.add(FILTER_BY_TS);\n          for (long ts : filterByTimestamps) {\n              args.add(toByteArray(ts));\n          }\n      }\n\n      if (filterByValues != null) {\n          args.add(FILTER_BY_VALUE);\n          for (double value : filterByValues) {\n              args.add(toByteArray(value));\n          }\n      }\n\n      if (withLabels) {\n          args.add(WITHLABELS);\n      } else if (selectedLabels != null) {\n          args.add(SELECTED_LABELS);\n          for (String label : selectedLabels) {\n              args.add(label);\n          }\n      }\n\n      if (count != null) {\n          args.add(COUNT).add(toByteArray(count));\n      }\n\n      if (aggregationType != null) {\n\n          if (align != null) {\n              args.add(ALIGN).add(align);\n          }\n\n          args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n          if (bucketTimestamp != null) {\n              args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n          }\n\n          if (empty) {\n              args.add(EMPTY);\n          }\n      }\n\n      args.add(FILTER);\n      for (String filter : filters) {\n          args.add(filter);\n      }\n\n      if (groupByLabel != null && groupByReduce != null) {\n          args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n      }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "194", "src_id": "M502", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "195", "src_id": "M416", "code": "\n  @Override\n  public List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "196", "src_id": "M390", "code": "\n  @Override\n  public Long objectFreq(final byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "197", "src_id": "M231", "code": "\n  public GeoRadiusStoreParam storeDist(String key) {\n      if (key != null) {\n          this.storeDist = true;\n          this.key = key;\n      }\n      return this;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "198", "src_id": "M777", "code": "\n  @Override\n  public List<Map<String, Object>> clusterLinks() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n    return connection.getObjectMultiBulkReply().stream()\n        .map(BuilderFactory.ENCODED_OBJECT_MAP::build)\n        .collect(Collectors.toList());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "199", "src_id": "M779", "code": "\n  @Override\n  public String clusterDelSlotsRange(int... ranges) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(\n        CLUSTER,\n        joinParameters(\n            ClusterKeyword.DELSLOTSRANGE.getRaw(),\n            joinParameters(ranges)\n        )\n    );\n    return connection.getStatusCodeReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "200", "src_id": "M818", "code": "\n  @Override\n  public Map<String, Object> memoryStats() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(MEMORY, STATS);\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "201", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(String key, HGetExParams params, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "202", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration)\n        && Objects.equals(expirationValue, setParams.expirationValue);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "203", "src_id": "M227", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "204", "src_id": "M868", "code": "\n  private void safeReAuthenticate(Token token) {\n    try {\n      byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n      byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n      Token newToken = pendingTokenRef.getAndSet(token);\n      if (newToken == null) {\n        commandSync.lock();\n        try {\n          sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n          resultHandler.add(this.authResultHandler);\n        } finally {\n          pendingTokenRef.set(null);\n          commandSync.unlock();\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error while re-authenticating connection\", e);\n      client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "205", "src_id": "M957", "code": "\n  public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n      this.listener = listener;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "206", "src_id": "M960", "code": "\n  private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n      onPong(null);\n    } else {\n      onPong(encode(resp));\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "207", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(String key, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "208", "src_id": "M890", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    final TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(timestamp, that.timestamp)\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "209", "src_id": "M903", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    final TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore\n        && ignoreMaxTimediff == that.ignoreMaxTimediff\n        && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n        && Objects.equals(retentionPeriod, that.retentionPeriod)\n        && encoding == that.encoding\n        && Objects.equals(chunkSize, that.chunkSize)\n        && duplicatePolicy == that.duplicatePolicy\n        && Objects.equals(labels, that.labels);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "210", "src_id": "M907", "code": "\n  @Override\n  public int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "211", "src_id": "M580", "code": "\n  @Override\n  public List<String> hgetex(String key, HGetExParams params, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "212", "src_id": "M237", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration)\n        && Objects.equals(expirationValue, setParams.expirationValue);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "213", "src_id": "M227", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance)\n        && super.equals((BaseSetExParams) o);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "214", "src_id": "M868", "code": "\n  private void safeReAuthenticate(Token token) {\n    try {\n      byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n      byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n      Token newToken = pendingTokenRef.getAndSet(token);\n      if (newToken == null) {\n        commandSync.lock();\n        try {\n          sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n          resultHandler.add(this.authResultHandler);\n        } finally {\n          pendingTokenRef.set(null);\n          commandSync.unlock();\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error while re-authenticating connection\", e);\n      client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "215", "src_id": "M957", "code": "\n  public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n      this.listener = listener;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "216", "src_id": "M960", "code": "\n  private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n      onPong(null);\n    } else {\n      onPong(encode(resp));\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "217", "src_id": "M581", "code": "\n  @Override\n  public List<String> hgetdel(String key, String... fields) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "218", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "219", "src_id": "M1104", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "220", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change\n        && existence == that.existence\n        && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "221", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "222", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs)\n        && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "223", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy\n        && replace == that.replace\n        && Objects.equals(username, that.username)\n        && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "224", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "225", "src_id": "M107", "code": "\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public List<Map.Entry<byte[], List<StreamEntryBinary>>> build(Object data) {\n    if (data == null) {\n      return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n      return ((List<KeyValue>) list).stream()\n          .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n              STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n          .collect(Collectors.toList());\n    } else {\n      List<Map.Entry<byte[], List<StreamEntryBinary>>> result = new ArrayList<>(list.size());\n      for (Object anObj : list) {\n        List<Object> streamObj = (List<Object>) anObj;\n        byte[] streamKey = BINARY.build(streamObj.get(0));\n        List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n        result.add(KeyValue.of(streamKey, streamEntries));\n      }\n      return result;\n    }\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "226", "src_id": "M1012", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(\n      byte[] groupName, byte[] consumer, XReadGroupParams xReadGroupParams,\n      Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n        .add(GROUP).add(groupName).add(consumer)\n        .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "227", "src_id": "M1172", "code": "\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (!(obj instanceof ByteArrayWrapper)) {\n      return false;\n    }\n\n    return Arrays.equals(data, ((ByteArrayWrapper) obj).data);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "228", "src_id": "M154", "code": "\n  @Override\n  public Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(XReadParams xReadParams,\n      Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "229", "src_id": "M1010", "code": "\n  public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "230", "src_id": "M1009", "code": "\n  public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary>>>> xreadBinary(\n      XReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID>> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "231", "src_id": "M152", "code": "\n  @Deprecated\n  @Override\n  public List<Object> xreadGroup(byte[] groupName, byte[] consumer,\n      XReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n        commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "232", "src_id": "M777", "code": "\n  @Override\n  public List<Map<String, Object>> clusterLinks() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n    return connection.getObjectMultiBulkReply().stream()\n        .map(BuilderFactory.ENCODED_OBJECT_MAP::build)\n        .collect(Collectors.toList());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "233", "src_id": "M779", "code": "\n  @Override\n  public String clusterDelSlotsRange(int... ranges) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(\n        CLUSTER,\n        joinParameters(\n            ClusterKeyword.DELSLOTSRANGE.getRaw(),\n            joinParameters(ranges)\n        )\n    );\n    return connection.getStatusCodeReply();\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "234", "src_id": "M818", "code": "\n  @Override\n  public Map<String, Object> memoryStats() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(MEMORY, STATS);\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "235", "src_id": "M233", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      XAutoClaimParams that = (XAutoClaimParams) o;\n      return Objects.equals(count, that.count);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "236", "src_id": "M1104", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        return Arrays.equals(raw, ((Raw) o).raw);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "237", "src_id": "M260", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ZAddParams that = (ZAddParams) o;\n      return change == that.change && existence == that.existence && comparison == that.comparison;\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "238", "src_id": "M234", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ClientKillParams that = (ClientKillParams) o;\n      return Objects.equals(params, that.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "239", "src_id": "M256", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ModuleLoadExParams that = (ModuleLoadExParams) o;\n      return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "240", "src_id": "M238", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      MigrateParams that = (MigrateParams) o;\n      return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "241", "src_id": "M229", "code": "\n  @Override\n  public boolean equals(Object o) {\n      if (this == o) {\n          return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n          return false;\n      }\n      ZParams zParams = (ZParams) o;\n      return Objects.equals(params, zParams.params);\n  }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "242", "src_id": "M890", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        TSArithByParams<?> that = (TSArithByParams<?>) o;\n        return ignore == that.ignore\n                && ignoreMaxTimediff == that.ignoreMaxTimediff\n                && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n                && Objects.equals(timestamp, that.timestamp)\n                && Objects.equals(retentionPeriod, that.retentionPeriod)\n                && encoding == that.encoding\n                && Objects.equals(chunkSize, that.chunkSize)\n                && duplicatePolicy == that.duplicatePolicy\n                && Objects.equals(labels, that.labels);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "243", "src_id": "M903", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        TSCreateParams that = (TSCreateParams) o;\n        return ignore == that.ignore\n                && ignoreMaxTimediff == that.ignoreMaxTimediff\n                && Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0\n                && Objects.equals(retentionPeriod, that.retentionPeriod)\n                && encoding == that.encoding\n                && Objects.equals(chunkSize, that.chunkSize)\n                && duplicatePolicy == that.duplicatePolicy\n                && Objects.equals(labels, that.labels);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "244", "src_id": "M907", "code": "\n    @Override\n    public int hashCode() {\n        int result = Boolean.hashCode(latest);\n        result = 31 * result + Boolean.hashCode(withLabels);\n        result = 31 * result + Arrays.hashCode(selectedLabels);\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "1", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n                || entry.getLastLine() == line\n                && entry.getLastColumn() >= column;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "2", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n\n        return classDef.getType() != TokenTypes.ENUM_DEF\n                && modifiers.findFirstToken(TokenTypes.FINAL) == null\n                && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "3", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "4", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "5", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "6", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "7", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n                && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "8", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n\n        return forwardReference;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "19", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n                || (entry.getLastLine() == line\n                        && entry.getLastColumn() >= column);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "20", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n                && modifiers.findFirstToken(TokenTypes.FINAL) == null\n                && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "21", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "22", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "23", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "24", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(\n            DetailAST ast, DetailAST token, int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "25", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n                && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "26", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n        return forwardReference;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "27", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "28", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n            DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "29", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "30", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "31", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "32", "src_id": "M597", "code": "\n    private void checkTypeDefinition(DetailAST ast) {\n\n        if (!ScopeUtil.isOuterMostType(ast)\n            && isSemicolon(ast.getNextSibling())) {\n\n            log(ast.getNextSibling(), MSG_SEMI);\n        }\n\n        final DetailAST firstMember =\n            ast.findFirstToken(TokenTypes.OBJBLOCK)\n                .getFirstChild()\n                .getNextSibling();\n\n        if (isSemicolon(firstMember)\n            && !ScopeUtil.isInEnumBlock(firstMember)) {\n\n            log(firstMember, MSG_SEMI);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "33", "src_id": "M655", "code": "\n    private void checkLambda(DetailAST ast, DetailAST currentStatement) {\n        int countOfSemiInCurrentLambda = countOfSemiInLambda.pop();\n        countOfSemiInCurrentLambda++;\n        countOfSemiInLambda.push(countOfSemiInCurrentLambda);\n\n        if (!inForHeader\n            && countOfSemiInCurrentLambda > 1\n            && isOnTheSameLine(\n                currentStatement,\n                lastStatementEnd,\n                forStatementEnd,\n                lambdaStatementEnd)) {\n\n            log(ast, MSG_KEY);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "34", "src_id": "M587", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n\n        final DetailAST enumBlock = ast.findFirstToken(TokenTypes.OBJBLOCK);\n        final DetailAST semicolon = enumBlock.findFirstToken(TokenTypes.SEMI);\n\n        if (semicolon != null\n            && isEndOfEnumerationAfter(semicolon)) {\n\n            log(semicolon, MSG_SEMI);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "35", "src_id": "M202", "code": "\n    public static InputSource sourceFromFilename(String filename)\n            throws CheckstyleException {\n\n        // figure out if this is a File or a URL\n        final URI uri = getUriByFilename(filename);\n\n        return new InputSource(uri.toASCIIString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "36", "src_id": "M633", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.RECORD_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "37", "src_id": "M285", "code": "\n    private static void addSuppressions(List<String> values, DetailAST targetAST) {\n\n        // get text range of target\n        final int firstLine = targetAST.getLineNo();\n        final int firstColumn = targetAST.getColumnNo();\n        final DetailAST nextAST = targetAST.getNextSibling();\n\n        final int lastLine;\n        final int lastColumn;\n\n        if (nextAST == null) {\n            lastLine = Integer.MAX_VALUE;\n            lastColumn = Integer.MAX_VALUE;\n        }\n        else {\n            lastLine = nextAST.getLineNo();\n            lastColumn = nextAST.getColumnNo();\n        }\n\n        final List<Entry> entries = ENTRIES.get();\n\n        for (String value : values) {\n            // strip off the checkstyle-only prefix if present\n            final String checkName = removeCheckstylePrefixIfExists(value);\n\n            entries.add(new Entry(\n                checkName, firstLine, firstColumn, lastLine, lastColumn));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "38", "src_id": "M276", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n\n        if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n\n            final int length = getLength(ast);\n\n            if (length > max) {\n                log(ast, MSG_KEY, length, max);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "39", "src_id": "M279", "code": "\n    private static int getFirstNodeLineNumber(DetailAST lambdaBody) {\n        DetailAST node = lambdaBody;\n        int result;\n\n        do {\n            result = node.getLineNo();\n            node = node.getFirstChild();\n        }\n        while (node != null);\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "40", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n            DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "41", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n            DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "42", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "43", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "44", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "45", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "46", "src_id": "M79", "code": "\n    private static Stream<?> getValuesStream(Object value) {\n        final Stream<?> result;\n        if (value instanceof Collection) {\n            final Collection<?> collection = (Collection<?>) value;\n            result = collection.stream();\n        }\n        else {\n            final Object[] array = (Object[]) value;\n            result = Arrays.stream(array);\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "47", "src_id": "M103", "code": "\n    @Override\n    public void body() {\n        write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding + \"\\\"?>\");\n        writeEOL();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "48", "src_id": "M72", "code": "\n    private static DetailNode getSinceJavadocTag(DetailNode javadoc) {\n        final DetailNode[] children = javadoc.getChildren();\n        DetailNode result = null;\n        for (final DetailNode child : children) {\n            if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                final DetailNode sinceNode = JavadocUtil.findFirstToken(\n                        child, JavadocTokenTypes.SINCE_LITERAL);\n                if (sinceNode != null) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "49", "src_id": "M46", "code": "\n    private static String getLinkToParentModule(String parentModule, String moduleName)\n            throws MacroExecutionException {\n        final Path templatePath = SiteUtil.getTemplatePath(moduleName);\n        if (templatePath == null) {\n            throw new MacroExecutionException(\n                    String.format(Locale.ROOT, \"Could not find template for %s\", moduleName));\n        }\n        final Path templatePathParent = templatePath.getParent();\n        if (templatePathParent == null) {\n            throw new MacroExecutionException(\"Failed to get parent path for \" + templatePath);\n        }\n        return templatePathParent\n                .relativize(Path.of(\"src\", \"site/xdoc\", \"config.xml\"))\n                .toString()\n                .replace(\".xml\", \".html\")\n                .replace('\\\\', '/')\n                + \"#\" + parentModule;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "50", "src_id": "M78", "code": "\n    private static String getStringArrayPropertyValue(String propertyName, Object value) {\n        String result;\n        if (value == null) {\n            result = \"\";\n        }\n        else {\n            try (Stream<?> valuesStream = getValuesStream(value)) {\n                result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(COMMA_SPACE));\n            }\n        }\n\n        if (result.isEmpty()) {\n            if (FILE_EXTENSIONS.equals(propertyName)) {\n                result = \"all files\";\n            }\n            else {\n                result = CURLY_BRACKETS;\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "51", "src_id": "M114", "code": "\n    private static void createListItem(XdocSink sink, Class<?> clss, String messageKey) {\n        final String messageKeyUrl = constructMessageKeyUrl(clss, messageKey);\n        final String indentLevel10 = SiteUtil.getNewlineAndIndentSpaces(10);\n        final String indentLevel12 = SiteUtil.getNewlineAndIndentSpaces(12);\n        final String indentLevel14 = SiteUtil.getNewlineAndIndentSpaces(14);\n\n        sink.rawText(indentLevel10);\n        // This is a hack to prevent a newline from being inserted by the default sink.\n        // Once we get rid of the custom parser, we can remove this.\n        // until https://github.com/checkstyle/checkstyle/issues/13426\n        sink.setInsertNewline(false);\n        sink.listItem();\n        sink.setInsertNewline(true);\n\n        sink.rawText(indentLevel12);\n        sink.link(messageKeyUrl);\n        sink.rawText(indentLevel14);\n        sink.rawText(messageKey);\n\n        sink.rawText(indentLevel12);\n        sink.link_();\n        sink.rawText(indentLevel10);\n        sink.listItem_();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "52", "src_id": "M58", "code": "\n    private static Set<Field> getCheckMessageKeys(Class<?> module)\n            throws MacroExecutionException {\n        try {\n            final Set<Field> result = new HashSet<>();\n            final Field[] fields = module.getDeclaredFields();\n\n            for (Field field : fields) {\n                if (field.getName().startsWith(\"MSG_\")) {\n                    result.add(field);\n                }\n            }\n\n            final Class<?> superModule = module.getSuperclass();\n            if (superModule != null) {\n                result.addAll(getCheckMessageKeys(superModule));\n            }\n\n            if (module == RegexpMultilineCheck.class) {\n                result.addAll(getCheckMessageKeys(Class\n                        .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.MultilineDetector\")));\n            }\n            else if (module == RegexpSinglelineCheck.class\n                    || module == RegexpSinglelineJavaCheck.class) {\n                result.addAll(getCheckMessageKeys(Class\n                        .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.SinglelineDetector\")));\n            }\n\n            return result;\n        }\n        catch (ClassNotFoundException exc) {\n            final String message = String.format(Locale.ROOT, \"Couldn't find class: %s\",\n                    module.getName());\n            throw new MacroExecutionException(message, exc);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "53", "src_id": "M68", "code": "\n    private static Set<String> getNonExplicitProperties(\n            Object instance, Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                result.add(TOKENS);\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n            result.add(\"violateExecutionOnNonTightHtml\");\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                result.add(JAVADOC_TOKENS);\n            }\n        }\n\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            result.add(FILE_EXTENSIONS);\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "54", "src_id": "M65", "code": "\n    private static void processModule(String moduleName, Path modulePath)\n            throws MacroExecutionException {\n        if (!Files.isRegularFile(modulePath)) {\n            final String message = String.format(Locale.ROOT,\n                    \"File %s is not a file. Please check the 'modulePath' property.\", modulePath);\n            throw new MacroExecutionException(message);\n        }\n        ClassAndPropertiesSettersJavadocScraper.initialize(moduleName);\n        final Checker checker = new Checker();\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n        final DefaultConfiguration scraperCheckConfig =\n                new DefaultConfiguration(\n                        ClassAndPropertiesSettersJavadocScraper.class.getName());\n        final DefaultConfiguration defaultConfiguration =\n                new DefaultConfiguration(\"configuration\");\n        final DefaultConfiguration treeWalkerConfig =\n                new DefaultConfiguration(TreeWalker.class.getName());\n        defaultConfiguration.addProperty(CHARSET, StandardCharsets.UTF_8.name());\n        defaultConfiguration.addChild(treeWalkerConfig);\n        treeWalkerConfig.addChild(scraperCheckConfig);\n        try {\n            checker.configure(defaultConfiguration);\n            final List<File> filesToProcess = List.of(modulePath.toFile());\n            checker.process(filesToProcess);\n            checker.destroy();\n        }\n        catch (CheckstyleException checkstyleException) {\n            final String message = String.format(Locale.ROOT, \"Failed processing %s\", moduleName);\n            throw new MacroExecutionException(message, checkstyleException);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "55", "src_id": "M110", "code": "\n    private static DetailAST getParentAst(DetailAST ast, int type) {\n        DetailAST result = ast.getParent();\n        while (result != null && result.getType() != type) {\n            result = result.getParent();\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "56", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(\n            DetailAST startingBranch, DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "57", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(\n            DetailAST token, DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "58", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar =\n                getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(\n                        expressionBranch, branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "59", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        final boolean result;\n        if (entry.getLastLine() > line) {\n            result = true;\n        }\n        else if (entry.getLastLine() == line && entry.getLastColumn() >= column) {\n            result = true;\n        }\n        else {\n            result = false;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "60", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        final boolean result;\n        if (classDef.getType() != TokenTypes.ENUM_DEF\n                && modifiers.findFirstToken(TokenTypes.FINAL) == null\n                && hasDefaultOrExplicitNonPrivateCtor(classDef)) {\n            result = true;\n        }\n        else {\n            result = false;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "61", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "62", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "63", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "64", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "65", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n                && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "66", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n        return forwardReference;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "67", "src_id": "M37", "code": "\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        ModuleType result;\n\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "68", "src_id": "M28", "code": "\n    private void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "69", "src_id": "M27", "code": "\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName.substring(0,\n                        moduleName.length() - checkModuleExtension.length());\n            }\n\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "70", "src_id": "M35", "code": "\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                   Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n                .filter(child -> pattern.matcher(child.getText()).matches())\n                .findFirst();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "71", "src_id": "M284", "code": "\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n            || (entry.getLastLine() == line\n                && entry.getLastColumn() >= column);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "72", "src_id": "M294", "code": "\n    private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n\n        return classDef.getType() != TokenTypes.ENUM_DEF\n            && modifiers.findFirstToken(TokenTypes.FINAL) == null\n            && hasDefaultOrExplicitNonPrivateCtor(classDef);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "73", "src_id": "M714", "code": "\n    private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (vertex.getType() == tokenType) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "74", "src_id": "M504", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.SINGLE_LINE_COMMENT,\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "75", "src_id": "M207", "code": "\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n\n        return extension;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "76", "src_id": "M716", "code": "\n    private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast,\n                                                                     DetailAST token,\n                                                                     int endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n            if (!stack.isEmpty()) {\n                vertex = stack.pop();\n            }\n            while (vertex != null) {\n                if (isAstSimilar(token, vertex)\n                    && vertex.getLineNo() <= endLineNumber) {\n                    result.add(vertex);\n                }\n                if (vertex.getNextSibling() != null) {\n                    stack.push(vertex.getNextSibling());\n                }\n                vertex = vertex.getFirstChild();\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "77", "src_id": "M293", "code": "\n    private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n            && searchAST.getType() != TokenTypes.ENUM_DEF) {\n            searchAST = searchAST.getParent();\n        }\n\n        return searchAST;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "78", "src_id": "M704", "code": "\n    private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n\n        for (DetailAST ident : exprIdents) {\n            if (classFieldNames.contains(ident.getText())) {\n                forwardReference = true;\n                break;\n            }\n        }\n\n        return forwardReference;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "79", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "80", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "81", "src_id": "M646", "code": "\n    private static List<DetailAST> getChildList(DetailAST ast) {\n        final List<DetailAST> children = new ArrayList<>();\n        DetailAST child = ast.findFirstToken(TokenTypes.OBJBLOCK).getFirstChild();\n        while (child != null) {\n            children.add(child);\n            child = child.getNextSibling();\n        }\n        return children;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "82", "src_id": "M373", "code": "\n    private void checkParagraphTag(DetailNode tag) {\n        if (!isNestedParagraph(tag)) {\n            final DetailNode newLine = getNearestEmptyLine(tag);\n\n            if (isFirstParagraph(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_REDUNDANT_PARAGRAPH);\n            }\n            else if (newLine == null || tag.getLineNumber() - newLine.getLineNumber() != 1) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_LINE_BEFORE);\n            }\n\n            final String blockTagName = findFollowedBlockTagName(tag);\n            if (blockTagName != null) {\n                log(tag.getLineNumber(), tag.getColumnNumber(),\n                        MSG_PRECEDED_BLOCK_TAG, blockTagName);\n            }\n\n            if (!allowNewlineParagraph && isImmediatelyFollowedByNewLine(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n            }\n            if (isImmediatelyFollowedByText(tag)) {\n                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "83", "src_id": "M406", "code": "\n    @Override\n    public void finishJavadocTree(DetailNode rootAst) {\n        // this method checks the alignment of closing javadoc tag.\n        final DetailAST javadocEndToken = getBlockCommentAst().getLastChild();\n        final String lastLine = fileLines[javadocEndToken.getLineNo() - 1];\n        final Optional<Integer> endingBlockColumnNumber = getAsteriskColumnNumber(lastLine);\n\n        endingBlockColumnNumber\n                .map(columnNumber -> expandedTabs(lastLine, columnNumber))\n                .filter(columnNumber -> !hasValidAlignment(expectedColumnNumberTabsExpanded, columnNumber))\n                .ifPresent(columnNumber -> logViolation(javadocEndToken.getLineNo(),\n                        columnNumber,\n                        expectedColumnNumberTabsExpanded));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "84", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "85", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "86", "src_id": "M37", "code": "\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        final ModuleType result;\n\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "87", "src_id": "M28", "code": "\n    private void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "88", "src_id": "M27", "code": "\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName.substring(\n                    0, moduleName.length() - checkModuleExtension.length());\n            }\n\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "89", "src_id": "M35", "code": "\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                   Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "90", "src_id": "M37", "code": "\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "91", "src_id": "M28", "code": "\n    private void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "92", "src_id": "M27", "code": "\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.endsWith(checkModuleExtension)) {\n                moduleName = moduleName.substring(0,\n                        moduleName.length() - checkModuleExtension.length());\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "93", "src_id": "M35", "code": "\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n            Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n            .filter(child -> pattern.matcher(child.getText()).matches())\n            .findFirst();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "94", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "95", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n            .map(HeaderFileMetadata::getHeaderFilePath)\n            .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "96", "src_id": "M601", "code": "\n    @Override\n    public void beginTree(DetailAST root) {\n        variables.clear();\n        typeDeclarations.clear();\n        typeDeclAstToTypeDeclDesc.clear();\n        anonInnerAstToTypeDeclDesc.clear();\n        anonInnerClassHolders.clear();\n        packageName = null;\n        depth = 0;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "97", "src_id": "M600", "code": "\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.DOT,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.IDENT,\n            TokenTypes.SLIST,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.OBJBLOCK,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.STATIC_INIT,\n            TokenTypes.INSTANCE_INIT,\n            TokenTypes.COMPILATION_UNIT,\n            TokenTypes.LAMBDA,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "98", "src_id": "M615", "code": "\n    private void iterateOverBlockContainingLocalAnonInnerClass(DetailAST ast,\n                                                               Deque<VariableDesc> variablesStack) {\n        DetailAST currNode = ast;\n        while (currNode != null) {\n            customVisitToken(currNode, variablesStack);\n            DetailAST toVisit = currNode.getFirstChild();\n            while (currNode != ast && toVisit == null) {\n                customLeaveToken(currNode, variablesStack);\n                toVisit = currNode.getNextSibling();\n                currNode = currNode.getParent();\n            }\n            currNode = toVisit;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "99", "src_id": "M383", "code": "\n    private static void extractInlineTagContent(DetailNode node,\n                                               StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "100", "src_id": "M593", "code": "\n    private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            parameterNames.add(ast.getText());\n        }\n        else {\n            visitParameters(ast);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "101", "src_id": "M175", "code": "\n    @Override\n    public void auditFinished(AuditEvent event) {\n        errorWriter.flush();\n        if (closeErrorWriter) {\n            errorWriter.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "102", "src_id": "M603", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isOfType(ast, SCOPES)) {\n            logViolations(ast, variables);\n        }\n        else if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n            leaveCompilationUnit();\n        }\n        else if (isNonLocalTypeDeclaration(ast)) {\n            depth--;\n            typeDeclarations.pop();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "103", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "104", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "105", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "106", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "107", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "108", "src_id": "M697", "code": "\n    @Nullable\n    private static DetailAST traverseUntilNeededBranchType(\n            DetailAST startingBranch, DetailAST bound, int neededTokenType) {\n        DetailAST match = null;\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n        while (iteratedBranch != null) {\n            if (iteratedBranch.getType() == neededTokenType) {\n                match = iteratedBranch;\n                break;\n            }\n            iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n        return match;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "109", "src_id": "M564", "code": "\n    private static boolean isTokenNotOnPreviousSiblingLines(\n            DetailAST token, DetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; astNode != null;\n                astNode = astNode.getLastChild()) {\n            previousSibling = astNode;\n        }\n        return token.getLineNo() != previousSibling.getLineNo();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "110", "src_id": "M695", "code": "\n    private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n                expressionBranch != null;\n                expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                        branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n            final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n            if (assignToken != null) {\n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n            }\n        }\n        return reassignedVariableIdents;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "121", "src_id": "M601", "code": "\n    @Override\n    public void beginTree(DetailAST root) {\n        variables.clear();\n        typeDeclarations.clear();\n        typeDeclAstToTypeDeclDesc.clear();\n        anonInnerAstToTypeDeclDesc.clear();\n        anonInnerClassHolders.clear();\n        packageName = null;\n        depth = 0;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "122", "src_id": "M600", "code": "\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.DOT,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.IDENT,\n            TokenTypes.SLIST,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.OBJBLOCK,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.STATIC_INIT,\n            TokenTypes.INSTANCE_INIT,\n            TokenTypes.COMPILATION_UNIT,\n            TokenTypes.LAMBDA,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "123", "src_id": "M615", "code": "\n    private void iterateOverBlockContainingLocalAnonInnerClass(\n            DetailAST ast, Deque<VariableDesc> variablesStack) {\n\n        DetailAST currNode = ast;\n\n        while (currNode != null) {\n            customVisitToken(currNode, variablesStack);\n\n            DetailAST toVisit = currNode.getFirstChild();\n\n            while (currNode != ast && toVisit == null) {\n                customLeaveToken(currNode, variablesStack);\n                toVisit = currNode.getNextSibling();\n                currNode = currNode.getParent();\n            }\n\n            currNode = toVisit;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "124", "src_id": "M383", "code": "\n    private static void extractInlineTagContent(DetailNode node,\n                                               StringBuilder customTagContent) {\n\n        final DetailNode[] children = node.getChildren();\n\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "125", "src_id": "M593", "code": "\n    private void visitLambdaParameters(DetailAST ast) {\n\n        if (ast.getType() == TokenTypes.IDENT) {\n            parameterNames.add(ast.getText());\n        }\n        else {\n            visitParameters(ast);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "126", "src_id": "M175", "code": "\n    @Override\n    public void auditFinished(AuditEvent event) {\n        errorWriter.flush();\n\n        if (closeErrorWriter) {\n            errorWriter.close();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "127", "src_id": "M603", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n\n        if (TokenUtil.isOfType(ast, SCOPES)) {\n            logViolations(ast, variables);\n        }\n        else if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n            leaveCompilationUnit();\n        }\n        else if (isNonLocalTypeDeclaration(ast)) {\n            depth--;\n            typeDeclarations.pop();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "128", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "129", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "130", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "131", "src_id": "M697", "code": "\n@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(\n        DetailAST startingBranch, DetailAST bound, int neededTokenType) {\n    DetailAST match = null;\n    DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n    while (iteratedBranch != null) {\n        if (iteratedBranch.getType() == neededTokenType) {\n            match = iteratedBranch;\n            break;\n        }\n        iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n    }\n    return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "132", "src_id": "M564", "code": "\nprivate static boolean isTokenNotOnPreviousSiblingLines(\n        DetailAST token, DetailAST parentToken) {\n    DetailAST previousSibling = parentToken.getPreviousSibling();\n    for (DetailAST astNode = previousSibling; astNode != null;\n            astNode = astNode.getLastChild()) {\n        previousSibling = astNode;\n    }\n    return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "133", "src_id": "M695", "code": "\nprivate static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n    final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n    final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n    for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n            expressionBranch != null;\n            expressionBranch = traverseUntilNeededBranchType(\n                    expressionBranch, branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n        final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n        if (assignToken != null) {\n            reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n        }\n    }\n    return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "134", "src_id": "M502", "code": "\n    private int expandedTabsColumnNo(DetailAST ast) {\n        final String line = indentCheck.getLine(ast.getLineNo() - 1);\n\n        return CommonUtil.lengthExpandedTabs(\n            line, ast.getColumnNo(), indentCheck.getIndentationTabWidth());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "135", "src_id": "M455", "code": "\n    @Override\n    public void init() {\n        if (fileNamePattern == null && folderPattern == null) {\n            fileNamePattern = CommonUtil.createPattern(\"\\\\s\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "136", "src_id": "M456", "code": "\n    @Override\n    protected void processFiltered(File file, FileText fileText)\n            throws CheckstyleException {\n        final String fileName = getFileName(file);\n        final String folderPath = getFolderPath(file);\n\n        if (isMatchFolder(folderPath) && isMatchFile(fileName)) {\n            log();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "137", "src_id": "M165", "code": "\n    private AxisIterator getPrecedingSiblingsIterator() {\n        final AxisIterator result;\n        if (indexAmongSiblings == 0) {\n            result = EmptyIterator.ofNodes();\n        }\n        else {\n            result = new ReverseListIterator(getPrecedingSiblings());\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "138", "src_id": "M750", "code": "\n    private static String convertUpperCamelToUpperUnderscore(String text) {\n        final StringBuilder result = new StringBuilder(20);\n        boolean first = true;\n        for (char letter : text.toCharArray()) {\n            if (!first && Character.isUpperCase(letter)) {\n                result.append('_');\n            }\n            result.append(Character.toUpperCase(letter));\n            first = false;\n        }\n        return result.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "139", "src_id": "M346", "code": "\n    @Override\n    protected boolean matchesExactly(String pkg, String fileName) {\n        final boolean result;\n        if (fileName == null) {\n            result = false;\n        }\n        else if (regex) {\n            result = patternForExactMatch.matcher(fileName).matches();\n        }\n        else {\n            result = name.equals(fileName);\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "140", "src_id": "M706", "code": "\n    @Override\n    public void beginTree(DetailAST rootAST) {\n\n        frames = new HashMap<>();\n        current.clear();\n\n        final Deque<AbstractFrame> frameStack = new LinkedList<>();\n        DetailAST curNode = rootAST;\n\n        while (curNode != null) {\n            collectDeclarations(frameStack, curNode);\n\n            DetailAST toVisit = curNode.getFirstChild();\n\n            while (curNode != null && toVisit == null) {\n                endCollectingDeclarations(frameStack, curNode);\n                toVisit = curNode.getNextSibling();\n                curNode = curNode.getParent();\n            }\n\n            curNode = toVisit;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "141", "src_id": "M308", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n            case TokenTypes.INSTANCE_INIT:\n            case TokenTypes.STATIC_INIT:\n            case TokenTypes.COMPACT_CTOR_DEF:\n                leaveMethodDef(ast);\n                break;\n            default:\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "142", "src_id": "M167", "code": "\n    private AttributeNode getAttributeNode() {\n        if (attributeNode == ATTRIBUTE_NODE_UNINITIALIZED) {\n            attributeNode = createAttributeNode();\n        }\n        return attributeNode;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "143", "src_id": "M398", "code": "\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "144", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "145", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "146", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "147", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n        final String[] attributes = config.getPropertyNames();\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n        finishLocalSetup();\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "148", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "149", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "150", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "151", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "152", "src_id": "M310", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "153", "src_id": "M200", "code": "\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n\n                if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "154", "src_id": "M201", "code": "\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n\n        return len;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "155", "src_id": "M255", "code": "\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result = false;\n\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n\n        for (DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "156", "src_id": "M689", "code": "\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "157", "src_id": "M347", "code": "\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "158", "src_id": "M394", "code": "\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.TEXT,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "159", "src_id": "M571", "code": "\n    private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n            result = node.getPreviousSibling();\n        }\n        else if (isInPatternDefinition(node)) {\n            result = node.getFirstChild();\n        }\n        else {\n            result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n        }\n        while (result.getLastChild() != null) {\n            result = result.getLastChild();\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "160", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "161", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "162", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "163", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n        final String[] attributes = config.getPropertyNames();\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n        finishLocalSetup();\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "164", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "165", "src_id": "M697", "code": "\n@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n                                                      DetailAST bound,\n                                                      int neededTokenType) {\n    DetailAST match = null;\n    DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n    while (iteratedBranch != null) {\n        if (iteratedBranch.getType() == neededTokenType) {\n            match = iteratedBranch;\n            break;\n        }\n        iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n    }\n    return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "166", "src_id": "M564", "code": "\nprivate static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n                                                        DetailAST parentToken) {\n    DetailAST previousSibling = parentToken.getPreviousSibling();\n    for (DetailAST astNode = previousSibling; astNode != null;\n         astNode = astNode.getLastChild()) {\n        previousSibling = astNode;\n    }\n    return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "167", "src_id": "M695", "code": "\nprivate static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n    final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n    final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n    for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n         expressionBranch != null;\n         expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n             branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n        final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n        if (assignToken != null) {\n            reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n        }\n    }\n    return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "168", "src_id": "M624", "code": "\n    private static boolean hasLiteralNull(DetailAST caseAST) {\n        return Optional.ofNullable(caseAST.findFirstToken(TokenTypes.EXPR))\n                .map(exp -> exp.findFirstToken(TokenTypes.LITERAL_NULL))\n                .isPresent();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "169", "src_id": "M253", "code": "\n    private void checkUnnamedVariables(DetailAST ast) {\n        if (jdkVersion >= JDK_22 && isUnnamedVariable(ast)) {\n            checkForRedundantModifier(ast, TokenTypes.FINAL);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "170", "src_id": "M638", "code": "\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.LITERAL_CATCH) {\n            final Optional<CatchParameterDetails> unusedCatchParameter =\n                    Optional.ofNullable(catchParameters.peek())\n                            .filter(parameter -> !parameter.isUsed())\n                            .filter(parameter -> !\"_\".equals(parameter.getName()));\n\n            unusedCatchParameter.ifPresent(parameter -> {\n                log(parameter.getParameterDefinition(),\n                        MSG_UNUSED_CATCH_PARAMETER,\n                        parameter.getName());\n            });\n            catchParameters.pop();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "171", "src_id": "M626", "code": "\n    private static boolean hasStringCaseLabel(DetailAST caseAST) {\n        DetailAST curNode = caseAST;\n        boolean hasStringCaseLabel = false;\n        boolean exitCaseLabelExpression = false;\n\n        while (!exitCaseLabelExpression) {\n            DetailAST toVisit = curNode.getFirstChild();\n            if (curNode.getType() == TokenTypes.STRING_LITERAL) {\n                hasStringCaseLabel = true;\n                break;\n            }\n            while (toVisit == null) {\n                toVisit = curNode.getNextSibling();\n                curNode = curNode.getParent();\n            }\n            curNode = toVisit;\n            exitCaseLabelExpression = TokenUtil.isOfType(curNode, TokenTypes.COLON, TokenTypes.LAMBDA);\n        }\n        return hasStringCaseLabel;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "172", "src_id": "M673", "code": "\n    private static boolean isLambdaParameterIdentifierCandidate(DetailAST identifierAst) {\n        // we should ignore the ident if it is in the lambda parameters declaration\n        final boolean isLambdaParameterDeclaration =\n                identifierAst.getParent().getType() == TokenTypes.LAMBDA\n                    || identifierAst.getParent().getType() == TokenTypes.PARAMETER_DEF;\n\n        return !isLambdaParameterDeclaration\n                && (hasValidParentToken(identifierAst) || isMethodInvocation(identifierAst));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "173", "src_id": "M251", "code": "\n    public void setJdkVersion(String jdkVersion) {\n        final String singleVersionNumber;\n        if (jdkVersion.startsWith(\"1.\")) {\n            singleVersionNumber = jdkVersion.substring(2);\n        }\n        else {\n            singleVersionNumber = jdkVersion;\n        }\n\n        this.jdkVersion = Integer.parseInt(singleVersionNumber);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "174", "src_id": "M675", "code": "\n    private static boolean isLeftHandOfAssignment(DetailAST identAst) {\n        final DetailAST parent = identAst.getParent();\n        return parent.getType() == TokenTypes.ASSIGN\n                && !identAst.equals(parent.getLastChild());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "175", "src_id": "M485", "code": "\n    private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n            result = BLANK_LINE;\n        }\n        else {\n            result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "176", "src_id": "M478", "code": "\n    public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n                .map(HeaderFileMetadata::getHeaderFilePath)\n                .collect(Collectors.joining(\", \"));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "177", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "178", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "179", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "180", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "181", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "182", "src_id": "M697", "code": "\n@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,\n        DetailAST bound, int neededTokenType) {\n    DetailAST match = null;\n    DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n    while (iteratedBranch != null) {\n        if (iteratedBranch.getType() == neededTokenType) {\n            match = iteratedBranch;\n            break;\n        }\n        iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n    }\n    return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "183", "src_id": "M564", "code": "\nprivate static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\n        DetailAST parentToken) {\n    DetailAST previousSibling = parentToken.getPreviousSibling();\n    for (DetailAST astNode = previousSibling; astNode != null;\n            astNode = astNode.getLastChild()) {\n        previousSibling = astNode;\n    }\n    return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "184", "src_id": "M695", "code": "\nprivate static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n    final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n    final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n    for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n            expressionBranch != null;\n            expressionBranch = traverseUntilNeededBranchType(expressionBranch,\n                    branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n        final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n        if (assignToken != null) {\n            reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n        }\n    }\n    return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "185", "src_id": "M310", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "186", "src_id": "M200", "code": "\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n                }\n            }\n            final String fileName = file.getName();\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "187", "src_id": "M201", "code": "\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "188", "src_id": "M255", "code": "\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result = false;\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n        for (DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "189", "src_id": "M689", "code": "\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "190", "src_id": "M310", "code": "\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "191", "src_id": "M200", "code": "\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        final boolean result;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n            boolean found = false;\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    found = true;\n                    break;\n                }\n            }\n            result = found;\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "192", "src_id": "M201", "code": "\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "193", "src_id": "M255", "code": "\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n        boolean result = false;\n        for (final DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "194", "src_id": "M689", "code": "\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.ASSIGN,      // '='\n            TokenTypes.DIV_ASSIGN,  // \"/=\"\n            TokenTypes.PLUS_ASSIGN, // \"+=\"\n            TokenTypes.MINUS_ASSIGN, // \"-=\"\n            TokenTypes.STAR_ASSIGN, // \"*=\"\n            TokenTypes.MOD_ASSIGN,  // \"%=\"\n            TokenTypes.SR_ASSIGN,   // \">>=\"\n            TokenTypes.BSR_ASSIGN,  // \">>>=\"\n            TokenTypes.SL_ASSIGN,   // \"<<=\"\n            TokenTypes.BXOR_ASSIGN, // \"^=\"\n            TokenTypes.BOR_ASSIGN,  // \"|=\"\n            TokenTypes.BAND_ASSIGN, // \"&=\"\n        };\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "195", "src_id": "M8", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "196", "src_id": "M10", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "197", "src_id": "M1", "code": "\n    private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "198", "src_id": "M4", "code": "\n    @Override\n    public final void configure(Configuration config) throws CheckstyleException {\n        configuration = config;\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n            final String value = config.getProperty(key);\n            tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n            setupChild(childConfig);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "199", "src_id": "M196", "code": "\n    private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n            final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n            annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n            annotationString = identNode.getText();\n        }\n        return annotationString;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "9", "src_id": "M855", "code": "\n    @Override\n    public DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n\n        final DetailAstImpl bop = create(ctx.bop);\n        bop.addChild(visit(ctx.expr()));\n        bop.addChild(create(ctx.LITERAL_THIS()));\n\n        return bop;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "10", "src_id": "M770", "code": "\n    @Override\n    public DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n\n        final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n        interfaceExtends.addChild(visit(ctx.typeList()));\n\n        return interfaceExtends;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "11", "src_id": "M854", "code": "\n    @Override\n    public DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n\n        final DetailAstImpl lambda = create(ctx.LAMBDA());\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n        final JavaLanguageParser.BlockContext blockContext = ctx.block();\n        final DetailAstImpl rightHandLambdaChild;\n\n        if (blockContext != null) {\n            rightHandLambdaChild = visit(blockContext);\n        }\n        else {\n            // Lambda expression child is built the same way that we build\n            // the initial expression node in visitExpression, i.e. with\n            // an imaginary EXPR node. This results in nested EXPR nodes\n            // in the AST.\n            rightHandLambdaChild = buildExpressionNode(ctx.expr());\n        }\n\n        lambda.addChild(rightHandLambdaChild);\n\n        return lambda;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "12", "src_id": "M779", "code": "\n    @Override\n    public DetailAstImpl visitInterfaceMethodDeclaration(\n            JavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n\n        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n        methodDef.addChild(createModifiers(ctx.mods));\n\n        // Process all children except C style array declarators and modifiers\n        final List<ParseTree> children = ctx.children\n            .stream()\n            .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n            .collect(Collectors.toUnmodifiableList());\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n        final DetailAstImpl typeAst =\n            (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n        ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n        return methodDef;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "13", "src_id": "M839", "code": "\n    @Override\n    public DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n        final DetailAstImpl dummyRoot = new DetailAstImpl();\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n        if (ctx.forInit() == null) {\n            final DetailAstImpl imaginaryForInitParent =\n                createImaginary(TokenTypes.FOR_INIT);\n            dummyRoot.addChild(imaginaryForInitParent);\n        }\n        else {\n            dummyRoot.addChild(visit(ctx.forInit()));\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n        final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n        forCondParent.addChild(visit(ctx.forCond));\n        dummyRoot.addChild(forCondParent);\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n        final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n        forItParent.addChild(visit(ctx.forUpdate));\n        dummyRoot.addChild(forItParent);\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n        return dummyRoot.getFirstChild();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "14", "src_id": "M228", "code": "\n    private static Map.Entry<Integer, Integer> countLinesColumns(\n            String text, int initialLinesCnt, int initialColumnsCnt) {\n\n        int lines = initialLinesCnt;\n        int columns = initialColumnsCnt;\n        boolean foundCr = false;\n\n        for (char c : text.toCharArray()) {\n            if (c == '\\n') {\n                foundCr = false;\n                lines++;\n                columns = 0;\n            }\n            else {\n                if (foundCr) {\n                    foundCr = false;\n                    lines++;\n                    columns = 0;\n                }\n                if (c == '\\r') {\n                    foundCr = true;\n                }\n                columns++;\n            }\n        }\n\n        if (foundCr) {\n            lines++;\n            columns = 0;\n        }\n\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "15", "src_id": "M212", "code": "\n    public static Properties getResolvedProperties(Properties properties)\n            throws CheckstyleException {\n\n        final Set<String> unresolvedPropertyNames = new HashSet<>(properties.stringPropertyNames());\n        Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n        final Map<Object, Object> comparisonProperties = new Properties();\n\n        while (unresolvedPropertyIterator.hasNext()) {\n            final String propertyName = unresolvedPropertyIterator.next();\n            String propertyValue = properties.getProperty(propertyName);\n            final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n            while (matcher.find()) {\n                final String propertyVariableExpression = matcher.group();\n                final String unresolvedPropertyName =\n                    getPropertyNameFromExpression(propertyVariableExpression);\n\n                final String resolvedPropertyValue =\n                    properties.getProperty(unresolvedPropertyName);\n\n                if (resolvedPropertyValue != null) {\n                    propertyValue = propertyValue.replace(\n                        propertyVariableExpression, resolvedPropertyValue);\n                    properties.setProperty(propertyName, propertyValue);\n                }\n            }\n\n            if (allChainedPropertiesAreResolved(propertyValue)) {\n                unresolvedPropertyIterator.remove();\n            }\n\n            if (!unresolvedPropertyIterator.hasNext()) {\n\n                if (comparisonProperties.equals(properties)) {\n                    // At this point, we will have not resolved any properties in two iterations,\n                    // so unresolvable properties exist.\n                    throw new CheckstyleException(\n                        UNDEFINED_PROPERTY_MESSAGE + unresolvedPropertyNames);\n                }\n                comparisonProperties.putAll(properties);\n                unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n            }\n\n        }\n\n        return properties;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "16", "src_id": "M794", "code": "\n    @Override\n    public DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n        final DetailAstImpl annotations;\n\n        if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n            // There are no annotations, and we don't want to create the empty node\n            annotations = null;\n        }\n        else {\n            // There are annotations, or we just want the empty node\n            annotations = createImaginary(TokenTypes.ANNOTATIONS);\n            processChildren(annotations, ctx.anno);\n        }\n\n        return annotations;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "17", "src_id": "M764", "code": "\n    @Override\n    public DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n        final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n        processChildren(typeParameter, ctx.children);\n        return typeParameter;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "18", "src_id": "M492", "code": "\n    private void checkYield() {\n\n        final DetailAST yieldKey = getMainAst();\n        final int columnNo = expandedTabsColumnNo(yieldKey);\n\n        if (isOnStartOfLine(yieldKey)\n            && !getIndent().isAcceptable(columnNo)) {\n\n            logError(yieldKey, \"\", columnNo);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "111", "src_id": "M855", "code": "\n    @Override\n    public DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n        final DetailAstImpl bop = create(ctx.bop);\n        bop.addChild(visit(ctx.expr()));\n        bop.addChild(create(ctx.LITERAL_THIS()));\n        return bop;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "112", "src_id": "M770", "code": "\n    @Override\n    public DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n        final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n        interfaceExtends.addChild(visit(ctx.typeList()));\n        return interfaceExtends;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "113", "src_id": "M854", "code": "\n    @Override\n    public DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n        final DetailAstImpl lambda = create(ctx.LAMBDA());\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n        final JavaLanguageParser.BlockContext blockContext = ctx.block();\n        final DetailAstImpl rightHandLambdaChild;\n        if (blockContext != null) {\n            rightHandLambdaChild = visit(blockContext);\n        }\n        else {\n            // Lambda expression child is built the same way that we build\n            // the initial expression node in visitExpression, i.e. with\n            // an imaginary EXPR node. This results in nested EXPR nodes\n            // in the AST.\n            rightHandLambdaChild = buildExpressionNode(ctx.expr());\n        }\n        lambda.addChild(rightHandLambdaChild);\n        return lambda;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "114", "src_id": "M779", "code": "\n    @Override\n    public DetailAstImpl visitInterfaceMethodDeclaration(\n            JavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n        methodDef.addChild(createModifiers(ctx.mods));\n\n        // Process all children except C style array declarators and modifiers\n        final List<ParseTree> children = ctx.children\n            .stream()\n            .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n            .collect(Collectors.toUnmodifiableList());\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n        final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n        ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n        return methodDef;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "115", "src_id": "M839", "code": "\n    @Override\n    public DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n        final DetailAstImpl dummyRoot = new DetailAstImpl();\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n        if (ctx.forInit() == null) {\n            final DetailAstImpl imaginaryForInitParent = createImaginary(TokenTypes.FOR_INIT);\n            dummyRoot.addChild(imaginaryForInitParent);\n        }\n        else {\n            dummyRoot.addChild(visit(ctx.forInit()));\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n        final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n        forCondParent.addChild(visit(ctx.forCond));\n        dummyRoot.addChild(forCondParent);\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n        final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n        forItParent.addChild(visit(ctx.forUpdate));\n        dummyRoot.addChild(forItParent);\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n        return dummyRoot.getFirstChild();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "116", "src_id": "M228", "code": "\n    private static Map.Entry<Integer, Integer> countLinesColumns(\n            String text, int initialLinesCnt, int initialColumnsCnt) {\n        int lines = initialLinesCnt;\n        int columns = initialColumnsCnt;\n        boolean foundCr = false;\n        for (char c : text.toCharArray()) {\n            if (c == '\\n') {\n                foundCr = false;\n                lines++;\n                columns = 0;\n            }\n            else {\n                if (foundCr) {\n                    foundCr = false;\n                    lines++;\n                    columns = 0;\n                }\n                if (c == '\\r') {\n                    foundCr = true;\n                }\n                columns++;\n            }\n        }\n        if (foundCr) {\n            lines++;\n            columns = 0;\n        }\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "117", "src_id": "M212", "code": "\n    public static Properties getResolvedProperties(Properties properties)\n            throws CheckstyleException {\n        final Set<String> unresolvedPropertyNames = new HashSet<>(properties.stringPropertyNames());\n        Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n        final Map<Object, Object> comparisonProperties = new Properties();\n\n        while (unresolvedPropertyIterator.hasNext()) {\n            final String propertyName = unresolvedPropertyIterator.next();\n            String propertyValue = properties.getProperty(propertyName);\n            final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n            while (matcher.find()) {\n                final String propertyVariableExpression = matcher.group();\n                final String unresolvedPropertyName =\n                    getPropertyNameFromExpression(propertyVariableExpression);\n\n                final String resolvedPropertyValue =\n                    properties.getProperty(unresolvedPropertyName);\n\n                if (resolvedPropertyValue != null) {\n                    propertyValue = propertyValue.replace(propertyVariableExpression,\n                        resolvedPropertyValue);\n                    properties.setProperty(propertyName, propertyValue);\n                }\n            }\n\n            if (allChainedPropertiesAreResolved(propertyValue)) {\n                unresolvedPropertyIterator.remove();\n            }\n\n            if (!unresolvedPropertyIterator.hasNext()) {\n                if (comparisonProperties.equals(properties)) {\n                    // At this point, we will have not resolved any properties in two iterations,\n                    // so unresolvable properties exist.\n                    throw new CheckstyleException(\n                        UNDEFINED_PROPERTY_MESSAGE + unresolvedPropertyNames);\n                }\n                comparisonProperties.putAll(properties);\n                unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n            }\n        }\n        return properties;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "118", "src_id": "M794", "code": "\n    @Override\n    public DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n        final DetailAstImpl annotations;\n        if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n            // There are no annotations, and we don't want to create the empty node\n            annotations = null;\n        }\n        else {\n            // There are annotations, or we just want the empty node\n            annotations = createImaginary(TokenTypes.ANNOTATIONS);\n            processChildren(annotations, ctx.anno);\n        }\n        return annotations;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "119", "src_id": "M764", "code": "\n    @Override\n    public DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n        final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n        processChildren(typeParameter, ctx.children);\n        return typeParameter;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "120", "src_id": "M492", "code": "\n    private void checkYield() {\n        final DetailAST yieldKey = getMainAst();\n        final int columnNo = expandedTabsColumnNo(yieldKey);\n        if (isOnStartOfLine(yieldKey)\n                && !getIndent().isAcceptable(columnNo)) {\n            logError(yieldKey, \"\", columnNo);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}

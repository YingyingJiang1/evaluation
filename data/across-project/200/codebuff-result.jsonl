{"project_name": "across-project", "pair_id": "1", "src_id": "M270", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "2", "src_id": "M928", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "3", "src_id": "M9", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "4", "src_id": "M140", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "5", "src_id": "M1324", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "6", "src_id": "M122", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "7", "src_id": "M8", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "8", "src_id": "M790", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "9", "src_id": "M716", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "10", "src_id": "M602", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "11", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    Thread thread = Thread.currentThread();\n    notifyPostProcessing(1);\n    if (DEBUG) {\n        thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n\n    Exception exception = null;\n    try\n    {\n        psAlgorithm.run(this);\n    } catch (Exception err)\n    {\n        Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n        if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n            notifyError( DownloadMission.ERROR_POSTPROCESSING_STOPPED, null );\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) errCode = ERROR_POSTPROCESSING;\n        exception = err;\n    }\n\nfinally\n{\nnotifyPostProcessing(errCode == ERROR_NOTHING ?\n   2: 0);\n}\n\n    if (errCode != ERROR_NOTHING) {\n        if (exception == null) exception = errObject;\n        notifyError( ERROR_POSTPROCESSING, exception );\n        return;\n    }\n    notifyFinished();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "12", "src_id": "M1031", "code": "\n    void establishConnection(int threadId,\n                             HttpURLConnection conn) throws IOException, HttpError {\n    int statusCode = conn.getResponseCode();\n\n    if (DEBUG) {\n        Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n        Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n        Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n        Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n    }\n\n    switch(statusCode) {\n        case 204: case 205: case 207:\n        throw new HttpError(statusCode);\n                       case 416:\n        return;// let the download thread handle this error\n                       default:\n                       if (statusCode < 200|| statusCode > 299) {\n                           throw new HttpError(statusCode);\n                       }\n\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "13", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n\n    if (b == null) {\n        return null;\n    }\n\n    final Elst obj = new Elst();\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n\n\n    final int entryCount = stream.readInt();\n\n    if (entryCount < 1) {\n        obj.bMediaRate = 0x00010000; // default media rate (1.0)\n        return obj;\n    }\n\n    if (v1) {\n                stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n                obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n                stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n            } else {\n                       stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n                       obj.mediaTime = stream.readInt();\n                   }\n    obj.bMediaRate = stream.readInt();\n    return obj;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "14", "src_id": "M1048", "code": "\n    @ Override public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n\n        if (DEBUG&& !mMission.unknownLength&&\n                start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n        try\n        {\n            long rangeStart = (mMission.unknownLength || start < 1) ?\n                - 1 : start;\n            int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, - 1);\n            if (mRetryCount == 0&&\n                    rangeStart == - 1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n            mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416&&\n                    start > 0) {\n                mMission.notifyProgress(- start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n\n            if (!mMission.unknownLength) mMission.unknownLength = Utility.getContentLength(mConn) == - 1;\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[ 0];\n            }\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n            mIs = mConn.getInputStream();\n\n\n            byte [] buf = new byte [DownloadMission.BUFFER_SIZE];\n            int len = 0;\n            while (mMission.running&& (len = mIs.read(buf, 0, buf.length)) != - 1) {\n            mF.write(buf, 0, len);\n            start += len;\n            mMission.notifyProgress(len);\n            }\n            dispose();\n\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == - 1;\n        } catch (Exception e)\n        {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n            if (!mMission.running || e instanceof ClosedByInterruptException) return;\n            if (e instanceof HttpError&& ((HttpError)e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n            run();// try again\n            return;\n        }\n\n        if (done) {\n                      mMission.notifyFinished();\n                  } else {\n                             mMission.fallbackResumeOffset = start;\n                         }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "15", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n        out.flush();\n        aux.flush();\n\n\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        byte [] buffer = new byte [COPY_BUFFER_SIZE];\n        aux.target.seek(0);\n        out.target.seek(out.length);\n        long length = amount;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n        if (underflow) {\n                           if (out.offset >= out.length) {\n                // calculate the aux underflow pointer\n                                                             if (aux.offset < amount) {\n                                                                                          out.offset += aux.offset;\n                                                                                          aux.offset = 0;\n                                                                                          out.target.seek(out.offset);\n                                                                                      } else {\n                                                                                                 aux.offset -= amount;\n                                                                                                 out.offset = out.length + amount;\n                                                                                             }\n                                                         } else {\n                                                                    aux.offset = 0;\n                                                                }\n                       } else {\n                                  out.offset += amount;\n                                  aux.offset -= amount;\n                              }\n        out.length += amount;\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n            aux.length -= amount;\n            length = aux.length;\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);// or setLength(0);\n        }\n        aux.reset();\n        }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "16", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action, @\n                                                                           StringRes int reason) {\n    StringBuilder request = new StringBuilder(256);\n    request.append(mission.source);\n    request.append(\" [\");\n    if (mission.recoveryInfo != null) {\n        for (MissionRecoveryInfo recovery : mission.recoveryInfo) request.append(' ').append(recovery.toString()).append(' ');\n    }\n    request.append(\"]\");\n    String service;\n    try\n    {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e)\n    {\n        service = ErrorInfo.SERVICE_NONE;\n    }\n    ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "17", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n    synchronized(this) {\n                           mission.timestamp = System.currentTimeMillis();\n                           mission.mHandler = mHandler;\n                           mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n                           while (true) {\n                           mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                           if (!mission.metadata.isFile()&& !mission.metadata.exists()) {\n                               try\n                               {\n                                   if (!mission.metadata.createNewFile()) throw new RuntimeException(\"Cant create download metadata file\");\n                               } catch (IOException e)\n                               {\n                                   throw new RuntimeException(e);\n                               }\n\n                               break;\n                           }\n                           mission.timestamp = System.currentTimeMillis();\n                           }\n                           mSelfMissionsControl = true;\n                           mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n                           Utility.writeToFile(mission.metadata, mission);\n                           if (mission.storage == null) {\n                // noting to do here\n                               mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                               if (mission.errObject != null) mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                               return;\n                           }\n\n                           boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n                           if (canDownloadInCurrentNetwork()&&\n                                   start) {\n                               mission.start();\n                           }\n                       }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "18", "src_id": "M1136", "code": "\n    @ Override int process(SharpStream out,\n                           SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n    String format = getArgumentAt(0, null);\n    boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n    if (format == null || format.equals(\"ttml\")) {\n                                                     SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n                                                     try\n                                                     {\n                                                         writer.build(sources[ 0]);\n                                                     } catch (Exception err)\n                                                     {\n                                                         Log.e(TAG, \"subtitle parse failed\", err);\n                                                         return err instanceof IOException ?\n                                                                1: 8;\n                                                     }\n\n                                                     return OK_RESULT;\n                                                 } else if (format.equals(\"srt\")) {\n                                                            byte [] buffer = new byte [ 8 * 1024];\n                                                            int read;\n                                                            while ((read = sources[ 0].read(buffer)) > 0) {\n                                                            out.write(buffer, 0, read);\n                                                            }\n\n                                                            return OK_RESULT;\n                                                        }\n\n    throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "19", "src_id": "M1047", "code": "\n    private void joinForThreads(int millis) {\n    final Thread currentThread = Thread.currentThread();\n\n    if (init != null&&\n            init != currentThread&&\n            init.isAlive()) {\n        init.interrupt();\n        if (millis > 0) {\n            try\n            {\n                init.join(millis);\n            } catch (InterruptedException e)\n            {\n                Log.w(TAG, \"Initializer thread is still running\", e);\n                return;\n            }\n        }\n    }\n\n        // if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n    for (Thread thread : threads) {\n    if (!thread.isAlive() || thread == Thread.currentThread()) continue;\n    thread.interrupt();\n    }\n\n    try\n    {\n        for (Thread thread : threads) {\n        if (!thread.isAlive()) continue;\n        if (DEBUG) {\n            Log.w(TAG, \"thread alive: \" + thread.getName());\n        }\n\n        if (millis > 0) thread.join(millis);\n        }\n    } catch (InterruptedException e)\n    {\n        throw new RuntimeException(\"A download thread is still running\", e);\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "20", "src_id": "M491", "code": "\n    @ SuppressLint(\"SwitchIntDef\" ) // only fit, fill and zoom are supported by NewPipe @ ResizeMode public static int nextResizeModeAndSaveToPrefs(final Player player, @ ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch(resizeMode) {\n                           case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                           newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                           break;\n                           case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n            break;\n                           case AspectRatioFrameLayout.RESIZE_MODE_ZOOM: default:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n            break;\n        }\n\n        // save the new resize mode so it can be restored in a future session\n        player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n\n", "compilable": false, "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "21", "src_id": "M424", "code": "\n    @ Override public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if(Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close it because when changing orientation from portrait\n            // (in fullscreen mode) the size of queue layout can be larger than the screen size\n            closeItemsList();\n        }\nelse if(ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            // Ensure that we have audio-only stream playing when a user\n            // started to play from notification's play button from outside of the app\n         if (!fragmentIsVisible) {\n             onFragmentStopped();\n         }\n     }\n     else if(VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n              fragmentIsVisible = false;\n              onFragmentStopped();\n          }\nelse if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            // Restore video source when user returns to the fragment\n         fragmentIsVisible = true;\n         player.useVideoSource(true);\n\n            // When a user returns from background, the system UI will always be shown even if\n            // controls are invisible: hide it in that case\n         if (!isControlsVisible()) {\n             hideSystemUIIfNeeded();\n         }\n     }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "22", "src_id": "M900", "code": "\n    @ StyleRes public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        final String selectedTheme = getSelectedThemeKey(context);\n        if(selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        }\nelse if(selectedTheme.equals(blackTheme)) {\n         return R.style.BlackSettingsTheme;\n     }\n     else if(selectedTheme.equals(automaticDeviceTheme)) {\n              if(isDeviceDarkThemeEnabled(context)) {\n                // use the dark theme variant preferred by the user\n                  final String selectedNightTheme = getSelectedNightThemeKey(context);\n                  if(selectedNightTheme.equals(blackTheme)) {\n                      return R.style.BlackSettingsTheme;\n                  }\nelse {\n                      return R.style.DarkSettingsTheme;\n                  }\n              }\nelse {\n                // there is only one day theme\n                  return R.style.LightSettingsTheme;\n              }\n          }\nelse {\n            // default to dark theme\n              return R.style.DarkSettingsTheme;\n          }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "23", "src_id": "M895", "code": "\n    @ Override public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n        final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n        final Bitmap result = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth, (int) (source.getHeight()/(source.getWidth()/notificationThumbnailWidth)), null, true);\n        if(result == source|| !result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth - 1, (int) (source.getHeight()/(source.getWidth()/(notificationThumbnailWidth - 1))), null, true);\n            source.recycle();\n            return copied;\n        }\nelse {\n            source.recycle();\n            return result;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "24", "src_id": "M225", "code": "\n    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null|| intent.getAction() == null) {\n            return;\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n        switch(intent.getAction()) {\n                                   case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                                   pause();\n                                   break;\n                                   case ACTION_CLOSE:\n            service.destroyPlayerAndStopService();\n            break;\n                                   case ACTION_PLAY_PAUSE:\n            playPause();\n            break;\n                                   case ACTION_PLAY_PREVIOUS:\n            playPrevious();\n            break;\n                                   case ACTION_PLAY_NEXT:\n            playNext();\n            break;\n                                   case ACTION_FAST_REWIND:\n            fastRewind();\n            break;\n                                   case ACTION_FAST_FORWARD:\n            fastForward();\n            break;\n                                   case ACTION_REPEAT:\n            cycleNextRepeatMode();\n            break;\n                                   case ACTION_SHUFFLE:\n            toggleShuffleModeEnabled();\n            break;\n                                   case Intent.ACTION_CONFIGURATION_CHANGED:\n                                   if (DEBUG) {\n                                       Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                                   }\n                                   break;\n        }\n        UIs.call(playerUi-> playerUi.onBroadcastReceived(intent));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "25", "src_id": "M749", "code": "\n    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n\n        if(errorInfo.getThrowable()instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            // Starting ReCaptcha Challenge Activity\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        }\nelse if(errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n         Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n     }\n     else if(errorInfo.getThrowable()instanceof AgeRestrictedContentException) {\n              Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n          }\nelse if(errorInfo.getThrowable()instanceof GeographicRestrictionException) {\n         Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n     }\nelse if(errorInfo.getThrowable()instanceof PaidContentException) {\n         Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n     }\nelse if(errorInfo.getThrowable()instanceof PrivateContentException) {\n         Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n     }\nelse if(errorInfo.getThrowable()instanceof SoundCloudGoPlusContentException) {\n         Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n     }\nelse if(errorInfo.getThrowable()instanceof YoutubeMusicPremiumContentException) {\n         Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n     }\nelse if(errorInfo.getThrowable()instanceof ContentNotAvailableException) {\n         Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n     }\nelse if(errorInfo.getThrowable()instanceof ContentNotSupportedException) {\n         Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n     }\nelse {\n         ErrorUtil.createNotification(context, errorInfo);\n     }\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity)context).finish();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "26", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@ NonNull final Context context, @ NonNull final FragmentManager fragmentManager, final int serviceId, @ Nullable final String url, @ NonNull final String title, @ Nullable final PlayQueue playQueue, final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @ Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n        if(playerType == null) {\n            // no player open\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        }\nelse if(switchingPlayers) {\n            // switching player to main player\n         autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n     }\n     else if(playerType == PlayerType.MAIN) {\n            // opening new stream while already playing in main player\n              autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n          }\nelse {\n            // opening new stream while already playing in another player\n              autoPlay = false;\n          }\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment-> {\n                                                                               expandMainPlayer(detailFragment.requireActivity());\n                                                                               detailFragment.setAutoPlay(autoPlay);\n                                                                               if(switchingPlayers) {\n                // Situation when user switches from players to main player. All needed data is\n                // here, we can start watching (assuming newQueue equals playQueue).\n                // Starting directly in fullscreen if the previous player type was popup.\n                                                                                   detailFragment.openVideoPlayer(playerType == PlayerType.POPUP|| PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n                                                                               }\nelse {\n                                                                                   detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n                                                                               }\n                                                                               detailFragment.scrollToTop();\n                                                                           };\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if(fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment)fragment);\n        }\nelse {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n            defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(()-> onVideoDetailFragmentReady.run(instance)).commit();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "27", "src_id": "M698", "code": "\n    @ Override public void handleResult(@ NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n        if(ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n        }\nelse {\n            // do not waste space for the banner, if the user disabled images or there is not one\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if(result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        }\nelse {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n        updateRssButton();\n        channelContentNotSupported = false;\n        for(final Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "28", "src_id": "M379", "code": "\n    @ Override public void onTextTracksChanged(@ NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)|| currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null|| !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n        final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo-> C.TRACK_TYPE_TEXT == trackGroupInfo.getType()).collect(Collectors.toList());\n        final List<String> availableLanguages = textTracks.stream().map(Tracks.Group::getMediaTrackGroup).filter(textTrack-> textTrack.length > 0).map(textTrack-> textTrack.getFormat(0).language).collect(Collectors.toList());\n\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info-> info.getMediaTrackGroup().length >= 1).map(info-> info.getMediaTrackGroup().getFormat(0)).findFirst();\n\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n        if(player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex())|| selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        }\nelse {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "29", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(final Context context, @ NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n            @ Override public Bitmap transform(final Bitmap source) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n                }\n                final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n                final Bitmap result = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth, (int) (source.getHeight()/(source.getWidth()/notificationThumbnailWidth)), null, true);\n                if(result == source|| !result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth - 1, (int) (source.getHeight()/(source.getWidth()/(notificationThumbnailWidth - 1))), null, true);\n                    source.recycle();\n                    return copied;\n                }\nelse {\n                    source.recycle();\n                    return result;\n                }\n            }\n            @ Override public String key() {\n                return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n            }});\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "30", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status if requested\n\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "31", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n        try {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class < ?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n\n            // Additional check for MimeMultipart\n\n            try {\n                Class < ?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "32", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[j].trim());\n                        } else {\n                            break;\n                        }\n                    }\n                    // Apply MIME header decoding\n\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim().isEmpty()) break;\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n\n        return \"\";\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "33", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(PDDocument document, List <EmailAttachment > attachments) throws\n        IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n\n        // 1. Find the screen position of all attachment markers\n\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true); // Process pages in order\n        finder.getText(document);\n        List <MarkerPosition > markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "34", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte [] emlBytes,EmlToPdfRequest request) {\n        if (emlBytes == null||emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null? textBody:\n                                         \"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\") .append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\") .append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \") .append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \") .append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim() .isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \") .append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n\n            if (!bcc.trim() .isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \") .append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim() .isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \") .append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status if requested\n\n        assert request != null;\n        if (request.getFileInput() .isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "35", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n        try {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n\n            // Additional check for MimeMultipart\n\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "36", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent,String headerName) {\n        try {\n            String [] lines = emlContent.split(\"\\r?\\n\");\n\n            for (int i = 0;\n            i<lines.length;\n            i++) {\n                String line = lines[ i];\n\n                if (line.toLowerCase() .startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()) .trim());\n                    // Handle multi-line headers\n\n                    for (int j = i+ 1;\n                    j<lines.length;\n                    j++) {\n                        if (lines[ j].startsWith(\" \")||lines[ j].startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[ j].trim());\n                        } else {\n                            break;\n                        }\n                    }\n                    // Apply MIME header decoding\n\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim() .isEmpty()) break;\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n\n        return \"\";\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "37", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(PDDocument document,List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0||attachments == null||attachments.isEmpty()) {\n            return;\n        }\n\n        // 1. Find the screen position of all attachment markers\n\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true); // Process pages in order\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n\n        for (int i = 0;\n        i<annotationsToAdd;\n        i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "38", "src_id": "M1277", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "39", "src_id": "M902", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "40", "src_id": "M1131", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "41", "src_id": "M1057", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1229", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "43", "src_id": "M894", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "44", "src_id": "M897", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1213", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "46", "src_id": "M9", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "47", "src_id": "M1105", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "48", "src_id": "M270", "code": "\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n\n        if (value.matches(\"^(ia64w?|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n\n        if (\"ia64n\".equals(value)) {\n            return \"itanium_32\";\n        }\n\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n\n        if (value.matches(\"^(mips|mips32)$\")) {\n            return \"mips_32\";\n        }\n\n        if (value.matches(\"^(mipsel|mips32el)$\")) {\n            return \"mipsel_32\";\n        }\n\n        if (\"mips64\".equals(value)) {\n            return \"mips_64\";\n        }\n\n        if (\"mips64el\".equals(value)) {\n            return \"mipsel_64\";\n        }\n\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n\n        if (value.matches(\"^(ppcle|ppc32le)$\")) {\n            return \"ppcle_32\";\n        }\n\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n\n        return value;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "49", "src_id": "M928", "code": "\n    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n        Map<String, Object> info = new HashMap<String, Object>();\n        info.put(LoggerHelper.name, logger.getName());\n        info.put(LoggerHelper.clazz, logger.getClass());\n        CodeSource codeSource = logger.getClass() .getProtectionDomain() .getCodeSource();\n\n        if (codeSource != null) {\n            info.put(LoggerHelper.codeSource, codeSource.getLocation());\n        }\n\n        info.put(LoggerHelper.additivity, logger.getAdditivity());\n        Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n\n        if (level != null) {\n            info.put(LoggerHelper.level, level.toString());\n        }\n\n        if (effectiveLevel != null) {\n            info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n        }\n\n        @ SuppressWarnings(\"unchecked\") List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n        info.put(LoggerHelper.appenders, result);\n        return info;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "50", "src_id": "M9", "code": "\n    @ SuppressWarnings(\"resource\")\n    public static long select(boolean v, long telnetPortPid,String select) throws InputMismatchException {\n        Map<Long, String> processMap = listProcessByJps(v);\n        // Put the port that is already listening at the first\n\n        if (telnetPortPid> 0 && processMap.containsKey(telnetPortPid)) {\n            String telnetPortProcess = processMap.get(telnetPortPid);\n            processMap.remove(telnetPortPid);\n            Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n            newProcessMap.put(telnetPortPid, telnetPortProcess);\n            newProcessMap.putAll(processMap);\n            processMap = newProcessMap;\n        }\n\n        if (processMap.isEmpty()) {\n            AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n            return -1;\n        }\n\n        // select target process by the '--select' option when match only one process\n\n        if (select != null && !select.trim() .isEmpty()) {\n            int matchedSelectCount = 0;\n            Long matchedPid = null;\n\n            for(Entry<Long, String> entry :processMap.entrySet() ) {\n                if (entry.getValue() .contains(select)) {\n                    matchedSelectCount++;\n                    matchedPid = entry.getKey();\n                }\n            }\n\n            if (matchedSelectCount == 1) {\n                return matchedPid;\n            }\n        }\n\n        AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n        // print list\n\n        int count = 1;\n\n        for(String process :processMap.values() ) {\n            if (count == 1) {\n                System.out.println(\"* [\"+count+ \"]: \"+process);\n            } else {\n                System.out.println(\"  [\"+count+ \"]: \"+process);\n            }\n\n            count++;\n        }\n\n        // read choice\n\n        String line = new Scanner(System.in) .nextLine();\n\n        if (line.trim() .isEmpty()) {\n            // get the first process id\n            return processMap.keySet() .iterator() .next();\n        }\n\n        int choice = new Scanner(line) .nextInt();\n\n        if (choice<= 0||choice> processMap.size()) {\n            return -1;\n        }\n\n        Iterator<Long> idIter = processMap.keySet() .iterator();\n\n        for (int i = 1;i<=choice;\n        ++i) {\n            if (i == choice) {\n                return idIter.next();\n            }\n\n            idIter.next();\n        }\n\n        return -1;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "51", "src_id": "M140", "code": "\n    void _processDo(int option) throws IOException {\n        if (debugoptions) {\n            System.err.println(\"RECEIVED DO: \"+TelnetOption.getOption(option));\n        }\n\n        if (__notifhand != null) {\n            __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n        }\n\n        boolean acceptNewState = false;\n\n\n        /* open TelnetOptionHandler functionality (start)*/\n\n        if (optionHandlers[option] != null) {\n            acceptNewState = optionHandlers[option].getAcceptLocal();\n        } else {\n        /* open TelnetOptionHandler functionality (end)*/\n            /* TERMINAL-TYPE option (start)*/\n            if (option == TERMINAL_TYPE) {\n                if ((terminalType != null) && (terminalType.length()> 0)) {\n                    acceptNewState = true;\n                }\n            }\n            /* TERMINAL-TYPE option (end)*/\n        /* open TelnetOptionHandler functionality (start)*/\n        }\n        /* open TelnetOptionHandler functionality (end)*/\n\n        if (_willResponse[option]> 0) {\n            -- _willResponse[option];\n            if (_willResponse[option]> 0 && _stateIsWill(option)) {\n                -- _willResponse[option];\n            }\n        }\n\n        if (_willResponse[option] == 0) {\n            if (_requestedWont(option)) {\n                switch (option) {\n                default:\n                    break;\n                }\n\n                if (acceptNewState) {\n                    _setWantWill(option);\n                    _sendWill(option);\n                } else {\n                    ++_willResponse[option];\n                    _sendWont(option);\n                }\n            } else {\n                // Other end has acknowledged option.\n                switch (option) {\n                default:\n                    break;\n                }\n            }\n        }\n\n        _setWill(option);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "52", "src_id": "M1324", "code": "\n    private void bind(Configure configure) throws Throwable {\n        long start = System.currentTimeMillis();\n\n        if (!isBindRef.compareAndSet(false, true)) {\n            throw new IllegalStateException(\"already bind\");\n        }\n\n        // init random port\n\n        if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n            int newTelnetPort = SocketUtils.findAvailableTcpPort();\n            configure.setTelnetPort(newTelnetPort);\n            logger().info(\"generate random telnet port: \"+newTelnetPort);\n        }\n\n        if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n            int newHttpPort = SocketUtils.findAvailableTcpPort();\n            configure.setHttpPort(newHttpPort);\n            logger().info(\"generate random http port: \"+newHttpPort);\n        }\n        // try to find appName\n\n        if (configure.getAppName() == null) {\n            configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n        }\n\n        try {\n            if (configure.getTunnelServer() != null) {\n                tunnelClient = new TunnelClient();\n                tunnelClient.setAppName(configure.getAppName());\n                tunnelClient.setId(configure.getAgentId());\n                tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n                tunnelClient.setVersion(ArthasBanner.version());\n                ChannelFuture channelFuture = tunnelClient.start();\n                channelFuture.await(10, TimeUnit.SECONDS);\n            }\n        } catch (Throwable t) {\n            logger().error(\"start tunnel client error\", t);\n        }\n\n        try {\n            ShellServerOptions options = new ShellServerOptions() .setInstrumentation(instrumentation) .setPid(PidUtils.currentLongPid() ) .setWelcomeMessage(ArthasBanner.welcome() );\n\n            if (configure.getSessionTimeout() != null) {\n                options.setSessionTimeout(configure.getSessionTimeout()* 1000);\n            }\n\n            this.httpSessionManager = new HttpSessionManager();\n            if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n                // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n                String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \"+ \"No password is currently configured. \"+ \"Therefore, a default password is generated, \"+ \"and clients need to use the password to connect!\";\n                AnsiLog.error(errorMsg);\n                configure.setPassword(StringUtils.randomString(64));\n                AnsiLog.error(\"Generated arthas password: \"+configure.getPassword());\n                logger().error(errorMsg);\n                logger().info(\"Generated arthas password: \"+configure.getPassword());\n            }\n\n            this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n            shellServer = new ShellServerImpl(options);\n            List<String> disabledCommands = new ArrayList <String>();\n\n            if (configure.getDisabledCommands() != null) {\n                String [] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n\n                if (strings != null) {\n                    disabledCommands.addAll(Arrays.asList(strings));\n                }\n            }\n\n            BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n            List<CommandResolver> resolvers = new ArrayList <CommandResolver>();\n            resolvers.add(builtinCommands);\n\n            //worker group\n            workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n            // TODO: discover user provided command resolver\n            if (configure.getTelnetPort() != null && configure.getTelnetPort()> 0) {\n                logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n                shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else {\n                logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n            }\n\n            if (configure.getHttpPort() != null && configure.getHttpPort()> 0) {\n                logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n                shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else {\n                // listen local address in VM communication\n                if (configure.getTunnelServer() != null) {\n                    shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n                }\n\n                logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n            }\n\n            for(CommandResolver resolver :resolvers) {\n                shellServer.registerCommandResolver(resolver);\n            }\n\n            shellServer.listen(new BindHandler(isBindRef));\n            if (!isBind()) {\n                throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \"+String.valueOf(configure.getTelnetPort())+ \", http port: \"+String.valueOf(configure.getHttpPort()));\n            }\n\n            //http api session manager\n\n            sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n            //http api handler\n            httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n            logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n            // 异步回报启动次数\n            if (configure.getStatUrl() != null) {\n                logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n            }\n\n            UserStatUtil.setStatUrl(configure.getStatUrl());\n            UserStatUtil.setAgentId(configure.getAgentId());\n            UserStatUtil.arthasStart();\n            try {\n                SpyAPI.init();\n            } catch (Throwable e) {\n                // ignore\n            }\n\n            logger().info(\"as-server started in {} ms\", System.currentTimeMillis()-start);\n        } catch (Throwable e) {\n            logger().error(\"Error during start as-server\", e);\n            destroy();\n            throw e;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "53", "src_id": "M122", "code": "\n    private int __read(boolean mayBlock) throws IOException {\n        int ch;\n\n        while (true) {\n\n            // If there is no more data AND we were told not to block,\n            // just return WOULD_BLOCK (-2). (More efficient than exception.)\n            if (!mayBlock && super.available() == 0) {\n                return WOULD_BLOCK;\n            }\n\n            // Otherwise, exit only when we reach end of stream.\n\n            if ((ch = super.read() )< 0) {\n                return EOF;\n            }\n\n            ch = (ch& 0xff);\n\n            /* Code Section added for supporting AYT (start)*/\n            synchronized (__client) {\n                                    __client._processAYTResponse();\n            }\n            /* Code Section added for supporting AYT (end)*/\n\n            /* Code Section added for supporting spystreams (start)*/\n\n            __client._spyRead(ch);\n            /* Code Section added for supporting spystreams (end)*/\n            switch (__receiveState) {\n            case _STATE_CR:\n                if (ch == '\\0') {\n                    // Strip null\n                    continue;\n                }\n                // How do we handle newline after cr?\n                //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n\n                // Handle as normal data by falling through to _STATE_DATA case\n\n                //$FALL-THROUGH$\n            case _STATE_DATA:\n                if (ch == TelnetCommand.IAC) {\n                    __receiveState = _STATE_IAC;\n                    continue;\n                }\n\n                if (ch == '\\r') {\n                    synchronized (__client) {\nif (__client._requestedDont(TelnetOption.BINARY)) {\n    __receiveState = _STATE_CR;\n} else {\n    __receiveState = _STATE_DATA;\n}\n                    }\n                } else {\n                    __receiveState = _STATE_DATA;\n                }\n\n                break;\n            case _STATE_IAC:\n                switch (ch) {\n                case TelnetCommand.WILL:\n                    __receiveState = _STATE_WILL;\n                    continue;\n                case TelnetCommand.WONT:\n                    __receiveState = _STATE_WONT;\n                    continue;\n                case TelnetCommand.DO:\n                    __receiveState = _STATE_DO;\n                    continue;\n                case TelnetCommand.DONT:\n                    __receiveState = _STATE_DONT;\n                    continue;\n                /* TERMINAL-TYPE option (start)*/\n                case TelnetCommand.SB:\n                    __suboption_count = 0;\n                    __receiveState = _STATE_SB;\n                    continue;\n                /* TERMINAL-TYPE option (end)*/\n                case TelnetCommand.IAC:\n                    __receiveState = _STATE_DATA;\n                    break; // exit to enclosing switch to return IAC from read\n                case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)\n                    __receiveState = _STATE_DATA;\n                    continue;\n                default:\n                    __receiveState = _STATE_DATA;\n                    __client._processCommand(ch); // Notify the user\n                    continue; // move on the next char\n                }\n\n                break; // exit and return from read\n            case _STATE_WILL:\n                synchronized (__client) {\n                                        __client._processWill(ch);\n                                        __client._flushOutputStream();\n                }\n\n                __receiveState = _STATE_DATA;\n                continue;\n            case _STATE_WONT:\n                synchronized (__client) {\n                                        __client._processWont(ch);\n                                        __client._flushOutputStream();\n                }\n\n                __receiveState = _STATE_DATA;\n                continue;\n            case _STATE_DO:\n                synchronized (__client) {\n                                        __client._processDo(ch);\n                                        __client._flushOutputStream();\n                }\n\n                __receiveState = _STATE_DATA;\n                continue;\n            case _STATE_DONT:\n                synchronized (__client) {\n                                        __client._processDont(ch);\n                                        __client._flushOutputStream();\n                }\n\n                __receiveState = _STATE_DATA;\n                continue;\n            /* TERMINAL-TYPE option (start)*/\n            case _STATE_SB:\n                switch (ch) {\n                case TelnetCommand.IAC:\n                    __receiveState = _STATE_IAC_SB;\n                    continue;\n                default:\n                    // store suboption char\n                    if (__suboption_count<__suboption.length) {\n                        __suboption[__suboption_count ++] = ch;\n                    }\n\n                    break;\n                }\n\n                __receiveState = _STATE_SB;\n                continue;\n            case _STATE_IAC_SB: // IAC received during SB phase\n                switch (ch) {\n                case TelnetCommand.SE:\n                    synchronized (__client) {\n                                            __client._processSuboption(__suboption, __suboption_count);\n                                            __client._flushOutputStream();\n                    }\n\n                    __receiveState = _STATE_DATA;\n                    continue;\n                case TelnetCommand.IAC: // De-dup the duplicated IAC\n                    if (__suboption_count<__suboption.length) {\n                        __suboption[__suboption_count ++] = ch;\n                    }\n\n                    break;\n                default:            // unexpected byte! ignore it\n                    break;\n                }\n\n                __receiveState = _STATE_SB;\n                continue;\n            /* TERMINAL-TYPE option (end)*/\n            }\n\n            break;\n        }\n\n        return ch;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "54", "src_id": "M8", "code": "\n    private static String formatFileSize(long size) {\n        String hrSize;\n        double b = size;\n        double k = size/1024.0;\n        double m = ((size/1024.0)/1024.0);\n        double g = (((size/1024.0)/1024.0)/1024.0);\n        double t = ((((size/1024.0)/1024.0)/1024.0)/1024.0);\n        DecimalFormat dec = new DecimalFormat(\"0.00\");\n\n        if (t> 1) {\n            hrSize = dec.format(t) .concat(\" TB\");\n        } else if (g> 1) {\n                   hrSize = dec.format(g) .concat(\" GB\");\n               } else if (m> 1) {\n                          hrSize = dec.format(m) .concat(\" MB\");\n                      } else if (k> 1) {\n                                 hrSize = dec.format(k) .concat(\" KB\");\n                             } else {\n                                 hrSize = dec.format(b) .concat(\" Bytes\");\n                             }\n\n        return hrSize;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "55", "src_id": "M790", "code": "\n    @Override\n    public byte [] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte [] classfileBuffer) throws IllegalClassFormatException {\n        if (className == null) {\n            return null;\n        }\n\n        className = className.replace('/', '.');\n        List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n            // 倒序，因为要执行的配置生效\n        ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n\n        while (listIterator.hasPrevious()) {\n            RetransformEntry retransformEntry = listIterator.previous();\n            int id = retransformEntry.getId();\n                // 判断类名是否一致\n            boolean updateFlag = false;\n                // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n\n            if (className.equals(retransformEntry.getClassName())) {\n                if (retransformEntry.getClassLoaderClass() != null||retransformEntry.getHashCode() != null) {\n                    updateFlag = isLoaderMatch(retransformEntry, loader);\n                } else {\n                    updateFlag = true;\n                }\n            }\n\n            if (updateFlag) {\n                logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n                retransformEntry.incTransformCount();\n                return retransformEntry.getBytes();\n            }\n        }\n\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "56", "src_id": "M716", "code": "\n    public static void drawPlayException(TableElement table,ObjectVO throwableVO) {\n        // 执行失败:输出失败状态\n        table.row(\"IS-RETURN\", \"\"+ false);\n        table.row(\"IS-EXCEPTION\", \"\"+ true);\n\n        // 执行失败:输出失败异常信息\n        Throwable cause;\n        Throwable t = (Throwable) throwableVO.getObject();\n\n        if (t instanceof InvocationTargetException) {\n            cause = t.getCause();\n        } else {\n            cause = t;\n        }\n\n        if (throwableVO.needExpand()) {\n            table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()) .draw());\n        } else {\n            StringWriter stringWriter = new StringWriter();\n            PrintWriter printWriter = new PrintWriter(stringWriter);\n\n            try {\n                cause.printStackTrace(printWriter);\n                table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n            } finally {\n                      printWriter.close();\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "57", "src_id": "M602", "code": "\n    private AsyncProfiler profilerInstance() {\n        if (profiler != null) {\n            return profiler;\n        }\n\n        // try to load from special path\n\n        if (ProfilerAction.load.toString() .equals(action)) {\n            profiler = AsyncProfiler.getInstance(this.actionArg);\n        }\n\n        if (libPath != null) {\n            // load from arthas directory\n            // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n            FileOutputStream tmpLibOutputStream = null;\n            FileInputStream libInputStream = null;\n\n            try {\n                File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n                tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n                libInputStream = new FileInputStream(libPath);\n                IOUtils.copy(libInputStream, tmpLibOutputStream);\n                libPath = tmpLibFile.getAbsolutePath();\n                logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n            } catch (Throwable e) {\n                logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n            }\n\n            finally {\n                    IOUtils.close(libInputStream);\n                    IOUtils.close(tmpLibOutputStream);\n            }\n\n            profiler = AsyncProfiler.getInstance(libPath);\n        } else {\n            if (OSUtils.isLinux()||OSUtils.isMac()) {\n                throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n            } else {\n                throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n            }\n        }\n\n        return profiler;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "58", "src_id": "M475", "code": "\n    @\n    Override public void draw(CommandProcess process, JvmModel result) {\n        TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n        for (Map.Entry <String, List <JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n            String group = entry.getKey();\n            List<JvmItemVO> items = entry.getValue();\n            table.row(true, label(group).style(Decoration.bold.bold()));\n            for (JvmItemVO item : items) {\n                String valueStr;\n                if (item.getValue() instanceof Map&& item.getName().endsWith(\"MEMORY-USAGE\")) {\n                                                                                                  valueStr = renderMemoryUsage((Map <String, Object>)item.getValue());\n                                                                                              }\n                else\n                {\n                    valueStr = renderItemValue(item.getValue());\n                }\n\n                if (item.getDesc() != null) {\n                                                table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n                                            }\n                else\n                {\n                    table.row(item.getName(), valueStr);\n                }\n            }\n            table.row(\"\", \"\");\n        }\n        process.write(RenderUtil.render(table, process.width()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "59", "src_id": "M535", "code": "\n    public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n        final StringBuilder infoSB = new StringBuilder();\n        List<String> classDumpFiles = affectVO.getClassDumpFiles();\n        if (classDumpFiles != null) {\n            for (String classDumpFile : classDumpFiles) {\n                infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n            }\n        }\n\n        List<String> methods = affectVO.getMethods();\n        if (methods != null) {\n            for (String method : methods) {\n                infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n            }\n        }\n        infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\", affectVO.getClassCount(), affectVO.getMethodCount(), affectVO.getCost(), affectVO.getListenerId()));\n        if (! StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n            infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n        }\n\n        if (affectVO.getThrowable() != null) {\n            infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n        }\n        infoSB.append(\"\\n\");\n        return infoSB.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "60", "src_id": "M753", "code": "\n    public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n        List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n\n        // Sample CPU\n        if (lastCpuTimes.isEmpty()) {\n            lastSampleTimeNanos = System.nanoTime();\n            for (ThreadVO thread : threads) {\n                if (thread.getId() > 0) {\n                    long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                    lastCpuTimes.put(thread, cpu);\n                    thread.setTime(cpu / 1000000);\n                }\n            }\n\n            // add internal threads\n\n            Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n            if (internalThreadCpuTimes != null) {\n                for (Map.Entry <String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                    String key = entry.getKey();\n                    ThreadVO thread = createThreadVO(key);\n                    thread.setTime(entry.getValue() / 1000000);\n                    threads.add(thread);\n                    lastCpuTimes.put(thread, entry.getValue());\n                }\n            }\n\n            //sort by time\n            Collections.sort(threads, new Comparator<ThreadVO>() {\n                                          @\n                                          Override public int compare(ThreadVO o1, ThreadVO o2) {\n                                              long l1 = o1.getTime();\n\n                                              long l2 = o2.getTime();\n                                              if (l1 < l2) {\n                                                  return 1;\n                                                           }\n                                              else if (l1 > l2) {\n                                                                    return - 1;\n                                              } else {\n                                                         return 0;\n                                              }\n                                          }\n\n                                      });\n            return threads;\n        }\n\n        // Resample\n\n        long newSampleTimeNanos = System.nanoTime();\n        Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                newCpuTimes.put(thread, cpu);\n            }\n        }\n        // internal threads\n\n        Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (newInternalThreadCpuTimes != null) {\n            for (Map.Entry <String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n                ThreadVO threadVO = createThreadVO(entry.getKey());\n                threads.add(threadVO);\n                newCpuTimes.put(threadVO, entry.getValue());\n            }\n        }\n\n        // Compute delta time\n\n        final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : newCpuTimes.keySet()) {\n            Long t = lastCpuTimes.get(thread);\n            if (t == null) {\n                t = 0L;\n            }\n\n            long time1 = t;\n\n            long time2 = newCpuTimes.get(thread);\n            if (time1 == - 1 ) {\n                                   time1 = time2;\n                               }\n            else if (time2 == - 1) {\n                 time2 = time1;\n                 }\n\n            long delta = time2 - time1;\n            deltas.put(thread, delta);\n        }\n\n        long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n\n        // Compute cpu usage\n\n        final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n        for (ThreadVO thread : threads) {\n            double cpu = sampleIntervalNanos == 0? 0: (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0);\n            cpuUsages.put(thread, cpu);\n        }\n\n        // Sort by CPU time : should be a rendering hint...\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n                                      @\n                                      Override public int compare(ThreadVO o1, ThreadVO o2) {\n                                          long l1 = deltas.get(o1);\n\n                                          long l2 = deltas.get(o2);\n                                          if (l1 < l2) {\n                                              return 1;\n                                                       }\n                                          else if (l1 > l2) {\n                                                                return - 1;\n                                          } else {\n                                                     return 0;\n                                          }\n                                      }\n\n                                  });\n        for (ThreadVO thread : threads) {\n            //nanos to mills\n            long timeMills = newCpuTimes.get(thread) / 1000000;\n\n            long deltaTime = deltas.get(thread) / 1000000;\n\n            double cpu = cpuUsages.get(thread);\n            thread.setCpu(cpu);\n            thread.setTime(timeMills);\n            thread.setDeltaTime(deltaTime);\n        }\n        lastCpuTimes = newCpuTimes;\n        lastSampleTimeNanos = newSampleTimeNanos;\n        return threads;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "61", "src_id": "M1131", "code": "\n    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<String, Object>();\n        body.put(\"command\", commandLine);\n        ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n        if (! session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n\n        int lock = session.getLock();\n        try\n        {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n\n            //create job\n\n            Job job = this.createJob(commandLine, session, session.getResultDistributor());\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            response.setState(ApiState.SCHEDULED);\n\n            //add command before exec job\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n            commandRequestModel.setJobId(job.id());\n            SharingResultDistributor resultDistributor = session.getResultDistributor();\n            if (resultDistributor != null) {\n                resultDistributor.appendResult(commandRequestModel);\n            }\n            session.setForegroundJob(job);\n            updateSessionInputStatus( session, InputStatus.ALLOW_INTERRUPT );\n\n            //run job\n            job.run();\n            return response;\n        } catch (Throwable e)\n        {\n            logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n            session.getResultDistributor().appendResult(commandRequestModel);\n            return response;\n        }\n\nfinally\n        {\n        if (session.getLock() == lock) {\n            session.unLock();\n        }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "62", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map <String, Object>> loggerInfos,\n                                    int width) {\n        StringBuilder sb = new StringBuilder(8192);\n        for (Map.Entry <String, Map <String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n            Class<?> clazz = (Class <?>)info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name))).row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName())).row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @\n                SuppressWarnings(\"unchecked\")List<Map <String, Object>> appenders = (List <Map <String, Object>>)info.get(LoggerHelper.appenders);\n            if (appenders != null&& ! appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class <?>)appenderInfo.get(LoggerHelper.clazz);\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n\n        return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "63", "src_id": "M15", "code": "\n    public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n        // start java telnet client\n        // find arthas-client.jar\n        URLClassLoader classLoader = new URLClassLoader(new URL [] {\n                                                            new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n        Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n        Method processMethod = telnetConsoleClass.getMethod(\n            \"process\", String[].class);\n\n        //redirect System.out/System.err\n        PrintStream originSysOut = System.out;\n        PrintStream originSysErr = System.err;\n        PrintStream newOut = new PrintStream(out);\n        PrintStream newErr = new PrintStream(out);\n\n        // call TelnetConsole.process()\n        // fix https://github.com/alibaba/arthas/issues/833\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try\n        {\n            System.setOut(newOut);\n            System.setErr(newErr);\n            Thread.currentThread().setContextClassLoader(classLoader);\n            return (Integer)processMethod.invoke(null, new Object [] {\n                                                                         telnetArgs.toArray(new String [ 0])});\n        } catch (Throwable e)\n        {\n            //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n            e = e.getCause();\n            if (e instanceof IOException || e instanceof InterruptedException) {\n                // ignore connection error and interrupted error\n                return STATUS_ERROR;\n                                                                               }\n            else\n            {\n                // process error\n                AnsiLog.error(\"process error: {}\", e.toString());\n                AnsiLog.error(e);\n                return STATUS_EXEC_ERROR;\n            }\n        }\n\nfinally\n        {\n            Thread.currentThread().setContextClassLoader(tccl);\n\n            //reset System.out/System.err\n            System.setOut(originSysOut);\n            System.setErr(originSysErr);\n            //flush output\n            newOut.flush();\n            newErr.flush();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "64", "src_id": "M1469", "code": "\n    public static FieldVO[] getFields(Class clazz, Integer expand) {\n        Field[] fields = clazz.getDeclaredFields();\n        if (fields.length == 0) {\n            return new FieldVO [ 0];\n        }\n\n        List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n        for (Field field : fields) {\n            FieldVO fieldVO = new FieldVO();\n            fieldVO.setName(field.getName());\n            fieldVO.setType(StringUtils.classname(field.getType()));\n            fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n            fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n            if (Modifier.isStatic(field.getModifiers())) {\n                                                             fieldVO.setStatic(true);\n                                                             fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n                                                         }\n            else\n            {\n                fieldVO.setStatic(false);\n            }\n            list.add(fieldVO);\n        }\n\n        return list.toArray(new FieldVO [ 0]);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "65", "src_id": "M1277", "code": "\n    public static Map<String, String> toStringMap(Map<String, Object> input,\n\n                                                  boolean stringEscape) {\n        Map<String, String> output = new HashMap < >(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n\n            String str;\n\n            if (obj instanceof byte[]) {\n                str = SafeEncoder.encode((byte[]) obj);\n            } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                       redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                       str = geo.getLongitude() + \",\" + geo.getLatitude();\n            } else if (obj instanceof String) {\n                       str = stringEscape ? escape((String) obj) : (String) obj;\n                   } else {\n                       str = String.valueOf(obj);\n                   }\n\n            output.put(key, str);\n        }\n\n        return output;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "66", "src_id": "M902", "code": "\n    @Override public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)->args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "67", "src_id": "M1131", "code": "\n    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n    // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE: // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n      // TODO: Blob error '!'\n                   default:\n                       throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "68", "src_id": "M1057", "code": "\n    @Override public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n\n        if (list == null || list.isEmpty()) return null;\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List < KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n\n            assert resultsData != null: \"Could not detect Results data.\";\n            assert profileData != null: \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1229", "code": "\n    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n\n        if (sslVerifyMode == SslVerifyMode.FULL) {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } else if (sslVerifyMode == SslVerifyMode.CA) {\n                   this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n        } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                   trustManagers = new TrustManager [] {\n                                       INSECURE_TRUST_MANAGER};\n               }\n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "70", "src_id": "M894", "code": "\n    @Override public TSInfo build(Object data) {\n        List < KeyValue> list = (List < KeyValue>) data;\n        Map<String, Object> properties = new HashMap < >();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List < Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n\n            if (value instanceof List) {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n                        value = labels;\n                        break;\n                    case RULES_PROPERTY:\n                        List < KeyValue> rulesDataList = (List < KeyValue>) value;\n                        Map<String, List < Object>> rulesValueMap = new HashMap < >(rulesDataList.size(), 1f);\n                        rules = new HashMap < >(rulesDataList.size());\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            List < Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                        }\n\n                        value = rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List < List < KeyValue>> chunksDataList = (List < List < KeyValue>>) value;\n                        List < Map<String, Object>> chunksValueList = new ArrayList < >(chunksDataList.size());\n                        chunks = new ArrayList < >(chunksDataList.size());\n                        for (List < KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv->BuilderFactory.STRING.build(kv.getKey()), kv->BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n                            chunks.add(chunk);\n                        }\n\n                        value = chunksValueList;\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } else if (value instanceof byte[]) {\n                       value = BuilderFactory.STRING.build(value);\n                       if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                           try {\n                               value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                           } catch (Exception e) {\n                           }\n                       }\n                   }\n\n            properties.put(prop, value);\n        }\n\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "71", "src_id": "M897", "code": "\n    @Override public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)->args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1213", "code": "\n    @Override public Connection getConnection() {\n        List < ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n\n                jedis.ping();\n                return jedis;\n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n\n        throw noReachableNode;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "73", "src_id": "M9", "code": "\n    @Override public CacheEntry set(CacheKey cacheKey,CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set < CacheKey < ?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n\n            stats.load();\n            return entry;\n        }\n\n            finally {\n            lock.unlock();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "74", "src_id": "M1105", "code": "\n    @Override public Class < ?> build(Object data) {\n        if (data == null) return null;\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n                     default:\n                         throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1277", "code": "\n    public static Map<String, String> toStringMap(Map<String, Object> input,\n                                                  boolean stringEscape) {\n        Map<String, String> output = new HashMap <>(input.size());\n\n        for(Map.Entry<String, Object> entry :input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n\n            if (key == null||obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n\n            String str;\n\n            if (obj instanceof byte[]) {\n                str = SafeEncoder.encode((byte[])obj);\n            } else\nif (obj instanceof redis .clients .jedis .GeoCoordinate) {\n    redis.clients .jedis .GeoCoordinate geo = (redis .clients .jedis .GeoCoordinate)obj;\n    str = geo.getLongitude()+\",\"+geo.getLatitude();\n} else\n            if (obj instanceof String) {\n                str = stringEscape?escape((String)obj):\n                    (String)obj;\n            } else {\n                str = String.valueOf(obj);\n            }\n\n            output.put(key, str);\n        }\n\n        return output;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "76", "src_id": "M902", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (ignore) {\n            args.add(IGNORE) .add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)->args.add(entry.getKey()) .add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1131", "code": "\n    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n    // System.out.println(\"BYTE: \" + (char) b);\n\n        switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE: // TODO:\n            return processMultiBulkReply(is);\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n      // TODO: Blob error '!'\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \"+(char)b);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "78", "src_id": "M1057", "code": "\n    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List)data;\n\n        if (list == null||list.isEmpty()) return null;\n        if (list.get(0)instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n\n            for(KeyValue keyValue :(List<KeyValue>)data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n\n                switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n                }\n            }\n\n            assert resultsData != null: \"Could not detect Results data.\";\n            assert profileData != null: \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "79", "src_id": "M1229", "code": "\n    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager [] keyManagers = null;\n        TrustManager [] trustManagers = null;\n\n        if (sslVerifyMode == SslVerifyMode.FULL) {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } else\nif (sslVerifyMode == SslVerifyMode.CA) {\n    this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n} else\n        if (sslVerifyMode == SslVerifyMode.INSECURE) {\n            trustManagers = new TrustManager [] {\n                                INSECURE_TRUST_MANAGER};\n        }\n\n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "80", "src_id": "M894", "code": "\n    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>)data;\n        Map<String, Object> properties = new HashMap <>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n\n        for(KeyValue propertyValue :list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n\n            if (value instanceof List) {\n                switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>)value;\n                    Map<String, List<Object>> rulesValueMap = new HashMap <>(rulesDataList.size(), 1f);\n                    rules = new HashMap <>(rulesDataList.size());\n                    for(KeyValue rkv :rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n\n                    value = rulesValueMap;\n                    break;\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>)value;\n                    List<Map<String, Object>> chunksValueList = new ArrayList <>(chunksDataList.size());\n                    chunks = new ArrayList <>(chunksDataList.size());\n                    for(List<KeyValue> chunkDataAsList :chunksDataList) {\n                        Map<String, Object> chunk = chunkDataAsList.stream() .collect(Collectors.toMap(kv->BuilderFactory.STRING.build(kv.getKey()), kv->BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n\n                    value = chunksValueList;\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n                }\n            } else\nif (value instanceof byte[]) {\n    value = BuilderFactory.STRING.build(value);\n    if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n        try {\n            value = DuplicatePolicy.valueOf(((String)value) .toUpperCase());\n        } catch (Exception e) {\n        }\n    }\n}\n\n            properties.put(prop, value);\n        }\n\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "81", "src_id": "M897", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n\n        if (ignore) {\n            args.add(IGNORE) .add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)->args.add(entry.getKey()) .add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "82", "src_id": "M1213", "code": "\n    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n\n        for(ConnectionPool pool :pools) {\n            Connection jedis = null;\n\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n\n                jedis.ping();\n                return jedis;\n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n\n        throw noReachableNode;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "83", "src_id": "M9", "code": "\n    @Override\n    public CacheEntry set(CacheKey cacheKey,CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n\n            for(Object redisKey :cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n\n            stats.load();\n            return entry;\n        } finally {\n                  lock.unlock();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "84", "src_id": "M1105", "code": "\n    @Override\n    public Class<?> build(Object data) {\n        if (data == null) return null;\n        String str = STRING.build(data);\n\n        switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \"+str);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "85", "src_id": "M1277", "code": "\n    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null\n            || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n\n            String str;\n            if (obj instanceof byte[]) {\n                str =\n                    SafeEncoder.encode((byte[]) obj);\n            } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                       redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                       str =\n                           geo.getLongitude() + \",\" + geo.getLatitude();\n                   } else if (obj instanceof String) {\n                              str =\n                                  stringEscape?escape((String) obj):\n                                  (String) obj;\n                          } else {\n                              str =\n                                  String.valueOf(obj);\n                          }\n\n            output.put(key, str);\n        }\n\n        return output;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "86", "src_id": "M902", "code": "\n    @Override public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION)\n            .add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING)\n            .add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE)\n            .add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY)\n            .add(duplicatePolicy);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff)\n            .add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet()\n            .forEach((entry) ->\n                args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "87", "src_id": "M1131", "code": "\n    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n    // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE: // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n      // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "88", "src_id": "M1057", "code": "\n    @Override public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null\n        || list.isEmpty()) return null;\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData =\n                            keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData =\n                            data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData =\n                            keyValue.getValue();\n                        break;\n                }\n            }\n            assert resultsData != null: \"Could not detect Results data.\";\n            assert profileData != null: \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData),\n                               ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue.of(resultsBuilder.build(list.get(0)),\n                           ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "89", "src_id": "M1229", "code": "\n    public SSLContext createSslContext()\n           throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode == SslVerifyMode.FULL) {\n            this\n.sslParameters\n.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } else if (sslVerifyMode == SslVerifyMode.CA) {\n                   this\n.sslParameters\n.setEndpointIdentificationAlgorithm(\"\");\n               } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                          trustManagers =\n                              new TrustManager [] {\n                                  INSECURE_TRUST_MANAGER };\n                      }\n\n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers =\n                keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers =\n                trustManagerFactory.getTrustManagers();\n        }\n\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "90", "src_id": "M894", "code": "\n    @Override public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap<>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            if (value instanceof List) {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels =\n                            BuilderFactory.STRING_MAP.build(value);\n                        value =\n                            labels;\n                        break;\n                    case RULES_PROPERTY:\n                        List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                        Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                        rules =\n                            new HashMap<>(rulesDataList.size());\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                        }\n\n                        value =\n                            rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                        List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                        chunks =\n                            new ArrayList<>(chunksDataList.size());\n                        for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv ->\n                                                                                             BuilderFactory.STRING.build(kv.getKey()), kv ->\n                                                                                                                                       BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n                            chunks.add(chunk);\n                        }\n\n                        value =\n                            chunksValueList;\n                        break;\n                    default:\n                        value =\n                            SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } else if (value instanceof byte[]) {\n                       value =\n                           BuilderFactory.STRING.build(value);\n                       if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                           try {\n                               value =\n                                   DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                           } catch (Exception e) {\n                           }\n                       }\n                   }\n\n            properties.put(prop, value);\n        }\n\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "91", "src_id": "M897", "code": "\n    @Override public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION)\n            .add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING)\n            .add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE)\n            .add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY)\n            .add(duplicatePolicy);\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY)\n            .add(duplicatePolicy);\n        }\n\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE)\n            .add(onDuplicate);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff)\n            .add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet()\n            .forEach((entry) ->\n                args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "92", "src_id": "M1213", "code": "\n    @Override public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis =\n                    pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n\n                jedis.ping();\n                return jedis;\n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed =\n                        ex;\n                }\n\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n\n        throw noReachableNode;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "93", "src_id": "M9", "code": "\n    @Override public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry =\n                putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey)\n                    .add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n\n            stats.load();\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "94", "src_id": "M1105", "code": "\n    @Override public Class<?> build(Object data) {\n        if (data == null) return null;\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "95", "src_id": "M270", "code": "\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64w?|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (\"ia64n\".equals(value)) {\n            return \"itanium_32\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(mips|mips32)$\")) {\n            return \"mips_32\";\n        }\n        if (value.matches(\"^(mipsel|mips32el)$\")) {\n            return \"mipsel_32\";\n        }\n        if (\"mips64\".equals(value)) {\n            return \"mips_64\";\n        }\n        if (\"mips64el\".equals(value)) {\n            return \"mipsel_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (value.matches(\"^(ppcle|ppc32le)$\")) {\n            return \"ppcle_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n        return value;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "96", "src_id": "M928", "code": "\n    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n        Map<String, Object> info = new HashMap<String, Object>();\n        info.put(LoggerHelper.name, logger.getName());\n        info.put(LoggerHelper.clazz, logger.getClass());\n\n\n        CodeSource codeSource = logger.getClass().getProtectionDomain()\n                                                 .getCodeSource();\n        if (codeSource != null) {\n            info.put(LoggerHelper.codeSource, codeSource.getLocation());\n        }\n        info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n\n        Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n        if (level != null) {\n            info.put(LoggerHelper.level, level.toString());\n        }\n        if (effectiveLevel != null) {\n            info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n        }\n        @ SuppressWarnings(\"unchecked\") List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n        info.put(LoggerHelper.appenders, result);\n        return info;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "97", "src_id": "M9", "code": "\n    @ SuppressWarnings(\"resource\")\n    public static long select(\nboolean v, long telnetPortPid, String select)\n    throws InputMismatchException {\n        Map<Long, String> processMap = listProcessByJps(v);\n        // Put the port that is already listening at the first\n        if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n            String telnetPortProcess = processMap.get(telnetPortPid);\n            processMap.remove(telnetPortPid);\n\n\n            Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n            newProcessMap.put(telnetPortPid, telnetPortProcess);\n            newProcessMap.putAll(processMap);\n            processMap = newProcessMap;\n        }\n        if (processMap.isEmpty()) {\n            AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n            return - 1;\n        }\n\n        // select target process by the '--select' option when match only one process\n        if (select != null && !select.trim().isEmpty()) {\n            int matchedSelectCount = 0;\n            Long matchedPid = null;\n            for (Entry<Long, String> entry : processMap.entrySet()) {\n                if (entry.getValue().contains(select)) {\n                    matchedSelectCount++;\n                    matchedPid = entry.getKey();\n                }\n            }\n            if (matchedSelectCount == 1) {\n                return matchedPid;\n            }\n        }\n        AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n        // print list\n\n        int count = 1;\n        for (String process : processMap.values()) {\n            if (count == 1) {\n                System.out.println(\"* [\" + count + \"]: \" + process);\n            } else {\n                System.out.println(\"  [\" + count + \"]: \" + process);\n            }\n            count++;\n        }\n\n        // read choice\n        String line = new Scanner(System.in).nextLine();\n        if (line.trim().isEmpty()) {\n            // get the first process id\n            return processMap.keySet().iterator()\n                                      .next();\n        }\n        int choice = new Scanner(line).nextInt();\n        if (choice <= 0 || choice > processMap.size()) {\n            return - 1;\n        }\n        Iterator<Long> idIter = processMap.keySet().iterator();\n        for(int i = 1;\n        i<=\n            choice;\n        ++ i) {\n            if (i == choice) {\n                return idIter.next();\n            }\n            idIter.next();\n        }\n        return - 1;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "98", "src_id": "M140", "code": "\n    void _processDo(int option)\n        throws IOException {\n        if (debugoptions) {\n            System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n        }\n        if (__notifhand != null) {\n            __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n        }\n        boolean acceptNewState = false;\n\n\n        /* open TelnetOptionHandler functionality (start)*/\n        if (optionHandlers[option] != null) {\n            acceptNewState = optionHandlers[option].getAcceptLocal();\n        } else {\n        /* open TelnetOptionHandler functionality (end)*/\n            /* TERMINAL-TYPE option (start)*/\n            if (option == TERMINAL_TYPE) {\n                if ((terminalType != null) && (terminalType.length()> 0)) {\n                    acceptNewState = true;\n                }\n            }\n            /* TERMINAL-TYPE option (end)*/\n        /* open TelnetOptionHandler functionality (start)*/\n        }\n        /* open TelnetOptionHandler functionality (end)*/\n        if (_willResponse[option]> 0) {\n            -- _willResponse[option];\n            if (_willResponse[option]> 0 && _stateIsWill(option)) {\n                -- _willResponse[option];\n            }\n        }\n        if (_willResponse[option] == 0) {\n            if (_requestedWont(option)) {\n                switch (option) {\n                    default:\n                        break;\n                }\n                if (acceptNewState) {\n                    _setWantWill(option);\n                    _sendWill(option);\n                } else {\n                    ++ _willResponse[option];\n                    _sendWont(option);\n                }\n            } else {\n                // Other end has acknowledged option.\n                switch (option) {\n                    default:\n                        break;\n                }\n            }\n        }\n        _setWill(option);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "99", "src_id": "M1324", "code": "\n    private void bind(Configure configure)\n        throws Throwable {\n        long start = System.currentTimeMillis();\n        if (!isBindRef.compareAndSet(false, true)) {\n            throw new IllegalStateException(\"already bind\");\n        }\n\n        // init random port\n        if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n            int newTelnetPort = SocketUtils.findAvailableTcpPort();\n            configure.setTelnetPort(newTelnetPort);\n            logger().info(\"generate random telnet port: \" + newTelnetPort);\n        }\n        if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n            int newHttpPort = SocketUtils.findAvailableTcpPort();\n            configure.setHttpPort(newHttpPort);\n            logger().info(\"generate random http port: \" + newHttpPort);\n        }\n        // try to find appName\n        if (configure.getAppName() == null) {\n            configure.setAppName(System.getProperty(\n                ArthasConstants.PROJECT_NAME,\n                System.getProperty(\n                    ArthasConstants.SPRING_APPLICATION_NAME, null)));\n        }\n        try {\n            if (configure.getTunnelServer() != null) {\n                tunnelClient =\n                    new TunnelClient();\n                tunnelClient.setAppName(configure.getAppName());\n                tunnelClient.setId(configure.getAgentId());\n                tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n                tunnelClient.setVersion(ArthasBanner.version());\n\n\n                ChannelFuture channelFuture = tunnelClient.start();\n                channelFuture.await(10, TimeUnit.SECONDS);\n            }\n        } catch (Throwable t) {\n            logger().error(\"start tunnel client error\", t);\n        }\n        try {\n            ShellServerOptions options = new ShellServerOptions().setInstrumentation(instrumentation)\n                                                                 .setPid(PidUtils.currentLongPid())\n                                                                 .setWelcomeMessage(ArthasBanner.welcome());\n            if (configure.getSessionTimeout() != null) {\n                options.setSessionTimeout(configure.getSessionTimeout()* 1000);\n            }\n            this.httpSessionManager =\n                new HttpSessionManager();\n            if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n                // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n                String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \" + \"No password is currently configured. \" + \"Therefore, a default password is generated, \" + \"and clients need to use the password to connect!\";\n                AnsiLog.error(errorMsg);\n                configure.setPassword(StringUtils.randomString(64));\n                AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n                logger().error(errorMsg);\n                logger().info(\"Generated arthas password: \" + configure.getPassword());\n            }\n            this.securityAuthenticator =\n                new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n            shellServer =\n                new ShellServerImpl(options);\n\n\n            List<String> disabledCommands = new ArrayList<String>();\n            if (configure.getDisabledCommands() != null) {\n                String[] strings = StringUtils.tokenizeToStringArray(\n                    configure.getDisabledCommands(), \",\");\n                if (strings != null) {\n                    disabledCommands.addAll(Arrays.asList(strings));\n                }\n            }\n            BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n            List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n            resolvers.add(builtinCommands);\n\n            //worker group\n            workerGroup =\n                new NioEventLoopGroup(new DefaultThreadFactory(\n                                              \"arthas-TermServer\", true));\n\n            // TODO: discover user provided command resolver\n            if (configure.getTelnetPort() != null && configure.getTelnetPort()> 0) {\n                logger().info(\n                             \"try to bind telnet server, host: {}, port: {}.\",\n                             configure.getIp(),\n                             configure.getTelnetPort());\n                shellServer.registerTermServer(new HttpTelnetTermServer(\n                                                       configure.getIp(),\n                                                       configure.getTelnetPort(),\n                                                       options.getConnectionTimeout(),\n                                                       workerGroup,\n                                                       httpSessionManager));\n            } else {\n                logger().info(\n                             \"telnet port is {}, skip bind telnet server.\",\n                             configure.getTelnetPort());\n            }\n            if (configure.getHttpPort() != null && configure.getHttpPort()> 0) {\n                logger().info(\n                             \"try to bind http server, host: {}, port: {}.\",\n                             configure.getIp(),\n                             configure.getHttpPort());\n                shellServer.registerTermServer(new HttpTermServer(\n                                                       configure.getIp(),\n                                                       configure.getHttpPort(),\n                                                       options.getConnectionTimeout(),\n                                                       workerGroup,\n                                                       httpSessionManager));\n            } else {\n                // listen local address in VM communication\n                if (configure.getTunnelServer() != null) {\n                    shellServer.registerTermServer(new HttpTermServer(\n                                                           configure.getIp(),\n                                                           configure.getHttpPort(),\n                                                           options.getConnectionTimeout(),\n                                                           workerGroup,\n                                                           httpSessionManager));\n                }\n                logger().info(\n                             \"http port is {}, skip bind http server.\",\n                             configure.getHttpPort());\n            }\n            for (CommandResolver resolver : resolvers) {\n                shellServer.registerCommandResolver(resolver);\n            }\n            shellServer.listen(new BindHandler(isBindRef));\n            if (!isBind()) {\n                throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" + String.valueOf(configure.getTelnetPort()) + \", http port: \" + String.valueOf(configure.getHttpPort()));\n            }\n\n            //http api session manager\n            sessionManager =\n                new SessionManagerImpl(\n                        options,\n                        shellServer.getCommandManager(),\n                        shellServer.getJobController());\n            //http api handler\n            httpApiHandler =\n                new HttpApiHandler(historyManager, sessionManager);\n            logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n            // 异步回报启动次数\n            if (configure.getStatUrl() != null) {\n                logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n            }\n            UserStatUtil.setStatUrl(configure.getStatUrl());\n            UserStatUtil.setAgentId(configure.getAgentId());\n            UserStatUtil.arthasStart();\n            try {\n                SpyAPI.init();\n            } catch (Throwable e) {\n                // ignore\n            }\n            logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n        } catch (Throwable e) {\n            logger().error(\"Error during start as-server\", e);\n            destroy();\n            throw e;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "100", "src_id": "M122", "code": "\n    private int __read(boolean mayBlock)\n        throws IOException {\n        int ch;\n        while(true) {\n\n            // If there is no more data AND we were told not to block,\n            // just return WOULD_BLOCK (-2). (More efficient than exception.)\n            if (!mayBlock && super.available() == 0) {\n                return WOULD_BLOCK;\n            }\n\n            // Otherwise, exit only when we reach end of stream.\n            if ((ch = super.read()) < 0) {\n                return EOF;\n            }\n            ch = (ch& 0xff);\n\n            /* Code Section added for supporting AYT (start)*/\n            synchronized(__client) {\n                                   __client._processAYTResponse();\n            }\n            /* Code Section added for supporting AYT (end)*/\n\n            /* Code Section added for supporting spystreams (start)*/\n            __client._spyRead(ch);\n            /* Code Section added for supporting spystreams (end)*/\n            switch (__receiveState) {\n                case _STATE_CR:\n                    if (ch == '\\0') {\n                    // Strip null\n                        continue;\n                    }\n                // How do we handle newline after cr?\n                //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n\n                // Handle as normal data by falling through to _STATE_DATA case\n\n                //$FALL-THROUGH$\n                case _STATE_DATA:\n                    if (ch == TelnetCommand.IAC) {\n                        __receiveState = _STATE_IAC;\n                        continue;\n                    }\n                    if (ch == '\\r') {\n                        synchronized(__client) {\n                                               if (__client._requestedDont(TelnetOption.BINARY)) {\n                                                   __receiveState = _STATE_CR;\n                                               } else {\n                                                   __receiveState = _STATE_DATA;\n                                               }\n                        }\n                    } else {\n                        __receiveState = _STATE_DATA;\n                    }\n                    break;\n                case _STATE_IAC:\n                    switch (ch) {\n                        case TelnetCommand.WILL:\n                            __receiveState = _STATE_WILL;\n                            continue;\n                        case TelnetCommand.WONT:\n                            __receiveState = _STATE_WONT;\n                            continue;\n                        case TelnetCommand.DO:\n                            __receiveState = _STATE_DO;\n                            continue;\n                        case TelnetCommand.DONT:\n                            __receiveState = _STATE_DONT;\n                            continue;\n                /* TERMINAL-TYPE option (start)*/\n                        case TelnetCommand.SB:\n                            __suboption_count = 0;\n                            __receiveState = _STATE_SB;\n                            continue;\n                /* TERMINAL-TYPE option (end)*/\n                        case TelnetCommand.IAC:\n                            __receiveState = _STATE_DATA;\n                            break; // exit to enclosing switch to return IAC from read\n                        case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)\n                            __receiveState = _STATE_DATA;\n                            continue;\n                        default:\n                            __receiveState = _STATE_DATA;\n                            __client._processCommand(ch); // Notify the user\n                            continue; // move on the next char\n                    }\n                    break; // exit and return from read\n                case _STATE_WILL:\n                    synchronized(__client) {\n                                           __client._processWill(ch);\n                                           __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n                case _STATE_WONT:\n                    synchronized(__client) {\n                                           __client._processWont(ch);\n                                           __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n                case _STATE_DO:\n                    synchronized(__client) {\n                                           __client._processDo(ch);\n                                           __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n                case _STATE_DONT:\n                    synchronized(__client) {\n                                           __client._processDont(ch);\n                                           __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n            /* TERMINAL-TYPE option (start)*/\n                case _STATE_SB:\n                    switch (ch) {\n                        case TelnetCommand.IAC:\n                            __receiveState = _STATE_IAC_SB;\n                            continue;\n                        default:\n                    // store suboption char\n                            if (__suboption_count < __suboption.length) {\n                                __suboption[__suboption_count ++] = ch;\n                            }\n                            break;\n                    }\n                    __receiveState = _STATE_SB;\n                    continue;\n                case _STATE_IAC_SB: // IAC received during SB phase\n                    switch (ch) {\n                        case TelnetCommand.SE:\n                            synchronized(__client) {\n                                                   __client._processSuboption(__suboption, __suboption_count);\n                                                   __client._flushOutputStream();\n                            }\n                            __receiveState = _STATE_DATA;\n                            continue;\n                        case TelnetCommand.IAC: // De-dup the duplicated IAC\n                            if (__suboption_count < __suboption.length) {\n                                __suboption[__suboption_count ++] = ch;\n                            }\n                            break;\n                        default:            // unexpected byte! ignore it\n                            break;\n                    }\n                    __receiveState = _STATE_SB;\n                    continue;\n            /* TERMINAL-TYPE option (end)*/\n            }\n            break;\n        }\n        return ch;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "101", "src_id": "M8", "code": "\n    private static String formatFileSize(long size) {\n        String hrSize;\n        double b = size;\n        double k = size/ 1024.0;\n        double m = ((size/ 1024.0)/ 1024.0);\n        double g = (((size/ 1024.0)/ 1024.0)/ 1024.0);\n        double t = ((((size/ 1024.0)/ 1024.0)/ 1024.0)/ 1024.0);\n        DecimalFormat dec = new DecimalFormat(\"0.00\");\n        if (t > 1) {\n            hrSize = dec.format(t).concat(\" TB\");\n        } else if (g > 1) {\n                   hrSize = dec.format(g).concat(\" GB\");\n               } else if (m > 1) {\n                          hrSize = dec.format(m).concat(\" MB\");\n                      } else if (k > 1) {\n                                 hrSize = dec.format(k).concat(\" KB\");\n                             } else {\n                                 hrSize = dec.format(b).concat(\" Bytes\");\n                      }\n        return hrSize;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "102", "src_id": "M790", "code": "\n    @Override\n    public byte[] transform(\nClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer)\n    throws IllegalClassFormatException {\n        if (className == null) {\n            return null;\n        }\n        className = className.replace('/', '.');\n\n\n        List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n            // 倒序，因为要执行的配置生效\n        ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n        while(listIterator.hasPrevious()) {\n            RetransformEntry retransformEntry = listIterator.previous();\n            int id = retransformEntry.getId();\n                // 判断类名是否一致\n            boolean updateFlag = false;\n                // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n            if (className.equals(retransformEntry.getClassName())) {\n                if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) {\n                    updateFlag = isLoaderMatch(retransformEntry, loader);\n                } else {\n                    updateFlag = true;\n                }\n            }\n            if (updateFlag) {\n                logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n                retransformEntry.incTransformCount();\n                return retransformEntry.getBytes();\n            }\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "103", "src_id": "M716", "code": "\n    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n        // 执行失败:输出失败状态\n        table.row(\"IS-RETURN\", \"\" + false);\n        table.row(\"IS-EXCEPTION\", \"\" + true);\n\n        // 执行失败:输出失败异常信息\n\n\n        Throwable cause;\n        Throwable t = (Throwable) throwableVO.getObject();\n        if (t instanceof\n            InvocationTargetException) {\n            cause = t.getCause();\n        } else {\n            cause = t;\n        }\n        if (throwableVO.needExpand()) {\n            table.row(\n                      \"THROW-EXCEPTION\",\n                      new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n        } else {\n            StringWriter stringWriter = new StringWriter();\n            PrintWriter printWriter = new PrintWriter(stringWriter);\n            try {\n                cause.printStackTrace(printWriter);\n                table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n            } finally {\n                printWriter.close();\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "104", "src_id": "M602", "code": "\n    private AsyncProfiler profilerInstance() {\n        if (profiler != null) {\n            return profiler;\n        }\n\n        // try to load from special path\n        if (ProfilerAction.load.toString().equals(action)) {\n            profiler = AsyncProfiler.getInstance(this.actionArg);\n        }\n        if (libPath != null) {\n            // load from arthas directory\n            // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n            FileOutputStream tmpLibOutputStream = null;\n            FileInputStream libInputStream = null;\n            try {\n                File tmpLibFile = File.createTempFile(\n                    VmTool.JNI_LIBRARY_NAME, null);\n                tmpLibOutputStream =\n                    new FileOutputStream(tmpLibFile);\n                libInputStream =\n                    new FileInputStream(libPath);\n                IOUtils.copy(libInputStream, tmpLibOutputStream);\n                libPath = tmpLibFile.getAbsolutePath();\n                logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n            } catch (Throwable e) {\n                logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n            } finally {\n                IOUtils.close(libInputStream);\n                IOUtils.close(tmpLibOutputStream);\n            }\n            profiler = AsyncProfiler.getInstance(libPath);\n        } else {\n            if (OSUtils.isLinux() || OSUtils.isMac()) {\n                throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n            } else {\n                throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n            }\n        }\n        return profiler;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "105", "src_id": "M1277", "code": "\n    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null|| obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n            if (obj instanceof byte[]) {\n                str = SafeEncoder.encode((byte[]) obj);\n            } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                       redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                       str = geo.getLongitude() + \",\" + geo.getLatitude();\n            } else if (obj instanceof String) {\n                       str = stringEscape ? escape((String) obj) : (String) obj;\n                   } else {\n                       str = String.valueOf(obj);\n                   }\n            output.put(key, str);\n        }\n        return output;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "106", "src_id": "M902", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)-> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "107", "src_id": "M1131", "code": "\n    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n    // System.out.println(\"BYTE: \" + (char) b);\n        switch(b) {\n            case PLUS_BYTE:\n            return is.readLineBytes();\n                  case DOLLAR_BYTE: case EQUAL_BYTE:\n            return processBulkReply(is);\n                  case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n                  case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n                  case HASH_BYTE:\n            return is.readBooleanCrLf();\n                  case COLON_BYTE:\n            return is.readLongCrLf();\n                  case COMMA_BYTE:\n            return is.readDoubleCrLf();\n                  case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n                  case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n            return processMapKeyValueReply(is);\n                  case TILDE_BYTE: // TODO:\n            return processMultiBulkReply(is);\n                  case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n                  case MINUS_BYTE:\n            processError(is);\n            return null;\n      // TODO: Blob error '!'\n                  default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "108", "src_id": "M1057", "code": "\n    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null|| list.isEmpty()) return null;\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch(keyStr) {\n                    case PROFILE_STR_REDIS7: case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                               case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                               case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n                }\n            }\n            assert resultsData != null: \"Could not detect Results data.\";\n            assert profileData != null: \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "109", "src_id": "M1229", "code": "\n    public SSLContext createSslContext()throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode == SslVerifyMode.FULL) {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } else if (sslVerifyMode == SslVerifyMode.CA) {\n                   this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n        } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                   trustManagers = new TrustManager[] {\n                                       INSECURE_TRUST_MANAGER };\n               }\n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "110", "src_id": "M894", "code": "\n    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap<>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            if (value instanceof List) {\n                switch(prop) {\n                    case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                             case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rulesValueMap;\n                    break;\n                             case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv-> BuilderFactory.STRING.build(kv.getKey()), kv-> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n                    value = chunksValueList;\n                    break;\n                             default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n                }\n            } else if (value instanceof byte[]) {\n                       value = BuilderFactory.STRING.build(value);\n                       if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                           try {\n                               value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                           } catch (Exception e) {\n                           }\n                       }\n                   }\n            properties.put(prop, value);\n        }\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "111", "src_id": "M897", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)-> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "112", "src_id": "M1213", "code": "\n    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n                jedis.ping();\n                return jedis;\n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "113", "src_id": "M9", "code": "\n    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n            stats.load();\n            return entry;\n        }\nfinally {\n            lock.unlock();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1105", "code": "\n    @Override\n    public Class<?> build(Object data) {\n        if (data == null) return null;\n        String str = STRING.build(data);\n        switch(str) {\n            case \"null\":\n            return null;\n                    case \"boolean\":\n            return boolean.class;\n                    case \"integer\":\n            return int.class;\n                    case \"number\":\n            return float.class;\n                    case \"string\":\n            return String.class;\n                    case \"object\":\n            return Object.class;\n                    case \"array\":\n            return List.class;\n                    default:\n            throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "115", "src_id": "M1277", "code": "\n    public static Map<String, String> toStringMap(Map<String, Object> input , boolean stringEscape) {\n        Map<String, String> output = new HashMap< >(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null|| obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n\n            String str;\n            if (obj instanceof byte[]) {\n                str = SafeEncoder.encode((byte[]) obj);\n            } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                str = geo.getLongitude() + \",\" + geo.getLatitude();\n            } else if (obj instanceof String) {\n                       str = stringEscape ? escape((String) obj): (String) obj;\n                   } else {\n                       str = String.valueOf(obj);\n                   }\n\n            output.put(key, str);\n        }\n        return output;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "116", "src_id": "M902", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)-> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1131", "code": "\n    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n    // System.out.println(\"BYTE: \" + (char) b);\n        switch(b) {\n                  case PLUS_BYTE:\n                  return is.readLineBytes();\n                  case DOLLAR_BYTE: case EQUAL_BYTE:\n                  return processBulkReply(is);\n                  case ASTERISK_BYTE:\n                  return processMultiBulkReply(is);\n                  case UNDERSCORE_BYTE:\n                  return is.readNullCrLf();\n                  case HASH_BYTE:\n                  return is.readBooleanCrLf();\n                  case COLON_BYTE:\n                  return is.readLongCrLf();\n                  case COMMA_BYTE:\n                  return is.readDoubleCrLf();\n                  case LEFT_BRACE_BYTE:\n                  return is.readBigIntegerCrLf();\n                  case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n                  return processMapKeyValueReply(is);\n                  case TILDE_BYTE: // TODO:\n                  return processMultiBulkReply(is);\n                  case GREATER_THAN_BYTE:\n                  return processMultiBulkReply(is);\n                  case MINUS_BYTE:\n                  processError(is);\n                  return null;\n      // TODO: Blob error '!'\n                  default:\n                  throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1057", "code": "\n    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null|| list.isEmpty()) return null;\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch(keyStr) {\n                               case PROFILE_STR_REDIS7: case PROFILE_STR_REDIS8:\n                               profileData = keyValue.getValue();\n                               break;\n                               case RESULTS_STR_REDIS7:\n                               resultsData = data;\n                               break;\n                               case RESULTS_STR_REDIS8:\n                               resultsData = keyValue.getValue();\n                               break;\n                }\n            }\n            assert resultsData != null: \"Could not detect Results data.\";\n            assert profileData != null: \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1229", "code": "\n    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode == SslVerifyMode.FULL) {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } else if (sslVerifyMode == SslVerifyMode.CA) {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n        } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                   trustManagers = new TrustManager[] {\n                                                      INSECURE_TRUST_MANAGER};\n               }\n\n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "120", "src_id": "M894", "code": "\n    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap< >();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            if (value instanceof List) {\n                switch(prop) {\n                             case LABELS_PROPERTY:\n                             labels = BuilderFactory.STRING_MAP.build(value);\n                             value = labels;\n                             break;\n                             case RULES_PROPERTY:\n                             List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                             Map<String, List<Object>> rulesValueMap = new HashMap< >(rulesDataList.size(), 1f);\n                             rules = new HashMap< >(rulesDataList.size());\n                             for (KeyValue rkv : rulesDataList) {\n                                 String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                                 List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                                 rulesValueMap.put(ruleName, ruleValueList);\n                                 rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                             }\n\n                             value = rulesValueMap;\n                             break;\n                             case CHUNKS_PROPERTY:\n                             List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                             List<Map<String, Object>> chunksValueList = new ArrayList< >(chunksDataList.size());\n                             chunks = new ArrayList< >(chunksDataList.size());\n                             for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                                 Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                                 chunksValueList.add(chunk);\n                                 chunks.add(chunk);\n                             }\n\n                             value = chunksValueList;\n                             break;\n                             default:\n                             value = SafeEncoder.encodeObject(value);\n                             break;\n                }\n            } else if (value instanceof byte[]) {\n                       value = BuilderFactory.STRING.build(value);\n                       if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                           try {\n                               value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                           } catch (Exception e) {\n\n                           }\n                       }\n                   }\n\n            properties.put(prop, value);\n        }\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "121", "src_id": "M897", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)-> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "122", "src_id": "M1213", "code": "\n    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n\n                jedis.ping();\n                return jedis;\n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "123", "src_id": "M9", "code": "\n    @Override\n    public CacheEntry set(CacheKey cacheKey , CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n\n            stats.load();\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "124", "src_id": "M1105", "code": "\n    @Override\n    public Class<?> build(Object data) {\n        if (data == null) return null;\n        String str = STRING.build(data);\n        switch(str) {\n                    case \"null\":\n                    return null;\n                    case \"boolean\":\n                    return boolean.class;\n                    case \"integer\":\n                    return int.class;\n                    case \"number\":\n                    return float.class;\n                    case \"string\":\n                    return String.class;\n                    case \"object\":\n                    return Object.class;\n                    case \"array\":\n                    return List.class;\n                    default:\n                    throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "125", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte [] emlBytes , EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ?\n                           textBody: \"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null&& request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if (request != null&& request.isIncludeAttachments()) {\n                                                                      html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                                                                      html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                                                                      html.append(\"</div>\\n\");\n                                                                  } else {\n                                                                             html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                                                                             html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                                                                             html.append(\"</div>\\n\");\n                                                                         }\n\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status if requested\n\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "126", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n        try\n        {\n            // Check if the object implements jakarta.mail.Multipart interface\n        Class < ?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n        if (!multipartInterface.isInstance(multipart)) {\n            return false;\n        }\n\n            // Additional check for MimeMultipart\n\n        try\n        {\n        Class < ?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n        if (mimeMultipartClass.isInstance(multipart)) {\n            log.debug(\"Found MimeMultipart instance for enhanced processing\");\n            return true;\n        }\n        } catch (ClassNotFoundException e)\n        {\n            log.debug(\"MimeMultipart not available, using base Multipart interface\");\n        }\n\n        return true;\n        } catch (ClassNotFoundException e)\n        {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "127", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent , String headerName) {\n        try\n        {\n            String [] lines = emlContent.split(\"\\r?\\n\");\n            for(int i = 0; i < lines.length;\ni++) {\n                String line = lines [ i ];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for(int j = i + 1; j < lines.length;\nj++) {\n                        if (lines [ j ].startsWith(\" \")|| lines [ j ].startsWith(\"\\t\")) {\n                                                                                            value.append(\" \").append(lines [ j ].trim());\n                                                                                            } else {\n                                                                                                       break;\n                                                                                                   }\n                    }\n                    // Apply MIME header decoding\n\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim().isEmpty()) break;\n            }\n        } catch (RuntimeException e)\n        {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n\n        return \"\";\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "128", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(PDDocument document , List < EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n\n        // 1. Find the screen position of all attachment markers\n\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true); // Process pages in order\n        finder.getText(document);\n        List < MarkerPosition> markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for(int i = 0; i < annotationsToAdd;\ni++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage( document, page, attachment, position.getX(), position.getY() );\n            }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "129", "src_id": "M31", "code": "\n    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws\n        Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")\n                        // .header(\"Authorization\", \"License \" + licenseKey).POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n        HttpResponse <String > response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n\n        if (response.statusCode() == 200) {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Also check the policy for floating license support if included\n\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n                // Policy takes precedence over license attributes\n\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Extract user count, default to 1 if not specified\n\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } else {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n\n        return jsonResponse;\n    }\n\n", "compilable": false, "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "130", "src_id": "M488", "code": "\n    @ PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\") @Operation(summary = \"Convert a file to a PDF using LibreOffice\", description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\") public ResponseEntity < byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws\n        Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        }\n\n        finally {\n            if (file != null)\n                file.delete();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "131", "src_id": "M625", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "132", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n\n            byte [] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes );\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload );\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            // Verify license file algorithm\n\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            // Verify signature\n\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n\n            log.info(\"License file signature is valid\");\n\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            // Process the certificate data\n\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "133", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws\n        IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager )) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while(entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "134", "src_id": "M317", "code": "\n    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws\n        IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth() );\n        }\n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight() );\n        }\n\n        PDPage page = new PDPage(pageSize );\n        doc.addPage(page);\n\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true )) {\n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                       float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                       float pageAspectRatio = pageWidth / pageHeight;\n                       float scaleFactor = 1.0f;\n\n                       if (imageAspectRatio > pageAspectRatio) {\n                           scaleFactor = pageWidth / image.getWidth();\n                       } else {\n                           scaleFactor = pageHeight / image.getHeight();\n                       }\n\n                       float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                       float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                       contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n                   }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "135", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n            if (network == null) {\n                Enumeration <NetworkInterface > networks = NetworkInterface.getNetworkInterfaces();\n                while(networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte [] mac = net.getHardwareAddress();\n\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } else {\n                byte [] mac = network.getHardwareAddress();\n\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                }\n            }\n\n            // Hash the MAC address for privacy and consistency\n\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte [] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "136", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "137", "src_id": "M128", "code": "\n    @ Bean(name = \"machineType\" ) public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            } else if (isDocker) {\n                       return \"Docker\";\n            } else if (isBrowserOpen) {\n                       String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n\n                       if (os.contains(\"win\")) {\n                           return \"Client-windows\";\n                       } else if (os.contains(\"mac\")) {\n                                  return \"Client-mac\";\n                       } else {\n                                  return \"Client-unix\";\n                       }\n                   } else {\n                       return \"Server-jar\";\n                   }\n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "138", "src_id": "M101", "code": "\n    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k->\n                                createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "139", "src_id": "M475", "code": "\n    @Override public void draw(CommandProcess process, JvmModel result) {\n        TableElement table = new TableElement(2, 5).leftCellPadding(1)\n                                                   .rightCellPadding(1);\n        for(Map.Entry<String, List<JvmItemVO>> entry :result.getJvmInfo().entrySet()) {\n            String group = entry.getKey();\n            List<JvmItemVO> items = entry.getValue();\n            table.row(true, label(group).style(Decoration.bold.bold()));\n            for(JvmItemVO item :items) {\n                String valueStr;\n                if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                    valueStr =\n                        renderMemoryUsage((Map<String, Object>) item.getValue());\n                } else {\n                    valueStr =\n                        renderItemValue(item.getValue());\n                }\n\n                if (item.getDesc() != null) {\n                    table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n                } else {\n                    table.row(item.getName(), valueStr);\n                }\n            }\n\n            table.row(\"\", \"\");\n        }\n\n        process.write(RenderUtil.render(table, process.width()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "140", "src_id": "M535", "code": "\n    public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n        final StringBuilder infoSB = new StringBuilder();\n        List<String> classDumpFiles = affectVO.getClassDumpFiles();\n        if (classDumpFiles != null) {\n            for(String classDumpFile :classDumpFiles) {\n                infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n            }\n        }\n\n\n        List<String> methods = affectVO.getMethods();\n        if (methods != null) {\n            for(String method :methods) {\n                infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n            }\n        }\n\n        infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\", affectVO.getClassCount(), affectVO.getMethodCount(), affectVO.getCost(), affectVO.getListenerId()));\n        if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n            infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n        }\n\n        if (affectVO.getThrowable() != null) {\n            infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n        }\n\n        infoSB.append(\"\\n\");\n        return infoSB.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "141", "src_id": "M753", "code": "\n    public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n        List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n\n        // Sample CPU\n        if (lastCpuTimes.isEmpty()) {\n            lastSampleTimeNanos =\n                System.nanoTime();\n            for(ThreadVO thread :threads) {\n                if (thread.getId() > 0) {\n                    long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                    lastCpuTimes.put(thread, cpu);\n                    thread.setTime(cpu / 1000000);\n                }\n            }\n\n            // add internal threads\n\n\n            Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n            if (internalThreadCpuTimes != null) {\n                for(Map.Entry<String, Long> entry :internalThreadCpuTimes.entrySet()) {\n                    String key = entry.getKey();\n                    ThreadVO thread = createThreadVO(key);\n                    thread.setTime(entry.getValue() / 1000000);\n                    threads.add(thread);\n                    lastCpuTimes.put(thread, entry.getValue());\n                }\n            }\n\n            //sort by time\n\n            Collections.sort(threads, new Comparator<ThreadVO>() {\n                                          @Override public int compare(ThreadVO o1, ThreadVO o2) {\n                                              long l1 = o1.getTime();\n                                              long l2 = o2.getTime();\n                                              if (l1< l2) {\n                                                  return 1;\n                                              } else if (l1 > l2) {\n                                                         return -1;\n                                              } else {\n                                                         return 0;\n                                              }\n                                          }\n\n                                      });\n            return threads;\n        }\n\n        // Resample\n\n\n        long newSampleTimeNanos = System.nanoTime();\n        Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n        for(ThreadVO thread :threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                newCpuTimes.put(thread, cpu);\n            }\n        }\n        // internal threads\n\n\n        Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (newInternalThreadCpuTimes != null) {\n            for(Map.Entry<String, Long> entry :newInternalThreadCpuTimes.entrySet()) {\n                ThreadVO threadVO = createThreadVO(entry.getKey());\n                threads.add(threadVO);\n                newCpuTimes.put(threadVO, entry.getValue());\n            }\n        }\n\n        // Compute delta time\n\n\n        final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n        for(ThreadVO thread :newCpuTimes.keySet()) {\n            Long t = lastCpuTimes.get(thread);\n            if (t == null) {\n                t =\n                    0L;\n            }\n\n\n            long time1 = t;\n            long time2 = newCpuTimes.get(thread);\n            if (time1 == -1) {\n                time1 =\n                    time2;\n            } else if (time2 == -1) {\n                       time2 =\n                           time1;\n                   }\n\n\n            long delta = time2 - time1;\n            deltas.put(thread, delta);\n        }\n\n\n        long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n\n        // Compute cpu usage\n        final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n        for(ThreadVO thread :threads) {\n            double cpu = sampleIntervalNanos == 0?0:\n                (Math.rint(deltas.get(thread)* 10000.0/ sampleIntervalNanos) / 100.0);\n            cpuUsages.put(thread, cpu);\n        }\n\n        // Sort by CPU time : should be a rendering hint...\n\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n                                      @Override public int compare(ThreadVO o1, ThreadVO o2) {\n                                          long l1 = deltas.get(o1);\n                                          long l2 = deltas.get(o2);\n                                          if (l1< l2) {\n                                              return 1;\n                                          } else if (l1 > l2) {\n                                                     return -1;\n                                          } else {\n                                                     return 0;\n                                          }\n                                      }\n\n                                  });\n        for(ThreadVO thread :threads) {\n            //nanos to mills\n            long timeMills = newCpuTimes.get(thread) / 1000000;\n            long deltaTime = deltas.get(thread) / 1000000;\n            double cpu = cpuUsages.get(thread);\n            thread.setCpu(cpu);\n            thread.setTime(timeMills);\n            thread.setDeltaTime(deltaTime);\n        }\n\n        lastCpuTimes =\n            newCpuTimes;\n        lastSampleTimeNanos =\n            newSampleTimeNanos;\n        return threads;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "142", "src_id": "M1131", "code": "\n    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<String, Object>();\n        body.put(\"command\", commandLine);\n        ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n\n\n        int lock = session.getLock();\n        try {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n\n            //create job\n\n\n            Job job = this.createJob(commandLine, session, session.getResultDistributor());\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            response.setState(ApiState.SCHEDULED);\n\n            //add command before exec job\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n            commandRequestModel.setJobId(job.id());\n            SharingResultDistributor resultDistributor = session.getResultDistributor();\n            if (resultDistributor != null) {\n                resultDistributor.appendResult(commandRequestModel);\n            }\n\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n            //run job\n            job.run();\n            return response;\n        } catch (Throwable e) {\n            logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n            session.getResultDistributor().appendResult(commandRequestModel);\n            return response;\n        } finally {\n                  if (session.getLock() == lock) {\n                      session.unLock();\n                  }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "143", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n        for(Map.Entry<String, Map<String, Object>> entry :loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n            TableElement table = new TableElement(2, 10).leftCellPadding(1)\n                                                        .rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name))).row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                     label(\"\" + info.get(LoggerHelper.classLoader)))\n                         .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                              label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(\n                          label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                          label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                      label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                                                                         label(\"\" + info.get(LoggerHelper.codeSource)));\n\n\n            @ SuppressWarnings(\"unchecked\" ) List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for(Map<String, Object> appenderInfo :appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n\n        return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "144", "src_id": "M15", "code": "\n    public static int startArthasClient(\nString arthasHomeDir, List<String> telnetArgs, OutputStream out)\n                  throws Throwable {\n        // start java telnet client\n        // find arthas-client.jar\n        URLClassLoader classLoader = new URLClassLoader(new URL [] {\n            new File(arthasHomeDir, \"arthas-client.jar\").toURI()\n                                                        .toURL()});\n        Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n        Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n\n        //redirect System.out/System.err\n        PrintStream originSysOut = System.out;\n        PrintStream originSysErr = System.err;\n        PrintStream newOut = new PrintStream(out);\n        PrintStream newErr = new PrintStream(out);\n\n        // call TelnetConsole.process()\n        // fix https://github.com/alibaba/arthas/issues/833\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            System.setOut(newOut);\n            System.setErr(newErr);\n            Thread.currentThread().setContextClassLoader(classLoader);\n            return (Integer) processMethod.invoke(null, new Object [] {\n                telnetArgs.toArray(new String [0])});\n        } catch (Throwable e) {\n            //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n            e =\n                e.getCause();\n            if (e instanceof IOException || e instanceof InterruptedException) {\n                // ignore connection error and interrupted error\n                return STATUS_ERROR;\n            } else {\n                // process error\n                AnsiLog.error(\"process error: {}\", e.toString());\n                AnsiLog.error(e);\n                return STATUS_EXEC_ERROR;\n            }\n        } finally {\n                  Thread.currentThread().setContextClassLoader(tccl);\n\n            //reset System.out/System.err\n                  System.setOut(originSysOut);\n                  System.setErr(originSysErr);\n            //flush output\n                  newOut.flush();\n                  newErr.flush();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "145", "src_id": "M1469", "code": "\n    public static FieldVO[] getFields(Class clazz, Integer expand) {\n        Field[] fields = clazz.getDeclaredFields();\n        if (fields.length == 0) {\n            return new FieldVO [0];\n        }\n\n\n        List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n        for(Field field :fields) {\n            FieldVO fieldVO = new FieldVO();\n            fieldVO.setName(field.getName());\n            fieldVO.setType(StringUtils.classname(field.getType()));\n            fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n            fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n            if (Modifier.isStatic(field.getModifiers())) {\n                fieldVO.setStatic(true);\n                fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n            } else {\n                fieldVO.setStatic(false);\n            }\n\n            list.add(fieldVO);\n        }\n\n        return list.toArray(new FieldVO [0]);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "146", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte [] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null\n                || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ?textBody : \"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status if requested\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "147", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n        try {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n\n            // Additional check for MimeMultipart\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            }\n\n                catch(ClassNotFoundException e ) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n            return true;\n        }\n\n            catch(ClassNotFoundException e ) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "148", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String [] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i ];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j ]\n                            .startsWith(\" \")\n                                || lines[j ]\n                                    .startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[j ]\n                                .trim());\n                        } else {\n                            break;\n                        }\n                    }\n                    // Apply MIME header decoding\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim().isEmpty()) break;\n            }\n        }\n\n            catch(RuntimeException e ) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "149", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n\n        // 1. Find the screen position of all attachment markers\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true); // Process pages in order\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "150", "src_id": "M491", "code": "\n    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe @ResizeMode public static int nextResizeModeAndSaveToPrefs(final Player player, @ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n\n        // save the new resize mode so it can be restored in a future session\n\n        player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n\n", "compilable": false, "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "151", "src_id": "M424", "code": "\n    @Override public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close it because when changing orientation from portrait\n            // (in fullscreen mode) the size of queue layout can be larger than the screen size\n            closeItemsList();\n        } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            // Ensure that we have audio-only stream playing when a user\n            // started to play from notification's play button from outside of the app\n            if (!fragmentIsVisible) {\n                onFragmentStopped();\n            }\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                   fragmentIsVisible = false;\n                   onFragmentStopped();\n               } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            // Restore video source when user returns to the fragment\n                          fragmentIsVisible = true;\n                          player.useVideoSource(true);\n\n            // When a user returns from background, the system UI will always be shown even if\n            // controls are invisible: hide it in that case\n                          if (!isControlsVisible()) {\n                              hideSystemUIIfNeeded();\n                          }\n                      }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "152", "src_id": "M900", "code": "\n    @StyleRes public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        final String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n                   return R.style.BlackSettingsTheme;\n        } else if (selectedTheme.equals(automaticDeviceTheme)) {\n                   if (isDeviceDarkThemeEnabled(context)) {\n                // use the dark theme variant preferred by the user\n                       final String selectedNightTheme = getSelectedNightThemeKey(context);\n\n                       if (selectedNightTheme.equals(blackTheme)) {\n                           return R.style.BlackSettingsTheme;\n                       } else {\n                           return R.style.DarkSettingsTheme;\n                       }\n                   } else {\n                // there is only one day theme\n                       return R.style.LightSettingsTheme;\n                   }\n               } else {\n            // default to dark theme\n                   return R.style.DarkSettingsTheme;\n               }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "153", "src_id": "M895", "code": "\n    @Override public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n\n        final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n        final Bitmap result = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n        if (result == source || !result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n            source.recycle();\n            return copied;\n        } else {\n            source.recycle();\n            return result;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "154", "src_id": "M225", "code": "\n    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n\n                if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                }\n\n                break;\n        }\n\n        UIs.call(playerUi->\n            playerUi.onBroadcastReceived(intent));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "155", "src_id": "M749", "code": "\n    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            // Starting ReCaptcha Challenge Activity\n\n            final Intent intent = new Intent(context, ReCaptchaActivity.class );\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n            Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n                   Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n               } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n                   Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n               } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n                          Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                      } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n                          Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                      } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                 Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n                             } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n                                 Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n                             } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n                                        Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n                                    } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                        Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n                                    } else {\n                                        ErrorUtil.createNotification(context, errorInfo);\n                                    }\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "156", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@NonNull final Context context, @NonNull final FragmentManager fragmentManager, final int serviceId, @Nullable final String url, @NonNull final String title, @Nullable final PlayQueue playQueue, final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n\n        if (playerType == null) {\n            // no player open\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else if (switchingPlayers) {\n            // switching player to main player\n            autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n        } else if (playerType == PlayerType.MAIN) {\n            // opening new stream while already playing in main player\n                   autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n               } else {\n            // opening new stream while already playing in another player\n                   autoPlay = false;\n               }\n\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment-> {\n                                                  expandMainPlayer(detailFragment.requireActivity());\n                                                  detailFragment.setAutoPlay(autoPlay);\n                                                  if (switchingPlayers) {\n                // Situation when user switches from players to main player. All needed data is\n                // here, we can start watching (assuming newQueue equals playQueue).\n                // Starting directly in fullscreen if the previous player type was popup.\n                                                      detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n                                                  } else {\n                                                      detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n                                                  }\n\n                                                  detailFragment.scrollToTop();\n                                              };\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n            defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(()->\n                                                                                                  onVideoDetailFragmentReady.run(instance)).commit();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "157", "src_id": "M698", "code": "\n    @Override public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n        } else {\n            // do not waste space for the banner, if the user disabled images or there is not one\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n        channelContentNotSupported = false;\n        for (final Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "158", "src_id": "M379", "code": "\n    @Override public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n\n        final List <Tracks.Group > textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo->\n                                                                                      C.TRACK_TYPE_TEXT == trackGroupInfo.getType()).collect(Collectors.toList());\n        final List <String > availableLanguages = textTracks.stream().map(Tracks.Group::getMediaTrackGroup).filter(textTrack->\n                                                                                                               textTrack.length > 0).map(textTrack->\n                                                                                                                                        textTrack.getFormat(0).language).collect(Collectors.toList());\n\n        // Find selected text track\n        final Optional <Format > selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info->\n                                                                                                          info.getMediaTrackGroup().length >= 1).map(info->\n                                                                                                                                                    info.getMediaTrackGroup().getFormat(0)).findFirst();\n\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "159", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(final Context context, @NonNull final List <Image > images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n                                                                 @Override public Bitmap transform(final Bitmap source) {\n                                                                     if (DEBUG) {\n                                                                         Log.d(TAG, \"Thumbnail - transform() called\");\n                                                                     }\n\n                                                                     final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n                                                                     final Bitmap result = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n                                                                     if (result == source || !result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n                                                                         final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n                                                                         source.recycle();\n                                                                         return copied;\n                                                                     } else {\n                                                                         source.recycle();\n                                                                         return result;\n                                                                     }\n                                                                 }\n\n                                                                                  @Override public String key() {\n                                                                                      return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                                                                                  }\n                                                             });\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "160", "src_id": "M66", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Observer < ? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference <SwitchMapMaybeObserver <R>> inner = this.inner;\n        for(;;\n        ) {\n            for(;;\n            ) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    if (!delayErrors) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean d = done;\n                SwitchMapMaybeObserver <R> current = inner.get();\n                boolean empty = current == null;\n\n                if (d&&\n                        empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty || current.item == null) {\n                    break;\n                }\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n                }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "161", "src_id": "M1333", "code": "\n    @ Override public void onNext(T t) {\n        if (done) {\n            return;\n        }\n\n        boolean b;\n        try\n        {\n            b = predicate.test(t);\n        } catch (Throwable e)\n        {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            downstream.onSuccess(false);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "162", "src_id": "M522", "code": "\n    void drainLoop() {\n    Observer < ? super T> actual = this.downstream;\n    int missed = 1;\n    for(;;\n    ) {\n        for(;;\n        ) {\n            if (disposed) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(actual);\n                return;\n            }\n\n            int os = otherState;\n\n            if (os == OTHER_STATE_HAS_VALUE) {\n                T v = singleItem;\n                singleItem = null;\n                otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                actual.onNext(v);\n            }\n\n            boolean d = mainDone;\n            SimplePlainQueue <T> q = queue;\n            T v = q != null ?\n                q.poll() : null;\n            boolean empty = v == null;\n\n            if (d&&\n                    empty&&\n                    os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                queue = null;\n                actual.onComplete();\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n            actual.onNext(v);\n            }\n        missed = addAndGet(- missed);\n        if (missed == 0) {\n            break;\n        }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "163", "src_id": "M1163", "code": "\n    @ Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        final SimplePlainQueue <Object> queue = this.queue;\n        final Subscriber < ? super Flowable <T>> downstream = this.downstream;\n        UnicastProcessor <T> window = this.window;\n        for(;;\n        ) {\n            if (upstreamCancelled) {\n                                       queue.clear();\n                                       window = null;\n                                       this.window = null;\n                                   } else {\n                                              boolean isDone = done;\n                                              Object o = queue.poll();\n                                              boolean isEmpty = o == null;\n\n                                              if (isDone&&\n                                                      isEmpty) {\n                                                                   Throwable ex = error;\n\n                                                                   if (ex != null) {\n                                                                                       if (window != null) {\n                                                                                           window.onError(ex);\n                                                                                       }\n                                                                                       downstream.onError(ex);\n                                                                                   } else {\n                                                                   if (window != null) {\n                                                                       window.onComplete();\n                                                                   }\n                                                                   downstream.onComplete();\n                                                                                          }\n                                                                   cleanupResources();\n                                                                   upstreamCancelled = true;\n                                                                   continue;\n                                                               } else if (!isEmpty) {\n                                                                          if (o instanceof WindowBoundaryRunnable) {\n                                                                                                                       WindowBoundaryRunnable boundary = (WindowBoundaryRunnable)o;\n\n                                                                                                                       if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                                                                                                           this.count = 0;\n                                                                                                                           window = createNewWindow(window);\n                                                                                                                       }\n                                                                                                                   } else if (window != null) {\n                                                                                                                              @ SuppressWarnings(\"unchecked\" )T item = (T)o;\n                                                                                                                              window.onNext(item);\n                                                                                                                              long count = this.count + 1;\n\n                                                                                                                              if (count == maxSize) {\n                                                                                                                                                        this.count = 0;\n                                                                                                                                                        window = createNewWindow(window);\n                                                                                                                                                    } else {\n                                                                                                                                                               this.count = count;\n                                                                                                                                                           }\n                                                                                                                          }\n\n                                                                          continue;\n                                                                      }\n                                          }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "164", "src_id": "M478", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        EqualObserver <T> [] as = observers;\n        final EqualObserver <T> observer1 = as[ 0];\n        final SpscLinkedArrayQueue <T> q1 = observer1.queue;\n        final EqualObserver <T> observer2 = as[ 1];\n        final SpscLinkedArrayQueue <T> q2 = observer2.queue;\n        for(;;\n        ) {\n            for(;;\n            ) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n\n                boolean d1 = observer1.done;\n\n                if (d1) {\n                    Throwable e = observer1.error;\n\n                    if (e != null) {\n                        cancel( q1, q2 );\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                boolean d2 = observer2.done;\n\n                if (d2) {\n                    Throwable e = observer2.error;\n\n                    if (e != null) {\n                        cancel( q1, q2 );\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n\n                boolean e1 = v1 == null;\n\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n\n                boolean e2 = v2 == null;\n\n                if (d1&&\n                        d2&&\n                        e1&&\n                        e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n\n                if ((d1&&\n                         d2)&& (e1 != e2)) {\n                    cancel( q1, q2 );\n                    downstream.onSuccess(false);\n                    return;\n                }\n\n                if (!e1&& !e2) {\n                    boolean c;\n                    try\n                    {\n                        c = comparer.test(v1, v2);\n                    } catch (Throwable ex)\n                    {\n                        Exceptions.throwIfFatal(ex);\n                        cancel( q1, q2 );\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    if (!c) {\n                        cancel( q1, q2 );\n                        downstream.onSuccess(false);\n                        return;\n                    }\n                    v1 = null;\n                    v2 = null;\n                }\n\n                if (e1 || e2) {\n                    break;\n                }\n                }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "165", "src_id": "M885", "code": "\n    void drainLoop() {\n    int missed = 1;\n    JoinInnerSubscriber <T> [] s = this.subscribers;\n    int n = s.length;\n    Subscriber < ? super T> a = this.downstream;\n    for(;;\n    ) {\n        long r = requested.get();\n        long e = 0;\n        middle: while(e != r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean d = done.get() == 0;\n                    boolean empty = true;\n                    for(int i = 0;\ni < s.length;\ni++) {\n                        JoinInnerSubscriber <T> inner = s[i];\n                        SimplePlainQueue <T> q = inner.queue;\n\n                        if (q != null) {\n                            T v = q.poll();\n\n                            if (v != null) {\n                                empty = false;\n                                a.onNext(v);\n                                inner.requestOne();\n                                if (++ e == r) {\n                                    break middle;\n                                }\n                            }\n                        }\n                        }\n\n                    if (d&&\n                            empty) {\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n                    }\n\n        if (e == r) {\n            if (cancelled) {\n                cleanup();\n                return;\n            }\n\n            Throwable ex = errors.get();\n\n            if (ex != null) {\n                cleanup();\n                a.onError(ex);\n                return;\n            }\n\n            boolean d = done.get() == 0;\n            boolean empty = true;\n            for(int i = 0;\ni < n;\ni++) {\n                JoinInnerSubscriber <T> inner = s[i];\n                SimpleQueue <T> q = inner.queue;\n\n                if (q != null&& !q.isEmpty()) {\n                    empty = false;\n                    break;\n                }\n                }\n\n            if (d&&\n                    empty) {\n                a.onComplete();\n                return;\n            }\n        }\n\n        if (e != 0) {\n            BackpressureHelper.produced(requested, e);\n        }\n        missed = addAndGet(- missed);\n        if (missed == 0) {\n            break;\n        }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1399", "code": "\n    @ Override public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        InnerQueuedSubscriber <R> inner = current;\n        Subscriber < ? super R> a = downstream;\n        ErrorMode em = errorMode;\n        for(;;\n        ) {\n            long r = requested.get();\n            long e = 0L;\n\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean outerDone = done;\n                inner = subscribers.poll();\n                if (outerDone&&\n                        inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n\n            boolean continueNextSource = false;\n\n            if (inner != null) {\n                SimpleQueue <R> q = inner.queue();\n\n                if (q != null) {\n                    while (e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        R v;\n                        try\n                        {\n                            v = q.poll();\n                        } catch (Throwable ex)\n                        {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d&&\n                                empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        boolean empty = q.isEmpty();\n\n                        if (d&&\n                                empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n\n            if (e != 0L&&\n                    r != Long.MAX_VALUE) {\n                requested.addAndGet(- e);\n            }\n\n            if (continueNextSource) {\n                continue;\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n            }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "167", "src_id": "M469", "code": "\n    @ SuppressWarnings(\"unchecked\" ) void remove(CacheDisposable <T> consumer) {\n    for(;;\n    ) {\n        CacheDisposable <T> [] current = observers.get();\n        int n = current.length;\n\n        if (n == 0) {\n            return;\n        }\n\n        int j = - 1;\n        for(int i = 0;\ni < n;\ni++) {\n            if (current[i] == consumer) {\n                j = i;\n                break;\n            }\n            }\n\n        if (j < 0) {\n            return;\n        }\n\n        CacheDisposable <T> [] next;\n\n        if (n == 1) {\n                        next = EMPTY;\n                    } else {\n                               next = new\nCacheDisposable [n - 1];\n                               System.arraycopy(current, 0, next, 0, j);\n                               System.arraycopy(current, j + 1, next, j, n - j - 1);\n                           }\n\n        if (observers.compareAndSet(current, next)) {\n            return;\n        }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "168", "src_id": "M362", "code": "\n    void drainFused() {\n    int missed = 1;\n    for(;;\n    ) {\n        if (disposed) {\n            return;\n        }\n\n        boolean d = done;\n        Throwable ex = error;\n\n        if (!delayError&&\n                d&&\n                ex != null) {\n            disposed = true;\n            downstream.onError(error);\n            worker.dispose();\n            return;\n        }\n        downstream.onNext(null);\n        if (d) {\n            disposed = true;\n            ex = error;\n            if (ex != null) {\n                                downstream.onError(ex);\n                            } else {\n                                       downstream.onComplete();\n                                   }\n            worker.dispose();\n            return;\n        }\n        missed = addAndGet(- missed);\n        if (missed == 0) {\n            break;\n        }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "169", "src_id": "M2247", "code": "\n    @ SuppressWarnings(\"unchecked\" ) void remove(PublishSubscription <T> ps) {\n    for(;;\n    ) {\n        PublishSubscription <T> [] a = subscribers.get();\n\n        if (a == TERMINATED || a == EMPTY) {\n            return;\n        }\n\n        int n = a.length;\n        int j = - 1;\n        for(int i = 0;\ni < n;\ni++) {\n            if (a[i] == ps) {\n                j = i;\n                break;\n            }\n            }\n\n        if (j < 0) {\n            return;\n        }\n\n        PublishSubscription <T> [] b;\n\n        if (n == 1) {\n                        b = EMPTY;\n                    } else {\n                               b = new\nPublishSubscription [n - 1];\n                               System.arraycopy(a, 0, b, 0, j);\n                               System.arraycopy(a, j + 1, b, j, n - j - 1);\n                           }\n\n        if (subscribers.compareAndSet(a, b)) {\n            return;\n        }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "170", "src_id": "M31", "code": "\n    private JsonNode validateLicense(String licenseKey, String machineFingerprint,LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(BASE_URL+\"/\"+ACCOUNT_ID+\"/licenses/actions/validate-key\")) .header(\"Content-Type\", \"application/vnd.api+json\" ) .header(\"Accept\", \"application/vnd.api+json\" )\n                        // .header(\"Authorization\", \"License \" + licenseKey) .POST(HttpRequest.BodyPublishers.ofString(requestBody)) .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n\n        if (response.statusCode() == 200) {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\") .asBoolean();\n            String detail = metaNode.path(\"detail\") .asText();\n            String code = metaNode.path(\"code\") .asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\") .path(\"attributes\");\n\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\") .asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\") .asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Also check the policy for floating license support if included\n\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n\n            if (includedNode.isArray()) {\n                for(JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\") .asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\") .path(\"floating\") .asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\") .path(\"maxMachines\") .asInt(1);\n\n                // Policy takes precedence over license attributes\n\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Extract user count, default to 1 if not specified\n\n            int users = jsonResponse.path(\"data\") .path(\"attributes\") .path(\"metadata\") .path(\"users\") .asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\") .path(\"attributes\") .path(\"metadata\") .path(\"isEnterprise\") .asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } else {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n\n        return jsonResponse;\n    }\n\n", "compilable": false, "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "171", "src_id": "M488", "code": "\n    @ PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @ Operation(summary = \"Convert a file to a PDF using LibreOffice\", description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\"+\" Output:PDF Type:SISO\")\n    public ResponseEntity<byte []> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()) .replaceFirst(\"[.][^.]+$\", \"\" )+\"_convertedToPDF.pdf\");\n        } finally {\n                  if (file != null) file.delete();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "172", "src_id": "M625", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "173", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile,LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n\n            byte [] payloadBytes = Base64.getDecoder() .decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            // Verify license file algorithm\n\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            // Verify signature\n\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n\n            log.info(\"License file signature is valid\");\n\n            // Decode the base64 data\n            String decodedData;\n\n            try {\n                decodedData = new String(Base64.getDecoder() .decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            // Process the certificate data\n\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "174", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize,TempFileManager tempFileManager) throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath() .resolve(sanitizeZipFilename(entry.getName()));\n\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName() .toLowerCase() .endsWith(\".html\")||entry.getName() .toLowerCase() .endsWith(\".htm\")) {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "175", "src_id": "M317", "code": "\n    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption,\n                                          boolean autoRotate) throws IOException {\n        boolean imageIsLandscape = image.getWidth()> image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n\n        float pageWidth = page.getMediaBox() .getWidth();\n        float pageHeight = page.getMediaBox() .getHeight();\n\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption)||\"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                       float imageAspectRatio = (float)image.getWidth()/(float)image.getHeight();\n                       float pageAspectRatio = pageWidth/pageHeight;\n                       float scaleFactor = 1.0f;\n\n                       if (imageAspectRatio > pageAspectRatio) {\n                           scaleFactor = pageWidth/image.getWidth();\n                       } else {\n                           scaleFactor = pageHeight/image.getHeight();\n                       }\n\n                       float xPos = (pageWidth-(image.getWidth()*scaleFactor))/ 2;\n                       float yPos = (pageHeight-(image.getHeight()*scaleFactor))/ 2;\n                       contentStream.drawImage(image, xPos, yPos, image.getWidth()*scaleFactor, image.getHeight()*scaleFactor);\n                   }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "176", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n            if (network == null) {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte [] mac = net.getHardwareAddress();\n\n                    if (mac != null) {\n                        for (int i = 0;\n                        i<mac.length;\n                        i++) {\n                            sb.append(String.format(\"%02X\", mac[ i]));\n                        }\n\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } else {\n                byte [] mac = network.getHardwareAddress();\n\n                if (mac != null) {\n                    for (int i = 0;\n                    i<mac.length;\n                    i++) {\n                        sb.append(String.format(\"%02X\", mac[ i]));\n                    }\n                }\n            }\n\n            // Hash the MAC address for privacy and consistency\n\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte [] hash = md.digest(sb.toString() .getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n\n            for(byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "177", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf,PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n\n        if (applicationProperties.getPremium() .getProFeatures() .getCustomMetadata() .isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium() .getProFeatures() .getCustomMetadata() .getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "178", "src_id": "M128", "code": "\n    @ Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            } else if (isDocker) {\n                       return \"Docker\";\n                   } else if (isBrowserOpen) {\n                              String os = System.getProperty(\"os.name\") .toLowerCase(Locale.ROOT);\n\n                              if (os.contains(\"win\")) {\n                                  return \"Client-windows\";\n                              } else if (os.contains(\"mac\")) {\n                                         return \"Client-mac\";\n                                     } else {\n                                         return \"Client-unix\";\n                                     }\n                          } else {\n                              return \"Server-jar\";\n                          }\n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "179", "src_id": "M101", "code": "\n    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response,FilterChain filterChain) throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k->createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill()/ 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "180", "src_id": "M31", "code": "\n    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n                                                      .header(\"Content-Type\", \"application/vnd.api+json\")\n                                                      .header(\"Accept\", \"application/vnd.api+json\")\n                        // .header(\"Authorization\", \"License \" + licenseKey)\n                                                      .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                                                      .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() == 200) {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for(JsonNode node :includedNode ) {\n                    if (\"policies\"\n                        .equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\")\n                                                                      .asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\")\n                                                                     .asInt(1);\n\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Extract user count, default to 1 if not specified\n\n            int users = jsonResponse.path(\"data\").path(\"attributes\")\n                                                 .path(\"metadata\")\n                                                 .path(\"users\")\n                                                 .asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\")\n                                                                   .path(\"metadata\")\n                                                                   .path(\"isEnterprise\")\n                                                                   .asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } else {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n        return jsonResponse;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "181", "src_id": "M488", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(summary = \"Convert a file to a PDF using LibreOffice\", description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte []> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        }\n\n            finally {\n            if (file != null) file.delete();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "182", "src_id": "M625", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "183", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n\n\n            byte [] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n            }\n\n                catch(JSONException e ) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            // Verify license file algorithm\n\n            if (!\"base64+ed25519\"\n                .equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            // Verify signature\n\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n            log.info(\"License file signature is valid\");\n\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            }\n\n                catch(IllegalArgumentException e ) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            // Process the certificate data\n\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n        }\n\n            catch(Exception e ) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "184", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn =ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while(entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase()\n                                           .endsWith(\".html\")\n                                || entry.getName().toLowerCase()\n                                                  .endsWith(\".htm\")) {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "185", "src_id": "M317", "code": "\n    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n\n        if (\"fitDocumentToImage\"\n            .equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n\n\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\"\n                .equals(fitOption)\n                    || \"fitDocumentToImage\"\n                        .equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\"\n                .equals(fitOption)) {\n                       float imageAspectRatio = (float)image.getWidth() / (float)image.getHeight();\n                       float pageAspectRatio = pageWidth / pageHeight;\n                       float scaleFactor = 1.0f;\n                       if (imageAspectRatio > pageAspectRatio) {\n                           scaleFactor = pageWidth / image.getWidth();\n                       } else {\n                           scaleFactor = pageHeight / image.getHeight();\n                       }\n\n                       float xPos = (pageWidth - (image.getWidth() *scaleFactor)) / 2;\n                       float yPos = (pageHeight - (image.getHeight() *scaleFactor)) / 2;\n                       contentStream.drawImage(image, xPos, yPos, image.getWidth() *scaleFactor, image.getHeight() *scaleFactor);\n                   }\n        }\n\n            catch(IOException e ) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "186", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network == null) {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while(networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte [] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i ]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } else {\n                byte [] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i ]));\n                    }\n                }\n            }\n\n            // Hash the MAC address for privacy and consistency\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte [] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for(byte b :hash ) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        }\n\n            catch(Exception e ) {\n            return \"GenericID\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "187", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures()\n                                              .getCustomMetadata()\n                                              .isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures()\n                                                       .getCustomMetadata()\n                                                       .getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "188", "src_id": "M128", "code": "\n    @Bean(name = \"machineType\" )\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\"\n                .equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            } else if (isDocker) {\n                       return \"Docker\";\n                   } else if (isBrowserOpen) {\n                              String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                              if (os.contains(\"win\")) {\n                                  return \"Client-windows\";\n                              } else if (os.contains(\"mac\")) {\n                                         return \"Client-mac\";\n                                     } else {\n                                         return \"Client-unix\";\n                                     }\n                          } else {\n                              return \"Server-jar\";\n                          }\n        }\n\n            catch(Exception e ) {\n            return \"Unknown\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "189", "src_id": "M101", "code": "\n    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "190", "src_id": "M491", "code": "\n    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,\n                                                   @ResizeMode final int resizeMode) {\n        final int newResizeMode;\n\n        switch (resizeMode) {\n        case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n        default:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n            break;\n        }\n\n        // save the new resize mode so it can be restored in a future session\n\n        player.getPrefs() .edit() .putInt(player.getContext() .getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "191", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close it because when changing orientation from portrait\n            // (in fullscreen mode) the size of queue layout can be larger than the screen size\n            closeItemsList();\n        } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            // Ensure that we have audio-only stream playing when a user\n            // started to play from notification's play button from outside of the app\n                   if (!fragmentIsVisible) {\n                       onFragmentStopped();\n                   }\n               } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                          fragmentIsVisible = false;\n                          onFragmentStopped();\n                      } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            // Restore video source when user returns to the fragment\n                                 fragmentIsVisible = true;\n                                 player.useVideoSource(true);\n\n            // When a user returns from background, the system UI will always be shown even if\n            // controls are invisible: hide it in that case\n                                 if (!isControlsVisible()) {\n                                     hideSystemUIIfNeeded();\n                                 }\n                             }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "192", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        final String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n                   return R.style.BlackSettingsTheme;\n               } else if (selectedTheme.equals(automaticDeviceTheme)) {\n                          if (isDeviceDarkThemeEnabled(context)) {\n                // use the dark theme variant preferred by the user\n                              final String selectedNightTheme = getSelectedNightThemeKey(context);\n\n                              if (selectedNightTheme.equals(blackTheme)) {\n                                  return R.style.BlackSettingsTheme;\n                              } else {\n                                  return R.style.DarkSettingsTheme;\n                              }\n                          } else {\n                // there is only one day theme\n                              return R.style.LightSettingsTheme;\n                          }\n                      } else {\n            // default to dark theme\n                          return R.style.DarkSettingsTheme;\n                      }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "193", "src_id": "M895", "code": "\n    @Override\n    public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n\n        final float notificationThumbnailWidth = Math.min(context.getResources() .getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n        final Bitmap result = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth, (int) (source.getHeight()/(source.getWidth()/notificationThumbnailWidth)), null, true);\n\n        if (result == source||!result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth- 1, (int) (source.getHeight()/(source.getWidth()/(notificationThumbnailWidth- 1))), null, true);\n            source.recycle();\n            return copied;\n        } else {\n            source.recycle();\n            return result;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "194", "src_id": "M225", "code": "\n    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null||intent.getAction() == null) {\n            return;\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\"+intent+\"]\");\n        }\n\n        switch (intent.getAction()) {\n        case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n            pause();\n            break;\n        case ACTION_CLOSE:\n            service.destroyPlayerAndStopService();\n            break;\n        case ACTION_PLAY_PAUSE:\n            playPause();\n            break;\n        case ACTION_PLAY_PREVIOUS:\n            playPrevious();\n            break;\n        case ACTION_PLAY_NEXT:\n            playNext();\n            break;\n        case ACTION_FAST_REWIND:\n            fastRewind();\n            break;\n        case ACTION_FAST_FORWARD:\n            fastForward();\n            break;\n        case ACTION_REPEAT:\n            cycleNextRepeatMode();\n            break;\n        case ACTION_SHUFFLE:\n            toggleShuffleModeEnabled();\n            break;\n        case Intent.ACTION_CONFIGURATION_CHANGED:\n            if (DEBUG) {\n                Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n            }\n\n            break;\n        }\n\n        UIs.call(playerUi->playerUi.onBroadcastReceived(intent));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "195", "src_id": "M749", "code": "\n    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            // Starting ReCaptcha Challenge Activity\n\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n                   Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n               } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n                          Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n                      } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n                                 Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n                             } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n                                        Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                                    } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n                                               Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                                           } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                                      Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n                                                  } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n                                                             Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n                                                         } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n                                                                    Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n                                                                } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                                                           Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n                                                                       } else {\n                                                                           ErrorUtil.createNotification(context, errorInfo);\n                                                                       }\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "196", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@NonNull final Context context, @NonNull final FragmentManager fragmentManager, final int serviceId, @Nullable final String url, @NonNull final String title, @Nullable final PlayQueue playQueue, final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance() .getType();\n\n        if (playerType == null) {\n            // no player open\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else if (switchingPlayers) {\n            // switching player to main player\n                   autoPlay = PlayerHolder.getInstance() .isPlaying(); // keep play/pause state\n               } else if (playerType == PlayerType.MAIN) {\n            // opening new stream while already playing in main player\n                          autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n                      } else {\n            // opening new stream while already playing in another player\n                          autoPlay = false;\n                      }\n\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment-> {\n                                                                               expandMainPlayer(detailFragment.requireActivity());\n                                                                               detailFragment.setAutoPlay(autoPlay);\n                                                                               if (switchingPlayers) {\n                // Situation when user switches from players to main player. All needed data is\n                // here, we can start watching (assuming newQueue equals playQueue).\n                // Starting directly in fullscreen if the previous player type was popup.\n                                                                                   detailFragment.openVideoPlayer(playerType == PlayerType.POPUP||PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n                                                                               } else {\n                                                                                   detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n                                                                               }\n\n                                                                               detailFragment.scrollToTop();\n                                                                           };\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n            defaultTransaction(fragmentManager) .replace(R.id.fragment_player_holder, instance) .runOnCommit(()->onVideoDetailFragmentReady.run(instance)).commit();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "197", "src_id": "M698", "code": "\n    @Override\n    public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners() .isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()) .tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n        } else {\n            // do not waste space for the banner, if the user disabled images or there is not one\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n\n        PicassoHelper.loadAvatar(result.getAvatars()) .tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()) .tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount()>= 0) {\n            binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n        channelContentNotSupported = false;\n        for(final Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "198", "src_id": "M379", "code": "\n    @Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)||currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n\n        if (getPlayer() .getTrackSelector() .getCurrentMappedTrackInfo() == null||!trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n\n        final List<Tracks.Group> textTracks = currentTracks.getGroups() .stream() .filter(trackGroupInfo->C.TRACK_TYPE_TEXT == trackGroupInfo.getType()) .collect(Collectors.toList());\n        final List<String> availableLanguages = textTracks.stream() .map(Tracks.Group::getMediaTrackGroup) .filter(textTrack->textTrack.length > 0) .map(textTrack->textTrack.getFormat(0) .language) .collect(Collectors.toList());\n\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks.stream() .filter(Tracks.Group::isSelected) .filter(info->info.getMediaTrackGroup() .length >= 1) .map(info->info.getMediaTrackGroup() .getFormat(0)) .findFirst();\n\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector() .getParameters() .getRendererDisabled(player.getCaptionRendererIndex())||selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get() .language);\n        }\n\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty()? View.GONE:\n                                              View.VISIBLE);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "199", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(final Context context,\n                                                         @NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images) .transform(new Transformation() {\n            @Override\n            public Bitmap transform(final Bitmap source) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n                }\n\n                final float notificationThumbnailWidth = Math.min(context.getResources() .getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n                final Bitmap result = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth, (int) (source.getHeight()/(source.getWidth()/notificationThumbnailWidth)), null, true);\n\n                if (result == source||!result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth- 1, (int) (source.getHeight()/(source.getWidth()/(notificationThumbnailWidth- 1))), null, true);\n                    source.recycle();\n                    return copied;\n                } else {\n                    source.recycle();\n                    return result;\n                }\n            }\n                @Override\n                public String key() {\n                    return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                }\n\n                                                              }\n\n);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            thread.setName(\"[\"+\n                               TAG+\"]  ps = \"+\n                               psAlgorithm+\"  filename = \"+\n                               storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \"+\n                           psAlgorithm.toString(), err);\n\n            if (err instanceof InterruptedIOException||\n                    err instanceof ClosedByInterruptException||\n                thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) errCode = ERROR_POSTPROCESSING;\n            exception = err;\n        }\n\n        finally {\n                notifyPostProcessing(errCode == ERROR_NOTHING? 2: 0);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) exception = errObject;\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n        notifyFinished();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, threadId+\":[request]  Range=\"+\n                           conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId+\":[response] Code=\"+\n                           statusCode);\n            Log.d(TAG, threadId+\":[response] Content-Length=\"+\n                           conn.getContentLength());\n            Log.d(TAG, threadId+\":[response] Content-Range=\"+\n                           conn.getHeaderField(\"Content-Range\"));\n        }\n\n        switch (statusCode) {\n        case 204:\n        case 205:\n        case 207:\n            throw new HttpError(statusCode);\n        case 416:\n            return;// let the download thread handle this error\n        default:\n            if (statusCode < 200||\n                statusCode> 299) {\n                throw new HttpError(statusCode);\n            }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "202", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws\n        IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n        final boolean v1 = stream.read() == 1;\n\n        stream.skipBytes(3); // flags\n\n        final int entryCount = stream.readInt();\n\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n\n        if (v1) {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n            stream.skipBytes((entryCount- 1)*(DataReader.LONG_SIZE* 2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        }\n\n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "203", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \"+\n                           start);\n        }\n\n        try {\n            long rangeStart = (mMission.unknownLength||\n                                   start < 1)?-1:\n                              start;\n            int mId = 1;\n\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n\n            if (!mMission.unknownLength) mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n\n            if (mMission.unknownLength||\n                mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current]-\n                                    mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current]+\n                        start);\n            mIs = mConn.getInputStream();\n\n            byte [] buf = new byte\n[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n            dispose();\n\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n\n            if (!mMission.running||\n                e instanceof ClosedByInterruptException) return;\n\n            if (e instanceof HttpError && ((HttpError)e) .statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount ++>= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n\n            run();// try again\n            return;\n        }\n\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "204", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws\n        IOException {\n        if (aux.length < 1) {\n            return;\n        }\n\n        out.flush();\n        aux.flush();\n\n        boolean underflow = aux.offset < aux.length||\n                                out.offset < out.length;\n        byte [] buffer = new byte\n[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long length = amount;\n\n        while (length > 0) {\n            int read = (int)Math.min(length, Integer.MAX_VALUE);\n\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n        if (underflow) {\n            if (out.offset >= out.length) {\n                // calculate the aux underflow pointer\n                if (aux.offset < amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length+\n                                     amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        } else {\n            out.offset += amount;\n            aux.offset -= amount;\n        }\n\n        out.length += amount;\n\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n\n            aux.length -= amount;\n            length = aux.length;\n            while (length > 0) {\n                int read = (int)Math.min(length, Integer.MAX_VALUE);\n\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);// or setLength(0);\n        }\n\n        aux.reset();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "205", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n\n        request.append(mission.source);\n        request.append(\" [\");\n\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) request.append(' ').append(recovery.toString()).append(' ');\n        }\n\n        request.append(\"]\");\n        String service;\n\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "206", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized(this) {\n                           mission.timestamp = System.currentTimeMillis();\n                           mission.mHandler = mHandler;\n                           mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n                           while (true) {\n                               mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n\n                               if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                                   try {\n                                       if (!mission.metadata.createNewFile()) throw new RuntimeException(\"Cant create download metadata file\");\n                                   } catch (IOException e) {\n                                       throw new RuntimeException(e);\n                                   }\n\n                                   break;\n                               }\n\n                               mission.timestamp = System.currentTimeMillis();\n                           }\n\n                           mSelfMissionsControl = true;\n                           mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n                           Utility.writeToFile(mission.metadata, mission);\n\n                           if (mission.storage == null) {\n                // noting to do here\n                               mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n\n                               if (mission.errObject != null) mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                               return;\n                           }\n\n                           boolean start = !mPrefQueueLimit||\n                                               getRunningMissionsCount() < 1;\n\n                           if (canDownloadInCurrentNetwork() && start) {\n                               mission.start();\n                           }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "207", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out, SharpStream... sources) throws\n        IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n        if (format == null||\n            format.equals(\"ttml\")) {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException? 1: 8;\n            }\n            return OK_RESULT;\n        } else\nif (format.equals(\"srt\")) {\n    byte [] buffer = new byte\n[ 8* 1024];\n    int read;\n\n    while ((read = sources[0] .read(buffer))> 0) {\n        out.write(buffer, 0, read);\n    }\n    return OK_RESULT;\n}\n\n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \"+\n                                                    format);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "208", "src_id": "M1047", "code": "\n    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n\n        if (init != null&& init != currentThread && init.isAlive()) {\n            init.interrupt();\n\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n            }\n        }\n\n        // if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive()||\n                thread == Thread.currentThread()) continue ;\n            thread.interrupt();\n        }\n\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) continue ;\n\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \"+\n                                   thread.getName());\n                }\n\n                if (millis > 0) thread.join(millis);\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "209", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null||emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null?textBody:\"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if(request != null && request.isIncludeAttachments())\n            {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n            else\n            {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status if requested\n\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "210", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n        try\n        {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n\n            // Additional check for MimeMultipart\n\n            try\n            {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            }\n            catch (ClassNotFoundException e)\n            {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        }\n        catch (ClassNotFoundException e)\n        {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "211", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent, String headerName) {\n        try\n        {\n            String [] lines = emlContent.split(\"\\r?\\n\");\n            for(int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for(int j = i + 1; j < lines.length; j++) {\n                        if(lines[j].startsWith(\" \")||lines[j].startsWith(\"\\t\"))\n                        {\n                            value.append(\" \").append(lines[j].trim());\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                    // Apply MIME header decoding\n\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim().isEmpty()) break;\n            }\n        }\n        catch (RuntimeException e)\n        {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n\n        return \"\";\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "212", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0||attachments == null||attachments.isEmpty()) {\n            return;\n        }\n\n        // 1. Find the screen position of all attachment markers\n\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true); // Process pages in order\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for(int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "213", "src_id": "M1086", "code": "\n    public static AdminServer createAdminServer() {\n        if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            try {\n                Class < ?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n                return (AdminServer) adminServer;\n            } catch (ClassNotFoundException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n              catch (InstantiationException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n              catch (IllegalAccessException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n              catch (InvocationTargetException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n              catch (NoSuchMethodException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n              catch (NoClassDefFoundError e) {\n                LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n            }\n        }\n\n        return new DummyAdminServer();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "214", "src_id": "M1149", "code": "\n    public void run() {\n        try {\n            while(!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                }\n\n                  catch (Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n\n                // Close connections still pending on the selector. Any others\n                // with in-flight work, let drain out of the work queue.\n\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n            while((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n\n            updateQueue.clear();\n        }\n\n        finally {\n            closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "215", "src_id": "M219", "code": "\n    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws\n        IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId ) );\n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n\n            zkMap.put(connectionId, zk);\n\n           // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n\n        return zk;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "216", "src_id": "M192", "code": "\n    private void init() throws\n        IOException {\n        File f = new File(file );\n        RandomAccessFileReader in = new RandomAccessFileReader(f );\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT );\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n\n    // if we have read data from the file, and it matches the timep pattern\n\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n\n    /*\n      Count number of log entries. Any line starting with a timestamp counts as an entry\n    */\n\n        String lastentry = line;\n        try {\n            while(line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n\n                    size++;\n                    lastentry = line;\n                }\n\n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n        }\n\nfinally {\n            in.close();\n        }\n\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "217", "src_id": "M235", "code": "\n    @POST @Produces({MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML}) public Response createSession(@QueryParam(\"op\") String op, @DefaultValue(\"5\") @QueryParam(\"expire\") String expire, @Context UriInfo ui) {\n        if (!op.equals(\"create\")) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\" )).build());\n        }\n\n        int expireInSeconds;\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n\n        String uuid = UUID.randomUUID().toString();\n        while(ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n\n        // establish the connection to the ZooKeeper cluster\n\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n\n        URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n        return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString() ))).build();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "218", "src_id": "M942", "code": "\n    public void schedule(WorkRequest workRequest, long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest );\n\n        // If we have a worker thread pool, use that; otherwise, do the work\n        // directly.\n        int size = workers.size();\n\n        if (size > 0) {\n            try {\n                // make sure to map negative ids as well to [0, size-1]\n                int workerNum = ((int) (id % size) + size) % size;\n                ExecutorService worker = workers.get(workerNum);\n                worker.execute(scheduledWorkRequest);\n            } catch (RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n            }\n        } else {\n            // When there is no worker thread pool, do the work directly\n            // and wait for its completion\n            scheduledWorkRequest.run();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "219", "src_id": "M520", "code": "\n    @Override public void close() throws\n        IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        }\n\n        finally {\n            if (success) {\n                boolean renamed = tmpFile.renameTo(origFile);\n\n                if (!renamed) {\n                    // On windows, renameTo does not replace.\n                    if (!origFile.delete() || !tmpFile.renameTo(origFile)) {\n                        throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile );\n                    }\n                }\n            } else {\n                if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                    IOUtils.closeStream(out);\n                }\n                // close wasn't successful, try to delete the tmp file\n\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "220", "src_id": "M186", "code": "\n    synchronized private LogEntry readNextEntry() {\n        try {\n            try {\n                while(true) {\n                    String line = in.readLine();\n\n                    if (line == null) {\n                        break;\n                    }\n\n                    Matcher m = src.timep.matcher(line);\n\n                    if (m.lookingAt()) {\n                        if (buf.length() > 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n                            return e;\n                        }\n\n                        buf = line;\n                    } else if (buf.length() > 0) {\n                               buf += line + \"\\n\";\n                           }\n                }\n            } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n\n            if (buf.length() > 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n                return e;\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n        }\n\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "221", "src_id": "M478", "code": "\n    public static void main(String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n\n        if (op.equalsIgnoreCase(\"gettracemask\")) {\n            getTraceMask(host, port);\n        } else if (op.equalsIgnoreCase(\"settracemask\")) {\n            setTraceMask(host, port, args[3]);\n        } else if (op.equalsIgnoreCase(\"ruok\")) {\n                   ruok(host, port);\n               } else if (op.equalsIgnoreCase(\"kill\")) {\n                   kill(host, port);\n               } else if (op.equalsIgnoreCase(\"stat\")) {\n                          stat(host, port);\n                      } else if (op.equalsIgnoreCase(\"dump\")) {\n                          dump(host, port);\n                      } else {\n                          System.out.println(\"Unrecognized op: \" + op);\n                      }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "222", "src_id": "M1086", "code": "\n    public static AdminServer createAdminServer() {\n        if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            try {\n                Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n                return (AdminServer) adminServer;\n            }\n\n                catch(ClassNotFoundException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n                catch(InstantiationException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n                catch(IllegalAccessException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n                catch(InvocationTargetException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n                catch(NoSuchMethodException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n\n                catch(NoClassDefFoundError e) {\n                LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n            }\n        }\n        return new DummyAdminServer();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "223", "src_id": "M1149", "code": "\n    public void run() {\n        try {\n            while(!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                }\n\n                    catch(RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                }\n\n                    catch(Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n\n                // Close connections still pending on the selector. Any others\n                // with in-flight work, let drain out of the work queue.\n\n            for(SelectionKey key :selector.keys() ) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n            while((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n            updateQueue.clear();\n        }\n\n            finally {\n            closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "224", "src_id": "M219", "code": "\n    synchronized\n    public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n            for(Map.Entry<String, String> p :e.getZooKeeperAuthInfo().entrySet() ) {\n                zk.addAuthInfo(\"digest\",\nString.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n            zkMap.put(connectionId, zk);\n\n           // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId,\nnew SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n        return zk;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "225", "src_id": "M192", "code": "\n    private void init() throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n\n    // if we have read data from the file, and it matches the timep pattern\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n\n    /*\n      Count number of log entries. Any line starting with a timestamp counts as an entry\n    */\n\n        String lastentry = line;\n        try {\n            while(line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size% skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n                    lastentry = line;\n                }\n\n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        }\n\n            catch(EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n        }\n\nfinally {\n            in.close();\n        }\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "226", "src_id": "M235", "code": "\n    @POST\n    @Produces({MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML} )\n    public Response createSession(@QueryParam(\"op\" ) String op, @DefaultValue(\"5\" ) @QueryParam(\"expire\" ) String expire, @Context UriInfo ui) {\n        if (!op.equals(\"create\")) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\"))\n                                                                                          .build());\n        }\n\n        int expireInSeconds;\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        }\n\n            catch(NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n\n        String uuid = UUID.randomUUID().toString();\n        while(ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n\n        // establish the connection to the ZooKeeper cluster\n\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        }\n\n            catch(IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n\n        URI uri = ui.getAbsolutePathBuilder().path(uuid)\n                                             .build();\n        return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString())))\n                                    .build();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "227", "src_id": "M942", "code": "\n    public void schedule(WorkRequest workRequest, long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n\n        // If we have a worker thread pool, use that; otherwise, do the work\n        // directly.\n        int size = workers.size();\n        if (size > 0) {\n            try {\n                // make sure to map negative ids as well to [0, size-1]\n                int workerNum = ((int) (id% size) + size) % size;\n                ExecutorService worker = workers.get(workerNum);\n                worker.execute(scheduledWorkRequest);\n            }\n\n                catch(RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n            }\n        } else {\n            // When there is no worker thread pool, do the work directly\n            // and wait for its completion\n            scheduledWorkRequest.run();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "228", "src_id": "M520", "code": "\n    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        }\n\n            finally {\n            if (success) {\n                boolean renamed = tmpFile.renameTo(origFile);\n                if (!renamed) {\n                    // On windows, renameTo does not replace.\n                    if (!origFile.delete()\n                            || !tmpFile.renameTo(origFile)) {\n                        throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                    }\n                }\n            } else {\n                if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                    IOUtils.closeStream(out);\n                }\n                // close wasn't successful, try to delete the tmp file\n\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "229", "src_id": "M186", "code": "\n    synchronized private LogEntry readNextEntry() {\n        try {\n            try {\n                while(true) {\n                    String line = in.readLine();\n                    if (line == null) {\n                        break;\n                    }\n\n                    Matcher m = src.timep.matcher(line);\n                    if (m.lookingAt()) {\n                        if (buf.length() > 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n                            return e;\n                        }\n                        buf = line;\n                    } else if (buf.length() > 0) {\n                               buf += line + \"\\n\";\n                           }\n                }\n            }\n\n                catch(EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n\n            if (buf.length() > 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n                return e;\n            }\n        }\n\n            catch(Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "230", "src_id": "M478", "code": "\n    public static void main(String [] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n        if (op.equalsIgnoreCase(\"gettracemask\")) {\n            getTraceMask(host, port);\n        } else if (op.equalsIgnoreCase(\"settracemask\")) {\n                   setTraceMask(host, port, args[3]);\n               } else if (op.equalsIgnoreCase(\"ruok\")) {\n                          ruok(host, port);\n                      } else if (op.equalsIgnoreCase(\"kill\")) {\n                                 kill(host, port);\n                             } else if (op.equalsIgnoreCase(\"stat\")) {\n                                        stat(host, port);\n                                    } else if (op.equalsIgnoreCase(\"dump\")) {\n                                               dump(host, port);\n                                           } else {\n                                               System.out.println(\"Unrecognized op: \" + op);\n                                           }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "231", "src_id": "M1043", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "232", "src_id": "M1031", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "233", "src_id": "M827", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "234", "src_id": "M1048", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "235", "src_id": "M1141", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "236", "src_id": "M1106", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "237", "src_id": "M1067", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "238", "src_id": "M1136", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "239", "src_id": "M1047", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "240", "src_id": "M66", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "241", "src_id": "M1333", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "242", "src_id": "M522", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "243", "src_id": "M1163", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "244", "src_id": "M478", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "245", "src_id": "M885", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "246", "src_id": "M1399", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "247", "src_id": "M469", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "248", "src_id": "M362", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "249", "src_id": "M2247", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "250", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte[] emlBytes,EmlToPdfRequest request) {\n\n    if (emlBytes == null ||emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n    }\n\n    String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n\n    String subject = extractBasicHeader(emlContent, \"Subject:\");\n\n    String from = extractBasicHeader(emlContent, \"From:\");\n\n    String to = extractBasicHeader(emlContent, \"To:\");\n\n    String cc = extractBasicHeader(emlContent, \"Cc:\");\n\n    String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n\n    String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n        String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n\n        // Generate HTML with custom styling based on request\n\n    StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n\n    if (request != null && request.isIncludeAllRecipients()) {\n\n        if (!cc.trim().isEmpty()) {\n                                                                 html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        }\n\n        if (!bcc.trim().isEmpty()) {\n                                                                 html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n        }\n    }\n\n    if (!date.trim().isEmpty()) {\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n    }\n\n    html.append(\"</div></div>\\n\");\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    html.append(processEmailHtmlBody(htmlBody));\n    html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n    String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        html.append(\"<h3>Attachments</h3>\\n\");\n        html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n\n        if (request != null && request.isIncludeAttachments()) {\n                                       html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                                       html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                                       html.append(\"</div>\\n\");\n        } else {\n          html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n          html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n          html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n    }\n\n        // Show advanced features status if requested\n\n    assert request != null;\n\n    if (request.getFileInput().isEmpty()) {\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n        html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n    return html.toString();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "251", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n\n    if (multipart == null) return false;\n    try {\n            // Check if the object implements jakarta.mail.Multipart interface\n        Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n        if (!multipartInterface.isInstance(multipart)) {\n        return false;\n        }\n\n            // Additional check for MimeMultipart\n\n        try {\n        Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n        if (mimeMultipartClass.isInstance(multipart)) {\n            log.debug(\"Found MimeMultipart instance for enhanced processing\");\n            return true;\n        }\n        } catch (ClassNotFoundException e) {\n          log.debug(\"MimeMultipart not available, using base Multipart interface\");\n        }\n        return true;\n    } catch (ClassNotFoundException e) {\n      log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n      return false;\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "252", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent,String headerName) {\n    try {\n        String[] lines = emlContent.split(\"\\r?\\n\");\n        for(int i = 0;i <lines.length;\ni++ ) {\n        String line = lines[i];\n        if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n          StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n          for(int j = i + 1;j <lines.length;\nj++ ) {\n\n                                                                         if (lines[j].startsWith(\" \")||lines[j].startsWith(\"\\t\")) {\n          value.append(\" \").append(lines[j].trim());\n                                                                         } else {\n                                                                           break;\n                                                                         }\n          }\n                    // Apply MIME header decoding\n          return safeMimeDecode(value.toString());\n        }\n\n        if (line.trim().isEmpty()) break;\n        }\n    } catch (RuntimeException e) {\n      log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n    }\n    return \"\";\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "253", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(PDDocument document,List<EmailAttachment> attachments) throws IOException {\n\n    if (document.getNumberOfPages() == 0 ||attachments == null||attachments.isEmpty()) {\n        return;\n    }\n\n        // 1. Find the screen position of all attachment markers\n\n    AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n    finder.setSortByPosition(true); // Process pages in order\n    finder.getText(document);\n    List<MarkerPosition> markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n    if (markerPositions.size() != attachments.size()) {\n        log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n    }\n\n        // 3. Create an invisible annotation over each found marker\n    int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n    for(int i = 0;i <annotationsToAdd;\ni++ ) {\n                                                                                                                                         MarkerPosition position = markerPositions.get(i);\n\n                                                                                                                                         EmailAttachment attachment = attachments.get(i);\n                                                                                                                                         if (attachment.getEmbeddedFilename() != null) {\n          PDPage page = document.getPage(position.getPageIndex());\n          addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n                                                                                                                                         }\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "254", "src_id": "M66", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Observer<? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n        for(;;\n) {\n            for(;;\n) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    if (!delayErrors) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean d = done;\n                SwitchMapMaybeObserver<R> current = inner.get();\n                boolean empty = current == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty || current.item == null) {\n                    break;\n                }\n\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "255", "src_id": "M1333", "code": "\n    @Override\n    public void onNext(T t) {\n        if (done) {\n            return;\n        }\n\n        boolean b;\n        try {\n            b = predicate.test(t);\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            downstream.onSuccess(false);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "256", "src_id": "M522", "code": "\n    void drainLoop() {\n        Observer<? super T> actual = this.downstream;\n        int missed = 1;\n        for(;;\n) {\n            for(;;\n) {\n                if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n                    return;\n                }\n\n                int os = otherState;\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                T v = q != null? q.poll(): null;\n                boolean empty = v == null;\n                if (d && empty\n                        && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                actual.onNext(v);\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "257", "src_id": "M1163", "code": "\n    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        final SimplePlainQueue<Object> queue = this.queue;\n        final Subscriber<? super Flowable<T>> downstream = this.downstream;\n        UnicastProcessor<T> window = this.window;\n        for(;;\n) {\n            if (upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n\n                        downstream.onComplete();\n                    }\n\n                    cleanupResources();\n                    upstreamCancelled = true;\n                    continue;\n                } else if (!isEmpty) {\n                           if (o instanceof WindowBoundaryRunnable) {\n                               WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                               if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                   this.count = 0;\n                                   window = createNewWindow(window);\n                               }\n                           } else if (window != null) {\n                                      @ SuppressWarnings(\"unchecked\" ) T item = (T) o;\n                                      window.onNext(item);\n\n                                      long count = this.count + 1;\n                                      if (count == maxSize) {\n                                          this.count = 0;\n                                          window = createNewWindow(window);\n                                      } else {\n                                          this.count = count;\n                                      }\n                                  }\n                           continue;\n                       }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "258", "src_id": "M478", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        EqualObserver<T>[] as = observers;\n        final EqualObserver<T> observer1 = as[0];\n        final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n        final EqualObserver<T> observer2 = as[1];\n        final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n        for(;;\n) {\n            for(;;\n) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n\n                boolean d1 = observer1.done;\n                if (d1) {\n                    Throwable e = observer1.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                boolean d2 = observer2.done;\n                if (d2) {\n                    Throwable e = observer2.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n\n                boolean e1 = v1 == null;\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n\n                boolean e2 = v2 == null;\n                if (d1 && d2 && e1\n                        && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n\n                if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(v1, v2);\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    v1 = null;\n                    v2 = null;\n                }\n\n                if (e1 || e2) {\n                    break;\n                }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "259", "src_id": "M885", "code": "\n    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T>[] s = this.subscribers;\n        int n = s.length;\n        Subscriber<? super T> a = this.downstream;\n        for(;;\n) {\n            long r = requested.get();\n            long e = 0;\n            middle: while (e != r) {\n                        if (cancelled) {\n                            cleanup();\n                            return;\n                        }\n\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            cleanup();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean d = done.get() == 0;\n                        boolean empty = true;\n                        for(int i = 0;\ni < s.length;\ni++) {\n                            JoinInnerSubscriber<T> inner = s[ i];\n                            SimplePlainQueue<T> q = inner.queue;\n                            if (q != null) {\n                                T v = q.poll();\n                                if (v != null) {\n                                    empty = false;\n                                    a.onNext(v);\n                                    inner.requestOne();\n                                    if (++ e == r) {\n                                        break middle;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (d && empty) {\n                            a.onComplete();\n                            return;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n                    }\n\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for(int i = 0;\ni < n;\ni++) {\n                    JoinInnerSubscriber<T> inner = s[ i];\n                    SimpleQueue<T> q = inner.queue;\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "260", "src_id": "M1399", "code": "\n    @Override\n    public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        InnerQueuedSubscriber<R> inner = current;\n        Subscriber<? super R> a = downstream;\n        ErrorMode em = errorMode;\n        for(;;\n) {\n            long r = requested.get();\n            long e = 0L;\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean outerDone = done;\n                inner = subscribers.poll();\n                if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n\n            boolean continueNextSource = false;\n            if (inner != null) {\n                SimpleQueue<R> q = inner.queue();\n                if (q != null) {\n                    while (e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        R v;\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        boolean empty = q.isEmpty();\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n\n            if (continueNextSource) {\n                continue;\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "261", "src_id": "M469", "code": "\n    @ SuppressWarnings(\"unchecked\" ) void remove(CacheDisposable<T> consumer) {\n        for(;;\n) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for(int i = 0;\ni < n;\ni++) {\n                if (current[ i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "262", "src_id": "M362", "code": "\n    void drainFused() {\n        int missed = 1;\n        for(;;\n) {\n            if (disposed) {\n                return;\n            }\n\n            boolean d = done;\n            Throwable ex = error;\n            if (!delayError && d\n                    && ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n\n            downstream.onNext(null);\n            if (d) {\n                disposed = true;\n                ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n\n                worker.dispose();\n                return;\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "263", "src_id": "M2247", "code": "\n    @ SuppressWarnings(\"unchecked\" ) void remove(PublishSubscription<T> ps) {\n        for(;;\n) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = -1;\n            for(int i = 0;\ni < n;\ni++) {\n                if (a[ i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "264", "src_id": "M1086", "code": "\n    public static AdminServer createAdminServer() {\n        if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            try {\n                Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n                return (AdminServer) adminServer;\n            } catch (ClassNotFoundException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n              catch (InstantiationException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n              catch (IllegalAccessException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n              catch (InvocationTargetException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n              catch (NoSuchMethodException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            }\n              catch (NoClassDefFoundError e) {\n                LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n            }\n        }\n        return new DummyAdminServer();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "265", "src_id": "M1149", "code": "\n    public void run() {\n        try {\n            while(!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                }\n                  catch (Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n\n                // Close connections still pending on the selector. Any others\n                // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n            SocketChannel accepted;\n            while((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n            updateQueue.clear();\n        }\n            finally {\n            closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "266", "src_id": "M219", "code": "\n    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime)throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n            zkMap.put(connectionId, zk);\n\n           // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n        return zk;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "267", "src_id": "M192", "code": "\n    private void init()throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n\n    // if we have read data from the file, and it matches the timep pattern\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n\n    /*\n      Count number of log entries. Any line starting with a timestamp counts as an entry\n    */\n        String lastentry = line;\n        try {\n            while(line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n                    lastentry = line;\n                }\n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n        }\nfinally {\n            in.close();\n        }\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "268", "src_id": "M235", "code": "\n    @POST @ Produces({MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML})\n    public Response createSession(@ QueryParam(\"op\" ) String op, @ DefaultValue(\"5\" )@ QueryParam(\"expire\" ) String expire, @Context UriInfo ui) {\n        if (!op.equals(\"create\")) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n        }\n        int expireInSeconds;\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n        String uuid = UUID.randomUUID().toString();\n        while(ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n\n        // establish the connection to the ZooKeeper cluster\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n        URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n        return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "269", "src_id": "M942", "code": "\n    public void schedule(WorkRequest workRequest, long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n\n        // If we have a worker thread pool, use that; otherwise, do the work\n        // directly.\n        int size = workers.size();\n        if (size > 0) {\n            try {\n                // make sure to map negative ids as well to [0, size-1]\n                int workerNum = ((int)(id % size)\n+ size) % size;\n                ExecutorService worker = workers.get(workerNum);\n                worker.execute(scheduledWorkRequest);\n            } catch (RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n            }\n        } else {\n            // When there is no worker thread pool, do the work directly\n            // and wait for its completion\n            scheduledWorkRequest.run();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "270", "src_id": "M520", "code": "\n    @Override\n    public void close()throws IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        }\nfinally {\n            if (success) {\n                boolean renamed = tmpFile.renameTo(origFile);\n                if (!renamed) {\n                    // On windows, renameTo does not replace.\n                    if (!origFile.delete()|| !tmpFile.renameTo(origFile)) {\n                        throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                    }\n                }\n            } else {\n                if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                    IOUtils.closeStream(out);\n                }\n                // close wasn't successful, try to delete the tmp file\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "271", "src_id": "M186", "code": "\n    synchronized private LogEntry readNextEntry() {\n        try {\n            try {\n                while(true) {\n                    String line = in.readLine();\n                    if (line == null) {\n                        break;\n                    }\n                    Matcher m = src.timep.matcher(line);\n                    if (m.lookingAt()) {\n                        if (buf.length() > 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n                            return e;\n                        }\n                        buf = line;\n                    } else if (buf.length() > 0) {\n                               buf += line + \"\\n\";\n                           }\n                }\n            } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n            if (buf.length() > 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n                return e;\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "272", "src_id": "M478", "code": "\n    public static void main(String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n        if (op.equalsIgnoreCase(\"gettracemask\")) {\n            getTraceMask(host, port);\n        } else if (op.equalsIgnoreCase(\"settracemask\")) {\n                   setTraceMask(host, port, args[3]);\n        } else if (op.equalsIgnoreCase(\"ruok\")) {\n                   ruok(host, port);\n               } else if (op.equalsIgnoreCase(\"kill\")) {\n                          kill(host, port);\n               } else if (op.equalsIgnoreCase(\"stat\")) {\n                          stat(host, port);\n                      } else if (op.equalsIgnoreCase(\"dump\")) {\n                                 dump(host, port);\n                      } else {\n                                 System.out.println(\"Unrecognized op: \" + op);\n                      }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "273", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    Thread thread = Thread.currentThread();\n    notifyPostProcessing(1);\n\n    if (DEBUG) {\n        thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n\n    Exception exception = null;\n    try {\n        psAlgorithm.run(this);\n    } catch (Exception err) {\n      Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n      if (err instanceof InterruptedIOException||err instanceof ClosedByInterruptException||thread.isInterrupted()) {\n          notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n          return;\n      }\n\n      if (errCode == ERROR_NOTHING) errCode = ERROR_POSTPROCESSING;\n      exception = err;\n    }\n\nfinally {\n        notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n\n        if (exception == null) exception = errObject;\n        notifyError(ERROR_POSTPROCESSING, exception);\n        return;\n    }\n\n    notifyFinished();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "274", "src_id": "M1031", "code": "\n    void establishConnection(int threadId,HttpURLConnection conn) throws IOException, HttpError {\n    int statusCode = conn.getResponseCode();\n    if (DEBUG) {\n        Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n        Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n        Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n        Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n    }\n\n    switch(statusCode) {\n        case 204: case 205: case 207:\n        throw new HttpError(statusCode);\n                       case 416:\n        return;// let the download thread handle this error\n                       default:\n        if (statusCode < 200 ||statusCode > 299) {\n        throw new HttpError(statusCode);\n        }\n\n}\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "275", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n    if (b == null) {\n        return null;\n    }\n    final Elst obj = new Elst();\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n        obj.bMediaRate = 0x00010000; // default media rate (1.0)\n        return obj;\n    }\n\n    if (v1) {\n        stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n        obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n        stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE* 2));\n    } else {\n      stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n      obj.mediaTime = stream.readInt();\n    }\n\n    obj.bMediaRate = stream.readInt();\n    return obj;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "276", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n    boolean done;\n    long start = mMission.fallbackResumeOffset;\n    if (DEBUG&& !mMission.unknownLength&& start > 0) {\n        Log.i(TAG, \"Resuming a single-thread download at \" + start);\n    }\n\n    try {\n        long rangeStart = (mMission.unknownLength||start < 1) ? -1 : start;\n        int mId = 1;\n        mConn = mMission.openConnection(false, rangeStart, -1);\n\n        if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n        mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n        }\n\n        mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n\n        if (mConn.getResponseCode() == 416 && start > 0) {\n        mMission.notifyProgress(-start);\n        start = 0;\n        mRetryCount--;\n        throw new DownloadMission . HttpError(416);\n        }\n\n            // secondary check for the file length\n\n        if (!mMission.unknownLength) mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n\n        if (mMission.unknownLength||mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n        mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0 ];\n        }\n\n        mF = mMission.storage.getStream();\n        mF.seek(mMission.offsets[mMission.current] + start);\n        mIs = mConn.getInputStream();\n        byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n        int len = 0;\n        while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n        mF.write(buf, 0, len);\n        start += len;\n        mMission.notifyProgress(len);\n        }\n\n        dispose();\n\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n        done = len == -1;\n    } catch (Exception e) {\n      dispose();\n      mMission.fallbackResumeOffset = start;\n\n      if (!mMission.running||e instanceof ClosedByInterruptException) return;\n\n      if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n          dispose();\n          mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n          return;\n      }\n\n      if (mRetryCount ++ >= mMission.maxRetry) {\n          mMission.notifyError(e);\n          return;\n      }\n\n      if (DEBUG) {\n          Log.e(TAG, \"got exception, retrying...\", e);\n      }\n\n      run();// try again\n      return;\n    }\n\n    if (done) {\n        mMission.notifyFinished();\n    } else {\n      mMission.fallbackResumeOffset = start;\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "277", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws IOException {\n\n    if (aux.length < 1) {\n        return;\n    }\n\n    out.flush();\n    aux.flush();\n    boolean underflow = aux.offset <aux.length||out.offset <out.length;\n    byte[] buffer = new byte[COPY_BUFFER_SIZE];\n    aux.target.seek(0);\n    out.target.seek(out.length);\n    long length = amount;\n    while (length > 0) {\n        int read = (int) Math.min(length, Integer.MAX_VALUE);\n        read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n        if (read < 1) {\n                           amount -= length;\n                           break;\n        }\n\n        out.writeProof(buffer, read);\n        length -= read;\n    }\n\n    if (underflow) {\n\n        if (out.offset >= out.length) {\n                // calculate the aux underflow pointer\n\n                       if (aux.offset <amount) {\n                                          out.offset += aux.offset;\n                                          aux.offset = 0;\n                                          out.target.seek(out.offset);\n                       } else {\n                         aux.offset -= amount;\n                         out.offset = out.length + amount;\n                       }\n        } else {\n          aux.offset = 0;\n        }\n    } else {\n      out.offset += amount;\n      aux.offset -= amount;\n    }\n\n    out.length += amount;\n\n    if (out.length > maxLengthKnown) {\n        maxLengthKnown = out.length;\n    }\n\n    if (amount <aux.length) {\n            // move the excess data to the beginning of the file\n        long readOffset = amount;\n        long writeOffset = 0;\n        aux.length -= amount;\n        length = aux.length;\n        while (length > 0) {\n        int read = (int) Math.min(length, Integer.MAX_VALUE);\n        read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n        aux.target.seek(writeOffset);\n        aux.writeProof(buffer, read);\n        writeOffset += read;\n        readOffset += read;\n        length -= read;\n        aux.target.seek(readOffset);\n        }\n\n        aux.target.setLength(aux.length);\n        return;\n    }\n\n    if (aux.length > THRESHOLD_AUX_LENGTH) {\n        aux.target.setLength(THRESHOLD_AUX_LENGTH);// or setLength(0);\n    }\n\n    aux.reset();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "278", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action,\n                           @StringRes int reason) {\n    StringBuilder request = new StringBuilder(256);\n    request.append(mission.source);\n    request.append(\" [\");\n\n    if (mission.recoveryInfo != null) {\n        for (MissionRecoveryInfo recovery : mission.recoveryInfo) request.append(' ').append(recovery.toString()).append(' ');\n    }\n\n    request.append(\"]\");\n    String service;\n    try {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e) {\n      service = ErrorInfo.SERVICE_NONE;\n    }\n\n    ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "279", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n    synchronized(this) {\n        mission.timestamp = System.currentTimeMillis();\n        mission.mHandler = mHandler;\n        mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n        while (true) {\n        mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n\n        if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                         try {\n\n            if (!mission.metadata.createNewFile()) throw new RuntimeException(\"Cant create download metadata file\");\n                         } catch (IOException e) {\n                           throw new RuntimeException(e);\n                         }\n\n                         break;\n        }\n\n        mission.timestamp = System.currentTimeMillis();\n        }\n\n        mSelfMissionsControl = true;\n        mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n        Utility.writeToFile(mission.metadata, mission);\n\n        if (mission.storage == null) {\n                // noting to do here\n        mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n\n        if (mission.errObject != null) mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n        return;\n        }\n        boolean start = !mPrefQueueLimit||getRunningMissionsCount() < 1;\n        if (canDownloadInCurrentNetwork() && start) {\n        mission.start();\n        }\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "280", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out,SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n    String format = getArgumentAt(0, null);\n    boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n    if (format == null ||format.equals(\"ttml\")) {\n        SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n        try {\n        writer.build(sources[0 ]);\n        } catch (Exception err) {\n          Log.e(TAG, \"subtitle parse failed\", err);\n          return err instanceof IOException ? 1 : 8;\n        }\n        return OK_RESULT;\n    } else if (format.equals(\"srt\")) {\n                                                                               byte[] buffer = new byte[8* 1024];\n                                                                               int read;\n                                                                               while ((read = sources[0 ].read(buffer)) > 0) {\n               out.write(buffer, 0, read);\n                                                                               }\n                                                                               return OK_RESULT;\n           }\n\n    throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "281", "src_id": "M1047", "code": "\n    private void joinForThreads(int millis) {\n    final Thread currentThread = Thread.currentThread();\n    if (init != null&& init != currentThread&& init.isAlive()) {\n        init.interrupt();\n\n        if (millis > 0) {\n                                                                   try {\n            init.join(millis);\n                                                                   } catch (InterruptedException e) {\n                                                                     Log.w(TAG, \"Initializer thread is still running\", e);\n                                                                     return;\n                                                                   }\n        }\n    }\n\n        // if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n    for (Thread thread : threads) {\n\n        if (!thread.isAlive()||thread == Thread.currentThread()) continue;\n        thread.interrupt();\n    }\n\n    try {\n        for (Thread thread : threads) {\n\n        if (!thread.isAlive()) continue;\n\n        if (DEBUG) {\n                                          Log.w(TAG, \"thread alive: \" + thread.getName());\n        }\n\n        if (millis > 0) thread.join(millis);\n        }\n    } catch (InterruptedException e) {\n      throw new RuntimeException(\"A download thread is still running\", e);\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "282", "src_id": "M66", "code": "\n    void drain() {\n\n    if (getAndIncrement() != 0) {\n        return;\n    }\n    int missed = 1;\n\n    Observer<? super R> downstream = this.downstream;\n\n    AtomicThrowable errors = this.errors;\n\n    AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n    for(;;\n) {\n        for(;;\n) {\n\n      if (cancelled) {\n      return;\n      }\n\n      if (errors.get() != null) {\n\n      if (!delayErrors) {\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n      }\n      }\n      boolean d = done;\n\n      SwitchMapMaybeObserver<R> current = inner.get();\n      boolean empty = current == null;\n      if (d && empty) {\n      errors.tryTerminateConsumer(downstream);\n      return;\n      }\n\n      if (empty||current.item == null) {\n      break;\n      }\n\n      inner.compareAndSet(current, null);\n      downstream.onNext(current.item);\n        }\n\n        missed = addAndGet(-missed);\n\n        if (missed == 0) {\n      break;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "283", "src_id": "M1333", "code": "\n    @Override\n    public void onNext(T t) {\n\n    if (done) {\n        return;\n    }\n    boolean b;\n    try {\n        b = predicate.test(t);\n    } catch (Throwable e) {\n      Exceptions.throwIfFatal(e);\n      upstream.cancel();\n      upstream = SubscriptionHelper.CANCELLED;\n      onError(e);\n      return;\n    }\n\n    if (!b) {\n        done = true;\n        upstream.cancel();\n        upstream = SubscriptionHelper.CANCELLED;\n        downstream.onSuccess(false);\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "284", "src_id": "M522", "code": "\n    void drainLoop() {\n    Observer<? super T> actual = this.downstream;\n    int missed = 1;\n    for(;;\n) {\n        for(;;\n) {\n\n      if (disposed) {\n      singleItem = null;\n      queue = null;\n      return;\n      }\n\n      if (errors.get() != null) {\n      singleItem = null;\n      queue = null;\n      errors.tryTerminateConsumer(actual);\n      return;\n      }\n      int os = otherState;\n      if (os == OTHER_STATE_HAS_VALUE) {\n      T v = singleItem;\n      singleItem = null;\n      otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n      os = OTHER_STATE_CONSUMED_OR_EMPTY;\n      actual.onNext(v);\n      }\n      boolean d = mainDone;\n\n      SimplePlainQueue<T> q = queue;\n\n      T v = q != null ? q.poll() : null;\n      boolean empty = v == null;\n      if (d&& empty&& os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n      queue = null;\n      actual.onComplete();\n      return;\n      }\n\n      if (empty) {\n      break;\n      }\n\n      actual.onNext(v);\n        }\n\n        missed = addAndGet(-missed);\n\n        if (missed == 0) {\n      break;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "285", "src_id": "M1163", "code": "\n    @Override\n    void drain() {\n\n    if (getAndIncrement() != 0) {\n        return;\n    }\n    int missed = 1;\n    final SimplePlainQueue<Object> queue = this.queue;\n    final Subscriber<? super Flowable<T>> downstream = this.downstream;\n\n    UnicastProcessor<T> window = this.window;\n    for(;;\n) {\n\n                     if (upstreamCancelled) {\n      queue.clear();\n      window = null;\n      this.window = null;\n                     } else {\n                       boolean isDone = done;\n\n                       Object o = queue.poll();\n                       boolean isEmpty = o == null;\n                       if (isDone && isEmpty) {\n                                Throwable ex = error;\n                                if (ex != null) {\n\n                                                  if (window != null) {\n                                                    window.onError(ex);\n                                                  }\n\n                                                  downstream.onError(ex);\n                                } else {\n\n                                  if (window != null) {\n                                           window.onComplete();\n                                  }\n\n                                  downstream.onComplete();\n                                }\n\n                                cleanupResources();\n                                upstreamCancelled = true;\n                                continue;\n                       } else if (!isEmpty) {\n\n                                if (o instanceof WindowBoundaryRunnable) {\n                                                WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                                                if (boundary.index == emitted||!restartTimerOnMaxSize) {\n                                                                             this.count = 0;\n                                                                             window = createNewWindow(window);\n                                                }\n                                } else if (window != null) {\n                                                @SuppressWarnings(\"unchecked\" ) T item = (T) o;\n                                                window.onNext(item);\n                                                long count = this.count + 1;\n                                                if (count == maxSize) {\n                                                               this.count = 0;\n                                                               window = createNewWindow(window);\n                                                } else {\n                                                  this.count = count;\n                                                }\n                                       }\n\n                                continue;\n                              }\n                     }\n\n                     missed = addAndGet(-missed);\n\n                     if (missed == 0) {\n      break;\n                     }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "286", "src_id": "M478", "code": "\n    void drain() {\n\n    if (getAndIncrement() != 0) {\n        return;\n    }\n    int missed = 1;\n\n    EqualObserver<T>[] as = observers;\n    final EqualObserver<T> observer1 = as[0 ];\n    final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n    final EqualObserver<T> observer2 = as[1 ];\n    final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n    for(;;\n) {\n        for(;;\n) {\n\n      if (cancelled) {\n      q1.clear();\n      q2.clear();\n      return;\n      }\n      boolean d1 = observer1.done;\n      if (d1) {\n      Throwable e = observer1.error;\n      if (e != null) {\n                  cancel(q1, q2);\n                  downstream.onError(e);\n                  return;\n      }\n      }\n      boolean d2 = observer2.done;\n      if (d2) {\n      Throwable e = observer2.error;\n      if (e != null) {\n                  cancel(q1, q2);\n                  downstream.onError(e);\n                  return;\n      }\n      }\n\n      if (v1 == null) {\n      v1 = q1.poll();\n      }\n      boolean e1 = v1 == null;\n      if (v2 == null) {\n      v2 = q2.poll();\n      }\n      boolean e2 = v2 == null;\n      if (d1&& d2&& e1&& e2) {\n      downstream.onSuccess(true);\n      return;\n      }\n\n      if ((d1 && d2) && (e1 != e2)) {\n      cancel(q1, q2);\n      downstream.onSuccess(false);\n      return;\n      }\n\n      if (!e1 && !e2) {\n      boolean c;\n      try {\n          c = comparer.test(v1, v2);\n      } catch (Throwable ex) {\n        Exceptions.throwIfFatal(ex);\n        cancel(q1, q2);\n        downstream.onError(ex);\n        return;\n      }\n\n      if (!c) {\n                          cancel(q1, q2);\n                          downstream.onSuccess(false);\n                          return;\n      }\n\n      v1 = null;\n      v2 = null;\n      }\n\n      if (e1||e2) {\n      break;\n      }\n        }\n\n        missed = addAndGet(-missed);\n\n        if (missed == 0) {\n      break;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "287", "src_id": "M885", "code": "\n    void drainLoop() {\n    int missed = 1;\n\n    JoinInnerSubscriber<T>[] s = this.subscribers;\n    int n = s.length;\n\n    Subscriber<? super T> a = this.downstream;\n    for(;;\n) {\n        long r = requested.get();\n        long e = 0;\n        middle: while (e != r) {\n\n      if (cancelled) {\n                                   cleanup();\n                                   return;\n      }\n\n      Throwable ex = errors.get();\n      if (ex != null) {\n                                   cleanup();\n                                   a.onError(ex);\n                                   return;\n      }\n      boolean d = done.get() == 0;\n      boolean empty = true;\n      for(int i = 0;i <s.length;\ni++ ) {\n                                   JoinInnerSubscriber<T> inner = s[i];\n\n                                   SimplePlainQueue<T> q = inner.queue;\n                                   if (q != null) {\n          T v = q.poll();\n          if (v != null) {\n                                                      empty = false;\n                                                      a.onNext(v);\n                                                      inner.requestOne();\n\n                                                      if (++e == r) {\n                             break middle;\n                                                      }\n          }\n                                   }\n      }\n\n      if (d && empty) {\n                                   a.onComplete();\n                                   return;\n      }\n\n      if (empty) {\n                                   break;\n      }\n                }\n\n        if (e == r) {\n\n      if (cancelled) {\n                        cleanup();\n                        return;\n      }\n\n      Throwable ex = errors.get();\n      if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n      }\n      boolean d = done.get() == 0;\n      boolean empty = true;\n      for(int i = 0;i <n;\ni++ ) {\n                        JoinInnerSubscriber<T> inner = s[i];\n\n                        SimpleQueue<T> q = inner.queue;\n                        if (q != null && !q.isEmpty()) {\n          empty = false;\n          break;\n                        }\n      }\n\n      if (d && empty) {\n                        a.onComplete();\n                        return;\n      }\n        }\n\n        if (e != 0) {\n      BackpressureHelper.produced(requested, e);\n        }\n\n        missed = addAndGet(-missed);\n\n        if (missed == 0) {\n      break;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "288", "src_id": "M1399", "code": "\n    @Override\n    public void drain() {\n\n    if (getAndIncrement() != 0) {\n        return;\n    }\n    int missed = 1;\n\n    InnerQueuedSubscriber<R> inner = current;\n\n    Subscriber<? super R> a = downstream;\n\n    ErrorMode em = errorMode;\n    for(;;\n) {\n        long r = requested.get();\n        long e = 0L;\n        if (inner == null) {\n\n      if (em != ErrorMode.END) {\n                               Throwable ex = errors.get();\n                               if (ex != null) {\n                                   cancelAll();\n                                   errors.tryTerminateConsumer(downstream);\n                                   return;\n                               }\n      }\n      boolean outerDone = done;\n      inner = subscribers.poll();\n\n      if (outerDone && inner == null) {\n                               errors.tryTerminateConsumer(downstream);\n                               return;\n      }\n\n      if (inner != null) {\n                               current = inner;\n      }\n        }\n        boolean continueNextSource = false;\n        if (inner != null) {\n      SimpleQueue<R> q = inner.queue();\n      if (q != null) {\n                               while (e != r) {\n\n                         if (cancelled) {\n                                                  cancelAll();\n                                                  return;\n                         }\n\n                         if (em == ErrorMode.IMMEDIATE) {\n                                                  Throwable ex = errors.get();\n                                                  if (ex != null) {\n                                                            current = null;\n                                                            inner.cancel();\n                                                            cancelAll();\n                                                            errors.tryTerminateConsumer(downstream);\n                                                            return;\n                                                  }\n                         }\n                         boolean d = inner.isDone();\n\n                         R v;\n                         try {\n                                   v = q.poll();\n                         } catch (Throwable ex) {\n                           Exceptions.throwIfFatal(ex);\n                           current = null;\n                           inner.cancel();\n                           cancelAll();\n                           a.onError(ex);\n                           return;\n                         }\n                         boolean empty = v == null;\n                         if (d && empty) {\n                                                  inner = null;\n                                                  current = null;\n                                                  upstream.request(1);\n                                                  continueNextSource = true;\n                                                  break;\n                         }\n\n                         if (empty) {\n                                                  break;\n                         }\n\n                         a.onNext(v);\n                         e++;\n                         inner.request(1L);\n                               }\n\n                               if (e == r) {\n\n                         if (cancelled) {\n                                               cancelAll();\n                                               return;\n                         }\n\n                         if (em == ErrorMode.IMMEDIATE) {\n                                               Throwable ex = errors.get();\n                                               if (ex != null) {\n                                                            current = null;\n                                                            inner.cancel();\n                                                            cancelAll();\n                                                            errors.tryTerminateConsumer(downstream);\n                                                            return;\n                                               }\n                         }\n                         boolean d = inner.isDone();\n                         boolean empty = q.isEmpty();\n                         if (d && empty) {\n                                               inner = null;\n                                               current = null;\n                                               upstream.request(1);\n                                               continueNextSource = true;\n                         }\n                               }\n      }\n        }\n\n        if (e != 0L && r != Long.MAX_VALUE) {\n      requested.addAndGet(-e);\n        }\n\n        if (continueNextSource) {\n      continue;\n        }\n\n        missed = addAndGet(-missed);\n\n        if (missed == 0) {\n      break;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "289", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\" ) void remove(CacheDisposable<T> consumer) {\n    for(;;\n) {\n                                                                                 CacheDisposable<T>[] current = observers.get();\n                                                                                 int n = current.length;\n                                                                                 if (n == 0) {\n      return;\n                                                                                 }\n                                                                                 int j = -1;\n                                                                                 for(int i = 0;i <n;\ni++ ) {\n\n      if (current[i] == consumer) {\n          j = i;\n          break;\n      }\n                                                                                 }\n\n                                                                                 if (j < 0) {\n      return;\n                                                                                 }\n\n                                                                                 CacheDisposable<T>[] next;\n                                                                                 if (n == 1) {\n      next = EMPTY;\n                                                                                 } else {\n                                                                                   next = new CacheDisposable[n - 1];\n                                                                                   System.arraycopy(current, 0, next, 0, j);\n                                                                                   System.arraycopy(current, j + 1, next, j, n - j - 1);\n                                                                                 }\n\n                                                                                 if (observers.compareAndSet(current, next)) {\n      return;\n                                                                                 }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "290", "src_id": "M362", "code": "\n    void drainFused() {\n    int missed = 1;\n    for(;;\n) {\n\n                          if (disposed) {\n      return;\n                          }\n                          boolean d = done;\n\n                          Throwable ex = error;\n                          if (!delayError&& d&& ex != null) {\n      disposed = true;\n      downstream.onError(error);\n      worker.dispose();\n      return;\n                          }\n\n                          downstream.onNext(null);\n\n                          if (d) {\n      disposed = true;\n      ex = error;\n\n      if (ex != null) {\n                                     downstream.onError(ex);\n      } else {\n        downstream.onComplete();\n      }\n\n      worker.dispose();\n      return;\n                          }\n\n                          missed = addAndGet(-missed);\n\n                          if (missed == 0) {\n      break;\n                          }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "291", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\" ) void remove(PublishSubscription<T> ps) {\n    for(;;\n) {\n                                                                               PublishSubscription<T>[] a = subscribers.get();\n                                                                               if (a == TERMINATED||a == EMPTY) {\n      return;\n                                                                               }\n                                                                               int n = a.length;\n                                                                               int j = -1;\n                                                                               for(int i = 0;i <n;\ni++ ) {\n\n      if (a[i] == ps) {\n          j = i;\n          break;\n      }\n                                                                               }\n\n                                                                               if (j < 0) {\n      return;\n                                                                               }\n\n                                                                               PublishSubscription<T>[] b;\n                                                                               if (n == 1) {\n      b = EMPTY;\n                                                                               } else {\n                                                                                 b = new PublishSubscription[n - 1];\n                                                                                 System.arraycopy(a, 0, b, 0, j);\n                                                                                 System.arraycopy(a, j + 1, b, j, n - j - 1);\n                                                                               }\n\n                                                                               if (subscribers.compareAndSet(a, b)) {\n      return;\n                                                                               }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "292", "src_id": "M31", "code": "\n    private JsonNode validateLicense(String licenseKey, String machineFingerprint,LicenseContext context) throws Exception {\n    String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n\n    HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")\n                        // .header(\"Authorization\", \"License \" + licenseKey).POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n    JsonNode jsonResponse = objectMapper.readTree(response.body());\n    if (response.statusCode() == 200) {\n        JsonNode metaNode = jsonResponse.path(\"meta\");\n        boolean isValid = metaNode.path(\"valid\").asBoolean();\n\n        String detail = metaNode.path(\"detail\").asText();\n\n        String code = metaNode.path(\"code\").asText();\n        log.info(\"License validity: {}\", isValid);\n        log.info(\"Validation detail: {}\", detail);\n        log.info(\"Validation code: {}\", code);\n\n            // Check if the license itself has floating attribute\n        JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n        if (!licenseAttrs.isMissingNode()) {\n                                          context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                                          context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                                          log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n        }\n\n            // Also check the policy for floating license support if included\n\n        JsonNode includedNode = jsonResponse.path(\"included\");\n\n        JsonNode policyNode = null;\n        if (includedNode.isArray()) {\n                                          for (JsonNode node : includedNode) {\n\n                                        if (\"policies\".equals(node.path(\"type\").asText())) {\n                                                                                 policyNode = node;\n                                                                                 break;\n                                        }\n                                          }\n        }\n\n        if (policyNode != null) {\n                // Check if this is a floating license from policy\n                                          boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                                          int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n                // Policy takes precedence over license attributes\n                                          if (policyFloating) {\n                                    context.isFloatingLicense = true;\n                                    context.maxMachines = policyMaxMachines;\n                                          }\n\n                                          log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n        }\n\n            // Extract user count, default to 1 if not specified\n        int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n        applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n        context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n        log.debug(applicationProperties.toString());\n    } else {\n      log.error(\"Error validating license. Status code: {}\", response.statusCode());\n    }\n    return jsonResponse;\n    }\n\n", "compilable": false, "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "293", "src_id": "M488", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\") @Operation(summary = \"Convert a file to a PDF using LibreOffice\", description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n    MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n\n    File file = null;\n    try {\n        file = convertToPdf(inputFile);\n        PDDocument doc = pdfDocumentFactory.load(file);\n        return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n    }\n\nfinally {\n\n        if (file != null) file.delete();\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "294", "src_id": "M625", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "295", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile,LicenseContext context) {\n    try {\n        String encodedPayload = licenseFile;\n            // Remove the header\n        encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n        encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n        encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n        byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n\n        String payload = new String(payloadBytes);\n        log.info(\"Decoded certificate payload: {}\", payload);\n        String encryptedData = \"\";\n\n        String encodedSignature = \"\";\n\n        String algorithm = \"\";\n        try {\n        JSONObject attrs = new JSONObject(payload);\n        encryptedData = (String) attrs.get(\"enc\");\n        encodedSignature = (String) attrs.get(\"sig\");\n        algorithm = (String) attrs.get(\"alg\");\n        } catch (JSONException e) {\n          log.error(\"Failed to parse license file: {}\", e.getMessage());\n          return false;\n        }\n\n            // Verify license file algorithm\n\n        if (!\"base64+ed25519\".equals(algorithm)) {\n        log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n        return false;\n        }\n\n            // Verify signature\n        boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n        if (!isSignatureValid) {\n        log.error(\"License file signature is invalid\");\n        return false;\n        }\n\n        log.info(\"License file signature is valid\");\n\n            // Decode the base64 data\n        String decodedData;\n        try {\n        decodedData = new String(Base64.getDecoder().decode(encryptedData));\n        } catch (IllegalArgumentException e) {\n          log.error(\"Failed to decode license data: {}\", e.getMessage());\n          return false;\n        }\n\n            // Process the certificate data\n        boolean isValid = processCertificateData(decodedData, context);\n        return isValid;\n    } catch (Exception e) {\n      log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n      return false;\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "296", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize,TempFileManager tempFileManager) throws IOException {\n    try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager) ) {\n        try (ZipInputStream zipIn =ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath))) ) {\n        ZipEntry entry = zipIn.getNextEntry();\n        while (entry != null) {\n            Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n            if (!entry.isDirectory()) {\n                                  Files.createDirectories(filePath.getParent());\n\n                                  if (entry.getName().toLowerCase().endsWith(\".html\")||entry.getName().toLowerCase().endsWith(\".htm\")) {\n                                          String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n\n                                          String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                                          Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                                  } else {\n                                    Files.copy(zipIn, filePath);\n                                  }\n            }\n\n            zipIn.closeEntry();\n            entry = zipIn.getNextEntry();\n        }\n        }\n\n            // Repack the sanitized files\n\n        zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n    } // tempUnzippedDir auto-cleaned\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "297", "src_id": "M317", "code": "\n    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption,boolean autoRotate) throws IOException {\n    boolean imageIsLandscape = image.getWidth() > image.getHeight();\n\n    PDRectangle pageSize = PDRectangle.A4;\n    if (autoRotate && imageIsLandscape) {\n        pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n    }\n\n    if (\"fitDocumentToImage\".equals(fitOption)) {\n        pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n    }\n\n    PDPage page = new PDPage(pageSize);\n    doc.addPage(page);\n    float pageWidth = page.getMediaBox().getWidth();\n    float pageHeight = page.getMediaBox().getHeight();\n    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true) ) {\n\n        if (\"fillPage\".equals(fitOption)||\"fitDocumentToImage\".equals(fitOption)) {\n        contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n        } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                                                                                                                     float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                                                                                                                     float pageAspectRatio = pageWidth / pageHeight;\n                                                                                                                     float scaleFactor = 1.0f;\n                                                                                                                     if (imageAspectRatio > pageAspectRatio) {\n                                                                scaleFactor = pageWidth / image.getWidth();\n                                                                                                                     } else {\n                                                                                                                       scaleFactor = pageHeight / image.getHeight();\n                                                                                                                     }\n                                                                                                                     float xPos = (pageWidth - (image.getWidth() *scaleFactor)) / 2;\n                                                                                                                     float yPos = (pageHeight - (image.getHeight() *scaleFactor)) / 2;\n                                                                                                                     contentStream.drawImage(image, xPos, yPos, image.getWidth() *scaleFactor, image.getHeight() *scaleFactor);\n               }\n    } catch (IOException e) {\n                                                                                                                                            log.error(\"Error adding image to PDF\", e);\n                                                                                                                                            throw e;\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "298", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n    try {\n            // Get the MAC address\n        StringBuilder sb = new StringBuilder();\n\n        InetAddress ip = InetAddress.getLocalHost();\n\n        NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n        if (network == null) {\n        Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n        while (networks.hasMoreElements()) {\n            NetworkInterface net = networks.nextElement();\n            byte[] mac = net.getHardwareAddress();\n            if (mac != null) {\n                                               for(int i = 0;i <mac.length;\n                i++ ) {\n                                 sb.append(String.format(\"%02X\", mac[i]));\n                                               }\n\n                                               break; // Use the first network interface with a MAC address\n            }\n        }\n        } else {\n          byte[] mac = network.getHardwareAddress();\n          if (mac != null) {\n                   for(int i = 0;i <mac.length;\n              i++ ) {\n                               sb.append(String.format(\"%02X\", mac[i]));\n                   }\n          }\n        }\n\n            // Hash the MAC address for privacy and consistency\n\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n        StringBuilder fingerprint = new StringBuilder();\n        for (byte b : hash) {\n        fingerprint.append(String.format(\"%02x\", b));\n        }\n        return fingerprint.toString();\n    } catch (Exception e) {\n      return \"GenericID\";\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "299", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf,PdfMetadata pdfMetadata) {\n    String title = pdfMetadata.getTitle();\n    pdf.getDocumentInformation().setTitle(title);\n    pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n        author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n\n        if (userService != null) {\n                                                                                                                                  author = author.replace(\"username\", userService.getCurrentUsername());\n        }\n    }\n\n    pdf.getDocumentInformation().setAuthor(author);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "300", "src_id": "M128", "code": "\n    @Bean(name = \"machineType\" )\n    public String determineMachineType() {\n    try {\n        boolean isDocker = runningInDocker();\n        boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n        boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n        if (isKubernetes) {\n        return \"Kubernetes\";\n        } else if (isDocker) {\n          return \"Docker\";\n        } else if (isBrowserOpen) {\n          String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n          if (os.contains(\"win\")) {\n                                      return \"Client-windows\";\n          } else if (os.contains(\"mac\")) {\n            return \"Client-mac\";\n          } else {\n            return \"Client-unix\";\n          }\n               } else {\n                 return \"Server-jar\";\n               }\n    } catch (Exception e) {\n      return \"Unknown\";\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "301", "src_id": "M101", "code": "\n    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response,FilterChain filterChain) throws IOException, ServletException {\n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n        filterChain.doFilter(request, response);\n    } else {\n      long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n      response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n      response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n      response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n    }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "302", "src_id": "M31", "code": "\n    private JsonNode validateLicense(String licenseKey, String machineFingerprint , LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\",\nlicenseKey,\nmachineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n            .header(\"Content-Type\", \"application/vnd.api+json\")\n                .header(\"Accept\", \"application/vnd.api+json\")\n                        // .header(\"Authorization\", \"License \" + licenseKey)\n                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                        .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() == 200) {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\",\n                    context.isFloatingLicense,\n                    context.maxMachines);\n            }\n\n            // Also check the policy for floating license support if included\n\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\")\n                    .asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\")\n                    .asInt(1);\n\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n\n                log.info(\"License floating (from policy): {}, maxMachines: {}\",\n                    context.isFloatingLicense,\n                    context.maxMachines);\n            }\n\n            // Extract user count, default to 1 if not specified\n\n            int users = jsonResponse.path(\"data\").path(\"attributes\")\n                .path(\"metadata\")\n                    .path(\"users\")\n                        .asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\")\n                .path(\"metadata\")\n                    .path(\"isEnterprise\")\n                        .asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } else {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n        return jsonResponse;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "303", "src_id": "M488", "code": "\n    @ PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\") @ Operation(summary = \"Convert a file to a PDF using LibreOffice\", description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc,\nFilenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) file.delete();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "304", "src_id": "M625", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "305", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile , LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            // Verify license file algorithm\n\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            // Verify signature\n\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n\n            log.info(\"License file signature is valid\");\n\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            // Process the certificate data\n\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "306", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize , TempFileManager tempFileManager) throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase()\n                            .endsWith(\".html\")|| entry.getName().toLowerCase()\n                                .endsWith(\".htm\")) {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "307", "src_id": "M317", "code": "\n    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption , boolean autoRotate) throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption)|| \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                       float imageAspectRatio = (float) image.getWidth()/(float) image.getHeight();\n                       float pageAspectRatio = pageWidth / pageHeight;\n                       float scaleFactor = 1.0f;\n                       if (imageAspectRatio > pageAspectRatio) {\n                           scaleFactor = pageWidth / image.getWidth();\n                       } else {\n                           scaleFactor = pageHeight / image.getHeight();\n                       }\n\n                       float xPos = (pageWidth - (image.getWidth()* scaleFactor))/2;\n                       float yPos = (pageHeight - (image.getHeight()* scaleFactor))/2;\n                       contentStream.drawImage(image, xPos, yPos, image.getWidth()* scaleFactor, image.getHeight()* scaleFactor);\n                   }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "308", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network == null) {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for(int i = 0;\n                        i < mac.length;\n                        i++) {\n                            sb.append(String.format(\"%02X\", mac[ i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } else {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for(int i = 0;\n                    i < mac.length;\n                    i++) {\n                        sb.append(String.format(\"%02X\", mac[ i]));\n                    }\n                }\n            }\n\n            // Hash the MAC address for privacy and consistency\n\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for ( byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "309", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf , PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures()\n            .getCustomMetadata()\n                .isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures()\n                .getCustomMetadata()\n                    .getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "310", "src_id": "M128", "code": "\n    @ Bean(name = \"machineType\" )\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            } else if (isDocker) {\n                return \"Docker\";\n            } else if (isBrowserOpen) {\n                       String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                       if (os.contains(\"win\")) {\n                           return \"Client-windows\";\n                       } else if (os.contains(\"mac\")) {\n                           return \"Client-mac\";\n                       } else {\n                           return \"Client-unix\";\n                       }\n                   } else {\n                       return \"Server-jar\";\n                   }\n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "311", "src_id": "M101", "code": "\n    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response , FilterChain filterChain) throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\",\n                     stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill()/1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "312", "src_id": "M475", "code": "\n    @Override\n    public void draw(CommandProcess process,JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n        String group = entry.getKey();\n\n        List<JvmItemVO> items = entry.getValue();\n        table.row(true, label(group).style(Decoration.bold.bold()));\n        for (JvmItemVO item : items) {\n                                                                                        String valueStr;\n                                                                                        if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                                         valueStr = renderMemoryUsage((Map<String, Object>) item.getValue());\n                                                                                        } else {\n                                                                                          valueStr = renderItemValue(item.getValue());\n                                                                                        }\n\n                                                                                        if (item.getDesc() != null) {\n                                         table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n                                                                                        } else {\n                                                                                          table.row(item.getName(), valueStr);\n                                                                                        }\n        }\n\n        table.row(\"\", \"\");\n    }\n\n    process.write(RenderUtil.render(table, process.width()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "313", "src_id": "M535", "code": "\n    public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n    final StringBuilder infoSB = new StringBuilder();\n\n    List<String> classDumpFiles = affectVO.getClassDumpFiles();\n    if (classDumpFiles != null) {\n        for (String classDumpFile : classDumpFiles) {\n                                    infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n        }\n    }\n\n    List<String> methods = affectVO.getMethods();\n    if (methods != null) {\n        for (String method : methods) {\n                             infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n        }\n    }\n\n    infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\", affectVO.getClassCount(), affectVO.getMethodCount(), affectVO.getCost(), affectVO.getListenerId()));\n\n    if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n        infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n    }\n\n    if (affectVO.getThrowable() != null) {\n        infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n    }\n\n    infoSB.append(\"\\n\");\n    return infoSB.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "314", "src_id": "M753", "code": "\n    public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n    List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n\n        // Sample CPU\n    if (lastCpuTimes.isEmpty()) {\n        lastSampleTimeNanos = System.nanoTime();\n        for (ThreadVO thread : threads) {\n\n                                    if (thread.getId() > 0) {\n                                            long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                                            lastCpuTimes.put(thread, cpu);\n                                            thread.setTime(cpu / 1000000);\n                                    }\n        }\n\n            // add internal threads\n\n        Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (internalThreadCpuTimes != null) {\n                                    for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                                                String key = entry.getKey();\n\n                                                ThreadVO thread = createThreadVO(key);\n                                                thread.setTime(entry.getValue() / 1000000);\n                                                threads.add(thread);\n                                                lastCpuTimes.put(thread, entry.getValue());\n                                    }\n        }\n\n            //sort by time\n\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n            @Override\n            public int compare(ThreadVO o1,ThreadVO o2) {\n                                      long l1 = o1.getTime();\n                                      long l2 = o2.getTime();\n                                      if (l1 <l2) {\n                return 1;\n                                      } else if (l1 > l2) {\n                                        return -1;\n                                      } else {\n                                        return 0;\n                                      }\n            }\n\n                                  });\n        return threads;\n    }\n\n        // Resample\n    long newSampleTimeNanos = System.nanoTime();\n\n    Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : threads) {\n\n        if (thread.getId() > 0) {\n                                        long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                                        newCpuTimes.put(thread, cpu);\n        }\n    }\n        // internal threads\n\n    Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n    if (newInternalThreadCpuTimes != null) {\n        for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n                                               ThreadVO threadVO = createThreadVO(entry.getKey());\n                                               threads.add(threadVO);\n                                               newCpuTimes.put(threadVO, entry.getValue());\n        }\n    }\n\n        // Compute delta time\n    final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : newCpuTimes.keySet()) {\n        Long t = lastCpuTimes.get(thread);\n        if (t == null) {\n                                                     t = 0L;\n        }\n        long time1 = t;\n        long time2 = newCpuTimes.get(thread);\n        if (time1 == -1) {\n                                                     time1 = time2;\n        } else if (time2 == -1) {\n                                                     time2 = time1;\n               }\n        long delta = time2 - time1;\n        deltas.put(thread, delta);\n    }\n    long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n\n        // Compute cpu usage\n    final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n    for (ThreadVO thread : threads) {\n        double cpu = sampleIntervalNanos == 0 ? 0 : (Math.rint(deltas.get(thread)*10000.0/ sampleIntervalNanos) / 100.0);\n        cpuUsages.put(thread, cpu);\n    }\n\n        // Sort by CPU time : should be a rendering hint...\n\n    Collections.sort(threads, new Comparator<ThreadVO>() {\n        @Override\n        public int compare(ThreadVO o1,ThreadVO o2) {\n                                  long l1 = deltas.get(o1);\n                                  long l2 = deltas.get(o2);\n                                  if (l1 <l2) {\n            return 1;\n                                  } else if (l1 > l2) {\n                                    return -1;\n                                  } else {\n                                    return 0;\n                                  }\n        }\n\n                              });\n    for (ThreadVO thread : threads) {\n            //nanos to mills\n        long timeMills = newCpuTimes.get(thread) / 1000000;\n        long deltaTime = deltas.get(thread) / 1000000;\n        double cpu = cpuUsages.get(thread);\n        thread.setCpu(cpu);\n        thread.setTime(timeMills);\n        thread.setDeltaTime(deltaTime);\n    }\n\n    lastCpuTimes = newCpuTimes;\n    lastSampleTimeNanos = newSampleTimeNanos;\n    return threads;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "315", "src_id": "M1131", "code": "\n    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest,Session session) {\n    String commandLine = apiRequest.getCommand();\n\n    Map<String, Object> body = new TreeMap<String, Object>();\n    body.put(\"command\", commandLine);\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId()).setBody(body);\n\n    if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n        return response;\n    }\n    int lock = session.getLock();\n    try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n        response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n        logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n        return response;\n        }\n\n            //create job\n\n        Job job = this.createJob(commandLine, session, session.getResultDistributor());\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        response.setState(ApiState.SCHEDULED);\n\n            //add command before exec job\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n        commandRequestModel.setJobId(job.id());\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) {\n        resultDistributor.appendResult(commandRequestModel);\n        }\n\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n            //run job\n        job.run();\n        return response;\n    } catch (Throwable e) {\n      logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n      response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n      CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n      session.getResultDistributor().appendResult(commandRequestModel);\n      return response;\n    }\n\nfinally {\n\n        if (session.getLock() == lock) {\n        session.unLock();\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "316", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos,int width) {\n    StringBuilder sb = new StringBuilder(8192);\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name))).row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName())).row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n                                                                                    table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n                                                                                    table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n        @SuppressWarnings(\"unchecked\" ) List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n                                                                                    for (Map<String, Object> appenderInfo : appenders) {\n                                                           Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                                                           appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                                                           appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                                                           appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                                                           appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n\n                                                           if (appenderInfo.get(LoggerHelper.file) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                                                           }\n\n                                                           if (appenderInfo.get(LoggerHelper.target) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                                                           }\n\n                                                           if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                                                           }\n\n                                                           if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                                                           }\n                                                                                    }\n\n                                                                                    table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "317", "src_id": "M15", "code": "\n    public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs,OutputStream out) throws Throwable {\n        // start java telnet client\n        // find arthas-client.jar\n    URLClassLoader classLoader = new URLClassLoader(new URL[] {\n                                                        new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL() });\n\n    Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n\n    Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n\n        //redirect System.out/System.err\n\n    PrintStream originSysOut = System.out;\n\n    PrintStream originSysErr = System.err;\n\n    PrintStream newOut = new PrintStream(out);\n\n    PrintStream newErr = new PrintStream(out);\n\n        // call TelnetConsole.process()\n        // fix https://github.com/alibaba/arthas/issues/833\n\n    ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n    try {\n        System.setOut(newOut);\n        System.setErr(newErr);\n        Thread.currentThread().setContextClassLoader(classLoader);\n        return (Integer) processMethod.invoke(null, new Object[] {\n                                                        telnetArgs.toArray(new String[0]) });\n    } catch (Throwable e) {\n            //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n      e = e.getCause();\n\n      if (e instanceof IOException||e instanceof InterruptedException) {\n                // ignore connection error and interrupted error\n          return STATUS_ERROR;\n      } else {\n                // process error\n        AnsiLog.error(\"process error: {}\", e.toString());\n        AnsiLog.error(e);\n        return STATUS_EXEC_ERROR;\n      }\n    }\n\nfinally {\n        Thread.currentThread().setContextClassLoader(tccl);\n\n            //reset System.out/System.err\n        System.setOut(originSysOut);\n        System.setErr(originSysErr);\n            //flush output\n        newOut.flush();\n        newErr.flush();\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "318", "src_id": "M1469", "code": "\n    public static FieldVO[] getFields(Class clazz,Integer expand) {\n    Field[] fields = clazz.getDeclaredFields();\n    if (fields.length == 0) {\n        return new FieldVO[0];\n    }\n\n    List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n    for (Field field : fields) {\n        FieldVO fieldVO = new FieldVO();\n        fieldVO.setName(field.getName());\n        fieldVO.setType(StringUtils.classname(field.getType()));\n        fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n        fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n\n        if (Modifier.isStatic(field.getModifiers())) {\n                                   fieldVO.setStatic(true);\n                                   fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n        } else {\n          fieldVO.setStatic(false);\n        }\n\n        list.add(fieldVO);\n    }\n    return list.toArray(new FieldVO[0]);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "319", "src_id": "M270", "code": "\n    private static String normalizeArch(String value) {\n    value = normalize(value);\n\n    if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n        return \"x86_64\";\n    }\n\n    if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n        return \"x86_32\";\n    }\n\n    if (value.matches(\"^(ia64w?|itanium64)$\")) {\n        return \"itanium_64\";\n    }\n\n    if (\"ia64n\".equals(value)) {\n        return \"itanium_32\";\n    }\n\n    if (value.matches(\"^(sparc|sparc32)$\")) {\n        return \"sparc_32\";\n    }\n\n    if (value.matches(\"^(sparcv9|sparc64)$\")) {\n        return \"sparc_64\";\n    }\n\n    if (value.matches(\"^(arm|arm32)$\")) {\n        return \"arm_32\";\n    }\n\n    if (\"aarch64\".equals(value)) {\n        return \"aarch_64\";\n    }\n\n    if (value.matches(\"^(mips|mips32)$\")) {\n        return \"mips_32\";\n    }\n\n    if (value.matches(\"^(mipsel|mips32el)$\")) {\n        return \"mipsel_32\";\n    }\n\n    if (\"mips64\".equals(value)) {\n        return \"mips_64\";\n    }\n\n    if (\"mips64el\".equals(value)) {\n        return \"mipsel_64\";\n    }\n\n    if (value.matches(\"^(ppc|ppc32)$\")) {\n        return \"ppc_32\";\n    }\n\n    if (value.matches(\"^(ppcle|ppc32le)$\")) {\n        return \"ppcle_32\";\n    }\n\n    if (\"ppc64\".equals(value)) {\n        return \"ppc_64\";\n    }\n\n    if (\"ppc64le\".equals(value)) {\n        return \"ppcle_64\";\n    }\n\n    if (\"s390\".equals(value)) {\n        return \"s390_32\";\n    }\n\n    if (\"s390x\".equals(value)) {\n        return \"s390_64\";\n    }\n    return value;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "320", "src_id": "M928", "code": "\n    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n    Map<String, Object> info = new HashMap<String, Object>();\n    info.put(LoggerHelper.name, logger.getName());\n    info.put(LoggerHelper.clazz, logger.getClass());\n    CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n    if (codeSource != null) {\n        info.put(LoggerHelper.codeSource, codeSource.getLocation());\n    }\n\n    info.put(LoggerHelper.additivity, logger.getAdditivity());\n    Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n    if (level != null) {\n        info.put(LoggerHelper.level, level.toString());\n    }\n\n    if (effectiveLevel != null) {\n        info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n    }\n    @SuppressWarnings(\"unchecked\" ) List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n    info.put(LoggerHelper.appenders, result);\n    return info;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "321", "src_id": "M9", "code": "\n    @SuppressWarnings(\"resource\" )\n    public static long select(boolean v, long telnetPortPid,String select) throws InputMismatchException {\n    Map<Long, String> processMap = listProcessByJps(v);\n        // Put the port that is already listening at the first\n    if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n        String telnetPortProcess = processMap.get(telnetPortPid);\n        processMap.remove(telnetPortPid);\n        Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n        newProcessMap.put(telnetPortPid, telnetPortProcess);\n        newProcessMap.putAll(processMap);\n        processMap = newProcessMap;\n    }\n\n    if (processMap.isEmpty()) {\n        AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n        return -1;\n    }\n\n        // select target process by the '--select' option when match only one process\n\n    if (select != null && !select.trim().isEmpty()) {\n        int matchedSelectCount = 0;\n\n        Long matchedPid = null;\n        for (Entry<Long, String> entry : processMap.entrySet()) {\n\n                                                        if (entry.getValue().contains(select)) {\n                                                                    matchedSelectCount++;\n                                                                    matchedPid = entry.getKey();\n                                                        }\n        }\n\n        if (matchedSelectCount == 1) {\n                                                        return matchedPid;\n        }\n    }\n\n    AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n        // print list\n    int count = 1;\n    for (String process : processMap.values()) {\n\n        if (count == 1) {\n                                                   System.out.println(\"* [\" + count + \"]: \" + process);\n        } else {\n          System.out.println(\"  [\" + count + \"]: \" + process);\n        }\n\n        count++;\n    }\n\n        // read choice\n\n    String line = new Scanner(System.in).nextLine();\n    if (line.trim().isEmpty()) {\n            // get the first process id\n        return processMap.keySet().iterator().next();\n    }\n    int choice = new Scanner(line).nextInt();\n    if (choice <= 0 ||choice > processMap.size()) {\n        return -1;\n    }\n\n    Iterator<Long> idIter = processMap.keySet().iterator();\n    for(int i = 1;i <= choice;\n++ i) {\n\n                                                                                                             if (i == choice) {\n          return idIter.next();\n                                                                                                             }\n\n                                                                                                             idIter.next();\n    }\n    return -1;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "322", "src_id": "M140", "code": "\n    void _processDo(int option) throws IOException {\n\n    if (debugoptions) {\n        System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n    }\n\n    if (__notifhand != null) {\n        __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n    }\n    boolean acceptNewState = false;\n\n\n        /* open TelnetOptionHandler functionality (start)*/\n    if (optionHandlers[option] != null) {\n        acceptNewState = optionHandlers[option].getAcceptLocal();\n    } else {\n        /* open TelnetOptionHandler functionality (end)*/\n            /* TERMINAL-TYPE option (start)*/\n\n      if (option == TERMINAL_TYPE) {\n\n               if ((terminalType != null) && (terminalType.length() > 0)) {\n                                       acceptNewState = true;\n               }\n      }\n            /* TERMINAL-TYPE option (end)*/\n        /* open TelnetOptionHandler functionality (start)*/\n    }\n        /* open TelnetOptionHandler functionality (end)*/\n\n    if (_willResponse[option] > 0) {\n        -- _willResponse[option];\n\n        if (_willResponse[option] > 0 && _stateIsWill(option)) {\n                                       -- _willResponse[option];\n        }\n    }\n\n    if (_willResponse[option] == 0) {\n\n        if (_requestedWont(option)) {\n                                        switch(option) {\n            default:\n                                        break;}\n\n                                        if (acceptNewState) {\n                                        _setWantWill(option);\n                                        _sendWill(option);\n                                        } else {\n                                          ++ _willResponse[option];\n                                          _sendWont(option);\n                                        }\n        } else {\n                // Other end has acknowledged option.\n          switch(option) {\n            default:\n                   break;}\n        }\n    }\n\n    _setWill(option);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "323", "src_id": "M1324", "code": "\n    private void bind(Configure configure) throws Throwable {\n    long start = System.currentTimeMillis();\n    if (!isBindRef.compareAndSet(false, true)) {\n        throw new IllegalStateException(\"already bind\");\n    }\n\n        // init random port\n\n    if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n        int newTelnetPort = SocketUtils.findAvailableTcpPort();\n        configure.setTelnetPort(newTelnetPort);\n        logger().info(\"generate random telnet port: \" + newTelnetPort);\n    }\n\n    if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n        int newHttpPort = SocketUtils.findAvailableTcpPort();\n        configure.setHttpPort(newHttpPort);\n        logger().info(\"generate random http port: \" + newHttpPort);\n    }\n        // try to find appName\n\n    if (configure.getAppName() == null) {\n        configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n    }\n\n    try {\n\n        if (configure.getTunnelServer() != null) {\n        tunnelClient = new TunnelClient();\n        tunnelClient.setAppName(configure.getAppName());\n        tunnelClient.setId(configure.getAgentId());\n        tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n        tunnelClient.setVersion(ArthasBanner.version());\n        ChannelFuture channelFuture = tunnelClient.start();\n        channelFuture.await(10, TimeUnit.SECONDS);\n        }\n    } catch (Throwable t) {\n      logger().error(\"start tunnel client error\", t);\n    }\n\n    try {\n        ShellServerOptions options = new ShellServerOptions().setInstrumentation(instrumentation).setPid(PidUtils.currentLongPid()).setWelcomeMessage(ArthasBanner.welcome());\n        if (configure.getSessionTimeout() != null) {\n        options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n        }\n\n        this.httpSessionManager = new HttpSessionManager();\n\n        if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n                // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n        String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \" + \"No password is currently configured. \" + \"Therefore, a default password is generated, \" + \"and clients need to use the password to connect!\";\n        AnsiLog.error(errorMsg);\n        configure.setPassword(StringUtils.randomString(64));\n        AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n        logger().error(errorMsg);\n        logger().info(\"Generated arthas password: \" + configure.getPassword());\n        }\n\n        this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n        shellServer = new ShellServerImpl(options);\n        List<String> disabledCommands = new ArrayList<String>();\n        if (configure.getDisabledCommands() != null) {\n        String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n        if (strings != null) {\n                                                         disabledCommands.addAll(Arrays.asList(strings));\n        }\n        }\n\n        BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n\n        List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n        resolvers.add(builtinCommands);\n\n            //worker group\n        workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n            // TODO: discover user provided command resolver\n\n        if (configure.getTelnetPort() != null && configure.getTelnetPort() > 0) {\n        logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n        shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n        } else {\n          logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n        }\n\n        if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n        logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n        shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n        } else {\n                // listen local address in VM communication\n\n          if (configure.getTunnelServer() != null) {\n                   shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n          }\n\n          logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n        }\n\n        for (CommandResolver resolver : resolvers) {\n        shellServer.registerCommandResolver(resolver);\n        }\n\n        shellServer.listen(new BindHandler(isBindRef));\n\n        if (!isBind()) {\n        throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" + String.valueOf(configure.getTelnetPort()) + \", http port: \" + String.valueOf(configure.getHttpPort()));\n        }\n\n            //http api session manager\n\n        sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n            //http api handler\n        httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n        logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n            // 异步回报启动次数\n\n        if (configure.getStatUrl() != null) {\n        logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n        }\n\n        UserStatUtil.setStatUrl(configure.getStatUrl());\n        UserStatUtil.setAgentId(configure.getAgentId());\n        UserStatUtil.arthasStart();\n        try {\n        SpyAPI.init();\n        } catch (Throwable e) {\n                // ignore\n        }\n\n        logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n    } catch (Throwable e) {\n      logger().error(\"Error during start as-server\", e);\n      destroy();\n      throw e;\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "324", "src_id": "M122", "code": "\n    private int __read(boolean mayBlock) throws IOException {\n    int ch;\n    while (true) {\n\n            // If there is no more data AND we were told not to block,\n            // just return WOULD_BLOCK (-2). (More efficient than exception.)\n\n        if (!mayBlock && super.available() == 0) {\n                     return WOULD_BLOCK;\n        }\n\n            // Otherwise, exit only when we reach end of stream.\n\n        if ((ch = super.read()) < 0) {\n                     return EOF;\n        }\n\n        ch = (ch&0xff);\n\n            /* Code Section added for supporting AYT (start)*/\n        synchronized(__client) {\n        __client._processAYTResponse();\n        }\n            /* Code Section added for supporting AYT (end)*/\n\n            /* Code Section added for supporting spystreams (start)*/\n\n        __client._spyRead(ch);\n            /* Code Section added for supporting spystreams (end)*/\n        switch(__receiveState) {\n            case _STATE_CR:\n            if (ch == '\\0') {\n                    // Strip null\n            continue;\n            }\n                // How do we handle newline after cr?\n                //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n\n                // Handle as normal data by falling through to _STATE_DATA case\n\n                //$FALL-THROUGH$\n\n                               case _STATE_DATA:\n                     if (ch == TelnetCommand.IAC) {\n            __receiveState = _STATE_IAC;\n            continue;\n                     }\n\n                     if (ch == '\\r') {\n            synchronized(__client) {\n\n                         if (__client._requestedDont(TelnetOption.BINARY)) {\n                __receiveState = _STATE_CR;\n                         } else {\n                           __receiveState = _STATE_DATA;\n                         }\n            }\n                     } else {\n                       __receiveState = _STATE_DATA;\n                     }\n\n                     break;\n                               case _STATE_IAC:\n        switch(ch) {\n            case TelnetCommand.WILL:\n            __receiveState = _STATE_WILL;\n            continue;\n                   case TelnetCommand.WONT:\n            __receiveState = _STATE_WONT;\n            continue;\n                   case TelnetCommand.DO:\n            __receiveState = _STATE_DO;\n            continue;\n                   case TelnetCommand.DONT:\n            __receiveState = _STATE_DONT;\n            continue;\n                /* TERMINAL-TYPE option (start)*/\n                   case TelnetCommand.SB:\n            __suboption_count = 0;\n            __receiveState = _STATE_SB;\n            continue;\n                /* TERMINAL-TYPE option (end)*/\n                   case TelnetCommand.IAC:\n            __receiveState = _STATE_DATA;\n            break; // exit to enclosing switch to return IAC from read\n                   case TelnetCommand.SE: // unexpected byte! ignore it (don't send it as a command)\n            __receiveState = _STATE_DATA;\n            continue;\n                   default:\n            __receiveState = _STATE_DATA;\n            __client._processCommand(ch); // Notify the user\n            continue; // move on the next char\n        }\n\n        break; // exit and return from read\n                               case _STATE_WILL:\n        synchronized(__client) {\n            __client._processWill(ch);\n            __client._flushOutputStream();\n        }\n\n        __receiveState = _STATE_DATA;\n        continue;\n                               case _STATE_WONT:\n        synchronized(__client) {\n            __client._processWont(ch);\n            __client._flushOutputStream();\n        }\n\n        __receiveState = _STATE_DATA;\n        continue;\n                               case _STATE_DO:\n        synchronized(__client) {\n            __client._processDo(ch);\n            __client._flushOutputStream();\n        }\n\n        __receiveState = _STATE_DATA;\n        continue;\n                               case _STATE_DONT:\n        synchronized(__client) {\n            __client._processDont(ch);\n            __client._flushOutputStream();\n        }\n\n        __receiveState = _STATE_DATA;\n        continue;\n            /* TERMINAL-TYPE option (start)*/\n                               case _STATE_SB:\n        switch(ch) {\n            case TelnetCommand.IAC:\n            __receiveState = _STATE_IAC_SB;\n            continue;\n                   default:\n                    // store suboption char\n            if (__suboption_count <__suboption.length) {\n            __suboption[__suboption_count ++ ] = ch;\n            }\n\n            break;\n        }\n\n        __receiveState = _STATE_SB;\n        continue;\n                               case _STATE_IAC_SB: // IAC received during SB phase\n        switch(ch) {\n            case TelnetCommand.SE:\n            synchronized(__client) {\n            __client._processSuboption(__suboption, __suboption_count);\n            __client._flushOutputStream();\n            }\n\n            __receiveState = _STATE_DATA;\n            continue;\n                   case TelnetCommand.IAC: // De-dup the duplicated IAC\n            if (__suboption_count <__suboption.length) {\n            __suboption[__suboption_count ++ ] = ch;\n            }\n\n            break;\n                   default:            // unexpected byte! ignore it\n            break;\n        }\n\n        __receiveState = _STATE_SB;\n        continue;\n            /* TERMINAL-TYPE option (end)*/\n}\n\n        break;\n    }\n    return ch;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "325", "src_id": "M8", "code": "\n    private static String formatFileSize(long size) {\n    String hrSize;\n    double b = size;\n    double k = size / 1024.0;\n    double m = ((size / 1024.0) / 1024.0);\n    double g = (((size / 1024.0) / 1024.0) / 1024.0);\n    double t = ((((size / 1024.0) / 1024.0) / 1024.0) / 1024.0);\n\n    DecimalFormat dec = new DecimalFormat(\"0.00\");\n    if (t > 1) {\n        hrSize = dec.format(t).concat(\" TB\");\n    } else if (g > 1) {\n      hrSize = dec.format(g).concat(\" GB\");\n    } else if (m > 1) {\n      hrSize = dec.format(m).concat(\" MB\");\n           } else if (k > 1) {\n             hrSize = dec.format(k).concat(\" KB\");\n           } else {\n             hrSize = dec.format(b).concat(\" Bytes\");\n           }\n    return hrSize;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "326", "src_id": "M790", "code": "\n    @Override\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain,byte[] classfileBuffer) throws IllegalClassFormatException {\n\n    if (className == null) {\n        return null;\n    }\n\n    className = className.replace('/', '.');\n    List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n            // 倒序，因为要执行的配置生效\n\n    ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n    while (listIterator.hasPrevious()) {\n        RetransformEntry retransformEntry = listIterator.previous();\n        int id = retransformEntry.getId();\n                // 判断类名是否一致\n        boolean updateFlag = false;\n                // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n        if (className.equals(retransformEntry.getClassName())) {\n\n                                           if (retransformEntry.getClassLoaderClass() != null ||retransformEntry.getHashCode() != null) {\n                                                                   updateFlag = isLoaderMatch(retransformEntry, loader);\n                                           } else {\n                                             updateFlag = true;\n                                           }\n        }\n\n        if (updateFlag) {\n                                           logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n                                           retransformEntry.incTransformCount();\n                                           return retransformEntry.getBytes();\n        }\n    }\n    return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "327", "src_id": "M716", "code": "\n    public static void drawPlayException(TableElement table,ObjectVO throwableVO) {\n        // 执行失败:输出失败状态\n    table.row(\"IS-RETURN\", \"\" + false);\n    table.row(\"IS-EXCEPTION\", \"\" + true);\n\n        // 执行失败:输出失败异常信息\n    Throwable cause;\n\n    Throwable t = (Throwable) throwableVO.getObject();\n    if (t instanceof InvocationTargetException) {\n        cause = t.getCause();\n    } else {\n      cause = t;\n    }\n\n    if (throwableVO.needExpand()) {\n        table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n    } else {\n      StringWriter stringWriter = new StringWriter();\n\n      PrintWriter printWriter = new PrintWriter(stringWriter);\n      try {\n        cause.printStackTrace(printWriter);\n        table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n      }\n\nfinally {\n               printWriter.close();\n      }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "328", "src_id": "M602", "code": "\n    private AsyncProfiler profilerInstance() {\n\n    if (profiler != null) {\n        return profiler;\n    }\n\n        // try to load from special path\n\n    if (ProfilerAction.load.toString().equals(action)) {\n        profiler = AsyncProfiler.getInstance(this.actionArg);\n    }\n\n    if (libPath != null) {\n            // load from arthas directory\n            // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n        FileOutputStream tmpLibOutputStream = null;\n\n        FileInputStream libInputStream = null;\n        try {\n        File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n        tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n        libInputStream = new FileInputStream(libPath);\n        IOUtils.copy(libInputStream, tmpLibOutputStream);\n        libPath = tmpLibFile.getAbsolutePath();\n        logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n        } catch (Throwable e) {\n          logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n        }\n\nfinally {\n                             IOUtils.close(libInputStream);\n                             IOUtils.close(tmpLibOutputStream);\n        }\n\n        profiler = AsyncProfiler.getInstance(libPath);\n    } else {\n\n      if (OSUtils.isLinux()||OSUtils.isMac()) {\n               throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n      } else {\n        throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n      }\n    }\n    return profiler;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "329", "src_id": "M1086", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "330", "src_id": "M1149", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "331", "src_id": "M219", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "332", "src_id": "M192", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "333", "src_id": "M235", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "334", "src_id": "M942", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "335", "src_id": "M520", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "336", "src_id": "M186", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "337", "src_id": "M478", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "338", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n        Exception exception = null;\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException\n                || err instanceof ClosedByInterruptException\n                    || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n\n            if (errCode == ERROR_NOTHING) errCode = ERROR_POSTPROCESSING;\n            exception = err;\n        }\n\n\nfinally {\n        notifyPostProcessing(errCode == ERROR_NOTHING?2:0);\n        }\n\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) exception = errObject;\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n\n        notifyFinished();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "339", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn)\n        throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n\n\n        switch(statusCode) {\n            case 204: case 205: case 207:\n            throw new HttpError(statusCode);\n                           case 416:\n            return;// let the download thread handle this error\n                           default:\n                           if (statusCode<200\n                                   || statusCode> 299) {\n                               throw new HttpError(statusCode);\n                           }\n\n\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "340", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref)\n        throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n        final Elst obj = new Elst();\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n\n        final int entryCount = stream.readInt();\n        if (entryCount<1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n\n\n        if (v1) {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1)*(DataReader.LONG_SIZE*2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        }\n\n\n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "341", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n        if (DEBUG\n                && !mMission.unknownLength\n                && start> 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n\n        try {\n            long rangeStart = (mMission.unknownLength\n                || start<1)?-1: start;\n            int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n\n            mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && start> 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n\n\n            if (!mMission.unknownLength) mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            if (mMission.unknownLength\n                    || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n            mIs = mConn.getInputStream();\n\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n            while(mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n\n            dispose();\n\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n            if (!mMission.running\n                    || e instanceof ClosedByInterruptException) return;\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n\n            if (mRetryCount++>= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n\n\n            run();// try again\n            return;\n        }\n\n\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "342", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount)\n        throws IOException {\n        if (aux.length<1) {\n            return;\n        }\n\n\n        out.flush();\n        aux.flush();\n\n\n        boolean underflow = aux.offset<aux.length\n        || out.offset<out.length;\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long length = amount;\n        while(length> 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n            if (read<1) {\n                amount -= length;\n                break;\n            }\n\n\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n\n        if (underflow) {\n            if (out.offset>= out.length) {\n                // calculate the aux underflow pointer\n                if (aux.offset<amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        } else {\n            out.offset += amount;\n            aux.offset -= amount;\n        }\n\n\n        out.length += amount;\n        if (out.length> maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n\n        if (amount<aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n            aux.length -= amount;\n            length = aux.length;\n            while(length> 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n\n        if (aux.length> THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);// or setLength(0);\n        }\n\n\n        aux.reset();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "343", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n        request.append(\" [\");\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) request.append(' ').append(recovery.toString()).append(' ');\n        }\n\n\n        request.append(\"]\");\n\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n\n        ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "344", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized(this) {\n                           mission.timestamp = System.currentTimeMillis();\n                           mission.mHandler = mHandler;\n                           mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n                           while(true) {\n                               mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                               if (!mission.metadata.isFile()\n                                       && !mission.metadata.exists()) {\n                                   try {\n                                       if (!mission.metadata.createNewFile()) throw new RuntimeException(\"Cant create download metadata file\");\n                                   } catch (IOException e) {\n                                       throw new RuntimeException(e);\n                                   }\n\n\n                                   break;\n                               }\n\n\n                               mission.timestamp = System.currentTimeMillis();\n                           }\n\n\n                           mSelfMissionsControl = true;\n                           mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n                           Utility.writeToFile(mission.metadata, mission);\n                           if (mission.storage == null) {\n                // noting to do here\n                               mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                               if (mission.errObject != null) mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                               return;\n                           }\n                           boolean start = !mPrefQueueLimit\n                           || getRunningMissionsCount()<1;\n                           if (canDownloadInCurrentNetwork()\n                                   && start) {\n                               mission.start();\n                           }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "345", "src_id": "M1136", "code": "\n    @Override int process(SharpStream out, SharpStream... sources)\n        throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n        if (format == null\n            || format.equals(\"ttml\")) {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException?1:8;\n            }\n\n\n            return OK_RESULT;\n        } else if (format.equals(\"srt\")) {\n                   byte[] buffer = new byte[8*1024];\n                   int read;\n                   while((read = sources[0].read(buffer))> 0) {\n                       out.write(buffer, 0, read);\n                   }\n\n\n                   return OK_RESULT;\n               }\n\n\n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "346", "src_id": "M1047", "code": "\n    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n        if (init != null\n                && init != currentThread\n                && init.isAlive()) {\n            init.interrupt();\n            if (millis> 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n            }\n        }\n\n        // if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive()\n                    || thread == Thread.currentThread()) continue;\n            thread.interrupt();\n        }\n\n\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) continue;\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n\n\n                if (millis> 0) thread.join(millis);\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "347", "src_id": "M31", "code": "\n    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context)throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")\n                        // .header(\"Authorization\", \"License \" + licenseKey).POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() == 200) {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Extract user count, default to 1 if not specified\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } else {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n        return jsonResponse;\n    }\n\n", "compilable": false, "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "348", "src_id": "M488", "code": "\n    @ PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\") @Operation(summary = \"Convert a file to a PDF using LibreOffice\", description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        }\nfinally {\n            if (file != null) file.delete();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "349", "src_id": "M625", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "350", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n            byte [] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String)attrs.get(\"enc\");\n                encodedSignature = (String)attrs.get(\"sig\");\n                algorithm = (String)attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            // Verify license file algorithm\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            // Verify signature\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n            log.info(\"License file signature is valid\");\n\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            // Process the certificate data\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "351", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while(entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase().endsWith(\".html\")||entry.getName().toLowerCase().endsWith(\".htm\")) {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "352", "src_id": "M317", "code": "\n    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption)|| \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                       float imageAspectRatio = (float)image.getWidth() / (float)image.getHeight();\n                       float pageAspectRatio = pageWidth / pageHeight;\n                       float scaleFactor = 1.0f;\n                       if (imageAspectRatio > pageAspectRatio) {\n                           scaleFactor = pageWidth / image.getWidth();\n                       } else {\n                           scaleFactor = pageHeight / image.getHeight();\n                       }\n                       float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                       float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                       contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n                   }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "353", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network == null) {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while(networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte [] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } else {\n                byte [] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                }\n            }\n\n            // Hash the MAC address for privacy and consistency\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte [] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for ( byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "354", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": true}
{"project_name": "across-project", "pair_id": "355", "src_id": "M128", "code": "\n    @ Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            } else if (isDocker) {\n                       return \"Docker\";\n            } else if (isBrowserOpen) {\n                       String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                       if (os.contains(\"win\")) {\n                           return \"Client-windows\";\n                       } else if (os.contains(\"mac\")) {\n                                  return \"Client-mac\";\n                       } else {\n                           return \"Client-unix\";\n                       }\n                   } else {\n                       return \"Server-jar\";\n                   }\n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "356", "src_id": "M101", "code": "\n    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k->createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "357", "src_id": "M491", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "358", "src_id": "M424", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "359", "src_id": "M900", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "360", "src_id": "M895", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "361", "src_id": "M225", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "362", "src_id": "M749", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "363", "src_id": "M999", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "364", "src_id": "M698", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "365", "src_id": "M379", "code": "", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "366", "src_id": "M894", "code": "", "compilable": false, "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "367", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n        Exception exception = null;\n        try {\n            psAlgorithm.run(this);\n        }\n\n            catch(Exception err ) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) errCode = ERROR_POSTPROCESSING;\n            exception = err;\n        }\n\nfinally {\n            notifyPostProcessing(errCode == ERROR_NOTHING?2:\n                                                         0);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) exception = errObject;\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n        notifyFinished();\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "368", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return;// let the download thread handle this error\n            default:\n                if (statusCode < 200\n                        || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "369", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n\n        if (v1) {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1) *(DataReader.LONG_SIZE* 2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        }\n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "380", "src_id": "M235", "code": "\n    @POST\n    @Produces({MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML})\n    public Response createSession(@QueryParam(\"op\")\n                        String op, @DefaultValue(\"5\") @QueryParam(\"expire\")\n                        String expire,\n                                  @Context UriInfo ui) {\n        if (!op.equals(\"create\")) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST) .entity(new ZError(ui.getRequestUri() .toString(), \"\") ) .build());\n        }\n\n        int expireInSeconds;\n\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST) .build());\n        }\n\n        String uuid = UUID.randomUUID() .toString();\n\n        while (ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID() .toString();\n        }\n\n        // establish the connection to the ZooKeeper cluster\n\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR) .build());\n        }\n\n        URI uri = ui.getAbsolutePathBuilder() .path(uuid) .build();\n        return Response.created(uri) .entity(new JSONWithPadding(new ZSession(uuid, uri.toString())) ) .build();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "381", "src_id": "M942", "code": "\n    public void schedule(WorkRequest workRequest,\n                         long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n\n        // If we have a worker thread pool, use that; otherwise, do the work\n        // directly.\n        int size = workers.size();\n\n        if (size > 0) {\n            try {\n                // make sure to map negative ids as well to [0, size-1]\n                int workerNum = ((int) (id%size) + size)%size;\n                ExecutorService worker = workers.get(workerNum);\n                worker.execute(scheduledWorkRequest);\n            } catch (RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n            }\n        } else {\n            // When there is no worker thread pool, do the work directly\n            // and wait for its completion\n            scheduledWorkRequest.run();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "382", "src_id": "M520", "code": "\n    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false, success = false;\n\n        try {\n            flush();\n            ((FileOutputStream) out) .getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        } finally {\n                  if (success) {\n                      boolean renamed = tmpFile.renameTo(origFile);\n\n                      if (!renamed) {\n                    // On windows, renameTo does not replace.\n                          if (!origFile.delete()||!tmpFile.renameTo(origFile)) {\n                              throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                          }\n                      }\n                  } else {\n                      if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                          IOUtils.closeStream(out);\n                      }\n                // close wasn't successful, try to delete the tmp file\n\n                      if (!tmpFile.delete()) {\n                          LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                      }\n                  }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "383", "src_id": "M186", "code": "\n    synchronized private\n    LogEntry readNextEntry() {\n        try {\n            try {\n                while (true) {\n                    String line = in.readLine();\n\n                    if (line == null) {\n                        break;\n                    }\n\n                    Matcher m = src.timep.matcher(line);\n\n                    if (m.lookingAt()) {\n                        if (buf.length()> 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n                            return e;\n                        }\n\n                        buf = line;\n                    } else if (buf.length()> 0) {\n                               buf += line + \"\\n\";\n                           }\n                }\n            } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n\n            if (buf.length()> 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n                return e;\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n        }\n\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "384", "src_id": "M478", "code": "\n    public static void main(String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n\n        if (op.equalsIgnoreCase(\"gettracemask\")) {\n            getTraceMask(host, port);\n        } else if (op.equalsIgnoreCase(\"settracemask\")) {\n                   setTraceMask(host, port, args[3]);\n               } else if (op.equalsIgnoreCase(\"ruok\")) {\n                          ruok(host, port);\n                      } else if (op.equalsIgnoreCase(\"kill\")) {\n                                 kill(host, port);\n                             } else if (op.equalsIgnoreCase(\"stat\")) {\n                                        stat(host, port);\n                                    } else if (op.equalsIgnoreCase(\"dump\")) {\n                                               dump(host, port);\n                                           } else {\n                                               System.out.println(\"Unrecognized op: \" + op);\n                                           }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "385", "src_id": "M66", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        Observer<? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n        for(;;\n) {\n            for(;;\n) {\n                if (cancelled) {\n                    return;\n                }\n                if (errors.get() != null) {\n                    if (!delayErrors) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean d = done;\n                SwitchMapMaybeObserver<R> current = inner.get();\n                boolean empty = current == null;\n                if (d&& empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (empty|| current.item == null) {\n                    break;\n                }\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "386", "src_id": "M1333", "code": "\n    @Override\n    public void onNext(T t) {\n        if (done) {\n            return;\n        }\n\n        boolean b;\n        try {\n            b = predicate.test(t);\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            downstream.onSuccess(false);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "387", "src_id": "M522", "code": "\n    void drainLoop() {\n        Observer<? super T> actual = this.downstream;\n        int missed = 1;\n        for(;;\n) {\n            for(;;\n) {\n                if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n                    return;\n                }\n                int os = otherState;\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                T v = q != null? q.poll(): null;\n                boolean empty = v == null;\n                if (d&& empty&& os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                actual.onNext(v);\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "388", "src_id": "M1163", "code": "\n    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        final SimplePlainQueue<Object> queue = this.queue;\n        final Subscriber<? super Flowable<T>> downstream = this.downstream;\n        UnicastProcessor<T> window = this.window;\n        for(;;\n) {\n            if(upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n                if(isDone&& isEmpty) {\n                    Throwable ex = error;\n                    if(ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n                        downstream.onComplete();\n                    }\n                    cleanupResources();\n                    upstreamCancelled = true;\n                    continue;\n                } else\nif (!isEmpty) {\n    if(o instanceof WindowBoundaryRunnable) {\n        WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n        if (boundary.index == emitted|| !restartTimerOnMaxSize) {\n            this.count = 0;\n            window = createNewWindow(window);\n        }\n    } else\n    if (window != null) {\n        @SuppressWarnings( \"unchecked\"\n            ) T item = (T) o;\n        window.onNext(item);\n\n        long count = this.count + 1;\n        if(count == maxSize) {\n            this.count = 0;\n            window = createNewWindow(window);\n        } else {\n            this.count = count;\n        }\n    }\n    continue;\n}\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "389", "src_id": "M478", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        EqualObserver<T> [] as = observers;\n        final EqualObserver<T> observer1 = as[ 0];\n        final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n        final EqualObserver<T> observer2 = as[ 1];\n        final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n        for(;;\n) {\n            for(;;\n) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n\n                boolean d1 = observer1.done;\n                if (d1) {\n                    Throwable e = observer1.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                boolean d2 = observer2.done;\n                if (d2) {\n                    Throwable e = observer2.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n\n                boolean e1 = v1 == null;\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n\n                boolean e2 = v2 == null;\n                if (d1&& d2&& e1&& e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n                if ((d1&& d2)&& (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n                if (!e1&& !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(\n                            v1, v2);\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n                    v1 = null;\n                    v2 = null;\n                }\n                if (e1|| e2) {\n                    break;\n                }\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "390", "src_id": "M885", "code": "\n    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T> [] s = this.subscribers;\n        int n = s.length;\n        Subscriber<? super T> a = this.downstream;\n        for(;;\n) {\n            long r = requested.get();\n            long e = 0;\n            middle: while(e != r) {\n                        if (cancelled) {\n                            cleanup();\n                            return;\n                        }\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            cleanup();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean d = done.get() == 0;\n                        boolean empty = true;\n                        for(int i = 0;\ni < s.length;\ni++) {\n                            JoinInnerSubscriber<T> inner = s[ i];\n                            SimplePlainQueue<T> q = inner.queue;\n                            if (q != null) {\n                                T v = q.poll();\n                                if (v != null) {\n                                    empty = false;\n                                    a.onNext(v);\n                                    inner.requestOne();\n                                    if (++\n                                            e == r) {\n                                        break middle;\n                                    }\n                                }\n                            }\n                        }\n                        if (d&& empty) {\n                            a.onComplete();\n                            return;\n                        }\n                        if (empty) {\n                            break;\n                        }\n                    }\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for(int i = 0;\ni < n;\ni++) {\n                    JoinInnerSubscriber<T> inner = s[ i];\n                    SimpleQueue<T> q = inner.queue;\n                    if (q != null&& !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n                if (d&& empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "391", "src_id": "M1399", "code": "\n    @Override\n    public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        InnerQueuedSubscriber<R> inner = current;\n        Subscriber<? super R> a = downstream;\n        ErrorMode em = errorMode;\n        for(;;\n) {\n            long r = requested.get();\n            long e = 0L;\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean outerDone = done;\n                inner = subscribers.poll();\n                if (outerDone&& inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n\n            boolean continueNextSource = false;\n            if (inner != null) {\n                SimpleQueue<R> q = inner.queue();\n                if (q != null) {\n                    while(e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        R v;\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n                        if (d&& empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n                        if (empty) {\n                            break;\n                        }\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        boolean empty = q.isEmpty();\n                        if (d&& empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n            if (e != 0L&& r != Long.MAX_VALUE) {\n                requested.addAndGet(- e);\n            }\n            if (continueNextSource) {\n                continue;\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "392", "src_id": "M469", "code": "\n    @SuppressWarnings( \"unchecked\"\n        ) void remove(CacheDisposable<T> consumer) {\n        for(;;\n) {\n            CacheDisposable<T> [] current = observers.get();\n            int n = current.length;\n            if (n == 0) {\n                return;\n            }\n            int j = - 1;\n            for(int i = 0;\ni < n;\ni++) {\n                if (current[ i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n            CacheDisposable<T> [] next;\n            if(n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable [ n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n            if (observers.compareAndSet(\n                current, next)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "393", "src_id": "M362", "code": "\n    void drainFused() {\n        int missed = 1;\n        for(;;\n) {\n            if (disposed) {\n                return;\n            }\n\n            boolean d = done;\n            Throwable ex = error;\n            if (!delayError&& d&& ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n            downstream.onNext(null);\n            if (d) {\n                disposed = true;\n                ex = error;\n                if(ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n                worker.dispose();\n                return;\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "394", "src_id": "M2247", "code": "\n    @SuppressWarnings( \"unchecked\"\n        ) void remove(PublishSubscription<T> ps) {\n        for(;;\n) {\n            PublishSubscription<T> [] a = subscribers.get();\n            if (a == TERMINATED|| a == EMPTY) {\n                return;\n            }\n            int n = a.length;\n            int j = - 1;\n            for(int i = 0;\ni < n;\ni++) {\n                if (a[ i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n            PublishSubscription<T> [] b;\n            if(n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription [ n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(\n                a, b)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "395", "src_id": "M491", "code": "\n    @ SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,\n                                                   @ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch(resizeMode) {\n                           case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                           newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                           break;\n                           case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                           newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                           break;\n                           case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                           newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                           break;\n        }\n\n        // save the new resize mode so it can be restored in a future session\n        player.getPrefs().edit()\n                         .putInt(\n                             player.getContext().getString(R.string.last_resize_mode),\n                             newResizeMode)\n                                 .apply();\n        return newResizeMode;\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "396", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close it because when changing orientation from portrait\n            // (in fullscreen mode) the size of queue layout can be larger than the screen size\n            closeItemsList();\n        } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            // Ensure that we have audio-only stream playing when a user\n            // started to play from notification's play button from outside of the app\n                   if (!fragmentIsVisible) {\n                       onFragmentStopped();\n                   }\n               } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                          fragmentIsVisible = false;\n                          onFragmentStopped();\n                      } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            // Restore video source when user returns to the fragment\n                                 fragmentIsVisible = true;\n                                 player.useVideoSource(true);\n\n            // When a user returns from background, the system UI will always be shown even if\n            // controls are invisible: hide it in that case\n                                 if (!isControlsVisible()) {\n                                     hideSystemUIIfNeeded();\n                                 }\n                             }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "397", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        final String selectedTheme = getSelectedThemeKey(context);\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n                   return R.style.BlackSettingsTheme;\n               } else if (selectedTheme.equals(automaticDeviceTheme)) {\n                          if (isDeviceDarkThemeEnabled(context)) {\n                // use the dark theme variant preferred by the user\n                              final String selectedNightTheme = getSelectedNightThemeKey(context);\n                              if (selectedNightTheme.equals(blackTheme)) {\n                                  return R.style.BlackSettingsTheme;\n                              } else {\n                                  return R.style.DarkSettingsTheme;\n                              }\n                          } else {\n                // there is only one day theme\n                              return R.style.LightSettingsTheme;\n                          }\n                      } else {\n            // default to dark theme\n                          return R.style.DarkSettingsTheme;\n                      }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "398", "src_id": "M895", "code": "\n    @Override\n    public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n        final float notificationThumbnailWidth = Math.min(\n            context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n            source.getWidth());\n        final Bitmap result = BitmapCompat.createScaledBitmap(\n            source,\n            (int)notificationThumbnailWidth,\n            (int) (source.getHeight()/(source.getWidth()/notificationThumbnailWidth)),\n            null,\n            true);\n        if (result == source || !result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(\n                source,\n                (int)notificationThumbnailWidth - 1,\n                (int) (source.getHeight()/(source.getWidth()/(notificationThumbnailWidth - 1))),\n                null,\n                true);\n            source.recycle();\n            return copied;\n        } else {\n            source.recycle();\n            return result;\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "399", "src_id": "M225", "code": "\n    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n\n\n        if (DEBUG) {\n            Log.d(\n                TAG,\n                \"onBroadcastReceived() called with: intent = [\"\n                    + intent + \"]\");\n        }\n\n\n        switch(intent.getAction()) {\n                                   case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                                   pause();\n                                   break;\n                                   case ACTION_CLOSE:\n                                   service.destroyPlayerAndStopService();\n                                   break;\n                                   case ACTION_PLAY_PAUSE:\n                                   playPause();\n                                   break;\n                                   case ACTION_PLAY_PREVIOUS:\n                                   playPrevious();\n                                   break;\n                                   case ACTION_PLAY_NEXT:\n                                   playNext();\n                                   break;\n                                   case ACTION_FAST_REWIND:\n                                   fastRewind();\n                                   break;\n                                   case ACTION_FAST_FORWARD:\n                                   fastForward();\n                                   break;\n                                   case ACTION_REPEAT:\n                                   cycleNextRepeatMode();\n                                   break;\n                                   case ACTION_SHUFFLE:\n                                   toggleShuffleModeEnabled();\n                                   break;\n                                   case Intent.ACTION_CONFIGURATION_CHANGED:\n                                   if (DEBUG) {\n                                       Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                                   }\n\n\n                                   break;\n        }\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "400", "src_id": "M749", "code": "\n    private static void handleError(final Context context,\n                                    final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable()\n                .printStackTrace();\n        }\n\n\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(\n                context,\n                R.string.recaptcha_request_toast,\n                Toast.LENGTH_LONG)\n                    .show();\n            // Starting ReCaptcha Challenge Activity\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n                   Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG)\n                       .show();\n               } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n                          Toast.makeText(\n                              context,\n                              R.string.restricted_video_no_stream,\n                              Toast.LENGTH_LONG)\n                                  .show();\n                      } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n                                 Toast.makeText(\n                                     context,\n                                     R.string.georestricted_content,\n                                     Toast.LENGTH_LONG)\n                                         .show();\n                             } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n                                        Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG)\n                                            .show();\n                                    } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n                                               Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG)\n                                                   .show();\n                                           } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                                      Toast.makeText(\n                                                          context,\n                                                          R.string.soundcloud_go_plus_content,\n                                                          Toast.LENGTH_LONG)\n                                                              .show();\n                                                  } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n                                                             Toast.makeText(\n                                                                 context,\n                                                                 R.string.youtube_music_premium_content,\n                                                                 Toast.LENGTH_LONG)\n                                                                     .show();\n                                                         } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n                                                                    Toast.makeText(\n                                                                        context,\n                                                                        R.string.content_not_available,\n                                                                        Toast.LENGTH_LONG)\n                                                                            .show();\n                                                                } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                                                           Toast.makeText(\n                                                                               context,\n                                                                               R.string.content_not_supported,\n                                                                               Toast.LENGTH_LONG)\n                                                                                   .show();\n                                                                       } else {\n                                                                           ErrorUtil.createNotification(context, errorInfo);\n                                                                       }\n\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context)\n                .finish();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "401", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(\n        @NonNull final Context context, @NonNull final FragmentManager fragmentManager, final int serviceId, @Nullable final String url, @NonNull final String title, @Nullable final PlayQueue playQueue,\n        final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) {\n            // no player open\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else if (switchingPlayers) {\n            // switching player to main player\n                   autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n               } else if (playerType == PlayerType.MAIN) {\n            // opening new stream while already playing in main player\n                          autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n                      } else {\n            // opening new stream while already playing in another player\n                          autoPlay = false;\n                      }\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n                                                                               expandMainPlayer(detailFragment.requireActivity());\n                                                                               detailFragment.setAutoPlay(autoPlay);\n                                                                               if (switchingPlayers) {\n                // Situation when user switches from players to main player. All needed data is\n                // here, we can start watching (assuming newQueue equals playQueue).\n                // Starting directly in fullscreen if the previous player type was popup.\n                                                                                   detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n                                                                               } else {\n                                                                                   detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n                                                                               }\n                                                                               detailFragment.scrollToTop();\n                                                                           };\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n            defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance)\n                                               .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n                                                   .commit();\n        }\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "402", "src_id": "M698", "code": "\n    @Override\n    public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(\n            result.getServiceId(),\n            result.getOriginalUrl(),\n            result.getName());\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG)\n                .into(\n                     binding.channelBannerImage);\n        } else {\n            // do not waste space for the banner, if the user disabled images or there is not one\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG)\n            .into(\n                 binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n            .into(\n                 binding.subChannelAvatarView);\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(\n                getString(R.string.channel_created_by),\n                currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n        updateRssButton();\n        channelContentNotSupported = false;\n        for(final\n        Throwable throwable :result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "403", "src_id": "M379", "code": "\n    @Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector()\n.getCurrentMappedTrackInfo() == null || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n        final List<Tracks.Group> textTracks = currentTracks.getGroups().stream()\n.filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n.collect(Collectors.toList());\n        final List<String> availableLanguages = textTracks.stream().map(Tracks.Group::getMediaTrackGroup)\n.filter(textTrack -> textTrack.length > 0)\n.map(textTrack -> textTrack.getFormat(0).language)\n.collect(Collectors.toList());\n\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected)\n.filter(info -> info.getMediaTrackGroup().length >= 1)\n.map(info -> info.getMediaTrackGroup().getFormat(0))\n.findFirst();\n\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters()\n.getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty()?View.GONE:\n                                              View.VISIBLE);\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "404", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(final Context context,\n                                                         @NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n                                                                 @Override\n                                                                 public Bitmap transform(final Bitmap source) {\n                                                                     if (DEBUG) {\n                                                                         Log.d(TAG, \"Thumbnail - transform() called\");\n                                                                     }\n                                                                     final float notificationThumbnailWidth = Math.min(\n                                                                         context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                                                                         source.getWidth());\n                                                                     final Bitmap result = BitmapCompat.createScaledBitmap(\n                                                                         source,\n                                                                         (int)notificationThumbnailWidth,\n                                                                         (int) (source.getHeight()/(source.getWidth()/notificationThumbnailWidth)),\n                                                                         null,\n                                                                         true);\n                                                                     if (result == source || !result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n                                                                         final Bitmap copied = BitmapCompat.createScaledBitmap(\n                                                                             source,\n                                                                             (int)notificationThumbnailWidth - 1,\n                                                                             (int) (source.getHeight()/(source.getWidth()/(notificationThumbnailWidth - 1))),\n                                                                             null,\n                                                                             true);\n                                                                         source.recycle();\n                                                                         return copied;\n                                                                     } else {\n                                                                         source.recycle();\n                                                                         return result;\n                                                                     }\n                                                                 }\n                                                                                  @Override\n                                                                                  public String key() {\n                                                                                      return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                                                                                  }\n                                                             });\n    }\n\n", "compilable": true, "test_passed": true, "successful_trans": false}
{"project_name": "across-project", "pair_id": "405", "src_id": "M66", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Observer<? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference<SwitchMapMaybeObserver <R>> inner = this.inner;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    if (!delayErrors) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean d = done;\n                SwitchMapMaybeObserver<R> current = inner.get();\n                boolean empty = current == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty || current.item == null) {\n                    break;\n                }\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "408", "src_id": "M1163", "code": "\n    @Override\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        final SimplePlainQueue<Object> queue = this.queue;\n        final Subscriber<? super Flowable <T>> downstream = this.downstream;\n        UnicastProcessor<T> window = this.window;\n        for (;;) {\n            if (upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n                        downstream.onComplete();\n                    }\n                    cleanupResources();\n                    upstreamCancelled = true;\n                    continue;\n                } else if (!isEmpty) {\n                           if (o instanceof WindowBoundaryRunnable) {\n                               WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                               if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                   this.count = 0;\n                                   window = createNewWindow(window);\n                               }\n                           } else if (window != null) {\n                                      @SuppressWarnings(\"unchecked\" ) T item = (T) o;\n                                      window.onNext(item);\n\n\n                                      long count = this.count + 1;\n                                      if (count == maxSize) {\n                                          this.count = 0;\n                                          window = createNewWindow(window);\n                                      } else {\n                                          this.count = count;\n                                      }\n                                  }\n                           continue;\n                       }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "409", "src_id": "M478", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        EqualObserver<T> [] as = observers;\n        final EqualObserver<T> observer1 = as[0];\n        final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n        final EqualObserver<T> observer2 = as[1];\n        final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n\n                boolean d1 = observer1.done;\n                if (d1) {\n                    Throwable e = observer1.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                boolean d2 = observer2.done;\n                if (d2) {\n                    Throwable e = observer2.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n\n                boolean e1 = v1 == null;\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n\n                boolean e2 = v2 == null;\n                if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n\n                if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(v1, v2);\n                    }\n\n                        catch(Throwable ex ) {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n                    v1 = null;\n                    v2 = null;\n                }\n\n                if (e1 || e2) {\n                    break;\n                }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "410", "src_id": "M885", "code": "\n    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T> [] s = this.subscribers;\n        int n = s.length;\n        Subscriber<? super T> a = this.downstream;\n        for (;;) {\n            long r = requested.get();\n            long e = 0;\n            middle:\nwhile(e != r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for (int i = 0; i < s.length; i++) {\n                    JoinInnerSubscriber<T> inner = s[i ];\n                    SimplePlainQueue<T> q = inner.queue;\n                    if (q != null) {\n                        T v = q.poll();\n                        if (v != null) {\n                            empty = false;\n                            a.onNext(v);\n                            inner.requestOne();\n                            if (++e == r) {\n                                break middle;\n                            }\n                        }\n                    }\n                }\n\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n}\n\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i ];\n                    SimpleQueue<T> q = inner.queue;\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "411", "src_id": "M1399", "code": "\n    @Override\n    public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        InnerQueuedSubscriber<R> inner = current;\n        Subscriber<? super R> a = downstream;\n        ErrorMode em = errorMode;\n        for (;;) {\n            long r = requested.get();\n            long e = 0L;\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean outerDone = done;\n                inner = subscribers.poll();\n                if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n\n            boolean continueNextSource = false;\n            if (inner != null) {\n                SimpleQueue<R> q = inner.queue();\n                if (q != null) {\n                    while(e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        R v;\n                        try {\n                            v = q.poll();\n                        }\n\n                            catch(Throwable ex ) {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        boolean empty = q.isEmpty();\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n\n            if (continueNextSource) {\n                continue;\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "412", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\" ) void remove(CacheDisposable<T> consumer) {\n        for (;;) {\n            CacheDisposable<T> [] current = observers.get();\n            int n = current.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = - 1;\n            for (int i = 0; i < n; i++) {\n                if (current[i ] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n            CacheDisposable<T> [] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable [n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "413", "src_id": "M362", "code": "\n    void drainFused() {\n        int missed = 1;\n        for (;;) {\n            if (disposed) {\n                return;\n            }\n\n            boolean d = done;\n            Throwable ex = error;\n            if (!delayError && d && ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n            downstream.onNext(null);\n            if (d) {\n                disposed = true;\n                ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n                worker.dispose();\n                return;\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "414", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\" ) void remove(PublishSubscription<T> ps) {\n        for (;;) {\n            PublishSubscription<T> [] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = - 1;\n            for (int i = 0; i < n; i++) {\n                if (a[i ] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n            PublishSubscription<T> [] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription [n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "415", "src_id": "M66", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Observer < ? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference < SwitchMapMaybeObserver < R>> inner = this.inner;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n                if (errors.get() != null) {\n                    if (!delayErrors) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean d = done;\n                SwitchMapMaybeObserver < R> current = inner.get();\n                boolean empty = current == null;\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (empty || current.item == null) {\n                    break;\n                }\n\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "416", "src_id": "M1333", "code": "\n    @Override public void onNext(T t) {\n        if (done) {\n            return;\n        }\n\n        boolean b;\n        try {\n            b = predicate.test(t);\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            downstream.onSuccess(false);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "417", "src_id": "M522", "code": "\n    void drainLoop() {\n        Observer < ? super T> actual = this.downstream;\n        int missed = 1;\n        for (;;) {\n            for (;;) {\n                if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n                    return;\n                }\n\n                int os = otherState;\n\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue < T> q = queue;\n                T v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n\n                actual.onNext(v);\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "418", "src_id": "M1163", "code": "\n    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        final SimplePlainQueue < Object> queue = this.queue;\n        final Subscriber < ? super Flowable < T>> downstream = this.downstream;\n        UnicastProcessor < T> window = this.window;\n        for (;;) {\n            if (upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n\n                        downstream.onComplete();\n                    }\n\n                    cleanupResources();\n                    upstreamCancelled = true;\n                    continue;\n                } else if (!isEmpty) {\n                           if (o instanceof WindowBoundaryRunnable) {\n                               WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n\n                               if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                   this.count = 0;\n                                   window = createNewWindow(window);\n                               }\n                           } else if (window != null) {\n                                      @SuppressWarnings(\"unchecked\") T item = (T) o;\n                                      window.onNext(item);\n\n                                      long count = this.count + 1;\n\n                                      if (count == maxSize) {\n                                          this.count = 0;\n                                          window = createNewWindow(window);\n                                      } else {\n                                          this.count = count;\n                                      }\n                                  }\n\n                           continue;\n                       }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "419", "src_id": "M478", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        EqualObserver < T> [] as = observers;\n        final EqualObserver < T> observer1 = as[0];\n        final SpscLinkedArrayQueue < T> q1 = observer1.queue;\n        final EqualObserver < T> observer2 = as[1];\n        final SpscLinkedArrayQueue < T> q2 = observer2.queue;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n\n                boolean d1 = observer1.done;\n\n                if (d1) {\n                    Throwable e = observer1.error;\n\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                boolean d2 = observer2.done;\n\n                if (d2) {\n                    Throwable e = observer2.error;\n\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n\n                boolean e1 = v1 == null;\n\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n\n                boolean e2 = v2 == null;\n\n                if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n                if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(v1, v2);\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    v1 = null;\n                    v2 = null;\n                }\n                if (e1 || e2) {\n                    break;\n                }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "420", "src_id": "M885", "code": "\n    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber < T> [] s = this.subscribers;\n        int n = s.length;\n        Subscriber < ? super T> a = this.downstream;\n        for (;;) {\n            long r = requested.get();\n            long e = 0;\n            middle: while(e != r) {\n                        if (cancelled) {\n                            cleanup();\n                            return;\n                        }\n\n                        Throwable ex = errors.get();\n\n                        if (ex != null) {\n                            cleanup();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean d = done.get() == 0;\n                        boolean empty = true;\n                        for (int i = 0; i < s.length; i++) {\n                            JoinInnerSubscriber < T> inner = s[i];\n                            SimplePlainQueue < T> q = inner.queue;\n\n                            if (q != null) {\n                                T v = q.poll();\n\n                                if (v != null) {\n                                    empty = false;\n                                    a.onNext(v);\n                                    inner.requestOne();\n                                    if (++e == r) {\n                                        break middle;\n                                    }\n                                }\n                            }\n                        }\n                        if (d && empty) {\n                            a.onComplete();\n                            return;\n                        }\n                        if (empty) {\n                            break;\n                        }\n                    }\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n\n                Throwable ex = errors.get();\n\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber < T> inner = s[i];\n                    SimpleQueue < T> q = inner.queue;\n\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "421", "src_id": "M1399", "code": "\n    @Override public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        InnerQueuedSubscriber < R> inner = current;\n        Subscriber < ? super R> a = downstream;\n        ErrorMode em = errorMode;\n        for (;;) {\n            long r = requested.get();\n            long e = 0L;\n\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean outerDone = done;\n                inner = subscribers.poll();\n                if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n\n            boolean continueNextSource = false;\n\n            if (inner != null) {\n                SimpleQueue < R> q = inner.queue();\n\n                if (q != null) {\n                    while(e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        R v;\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n                        if (empty) {\n                            break;\n                        }\n\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n                        boolean empty = q.isEmpty();\n\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n            if (continueNextSource) {\n                continue;\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "422", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\") void remove(CacheDisposable < T> consumer) {\n        for (;;) {\n            CacheDisposable < T> [] current = observers.get();\n            int n = current.length;\n\n            if (n == 0) {\n                return;\n            }\n\n            int j = - 1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n\n            CacheDisposable < T> [] next;\n\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "423", "src_id": "M362", "code": "\n    void drainFused() {\n        int missed = 1;\n        for (;;) {\n            if (disposed) {\n                return;\n            }\n\n            boolean d = done;\n            Throwable ex = error;\n\n            if (!delayError && d && ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n\n            downstream.onNext(null);\n            if (d) {\n                disposed = true;\n                ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n\n                worker.dispose();\n                return;\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "424", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\") void remove(PublishSubscription < T> ps) {\n        for (;;) {\n            PublishSubscription < T> [] a = subscribers.get();\n\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = - 1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n\n            PublishSubscription < T> [] b;\n\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}

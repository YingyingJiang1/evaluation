{"project_name": "across-project", "pair_id": "139", "src_id": "M475", "code": "    @Override\n    public void draw(CommandProcess process, JvmModel result) {\n        TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n        for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n            String group = entry.getKey();\n            List<JvmItemVO> items = entry.getValue();\n            table.row(true, label(group).style(Decoration.bold.bold()));\n            for (JvmItemVO item : items) {\n                String valueStr = item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")? renderMemoryUsage((Map<String, Object>) item.getValue()) : renderItemValue(item.getValue()); \n                if (item.getDesc() != null) {\n                    table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n                } else {\n                    table.row(item.getName(), valueStr);\n                }\n            }\n            table.row(\"\", \"\");\n        }\n        process.write(RenderUtil.render(table, process.width()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "140", "src_id": "M535", "code": "    public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n        final StringBuilder infoSB = new StringBuilder();\n        List<String> classDumpFiles = affectVO.getClassDumpFiles();\n        if (classDumpFiles != null) {\n            for (String classDumpFile : classDumpFiles) {\n                infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n            }\n        }\n        List<String> methods = affectVO.getMethods();\n        if (methods != null) {\n            for (String method : methods) {\n                infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n            }\n        }\n        infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\", affectVO.getClassCount(), affectVO.getMethodCount(), affectVO.getCost(), affectVO.getListenerId()));\n        if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n            infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n        }\n        if (affectVO.getThrowable() != null) {\n            infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n        }\n        infoSB.append(\"\\n\");\n        return infoSB.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "141", "src_id": "M753", "code": "    public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n        List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n        // Sample CPU\n        if (lastCpuTimes.isEmpty()) {\n            lastSampleTimeNanos = System.nanoTime();\n            for (ThreadVO thread : threads) {\n                if (thread.getId() > 0) {\n                    long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                    lastCpuTimes.put(thread, cpu);\n                    thread.setTime(cpu / 1000000);\n                }\n            }\n            // add internal threads\n            Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n            if (internalThreadCpuTimes != null) {\n                for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                    String key = entry.getKey();\n                    ThreadVO thread = createThreadVO(key);\n                    thread.setTime(entry.getValue() / 1000000);\n                    threads.add(thread);\n                    lastCpuTimes.put(thread, entry.getValue());\n                }\n            }\n            //sort by time\n            Collections.sort(threads, new Comparator<ThreadVO>() {\n                @Override\n                public int compare(ThreadVO o1, ThreadVO o2) {\n                    long l1 = o1.getTime(), l2 = o2.getTime();\n                    if (l1 < l2) {\n                        return 1;\n                    } else {\n                        if (l1 > l2) {\n                            return -1;\n                        } else {\n                            return 0;\n                        }\n                    }\n                }\n            });\n            return threads;\n        }\n        // Resample\n        long newSampleTimeNanos = System.nanoTime();\n        Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                newCpuTimes.put(thread, cpu);\n            }\n        }\n        // internal threads\n        Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (newInternalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n                ThreadVO threadVO = createThreadVO(entry.getKey());\n                threads.add(threadVO);\n                newCpuTimes.put(threadVO, entry.getValue());\n            }\n        }\n        // Compute delta time\n        final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : newCpuTimes.keySet()) {\n            Long t = lastCpuTimes.get(thread);\n            if (t == null) {\n                t = 0L;\n            }\n            long time1 = t, time2 = newCpuTimes.get(thread);\n            if (time1 == -1) {\n                time1 = time2;\n            } else {\n                if (time2 == -1) {\n                    time2 = time1;\n                }\n            }\n            long delta = time2 - time1;\n            deltas.put(thread, delta);\n        }\n        long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n        // Compute cpu usage\n        final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n        for (ThreadVO thread : threads) {\n            double cpu = sampleIntervalNanos == 0 ? 0 : (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0);\n            cpuUsages.put(thread, cpu);\n        }\n        // Sort by CPU time : should be a rendering hint...\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n            @Override\n            public int compare(ThreadVO o1, ThreadVO o2) {\n                long l1 = deltas.get(o1), l2 = deltas.get(o2);\n                if (l1 < l2) {\n                    return 1;\n                } else {\n                    if (l1 > l2) {\n                        return -1;\n                    } else {\n                        return 0;\n                    }\n                }\n            }\n        });\n        for (ThreadVO thread : threads) {\n            //nanos to mills\n            long timeMills = newCpuTimes.get(thread) / 1000000, deltaTime = deltas.get(thread) / 1000000;\n            double cpu = cpuUsages.get(thread);\n            thread.setCpu(cpu);\n            thread.setTime(timeMills);\n            thread.setDeltaTime(deltaTime);\n        }\n        lastCpuTimes = newCpuTimes;\n        lastSampleTimeNanos = newSampleTimeNanos;\n        return threads;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "142", "src_id": "M1131", "code": "    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<String, Object>();\n\n        body.put(\"command\", commandLine);\n\n        ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n\n        int lock = session.getLock();\n        try {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n            //create job\n            Job job = this.createJob(commandLine, session, session.getResultDistributor());\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            response.setState(ApiState.SCHEDULED);\n\n            //add command before exec job\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n\n            commandRequestModel.setJobId(job.id());\n\n            SharingResultDistributor resultDistributor = session.getResultDistributor();\n\n            if (resultDistributor != null) {\n                resultDistributor.appendResult(commandRequestModel);\n            }\n\n            session.setForegroundJob(job);\n\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n            //run job\n            job.run();\n            return response;\n        } catch (Throwable e) {\n            logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n            session.getResultDistributor().appendResult(commandRequestModel);\n\n            return response;\n        } finally {\n            if (session.getLock() == lock) {\n                session.unLock();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "143", "src_id": "M542", "code": "    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1), appendersTable = new TableElement().rightCellPadding(1);\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n            .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n            .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n            .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n            .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity)))\n            .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n            @SuppressWarnings(\"unchecked\") List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "144", "src_id": "M15", "code": "    public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) \n    throws Throwable {\n        // start java telnet client\n        // find arthas-client.jar\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{\n        new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n        Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n        Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n        //redirect System.out/System.err\n        PrintStream originSysOut = System.out, originSysErr = System.err;\n\n        PrintStream newOut = new PrintStream(out);\n        PrintStream newErr = new PrintStream(out);\n        // call TelnetConsole.process()\n        // fix https://github.com/alibaba/arthas/issues/833\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            System.setOut(newOut);\n            System.setErr(newErr);\n            Thread.currentThread().setContextClassLoader(classLoader);\n\n            return (Integer) processMethod.invoke(null, new Object[]{\n            telnetArgs.toArray(new String[0])});\n        } catch (Throwable e) {\n            //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n            e = e.getCause();\n            if (e instanceof IOException || e instanceof InterruptedException) {\n                // ignore connection error and interrupted error\n                return STATUS_ERROR;\n            } else {\n                // process error\n                AnsiLog.error(\"process error: {}\", e.toString());\n                AnsiLog.error(e);\n                return STATUS_EXEC_ERROR;\n            }\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n            //reset System.out/System.err\n            System.setOut(originSysOut);\n            System.setErr(originSysErr);\n            //flush output\n            newOut.flush();\n            newErr.flush();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "145", "src_id": "M1469", "code": "    public static FieldVO[] getFields(Class clazz, Integer expand) {\n        Field[] fields = clazz.getDeclaredFields();\n        if (fields.length == 0) {\n            return new FieldVO[0];\n        }\n\n        List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n        for (Field field : fields) {\n            FieldVO fieldVO = new FieldVO();\n            fieldVO.setName(field.getName());\n            fieldVO.setType(StringUtils.classname(field.getType()));\n            fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n\n            fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n            if (!(Modifier.isStatic(field.getModifiers()))) {\n                fieldVO.setStatic(false);\n            } else {\n                fieldVO.setStatic(true);\n                fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n            } \n            list.add(fieldVO);\n        }\n        return list.toArray(new FieldVO[0]);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "65", "src_id": "M1277", "code": "    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n\n            if (!(obj instanceof byte[])) {\n                if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                    redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                    str = geo.getLongitude() + \",\" + geo.getLatitude();\n                } else {\n                    if (obj instanceof String) {\n                        if (stringEscape) {\n                            str = escape((String) obj); \n                        } else {\n                            str = (String) obj; \n                        } \n                    } else {\n                        str = String.valueOf(obj);\n                    }\n                }\n            }else {\n                str = SafeEncoder.encode((byte[]) obj);\n            } \n\n            output.put(key, str);\n        }\n\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "66", "src_id": "M902", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "67", "src_id": "M1131", "code": "    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE : // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n                // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "68", "src_id": "M1057", "code": "    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n\n            assert resultsData != null : \"Could not detect Results data.\";\n\n            assert profileData != null : \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1229", "code": "    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n\n        if (sslVerifyMode != SslVerifyMode.FULL) {\n            if (sslVerifyMode == SslVerifyMode.CA) {\n                this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n            } else {\n                if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                    trustManagers = new TrustManager[]{INSECURE_TRUST_MANAGER};\n                }\n            }\n        }else {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } \n\n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n\n        sslContext.init(keyManagers, trustManagers, null);\n\n        return sslContext;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "70", "src_id": "M894", "code": "    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap<>();\n\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n\n            if (!(value instanceof List)) {\n                if (value instanceof byte[]) {\n                    value = BuilderFactory.STRING.build(value);\n                    if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                        try {\n                            value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                        } catch (Exception e) { }\n                    }\n                }\n            } else {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n                        value = labels;\n                        break;\n                    case RULES_PROPERTY:\n                        List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                        Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n\n                        rules = new HashMap<>(rulesDataList.size());\n\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                        }\n\n                        value = rulesValueMap;\n\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                        List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n\n                        chunks = new ArrayList<>(chunksDataList.size());\n\n                        for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n\n                            chunks.add(chunk);\n                        }\n\n                        value = chunksValueList;\n\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } \n\n            properties.put(prop, value);\n        }\n\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "71", "src_id": "M897", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null || duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis != null) {\n                    jedis.ping();\n                    return jedis;\n                } \n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "73", "src_id": "M9", "code": "    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n\n            policy.touch(cacheKey);\n\n            CacheKey evictedKey = policy.evictNext();\n\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n\n            stats.load();\n\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "74", "src_id": "M1105", "code": "    @Override\n    public Class<?> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        String str = STRING.build(data);\n\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "146", "src_id": "M342", "code": "    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n\n        String from = extractBasicHeader(emlContent, \"From:\");\n\n        String to = extractBasicHeader(emlContent, \"To:\");\n\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n        StringBuilder html = new StringBuilder();\n\n        html.append(\"<!DOCTYPE html>\\n\");\n\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n\n        html.append(\"<style>\\n\");\n\n        appendEnhancedStyles(html);\n\n        html.append(\"</style>\\n\");\n\n        html.append(\"</head><body>\\n\");\n\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n\n        html.append(processEmailHtmlBody(htmlBody));\n\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n\n            html.append(attachmentInfo);\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n\n                html.append(\"</div>\\n\");\n            }\n            html.append(\"</div>\\n\");\n        }\n        // Show advanced features status if requested\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n\n        html.append(\"</body></html>\");\n\n        return html.toString();\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "147", "src_id": "M371", "code": "    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) {\n            return false;\n        }\n        try {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n            // Additional check for MimeMultipart\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "148", "src_id": "M348", "code": "    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[j].trim());\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // Apply MIME header decoding\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim().isEmpty()) {\n                    break;\n                }\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "149", "src_id": "M364", "code": "    private static void addAttachmentAnnotationsToDocument(PDDocument document, \n    List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n        // 1. Find the screen position of all attachment markers\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n\n        finder.setSortByPosition(true); // Process pages in order\n\n        finder.getText(document);\n\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "1", "src_id": "M270", "code": "            private static String normalizeArch(String value) {\n             value = normalize(value);\n\n             if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n              return \"x86_64\";\n             }\n             if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n              return \"x86_32\";\n             }\n\n             if (value.matches(\"^(ia64w?|itanium64)$\")) {\n              return \"itanium_64\";\n             }\n\n             if (\"ia64n\".equals(value)) {\n              return \"itanium_32\";\n             }\n             if (value.matches(\"^(sparc|sparc32)$\")) {\n              return \"sparc_32\";\n             }\n             if (value.matches(\"^(sparcv9|sparc64)$\")) {\n              return \"sparc_64\";\n             }\n             if (value.matches(\"^(arm|arm32)$\")) {\n              return \"arm_32\";\n             }\n             if (\"aarch64\".equals(value)) {\n              return \"aarch_64\";\n             }\n             if (value.matches(\"^(mips|mips32)$\")) {\n              return \"mips_32\";\n             }\n             if (value.matches(\"^(mipsel|mips32el)$\")) {\n              return \"mipsel_32\";\n             }\n             if (\"mips64\".equals(value)) {\n              return \"mips_64\";\n             }\n             if (\"mips64el\".equals(value)) {\n              return \"mipsel_64\";\n             }\n             if (value.matches(\"^(ppc|ppc32)$\")) {\n              return \"ppc_32\";\n             }\n             if (value.matches(\"^(ppcle|ppc32le)$\")) {\n              return \"ppcle_32\";\n             }\n             if (\"ppc64\".equals(value)) {\n              return \"ppc_64\";\n             }\n             if (\"ppc64le\".equals(value)) {\n              return \"ppcle_64\";\n             }\n             if (\"s390\".equals(value)) {\n              return \"s390_32\";\n             }\n             if (\"s390x\".equals(value)) {\n              return \"s390_64\";\n             }\n             return value;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "2", "src_id": "M928", "code": "            private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n             Map<String, Object> info = new HashMap<String, Object>();\n             info.put(LoggerHelper.name, logger.getName());\n\n             info.put(LoggerHelper.clazz, logger.getClass());\n             CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n\n             if (codeSource != null) {\n              info.put(LoggerHelper.codeSource, codeSource.getLocation());\n             }\n\n             info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n             Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n\n             if (level != null) {\n              info.put(LoggerHelper.level, level.toString());\n             }\n\n             if (effectiveLevel != null) {\n              info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n             }\n\n             @SuppressWarnings(\"unchecked\") List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n\n             info.put(LoggerHelper.appenders, result);\n\n             return info;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "3", "src_id": "M9", "code": "            @SuppressWarnings(\"resource\") public static long select(boolean v, long telnetPortPid, String select) throws InputMismatchException {\n             Map<Long, String> processMap = listProcessByJps(v);\n             // Put the port that is already listening at the first\n             if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n              String telnetPortProcess = processMap.get(telnetPortPid);\n\n              processMap.remove(telnetPortPid);\n\n              Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n\n              newProcessMap.put(telnetPortPid, telnetPortProcess);\n\n              newProcessMap.putAll(processMap);\n              processMap = newProcessMap;\n             }\n\n             if (processMap.isEmpty()) {\n              AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n              return -1;\n             }\n\n             // select target process by the '--select' option when match only one process\n             if (select != null && !select.trim().isEmpty()) {\n              int matchedSelectCount = 0;\n              Long matchedPid = null;\n\n              for (Entry<Long, String> entry : processMap.entrySet()) {\n               if (entry.getValue().contains(select)) {\n                matchedSelectCount++;\n                matchedPid = entry.getKey();\n               }\n              }\n\n              if (matchedSelectCount == 1) {\n               return matchedPid;\n              }\n             }\n\n             AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n\n             // print list\n             int count = 1;\n\n             for (String process : processMap.values()) {\n              if (count == 1) {\n               System.out.println(\"* [\" + count + \"]: \" + process);\n              } else {\n               System.out.println(\"  [\" + count + \"]: \" + process);\n              }\n              count++;\n             }\n\n             // read choice\n             String line = new Scanner(System.in).nextLine();\n\n             if (line.trim().isEmpty()) {\n              // get the first process id\n              return processMap.keySet().iterator().next();\n             }\n             int choice = new Scanner(line).nextInt();\n             if (choice <= 0 || choice > processMap.size()) {\n              return -1;\n             }\n\n             Iterator<Long> idIter = processMap.keySet().iterator();\n\n             for (int i = 1; i <= choice; ++i) {\n              if (i == choice) {\n               return idIter.next();\n              }\n              idIter.next();\n             }\n\n             return -1;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "4", "src_id": "M140", "code": "            void _processDo(int option) throws IOException {\n             if (debugoptions) {\n              System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n             }\n             if (__notifhand != null) {\n              __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n             }\n\n             boolean acceptNewState = false;\n             /* open TelnetOptionHandler functionality (start)*/\n\n             if (optionHandlers[option] != null) {\n              acceptNewState = optionHandlers[option].getAcceptLocal();\n             } else {/* open TelnetOptionHandler functionality (end)*//* TERMINAL-TYPE option (start)*/\n              if (option == TERMINAL_TYPE && ((terminalType != null) && (terminalType.length() > 0))) {\n               acceptNewState = true;\n              }\n             }/* open TelnetOptionHandler functionality (end)*/\n\n             if (_willResponse[option] > 0) {\n              --_willResponse[option];\n              if (_willResponse[option] > 0 && _stateIsWill(option)) {\n               --_willResponse[option];\n              }\n             }\n\n             if (_willResponse[option] == 0) {\n              if (!_requestedWont(option)) {// Other end has acknowledged option.\n\n               switch (option)\n               {\n\n                default:\n                 break;\n\n               }\n              } else {\n               switch (option)\n               {\n\n                default:\n                 break;\n\n               }\n               if (acceptNewState) {\n                _setWantWill(option);\n                _sendWill(option);\n               } else {\n                ++_willResponse[option];\n                _sendWont(option);\n               }\n              }\n             }\n\n             _setWill(option);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "5", "src_id": "M1324", "code": "            private void bind(Configure configure) throws Throwable {\n             long start = System.currentTimeMillis();\n             if (!isBindRef.compareAndSet(false, true)) {\n              throw new IllegalStateException(\"already bind\");\n             }\n\n             // init random port\n             if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n              int newTelnetPort = SocketUtils.findAvailableTcpPort();\n\n              configure.setTelnetPort(newTelnetPort);\n              logger().info(\"generate random telnet port: \" + newTelnetPort);\n             }\n\n             if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n              int newHttpPort = SocketUtils.findAvailableTcpPort();\n              configure.setHttpPort(newHttpPort);\n              logger().info(\"generate random http port: \" + newHttpPort);\n             }\n\n             // try to find appName\n             if (configure.getAppName() == null) {\n              configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n             }\n\n             try {\n              if (configure.getTunnelServer() != null) {\n               tunnelClient = new TunnelClient();\n               tunnelClient.setAppName(configure.getAppName());\n               tunnelClient.setId(configure.getAgentId());\n               tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n               tunnelClient.setVersion(ArthasBanner.version());\n               ChannelFuture channelFuture = tunnelClient.start();\n               channelFuture.await(10, TimeUnit.SECONDS);\n              }\n             } catch (Throwable t) {\n              logger().error(\"start tunnel client error\", t);\n             }\n\n             try {\n              ShellServerOptions options = new ShellServerOptions().setInstrumentation(instrumentation).setPid(PidUtils.currentLongPid())\n              .setWelcomeMessage(ArthasBanner.welcome());\n              if (configure.getSessionTimeout() != null) {\n               options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n              }\n\n              this.httpSessionManager = new HttpSessionManager();\n\n              if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n               // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n               String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \"\n               + \"No password is currently configured. \" \n               + \"Therefore, a default password is generated, \"\n               + \"and clients need to use the password to connect!\";\n               AnsiLog.error(errorMsg);\n\n               configure.setPassword(StringUtils.randomString(64));\n               AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n               logger().error(errorMsg);\n               logger().info(\"Generated arthas password: \" + configure.getPassword());\n              }\n\n              this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n\n              shellServer = new ShellServerImpl(options);\n\n              List<String> disabledCommands = new ArrayList<String>();\n\n              if (configure.getDisabledCommands() != null) {\n               String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n               if (strings != null) {\n                disabledCommands.addAll(Arrays.asList(strings));\n               }\n              }\n\n              BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n\n              List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n\n              resolvers.add(builtinCommands);\n\n              //worker group\n              workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n              // TODO: discover user provided command resolver\n              if (!(configure.getTelnetPort() != null && configure.getTelnetPort() > 0)) {\n               logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n              } else {\n               logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n               shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n              } \n\n              if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n               logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n               shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n              } else {\n               // listen local address in VM communication\n               if (configure.getTunnelServer() != null) {\n                shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n               }\n               logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n              }\n\n              for (CommandResolver resolver : resolvers) {\n               shellServer.registerCommandResolver(resolver);\n              }\n\n              shellServer.listen(new BindHandler(isBindRef));\n\n              if (!isBind()) {\n               throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" + String.valueOf(configure.getTelnetPort()) \n               + \", http port: \"\n               + String.valueOf(configure.getHttpPort()));\n              }\n\n              //http api session manager\n              sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n\n              //http api handler\n              httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n\n              logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n              // 异步回报启动次数\n              if (configure.getStatUrl() != null) {\n               logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n              }\n\n              UserStatUtil.setStatUrl(configure.getStatUrl());\n\n              UserStatUtil.setAgentId(configure.getAgentId());\n              UserStatUtil.arthasStart();\n              try {\n               SpyAPI.init();\n              } catch (Throwable e) {\n              // ignore\n              }\n              logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n             } catch (Throwable e) {\n              logger().error(\"Error during start as-server\", e);\n              destroy();\n              throw e;\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "6", "src_id": "M122", "code": "            private int __read(boolean mayBlock) throws IOException {\n             int ch;\n             while (true) {\n              // If there is no more data AND we were told not to block,\n              // just return WOULD_BLOCK (-2). (More efficient than exception.)\n              if (!mayBlock && super.available() == 0) {\n               return WOULD_BLOCK;\n              }\n\n              // Otherwise, exit only when we reach end of stream.\n              if ((ch = super.read()) < 0) {\n               return EOF;\n              }\n              ch = (ch & 0xff); /* Code Section added for supporting AYT (start)*/\n              synchronized (__client)\n              {\n               __client._processAYTResponse();\n              }/* Code Section added for supporting AYT (end)*//* Code Section added for supporting spystreams (start)*/\n              __client._spyRead(ch); /* Code Section added for supporting spystreams (end)*/\n\n              switch (__receiveState) {\n\n               case _STATE_CR:\n                if (ch == '\\0')\n                {\n                 // Strip null\n                 continue;\n                }\n                // How do we handle newline after cr?\n                //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n\n                // Handle as normal data by falling through to _STATE_DATA case\n\n                //$FALL-THROUGH$\n               case _STATE_DATA:\n                if (ch == TelnetCommand.IAC) {\n                 __receiveState = _STATE_IAC;\n                 continue;\n                }\n\n                if (ch != '\\r') {\n                 __receiveState = _STATE_DATA;\n                }\n                else {\n                 synchronized (__client)\n                 {\n                  if (__client._requestedDont(TelnetOption.BINARY)) {\n                   __receiveState = _STATE_CR;\n                  } else {\n                   __receiveState = _STATE_DATA;\n                  }\n                 }\n                } \n\n                break;\n\n               case _STATE_IAC:\n                switch (ch) {\n                 case TelnetCommand.WILL:\n                  __receiveState = _STATE_WILL;\n                  continue;\n                 case TelnetCommand.WONT:\n                  __receiveState = _STATE_WONT;\n                  continue;\n                 case TelnetCommand.DO:\n                  __receiveState = _STATE_DO;\n                  continue;\n                 case TelnetCommand.DONT:\n                  __receiveState = _STATE_DONT;\n                  continue;\n                  /* TERMINAL-TYPE option (start)*/\n                 case TelnetCommand.SB:\n                  __suboption_count = 0;\n                  __receiveState = _STATE_SB;\n                  continue;\n                  /* TERMINAL-TYPE option (end)*/\n                 case TelnetCommand.IAC:\n                  __receiveState = _STATE_DATA;\n                  break; // exit to enclosing switch to return IAC from read\n                 case TelnetCommand.SE : // unexpected byte! ignore it (don't send it as a command)\n                  __receiveState = _STATE_DATA;\n                  continue;\n                 default:\n                  __receiveState = _STATE_DATA;\n                  __client._processCommand(ch); // Notify the user\n                  continue; // move on the next char\n                }\n\n                break; // exit and return from read\n               case _STATE_WILL:\n                synchronized (__client)\n                {\n                 __client._processWill(ch);\n                 __client._flushOutputStream();\n                }\n                __receiveState = _STATE_DATA;\n                continue;\n               case _STATE_WONT:\n                synchronized (__client)\n                {\n                 __client._processWont(ch);\n                 __client._flushOutputStream();\n                }\n                __receiveState = _STATE_DATA;\n                continue;\n               case _STATE_DO:\n                synchronized (__client)\n                {\n                 __client._processDo(ch);\n                 __client._flushOutputStream();\n                }\n                __receiveState = _STATE_DATA;\n                continue;\n               case _STATE_DONT:\n                synchronized (__client)\n                {\n                 __client._processDont(ch);\n                 __client._flushOutputStream();\n                }\n                __receiveState = _STATE_DATA;\n                continue;\n                /* TERMINAL-TYPE option (start)*/\n               case _STATE_SB:\n                switch (ch) {\n                 case TelnetCommand.IAC:\n                  __receiveState = _STATE_IAC_SB;\n                  continue;\n                 default:\n                  // store suboption char\n                  if (__suboption_count < __suboption.length) {\n                   __suboption[__suboption_count++] = ch;\n                  }\n                  break;\n                }\n\n                __receiveState = _STATE_SB;\n\n                continue;\n               case _STATE_IAC_SB : // IAC received during SB phase\n                switch (ch) {\n                 case TelnetCommand.SE:\n                  synchronized (__client)\n                  {\n                   __client._processSuboption(__suboption, __suboption_count);\n\n                   __client._flushOutputStream();\n                  }\n                  __receiveState = _STATE_DATA;\n                  continue;\n                 case TelnetCommand.IAC : // De-dup the duplicated IAC\n                  if (__suboption_count < __suboption.length) {\n                   __suboption[__suboption_count++] = ch;\n                  }\n                  break;\n                 default :            // unexpected byte! ignore it\n                  break;\n                }\n\n                __receiveState = _STATE_SB;\n\n                continue;\n                /* TERMINAL-TYPE option (end)*/\n              }\n\n              break;\n             }\n\n             return ch;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "7", "src_id": "M8", "code": "            private static String formatFileSize(long size) {\n             String hrSize;\n             double b = size;\n             double k = size / 1024.0;\n             double m = ((size / 1024.0) / 1024.0);\n             double g = (((size / 1024.0) / 1024.0) / 1024.0);\n             double t = ((((size / 1024.0) / 1024.0) / 1024.0) / 1024.0);\n             DecimalFormat dec = new DecimalFormat(\"0.00\");\n\n             if (t > 1) {\n              hrSize = dec.format(t).concat(\" TB\");\n             } else {\n              if (g <= 1) {\n               if (m > 1) {\n                hrSize = dec.format(m).concat(\" MB\");\n               } else {\n                if (k > 1) {\n                 hrSize = dec.format(k).concat(\" KB\");\n                } else {\n                 hrSize = dec.format(b).concat(\" Bytes\");\n                }\n               }\n              }else {\n               hrSize = dec.format(g).concat(\" GB\");\n              } \n             }\n\n             return hrSize;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "8", "src_id": "M790", "code": "            @Override\n            public byte[] transform(ClassLoader loader, String className, \n            Class<?> classBeingRedefined,\n            ProtectionDomain protectionDomain, \n            byte[] classfileBuffer) \n            throws IllegalClassFormatException {\n             if (className == null) {\n              return null;\n             }\n             className = className.replace('/', '.');\n\n             List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n\n             // 倒序，因为要执行的配置生效\n             ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n\n             while (listIterator.hasPrevious()) {\n              RetransformEntry retransformEntry = listIterator.previous();\n              int id = retransformEntry.getId();\n              // 判断类名是否一致\n              boolean updateFlag = false;\n\n              // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n              if (className.equals(retransformEntry.getClassName())) {\n               if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) {\n                updateFlag = isLoaderMatch(retransformEntry, loader);\n               } else {\n                updateFlag = true;\n               }\n              }\n\n              if (updateFlag) {\n               logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n               retransformEntry.incTransformCount();\n\n               return retransformEntry.getBytes();\n              }\n             }\n\n             return null;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "9", "src_id": "M716", "code": "            public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n             // 执行失败:输出失败状态\n             table.row(\"IS-RETURN\", \"\" + false);\n             table.row(\"IS-EXCEPTION\", \"\" + true);\n             // 执行失败:输出失败异常信息\n             Throwable cause;\n             Throwable t = (Throwable) throwableVO.getObject();\n             if (t instanceof InvocationTargetException) {\n              cause = t.getCause();\n             } else {\n              cause = t;\n             }\n\n             if (throwableVO.needExpand()) {\n              table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n             } else {\n              StringWriter stringWriter = new StringWriter();\n\n              PrintWriter printWriter = new PrintWriter(stringWriter);\n\n              try {\n               cause.printStackTrace(printWriter);\n\n               table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n              } finally {\n               printWriter.close();\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "10", "src_id": "M602", "code": "            private AsyncProfiler profilerInstance() {\n             if (profiler != null) {\n              return profiler;\n             }\n             // try to load from special path\n             if (ProfilerAction.load.toString().equals(action)) {\n              profiler = AsyncProfiler.getInstance(this.actionArg);\n             }\n\n             if (libPath == null) {\n              if (OSUtils.isLinux() || OSUtils.isMac()) {\n               throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n              } else {\n               throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n              }\n             } else {\n              // load from arthas directory\n              // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n              FileOutputStream tmpLibOutputStream = null;\n              FileInputStream libInputStream = null;\n\n              try {\n               File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n               tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n               libInputStream = new FileInputStream(libPath);\n               IOUtils.copy(libInputStream, tmpLibOutputStream);\n               libPath = tmpLibFile.getAbsolutePath();\n               logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n              } catch (Throwable e) {\n               logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n              } finally {\n               IOUtils.close(libInputStream);\n               IOUtils.close(tmpLibOutputStream);\n              }\n\n              profiler = AsyncProfiler.getInstance(libPath);\n             } \n\n             return profiler;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "150", "src_id": "M491", "code": "    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,@ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n\n        // save the new resize mode so it can be restored in a future session\n        player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode)\n        .apply();\n\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "151", "src_id": "M424", "code": "    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close it because when changing orientation from portrait\n            // (in fullscreen mode) the size of queue layout can be larger than the screen size\n            closeItemsList();\n        } else {\n            if (!(ACTION_PLAY_PAUSE.equals(intent.getAction()))) {\n                if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                    fragmentIsVisible = false;\n                    onFragmentStopped();\n                } else {\n                    if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n                        // Restore video source when user returns to the fragment\n                        fragmentIsVisible = true;\n                        player.useVideoSource(true);\n\n                        // When a user returns from background, the system UI will always be shown even if\n                        // controls are invisible: hide it in that case\n                        if (!isControlsVisible()) {\n                            hideSystemUIIfNeeded();\n                        }\n                    }\n                }\n            }else {\n                // Ensure that we have audio-only stream playing when a user\n                // started to play from notification's play button from outside of the app\n                if (!fragmentIsVisible) {\n                    onFragmentStopped();\n                }\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "152", "src_id": "M900", "code": "    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        final String selectedTheme = getSelectedThemeKey(context);\n\n        if (!(selectedTheme.equals(lightTheme))) {\n            if (selectedTheme.equals(blackTheme)) {\n                return R.style.BlackSettingsTheme;\n            } else {\n                if (!(selectedTheme.equals(automaticDeviceTheme))) {\n                    // default to dark theme\n                    return R.style.DarkSettingsTheme;\n                } else {\n                    if (!isDeviceDarkThemeEnabled(context)) {\n                        // there is only one day theme\n                        return R.style.LightSettingsTheme;\n                    } else {\n                        // use the dark theme variant preferred by the user\n                        final String selectedNightTheme = getSelectedNightThemeKey(context);\n                        if (selectedNightTheme.equals(blackTheme)) {\n                            return R.style.BlackSettingsTheme;\n                        } else {\n                            return R.style.DarkSettingsTheme;\n                        }\n                    } \n                } \n            }\n        }else {\n            return R.style.LightSettingsTheme;\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "153", "src_id": "M895", "code": "    @Override\n    public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n        final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n        final Bitmap result = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n        if (!(result == source || !result.isMutable())) {\n            source.recycle();\n            return result;\n        } else {\n            // create a new mutable bitmap to prevent strange crashes on some\n            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n            source.recycle();\n            return copied;\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "154", "src_id": "M225", "code": "    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                }\n                break;\n        }\n\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "155", "src_id": "M749", "code": "    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n        if (!(errorInfo.getThrowable() instanceof ReCaptchaException)) {\n            if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n                Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n            } else {\n                if (!(errorInfo.getThrowable() instanceof AgeRestrictedContentException)) {\n                    if (!(errorInfo.getThrowable() instanceof GeographicRestrictionException)) {\n                        if (errorInfo.getThrowable() instanceof PaidContentException) {\n                            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                        } else {\n                            if (!(errorInfo.getThrowable() instanceof PrivateContentException)) {\n                                if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                    Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n                                } else {\n                                    if (!(errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException)) {\n                                        if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n                                            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n                                        } else {\n                                            if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                                Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n                                            } else {\n                                                ErrorUtil.createNotification(context, errorInfo);\n                                            }\n                                        }\n                                    }else {\n                                        Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n                                    } \n                                }\n                            }else {\n                                Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                            } \n                        }\n                    }else {\n                        Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n                    } \n                }else {\n                    Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n                } \n            }\n        }else {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            // Starting ReCaptcha Challenge Activity\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } \n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "156", "src_id": "M999", "code": "    public static void openVideoDetailFragment(@NonNull final Context context,@NonNull final FragmentManager fragmentManager, final int serviceId,@Nullable final String url,@NonNull final String title,@Nullable final PlayQueue playQueue, final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n\n        if (playerType != null) {\n            if (switchingPlayers) {\n                // switching player to main player\n                autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n            } else {\n                if (playerType == PlayerType.MAIN) {\n                    // opening new stream while already playing in main player\n                    autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n                } else {\n                    // opening new stream while already playing in another player\n                    autoPlay = false;\n                }\n            }\n        }else {\n            // no player open\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } \n\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> \n        {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n\n            if (!switchingPlayers) {\n                detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            } else {\n                // Situation when user switches from players to main player. All needed data is\n                // here, we can start watching (assuming newQueue equals playQueue).\n                // Starting directly in fullscreen if the previous player type was popup.\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } \n\n            detailFragment.scrollToTop();\n        };\n\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n\n            defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n            .commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "157", "src_id": "M698", "code": "    @Override\n    public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n        } else {\n            // do not waste space for the banner, if the user disabled images or there is not one\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n\n        if (result.getSubscriberCount() < 0) {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        } else {\n            binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        } \n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n\n        channelContentNotSupported = false;\n        for (final Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n        disposables.clear();\n\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n\n        updateTabs();\n\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "158", "src_id": "M379", "code": "    import null;@Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n        final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> \n        C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n        .collect(Collectors.toList());\n\n        List<Tracks.Group>tmp = textTracks.stream().map(Tracks.Group::getMediaTrackGroup);\n\n        final List<String> availableLanguages = tmp.filter(textTrack -> textTrack.length > 0).map(textTrack -> textTrack.getFormat(0).language).collect(Collectors.toList());\n\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info -> info.getMediaTrackGroup().length >= 1)\n        .map(info -> info.getMediaTrackGroup().getFormat(0))\n        .findFirst();\n\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n\n        if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "159", "src_id": "M894", "code": "    public static RequestCreator loadScaledDownThumbnail(final Context context,@NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n            @Override\n            public Bitmap transform(final Bitmap source) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n                }\n                final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n                final Bitmap result = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n                if (!(result == source || !result.isMutable())) {\n                    source.recycle();\n                    return result;\n                } else {\n                    // create a new mutable bitmap to prevent strange crashes on some\n                    // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n                    source.recycle();\n                    return copied;\n                } \n            }\n\n            @Override\n            public String key() {\n                return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n            }\n\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "240", "src_id": "M66", "code": "            void drain() {\n             if (getAndIncrement() != 0) {\n              return;\n             }\n             int missed = 1;\n             Observer<? super R> downstream = this.downstream;\n             AtomicThrowable errors = this.errors;\n\n             AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n             for (;;) {\n              for (;;) {\n               if (cancelled) {\n                return;\n               }\n               if (errors.get() != null && !delayErrors) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n               }\n               boolean d = done;\n\n               SwitchMapMaybeObserver<R> current = inner.get();\n               boolean empty = current == null;\n               if (d && empty) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n               }\n               if (empty || current.item == null) {\n                break;\n               }\n               inner.compareAndSet(current, null);\n               downstream.onNext(current.item);\n              }\n              missed = addAndGet(-missed);\n\n              if (missed == 0) {\n               break;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "241", "src_id": "M1333", "code": "            @Override\n            public void onNext(T t) {\n             if (done) {\n              return;\n             }\n             boolean b;\n\n             try {\n              b = predicate.test(t);\n             } catch (Throwable e) {\n              Exceptions.throwIfFatal(e);\n              upstream.cancel();\n              upstream = SubscriptionHelper.CANCELLED;\n              onError(e);\n              return;\n             }\n\n             if (!b) {\n              done = true;\n              upstream.cancel();\n              upstream = SubscriptionHelper.CANCELLED;\n              downstream.onSuccess(false);\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "242", "src_id": "M522", "code": "            void drainLoop() {\n             Observer<? super T> actual = this.downstream;\n             int missed = 1;\n\n             for (;;) {\n              for (;;) {\n               if (disposed) {\n                singleItem = null;\n                queue = null;\n                return;\n               }\n               if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(actual);\n                return;\n               }\n               int os = otherState;\n\n               if (os == OTHER_STATE_HAS_VALUE) {\n                T v = singleItem;\n                singleItem = null;\n                otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                actual.onNext(v);\n               }\n\n               boolean d = mainDone;\n\n               SimplePlainQueue<T> q = queue;\n               T v = q != null ? q.poll() : null;\n               boolean empty = v == null;\n               if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                queue = null;\n                actual.onComplete();\n                return;\n               }\n               if (empty) {\n                break;\n               }\n               actual.onNext(v);\n              }\n              missed = addAndGet(-missed);\n\n              if (missed == 0) {\n               break;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "243", "src_id": "M1163", "code": "            @Override\n            void drain() {\n             if (getAndIncrement() != 0) {\n              return;\n             }\n             int missed = 1;\n             final SimplePlainQueue<Object> queue = this.queue;\n\n             final Subscriber<? super Flowable<T>> downstream = this.downstream;\n\n             UnicastProcessor<T> window = this.window;\n\n             for (;;) {\n              if (upstreamCancelled) {\n               queue.clear();\n               window = null;\n               this.window = null;\n              } else {\n               boolean isDone = done;\n               Object o = queue.poll();\n               boolean isEmpty = o == null;\n\n               if (isDone && isEmpty) {\n                Throwable ex = error;\n                if (ex != null) {\n                 if (window != null) {\n                  window.onError(ex);\n                 }\n                 downstream.onError(ex);\n                } else {\n                 if (window != null) {\n                  window.onComplete();\n                 }\n                 downstream.onComplete();\n                }\n\n                cleanupResources();\n\n                upstreamCancelled = true;\n                continue;\n               } else {\n                if (!isEmpty) {\n                 if (o instanceof WindowBoundaryRunnable) {\n                  WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                  if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                   this.count = 0;\n                   window = createNewWindow(window);\n                  }\n                 } else {\n                  if (window != null) {\n                   @SuppressWarnings(\"unchecked\") T item = (T) o;\n                   window.onNext(item);\n                   long count = this.count + 1;\n                   if (count != maxSize) {\n                    this.count = count;\n                   } else {\n                    this.count = 0;\n                    window = createNewWindow(window);\n                   } \n                  }\n                 }\n                 continue;\n                }\n               }\n              }\n              missed = addAndGet(-missed);\n\n              if (missed == 0) {\n               break;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "244", "src_id": "M478", "code": "            void drain() {\n             if (getAndIncrement() != 0) {\n              return;\n             }\n             int missed = 1;\n             EqualObserver<T>[] as = observers;\n             final EqualObserver<T> observer1 = as[0];\n\n             final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n\n             final EqualObserver<T> observer2 = as[1];\n\n             final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n             for (;;) {\n              for (;;) {\n               if (cancelled) {\n                q1.clear();\n                q2.clear();\n                return;\n               }\n               boolean d1 = observer1.done;\n               if (d1) {\n                Throwable e = observer1.error;\n                if (e != null) {\n                 cancel(q1, q2);\n                 downstream.onError(e);\n                 return;\n                }\n               }\n               boolean d2 = observer2.done;\n\n               if (d2) {\n                Throwable e = observer2.error;\n                if (e != null) {\n                 cancel(q1, q2);\n                 downstream.onError(e);\n                 return;\n                }\n               }\n               if (v1 == null) {\n                v1 = q1.poll();\n               }\n               boolean e1 = v1 == null;\n               if (v2 == null) {\n                v2 = q2.poll();\n               }\n               boolean e2 = v2 == null;\n               if (d1 && d2 && e1 && e2) {\n                downstream.onSuccess(true);\n                return;\n               }\n               if ((d1 && d2) && (e1 != e2)) {\n                cancel(q1, q2);\n                downstream.onSuccess(false);\n                return;\n               }\n\n               if (!e1 && !e2) {\n                boolean c;\n                try {\n                 c = comparer.test(v1, v2);\n                } catch (Throwable ex) {\n                 Exceptions.throwIfFatal(ex);\n                 cancel(q1, q2);\n                 downstream.onError(ex);\n                 return;\n                }\n\n                if (!c) {\n                 cancel(q1, q2);\n                 downstream.onSuccess(false);\n                 return;\n                }\n\n                v1 = null;\n                v2 = null;\n               }\n\n               if (e1 || e2) {\n                break;\n               }\n              }\n              missed = addAndGet(-missed);\n\n              if (missed == 0) {\n               break;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "245", "src_id": "M885", "code": "            void drainLoop() {\n             int missed = 1;\n\n             JoinInnerSubscriber<T>[] s = this.subscribers;\n             int n = s.length;\n             Subscriber<? super T> a = this.downstream;\n\n             for (;;) {\n              long r = requested.get();\n              long e = 0;\n\n              middle:\n              while (e != r) {\n               if (cancelled) {\n                cleanup();\n                return;\n               }\n               Throwable ex = errors.get();\n               if (ex != null) {\n                cleanup();\n                a.onError(ex);\n                return;\n               }\n               boolean d = done.get() == 0;\n               boolean empty = true;\n\n               for (int i = 0; i < s.length; i++) {\n                JoinInnerSubscriber<T> inner = s[i];\n                SimplePlainQueue<T> q = inner.queue;\n\n                if (q != null) {\n                 T v = q.poll();\n\n                 if (v != null) {\n                  empty = false;\n                  a.onNext(v);\n                  inner.requestOne();\n                  if (++e == r) {\n                   break middle;\n                  }\n                 }\n                }\n               }\n\n               if (d && empty) {\n                a.onComplete();\n                return;\n               }\n\n               if (empty) {\n                break;\n               }\n              }\n\n              if (e == r) {\n               if (cancelled) {\n                cleanup();\n                return;\n               }\n               Throwable ex = errors.get();\n               if (ex != null) {\n                cleanup();\n                a.onError(ex);\n                return;\n               }\n               boolean d = done.get() == 0;\n               boolean empty = true;\n\n               for (int i = 0; i < n; i++) {\n                JoinInnerSubscriber<T> inner = s[i];\n                SimpleQueue<T> q = inner.queue;\n\n                if (q != null && !q.isEmpty()) {\n                 empty = false;\n                 break;\n                }\n               }\n\n               if (d && empty) {\n                a.onComplete();\n                return;\n               }\n              }\n\n              if (e != 0) {\n               BackpressureHelper.produced(requested, e);\n              }\n\n              missed = addAndGet(-missed);\n              if (missed == 0) {\n               break;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "246", "src_id": "M1399", "code": "            @Override\n            public void drain() {\n             if (getAndIncrement() != 0) {\n              return;\n             }\n             int missed = 1;\n             InnerQueuedSubscriber<R> inner = current;\n             Subscriber<? super R> a = downstream;\n             ErrorMode em = errorMode;\n\n             for (;;) {\n              long r = requested.get();\n              long e = 0L;\n\n              if (inner == null) {\n               if (em != ErrorMode.END) {\n                Throwable ex = errors.get();\n                if (ex != null) {\n                 cancelAll();\n                 errors.tryTerminateConsumer(downstream);\n                 return;\n                }\n               }\n               boolean outerDone = done;\n               inner = subscribers.poll();\n               if (outerDone && inner == null) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n               }\n               if (inner != null) {\n                current = inner;\n               }\n              }\n\n              boolean continueNextSource = false;\n\n              if (inner != null) {\n               SimpleQueue<R> q = inner.queue();\n               if (q != null) {\n                while (e != r) {\n                 if (cancelled) {\n                  cancelAll();\n                  return;\n                 }\n                 if (em == ErrorMode.IMMEDIATE) {\n                  Throwable ex = errors.get();\n                  if (ex != null) {\n                   current = null;\n                   inner.cancel();\n                   cancelAll();\n                   errors.tryTerminateConsumer(downstream);\n                   return;\n                  }\n                 }\n\n                 boolean d = inner.isDone();\n\n                 R v;\n                 try {\n                  v = q.poll();\n                 } catch (Throwable ex) {\n                  Exceptions.throwIfFatal(ex);\n                  current = null;\n                  inner.cancel();\n                  cancelAll();\n                  a.onError(ex);\n                  return;\n                 }\n                 boolean empty = v == null;\n\n                 if (d && empty) {\n                  inner = null;\n                  current = null;\n                  upstream.request(1);\n                  continueNextSource = true;\n                  break;\n                 }\n                 if (empty) {\n                  break;\n                 }\n                 a.onNext(v);\n                 e++;\n                 inner.request(1L);\n                }\n                if (e == r) {\n                 if (cancelled) {\n                  cancelAll();\n                  return;\n                 }\n                 if (em == ErrorMode.IMMEDIATE) {\n                  Throwable ex = errors.get();\n                  if (ex != null) {\n                   current = null;\n                   inner.cancel();\n                   cancelAll();\n                   errors.tryTerminateConsumer(downstream);\n                   return;\n                  }\n                 }\n\n                 boolean d = inner.isDone();\n\n                 boolean empty = q.isEmpty();\n                 if (d && empty) {\n                  inner = null;\n                  current = null;\n                  upstream.request(1);\n                  continueNextSource = true;\n                 }\n                }\n               }\n              }\n\n              if (e != 0L && r != Long.MAX_VALUE) {\n               requested.addAndGet(-e);\n              }\n\n              if (continueNextSource) {\n               continue;\n              }\n              missed = addAndGet(-missed);\n              if (missed == 0) {\n               break;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "247", "src_id": "M469", "code": "            @SuppressWarnings(\"unchecked\") void remove(CacheDisposable<T> consumer) {\n             for (;;) {\n              CacheDisposable<T>[] current = observers.get();\n              int n = current.length;\n              if (n == 0) {\n               return;\n              }\n              int j = -1;\n              for (int i = 0; i < n; i++) {\n               if (current[i] == consumer) {\n                j = i;\n                break;\n               }\n              }\n              if (j < 0) {\n               return;\n              }\n              CacheDisposable<T>[] next;\n\n              if (n == 1) {\n               next = EMPTY;\n              } else {\n               next = new CacheDisposable[n - 1];\n               System.arraycopy(current, 0, next, 0, j);\n               System.arraycopy(current, j + 1, next, j, n - j - 1);\n              }\n\n              if (observers.compareAndSet(current, next)) {\n               return;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "248", "src_id": "M362", "code": "            void drainFused() {\n             int missed = 1;\n             for (;;) {\n              if (disposed) {\n               return;\n              }\n              boolean d = done;\n              Throwable ex = error;\n              if (!delayError && d && ex != null) {\n               disposed = true;\n               downstream.onError(error);\n               worker.dispose();\n               return;\n              }\n              downstream.onNext(null);\n\n              if (d) {\n               disposed = true;\n               ex = error;\n               if (ex != null) {\n                downstream.onError(ex);\n               } else {\n                downstream.onComplete();\n               }\n               worker.dispose();\n               return;\n              }\n\n              missed = addAndGet(-missed);\n\n              if (missed == 0) {\n               break;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "249", "src_id": "M2247", "code": "            @SuppressWarnings(\"unchecked\") void remove(PublishSubscription<T> ps) {\n             for (;;) {\n              PublishSubscription<T>[] a = subscribers.get();\n              if (a == TERMINATED || a == EMPTY) {\n               return;\n              }\n              int n = a.length;\n              int j = -1;\n              for (int i = 0; i < n; i++) {\n               if (a[i] == ps) {\n                j = i;\n                break;\n               }\n              }\n              if (j < 0) {\n               return;\n              }\n              PublishSubscription<T>[] b;\n\n              if (n == 1) {\n               b = EMPTY;\n              } else {\n               b = new PublishSubscription[n - 1];\n               System.arraycopy(a, 0, b, 0, j);\n               System.arraycopy(a, j + 1, b, j, n - j - 1);\n              }\n\n              if (subscribers.compareAndSet(a, b)) {\n               return;\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "105", "src_id": "M1277", "code": "    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n            if (!(obj instanceof byte[])) {\n                if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                    redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                    str = geo.getLongitude() + \",\" + geo.getLatitude();\n\n                } else {\n                    if (obj instanceof String) {\n                        if (stringEscape) { \n                            str = escape((String) obj); \n                        } else { \n                            str = (String) obj; \n                        } \n                    } else {\n                        str = String.valueOf(obj);\n                    }\n                }\n            }else {\n                str = SafeEncoder.encode((byte[]) obj);\n            } \n            output.put(key, str);\n        }\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "106", "src_id": "M902", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "107", "src_id": "M1131", "code": "    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE : // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n                // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "108", "src_id": "M1057", "code": "    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n\n        }\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "109", "src_id": "M1229", "code": "    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode != SslVerifyMode.FULL) {\n            if (sslVerifyMode == SslVerifyMode.CA) {\n                this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n            } else {\n                if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                    trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n                }\n            }\n        }else {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } \n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n\n        }\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n\n        }\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "110", "src_id": "M894", "code": "    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap<>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            if (!(value instanceof List)) {\n                if (value instanceof byte[]) {\n                    value = BuilderFactory.STRING.build(value);\n                    if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                        try {\n                            value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                        } catch (Exception e) { }\n                    }\n\n                }\n            } else {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n                        value = labels;\n                        break;\n                    case RULES_PROPERTY:\n                        List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                        Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                        rules = new HashMap<>(rulesDataList.size());\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n\n                        }\n                        value = rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                        List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                        chunks = new ArrayList<>(chunksDataList.size());\n                        for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n                            chunks.add(chunk);\n                        }\n                        value = chunksValueList;\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } \n            properties.put(prop, value);\n        }\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "111", "src_id": "M897", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null || duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "112", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis != null) { \n                    jedis.ping();\n                    return jedis;\n                } \n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "113", "src_id": "M9", "code": "    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n            stats.load();\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1105", "code": "    @Override\n    public Class<?> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "250", "src_id": "M342", "code": "  private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n    if (emlBytes == null) {\n      throw new IllegalArgumentException(\"EML file is empty or null\");\n    }\n    if (emlBytes.length == 0) {\n    throw new IllegalArgumentException(\"EML file is empty or null\");\n      }\n    String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n    // Basic email parsing\n    String subject = extractBasicHeader(emlContent, \"Subject:\");\n    String from = extractBasicHeader(emlContent, \"From:\");\n    String to = extractBasicHeader(emlContent, \"To:\");\n    String cc = extractBasicHeader(emlContent, \"Cc:\");\n    String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n    String date = extractBasicHeader(emlContent, \"Date:\");\n    // Try to extract HTML content\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n      String textBody = extractTextBody(emlContent);\n      htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n    // Generate HTML with custom styling based on request\n    StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n\n    html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n    // Include CC and BCC if present and requested\n    if (request != null && request.isIncludeAllRecipients()) {\n      if (!cc.trim().isEmpty()) {\n        html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n      }\n      if (!bcc.trim().isEmpty()) {\n        html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n      }\n    }\n    if (!date.trim().isEmpty()) {\n      html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    html.append(processEmailHtmlBody(htmlBody));\n    html.append(\"</div>\\n\");\n    // Add attachment information - always check for and display attachments\n    String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n      html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n      html.append(\"<h3>Attachments</h3>\\n\");\n      html.append(attachmentInfo);\n      // Add a status message about attachment inclusion\n      if (request != null && request.isIncludeAttachments()) {\n        html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n        html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n        html.append(\"</div>\\n\");\n      } else {\n        html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n        html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n      }\n      html.append(\"</div>\\n\");\n    }\n    // Show advanced features status if requested\n    assert request != null;\n    if (request.getFileInput().isEmpty()) {\n      html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n      html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n      html.append(\"</div>\\n\");\n    }\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n    return html.toString();\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "251", "src_id": "M371", "code": "  private static boolean isValidJakartaMailMultipart(Object multipart) {\n    if (multipart == null) {\n      return false;\n    }\n    try {\n      // Check if the object implements jakarta.mail.Multipart interface\n      Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n      if (!multipartInterface.isInstance(multipart)) {\n        return false;\n      }\n      // Additional check for MimeMultipart\n      try {\n        Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n        if (mimeMultipartClass.isInstance(multipart)) {\n          log.debug(\"Found MimeMultipart instance for enhanced processing\");\n          return true;\n        }\n      } catch (ClassNotFoundException e) {\n        log.debug(\"MimeMultipart not available, using base Multipart interface\");\n      }\n      return true;\n    } catch (ClassNotFoundException e) {\n      log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n      return false;\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "252", "src_id": "M348", "code": "  private static String extractBasicHeader(String emlContent, String headerName) {\n    try {\n      String[] lines = emlContent.split(\"\\r?\\n\");\n      for (int i = 0; i < lines.length; i++) {\n        String line = lines[i];\n        if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n          StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n          // Handle multi-line headers\n          for (int j = i + 1; j < lines.length; j++) {\n            if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n              value.append(\" \").append(lines[j].trim());\n            } else {\n              break;\n            }\n          }\n          // Apply MIME header decoding\n          return safeMimeDecode(value.toString());\n        }\n        if (line.trim().isEmpty()) {\n          break;\n        }\n      }\n    } catch (RuntimeException e) {\n      log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n    }\n    return \"\";\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "253", "src_id": "M364", "code": "  private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n    if (document.getNumberOfPages() == 0 || attachments == null) {\n      return;\n    }\n    // 1. Find the screen position of all attachment markers\n    if (attachments.isEmpty()) {\n    return;\n      }\n    // 1. Find the screen position of all attachment markers\n    AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n    finder.setSortByPosition(true); // Process pages in order\n    finder.getText(document);\n    List<MarkerPosition> markerPositions = finder.getPositions();\n    // 2. Warn if the number of markers and attachments don't match\n    if (markerPositions.size() != attachments.size()) {\n      log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n    }\n    // 3. Create an invisible annotation over each found marker\n    int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n    for (int i = 0; i < annotationsToAdd; i++) {\n      MarkerPosition position = markerPositions.get(i);\n      EmailAttachment attachment = attachments.get(i);\n      if (attachment.getEmbeddedFilename() != null) {\n        PDPage page = document.getPage(position.getPageIndex());\n        addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n      }\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "115", "src_id": "M1277", "code": "    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n            if (!(obj instanceof byte[])) {\n\n                if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                    redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                    str = geo.getLongitude() + \",\" + geo.getLatitude();\n                } else {\n                    if (obj instanceof String) {\n                        str = stringEscape ? escape((String) obj) : (String) obj;\n                    } else {\n                        str = String.valueOf(obj);\n                    }\n                }\n            }else {\n                str = SafeEncoder.encode((byte[]) obj);\n            } \n            output.put(key, str);\n        }\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "116", "src_id": "M902", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1131", "code": "    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE : // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n                // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1057", "code": "    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1229", "code": "    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode != SslVerifyMode.FULL) {\n            if (sslVerifyMode == SslVerifyMode.CA) {\n                this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n            } \n\n            else {\n                if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                    trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n                }\n            }\n        }else {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } \n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "120", "src_id": "M894", "code": "    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap<>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            if (!(value instanceof List)) {\n                if (value instanceof byte[]) {\n                    value = BuilderFactory.STRING.build(value);\n                    if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                        try {\n                            value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                        } \n                        catch (Exception e) { }\n                    }\n                }\n            } else {\n\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n                        value = labels;\n                        break;\n                    case RULES_PROPERTY:\n                        List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                        Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                        rules = new HashMap<>(rulesDataList.size());\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                        }\n                        value = rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                        List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                        chunks = new ArrayList<>(chunksDataList.size());\n                        for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n                            chunks.add(chunk);\n                        }\n                        value = chunksValueList;\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } \n            properties.put(prop, value);\n        }\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "121", "src_id": "M897", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null\n        || duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "122", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis != null) { \n                    jedis.ping();\n                    return jedis;\n                } \n            } \n            catch (JedisException ex) \n            {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "123", "src_id": "M9", "code": "    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n\n            policy.touch(cacheKey);\n\n            CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) { \n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                    continue; \n                } \n\n                else { \n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                } \n            }\n            stats.load();\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "124", "src_id": "M1105", "code": "    @Override\n    public Class<?> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "254", "src_id": "M66", "code": "    void drain() {\n        if (getAndIncrement() != 0) \n        {\n            return;\n        }\n        int missed = 1;\n        Observer<? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n        while (true) {\n\n            while (true) {\n                if (cancelled) \n                {\n                    return;\n                }\n                if (errors.get() != null && !delayErrors) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                boolean d = done;\n                SwitchMapMaybeObserver<R> current = inner.get();\n                boolean empty = current == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (empty || current.item == null) \n                {\n                    break;\n                }\n                inner.compareAndSet(current, null);\n\n                downstream.onNext(current.item);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) \n            {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "255", "src_id": "M1333", "code": "    @Override\n    public void onNext(T t) {\n        if (done) {\n            return;\n        }\n        boolean b;\n        try {\n            b = predicate.test(t);\n        } \n        catch (Throwable e) \n        {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n\n            downstream.onSuccess(false);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "256", "src_id": "M522", "code": "    void drainLoop() {\n        Observer<? super T> actual = this.downstream;\n        int missed = 1;\n        while (true) {\n\n            while (true) {\n                if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n                    return;\n                }\n                int os = otherState;\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n\n                    actual.onNext(v);\n                }\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n\n                T v = null; \n\n                if (q != null) { \n                    v = q.poll(); \n                } \n                boolean empty = v == null;\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n\n                actual.onNext(v);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) \n            {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "257", "src_id": "M1163", "code": "    @Override void drain() {\n        if (getAndIncrement() != 0) \n        {\n            return;\n        }\n        int missed = 1;\n        final SimplePlainQueue<Object> queue = this.queue;\n        final Subscriber<? super Flowable<T>> downstream = this.downstream;\n        UnicastProcessor<T> window = this.window;\n        while (true) {\n\n            if (upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n                        downstream.onComplete();\n                    }\n                    cleanupResources();\n                    upstreamCancelled = true;\n                    continue;\n                } else {\n\n                    if (!isEmpty) {\n\n                        if (o instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted \n                            || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else {\n                            if (window != null) {\n                                @SuppressWarnings(\"unchecked\") T item = (T) o;\n                                window.onNext(item);\n\n                                long count = this.count + 1;\n                                if (count != maxSize) {\n                                    this.count = count;\n                                } else {\n                                    this.count = 0;\n                                    window = createNewWindow(window);\n                                } \n                            }\n                        }\n                        continue;\n                    }\n                }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) \n            {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "258", "src_id": "M478", "code": "    void drain() {\n        if (getAndIncrement() != 0) \n        {\n            return;\n        }\n        int missed = 1;\n\n        EqualObserver<T>[] as = observers;\n        final EqualObserver<T> observer1 = as[0];\n        final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n        final EqualObserver<T> observer2 = as[1];\n        final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n        while (true) {\n\n            while (true) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n                boolean d1 = observer1.done;\n                if (d1) {\n                    Throwable e = observer1.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                boolean d2 = observer2.done;\n                if (d2) {\n                    Throwable e = observer2.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n                boolean e1 = v1 == null;\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n                boolean e2 = v2 == null;\n\n                if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n                if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(v1, v2);\n                    } \n                    catch (Throwable ex) \n                    {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n                    v1 = null;\n                    v2 = null;\n                }\n                if (e1 || e2) {\n                    break;\n                }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) \n            {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "259", "src_id": "M885", "code": "    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T>[] s = this.subscribers;\n\n        int n = s.length;\n        Subscriber<? super T> a = this.downstream;\n        while (true) {\n            long r = requested.get();\n            long e = 0;\n            middle:\n            while (e != r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n\n                boolean empty = true;\n                for (int i = 0; i < s.length; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimplePlainQueue<T> q = inner.queue;\n                    if (q != null) {\n                        T v = q.poll();\n                        if (v != null) {\n                            empty = false;\n                            a.onNext(v);\n                            inner.requestOne();\n                            if (++e == r) {\n                                break middle;\n                            }\n                        }\n                    }\n                }\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n            }\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n\n                boolean empty = true;\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimpleQueue<T> q = inner.queue;\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) \n            {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "260", "src_id": "M1399", "code": "    @Override\n    public void drain() {\n        if (getAndIncrement() != 0) \n        {\n            return;\n        }\n        int missed = 1;\n        InnerQueuedSubscriber<R> inner = current;\n        Subscriber<? super R> a = downstream;\n        ErrorMode em = errorMode;\n        while (true) {\n            long r = requested.get();\n            long e = 0L;\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n                boolean outerDone = done;\n                inner = subscribers.poll();\n                if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n            boolean continueNextSource = false;\n            if (inner != null) {\n                SimpleQueue<R> q = inner.queue();\n                if (q != null) {\n\n                    while (e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n                        boolean d = inner.isDone();\n                        R v;\n                        try {\n                            v = q.poll();\n                        } \n                        catch (Throwable ex) \n                        {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n                        if (empty) {\n                            break;\n                        }\n\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n                        boolean d = inner.isDone();\n                        boolean empty = q.isEmpty();\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n            if (!continueNextSource) { \n                missed = addAndGet(-missed);\n                if (missed == 0) \n                {\n                    break;\n                }\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "261", "src_id": "M469", "code": "    @SuppressWarnings(\"unchecked\") void remove(CacheDisposable<T> consumer) {\n\n        while (true) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n\n            if (n == 0) {\n                return;\n            }\n            int j = -1;\n\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) \n                {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n            CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "262", "src_id": "M362", "code": "    void drainFused() {\n        int missed = 1;\n        while (true) {\n            if (disposed) {\n                return;\n            }\n            boolean d = done;\n            Throwable ex = error;\n            if (!delayError && d && ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n            downstream.onNext(null);\n            if (d) {\n                disposed = true;\n                ex = error;\n\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n\n                worker.dispose();\n\n                return;\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) \n            {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "263", "src_id": "M2247", "code": "    @SuppressWarnings(\"unchecked\") void remove(PublishSubscription<T> ps) {\n\n        while (true) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED \n            || a == EMPTY) \n            {\n                return;\n            }\n            int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n            PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "209", "src_id": "M342", "code": "    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null \n        || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n        // Generate HTML with custom styling based on request\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n\n        html.append(\"</head><body>\\n\");\n\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n\n        html.append(\"</div>\\n\");\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n            html.append(\"</div>\\n\");\n        }\n        // Show advanced features status if requested\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "210", "src_id": "M371", "code": "    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) {\n            return false;\n        }\n        try {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n            // Additional check for MimeMultipart\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) \n            {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n            return true;\n        } catch (ClassNotFoundException e) \n        {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "211", "src_id": "M348", "code": "    private static String extractBasicHeader(String emlContent, String headerName) {\n\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") \n                        || lines[j].startsWith(\"\\t\")) { \n                            value.append(\" \").append(lines[j].trim());\n                            continue; \n                        } else { break;\n                        } \n                    }\n                    // Apply MIME header decoding\n                    return safeMimeDecode(value.toString());\n                }\n                if (line.trim().isEmpty()) {break;\n                }\n            }\n        } catch (RuntimeException e) \n        {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "212", "src_id": "M364", "code": "    private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 \n        || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n        // 1. Find the screen position of all attachment markers\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true); // Process pages in order\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n        // 2. Warn if the number of markers and attachments don't match\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n        // 3. Create an invisible annotation over each found marker\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "273", "src_id": "M1043", "code": "  private void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    Thread thread = Thread.currentThread();\n    notifyPostProcessing(1);\n    if (DEBUG) {\n      thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n    Exception exception = null;\n    try {\n      psAlgorithm.run(this);\n    } catch (Exception err) {\n      Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n      if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException) {\n        notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n        return;\n      }\n      if (thread.isInterrupted()) {\n      notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n        return;\n        }\n      if (errCode == ERROR_NOTHING) {\n        errCode = ERROR_POSTPROCESSING;\n      }\n      exception = err;\n    } finally {\n      notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n    if (errCode != ERROR_NOTHING) {\n      if (exception == null) {\n        exception = errObject;\n      }\n      notifyError(ERROR_POSTPROCESSING, exception);\n      return;\n    }\n    notifyFinished();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "274", "src_id": "M1031", "code": "  void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n    int statusCode = conn.getResponseCode();\n    if (DEBUG) {\n      Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n      Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n\n      Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n      Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n    }\n    switch (statusCode) {\n      case 204:\n      case 205:\n      case 207:\n        throw new HttpError(statusCode);\n      case 416:\n        return; // let the download thread handle this error\n      default:\n        if (statusCode < 200) {\n          throw new HttpError(statusCode);\n        }\n        if (statusCode > 299) {\n        throw new HttpError(statusCode);\n          }\n        }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "275", "src_id": "M827", "code": "  private Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n\n    if (b == null) {\n      return null;\n    }\n    final Elst obj = new Elst();\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n      obj.bMediaRate = 0x00010000; // default media rate (1.0)\n      return obj;\n    }\n    if (!v1) {\n      stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n      obj.mediaTime = stream.readInt();\n    } else {\n      stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n      obj.mediaTime = stream.readLong();\n      // ignore all remain entries\n      stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n    } \n    obj.bMediaRate = stream.readInt();\n    return obj;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "276", "src_id": "M1048", "code": "  @Override\n  public void run() {\n    boolean done;\n    long start = mMission.fallbackResumeOffset;\n    if (DEBUG && !mMission.unknownLength && start > 0) {\n      Log.i(TAG, \"Resuming a single-thread download at \" + start);\n    }\n    try {\n      long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n      int mId = 1;\n      mConn = mMission.openConnection(false, rangeStart, -1);\n      if (mRetryCount == 0 && rangeStart == -1) {\n        // workaround: bypass android connection pool\n        mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n      }\n\n      mMission.establishConnection(mId, mConn);\n      // check if the download can be resumed\n      if (mConn.getResponseCode() == 416 && start > 0) {\n        mMission.notifyProgress(-start);\n        start = 0;\n        mRetryCount--;\n        throw new DownloadMission.HttpError(416);\n      }\n      // secondary check for the file length\n      if (!mMission.unknownLength)\n      {\n        mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n      }\n      if (mMission.unknownLength) {\n        // restart amount of bytes downloaded\n        mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n      }\n      if (mConn.getResponseCode() == 200) {\n      // restart amount of bytes downloaded\n      mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n        }\n      mF = mMission.storage.getStream();\n      mF.seek(mMission.offsets[mMission.current] + start);\n      mIs = mConn.getInputStream();\n      byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n      int len = 0;\n      while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n        mF.write(buf, 0, len);\n        start += len;\n        mMission.notifyProgress(len);\n      }\n      dispose();\n      // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n      done = len == -1;\n    } catch (Exception e) {\n      dispose();\n      mMission.fallbackResumeOffset = start;\n      if (!mMission.running || e instanceof ClosedByInterruptException) {\n        return;\n      }\n      if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n        // for youtube streams. The url has expired, recover\n        dispose();\n        mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n        return;\n      }\n      if (mRetryCount++ >= mMission.maxRetry) {\n        mMission.notifyError(e);\n        return;\n      }\n      if (DEBUG) {\n        Log.e(TAG, \"got exception, retrying...\", e);\n      }\n      run(); // try again\n      return;\n    }\n    if (done) {\n      mMission.notifyFinished();\n    } else {\n      mMission.fallbackResumeOffset = start;\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "277", "src_id": "M1141", "code": "  private void flushAuxiliar(long amount) throws IOException {\n    if (aux.length < 1) {\n      return;\n    }\n    out.flush();\n    aux.flush();\n    boolean underflow = aux.offset < aux.length || out.offset < out.length;\n    byte[] buffer = new byte[COPY_BUFFER_SIZE];\n    aux.target.seek(0);\n    out.target.seek(out.length);\n    long length = amount;\n    while (length > 0) {\n      int read = (int) Math.min(length, Integer.MAX_VALUE);\n      read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n      if (read < 1) {\n        amount -= length;\n        break;\n      }\n      out.writeProof(buffer, read);\n      length -= read;\n    }\n    if (!underflow) {\n      out.offset += amount;\n      aux.offset -= amount;\n    } else {\n      if (out.offset < out.length) {\n        aux.offset = 0;\n      } else {\n        // calculate the aux underflow pointer\n        if (aux.offset >= amount) {\n          aux.offset -= amount;\n          out.offset = out.length + amount;\n        } else {\n          out.offset += aux.offset;\n          aux.offset = 0;\n          out.target.seek(out.offset);\n        } \n      } \n    } \n    out.length += amount;\n    if (out.length > maxLengthKnown) {\n      maxLengthKnown = out.length;\n    }\n    if (amount < aux.length) {\n      // move the excess data to the beginning of the file\n      long readOffset = amount;\n      long writeOffset = 0;\n      aux.length -= amount;\n      length = aux.length;\n      while (length > 0) {\n        int read = (int) Math.min(length, Integer.MAX_VALUE);\n        read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n        aux.target.seek(writeOffset);\n        aux.writeProof(buffer, read);\n        writeOffset += read;\n        readOffset += read;\n        length -= read;\n        aux.target.seek(readOffset);\n      }\n      aux.target.setLength(aux.length);\n      return;\n    }\n    if (aux.length > THRESHOLD_AUX_LENGTH) {\n      aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n    }\n    aux.reset();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "278", "src_id": "M1106", "code": "  private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n    StringBuilder request = new StringBuilder(256);\n    request.append(mission.source);\n    request.append(\" [\");\n\n    if (mission.recoveryInfo != null) {\n      for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n      {\n        request.append(' ').append(recovery.toString()).append(' ');\n      }\n    }\n    request.append(\"]\");\n    String service;\n    try {\n      service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e) {\n      service = ErrorInfo.SERVICE_NONE;\n    }\n    ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "279", "src_id": "M1067", "code": "  void startMission(DownloadMission mission) {\n    synchronized (this) {\n      mission.timestamp = System.currentTimeMillis();\n      mission.mHandler = mHandler;\n      mission.maxRetry = mPrefMaxRetry;\n      // create metadata file\n      while (true) {\n        mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n        if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n          try {\n            if (!mission.metadata.createNewFile())\n            {\n              throw new RuntimeException(\"Cant create download metadata file\");\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n          break;\n        }\n        mission.timestamp = System.currentTimeMillis();\n      }\n      mSelfMissionsControl = true;\n      mMissionsPending.add(mission);\n      // Before continue, save the metadata in case the internet connection is not available\n      Utility.writeToFile(mission.metadata, mission);\n      if (mission.storage == null) {\n        // noting to do here\n        mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n        if (mission.errObject != null)\n        {\n          mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n        }\n        return;\n      }\n      boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n      if (canDownloadInCurrentNetwork() && start) {\n        mission.start();\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "280", "src_id": "M1136", "code": "  @Override int process(SharpStream out, SharpStream... sources) throws IOException {\n    // check if the subtitle is already in srt and copy, this should never happen\n    String format = getArgumentAt(0, null);\n    boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n    if (!(format == null || format.equals(\"ttml\"))) {\n      if (format.equals(\"srt\")) {\n        byte[] buffer = new byte[8 * 1024];\n        int read;\n        while ((read = sources[0].read(buffer)) > 0) {\n          out.write(buffer, 0, read);\n        }\n        return OK_RESULT;\n      }\n    } else {\n      SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n      try {\n        writer.build(sources[0]);\n      } catch (Exception err) {\n        Log.e(TAG, \"subtitle parse failed\", err);\n        return err instanceof IOException ? 1 : 8;\n      }\n      return OK_RESULT;\n    } \n    throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "281", "src_id": "M1047", "code": "  private void joinForThreads(int millis) {\n    final Thread currentThread = Thread.currentThread();\n    if (init != null && init != currentThread && init.isAlive()) {\n      init.interrupt();\n      if (millis > 0) {\n        try {\n          init.join(millis);\n        } catch (InterruptedException e) {\n          Log.w(TAG, \"Initializer thread is still running\", e);\n          return;\n        }\n      }\n    }// if a thread is still alive, possible reasons:\n    //      slow device\n    //      the user is spamming start/pause buttons\n    //      start() method called quickly after pause()\n\n    for (Thread thread : threads) {\n      if (!thread.isAlive() || thread == Thread.currentThread()) {\n        continue;\n      }\n      thread.interrupt();\n    }\n    try {\n      for (Thread thread : threads) {\n        if (!thread.isAlive()) {\n          continue;\n        }\n        if (DEBUG) {\n          Log.w(TAG, \"thread alive: \" + thread.getName());\n        }\n        if (millis > 0) {\n          thread.join(millis);\n        }\n      }\n    } catch (InterruptedException e) {\n      throw new RuntimeException(\"A download thread is still running\", e);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "170", "src_id": "M31", "code": "        import null;private JsonNode validateLicense(String licenseKey, \n        String machineFingerprint, \n        LicenseContext context)throws Exception {\n            String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n            HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")// .header(\"Authorization\", \"License \" + licenseKey)\n            .POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n\n            JsonNode jsonResponse = objectMapper.readTree(response.body());\n\n            if (response.statusCode() == 200) {\n                JsonNode metaNode = jsonResponse.path(\"meta\");\n                boolean isValid = metaNode.path(\"valid\").asBoolean();\n\n                String detail = metaNode.path(\"detail\").asText();\n\n                String code = metaNode.path(\"code\").asText();\n\n                log.info(\"License validity: {}\", isValid);\n\n                log.info(\"Validation detail: {}\", detail);\n\n                log.info(\"Validation code: {}\", code);\n\n                // Check if the license itself has floating attribute\n                JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n\n                if (!licenseAttrs.isMissingNode()) {\n                    context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                    context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n\n                    log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n                }\n\n                // Also check the policy for floating license support if included\n                JsonNode includedNode = jsonResponse.path(\"included\");\n\n                JsonNode policyNode = null;\n\n                if (includedNode.isArray()) {\n                    for (JsonNode node : includedNode) {\n                        if (\"policies\".equals(node.path(\"type\").asText())) {\n                            policyNode = node;\n                            break;\n                        }\n                    }\n                }\n\n                if (policyNode != null) {\n                    // Check if this is a floating license from policy\n                    boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                    int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n                    // Policy takes precedence over license attributes\n                    if (policyFloating) {\n                        context.isFloatingLicense = true;\n                        context.maxMachines = policyMaxMachines;\n                    }\n\n                    log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n                }\n\n                // Extract user count, default to 1 if not specified\n                JsonNode tmp = jsonResponse.path(\"data\");\n\n                int users = tmp.path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n\n                applicationProperties.getPremium().setMaxUsers(users);\n\n                // Extract isEnterprise flag\n                context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n\n                log.debug(applicationProperties.toString());\n            } else {\n                log.error(\"Error validating license. Status code: {}\", response.statusCode());\n            }\n\n            return jsonResponse;\n        }\n", "compilable": false, "test_passed": false, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "171", "src_id": "M488", "code": "        @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n        @Operation(\n        summary = \"Convert a file to a PDF using LibreOffice\",\n        description =\n        \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n        public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n        throws Exception {\n            MultipartFile inputFile = generalFile.getFileInput();\n            // unused but can start server instance if startup time is to long\n            // LibreOfficeListener.getInstance().start();\n            File file = null;\n\n            try {\n                file = convertToPdf(inputFile);\n                PDDocument doc = pdfDocumentFactory.load(file);\n\n                return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n            } finally {\n                if (file != null) {\n                    file.delete();\n                }\n            }\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "172", "src_id": "M625", "code": "        @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n        @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n        public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request)throws IOException {\n            MultipartFile inputFile = request.getFileInput();\n            boolean readonly = true;\n\n            try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly);) {\n                ObjectMapper objectMapper = new ObjectMapper();\n                ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n                // Metadata using PDFBox\n                PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n\n                ObjectNode metadata = objectMapper.createObjectNode();\n\n                ObjectNode basicInfo = objectMapper.createObjectNode();\n\n                ObjectNode docInfoNode = objectMapper.createObjectNode();\n\n                ObjectNode compliancy = objectMapper.createObjectNode();\n\n                ObjectNode encryption = objectMapper.createObjectNode();\n\n                ObjectNode other = objectMapper.createObjectNode();\n\n                metadata.put(\"Title\", info.getTitle());\n\n                metadata.put(\"Author\", info.getAuthor());\n\n                metadata.put(\"Subject\", info.getSubject());\n\n                metadata.put(\"Keywords\", info.getKeywords());\n\n                metadata.put(\"Producer\", info.getProducer());\n\n                metadata.put(\"Creator\", info.getCreator());\n\n                metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n\n                metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n\n                jsonOutput.set(\"Metadata\", metadata);\n\n                // Total file size of the PDF\n                long fileSizeInBytes = inputFile.getSize();\n\n                basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n                // Number of words, paragraphs, and images in the entire document\n                String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n\n                String[] words = fullText.split(\"\\\\s+\");\n\n                int wordCount = words.length;\n\n                int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n\n                basicInfo.put(\"WordCount\", wordCount);\n\n                basicInfo.put(\"ParagraphCount\", paragraphCount);\n\n                // Number of characters in the entire document (including spaces and special characters)\n                int charCount = fullText.length();\n\n                basicInfo.put(\"CharacterCount\", charCount);\n\n                // Initialize the flags and types\n                boolean hasCompression = false;\n\n                String compressionType = \"None\";\n\n                basicInfo.put(\"Compression\", hasCompression);\n\n                if (hasCompression) {\n                    basicInfo.put(\"CompressionType\", compressionType);\n                }\n\n                String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n\n                basicInfo.put(\"Language\", language);\n\n                basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n                PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n\n                String pageMode = catalog.getPageMode().name();\n\n                // Document Information using PDFBox\n                docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n\n                docInfoNode.put(\"Trapped\", info.getTrapped());\n\n                docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n                ;\n\n                PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n\n                ObjectNode formFieldsNode = objectMapper.createObjectNode();\n\n                if (acroForm != null) {\n                    for (PDField field : acroForm.getFieldTree()) {\n                        formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                    }\n                }\n\n                jsonOutput.set(\"FormFields\", formFieldsNode);\n\n                // Generate structured summary data about PDF characteristics\n                ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n\n                if (summaryData != null && summaryData.size() > 0) {\n                    jsonOutput.set(\"SummaryData\", summaryData);\n                }\n\n                // embeed files TODO size\n                if (catalog.getNames() != null) {\n                    PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                    ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n\n                    if (efTree != null) {\n                        Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                        if (efMap != null) {\n                            for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                                ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                                embeddedFileNode.put(\"Name\", entry.getKey());\n\n                                PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n\n                                if (embeddedFile != null) {\n                                    embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                                }\n\n                                embeddedFilesArray.add(embeddedFileNode);\n                            }\n                        }\n                    }\n\n                    other.set(\"EmbeddedFiles\", embeddedFilesArray);\n                }\n\n                // attachments TODO size\n                ArrayNode attachmentsArray = objectMapper.createArrayNode();\n\n                for (PDPage page : pdfBoxDoc.getPages()) {\n                    for (PDAnnotation annotation : page.getAnnotations()) {\n                        if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                            ObjectNode attachmentNode = objectMapper.createObjectNode();\n                            attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n\n                            attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n\n                            attachmentsArray.add(attachmentNode);\n                        }\n                    }\n                }\n\n                other.set(\"Attachments\", attachmentsArray);\n\n                // Javascript\n                PDDocumentNameDictionary namesDict = catalog.getNames();\n\n                ArrayNode javascriptArray = objectMapper.createArrayNode();\n\n                if (namesDict != null) {\n                    PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                    if (javascriptDict != null) {\n                        try {\n                            Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                            for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                                ObjectNode jsNode = objectMapper.createObjectNode();\n                                jsNode.put(\"JS Name\", entry.getKey());\n\n                                PDActionJavaScript jsAction = entry.getValue();\n\n                                if (jsAction != null) {\n                                    String jsCodeStr = jsAction.getAction();\n                                    if (jsCodeStr != null) {\n                                        jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                    }\n                                }\n\n                                javascriptArray.add(jsNode);\n                            }\n                        } catch (IOException e) {\n                            log.error(\"exception\", e);\n                        }\n                    }\n                }\n\n                other.set(\"JavaScript\", javascriptArray);\n\n                // TODO size\n                PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n\n                ArrayNode layersArray = objectMapper.createArrayNode();\n\n                if (ocProperties != null) {\n                    for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                        ObjectNode layerNode = objectMapper.createObjectNode();\n                        layerNode.put(\"Name\", ocg.getName());\n\n                        layersArray.add(layerNode);\n                    }\n                }\n\n                other.set(\"Layers\", layersArray);\n                // TODO Security\n\n\n                PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n\n                ArrayNode structureTreeArray;\n\n                try {\n                    if (structureTreeRoot != null) {\n                        structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                        other.set(\"StructureTree\", structureTreeArray);\n                    }\n                } catch (Exception e) {\n                    // TODO Auto-generated catch block\n                    log.error(\"exception\", e);\n                }\n\n                boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n\n                boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n\n                boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n\n                boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n\n                boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n\n                boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n\n                // an official ISO standard.\n                boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n                // development in 2021.\n\n                compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n\n                compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n\n                compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n\n                compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n\n                compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n\n                compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n\n                compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n                PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n\n                ArrayNode bookmarksArray = objectMapper.createArrayNode();\n\n                if (root != null) {\n                    for (PDOutlineItem child : root.children()) {\n                        addOutlinesToArray(child, bookmarksArray);\n                    }\n                }\n\n                other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n                PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n\n                String xmpString = null;\n\n                if (pdMetadata != null) {\n                    try {\n                        try (COSInputStream is = pdMetadata.createInputStream()) {\n                            DomXmpParser domXmpParser = new DomXmpParser();\n                            XMPMetadata xmpMeta = domXmpParser.parse(is);\n\n                            ByteArrayOutputStream os = new ByteArrayOutputStream();\n\n                            new XmpSerializer().serialize(xmpMeta, os, true);\n\n                            xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                        }\n                    } catch (XmpParsingException e) {\n                        // XMP parsing failed, try to read raw metadata instead\n                        log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                        try (COSInputStream is = pdMetadata.createInputStream()) {\n                            byte[] metadataBytes = is.readAllBytes();\n                            xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n\n                other.put(\"XMPMetadata\", xmpString);\n\n                if (pdfBoxDoc.isEncrypted()) {\n                    encryption.put(\"IsEncrypted\", true);\n                    // Retrieve encryption details using getEncryption()\n                    PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n\n                    encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n\n                    encryption.put(\"KeyLength\", pdfEncryption.getLength());\n                    // Add other encryption-related properties as needed\n                } else {\n                    encryption.put(\"IsEncrypted\", false);\n                }\n\n                ObjectNode permissionsNode = objectMapper.createObjectNode();\n\n                setNodePermissions(pdfBoxDoc, permissionsNode);\n\n                ObjectNode pageInfoParent = objectMapper.createObjectNode();\n\n                for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                    ObjectNode pageInfo = objectMapper.createObjectNode();\n                    // Retrieve the page\n                    PDPage page = pdfBoxDoc.getPage(pageNum);\n\n                    // Page-level Information\n                    PDRectangle mediaBox = page.getMediaBox();\n\n                    float width = mediaBox.getWidth();\n\n                    float height = mediaBox.getHeight();\n\n                    ObjectNode sizeInfo = objectMapper.createObjectNode();\n\n                    getDimensionInfo(sizeInfo, width, height);\n\n                    sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n\n                    pageInfo.set(\"Size\", sizeInfo);\n\n                    pageInfo.put(\"Rotation\", page.getRotation());\n\n                    pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n                    // Boxes\n                    pageInfo.put(\"MediaBox\", mediaBox.toString());\n\n                    // Assuming the following boxes are defined for your document; if not, you may get\n                    // null values.\n                    PDRectangle cropBox = page.getCropBox();\n\n                    pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n\n                    PDRectangle bleedBox = page.getBleedBox();\n\n                    pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n\n                    PDRectangle trimBox = page.getTrimBox();\n\n                    pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n\n                    PDRectangle artBox = page.getArtBox();\n\n                    pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n\n                    // Content Extraction\n                    PDFTextStripper textStripper = new PDFTextStripper();\n\n                    textStripper.setStartPage(pageNum + 1);\n\n                    textStripper.setEndPage(pageNum + 1);\n\n                    String pageText = textStripper.getText(pdfBoxDoc);\n\n                    pageInfo.put(\"Text Characters Count\", pageText.length()); //\n                    // Annotations\n\n                    List<PDAnnotation> annotations = page.getAnnotations();\n\n                    int subtypeCount = 0;\n\n                    int contentsCount = 0;\n\n                    for (PDAnnotation annotation : annotations) {\n                        if (annotation.getSubtype() != null) {\n                            subtypeCount++; // Increase subtype count\n                        }\n                        if (annotation.getContents() != null) {\n                            contentsCount++; // Increase contents count\n                        }\n                    }\n\n                    ObjectNode annotationsObject = objectMapper.createObjectNode();\n\n                    annotationsObject.put(\"AnnotationsCount\", annotations.size());\n\n                    annotationsObject.put(\"SubtypeCount\", subtypeCount);\n\n                    annotationsObject.put(\"ContentsCount\", contentsCount);\n\n                    pageInfo.set(\"Annotations\", annotationsObject);\n\n                    // Images (simplified)\n                    // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                    // Here is a basic structure to recognize image XObjects on a page.\n                    ArrayNode imagesArray = objectMapper.createArrayNode();\n\n                    PDResources resources = page.getResources();\n\n                    for (COSName name : resources.getXObjectNames()) {\n                        PDXObject xObject = resources.getXObject(name);\n                        if (xObject instanceof PDImageXObject image) {\n                            ObjectNode imageNode = objectMapper.createObjectNode();\n                            imageNode.put(\"Width\", image.getWidth());\n\n                            imageNode.put(\"Height\", image.getHeight());\n\n                            if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                                imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                            }\n\n                            if (image.getColorSpace() != null) {\n                                imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                            }\n\n                            imagesArray.add(imageNode);\n                        }\n                    }\n\n                    pageInfo.set(\"Images\", imagesArray);\n\n                    // Links\n                    ArrayNode linksArray = objectMapper.createArrayNode();\n\n                    Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n                    for (PDAnnotation annotation : annotations) {\n                        if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                            String uri = uriAction.getURI();\n                            uniqueURIs.add(uri); // Add to set to ensure uniqueness\n                        }\n                    }\n\n                    // Add unique URIs to linksArray\n                    for (String uri : uniqueURIs) {\n                        ObjectNode linkNode = objectMapper.createObjectNode();\n                        linkNode.put(\"URI\", uri);\n\n                        linksArray.add(linkNode);\n                    }\n\n                    pageInfo.set(\"Links\", linksArray);\n\n                    // Fonts\n                    ArrayNode fontsArray = objectMapper.createArrayNode();\n\n                    Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n\n                    for (COSName fontName : resources.getFontNames()) {\n                        PDFont font = resources.getFont(fontName);\n                        ObjectNode fontNode = objectMapper.createObjectNode();\n\n                        fontNode.put(\"IsEmbedded\", font.isEmbedded());\n\n                        // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                        fontNode.put(\"Name\", font.getName());\n\n                        fontNode.put(\"Subtype\", font.getType());\n\n                        PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n\n                        if (fontDescriptor != null) {\n                            fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                            int flags = fontDescriptor.getFlags();\n\n                            fontNode.put(\"IsItalic\", (flags & 1) != 0);\n\n                            fontNode.put(\"IsBold\", (flags & 64) != 0);\n\n                            fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n\n                            fontNode.put(\"IsSerif\", (flags & 4) != 0);\n\n                            fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n\n                            fontNode.put(\"IsScript\", (flags & 16) != 0);\n\n                            fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n\n                            fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n\n                            // Font stretch and BBox are not directly available in PDFBox's API, so\n                            // these are omitted for simplicity\n                            fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                        }\n\n                        // Create a unique key for this font node based on its attributes\n                        String uniqueKey = fontNode.toString();\n\n                        // Increment count if this font exists, or initialize it if new\n                        if (uniqueFontsMap.containsKey(uniqueKey)) {\n                            ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                            int count = existingFontNode.get(\"Count\").asInt() + 1;\n\n                            existingFontNode.put(\"Count\", count);\n                        } else {\n                            fontNode.put(\"Count\", 1);\n                            uniqueFontsMap.put(uniqueKey, fontNode);\n                        }\n                    }\n\n                    // Add unique font entries to fontsArray\n                    for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                        fontsArray.add(uniqueFontNode);\n                    }\n\n                    pageInfo.set(\"Fonts\", fontsArray);\n\n                    // Access resources dictionary\n                    ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n\n                    Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n\n                    for (COSName name : colorSpaceNames) {\n                        PDColorSpace colorSpace = resources.getColorSpace(name);\n                        if (colorSpace instanceof PDICCBased iccBased) {\n                            PDStream iccData = iccBased.getPDStream();\n                            byte[] iccBytes = iccData.toByteArray();\n\n                            // TODO: Further decode and analyze the ICC data if needed\n                            ObjectNode iccProfileNode = objectMapper.createObjectNode();\n\n                            iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n\n                            colorSpacesArray.add(iccProfileNode);\n                        }\n                    }\n\n                    pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n                    // Other XObjects\n                    Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n\n                    for (COSName name : resources.getXObjectNames()) {\n                        PDXObject xObject = resources.getXObject(name);\n                        String xObjectType;\n\n                        if (!(xObject instanceof PDImageXObject)) {\n                            if (xObject instanceof PDFormXObject) {\n                                xObjectType = \"Form\";\n                            } else {\n                                xObjectType = \"Other\";\n                            }\n                            // Increment the count for this type in the map\n                        } else {\n                            xObjectType = \"Image\";\n                        } \n\n                        xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                    }\n\n                    // Add the count map to pageInfo (or wherever you want to store it)\n                    ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n\n                    for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                        xObjectCountNode.put(entry.getKey(), entry.getValue());\n                    }\n\n                    pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n                    ArrayNode multimediaArray = objectMapper.createArrayNode();\n\n                    for (PDAnnotation annotation : annotations) {\n                        if (\"RichMedia\".equals(annotation.getSubtype())) {\n                            ObjectNode multimediaNode = objectMapper.createObjectNode();\n                            // Extract details from the annotation as needed\n                            multimediaArray.add(multimediaNode);\n                        }\n                    }\n\n                    pageInfo.set(\"Multimedia\", multimediaArray);\n\n                    pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n                }\n\n                jsonOutput.set(\"BasicInfo\", basicInfo);\n\n                jsonOutput.set(\"DocumentInfo\", docInfoNode);\n\n                jsonOutput.set(\"Compliancy\", compliancy);\n\n                jsonOutput.set(\"Encryption\", encryption);\n\n                jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n\n                jsonOutput.set(\"Other\", other);\n\n                jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n                // Save JSON to file\n                String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n\n                return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n            } catch (Exception e) {\n                log.error(\"exception\", e);\n            }\n\n            return null;\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "173", "src_id": "M24", "code": "        private boolean verifyCertificateLicense(String licenseFile, \n        LicenseContext context) {\n\n            try {\n                String encodedPayload = licenseFile;\n                // Remove the header\n                encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n\n                // Remove the footer\n                encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n\n                // Remove all newlines\n                encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n\n                byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n\n                String payload = new String(payloadBytes);\n\n                log.info(\"Decoded certificate payload: {}\", payload);\n\n                String encryptedData = \"\";\n\n                String encodedSignature = \"\";\n\n                String algorithm = \"\";\n\n                try {\n                    JSONObject attrs = new JSONObject(payload);\n                    encryptedData = (String) attrs.get(\"enc\");\n\n                    encodedSignature = (String) attrs.get(\"sig\");\n\n                    algorithm = (String) attrs.get(\"alg\");\n                } catch (JSONException e) {\n                    log.error(\"Failed to parse license file: {}\", e.getMessage());\n                    return false;\n                }\n\n                // Verify license file algorithm\n                if (!\"base64+ed25519\".equals(algorithm)) {\n                    log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                    return false;\n                }\n\n                // Verify signature\n                boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n\n                if (!isSignatureValid) {\n                    log.error(\"License file signature is invalid\");\n                    return false;\n                }\n\n                log.info(\"License file signature is valid\");\n\n                // Decode the base64 data\n                String decodedData;\n\n                try {\n                    decodedData = new String(Base64.getDecoder().decode(encryptedData));\n                } catch (IllegalArgumentException e) {\n                    log.error(\"Failed to decode license data: {}\", e.getMessage());\n                    return false;\n                }\n\n                // Process the certificate data\n                boolean isValid = processCertificateData(decodedData, context);\n\n                return isValid;\n            } catch (Exception e) {\n                log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n                return false;\n            }\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "174", "src_id": "M403", "code": "        private static void sanitizeHtmlFilesInZip(Path zipFilePath, \n        boolean disableSanitize, \n        TempFileManager tempFileManager)\n        throws IOException {\n\n            try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n\n                try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                    ZipEntry entry = zipIn.getNextEntry();\n                    while (entry != null) {\n                        Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                        if (!entry.isDirectory()) {\n                            Files.createDirectories(filePath.getParent());\n                            if (entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                                String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                                String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n\n                                Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                            } else {\n                                Files.copy(zipIn, filePath);\n                            }\n                        }\n\n                        zipIn.closeEntry();\n\n                        entry = zipIn.getNextEntry();\n                    }\n                }\n                // Repack the sanitized files\n                zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n            } // tempUnzippedDir auto-cleaned\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "175", "src_id": "M317", "code": "        public static void addImageToDocument(PDDocument doc, \n        PDImageXObject image, \n        String fitOption, \n        boolean autoRotate)\n        throws IOException {\n            boolean imageIsLandscape = image.getWidth() > image.getHeight();\n            PDRectangle pageSize = PDRectangle.A4;\n\n            if (autoRotate && imageIsLandscape) {\n                pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n            }\n\n            if (\"fitDocumentToImage\".equals(fitOption)) {\n                pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n            }\n\n            PDPage page = new PDPage(pageSize);\n\n            doc.addPage(page);\n\n            float pageWidth = page.getMediaBox().getWidth();\n\n            float pageHeight = page.getMediaBox().getHeight();\n\n            try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n\n                if (!(\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption))) {\n                    if (\"maintainAspectRatio\".equals(fitOption)) {\n                        float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                        float pageAspectRatio = pageWidth / pageHeight;\n\n                        float scaleFactor = 1.0f;\n\n                        if (imageAspectRatio > pageAspectRatio) {\n                            scaleFactor = pageWidth / image.getWidth();\n                        } else {\n                            scaleFactor = pageHeight / image.getHeight();\n                        }\n\n                        float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n\n                        float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n\n                        contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n                    }\n                } else {\n                    contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n                } \n            } catch (IOException e) {\n                log.error(\"Error adding image to PDF\", e);\n                throw e;\n            }\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "176", "src_id": "M307", "code": "        public static String generateMachineFingerprint() {\n\n            try {\n                // Get the MAC address\n                StringBuilder sb = new StringBuilder();\n                InetAddress ip = InetAddress.getLocalHost();\n\n                NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n                if (network == null) {\n                    Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                    while (networks.hasMoreElements()) {\n                        NetworkInterface net = networks.nextElement();\n                        byte[] mac = net.getHardwareAddress();\n\n                        if (mac != null) {\n                            for (int i = 0; i < mac.length; i++) {\n                                sb.append(String.format(\"%02X\", mac[i]));\n                            }\n                            break; // Use the first network interface with a MAC address\n                        }\n                    }\n                } else {\n                    byte[] mac = network.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n                    }\n                }\n\n                // Hash the MAC address for privacy and consistency\n                MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n                byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n                StringBuilder fingerprint = new StringBuilder();\n\n                for (byte b : hash) {\n                    fingerprint.append(String.format(\"%02x\", b));\n                }\n\n                return fingerprint.toString();\n            } catch (Exception e) {\n                return \"GenericID\";\n            }\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "177", "src_id": "M135", "code": "        private void setCommonMetadata(PDDocument pdf, \n        PdfMetadata pdfMetadata) {\n            String title = pdfMetadata.getTitle();\n            pdf.getDocumentInformation().setTitle(title);\n\n            pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n\n            pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n\n            pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n\n            pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n            String author = pdfMetadata.getAuthor();\n\n            if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n                author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n                if (userService != null) {\n                    author = author.replace(\"username\", userService.getCurrentUsername());\n                }\n            }\n\n            pdf.getDocumentInformation().setAuthor(author);\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "178", "src_id": "M128", "code": "        @Bean(name = \"machineType\")\n        public String determineMachineType() {\n            try {\n                boolean isDocker = runningInDocker();\n                boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n\n                boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n                if (isKubernetes) {\n                    return \"Kubernetes\";\n                } else {\n                    if (!isDocker) {\n                        if (isBrowserOpen) {\n                            String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                            if (!(os.contains(\"win\"))) {\n                                if (os.contains(\"mac\")) {\n                                    return \"Client-mac\";\n                                } else {\n                                    return \"Client-unix\";\n                                }\n                            } else {\n                                return \"Client-windows\";\n                            } \n                        } else {\n                            return \"Server-jar\";\n                        }\n                    } else {\n                        return \"Docker\";\n                    } \n                }\n            } catch (Exception e) {\n                return \"Unknown\";\n            }\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "179", "src_id": "M101", "code": "        private void processRequest(int limitPerDay,\n        String identifier,\n        Map<String, Bucket> buckets,\n        HttpServletRequest request,\n        HttpServletResponse response,\n        FilterChain filterChain)\n        throws IOException, ServletException {\n            Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n            ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n\n            if (!(probe.isConsumed())) {\n                long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n                response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n\n                response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n\n                response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n            } else {\n                response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n                filterChain.doFilter(request, response);\n            } \n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "282", "src_id": "M66", "code": "  void drain() {\n    if (getAndIncrement() != 0) {\n      return;\n    }\n    int missed = 1;\n    Observer<? super R> downstream = this.downstream;\n    AtomicThrowable errors = this.errors;\n    AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n    for (;;) {\n      for (;;) {\n        if (cancelled) {\n          return;\n        }\n        if (errors.get() != null && !delayErrors) {\n          errors.tryTerminateConsumer(downstream);\n          return;\n        }\n        boolean d = done;\n        SwitchMapMaybeObserver<R> current = inner.get();\n        boolean empty = current == null;\n        if (d && empty) {\n          errors.tryTerminateConsumer(downstream);\n          return;\n        }\n        if (empty) {\n          break;\n        }\n        if (current.item == null) {\n        break;\n          }\n        inner.compareAndSet(current, null);\n        downstream.onNext(current.item);\n      }\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "283", "src_id": "M1333", "code": "  @Override\n  public void onNext(T t) {\n    if (done) {\n      return;\n    }\n    boolean b;\n    try {\n      b = predicate.test(t);\n    } catch (Throwable e) {\n      Exceptions.throwIfFatal(e);\n      upstream.cancel();\n      upstream = SubscriptionHelper.CANCELLED;\n      onError(e);\n      return;\n    }\n    if (!b) {\n      done = true;\n      upstream.cancel();\n      upstream = SubscriptionHelper.CANCELLED;\n      downstream.onSuccess(false);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "284", "src_id": "M522", "code": "  void drainLoop() {\n    Observer<? super T> actual = this.downstream;\n    int missed = 1;\n    for (;;) {\n      for (;;) {\n        if (disposed) {\n          singleItem = null;\n          queue = null;\n          return;\n        }\n        if (errors.get() != null) {\n          singleItem = null;\n          queue = null;\n          errors.tryTerminateConsumer(actual);\n          return;\n        }\n        int os = otherState;\n        if (os == OTHER_STATE_HAS_VALUE) {\n          T v = singleItem;\n          singleItem = null;\n          otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n          os = OTHER_STATE_CONSUMED_OR_EMPTY;\n          actual.onNext(v);\n        }\n        boolean d = mainDone;\n        SimplePlainQueue<T> q = queue;\n        T v = q != null ? q.poll() : null;\n        boolean empty = v == null;\n        if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n          queue = null;\n          actual.onComplete();\n          return;\n        }\n        if (empty) {\n          break;\n        }\n        actual.onNext(v);\n      }\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "285", "src_id": "M1163", "code": "  @Override void drain() {\n    if (getAndIncrement() != 0) {\n      return;\n    }\n    int missed = 1;\n    final SimplePlainQueue<Object> queue = this.queue;\n    final Subscriber<? super Flowable<T>> downstream = this.downstream;\n    UnicastProcessor<T> window = this.window;\n    for (;;) {\n      if (upstreamCancelled) {\n        queue.clear();\n        window = null;\n        this.window = null;\n      } else {\n        boolean isDone = done;\n        Object o = queue.poll();\n        boolean isEmpty = o == null;\n        if (isDone && isEmpty) {\n          Throwable ex = error;\n          if (ex != null) {\n            if (window != null) {\n              window.onError(ex);\n            }\n\n            downstream.onError(ex);\n          } else {\n            if (window != null) {\n              window.onComplete();\n            }\n\n            downstream.onComplete();\n          }\n          cleanupResources();\n          upstreamCancelled = true;\n          continue;\n        } else {\n          if (!isEmpty) {\n            if (o instanceof WindowBoundaryRunnable) {\n              WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n              if (boundary.index == emitted) {\n                this.count = 0;\n                window = createNewWindow(window);\n              }\n\n              if (!restartTimerOnMaxSize) {\n              this.count = 0;\n                window = createNewWindow(window);\n                }\n              } else {\n              if (window != null) {\n                @SuppressWarnings(\"unchecked\") T item = (T) o;\n\n                window.onNext(item);\n                long count = this.count + 1;\n                if (count != maxSize) {\n                  this.count = count;\n                } else {\n                  this.count = 0;\n                  window = createNewWindow(window);\n                } \n              }\n            }\n            continue;\n          }\n        }\n      }\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "286", "src_id": "M478", "code": "  void drain() {\n    if (getAndIncrement() != 0) {\n      return;\n    }\n    int missed = 1;\n    EqualObserver<T>[] as = observers;\n    final EqualObserver<T> observer1 = as[0];\n    final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n    final EqualObserver<T> observer2 = as[1];\n    final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n    for (;;) {\n      for (;;) {\n        if (cancelled) {\n          q1.clear();\n          q2.clear();\n          return;\n        }\n        boolean d1 = observer1.done;\n        if (d1) {\n          Throwable e = observer1.error;\n          if (e != null) {\n            cancel(q1, q2);\n            downstream.onError(e);\n            return;\n          }\n        }\n        boolean d2 = observer2.done;\n        if (d2) {\n          Throwable e = observer2.error;\n          if (e != null) {\n            cancel(q1, q2);\n            downstream.onError(e);\n            return;\n          }\n        }\n        if (v1 == null) {\n          v1 = q1.poll();\n        }\n        boolean e1 = v1 == null;\n        if (v2 == null) {\n          v2 = q2.poll();\n        }\n        boolean e2 = v2 == null;\n        if (d1 && d2 && e1 && e2) {\n          downstream.onSuccess(true);\n          return;\n        }\n        if ((d1 && d2) && (e1 != e2)) {\n          cancel(q1, q2);\n          downstream.onSuccess(false);\n          return;\n        }\n        if (!e1 && !e2) {\n          boolean c;\n          try {\n            c = comparer.test(v1, v2);\n          } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            cancel(q1, q2);\n            downstream.onError(ex);\n            return;\n          }\n          if (!c) {\n            cancel(q1, q2);\n            downstream.onSuccess(false);\n            return;\n          }\n          v1 = null;\n          v2 = null;\n        }\n        if (e1) {\n          break;\n        }\n        if (e2) {\n        break;\n          }\n        }\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "287", "src_id": "M885", "code": "  void drainLoop() {\n    int missed = 1;\n    JoinInnerSubscriber<T>[] s = this.subscribers;\n    int n = s.length;\n    Subscriber<? super T> a = this.downstream;\n    for (;;) {\n      long r = requested.get();\n      long e = 0;\n      middle:\n      while (e != r) {\n        if (cancelled) {\n          cleanup();\n          return;\n        }\n        Throwable ex = errors.get();\n        if (ex != null) {\n          cleanup();\n          a.onError(ex);\n          return;\n        }\n        boolean d = done.get() == 0;\n        boolean empty = true;\n        for (int i = 0; i < s.length; i++) {\n          JoinInnerSubscriber<T> inner = s[i];\n          SimplePlainQueue<T> q = inner.queue;\n          if (q != null) {\n            T v = q.poll();\n            if (v != null) {\n              empty = false;\n              a.onNext(v);\n              inner.requestOne();\n              if (++e == r) {\n                break middle;\n              }\n            }\n          }\n        }\n        if (d && empty) {\n          a.onComplete();\n          return;\n        }\n        if (empty) {\n          break;\n        }\n      }\n      if (e == r) {\n        if (cancelled) {\n          cleanup();\n          return;\n        }\n        Throwable ex = errors.get();\n        if (ex != null) {\n          cleanup();\n          a.onError(ex);\n          return;\n        }\n        boolean d = done.get() == 0;\n        boolean empty = true;\n        for (int i = 0; i < n; i++) {\n          JoinInnerSubscriber<T> inner = s[i];\n          SimpleQueue<T> q = inner.queue;\n          if (q != null && !q.isEmpty()) {\n            empty = false;\n            break;\n          }\n        }\n        if (d && empty) {\n          a.onComplete();\n          return;\n        }\n      }\n      if (e != 0) {\n        BackpressureHelper.produced(requested, e);\n      }\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "288", "src_id": "M1399", "code": "  @Override\n  public void drain() {\n    if (getAndIncrement() != 0) {\n      return;\n    }\n    int missed = 1;\n    InnerQueuedSubscriber<R> inner = current;\n    Subscriber<? super R> a = downstream;\n    ErrorMode em = errorMode;\n    for (;;) {\n      long r = requested.get();\n      long e = 0L;\n      if (inner == null) {\n        if (em != ErrorMode.END) {\n          Throwable ex = errors.get();\n          if (ex != null) {\n            cancelAll();\n            errors.tryTerminateConsumer(downstream);\n            return;\n          }\n        }\n        boolean outerDone = done;\n        inner = subscribers.poll();\n        if (outerDone && inner == null) {\n          errors.tryTerminateConsumer(downstream);\n          return;\n        }\n        if (inner != null) {\n          current = inner;\n        }\n      }\n      boolean continueNextSource = false;\n      if (inner != null) {\n        SimpleQueue<R> q = inner.queue();\n        if (q != null) {\n          while (e != r) {\n            if (cancelled) {\n              cancelAll();\n              return;\n            }\n            if (em == ErrorMode.IMMEDIATE) {\n              Throwable ex = errors.get();\n              if (ex != null) {\n                current = null;\n                inner.cancel();\n                cancelAll();\n                errors.tryTerminateConsumer(downstream);\n                return;\n              }\n            }\n            boolean d = inner.isDone();\n            R v;\n            try {\n              v = q.poll();\n            } catch (Throwable ex) {\n              Exceptions.throwIfFatal(ex);\n              current = null;\n              inner.cancel();\n              cancelAll();\n              a.onError(ex);\n              return;\n            }\n            boolean empty = v == null;\n            if (d && empty) {\n              inner = null;\n              current = null;\n              upstream.request(1);\n              continueNextSource = true;\n              break;\n            }\n            if (empty) {\n              break;\n            }\n            a.onNext(v);\n            ++e; \n            inner.request(1L);\n          }\n          if (e == r) {\n            if (cancelled) {\n              cancelAll();\n              return;\n            }\n            if (em == ErrorMode.IMMEDIATE) {\n              Throwable ex = errors.get();\n              if (ex != null) {\n                current = null;\n                inner.cancel();\n                cancelAll();\n                errors.tryTerminateConsumer(downstream);\n                return;\n              }\n            }\n            boolean d = inner.isDone();\n            boolean empty = q.isEmpty();\n            if (d && empty) {\n              inner = null;\n              current = null;\n              upstream.request(1);\n              continueNextSource = true;\n            }\n          }\n        }\n      }\n      if (e != 0L && r != Long.MAX_VALUE) {\n        requested.addAndGet(-e);\n      }\n      if (!continueNextSource) { \n        missed = addAndGet(-missed);\n        if (missed == 0) {\n          break;\n        }\n      } \n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "289", "src_id": "M469", "code": "  @SuppressWarnings(\"unchecked\") void remove(CacheDisposable<T> consumer) {\n    for (;;) {\n      CacheDisposable<T>[] current = observers.get();\n      int n = current.length;\n      if (n == 0) {\n        return;\n      }\n      int j = -1;\n      for (int i = 0; i < n; i++) {\n        if (current[i] == consumer) {\n          j = i;\n          break;\n        }\n      }\n      if (j < 0) {\n        return;\n      }\n      CacheDisposable<T>[] next;\n      if (n == 1) {\n        next = EMPTY;\n      } else {\n        next = new CacheDisposable[n - 1];\n\n        System.arraycopy(current, 0, next, 0, j);\n        System.arraycopy(current, j + 1, next, j, n - j - 1);\n      }\n      if (observers.compareAndSet(current, next)) {\n        return;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "290", "src_id": "M362", "code": "  void drainFused() {\n    int missed = 1;\n    for (;;) {\n      if (disposed) {\n        return;\n      }\n      boolean d = done;\n      Throwable ex = error;\n      if (!delayError && d && ex != null) {\n        disposed = true;\n        downstream.onError(error);\n        worker.dispose();\n        return;\n      }\n      downstream.onNext(null);\n      if (d) {\n        disposed = true;\n        ex = error;\n        if (ex != null) {\n          downstream.onError(ex);\n        } else {\n          downstream.onComplete();\n        }\n        worker.dispose();\n        return;\n      }\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "291", "src_id": "M2247", "code": "  @SuppressWarnings(\"unchecked\") void remove(PublishSubscription<T> ps) {\n    for (;;) {\n      PublishSubscription<T>[] a = subscribers.get();\n      if (a == TERMINATED) {\n        return;\n      }\n      if (a == EMPTY) {\n      return;\n        }\n      int n = a.length;\n      int j = -1;\n      for (int i = 0; i < n; i++) {\n        if (a[i] == ps) {\n          j = i;\n          break;\n        }\n      }\n      if (j < 0) {\n        return;\n      }\n      PublishSubscription<T>[] b;\n\n      if (n == 1) {\n        b = EMPTY;\n      } else {\n        b = new PublishSubscription[n - 1];\n\n        System.arraycopy(a, 0, b, 0, j);\n        System.arraycopy(a, j + 1, b, j, n - j - 1);\n      }\n      if (subscribers.compareAndSet(a, b)) {\n        return;\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "312", "src_id": "M475", "code": "  @Override\n  public void draw(CommandProcess process, JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n      String group = entry.getKey();\n      List<JvmItemVO> items = entry.getValue();\n      table.row(true, label(group).style(Decoration.bold.bold()));\n      for (JvmItemVO item : items) {\n        String valueStr = item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\") ? renderMemoryUsage((Map<String, Object>) item.getValue()) : renderItemValue(item.getValue()); \n        if (item.getDesc() != null) {\n          table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n        } else {\n          table.row(item.getName(), valueStr);\n        }\n      }\n      table.row(\"\", \"\");\n    }\n    process.write(RenderUtil.render(table, process.width()));\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "313", "src_id": "M535", "code": "  public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n    final StringBuilder infoSB = new StringBuilder();\n    List<String> classDumpFiles = affectVO.getClassDumpFiles();\n    if (classDumpFiles != null) {\n      for (String classDumpFile : classDumpFiles) {\n        infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n      }\n    }\n    List<String> methods = affectVO.getMethods();\n    if (methods != null) {\n      for (String method : methods) {\n        infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n      }\n    }\n    infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\", affectVO.getClassCount(), affectVO.getMethodCount(), affectVO.getCost(), affectVO.getListenerId()));\n    if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n      infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n    }\n    if (affectVO.getThrowable() != null) {\n      infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n    }\n    infoSB.append(\"\\n\");\n    return infoSB.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "314", "src_id": "M753", "code": "  public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n    List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n    // Sample CPU\n    if (lastCpuTimes.isEmpty()) {\n      lastSampleTimeNanos = System.nanoTime();\n      for (ThreadVO thread : threads) {\n        if (thread.getId() > 0) {\n          long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n          lastCpuTimes.put(thread, cpu);\n          thread.setTime(cpu / 1000000);\n        }\n      }\n      // add internal threads\n      Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n      if (internalThreadCpuTimes != null) {\n        for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n          String key = entry.getKey();\n\n          ThreadVO thread = createThreadVO(key);\n          thread.setTime(entry.getValue() / 1000000);\n          threads.add(thread);\n          lastCpuTimes.put(thread, entry.getValue());\n        }\n      }\n      //sort by time\n      Collections.sort(threads, new Comparator<ThreadVO>() {\n        @Override\n        public int compare(ThreadVO o1, ThreadVO o2) {\n          long l1 = o1.getTime();\n          long l2 = o2.getTime();\n          if (l1 < l2) {\n            return 1;\n          } else {\n            if (l1 > l2) {\n              return -1;\n            } else {\n              return 0;\n            }\n          }\n        }\n      });\n      return threads;\n    }\n    // Resample\n    long newSampleTimeNanos = System.nanoTime();\n    Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : threads) {\n      if (thread.getId() > 0) {\n        long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n        newCpuTimes.put(thread, cpu);\n      }\n    }\n    // internal threads\n    Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n    if (newInternalThreadCpuTimes != null) {\n      for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n        ThreadVO threadVO = createThreadVO(entry.getKey());\n        threads.add(threadVO);\n        newCpuTimes.put(threadVO, entry.getValue());\n      }\n    }\n    // Compute delta time\n    final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : newCpuTimes.keySet()) {\n      Long t = lastCpuTimes.get(thread);\n      if (t == null) {\n        t = 0L;\n      }\n      long time1 = t;\n      long time2 = newCpuTimes.get(thread);\n      if (time1 == -1) {\n        time1 = time2;\n      } else {\n        if (time2 == -1) {\n          time2 = time1;\n        }\n      }\n      long delta = time2 - time1;\n      deltas.put(thread, delta);\n    }\n    long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n    // Compute cpu usage\n    final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n    for (ThreadVO thread : threads) {\n      double cpu = sampleIntervalNanos == 0 ? 0 : (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0);\n      cpuUsages.put(thread, cpu);\n    }\n    // Sort by CPU time : should be a rendering hint...\n    Collections.sort(threads, new Comparator<ThreadVO>() {\n      @Override\n      public int compare(ThreadVO o1, ThreadVO o2) {\n        long l1 = deltas.get(o1);\n        long l2 = deltas.get(o2);\n        if (l1 < l2) {\n          return 1;\n        } else {\n          if (l1 > l2) {\n            return -1;\n          } else {\n            return 0;\n          }\n        }\n      }\n    });\n    for (ThreadVO thread : threads) {\n      //nanos to mills\n      long timeMills = newCpuTimes.get(thread) / 1000000;\n      long deltaTime = deltas.get(thread) / 1000000;\n      double cpu = cpuUsages.get(thread);\n      thread.setCpu(cpu);\n      thread.setTime(timeMills);\n      thread.setDeltaTime(deltaTime);\n    }\n    lastCpuTimes = newCpuTimes;\n    lastSampleTimeNanos = newSampleTimeNanos;\n    return threads;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "315", "src_id": "M1131", "code": "  private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<String, Object>();\n\n    body.put(\"command\", commandLine);\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId()).setBody(body);\n    if (!session.tryLock()) {\n      response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n      return response;\n    }\n    int lock = session.getLock();\n    try {\n      Job foregroundJob = session.getForegroundJob();\n      if (foregroundJob != null) {\n        response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n        logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n        return response;\n      }\n      //create job\n      Job job = this.createJob(commandLine, session, session.getResultDistributor());\n      body.put(\"jobId\", job.id());\n      body.put(\"jobStatus\", job.status());\n      response.setState(ApiState.SCHEDULED);\n      //add command before exec job\n      CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n      commandRequestModel.setJobId(job.id());\n      SharingResultDistributor resultDistributor = session.getResultDistributor();\n\n      if (resultDistributor != null) {\n        resultDistributor.appendResult(commandRequestModel);\n      }\n      session.setForegroundJob(job);\n      updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n      //run job\n      job.run();\n      return response;\n    } catch (Throwable e) {\n      logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n      response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n      CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n      session.getResultDistributor().appendResult(commandRequestModel);\n\n      return response;\n    } finally {\n      if (session.getLock() == lock) {\n        session.unLock();\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "316", "src_id": "M542", "code": "  private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n      Map<String, Object> info = entry.getValue();\n      TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n      TableElement appendersTable = new TableElement().rightCellPadding(1);\n      Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n      table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name))).row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName())).row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n      if (info.get(LoggerHelper.effectiveLevel) != null) {\n        table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n      }\n      if (info.get(LoggerHelper.config) != null) {\n        table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n      }\n      table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n      @SuppressWarnings(\"unchecked\") List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n      if (appenders != null && !appenders.isEmpty()) {\n        for (Map<String, Object> appenderInfo : appenders) {\n          Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n          appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n          appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n          appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n          appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n          if (appenderInfo.get(LoggerHelper.file) != null) {\n            appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n          }\n          if (appenderInfo.get(LoggerHelper.target) != null) {\n            appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n          }\n          if (appenderInfo.get(LoggerHelper.blocking) != null) {\n            appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n          }\n          if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n            appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n          }\n        }\n        table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n      }\n      sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "317", "src_id": "M15", "code": "  public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n    // start java telnet client\n    // find arthas-client.jar\n    URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n    Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n    Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n    //redirect System.out/System.err\n    PrintStream originSysOut = System.out;\n    PrintStream originSysErr = System.err;\n    PrintStream newOut = new PrintStream(out);\n    PrintStream newErr = new PrintStream(out);\n    // call TelnetConsole.process()\n    // fix https://github.com/alibaba/arthas/issues/833\n    ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n    try {\n      System.setOut(newOut);\n      System.setErr(newErr);\n      Thread.currentThread().setContextClassLoader(classLoader);\n      return (Integer) processMethod.invoke(null, new Object[]{telnetArgs.toArray(new String[0])});\n    } catch (Throwable e) {\n      //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n      e = e.getCause();\n      if (e instanceof IOException || e instanceof InterruptedException) {\n        // ignore connection error and interrupted error\n        return STATUS_ERROR;\n      } else {\n        // process error\n        AnsiLog.error(\"process error: {}\", e.toString());\n\n        AnsiLog.error(e);\n        return STATUS_EXEC_ERROR;\n      }\n    } finally {\n      Thread.currentThread().setContextClassLoader(tccl);\n      //reset System.out/System.err\n      System.setOut(originSysOut);\n      System.setErr(originSysErr);\n      //flush output\n      newOut.flush();\n      newErr.flush();\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "318", "src_id": "M1469", "code": "  public static FieldVO[] getFields(Class clazz, Integer expand) {\n    Field[] fields = clazz.getDeclaredFields();\n    if (fields.length == 0) {\n      return new FieldVO[0];\n    }\n    List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n    for (Field field : fields) {\n      FieldVO fieldVO = new FieldVO();\n\n      fieldVO.setName(field.getName());\n      fieldVO.setType(StringUtils.classname(field.getType()));\n      fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n\n      fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n      if (!(Modifier.isStatic(field.getModifiers()))) {\n        fieldVO.setStatic(false);\n      } else {\n        fieldVO.setStatic(true);\n        fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n      } \n      list.add(fieldVO);\n    }\n    return list.toArray(new FieldVO[0]);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "34", "src_id": "M342", "code": "        private static String convertEmlToHtmlBasic(byte[] emlBytes, \n        EmlToPdfRequest request) {\n            if (emlBytes == null || emlBytes.length == 0) {\n                throw new IllegalArgumentException(\"EML file is empty or null\");\n            }\n            String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n            // Basic email parsing\n            String subject = extractBasicHeader(emlContent, \"Subject:\");\n\n            String from = extractBasicHeader(emlContent, \"From:\");\n\n            String to = extractBasicHeader(emlContent, \"To:\");\n\n            String cc = extractBasicHeader(emlContent, \"Cc:\");\n\n            String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n\n            String date = extractBasicHeader(emlContent, \"Date:\");\n\n            // Try to extract HTML content\n            String htmlBody = extractHtmlBody(emlContent);\n\n            if (htmlBody == null) {\n                String textBody = extractTextBody(emlContent);\n                htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n            }\n\n            // Generate HTML with custom styling based on request\n            StringBuilder html = new StringBuilder();\n\n            html.append(\"<!DOCTYPE html>\\n\");\n\n            html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n\n            html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n\n            html.append(\"<style>\\n\");\n\n            appendEnhancedStyles(html);\n\n            html.append(\"</style>\\n\");\n\n            html.append(\"</head><body>\\n\");\n\n            html.append(\"<div class=\\\"email-container\\\">\\n\");\n\n            html.append(\"<div class=\\\"email-header\\\">\\n\");\n\n            html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n\n            html.append(\"<div class=\\\"email-meta\\\">\\n\");\n\n            html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n\n            html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n            // Include CC and BCC if present and requested\n            if (request != null && request.isIncludeAllRecipients()) {\n                if (!cc.trim().isEmpty()) {\n                    html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n                }\n                if (!bcc.trim().isEmpty()) {\n                    html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n                }\n            }\n\n            if (!date.trim().isEmpty()) {\n                html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n            }\n\n            html.append(\"</div></div>\\n\");\n\n            html.append(\"<div class=\\\"email-body\\\">\\n\");\n\n            html.append(processEmailHtmlBody(htmlBody));\n\n            html.append(\"</div>\\n\");\n\n            // Add attachment information - always check for and display attachments\n            String attachmentInfo = extractAttachmentInfo(emlContent);\n\n            if (!attachmentInfo.isEmpty()) {\n                html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n                html.append(\"<h3>Attachments</h3>\\n\");\n\n                html.append(attachmentInfo);\n\n                // Add a status message about attachment inclusion\n                if (request != null && request.isIncludeAttachments()) {\n                    html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                    html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n\n                    html.append(\"</div>\\n\");\n                } else {\n                    html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                    html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n\n                    html.append(\"</div>\\n\");\n                }\n\n                html.append(\"</div>\\n\");\n            }\n\n            // Show advanced features status if requested\n            assert request != null;\n\n            if (request.getFileInput().isEmpty()) {\n                html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n                html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n\n            html.append(\"</body></html>\");\n\n            return html.toString();\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "35", "src_id": "M371", "code": "        private static boolean isValidJakartaMailMultipart(Object multipart) {\n            if (multipart == null) {\n                return false;\n            }\n            try {\n                // Check if the object implements jakarta.mail.Multipart interface\n                Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n                if (!multipartInterface.isInstance(multipart)) {\n                    return false;\n                }\n\n                // Additional check for MimeMultipart\n                try {\n                    Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                    if (mimeMultipartClass.isInstance(multipart)) {\n                        log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                        return true;\n                    }\n                } catch (ClassNotFoundException e) {\n                    log.debug(\"MimeMultipart not available, using base Multipart interface\");\n                }\n\n                return true;\n            } catch (ClassNotFoundException e) {\n                log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n                return false;\n            }\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "36", "src_id": "M348", "code": "        private static String extractBasicHeader(String emlContent, \n        String headerName) {\n            try {\n                String[] lines = emlContent.split(\"\\r?\\n\");\n                for (int i = 0; i < lines.length; i++) {\n                    String line = lines[i];\n                    if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                        StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                        // Handle multi-line headers\n                        for (int j = i + 1; j < lines.length; j++) {\n                            if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                                value.append(\" \").append(lines[j].trim());\n                            } else {\n                                break;\n                            }\n                        }\n\n                        // Apply MIME header decoding\n                        return safeMimeDecode(value.toString());\n                    }\n\n                    if (line.trim().isEmpty()) {\n                        break;\n                    }\n                }\n            } catch (RuntimeException e) {\n                log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n            }\n            return \"\";\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "37", "src_id": "M364", "code": "        private static void addAttachmentAnnotationsToDocument(PDDocument document, \n        List<EmailAttachment> attachments)throws IOException {\n            if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n                return;\n            }\n            // 1. Find the screen position of all attachment markers\n            AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n\n            finder.setSortByPosition(true); // Process pages in order\n\n            finder.getText(document);\n\n            List<MarkerPosition> markerPositions = finder.getPositions();\n\n            // 2. Warn if the number of markers and attachments don't match\n            if (markerPositions.size() != attachments.size()) {\n                log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n            }\n\n            // 3. Create an invisible annotation over each found marker\n            int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n\n            for (int i = 0; i < annotationsToAdd; i++) {\n                MarkerPosition position = markerPositions.get(i);\n                EmailAttachment attachment = attachments.get(i);\n\n                if (attachment.getEmbeddedFilename() != null) {\n                    PDPage page = document.getPage(position.getPageIndex());\n                    addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n                }\n            }\n        }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "180", "src_id": "M31", "code": "    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n        .header(\"Content-Type\", \"application/vnd.api+json\")\n        .header(\"Accept\", \"application/vnd.api+json\")\n        // .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n        .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() != 200) {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        } else {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n\n            String detail = metaNode.path(\"detail\").asText();\n\n            String code = metaNode.path(\"code\").asText();\n\n            log.info(\"License validity: {}\", isValid);\n\n            log.info(\"Validation detail: {}\", detail);\n\n            log.info(\"Validation code: {}\", code);\n\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n\n            JsonNode policyNode = null;\n\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n            // Extract user count, default to 1 if not specified\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\")\n            .asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\")\n            .asBoolean(false);\n\n            log.debug(applicationProperties.toString());\n        } \n        return jsonResponse;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "181", "src_id": "M488", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description =\n    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n    throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "182", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n            // Metadata using PDFBox\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n\n            ObjectNode metadata = objectMapper.createObjectNode();\n\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n\n            ObjectNode compliancy = objectMapper.createObjectNode();\n\n            ObjectNode encryption = objectMapper.createObjectNode();\n\n            ObjectNode other = objectMapper.createObjectNode();\n\n            metadata.put(\"Title\", info.getTitle());\n\n            metadata.put(\"Author\", info.getAuthor());\n\n            metadata.put(\"Subject\", info.getSubject());\n\n            metadata.put(\"Keywords\", info.getKeywords());\n\n            metadata.put(\"Producer\", info.getProducer());\n\n            metadata.put(\"Creator\", info.getCreator());\n\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n\n            jsonOutput.set(\"Metadata\", metadata);\n\n            // Total file size of the PDF\n            long fileSizeInBytes = inputFile.getSize();\n\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n            // Number of words, paragraphs, and images in the entire document\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n\n            String[] words = fullText.split(\"\\\\s+\");\n\n            int wordCount = words.length;\n\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n\n            basicInfo.put(\"WordCount\", wordCount);\n\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n\n            // Number of characters in the entire document (including spaces and special characters)\n            int charCount = fullText.length();\n\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            // Initialize the flags and types\n            boolean hasCompression = false;\n\n            String compressionType = \"None\";\n\n            basicInfo.put(\"Compression\", hasCompression);\n\n            if (hasCompression) {\n                basicInfo.put(\"CompressionType\", compressionType);\n            }\n\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n\n            basicInfo.put(\"Language\", language);\n\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n\n            String pageMode = catalog.getPageMode().name();\n\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n            ;\n\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n\n            // Generate structured summary data about PDF characteristics\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n            // embeed files TODO size\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                            }\n\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n            // attachments TODO size\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n            // Javascript\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n\n                            PDActionJavaScript jsAction = entry.getValue();\n\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n            // TODO size\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n\n            ArrayNode layersArray = objectMapper.createArrayNode();\n\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n\n                    layersArray.add(layerNode);\n                }\n            }\n\n            other.set(\"Layers\", layersArray);\n            // TODO Security\n\n\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n\n            ArrayNode structureTreeArray;\n\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                }\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                log.error(\"exception\", e);\n            }\n\n            boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n\n            boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n\n            boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n\n            boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n\n            boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n\n            boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n\n            // an official ISO standard.\n            boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n            // development in 2021.\n\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n\n            String xmpString = null;\n            if (pdMetadata != null) {\n                try {\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        DomXmpParser domXmpParser = new DomXmpParser();\n                        XMPMetadata xmpMeta = domXmpParser.parse(is);\n\n                        ByteArrayOutputStream os = new ByteArrayOutputStream();\n\n                        new XmpSerializer().serialize(xmpMeta, os, true);\n\n                        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                    }\n                } catch (XmpParsingException e) {\n                    // XMP parsing failed, try to read raw metadata instead\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", xmpString);\n            if (!(pdfBoxDoc.isEncrypted())) {\n                encryption.put(\"IsEncrypted\", false);\n            } else {\n                encryption.put(\"IsEncrypted\", true);\n                // Retrieve encryption details using getEncryption()\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n                // Add other encryption-related properties as needed\n            } \n\n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                // Retrieve the page\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n\n                // Page-level Information\n                PDRectangle mediaBox = page.getMediaBox();\n\n                float width = mediaBox.getWidth();\n\n                float height = mediaBox.getHeight();\n\n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n\n                getDimensionInfo(sizeInfo, width, height);\n\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n\n                pageInfo.set(\"Size\", sizeInfo);\n\n                pageInfo.put(\"Rotation\", page.getRotation());\n\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n\n                // Assuming the following boxes are defined for your document; if not, you may get\n                // null values.\n                PDRectangle cropBox = page.getCropBox();\n\n                pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n\n                PDRectangle bleedBox = page.getBleedBox();\n\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n\n                PDRectangle trimBox = page.getTrimBox();\n\n                pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n\n                PDRectangle artBox = page.getArtBox();\n\n                pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n\n                // Content Extraction\n                PDFTextStripper textStripper = new PDFTextStripper();\n\n                textStripper.setStartPage(pageNum + 1);\n\n                textStripper.setEndPage(pageNum + 1);\n\n                String pageText = textStripper.getText(pdfBoxDoc);\n\n                pageInfo.put(\"Text Characters Count\", pageText.length()); //\n                // Annotations\n\n                List<PDAnnotation> annotations = page.getAnnotations();\n\n                int subtypeCount = 0;\n\n                int contentsCount = 0;\n\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) {\n                        subtypeCount++; // Increase subtype count\n                    }\n                    if (annotation.getContents() != null) {\n                        contentsCount++; // Increase contents count\n                    }\n                }\n\n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n\n                pageInfo.set(\"Annotations\", annotationsObject);\n\n                // Images (simplified)\n                // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                // Here is a basic structure to recognize image XObjects on a page.\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n\n                PDResources resources = page.getResources();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n\n                        imageNode.put(\"Height\", image.getHeight());\n\n                        if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n\n                Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri); // Add to set to ensure uniqueness\n                    }\n                }\n                // Add unique URIs to linksArray\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n\n                    linksArray.add(linkNode);\n                }\n\n                pageInfo.set(\"Links\", linksArray);\n\n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n\n                    // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                    fontNode.put(\"Name\", font.getName());\n\n                    fontNode.put(\"Subtype\", font.getType());\n\n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n\n                        // Font stretch and BBox are not directly available in PDFBox's API, so\n                        // these are omitted for simplicity\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n                    // Create a unique key for this font node based on its attributes\n                    String uniqueKey = fontNode.toString();\n                    // Increment count if this font exists, or initialize it if new\n                    if (!(uniqueFontsMap.containsKey(uniqueKey))) {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    } else {\n                        ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        int count = existingFontNode.get(\"Count\").asInt() + 1;\n\n                        existingFontNode.put(\"Count\", count);\n                    } \n                }\n                // Add unique font entries to fontsArray\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", fontsArray);\n\n                // Access resources dictionary\n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n\n                Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n                for (COSName name : colorSpaceNames) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        byte[] iccBytes = iccData.toByteArray();\n\n                        // TODO: Further decode and analyze the ICC data if needed\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n                // Other XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType;\n\n                    if (xObject instanceof PDImageXObject) {\n                        xObjectType = \"Image\";\n                    } else {\n                        if (xObject instanceof PDFormXObject) {\n                            xObjectType = \"Form\";\n                        } else {\n                            xObjectType = \"Other\";\n                        }\n                        // Increment the count for this type in the map\n                    }\n\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                // Add the count map to pageInfo (or wherever you want to store it)\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n                ArrayNode multimediaArray = objectMapper.createArrayNode();\n\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        ObjectNode multimediaNode = objectMapper.createObjectNode();\n                        // Extract details from the annotation as needed\n                        multimediaArray.add(multimediaNode);\n                    }\n                }\n\n                pageInfo.set(\"Multimedia\", multimediaArray);\n\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n\n            jsonOutput.set(\"Compliancy\", compliancy);\n\n            jsonOutput.set(\"Encryption\", encryption);\n\n            jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n\n            jsonOutput.set(\"Other\", other);\n\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n            // Save JSON to file\n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n\n            return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n        return null;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "183", "src_id": "M24", "code": "    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n\n            String payload = new String(payloadBytes);\n\n            log.info(\"Decoded certificate payload: {}\", payload);\n\n            String encryptedData = \"\";\n\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n\n                encodedSignature = (String) attrs.get(\"sig\");\n\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n            // Verify license file algorithm\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n            // Verify signature\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n\n            log.info(\"License file signature is valid\");\n\n            // Decode the base64 data\n            String decodedData;\n\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            // Process the certificate data\n            boolean isValid = processCertificateData(decodedData, context);\n\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "184", "src_id": "M403", "code": "    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n    throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (!(entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\"))) {\n                            Files.copy(zipIn, filePath);\n                        } else {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } \n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "185", "src_id": "M317", "code": "    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n    throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n\n        PDPage page = new PDPage(pageSize);\n\n        doc.addPage(page);\n\n        float pageWidth = page.getMediaBox().getWidth();\n\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else {\n                if (\"maintainAspectRatio\".equals(fitOption)) {\n                    float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                    float pageAspectRatio = pageWidth / pageHeight;\n\n                    float scaleFactor = 1.0f;\n\n                    if (imageAspectRatio > pageAspectRatio) {\n                        scaleFactor = pageWidth / image.getWidth();\n                    } else {\n                        scaleFactor = pageHeight / image.getHeight();\n                    }\n\n                    float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n\n                    float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n\n                    contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n                }\n            }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "186", "src_id": "M307", "code": "    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network != null) {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                }\n            }// Hash the MAC address for privacy and consistency\n            else {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } \n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n            StringBuilder fingerprint = new StringBuilder();\n\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "187", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata()\n        .isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata()\n            .getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "188", "src_id": "M128", "code": "    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (!isKubernetes) {\n                if (isDocker) {\n                    return \"Docker\";\n                } else {\n                    if (!isBrowserOpen) {\n                        return \"Server-jar\";\n                    } else {\n                        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                        if (os.contains(\"win\")) {\n                            return \"Client-windows\";\n                        } else {\n                            if (os.contains(\"mac\")) {\n                                return \"Client-mac\";\n                            } else {\n                                return \"Client-unix\";\n                            }\n                        }\n                    } \n                }\n            }else {\n                return \"Kubernetes\";\n            } \n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "189", "src_id": "M101", "code": "    private void processRequest(int limitPerDay, String identifier,\n    Map<String, Bucket> buckets,\n    HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n    throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "292", "src_id": "M31", "code": "  private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n    String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n    HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")// .header(\"Authorization\", \"License \" + licenseKey)\n    .POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n    JsonNode jsonResponse = objectMapper.readTree(response.body());\n    if (response.statusCode() != 200) {\n      log.error(\"Error validating license. Status code: {}\", response.statusCode());\n    } else {\n      JsonNode metaNode = jsonResponse.path(\"meta\");\n      boolean isValid = metaNode.path(\"valid\").asBoolean();\n      String detail = metaNode.path(\"detail\").asText();\n      String code = metaNode.path(\"code\").asText();\n      log.info(\"License validity: {}\", isValid);\n      log.info(\"Validation detail: {}\", detail);\n      log.info(\"Validation code: {}\", code);\n      // Check if the license itself has floating attribute\n      JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n      if (!licenseAttrs.isMissingNode()) {\n        context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n        context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n        log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n      }\n      // Also check the policy for floating license support if included\n      JsonNode includedNode = jsonResponse.path(\"included\");\n      JsonNode policyNode = null;\n      if (includedNode.isArray()) {\n        for (JsonNode node : includedNode) {\n          if (\"policies\".equals(node.path(\"type\").asText())) {\n            policyNode = node;\n            break;\n          }\n        }\n      }\n      if (policyNode != null) {\n        // Check if this is a floating license from policy\n        boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n        int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n        // Policy takes precedence over license attributes\n        if (policyFloating) {\n          context.isFloatingLicense = true;\n          context.maxMachines = policyMaxMachines;\n        }\n        log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n      }\n      // Extract user count, default to 1 if not specified\n      int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n      applicationProperties.getPremium().setMaxUsers(users);\n      // Extract isEnterprise flag\n      context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n      log.debug(applicationProperties.toString());\n    } \n    return jsonResponse;\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "293", "src_id": "M488", "code": "  @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n  @Operation(\n  summary = \"Convert a file to a PDF using LibreOffice\",\n  description =\n  \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n  public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n    MultipartFile inputFile = generalFile.getFileInput();\n\n    // unused but can start server instance if startup time is to long\n    // LibreOfficeListener.getInstance().start();\n    File file = null;\n    try {\n      file = convertToPdf(inputFile);\n      PDDocument doc = pdfDocumentFactory.load(file);\n      return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n    } finally {\n      if (file != null) {\n        file.delete();\n      }\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "294", "src_id": "M625", "code": "  @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n  @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n  public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n\n    boolean readonly = true;\n    try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n      ObjectMapper objectMapper = new ObjectMapper();\n      ObjectNode jsonOutput = objectMapper.createObjectNode();\n      // Metadata using PDFBox\n      PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n      ObjectNode metadata = objectMapper.createObjectNode();\n      ObjectNode basicInfo = objectMapper.createObjectNode();\n      ObjectNode docInfoNode = objectMapper.createObjectNode();\n      ObjectNode compliancy = objectMapper.createObjectNode();\n      ObjectNode encryption = objectMapper.createObjectNode();\n      ObjectNode other = objectMapper.createObjectNode();\n      metadata.put(\"Title\", info.getTitle());\n      metadata.put(\"Author\", info.getAuthor());\n      metadata.put(\"Subject\", info.getSubject());\n      metadata.put(\"Keywords\", info.getKeywords());\n      metadata.put(\"Producer\", info.getProducer());\n      metadata.put(\"Creator\", info.getCreator());\n      metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n      metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n      jsonOutput.set(\"Metadata\", metadata);\n      // Total file size of the PDF\n      long fileSizeInBytes = inputFile.getSize();\n      basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n      // Number of words, paragraphs, and images in the entire document\n      String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n      String[] words = fullText.split(\"\\\\s+\");\n      int wordCount = words.length;\n      int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n      basicInfo.put(\"WordCount\", wordCount);\n      basicInfo.put(\"ParagraphCount\", paragraphCount);\n      // Number of characters in the entire document (including spaces and special characters)\n      int charCount = fullText.length();\n      basicInfo.put(\"CharacterCount\", charCount);\n      // Initialize the flags and types\n      boolean hasCompression = false;\n      String compressionType = \"None\";\n      basicInfo.put(\"Compression\", hasCompression);\n      if (hasCompression) {\n        basicInfo.put(\"CompressionType\", compressionType);\n      }\n      String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n      basicInfo.put(\"Language\", language);\n      basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n      PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n      String pageMode = catalog.getPageMode().name();\n      // Document Information using PDFBox\n      docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n      docInfoNode.put(\"Trapped\", info.getTrapped());\n      docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n      ;\n      PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n      ObjectNode formFieldsNode = objectMapper.createObjectNode();\n      if (acroForm != null) {\n        for (PDField field : acroForm.getFieldTree()) {\n          formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n        }\n      }\n      jsonOutput.set(\"FormFields\", formFieldsNode);\n      // Generate structured summary data about PDF characteristics\n      ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n      if (summaryData != null && summaryData.size() > 0) {\n        jsonOutput.set(\"SummaryData\", summaryData);\n      }\n      // embeed files TODO size\n      if (catalog.getNames() != null) {\n        PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n        ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n        if (efTree != null) {\n          Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n          if (efMap != null) {\n            for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n              ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n              embeddedFileNode.put(\"Name\", entry.getKey());\n              PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n              if (embeddedFile != null) {\n                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n              }\n              embeddedFilesArray.add(embeddedFileNode);\n            }\n          }\n        }\n        other.set(\"EmbeddedFiles\", embeddedFilesArray);\n      }\n      // attachments TODO size\n      ArrayNode attachmentsArray = objectMapper.createArrayNode();\n      for (PDPage page : pdfBoxDoc.getPages()) {\n        for (PDAnnotation annotation : page.getAnnotations()) {\n          if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n            ObjectNode attachmentNode = objectMapper.createObjectNode();\n            attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n\n            attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n            attachmentsArray.add(attachmentNode);\n          }\n        }\n      }\n      other.set(\"Attachments\", attachmentsArray);\n      // Javascript\n      PDDocumentNameDictionary namesDict = catalog.getNames();\n      ArrayNode javascriptArray = objectMapper.createArrayNode();\n      if (namesDict != null) {\n        PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n        if (javascriptDict != null) {\n          try {\n            Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n            for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n              ObjectNode jsNode = objectMapper.createObjectNode();\n              jsNode.put(\"JS Name\", entry.getKey());\n              PDActionJavaScript jsAction = entry.getValue();\n              if (jsAction != null) {\n                String jsCodeStr = jsAction.getAction();\n                if (jsCodeStr != null) {\n                  jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                }\n              }\n              javascriptArray.add(jsNode);\n            }\n          } catch (IOException e) {\n            log.error(\"exception\", e);\n          }\n        }\n      }\n      other.set(\"JavaScript\", javascriptArray);\n      // TODO size\n      PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n      ArrayNode layersArray = objectMapper.createArrayNode();\n      if (ocProperties != null) {\n        for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n          ObjectNode layerNode = objectMapper.createObjectNode();\n          layerNode.put(\"Name\", ocg.getName());\n          layersArray.add(layerNode);\n        }\n      }\n      other.set(\"Layers\", layersArray); // TODO Security\n\n      PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n      ArrayNode structureTreeArray;\n      try {\n        if (structureTreeRoot != null) {\n          structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n          other.set(\"StructureTree\", structureTreeArray);\n        }\n      } catch (Exception e) {\n        // TODO Auto-generated catch block\n        log.error(\"exception\", e);\n      }\n      boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n      boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n      boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n      boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n      boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n      boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n      // an official ISO standard.\n      boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n      // development in 2021.\n\n      compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n      compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n      compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n      compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n      compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n      compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n      compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n      PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n      ArrayNode bookmarksArray = objectMapper.createArrayNode();\n      if (root != null) {\n        for (PDOutlineItem child : root.children()) {\n          addOutlinesToArray(child, bookmarksArray);\n        }\n      }\n      other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n      PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n      String xmpString = null;\n      if (pdMetadata != null) {\n        try {\n          try (COSInputStream is = pdMetadata.createInputStream()) {\n            DomXmpParser domXmpParser = new DomXmpParser();\n            XMPMetadata xmpMeta = domXmpParser.parse(is);\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            new XmpSerializer().serialize(xmpMeta, os, true);\n            xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n          }\n        } catch (XmpParsingException e) {\n          // XMP parsing failed, try to read raw metadata instead\n          log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n          try (COSInputStream is = pdMetadata.createInputStream()) {\n            byte[] metadataBytes = is.readAllBytes();\n            xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n          }\n        } catch (IOException e) {\n          log.error(\"exception\", e);\n        }\n      }\n      other.put(\"XMPMetadata\", xmpString);\n      if (!(pdfBoxDoc.isEncrypted())) {\n        encryption.put(\"IsEncrypted\", false);\n      } else {\n        encryption.put(\"IsEncrypted\", true);\n        // Retrieve encryption details using getEncryption()\n        PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n        encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n        encryption.put(\"KeyLength\", pdfEncryption.getLength());\n        // Add other encryption-related properties as needed\n      } \n      ObjectNode permissionsNode = objectMapper.createObjectNode();\n      setNodePermissions(pdfBoxDoc, permissionsNode);\n      ObjectNode pageInfoParent = objectMapper.createObjectNode();\n      for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n        ObjectNode pageInfo = objectMapper.createObjectNode();\n        // Retrieve the page\n        PDPage page = pdfBoxDoc.getPage(pageNum);\n        // Page-level Information\n        PDRectangle mediaBox = page.getMediaBox();\n        float width = mediaBox.getWidth();\n        float height = mediaBox.getHeight();\n        ObjectNode sizeInfo = objectMapper.createObjectNode();\n        getDimensionInfo(sizeInfo, width, height);\n        sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n        pageInfo.set(\"Size\", sizeInfo);\n        pageInfo.put(\"Rotation\", page.getRotation());\n        pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n        // Boxes\n        pageInfo.put(\"MediaBox\", mediaBox.toString());\n        // Assuming the following boxes are defined for your document; if not, you may get\n        // null values.\n        PDRectangle cropBox = page.getCropBox();\n        pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n        PDRectangle bleedBox = page.getBleedBox();\n        pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n        PDRectangle trimBox = page.getTrimBox();\n        pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n        PDRectangle artBox = page.getArtBox();\n        pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n        // Content Extraction\n        PDFTextStripper textStripper = new PDFTextStripper();\n        textStripper.setStartPage(pageNum + 1);\n        textStripper.setEndPage(pageNum + 1);\n        String pageText = textStripper.getText(pdfBoxDoc);\n        pageInfo.put(\"Text Characters Count\", pageText.length()); //\n\n        // Annotations\n\n        List<PDAnnotation> annotations = page.getAnnotations();\n        int subtypeCount = 0;\n        int contentsCount = 0;\n        for (PDAnnotation annotation : annotations) {\n          if (annotation.getSubtype() != null) {\n            ++subtypeCount; \n          }\n          if (annotation.getContents() != null) {\n            ++contentsCount; \n          }\n        }\n        ObjectNode annotationsObject = objectMapper.createObjectNode();\n        annotationsObject.put(\"AnnotationsCount\", annotations.size());\n        annotationsObject.put(\"SubtypeCount\", subtypeCount);\n        annotationsObject.put(\"ContentsCount\", contentsCount);\n        pageInfo.set(\"Annotations\", annotationsObject);\n        // Images (simplified)\n        // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n        // Here is a basic structure to recognize image XObjects on a page.\n        ArrayNode imagesArray = objectMapper.createArrayNode();\n        PDResources resources = page.getResources();\n        for (COSName name : resources.getXObjectNames()) {\n          PDXObject xObject = resources.getXObject(name);\n          if (xObject instanceof PDImageXObject image) {\n            ObjectNode imageNode = objectMapper.createObjectNode();\n            imageNode.put(\"Width\", image.getWidth());\n            imageNode.put(\"Height\", image.getHeight());\n            if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n              imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n            }\n            if (image.getColorSpace() != null) {\n              imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n            }\n            imagesArray.add(imageNode);\n          }\n        }\n        pageInfo.set(\"Images\", imagesArray);\n        // Links\n        ArrayNode linksArray = objectMapper.createArrayNode();\n\n        Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n        for (PDAnnotation annotation : annotations) {\n          if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n            String uri = uriAction.getURI();\n            uniqueURIs.add(uri); // Add to set to ensure uniqueness\n          }\n        }\n        // Add unique URIs to linksArray\n        for (String uri : uniqueURIs) {\n          ObjectNode linkNode = objectMapper.createObjectNode();\n          linkNode.put(\"URI\", uri);\n          linksArray.add(linkNode);\n        }\n        pageInfo.set(\"Links\", linksArray);\n        // Fonts\n        ArrayNode fontsArray = objectMapper.createArrayNode();\n        Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n        for (COSName fontName : resources.getFontNames()) {\n          PDFont font = resources.getFont(fontName);\n          ObjectNode fontNode = objectMapper.createObjectNode();\n          fontNode.put(\"IsEmbedded\", font.isEmbedded());\n          // PDFBox provides Font's BaseFont (i.e., the font name) directly\n          fontNode.put(\"Name\", font.getName());\n          fontNode.put(\"Subtype\", font.getType());\n          PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n          if (fontDescriptor != null) {\n            fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n            int flags = fontDescriptor.getFlags();\n            fontNode.put(\"IsItalic\", (flags & 1) != 0);\n            fontNode.put(\"IsBold\", (flags & 64) != 0);\n            fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n            fontNode.put(\"IsSerif\", (flags & 4) != 0);\n            fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n            fontNode.put(\"IsScript\", (flags & 16) != 0);\n            fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n            fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n            // Font stretch and BBox are not directly available in PDFBox's API, so\n            // these are omitted for simplicity\n            fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n          }\n          // Create a unique key for this font node based on its attributes\n          String uniqueKey = fontNode.toString();\n          // Increment count if this font exists, or initialize it if new\n          if (!(uniqueFontsMap.containsKey(uniqueKey))) {\n            fontNode.put(\"Count\", 1);\n\n            uniqueFontsMap.put(uniqueKey, fontNode);\n          } else {\n            ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n            int count = existingFontNode.get(\"Count\").asInt() + 1;\n            existingFontNode.put(\"Count\", count);\n          } \n        }\n        // Add unique font entries to fontsArray\n        for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n          fontsArray.add(uniqueFontNode);\n        }\n        pageInfo.set(\"Fonts\", fontsArray);\n        // Access resources dictionary\n        ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n\n        Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n        for (COSName name : colorSpaceNames) {\n          PDColorSpace colorSpace = resources.getColorSpace(name);\n          if (colorSpace instanceof PDICCBased iccBased) {\n            PDStream iccData = iccBased.getPDStream();\n            byte[] iccBytes = iccData.toByteArray();\n            // TODO: Further decode and analyze the ICC data if needed\n            ObjectNode iccProfileNode = objectMapper.createObjectNode();\n            iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n            colorSpacesArray.add(iccProfileNode);\n          }\n        }\n        pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n        // Other XObjects\n        Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n        for (COSName name : resources.getXObjectNames()) {\n          PDXObject xObject = resources.getXObject(name);\n\n          String xObjectType;\n\n          if (!(xObject instanceof PDImageXObject)) {\n            xObjectType = xObject instanceof PDFormXObject ? \"Form\" : \"Other\"; \n          }else {\n            xObjectType = \"Image\";\n          } \n          xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n        }\n        // Add the count map to pageInfo (or wherever you want to store it)\n        ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n        for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n          xObjectCountNode.put(entry.getKey(), entry.getValue());\n        }\n        pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n        ArrayNode multimediaArray = objectMapper.createArrayNode();\n        for (PDAnnotation annotation : annotations) {\n          if (\"RichMedia\".equals(annotation.getSubtype())) {\n            ObjectNode multimediaNode = objectMapper.createObjectNode();\n            // Extract details from the annotation as needed\n            multimediaArray.add(multimediaNode);\n          }\n        }\n        pageInfo.set(\"Multimedia\", multimediaArray);\n        pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n      }\n      jsonOutput.set(\"BasicInfo\", basicInfo);\n      jsonOutput.set(\"DocumentInfo\", docInfoNode);\n      jsonOutput.set(\"Compliancy\", compliancy);\n      jsonOutput.set(\"Encryption\", encryption);\n      jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n      jsonOutput.set(\"Other\", other);\n      jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n      // Save JSON to file\n      String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n      return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n    } catch (Exception e) {\n      log.error(\"exception\", e);\n    }\n    return null;\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "295", "src_id": "M24", "code": "  private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n    try {\n      String encodedPayload = licenseFile;\n      // Remove the header\n      encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n      // Remove the footer\n      encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n      // Remove all newlines\n      encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n      byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n      String payload = new String(payloadBytes);\n      log.info(\"Decoded certificate payload: {}\", payload);\n      String encryptedData = \"\";\n      String encodedSignature = \"\";\n      String algorithm = \"\";\n      try {\n        JSONObject attrs = new JSONObject(payload);\n        encryptedData = (String) attrs.get(\"enc\");\n        encodedSignature = (String) attrs.get(\"sig\");\n        algorithm = (String) attrs.get(\"alg\");\n      } catch (JSONException e) {\n        log.error(\"Failed to parse license file: {}\", e.getMessage());\n        return false;\n      }\n      // Verify license file algorithm\n      if (!\"base64+ed25519\".equals(algorithm)) {\n        log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n        return false;\n      }\n      // Verify signature\n      boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n      if (!isSignatureValid) {\n        log.error(\"License file signature is invalid\");\n        return false;\n      }\n      log.info(\"License file signature is valid\");\n      // Decode the base64 data\n      String decodedData;\n      try {\n        decodedData = new String(Base64.getDecoder().decode(encryptedData));\n      } catch (IllegalArgumentException e) {\n        log.error(\"Failed to decode license data: {}\", e.getMessage());\n        return false;\n      }\n      // Process the certificate data\n      boolean isValid = processCertificateData(decodedData, context);\n      return isValid;\n    } catch (Exception e) {\n      log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n      return false;\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "296", "src_id": "M403", "code": "  private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws IOException {\n    try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n      try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n        ZipEntry entry = zipIn.getNextEntry();\n        while (entry != null) {\n          Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n          if (!entry.isDirectory()) {\n            Files.createDirectories(filePath.getParent());\n            if (!(entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\"))) {\n              Files.copy(zipIn, filePath);\n            } else {\n              String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n              String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n              Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n            } \n          }\n          zipIn.closeEntry();\n          entry = zipIn.getNextEntry();\n        }\n      }\n      // Repack the sanitized files\n      zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n    } // tempUnzippedDir auto-cleaned\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "297", "src_id": "M317", "code": "  public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws IOException {\n    boolean imageIsLandscape = image.getWidth() > image.getHeight();\n    PDRectangle pageSize = PDRectangle.A4;\n\n    if (autoRotate && imageIsLandscape) {\n      pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n    }\n    if (\"fitDocumentToImage\".equals(fitOption)) {\n      pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n    }\n    PDPage page = new PDPage(pageSize);\n    doc.addPage(page);\n    float pageWidth = page.getMediaBox().getWidth();\n    float pageHeight = page.getMediaBox().getHeight();\n    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n      if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n        contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n      } else {\n        if (\"maintainAspectRatio\".equals(fitOption)) {\n          float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n          float pageAspectRatio = pageWidth / pageHeight;\n          float scaleFactor = 1.0f;\n          scaleFactor = imageAspectRatio > pageAspectRatio ? pageWidth / image.getWidth() : pageHeight / image.getHeight(); \n          float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n          float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n          contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n        }\n      }\n    } catch (IOException e) {\n      log.error(\"Error adding image to PDF\", e);\n      throw e;\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "298", "src_id": "M307", "code": "  public static String generateMachineFingerprint() {\n    try {\n      // Get the MAC address\n      StringBuilder sb = new StringBuilder();\n      InetAddress ip = InetAddress.getLocalHost();\n      NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n      if (network != null) {\n        byte[] mac = network.getHardwareAddress();\n        if (mac != null) {\n          for (int i = 0; i < mac.length; i++) {\n            sb.append(String.format(\"%02X\", mac[i]));\n          }\n        }\n      }// Hash the MAC address for privacy and consistency\n      else {\n        Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n        while (networks.hasMoreElements()) {\n          NetworkInterface net = networks.nextElement();\n          byte[] mac = net.getHardwareAddress();\n          if (mac != null) {\n            for (int i = 0; i < mac.length; i++) {\n              sb.append(String.format(\"%02X\", mac[i]));\n            }\n            break; // Use the first network interface with a MAC address\n          }\n        }\n      } \n      MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n      byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n      StringBuilder fingerprint = new StringBuilder();\n      for (byte b : hash) {\n        fingerprint.append(String.format(\"%02x\", b));\n      }\n      return fingerprint.toString();\n    } catch (Exception e) {\n      return \"GenericID\";\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "299", "src_id": "M135", "code": "  private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n    String title = pdfMetadata.getTitle();\n    pdf.getDocumentInformation().setTitle(title);\n    pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n      author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n      if (userService != null) {\n        author = author.replace(\"username\", userService.getCurrentUsername());\n      }\n    }\n    pdf.getDocumentInformation().setAuthor(author);\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "300", "src_id": "M128", "code": "  @Bean(name = \"machineType\")\n  public String determineMachineType() {\n    try {\n      boolean isDocker = runningInDocker();\n      boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n      boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n      if (!isKubernetes) {\n        if (isDocker) {\n          return \"Docker\";\n        } else {\n          if (!isBrowserOpen) {\n            return \"Server-jar\";\n          } else {\n            String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n            if (os.contains(\"win\")) {\n              return \"Client-windows\";\n            } else {\n              if (os.contains(\"mac\")) {\n                return \"Client-mac\";\n              } else {\n                return \"Client-unix\";\n              }\n            }\n          } \n        }\n      }else {\n        return \"Kubernetes\";\n      } \n    } catch (Exception e) {\n      return \"Unknown\";\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "301", "src_id": "M101", "code": "  private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n      response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n      filterChain.doFilter(request, response);\n    } else {\n      long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n      response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n      response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n      response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n    }\n  }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "319", "src_id": "M270", "code": "  private static String normalizeArch(String value) {\n    value = normalize(value);\n    if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n      return \"x86_64\";\n    }\n    if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n      return \"x86_32\";\n    }\n\n    if (value.matches(\"^(ia64w?|itanium64)$\")) {\n      return \"itanium_64\";\n    }\n    if (\"ia64n\".equals(value)) {\n      return \"itanium_32\";\n    }\n    if (value.matches(\"^(sparc|sparc32)$\")) {\n      return \"sparc_32\";\n    }\n    if (value.matches(\"^(sparcv9|sparc64)$\")) {\n      return \"sparc_64\";\n    }\n    if (value.matches(\"^(arm|arm32)$\")) {\n      return \"arm_32\";\n    }\n    if (\"aarch64\".equals(value)) {\n      return \"aarch_64\";\n    }\n    if (value.matches(\"^(mips|mips32)$\")) {\n      return \"mips_32\";\n    }\n    if (value.matches(\"^(mipsel|mips32el)$\")) {\n      return \"mipsel_32\";\n    }\n    if (\"mips64\".equals(value)) {\n      return \"mips_64\";\n    }\n    if (\"mips64el\".equals(value)) {\n      return \"mipsel_64\";\n    }\n    if (value.matches(\"^(ppc|ppc32)$\")) {\n      return \"ppc_32\";\n    }\n    if (value.matches(\"^(ppcle|ppc32le)$\")) {\n      return \"ppcle_32\";\n    }\n    if (\"ppc64\".equals(value)) {\n      return \"ppc_64\";\n    }\n    if (\"ppc64le\".equals(value)) {\n      return \"ppcle_64\";\n    }\n    if (\"s390\".equals(value)) {\n      return \"s390_32\";\n    }\n    if (\"s390x\".equals(value)) {\n      return \"s390_64\";\n    }\n    return value;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "320", "src_id": "M928", "code": "  private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n    Map<String, Object> info = new HashMap<String, Object>();\n    info.put(LoggerHelper.name, logger.getName());\n    info.put(LoggerHelper.clazz, logger.getClass());\n    CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n\n    if (codeSource != null) {\n      info.put(LoggerHelper.codeSource, codeSource.getLocation());\n    }\n    info.put(LoggerHelper.additivity, logger.getAdditivity());\n    Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n\n    if (level != null) {\n      info.put(LoggerHelper.level, level.toString());\n    }\n    if (effectiveLevel != null) {\n      info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n    }\n    @SuppressWarnings(\"unchecked\") List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n    info.put(LoggerHelper.appenders, result);\n    return info;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "321", "src_id": "M9", "code": "  @SuppressWarnings(\"resource\")\n  public static long select(boolean v, long telnetPortPid, String select) throws InputMismatchException {\n    Map<Long, String> processMap = listProcessByJps(v);\n    // Put the port that is already listening at the first\n    if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n      String telnetPortProcess = processMap.get(telnetPortPid);\n      processMap.remove(telnetPortPid);\n      Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n      newProcessMap.put(telnetPortPid, telnetPortProcess);\n      newProcessMap.putAll(processMap);\n      processMap = newProcessMap;\n    }\n    if (processMap.isEmpty()) {\n      AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n      return -1;\n    }\n    // select target process by the '--select' option when match only one process\n    if (select != null && !select.trim().isEmpty()) {\n      int matchedSelectCount = 0;\n      Long matchedPid = null;\n      for (Entry<Long, String> entry : processMap.entrySet()) {\n        if (entry.getValue().contains(select)) {\n          ++matchedSelectCount; \n          matchedPid = entry.getKey();\n        }\n      }\n      if (matchedSelectCount == 1) {\n        return matchedPid;\n      }\n    }\n    AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n    // print list\n    int count = 1;\n    for (String process : processMap.values()) {\n      if (count == 1) {\n        System.out.println(\"* [\" + count + \"]: \" + process);\n      } else {\n        System.out.println(\"  [\" + count + \"]: \" + process);\n      }\n      ++count; \n    }\n    // read choice\n    String line = new Scanner(System.in).nextLine();\n    if (line.trim().isEmpty()) {\n      // get the first process id\n      return processMap.keySet().iterator().next();\n    }\n    int choice = new Scanner(line).nextInt();\n    if (choice <= 0) {\n      return -1;\n    }\n    if (choice > processMap.size()) {\n    return -1;\n      }\n    Iterator<Long> idIter = processMap.keySet().iterator();\n    for (int i = 1; i <= choice; ++i) {\n      if (i == choice) {\n        return idIter.next();\n      }\n      idIter.next();\n    }\n    return -1;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "322", "src_id": "M140", "code": "  void _processDo(int option) throws IOException {\n    if (debugoptions) {\n      System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n    }\n    if (__notifhand != null) {\n      __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n    }\n    boolean acceptNewState = false; /* open TelnetOptionHandler functionality (start)*/\n    if (optionHandlers[option] != null) {\n      acceptNewState = optionHandlers[option].getAcceptLocal();\n    } else { /* open TelnetOptionHandler functionality (end)*//* TERMINAL-TYPE option (start)*/\n      if (option == TERMINAL_TYPE && ((terminalType != null) && (terminalType.length() > 0))) {\n        acceptNewState = true;\n      }\n    }/* open TelnetOptionHandler functionality (end)*/\n    if (_willResponse[option] > 0) {\n      --_willResponse[option];\n      if (_willResponse[option] > 0 && _stateIsWill(option)) {\n        --_willResponse[option];\n      }\n    }\n    if (_willResponse[option] == 0) {\n      if (!_requestedWont(option)) { // Other end has acknowledged option.\n\n        switch (option)\n        {\n\n          default:\n            break;\n\n        }\n      } else {\n        switch (option)\n        {\n\n          default:\n            break;\n\n        }\n        if (acceptNewState) {\n          _setWantWill(option);\n          _sendWill(option);\n        } else {\n          ++_willResponse[option];\n          _sendWont(option);\n        }\n      }\n    }\n    _setWill(option);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "323", "src_id": "M1324", "code": "  private void bind(Configure configure) throws Throwable {\n    long start = System.currentTimeMillis();\n    if (!isBindRef.compareAndSet(false, true)) {\n      throw new IllegalStateException(\"already bind\");\n    }\n    // init random port\n    if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n      int newTelnetPort = SocketUtils.findAvailableTcpPort();\n      configure.setTelnetPort(newTelnetPort);\n      logger().info(\"generate random telnet port: \" + newTelnetPort);\n    }\n    if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n      int newHttpPort = SocketUtils.findAvailableTcpPort();\n      configure.setHttpPort(newHttpPort);\n      logger().info(\"generate random http port: \" + newHttpPort);\n    }\n    // try to find appName\n    if (configure.getAppName() == null) {\n      configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n    }\n    try {\n      if (configure.getTunnelServer() != null) {\n        tunnelClient = new TunnelClient();\n        tunnelClient.setAppName(configure.getAppName());\n        tunnelClient.setId(configure.getAgentId());\n        tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n        tunnelClient.setVersion(ArthasBanner.version());\n        ChannelFuture channelFuture = tunnelClient.start();\n        channelFuture.await(10, TimeUnit.SECONDS);\n      }\n    } catch (Throwable t) {\n      logger().error(\"start tunnel client error\", t);\n    }\n    try {\n      ShellServerOptions options = new ShellServerOptions().setInstrumentation(instrumentation).setPid(PidUtils.currentLongPid()).setWelcomeMessage(ArthasBanner.welcome());\n      if (configure.getSessionTimeout() != null) {\n        options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n      }\n      this.httpSessionManager = new HttpSessionManager();\n      if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n        // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n        String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \" + \"No password is currently configured. \" + \"Therefore, a default password is generated, \" + \"and clients need to use the password to connect!\";\n        AnsiLog.error(errorMsg);\n        configure.setPassword(StringUtils.randomString(64));\n        AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n        logger().error(errorMsg);\n        logger().info(\"Generated arthas password: \" + configure.getPassword());\n      }\n      this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n      shellServer = new ShellServerImpl(options);\n      List<String> disabledCommands = new ArrayList<String>();\n      if (configure.getDisabledCommands() != null) {\n        String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n        if (strings != null) {\n          disabledCommands.addAll(Arrays.asList(strings));\n        }\n      }\n      BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n      List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n      resolvers.add(builtinCommands);\n      //worker group\n      workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n      // TODO: discover user provided command resolver\n      if (!(configure.getTelnetPort() != null && configure.getTelnetPort() > 0)) {\n        logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n      } else {\n        logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n        shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n      } \n      if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n        logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n        shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n      } else {\n        // listen local address in VM communication\n        if (configure.getTunnelServer() != null) {\n          shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n        }\n        logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n      }\n      for (CommandResolver resolver : resolvers) {\n        shellServer.registerCommandResolver(resolver);\n      }\n      shellServer.listen(new BindHandler(isBindRef));\n      if (!isBind()) {\n        throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" + String.valueOf(configure.getTelnetPort()) + \", http port: \" + String.valueOf(configure.getHttpPort()));\n      }\n      //http api session manager\n      sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n      //http api handler\n      httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n      logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n      // 异步回报启动次数\n      if (configure.getStatUrl() != null) {\n        logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n      }\n      UserStatUtil.setStatUrl(configure.getStatUrl());\n\n      UserStatUtil.setAgentId(configure.getAgentId());\n      UserStatUtil.arthasStart();\n      try {\n        SpyAPI.init();\n      } catch (Throwable e) {\n      // ignore\n      }\n      logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n    } catch (Throwable e) {\n      logger().error(\"Error during start as-server\", e);\n\n      destroy();\n      throw e;\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "324", "src_id": "M122", "code": "  private int __read(boolean mayBlock) throws IOException {\n    int ch;\n    while (true) {\n      // If there is no more data AND we were told not to block,\n      // just return WOULD_BLOCK (-2). (More efficient than exception.)\n      if (!mayBlock && super.available() == 0) {\n        return WOULD_BLOCK;\n      }\n      // Otherwise, exit only when we reach end of stream.\n      if ((ch = super.read()) < 0) {\n        return EOF;\n      }\n      ch = (ch & 0xff); /* Code Section added for supporting AYT (start)*/\n      synchronized (__client)\n      {\n        __client._processAYTResponse();\n      }/* Code Section added for supporting AYT (end)*//* Code Section added for supporting spystreams (start)*/\n      __client._spyRead(ch); /* Code Section added for supporting spystreams (end)*/\n      switch (__receiveState) {\n\n        case _STATE_CR:\n          if (ch == '\\0')\n          {\n            // Strip null\n            continue;\n          }\n          // How do we handle newline after cr?\n          //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n\n          // Handle as normal data by falling through to _STATE_DATA case\n\n          //$FALL-THROUGH$\n        case _STATE_DATA:\n          if (ch == TelnetCommand.IAC) {\n            __receiveState = _STATE_IAC;\n            continue;\n          }\n          if (ch != '\\r') {\n            __receiveState = _STATE_DATA;\n          }\n          else {\n            synchronized (__client)\n            {\n              __receiveState = __client._requestedDont(TelnetOption.BINARY) ? _STATE_CR : _STATE_DATA; \n            }\n          } \n          break;\n        case _STATE_IAC:\n          switch (ch) {\n            case TelnetCommand.WILL:\n              __receiveState = _STATE_WILL;\n              continue;\n            case TelnetCommand.WONT:\n              __receiveState = _STATE_WONT;\n              continue;\n            case TelnetCommand.DO:\n              __receiveState = _STATE_DO;\n              continue;\n            case TelnetCommand.DONT:\n              __receiveState = _STATE_DONT;\n              continue;\n              /* TERMINAL-TYPE option (start)*/\n            case TelnetCommand.SB:\n              __suboption_count = 0;\n              __receiveState = _STATE_SB;\n              continue;\n              /* TERMINAL-TYPE option (end)*/\n            case TelnetCommand.IAC:\n              __receiveState = _STATE_DATA;\n              break; // exit to enclosing switch to return IAC from read\n            case TelnetCommand.SE : // unexpected byte! ignore it (don't send it as a command)\n              __receiveState = _STATE_DATA;\n              continue;\n            default:\n              __receiveState = _STATE_DATA;\n              __client._processCommand(ch); // Notify the user\n              continue; // move on the next char\n          }\n          break; // exit and return from read\n        case _STATE_WILL:\n          synchronized (__client)\n          {\n            __client._processWill(ch);\n            __client._flushOutputStream();\n          }\n          __receiveState = _STATE_DATA;\n          continue;\n        case _STATE_WONT:\n          synchronized (__client)\n          {\n            __client._processWont(ch);\n            __client._flushOutputStream();\n          }\n          __receiveState = _STATE_DATA;\n          continue;\n        case _STATE_DO:\n          synchronized (__client)\n          {\n            __client._processDo(ch);\n            __client._flushOutputStream();\n          }\n          __receiveState = _STATE_DATA;\n          continue;\n        case _STATE_DONT:\n          synchronized (__client)\n          {\n            __client._processDont(ch);\n            __client._flushOutputStream();\n          }\n          __receiveState = _STATE_DATA;\n          continue; /* TERMINAL-TYPE option (start)*/\n        case _STATE_SB:\n          switch (ch)\n          {\n            case TelnetCommand.IAC:\n              __receiveState = _STATE_IAC_SB;\n              continue;\n            default:\n              // store suboption char\n              if (__suboption_count < __suboption.length) {\n                __suboption[__suboption_count++] = ch;\n              }\n              break;\n          }\n          __receiveState = _STATE_SB;\n\n          continue;\n        case _STATE_IAC_SB : // IAC received during SB phase\n          switch (ch)\n          {\n            case TelnetCommand.SE:\n              synchronized (__client)\n              {\n                __client._processSuboption(__suboption, __suboption_count);\n                __client._flushOutputStream();\n              }\n              __receiveState = _STATE_DATA;\n              continue;\n            case TelnetCommand.IAC : // De-dup the duplicated IAC\n              if (__suboption_count < __suboption.length) {\n                __suboption[__suboption_count++] = ch;\n              }\n              break;\n            default :            // unexpected byte! ignore it\n              break;\n          }\n          __receiveState = _STATE_SB;\n          continue; /* TERMINAL-TYPE option (end)*/\n      }\n      break;\n    }\n    return ch;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "325", "src_id": "M8", "code": "  private static String formatFileSize(long size) {\n    String hrSize;\n    double b = size;\n    double k = size / 1024.0;\n    double m = ((size / 1024.0) / 1024.0);\n    double g = (((size / 1024.0) / 1024.0) / 1024.0);\n    double t = ((((size / 1024.0) / 1024.0) / 1024.0) / 1024.0);\n    DecimalFormat dec = new DecimalFormat(\"0.00\");\n    if (t <= 1) {\n      if (g > 1) {\n        hrSize = dec.format(g).concat(\" GB\");\n      } else {\n        if (m <= 1) {\n          hrSize = k > 1? dec.format(k).concat(\" KB\") : dec.format(b).concat(\" Bytes\"); \n        }else {\n          hrSize = dec.format(m).concat(\" MB\");\n        } \n      }\n    }else {\n      hrSize = dec.format(t).concat(\" TB\");\n    } \n    return hrSize;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "326", "src_id": "M790", "code": "  @Override\n  public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n    if (className == null) {\n      return null;\n    }\n\n    className = className.replace('/', '.');\n    List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n    // 倒序，因为要执行的配置生效\n    ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n    while (listIterator.hasPrevious()) {\n      RetransformEntry retransformEntry = listIterator.previous();\n      int id = retransformEntry.getId();\n      // 判断类名是否一致\n      boolean updateFlag = false;\n      // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n      if (className.equals(retransformEntry.getClassName())) {\n        updateFlag = retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null? isLoaderMatch(retransformEntry, loader) : true; \n      }\n      if (updateFlag) {\n        logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n        retransformEntry.incTransformCount();\n        return retransformEntry.getBytes();\n      }\n    }\n    return null;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "327", "src_id": "M716", "code": "  public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n    // 执行失败:输出失败状态\n    table.row(\"IS-RETURN\", \"\" + false);\n\n    table.row(\"IS-EXCEPTION\", \"\" + true);\n    // 执行失败:输出失败异常信息\n    Throwable cause;\n    Throwable t = (Throwable) throwableVO.getObject();\n    cause = t instanceof InvocationTargetException ? t.getCause() : t; \n    if (throwableVO.needExpand()) {\n      table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n    } else {\n      StringWriter stringWriter = new StringWriter();\n      PrintWriter printWriter = new PrintWriter(stringWriter);\n      try {\n        cause.printStackTrace(printWriter);\n        table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n      } finally {\n        printWriter.close();\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "328", "src_id": "M602", "code": "  private AsyncProfiler profilerInstance() {\n    if (profiler != null) {\n      return profiler;\n    }\n    // try to load from special path\n    if (ProfilerAction.load.toString().equals(action)) {\n      profiler = AsyncProfiler.getInstance(this.actionArg);\n    }\n    if (libPath == null) {\n      if (OSUtils.isLinux() || OSUtils.isMac()) {\n        throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n      } else {\n        throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n      }\n    } else {\n      // load from arthas directory\n      // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n      FileOutputStream tmpLibOutputStream = null;\n      FileInputStream libInputStream = null;\n      try {\n        File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n        tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n        libInputStream = new FileInputStream(libPath);\n        IOUtils.copy(libInputStream, tmpLibOutputStream);\n        libPath = tmpLibFile.getAbsolutePath();\n        logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n      } catch (Throwable e) {\n        logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n      } finally {\n        IOUtils.close(libInputStream);\n\n        IOUtils.close(tmpLibOutputStream);\n      }\n      profiler = AsyncProfiler.getInstance(libPath);\n    } \n    return profiler;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "11", "src_id": "M1043", "code": "private void doPostprocessing() {\n     errCode = ERROR_NOTHING;\n     errObject = null;\n     Thread thread = Thread.currentThread();\n     notifyPostProcessing(1);\n\n     if (DEBUG) {\n          thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n     }\n\n     Exception exception = null;\n\n     try {\n          psAlgorithm.run(this);\n     } catch (Exception err) {\n          Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n          if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n               notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n               return;\n          }\n\n          if (errCode == ERROR_NOTHING) {\n               errCode = ERROR_POSTPROCESSING;\n          }\n\n          exception = err;\n     } finally {\n          notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n     }\n\n     if (errCode != ERROR_NOTHING) {\n          if (exception == null) {\n               exception = errObject;\n          }\n\n          notifyError(ERROR_POSTPROCESSING, exception);\n          return;\n     }\n\n     notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "12", "src_id": "M1031", "code": "void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n     int statusCode = conn.getResponseCode();\n     if (DEBUG) {\n          Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n          \n          Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n          \n          Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n          \n          Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n     }\n\n     switch (statusCode) {\n          case 204:\n          case 205:\n          case 207:\n               throw new HttpError(statusCode);\n          case 416:\n               return; // let the download thread handle this error\n          default:\n               if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n               }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "13", "src_id": "M827", "code": "private Elst parseEdts(final Box ref) throws IOException {\n     final Box b = untilBox(ref, ATOM_ELST);\n     if (b == null) {\n          return null;\n     }\n     final Elst obj = new Elst();\n     final boolean v1 = stream.read() == 1;\n     stream.skipBytes(3); // flags\n     \n     final int entryCount = stream.readInt();\n     \n     if (entryCount < 1) {\n          obj.bMediaRate = 0x00010000; // default media rate (1.0)\n          return obj;\n     }\n\n     if (!v1) {\n          stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n          obj.mediaTime = stream.readInt();\n     } else {\n          stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n          obj.mediaTime = stream.readLong();\n          \n          // ignore all remain entries\n          stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n     } \n\n     obj.bMediaRate = stream.readInt();\n\n     return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "14", "src_id": "M1048", "code": "@Override\npublic void run() {\n     boolean done;\n     long start = mMission.fallbackResumeOffset;\n\n     if (DEBUG && !mMission.unknownLength && start > 0) {\n          Log.i(TAG, \"Resuming a single-thread download at \" + start);\n     }\n\n     try {\n          long rangeStart = (mMission.unknownLength || start < 1) ? \n          -1 : start;\n\n          int mId = 1;\n          \n          mConn = mMission.openConnection(false, rangeStart, -1);\n\n          if (mRetryCount == 0 && rangeStart == -1) {\n               // workaround: bypass android connection pool\n               mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n          }\n\n          mMission.establishConnection(mId, mConn);\n\n          // check if the download can be resumed\n          if (mConn.getResponseCode() == 416 && start > 0) {\n               mMission.notifyProgress(-start);\n               start = 0;\n               mRetryCount--;\n               throw new DownloadMission.HttpError(416);\n          }\n\n          // secondary check for the file length\n          if (!mMission.unknownLength)\n          {\n               mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n          }\n\n          if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n               // restart amount of bytes downloaded\n               mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n          }\n\n          mF = mMission.storage.getStream();\n          \n          mF.seek(mMission.offsets[mMission.current] + start);\n          mIs = mConn.getInputStream();\n\n          byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n          int len = 0;\n\n          while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n               mF.write(buf, 0, len);\n               start += len;\n               mMission.notifyProgress(len);\n          }\n\n          dispose();\n\n          // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n          done = len == -1;\n     } catch (Exception e) {\n          dispose();\n          mMission.fallbackResumeOffset = start;\n\n          if (!mMission.running || e instanceof ClosedByInterruptException) {\n               return;\n          }\n\n          if (e instanceof HttpError && ((HttpError)e).statusCode == ERROR_HTTP_FORBIDDEN) {\n               // for youtube streams. The url has expired, recover\n               dispose();\n               mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n               return;\n          }\n\n          if (mRetryCount++ >= mMission.maxRetry) {\n               mMission.notifyError(e);\n               return;\n          }\n\n          if (DEBUG) {\n               Log.e(TAG, \"got exception, retrying...\", e);\n          }\n\n          run(); // try again\n          return;\n     }\n\n     if (done) {\n          mMission.notifyFinished();\n     } else {\n          mMission.fallbackResumeOffset = start;\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "15", "src_id": "M1141", "code": "private void flushAuxiliar(long amount) throws IOException {\n     if (aux.length < 1) {\n          return;\n     }\n     out.flush();\n     aux.flush();\n     boolean underflow = aux.offset < aux.length || out.offset < out.length;\n     \n     byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n     aux.target.seek(0);\n     out.target.seek(out.length);\n     long length = amount;\n     \n     while (length > 0) {\n          int read = (int)Math.min(length, Integer.MAX_VALUE);\n          \n          read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n          if (read < 1) {\n               amount -= length;\n               break;\n          }\n\n          out.writeProof(buffer, read);\n          length -= read;\n     }\n\n     if (!underflow) {\n          out.offset += amount;\n          aux.offset -= amount;\n     } else {\n          if (out.offset < out.length) {\n               aux.offset = 0;\n          } else {\n               // calculate the aux underflow pointer\n               if (aux.offset >= amount) {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n               } else {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n               } \n          } \n     } \n\n     out.length += amount;\n\n     if (out.length > maxLengthKnown) {\n          maxLengthKnown = out.length;\n     }\n\n     if (amount < aux.length) {\n          // move the excess data to the beginning of the file\n          long readOffset = amount;\n          long writeOffset = 0;\n          aux.length -= amount;\n          length = aux.length;\n          \n          while (length > 0) {\n               int read = (int)Math.min(length, Integer.MAX_VALUE);\n               \n               read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n               aux.target.seek(writeOffset);\n               \n               aux.writeProof(buffer, read);\n               writeOffset += read;\n               readOffset += read;\n               length -= read;\n               aux.target.seek(readOffset);\n          }\n\n          aux.target.setLength(aux.length);\n          \n          return;\n     }\n\n     if (aux.length > THRESHOLD_AUX_LENGTH) {\n          aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n     }\n\n     aux.reset();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "16", "src_id": "M1106", "code": "private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n     StringBuilder request = new StringBuilder(256);\n     \n     request.append(mission.source);\n     request.append(\" [\");\n     \n     if (mission.recoveryInfo != null) {\n          for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n          {\n               request.append(' ').append(recovery.toString()).append(' ');\n          }\n     }\n     \n     request.append(\"]\");\n\n     String service;\n     \n     try {\n          service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n     } catch (Exception e) {\n          service = ErrorInfo.SERVICE_NONE;\n     }\n\n     ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "17", "src_id": "M1067", "code": "void startMission(DownloadMission mission) {\n     synchronized (this) {\n          mission.timestamp = System.currentTimeMillis();\n          mission.mHandler = mHandler;\n          mission.maxRetry = mPrefMaxRetry;\n\n          // create metadata file\n          while (true) {\n               mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n               if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                         if (!mission.metadata.createNewFile())\n                         {\n                              throw new RuntimeException(\"Cant create download metadata file\");\n                         }\n                    } catch (IOException e) {\n                         throw new RuntimeException(e);\n                    }\n                    break;\n               }\n               \n               mission.timestamp = System.currentTimeMillis();\n          }\n\n          mSelfMissionsControl = true;\n          \n          mMissionsPending.add(mission);\n          // Before continue, save the metadata in case the internet connection is not available\n          Utility.writeToFile(mission.metadata, mission);\n\n          if (mission.storage == null) {\n               // noting to do here\n               mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n               if (mission.errObject != null)\n               {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n               }\n\n               return;\n          }\n\n          boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n          if (canDownloadInCurrentNetwork() && start) {\n               mission.start();\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "18", "src_id": "M1136", "code": "@Override int process(SharpStream out, SharpStream... sources) throws IOException {\n     // check if the subtitle is already in srt and copy, this should never happen\n     String format = getArgumentAt(0, null);\n     \n     boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n     if (!(format == null || format.equals(\"ttml\"))) {\n          if (format.equals(\"srt\")) {\n               byte[] buffer = new byte[8 * 1024];\n               int read;\n               while ((read = sources[0].read(buffer)) > 0) {\n                    out.write(buffer, 0, read);\n               }\n               return OK_RESULT;\n          }\n     } else {\n          SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n          try {\n               writer.build(sources[0]);\n          } catch (Exception err) {\n               Log.e(TAG, \"subtitle parse failed\", err);\n               \n               if (err instanceof IOException) { \n                    return 1; \n               } else { \n                    return 8; \n               } \n          }\n\n          return OK_RESULT;\n     } \n\n     throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "19", "src_id": "M1047", "code": "private void joinForThreads(int millis) {\n     final Thread currentThread = Thread.currentThread();\n     if (init != null && init != currentThread && init.isAlive()) {\n          init.interrupt();\n          if (millis > 0) {\n               try {\n                    init.join(millis);\n               } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n               }\n          }\n     }\n     // if a thread is still alive, possible reasons:\n     //      slow device\n     //      the user is spamming start/pause buttons\n     //      start() method called quickly after pause()\n     \n\n     for (Thread thread : threads) {\n          if (!thread.isAlive() || thread == Thread.currentThread()) {\n               continue;\n          }\n\n          thread.interrupt();\n     }\n\n     try {\n          for (Thread thread : threads) {\n               if (!thread.isAlive()) {\n                    continue;\n               }\n\n               if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n               }\n               \n               if (millis > 0) {\n                    thread.join(millis);\n               }\n          }\n     } catch (InterruptedException e) {\n          throw new RuntimeException(\"A download thread is still running\", e);\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "38", "src_id": "M1277", "code": "            public static Map<String, String> toStringMap(Map<String, Object> input, \n            boolean stringEscape) {\n             Map<String, String> output = new HashMap<>(input.size());\n             for (Map.Entry<String, Object> entry : input.entrySet()) {\n              String key = entry.getKey();\n              Object obj = entry.getValue();\n              if (key == null || obj == null) {\n               throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n              }\n              String str;\n\n              if (!(obj instanceof byte[])) {\n               if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                str = geo.getLongitude() + \",\" + geo.getLatitude();\n               } else {\n                if (obj instanceof String) {\n                 if (stringEscape) {\n                  str = escape((String) obj); \n                 } else {\n                  str = (String) obj; } \n                } else {\n                 str = String.valueOf(obj);\n                }\n               }\n              }else {\n               str = SafeEncoder.encode((byte[]) obj);\n              } \n\n              output.put(key, str);\n             }\n\n             return output;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "39", "src_id": "M902", "code": "            @Override\n            public void addParams(CommandArguments args) {\n             if (retentionPeriod != null) {\n              args.add(RETENTION).add(toByteArray(retentionPeriod));\n             }\n             if (encoding != null) {\n              args.add(ENCODING).add(encoding);\n             }\n\n             if (chunkSize != null) {\n              args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n             }\n\n             if (duplicatePolicy != null) {\n              args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n             }\n\n             if (ignore) {\n              args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n             }\n\n             if (labels != null) {\n              args.add(LABELS);\n              labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "40", "src_id": "M1131", "code": "            private static Object process(final RedisInputStream is) {\n             final byte b = is.readByte();\n             // System.out.println(\"BYTE: \" + (char) b);\n             switch (b) {\n              case PLUS_BYTE:\n               return is.readLineBytes();\n              case DOLLAR_BYTE:\n              case EQUAL_BYTE:\n               return processBulkReply(is);\n              case ASTERISK_BYTE:\n               return processMultiBulkReply(is);\n              case UNDERSCORE_BYTE:\n               return is.readNullCrLf();\n              case HASH_BYTE:\n               return is.readBooleanCrLf();\n              case COLON_BYTE:\n               return is.readLongCrLf();\n              case COMMA_BYTE:\n               return is.readDoubleCrLf();\n              case LEFT_BRACE_BYTE:\n               return is.readBigIntegerCrLf();\n              case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n               return processMapKeyValueReply(is);\n              case TILDE_BYTE : // TODO:\n               return processMultiBulkReply(is);\n              case GREATER_THAN_BYTE:\n               return processMultiBulkReply(is);\n              case MINUS_BYTE:\n               processError(is);\n               return null;\n               // TODO: Blob error '!'\n              default:\n               throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "41", "src_id": "M1057", "code": "            @Override\n            public Map.Entry<T, ProfilingInfo> build(Object data) {\n             List list = (List) data;\n             if (list == null || list.isEmpty()) {return null;\n\n             }\n\n             if (list.get(0) instanceof KeyValue) { // RESP3\n              Object resultsData = null, profileData = null;\n              for (KeyValue keyValue : (List<KeyValue>) data) {\n               String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n               switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                 profileData = keyValue.getValue();\n                 break;\n                case RESULTS_STR_REDIS7:\n                 resultsData = data;\n                 break;\n                case RESULTS_STR_REDIS8:\n                 resultsData = keyValue.getValue();\n                 break;\n               }\n              }\n\n              assert resultsData != null : \"Could not detect Results data.\";\n\n              assert profileData != null : \"Could not detect Profile data.\";\n\n              return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n             }\n\n             return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1229", "code": "            public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n             KeyManager[] keyManagers = null;\n             TrustManager[] trustManagers = null;\n\n             if (sslVerifyMode != SslVerifyMode.FULL) {\n              if (sslVerifyMode == SslVerifyMode.CA) {\n               this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n              } else {\n               if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                trustManagers = new TrustManager[] {INSECURE_TRUST_MANAGER };\n               }\n              }\n             }else {\n              this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n             } \n\n             if (keystoreResource != null) {\n              KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n              try (InputStream keystoreStream = keystoreResource.get()) {\n               keyStore.load(keystoreStream, keystorePassword);\n              }\n\n              KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n\n              keyManagerFactory.init(keyStore, keystorePassword);\n\n              keyManagers = keyManagerFactory.getKeyManagers();\n             }\n\n             if (trustManagers == null && truststoreResource != null) {\n              KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n              try (InputStream truststoreStream = truststoreResource.get()) {\n               trustStore.load(truststoreStream, truststorePassword);\n              }\n\n              TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n\n              trustManagerFactory.init(trustStore);\n\n              trustManagers = trustManagerFactory.getTrustManagers();\n             }\n\n             SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n\n             sslContext.init(keyManagers, trustManagers, null);\n             return sslContext;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "43", "src_id": "M894", "code": "            @Override\n            public TSInfo build(Object data) {\n             List<KeyValue> list = (List<KeyValue>) data;\n             Map<String, Object> properties = new HashMap<>();\n\n             Map<String, String> labels = null;\n\n             Map<String, Rule> rules = null;\n\n             List<Map<String, Object>> chunks = null;\n\n             for (KeyValue propertyValue : list) {\n              String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n              Object value = propertyValue.getValue();\n\n              if (!(value instanceof List)) {\n               if (value instanceof byte[]) {\n                value = BuilderFactory.STRING.build(value);\n                if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                 try {\n                  value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                 } catch (Exception e) { }\n                }\n               }\n              } else {\n               switch (prop) {\n                case LABELS_PROPERTY:\n                 labels = BuilderFactory.STRING_MAP.build(value);\n                 value = labels;\n                 break;\n                case RULES_PROPERTY:\n                 List<KeyValue> rulesDataList = (List<KeyValue>) value;\n\n                 Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n\n                 rules = new HashMap<>(rulesDataList.size());\n\n                 for (KeyValue rkv : rulesDataList) {\n                  String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                  List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n\n                  rulesValueMap.put(ruleName, ruleValueList);\n\n                  rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                 }\n\n                 value = rulesValueMap;\n\n                 break;\n                case CHUNKS_PROPERTY:\n                 List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n\n                 List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n\n                 chunks = new ArrayList<>(chunksDataList.size());\n\n                 for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                  Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                  chunksValueList.add(chunk);\n\n                  chunks.add(chunk);\n                 }\n\n                 value = chunksValueList;\n\n                 break;\n                default:\n                 value = SafeEncoder.encodeObject(value);\n                 break;\n               }\n              } \n\n              properties.put(prop, value);\n             }\n\n             return new TSInfo(properties, labels, rules, chunks);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "44", "src_id": "M897", "code": "            @Override\n            public void addParams(CommandArguments args) {\n             if (retentionPeriod != null) {\n              args.add(RETENTION).add(toByteArray(retentionPeriod));\n             }\n             if (encoding != null) {\n              args.add(ENCODING).add(encoding);\n             }\n\n             if (chunkSize != null) {\n              args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n             }\n\n             if (duplicatePolicy != null || duplicatePolicy != null) {\n              args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n             }\n\n             if (onDuplicate != null) {\n              args.add(ON_DUPLICATE).add(onDuplicate);\n             }\n\n             if (ignore) {\n              args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n             }\n\n             if (labels != null) {\n              args.add(LABELS);\n              labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1213", "code": "            @Override\n            public Connection getConnection() {\n             List<ConnectionPool> pools = getShuffledNodesPool();\n             JedisException suppressed = null;\n\n             for (ConnectionPool pool : pools) {\n              Connection jedis = null;\n              try {\n               jedis = pool.getResource();\n               if (jedis == null) {\n                continue;\n               }\n               jedis.ping();\n               return jedis;\n              } catch (JedisException ex) {\n               if (suppressed == null) { // remembering first suppressed exception\n                suppressed = ex;\n               }\n               if (jedis != null) {\n                jedis.close();\n               }\n              }\n             }\n\n             JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n             if (suppressed != null) {\n              noReachableNode.addSuppressed(suppressed);\n             }\n             throw noReachableNode;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "46", "src_id": "M9", "code": "            @Override\n            public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n             lock.lock();\n             try {\n              entry = putIntoStore(cacheKey, entry);\n              EvictionPolicy policy = getEvictionPolicy();\n              policy.touch(cacheKey);\n              CacheKey evictedKey = policy.evictNext();\n              if (evictedKey != null) {\n               delete(evictedKey);\n               stats.evict();\n              }\n\n              for (Object redisKey : cacheKey.getRedisKeys()) {\n               ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n               if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n               } else {\n                Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n\n                redisKeysToCacheKeys.put(mapKey, set);\n               }\n              }\n\n              stats.load();\n\n              return entry;\n             } finally {\n              lock.unlock();\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "47", "src_id": "M1105", "code": "            @Override\n            public Class<?> build(Object data) {\n             if (data == null) {return null;\n             }\n             String str = STRING.build(data);\n\n             switch (str) {\n              case \"null\":\n               return null;\n              case \"boolean\":\n               return boolean.class;\n              case \"integer\":\n               return int.class;\n              case \"number\":\n               return float.class;\n              case \"string\":\n               return String.class;\n              case \"object\":\n               return Object.class;\n              case \"array\":\n               return List.class;\n              default:\n               throw new JedisException(\"Unknown type: \" + str);\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "302", "src_id": "M31", "code": "    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")// .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() != 200) {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n\n        else {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n\n            log.info(\"Validation code: {}\", code);\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n            // Extract user count, default to 1 if not specified\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense =\n            jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } \n        return jsonResponse;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "303", "src_id": "M488", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")@Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description =\n    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "304", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            // Metadata using PDFBox\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode();\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            ObjectNode encryption = objectMapper.createObjectNode();\n            ObjectNode other = objectMapper.createObjectNode();\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n            // Total file size of the PDF\n            long fileSizeInBytes = inputFile.getSize();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n            // Number of words, paragraphs, and images in the entire document\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n\n            int wordCount = words.length;\n\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n\n            // Number of characters in the entire document (including spaces and special characters)\n            int charCount = fullText.length();\n\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            // Initialize the flags and types\n            boolean hasCompression = false;\n\n            String compressionType = \"None\";\n\n            basicInfo.put(\"Compression\", hasCompression);\n            if (hasCompression) {\n                basicInfo.put(\"CompressionType\", compressionType);\n            }\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            String pageMode = catalog.getPageMode().name();\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n            ;\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n            // Generate structured summary data about PDF characteristics\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n            // embeed files TODO size\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n            // attachments TODO size\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n\n                for (PDAnnotation annotation : page.getAnnotations()) {\n\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n            // Javascript\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n                            PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) \n                    {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n            // TODO size\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n\n                    layersArray.add(layerNode);\n                }\n            }\n            other.set(\"Layers\", layersArray); // TODO Security\n\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            ArrayNode structureTreeArray;\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                }\n            } \n            catch (Exception e) \n            {\n                // TODO Auto-generated catch block\n                log.error(\"exception\", e);\n            }\n            boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n            boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n            boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n            boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n            boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n            boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n            // an official ISO standard.\n            boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n            // development in 2021.\n\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            String xmpString = null;\n            if (pdMetadata != null) {\n\n                try {\n\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        DomXmpParser domXmpParser = new DomXmpParser();\n                        XMPMetadata xmpMeta = domXmpParser.parse(is);\n                        ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        new XmpSerializer().serialize(xmpMeta, os, true);\n                        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                    }\n                } catch (XmpParsingException e) \n                {\n                    // XMP parsing failed, try to read raw metadata instead\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) \n                {\n                    log.error(\"exception\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", xmpString);\n            if (!(pdfBoxDoc.isEncrypted())) {\n                encryption.put(\"IsEncrypted\", false);\n            } else {\n                encryption.put(\"IsEncrypted\", true);\n                // Retrieve encryption details using getEncryption()\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n                // Add other encryption-related properties as needed\n            } \n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                // Retrieve the page\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n                // Page-level Information\n                PDRectangle mediaBox = page.getMediaBox();\n\n                float width = mediaBox.getWidth();\n\n                float height = mediaBox.getHeight();\n\n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                // Assuming the following boxes are defined for your document; if not, you may get\n                // null values.\n                PDRectangle cropBox = page.getCropBox();\n                pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n                PDRectangle bleedBox = page.getBleedBox();\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n                PDRectangle trimBox = page.getTrimBox();\n                pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n                PDRectangle artBox = page.getArtBox();\n                pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n                // Content Extraction\n                PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n\n                String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length()); //\n\n                // Annotations\n\n                List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) {\n                        subtypeCount++; // Increase subtype count\n                    }\n                    if (annotation.getContents() != null) {\n                        contentsCount++; // Increase contents count\n                    }\n                }\n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n                // Images (simplified)\n                // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                // Here is a basic structure to recognize image XObjects on a page.\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                PDResources resources = page.getResources();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n                Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri); // Add to set to ensure uniqueness\n                    }\n                }\n                // Add unique URIs to linksArray\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n\n                    linksArray.add(linkNode);\n                }\n                pageInfo.set(\"Links\", linksArray);\n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        // Font stretch and BBox are not directly available in PDFBox's API, so\n                        // these are omitted for simplicity\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n                    // Create a unique key for this font node based on its attributes\n                    String uniqueKey = fontNode.toString();\n                    // Increment count if this font exists, or initialize it if new\n                    if (!(uniqueFontsMap.containsKey(uniqueKey))) { \n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                        continue; \n                    } else { \n                        ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        int count = existingFontNode.get(\"Count\").asInt() + 1;\n                        existingFontNode.put(\"Count\", count);\n                    } \n                }\n                // Add unique font entries to fontsArray\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", fontsArray);\n                // Access resources dictionary\n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n                for (COSName name : colorSpaceNames) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        byte[] iccBytes = iccData.toByteArray();\n                        // TODO: Further decode and analyze the ICC data if needed\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n                // Other XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType;\n                    if (xObject instanceof PDImageXObject) {\n                        xObjectType = \"Image\";\n                    } else {\n                        if (xObject instanceof PDFormXObject) {\n                            xObjectType = \"Form\";\n                        } else {\n                            xObjectType = \"Other\";\n                        }\n                        // Increment the count for this type in the map\n                    }\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                // Add the count map to pageInfo (or wherever you want to store it)\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n                ArrayNode multimediaArray = objectMapper.createArrayNode();\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        ObjectNode multimediaNode = objectMapper.createObjectNode();\n                        // Extract details from the annotation as needed\n                        multimediaArray.add(multimediaNode);\n                    }\n                }\n                pageInfo.set(\"Multimedia\", multimediaArray);\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Encryption\", encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n\n            jsonOutput.set(\"Other\", other);\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n            // Save JSON to file\n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n        } catch (Exception e) \n        {\n            log.error(\"exception\", e);\n        }\n        return null;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "305", "src_id": "M24", "code": "    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n\n            String encryptedData = \"\";\n\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) \n            {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n            // Verify license file algorithm\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n            // Verify signature\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n            log.info(\"License file signature is valid\");\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } \n            catch (IllegalArgumentException e) \n            {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n            // Process the certificate data\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n        } catch (Exception e) \n        {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "306", "src_id": "M403", "code": "    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws IOException {\n\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (!(entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\"))) {\n                            Files.copy(zipIn, filePath);\n                        } else {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } \n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        }// tempUnzippedDir auto-cleaned\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "307", "src_id": "M317", "code": "    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n\n        float pageWidth = page.getMediaBox().getWidth();\n\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n\n            if (\"fillPage\".equals(fitOption) \n            || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else {\n\n                if (\"maintainAspectRatio\".equals(fitOption)) {\n                    float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                    float pageAspectRatio = pageWidth / pageHeight;\n                    float scaleFactor = 1.0f;\n                    if (imageAspectRatio > pageAspectRatio) {\n                        scaleFactor = pageWidth / image.getWidth();\n                    } \n\n                    else {\n                        scaleFactor = pageHeight / image.getHeight();\n                    }\n                    float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                    float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                    contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n                }\n            }\n        } catch (IOException e) \n        {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "308", "src_id": "M307", "code": "    public static String generateMachineFingerprint() {\n\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network != null) {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                }\n            }// Hash the MAC address for privacy and consistency\n            else {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } \n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) \n        {\n            return \"GenericID\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "309", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "310", "src_id": "M128", "code": "    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (!isKubernetes) {\n                if (isDocker) {\n                    return \"Docker\";\n                } else {\n                    if (!isBrowserOpen) {\n                        return \"Server-jar\";\n                    } else {\n                        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                        if (os.contains(\"win\")) {\n                            return \"Client-windows\";\n                        } else {\n                            if (os.contains(\"mac\")) {\n                                return \"Client-mac\";\n                            } else {\n                                return \"Client-unix\";\n                            }\n                        }\n                    } \n                }\n            }else {\n                return \"Kubernetes\";\n            } \n        } catch (Exception e) \n        {\n            return \"Unknown\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "311", "src_id": "M101", "code": "    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "190", "src_id": "M491", "code": "        @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n        @ResizeMode\n        public static int nextResizeModeAndSaveToPrefs(final Player player,\n        @ResizeMode final int resizeMode) {\n            final int newResizeMode;\n            switch (resizeMode) {\n                case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                    newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                    break;\n                case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                    newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                    break;\n                case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n                default:\n                    newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                    break;\n            }\n\n            // save the new resize mode so it can be restored in a future session\n            player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n\n            return newResizeMode;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "191", "src_id": "M424", "code": "        @Override\n        public void onBroadcastReceived(final Intent intent) {\n            super.onBroadcastReceived(intent);\n            if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n                // Close it because when changing orientation from portrait\n                // (in fullscreen mode) the size of queue layout can be larger than the screen size\n                closeItemsList();\n            } else {\n                if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n                    // Ensure that we have audio-only stream playing when a user\n                    // started to play from notification's play button from outside of the app\n                    if (!fragmentIsVisible) {\n                        onFragmentStopped();\n                    }\n                } else {\n                    if (!(VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction()))) {\n                        if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n                            // Restore video source when user returns to the fragment\n                            fragmentIsVisible = true;\n                            player.useVideoSource(true);\n\n                            // When a user returns from background, the system UI will always be shown even if\n                            // controls are invisible: hide it in that case\n                            if (!isControlsVisible()) {\n                                hideSystemUIIfNeeded();\n                            }\n                        }\n                    } else {\n                        fragmentIsVisible = false;\n                        onFragmentStopped();\n                    } \n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "192", "src_id": "M900", "code": "        @StyleRes\n        public static int getSettingsThemeStyle(final Context context) {\n            final Resources res = context.getResources();\n            final String lightTheme = res.getString(R.string.light_theme_key);\n\n            final String blackTheme = res.getString(R.string.black_theme_key);\n\n            final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n            final String selectedTheme = getSelectedThemeKey(context);\n\n            if (selectedTheme.equals(lightTheme)) {\n                return R.style.LightSettingsTheme;\n            } else {\n                if (!(selectedTheme.equals(blackTheme))) {\n                    if (selectedTheme.equals(automaticDeviceTheme)) {\n                        if (isDeviceDarkThemeEnabled(context)) {\n                            // use the dark theme variant preferred by the user\n                            final String selectedNightTheme = getSelectedNightThemeKey(context);\n                            if (selectedNightTheme.equals(blackTheme)) {\n                                return R.style.BlackSettingsTheme;\n                            } else {\n                                return R.style.DarkSettingsTheme;\n                            }\n                        } else {\n                            // there is only one day theme\n                            return R.style.LightSettingsTheme;\n                        }\n                    } else {\n                        // default to dark theme\n                        return R.style.DarkSettingsTheme;\n                    }\n                } else {\n                    return R.style.BlackSettingsTheme;\n                } \n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "193", "src_id": "M895", "code": "        @Override\n        public Bitmap transform(final Bitmap source) {\n            if (DEBUG) {\n                Log.d(TAG, \"Thumbnail - transform() called\");\n            }\n            final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n            final Bitmap result = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth,(int) (source.getHeight()\n            / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n            if (result == source || !result.isMutable()) {\n                // create a new mutable bitmap to prevent strange crashes on some\n                // devices (see #4638)\n                final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth()\n                / (notificationThumbnailWidth - 1))), null, true);\n                source.recycle();\n\n                return copied;\n            } else {\n                source.recycle();\n                return result;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "194", "src_id": "M225", "code": "        private void onBroadcastReceived(final Intent intent) {\n            if (intent == null || intent.getAction() == null) {\n                return;\n            }\n            if (DEBUG) {\n                Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n            }\n\n            switch (intent.getAction()) {\n                case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                    pause();\n                    break;\n                case ACTION_CLOSE:\n                    service.destroyPlayerAndStopService();\n                    break;\n                case ACTION_PLAY_PAUSE:\n                    playPause();\n                    break;\n                case ACTION_PLAY_PREVIOUS:\n                    playPrevious();\n                    break;\n                case ACTION_PLAY_NEXT:\n                    playNext();\n                    break;\n                case ACTION_FAST_REWIND:\n                    fastRewind();\n                    break;\n                case ACTION_FAST_FORWARD:\n                    fastForward();\n                    break;\n                case ACTION_REPEAT:\n                    cycleNextRepeatMode();\n                    break;\n                case ACTION_SHUFFLE:\n                    toggleShuffleModeEnabled();\n                    break;\n                case Intent.ACTION_CONFIGURATION_CHANGED:\n                    if (DEBUG) {\n                        Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                    }\n                    break;\n            }\n\n            UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "195", "src_id": "M749", "code": "        private static void handleError(final Context context, \n        final ErrorInfo errorInfo) {\n            if (errorInfo.getThrowable() != null) {\n                errorInfo.getThrowable().printStackTrace();\n            }\n            if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n                Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n                // Starting ReCaptcha Challenge Activity\n                final Intent intent = new Intent(context, ReCaptchaActivity.class);\n\n                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n                context.startActivity(intent);\n            } else {\n\n                if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n                    Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n                } else {\n\n                    if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n                        Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n                    } else {\n\n                        if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n                            Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n                        } else {\n\n                            if (errorInfo.getThrowable() instanceof PaidContentException) {\n                                Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                            } else {\n\n                                if (errorInfo.getThrowable() instanceof PrivateContentException) {\n                                    Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                                } else {\n\n                                    if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                        Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n                                    } else {\n                                        if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n                                            Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n                                        } else {\n                                            if (!(errorInfo.getThrowable() instanceof ContentNotAvailableException)) {\n                                                if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                                    Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n                                                } else {\n                                                    ErrorUtil.createNotification(context, errorInfo);\n                                                }\n                                            } else {\n                                                Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n                                            } \n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (context instanceof RouterActivity) {\n                ((RouterActivity) context).finish();\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "196", "src_id": "M999", "code": "        public static void openVideoDetailFragment(@NonNull final Context context,\n        @NonNull final FragmentManager fragmentManager,\n        final int serviceId,\n        @Nullable final String url,\n        @NonNull final String title,\n        @Nullable final PlayQueue playQueue,\n        final boolean switchingPlayers) {\n            final boolean autoPlay;\n            @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n\n            if (playerType == null) {\n                // no player open\n                autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n            } else {\n                if (!switchingPlayers) {\n                    if (playerType == PlayerType.MAIN) {\n                        // opening new stream while already playing in main player\n                        autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n                    } else {\n                        // opening new stream while already playing in another player\n                        autoPlay = false;\n                    }\n                } else {\n                    // switching player to main player\n                    autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n                } \n            }\n\n            final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n                expandMainPlayer(detailFragment.requireActivity());\n                detailFragment.setAutoPlay(autoPlay);\n\n                if (switchingPlayers) {\n                    // Situation when user switches from players to main player. All needed data is\n                    // here, we can start watching (assuming newQueue equals playQueue).\n                    // Starting directly in fullscreen if the previous player type was popup.\n                    detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n                } else {\n                    detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n                }\n\n                detailFragment.scrollToTop();\n            };\n\n            final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n\n            if (!(fragment instanceof VideoDetailFragment && fragment.isVisible())) {\n                // Specify no url here, otherwise the VideoDetailFragment will start loading the\n                // stream automatically if it's the first time it is being opened, but then\n                // onVideoDetailFragmentReady will kick in and start another loading process.\n                // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n                final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n                instance.setAutoPlay(autoPlay);\n\n                defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(() -> onVideoDetailFragmentReady.run(instance)).commit();\n            } else {\n                onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n            } \n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "197", "src_id": "M698", "code": "        @Override\n        public void handleResult(@NonNull final ChannelInfo result) {\n            super.handleResult(result);\n            currentInfo = result;\n\n            setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n            if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n                PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n            } else {\n                // do not waste space for the banner, if the user disabled images or there is not one\n                binding.channelBannerImage.setImageDrawable(null);\n            }\n\n            PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n\n            PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n\n            binding.channelTitleView.setText(result.getName());\n\n            binding.channelSubscriberView.setVisibility(View.VISIBLE);\n\n            if (result.getSubscriberCount() >= 0) {\n                binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n            } else {\n                binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n            }\n\n            if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n                binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n                binding.subChannelTitleView.setVisibility(View.VISIBLE);\n\n                binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n            }\n\n            updateRssButton();\n\n            channelContentNotSupported = false;\n\n            for (final Throwable throwable : result.getErrors()) {\n                if (throwable instanceof ContentNotSupportedException) {\n                    channelContentNotSupported = true;\n                    showContentNotSupportedIfNeeded();\n\n                    break;\n                }\n            }\n\n            disposables.clear();\n\n            if (subscribeButtonMonitor != null) {\n                subscribeButtonMonitor.dispose();\n            }\n\n            updateTabs();\n\n            updateSubscription(result);\n\n            monitorSubscription(result);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "198", "src_id": "M379", "code": "        import null;@Override\n        public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n            super.onTextTracksChanged(currentTracks);\n            final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n\n            if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null || !trackTypeTextSupported) {\n                binding.captionTextView.setVisibility(View.GONE);\n                return;\n            }\n\n            // Extract all loaded languages\n            final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType()).collect(Collectors.toList());\n\n            List<Tracks.Group>tmp = textTracks.stream();\n\n            final List<String> availableLanguages = tmp.map(Tracks.Group::getMediaTrackGroup).filter(textTrack -> textTrack.length > 0).map(textTrack -> textTrack.getFormat(0).language).collect(Collectors.toList());\n\n            // Find selected text track\n            final \n            Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info -> info.getMediaTrackGroup().length >= 1).map(info -> info.getMediaTrackGroup().getFormat(0)).findFirst();\n\n            // Build UI\n            buildCaptionMenu(availableLanguages);\n\n            if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n                binding.captionTextView.setText(R.string.caption_none);\n            } else {\n                binding.captionTextView.setText(selectedTracks.get().language);\n            }\n\n            binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "199", "src_id": "M894", "code": "        public static RequestCreator loadScaledDownThumbnail(final Context context,\n        @NonNull final List<Image> images) {\n\n            // scale down the notification thumbnail for performance\n            return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n                @Override\n                public Bitmap transform(final Bitmap source) {\n                    if (DEBUG) {\n                        Log.d(TAG, \"Thumbnail - transform() called\");\n                    }\n                    final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n                    final Bitmap result = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth,(int) (source.getHeight()\n                    / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n                    if (result == source || !result.isMutable()) {\n                        // create a new mutable bitmap to prevent strange crashes on some\n                        // devices (see #4638)\n                        final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth()\n                        / (notificationThumbnailWidth - 1))), null, true);\n                        source.recycle();\n\n                        return copied;\n                    } else {\n                        source.recycle();\n                        return result;\n                    }\n                }\n\n                @Override\n                public String key() {\n                    return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                }\n            });\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "329", "src_id": "M1086", "code": "            public static AdminServer createAdminServer() {\n             if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n              try {\n               Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n               Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n\n               return (AdminServer) adminServer;\n              } catch (ClassNotFoundException e) {\n               LOG.warn(\"Unable to start JettyAdminServer\", e);\n              } catch (InstantiationException e) {\n               LOG.warn(\"Unable to start JettyAdminServer\", e);\n              } catch (IllegalAccessException e) {\n               LOG.warn(\"Unable to start JettyAdminServer\", e);\n              } catch (InvocationTargetException e) {\n               LOG.warn(\"Unable to start JettyAdminServer\", e);\n              } catch (NoSuchMethodException e) {\n               LOG.warn(\"Unable to start JettyAdminServer\", e);\n              } catch (NoClassDefFoundError e) {\n               LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n              }\n             }\n             return new DummyAdminServer();\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "330", "src_id": "M1149", "code": "            public void run() {\n             try {\n              while (!stopped) {\n               try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n               } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n               } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n               }\n              }\n              // Close connections still pending on the selector. Any others\n              // with in-flight work, let drain out of the work queue.\n              for (SelectionKey key : selector.keys()) {\n               NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n               if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n               }\n               cleanupSelectionKey(key);\n              }\n\n              SocketChannel accepted;\n\n              while ((accepted = acceptedQueue.poll()) != null) {\n               fastCloseSock(accepted);\n              }\n              updateQueue.clear();\n             } finally {\n              closeSelector();\n              // This will wake up the accept thread and the other selector\n              // threads, and tell the worker thread pool to begin shutdown.\n              NIOServerCnxnFactory.this.stop();\n              LOG.info(\"selector thread exited run method\");\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "331", "src_id": "M219", "code": "            synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n             final String connectionId = concat(contextPath, session);\n             ZooKeeper zk = zkMap.get(connectionId);\n\n             if (zk == null) {\n              if (LOG.isInfoEnabled()) {\n               LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n              }\n              Endpoint e = contextMap.get(contextPath);\n\n              zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n              for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n               zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n              }\n\n              zkMap.put(connectionId, zk);\n\n              // a session should automatically expire after an amount of time\n              if (session != null) {\n               zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n              }\n             }\n\n             return zk;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "332", "src_id": "M192", "code": "            import null;private void init() throws IOException {\n             File f = new File(file);\n             RandomAccessFileReader in = new RandomAccessFileReader(f);\n             SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n             Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n             long lastFp = in.getPosition();\n             String line = in.readLine();\n             Matcher m = null;\n\n             // if we have read data from the file, and it matches the timep pattern\n             if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n              starttime = timestampFromText(dateformat, m.group(1));\n             } else {\n              throw new IOException(\"Invalid log format. First line doesn't start with time\");\n             }\n             /*\n\t  Count number of log entries. Any line starting with a timestamp counts as an entry\n\t*/\n\n             String lastentry = line;\n\n             try {\n              while (line != null) {\n               m = timep.matcher(line);\n               if (m.lookingAt()) {\n                if (size % skipN == 0) {\n                 long time = timestampFromText(dateformat, m.group(1));\n                 skiplist.addMark(time, lastFp, size);\n                }\n                size++;\n                lastentry = line;\n               } \n\n               Patterntmp = idp.matcher(line);\n\n               if (serverid == 0 && (m = tmp).find()) {\n                serverid = Integer.valueOf(m.group(1));\n               }\n               lastFp = in.getPosition();\n               line = in.readLine();\n              }\n             } catch (EOFException eof) {\n             // ignore, simply end of file, though really (line!=null) should have caught this\n             } finally {\n              in.close();\n             }\n\n             m = timep.matcher(lastentry);\n\n             if (m.lookingAt()) {\n              endtime = timestampFromText(dateformat, m.group(1));\n             } else {\n              throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "333", "src_id": "M235", "code": "            @POST @Produces( {MediaType.APPLICATION_JSON, \"application/javascript\",\n            MediaType.APPLICATION_XML }) public Response createSession(@QueryParam(\"op\") String op,\n            @DefaultValue(\"5\") @QueryParam(\"expire\") String expire,\n            @Context UriInfo ui) {\n             if (!op.equals(\"create\")) {\n              throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\"))\n              .build());\n             }\n             int expireInSeconds;\n\n             try {\n              expireInSeconds = Integer.parseInt(expire);\n             } catch (NumberFormatException e) {\n              throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n             }\n\n             String uuid = UUID.randomUUID().toString();\n\n             while (ZooKeeperService.isConnected(contextPath, uuid)) {\n              uuid = UUID.randomUUID().toString();\n             }\n\n             // establish the connection to the ZooKeeper cluster\n             try {\n              ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n             } catch (IOException e) {\n              LOG.error(\"Failed while trying to create a new session\", e);\n              throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n             }\n\n             URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n\n             return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString())))\n             .build();\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "334", "src_id": "M942", "code": "            public void schedule(WorkRequest workRequest, long id) {\n             if (stopped) {\n              workRequest.cleanup();\n              return;\n             }\n             ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n             // If we have a worker thread pool, use that; otherwise, do the work\n             // directly.\n             int size = workers.size();\n\n             if (size <= 0) {\n              // When there is no worker thread pool, do the work directly\n              // and wait for its completion\n              scheduledWorkRequest.run();\n             }\n             else {\n              try {\n               // make sure to map negative ids as well to [0, size-1]\n               int workerNum = ((int) (id % size) + size) % size;\n               ExecutorService worker = workers.get(workerNum);\n               worker.execute(scheduledWorkRequest);\n              } catch (RejectedExecutionException e) {\n               LOG.warn(\"ExecutorService rejected execution\", e);\n               workRequest.cleanup();\n              }\n             } \n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "335", "src_id": "M520", "code": "            @Override\n            public void close() throws IOException {\n             boolean triedToClose = false, success = false;\n             try {\n              flush();\n              ((FileOutputStream) out).getFD().sync();\n              triedToClose = true;\n              super.close();\n              success = true;\n             } finally {\n              if (success) {\n               boolean renamed = tmpFile.renameTo(origFile);\n               if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n               }\n              } else {\n               if (!triedToClose) {\n                // If we failed when flushing, try to close it to not leak\n                // an FD\n                IOUtils.closeStream(out);\n               }\n               // close wasn't successful, try to delete the tmp file\n               if (!tmpFile.delete()) {\n                LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n               }\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "336", "src_id": "M186", "code": "            synchronized private LogEntry readNextEntry() {\n             try {\n              try {\n               while (true) {\n                String line = in.readLine();\n                if (line == null) {\n                 break;\n                }\n                Matcher m = src.timep.matcher(line);\n\n                if (!(m.lookingAt())) {\n                 if (buf.length() > 0) {\n                  buf += line + \"\\n\";\n                 }\n                } else {\n                 if (buf.length() > 0) {\n                  LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n\n                  buf = line;\n                  return e;\n                 }\n                 buf = line;\n                } \n               }\n              } catch (EOFException eof) {\n              // ignore, we've simply come to the end of the file\n              }\n              if (buf.length() > 0) {\n               LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n\n               buf = \"\";\n               return e;\n              }\n             } catch (Exception e) {\n              LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n              return null;\n             }\n             return null;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "337", "src_id": "M478", "code": "            public static void main(String[] args) {\n             if (args.length < 3) {\n              usage();\n              return;\n             }\n             String host = args[0];\n             int port = Integer.parseInt(args[1]);\n             String op = args[2];\n\n             if (op.equalsIgnoreCase(\"gettracemask\")) {\n              getTraceMask(host, port);\n             } else {\n              if (!(op.equalsIgnoreCase(\"settracemask\"))) {\n               if (op.equalsIgnoreCase(\"ruok\")) {\n                ruok(host, port);\n               } else {\n                if (!(op.equalsIgnoreCase(\"kill\"))) {\n                 if (op.equalsIgnoreCase(\"stat\")) {\n                  stat(host, port);\n                 } else {\n                  if (op.equalsIgnoreCase(\"dump\")) {\n                   dump(host, port);\n                  } else {\n                   System.out.println(\"Unrecognized op: \" + op);\n                  }\n                 }\n                }else {\n                 kill(host, port);\n                } \n               }\n              }else {\n               setTraceMask(host, port, args[3]);\n              } \n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "20", "src_id": "M491", "code": "@SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n@ResizeMode\npublic static int nextResizeModeAndSaveToPrefs(final Player player,@ResizeMode final int resizeMode) {\n     final int newResizeMode;\n     switch (resizeMode) {\n          case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n               newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n               break;\n          case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n               newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n               break;\n          case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n          default:\n               newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n               break;\n     }\n\n     // save the new resize mode so it can be restored in a future session\n     player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n     \n     return newResizeMode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "21", "src_id": "M424", "code": "@Override\npublic void onBroadcastReceived(final Intent intent) {\n     super.onBroadcastReceived(intent);\n     if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n          // Close it because when changing orientation from portrait\n          // (in fullscreen mode) the size of queue layout can be larger than the screen size\n          closeItemsList();\n     } else {\n          if (!(ACTION_PLAY_PAUSE.equals(intent.getAction()))) {\n               if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                    fragmentIsVisible = false;\n                    onFragmentStopped();\n               } else {\n                    if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n                         // Restore video source when user returns to the fragment\n                         fragmentIsVisible = true;\n                         player.useVideoSource(true);\n                         // When a user returns from background, the system UI will always be shown even if\n                         // controls are invisible: hide it in that case\n                         if (!isControlsVisible()) {\n                              hideSystemUIIfNeeded();\n                         }\n                    }\n               }\n          }else {\n               // Ensure that we have audio-only stream playing when a user\n               // started to play from notification's play button from outside of the app\n               if (!fragmentIsVisible) {\n                    onFragmentStopped();\n               }\n          } \n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "22", "src_id": "M900", "code": "@StyleRes\npublic static int getSettingsThemeStyle(final Context context) {\n     final Resources res = context.getResources();\n     \n     final String lightTheme = res.getString(R.string.light_theme_key);\n     \n     final String blackTheme = res.getString(R.string.black_theme_key);\n     \n     final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n     final String selectedTheme = getSelectedThemeKey(context);\n\n     if (!(selectedTheme.equals(lightTheme))) {\n          if (selectedTheme.equals(blackTheme)) {\n               return R.style.BlackSettingsTheme;\n          } else {\n               if (!(selectedTheme.equals(automaticDeviceTheme))) {\n                    // default to dark theme\n                    return R.style.DarkSettingsTheme;\n               } else {\n                    if (!isDeviceDarkThemeEnabled(context)) {\n                         // there is only one day theme\n                         return R.style.LightSettingsTheme;\n                    } else {\n                         // use the dark theme variant preferred by the user\n                         final String selectedNightTheme = getSelectedNightThemeKey(context);\n                         if (selectedNightTheme.equals(blackTheme)) {\n                              return R.style.BlackSettingsTheme;\n                         } else {\n                              return R.style.DarkSettingsTheme;\n                         }\n                    } \n               } \n          }\n     }else {\n          return R.style.LightSettingsTheme;\n     } \n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "23", "src_id": "M895", "code": "@Override\npublic Bitmap transform(final Bitmap source) {\n     if (DEBUG) {\n          Log.d(TAG, \"Thumbnail - transform() called\");\n     }\n     final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n     final Bitmap result = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n     if (!(result == source || !result.isMutable())) {\n          source.recycle();\n          return result;\n     } else {\n          // create a new mutable bitmap to prevent strange crashes on some\n          // devices (see #4638)\n          final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n          source.recycle();\n          \n          return copied;\n     } \n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "24", "src_id": "M225", "code": "private void onBroadcastReceived(final Intent intent) {\n     if (intent == null || intent.getAction() == null) {\n          return;\n     }\n     if (DEBUG) {\n          Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n     }\n\n     switch (intent.getAction()) {\n          case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n               pause();\n               break;\n          case ACTION_CLOSE:\n               service.destroyPlayerAndStopService();\n               break;\n          case ACTION_PLAY_PAUSE:\n               playPause();\n               break;\n          case ACTION_PLAY_PREVIOUS:\n               playPrevious();\n               break;\n          case ACTION_PLAY_NEXT:\n               playNext();\n               break;\n          case ACTION_FAST_REWIND:\n               fastRewind();\n               break;\n          case ACTION_FAST_FORWARD:\n               fastForward();\n               break;\n          case ACTION_REPEAT:\n               cycleNextRepeatMode();\n               break;\n          case ACTION_SHUFFLE:\n               toggleShuffleModeEnabled();\n               break;\n          case Intent.ACTION_CONFIGURATION_CHANGED:\n               if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n               }\n               break;\n     }\n\n     UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "25", "src_id": "M749", "code": "private static void handleError(final Context context, final ErrorInfo errorInfo) {\n     if (errorInfo.getThrowable() != null) {\n          errorInfo.getThrowable().printStackTrace();\n     }\n     if (!(errorInfo.getThrowable() instanceof ReCaptchaException)) {\n          if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n               Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n          } else {\n               if (!(errorInfo.getThrowable() instanceof AgeRestrictedContentException)) {\n                    if (!(errorInfo.getThrowable() instanceof GeographicRestrictionException)) {\n                         if (errorInfo.getThrowable() instanceof PaidContentException) {\n                              Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                         } else {\n                              if (!(errorInfo.getThrowable() instanceof PrivateContentException)) {\n                                   if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                        Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n                                   } else {\n                                        if (!(errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException)) {\n                                             if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n                                                  Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n                                             } else {\n                                                  if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                                       Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n                                                  } else {\n                                                       ErrorUtil.createNotification(context, errorInfo);\n                                                  }\n                                             }\n                                        }else {\n                                             Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n                                        } \n                                   }\n                              }else {\n                                   Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                              } \n                         }\n                    }else {\n                         Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n                    } \n               }else {\n                    Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n               } \n          }\n     }else {\n          Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n          // Starting ReCaptcha Challenge Activity\n          final Intent intent = new Intent(context, ReCaptchaActivity.class);\n          \n          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n          \n          context.startActivity(intent);\n     } \n\n     if (context instanceof RouterActivity) {\n          ((RouterActivity)context).finish();\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "26", "src_id": "M999", "code": "public static void openVideoDetailFragment(@NonNull final Context context,@NonNull final FragmentManager fragmentManager, final int serviceId,@Nullable final String url,@NonNull final String title,@Nullable final PlayQueue playQueue, final boolean switchingPlayers) {\n     final boolean autoPlay;\n     \n     @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n     \n     if (playerType != null) {\n          if (switchingPlayers) {\n               // switching player to main player\n               autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n          } else {\n               if (playerType == PlayerType.MAIN) {\n                    // opening new stream while already playing in main player\n                    autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n               } else {\n                    // opening new stream while already playing in another player\n                    autoPlay = false;\n               }\n          }\n     }else {\n          // no player open\n          autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n     } \n\n     final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n          expandMainPlayer(detailFragment.requireActivity());\n          \n          detailFragment.setAutoPlay(autoPlay);\n          \n          if (!switchingPlayers) {\n               detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n          } else {\n               // Situation when user switches from players to main player. All needed data is\n               // here, we can start watching (assuming newQueue equals playQueue).\n               // Starting directly in fullscreen if the previous player type was popup.\n               detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n          } \n\n          detailFragment.scrollToTop();\n     };\n\n     final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n     \n     if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n          onVideoDetailFragmentReady.run((VideoDetailFragment)fragment);\n     } else {\n          // Specify no url here, otherwise the VideoDetailFragment will start loading the\n          // stream automatically if it's the first time it is being opened, but then\n          // onVideoDetailFragmentReady will kick in and start another loading process.\n          // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n          final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n          \n          instance.setAutoPlay(autoPlay);\n\n          defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(() -> onVideoDetailFragmentReady.run(instance)).commit();\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "27", "src_id": "M698", "code": "@Override\npublic void handleResult(@NonNull final ChannelInfo result) {\n     super.handleResult(result);\n     currentInfo = result;\n     \n     setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n     if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n          PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n     } else {\n          // do not waste space for the banner, if the user disabled images or there is not one\n          binding.channelBannerImage.setImageDrawable(null);\n     }\n\n     PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n     \n     PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n\n     binding.channelTitleView.setText(result.getName());\n     \n     binding.channelSubscriberView.setVisibility(View.VISIBLE);\n     \n     if (result.getSubscriberCount() < 0) {\n          binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n     } else {\n          binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n     } \n\n     if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n          binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n          binding.subChannelTitleView.setVisibility(View.VISIBLE);\n          \n          binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n     }\n\n     updateRssButton();\n\n     channelContentNotSupported = false;\n     \n     for (final Throwable throwable : result.getErrors()) {\n          if (throwable instanceof ContentNotSupportedException) {\n               channelContentNotSupported = true;\n               showContentNotSupportedIfNeeded();\n               break;\n          }\n     }\n\n     disposables.clear();\n     \n     if (subscribeButtonMonitor != null) {\n          subscribeButtonMonitor.dispose();\n     }\n     updateTabs();\n     updateSubscription(result);\n     monitorSubscription(result);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "28", "src_id": "M379", "code": "@Override\npublic void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n     super.onTextTracksChanged(currentTracks);\n     final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n     \n     if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null || !trackTypeTextSupported) {\n          binding.captionTextView.setVisibility(View.GONE);\n          return;\n     }\n\n     // Extract all loaded languages\n     final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType()).collect(Collectors.toList());\n     \n     final List<String> availableLanguages = textTracks.stream().map(Tracks.Group::getMediaTrackGroup).filter(textTrack -> textTrack.length > 0).map(textTrack -> textTrack.getFormat(0).language).collect(Collectors.toList());\n\n     // Find selected text track\n     final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info -> info.getMediaTrackGroup().length >= 1).map(info -> info.getMediaTrackGroup().getFormat(0)).findFirst();\n\n     // Build UI\n     buildCaptionMenu(availableLanguages);\n     \n     if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n          binding.captionTextView.setText(R.string.caption_none);\n     } else {\n          binding.captionTextView.setText(selectedTracks.get().language);\n     }\n     \n     binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "29", "src_id": "M894", "code": "public static RequestCreator loadScaledDownThumbnail(final Context context,@NonNull final List<Image> images) {\n     // scale down the notification thumbnail for performance\n     return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n          @Override\n          public Bitmap transform(final Bitmap source) {\n               if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n               }\n               final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n               final Bitmap result = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n               if (!(result == source || !result.isMutable())) {\n                    source.recycle();\n                    return result;\n               } else {\n                    // create a new mutable bitmap to prevent strange crashes on some\n                    // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int)notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n                    source.recycle();\n                    \n                    return copied;\n               } \n          }\n\n          @Override\n          public String key() {\n               return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n          }});\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "48", "src_id": "M270", "code": "        private static String normalizeArch(String value) {\n            value = normalize(value);\n            if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n                return \"x86_64\";\n            }\n\n            if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n                return \"x86_32\";\n            }\n\n            if (value.matches(\"^(ia64w?|itanium64)$\")) {\n                return \"itanium_64\";\n            }\n\n            if (\"ia64n\".equals(value)) {\n                return \"itanium_32\";\n            }\n\n            if (value.matches(\"^(sparc|sparc32)$\")) {\n                return \"sparc_32\";\n            }\n\n            if (value.matches(\"^(sparcv9|sparc64)$\")) {\n                return \"sparc_64\";\n            }\n\n            if (value.matches(\"^(arm|arm32)$\")) {\n                return \"arm_32\";\n            }\n\n            if (\"aarch64\".equals(value)) {\n                return \"aarch_64\";\n            }\n\n            if (value.matches(\"^(mips|mips32)$\")) {\n                return \"mips_32\";\n            }\n\n            if (value.matches(\"^(mipsel|mips32el)$\")) {\n                return \"mipsel_32\";\n            }\n\n            if (\"mips64\".equals(value)) {\n                return \"mips_64\";\n            }\n\n            if (\"mips64el\".equals(value)) {\n                return \"mipsel_64\";\n            }\n\n            if (value.matches(\"^(ppc|ppc32)$\")) {\n                return \"ppc_32\";\n            }\n\n            if (value.matches(\"^(ppcle|ppc32le)$\")) {\n                return \"ppcle_32\";\n            }\n\n            if (\"ppc64\".equals(value)) {\n                return \"ppc_64\";\n            }\n\n            if (\"ppc64le\".equals(value)) {\n                return \"ppcle_64\";\n            }\n\n            if (\"s390\".equals(value)) {\n                return \"s390_32\";\n            }\n\n            if (\"s390x\".equals(value)) {\n                return \"s390_64\";\n            }\n\n            return value;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "49", "src_id": "M928", "code": "        private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n            Map<String, Object> info = new HashMap<String, Object>();\n            info.put(LoggerHelper.name, logger.getName());\n\n            info.put(LoggerHelper.clazz, logger.getClass());\n\n            CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n\n            if (codeSource != null) {\n                info.put(LoggerHelper.codeSource, codeSource.getLocation());\n            }\n\n            info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n            Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n\n            if (level != null) {\n                info.put(LoggerHelper.level, level.toString());\n            }\n\n            if (effectiveLevel != null) {\n                info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n\n            info.put(LoggerHelper.appenders, result);\n\n            return info;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "50", "src_id": "M9", "code": "        @SuppressWarnings(\"resource\")\n        public static long select(boolean v, \n        long telnetPortPid, \n        String select)throws InputMismatchException {\n            Map<Long, String> processMap = listProcessByJps(v);\n            // Put the port that is already listening at the first\n            if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n                String telnetPortProcess = processMap.get(telnetPortPid);\n                processMap.remove(telnetPortPid);\n\n                Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n\n                newProcessMap.put(telnetPortPid, telnetPortProcess);\n\n                newProcessMap.putAll(processMap);\n\n                processMap = newProcessMap;\n            }\n\n            if (processMap.isEmpty()) {\n                AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n                return -1;\n            }\n\n            // select target process by the '--select' option when match only one process\n            if (select != null && !select.trim().isEmpty()) {\n                int matchedSelectCount = 0;\n                Long matchedPid = null;\n\n                for (Entry<Long, String> entry : processMap.entrySet()) {\n                    if (entry.getValue().contains(select)) {\n                        matchedSelectCount++;\n                        matchedPid = entry.getKey();\n                    }\n                }\n\n                if (matchedSelectCount == 1) {\n                    return matchedPid;\n                }\n            }\n\n            AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n\n            // print list\n            int count = 1;\n\n            for (String process : processMap.values()) {\n                if (count == 1) {\n                    System.out.println(\"* [\" + count + \"]: \" + process);\n                } else {\n                    System.out.println(\"  [\" + count + \"]: \" + process);\n                }\n                count++;\n            }\n\n            // read choice\n            String line = new Scanner(System.in).nextLine();\n\n            if (line.trim().isEmpty()) {\n                // get the first process id\n                return processMap.keySet().iterator().next();\n            }\n\n            int choice = new Scanner(line).nextInt();\n\n            if (choice <= 0 || choice > processMap.size()) {\n                return -1;\n            }\n\n            Iterator<Long> idIter = processMap.keySet().iterator();\n\n            for (int i = 1; i <= choice; ++i) {\n                if (i == choice) {\n                    return idIter.next();\n                }\n                idIter.next();\n            }\n\n            return -1;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "51", "src_id": "M140", "code": "        void _processDo(int option)throws IOException{\n            if (debugoptions) {\n                System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n            }\n            if (__notifhand != null) {\n                __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n            }\n\n            boolean acceptNewState = false;\n            /* open TelnetOptionHandler functionality (start)*/\n\n            if (optionHandlers[option] == null) {/* open TelnetOptionHandler functionality (end)*//* TERMINAL-TYPE option (start)*/\n                if (option == TERMINAL_TYPE && ((terminalType != null) && (terminalType.length() > 0))) {\n                    acceptNewState = true;\n                }\n            }/* open TelnetOptionHandler functionality (end)*/else {\n                acceptNewState = optionHandlers[option].getAcceptLocal();\n            }\n\n            if (_willResponse[option] > 0) {\n                _willResponse[option]--; \n                if (_willResponse[option] > 0 && _stateIsWill(option)) {\n                    _willResponse[option]--; \n                }\n            }\n\n            if (_willResponse[option] == 0) {\n                if (_requestedWont(option)) {\n                    switch (option)\n                    {\n                        default:\n                            break;\n\n                    }\n                    if (acceptNewState) {\n                        _setWantWill(option);\n                        _sendWill(option);\n                    } else {\n                        _willResponse[option]++; \n                        _sendWont(option);\n                    }\n                } else {// Other end has acknowledged option.\n\n                    switch (option)\n                    {\n                        default:\n                            break;\n\n                    }\n                }\n            }\n\n            _setWill(option);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "52", "src_id": "M1324", "code": "        private void bind(Configure configure)throws Throwable {\n            long start = System.currentTimeMillis();\n            if (!isBindRef.compareAndSet(false, true)) {\n                throw new IllegalStateException(\"already bind\");\n            }\n\n            // init random port\n            if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n                int newTelnetPort = SocketUtils.findAvailableTcpPort();\n                configure.setTelnetPort(newTelnetPort);\n\n                logger().info(\"generate random telnet port: \" + newTelnetPort);\n            }\n\n            if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n                int newHttpPort = SocketUtils.findAvailableTcpPort();\n                configure.setHttpPort(newHttpPort);\n\n                logger().info(\"generate random http port: \" + newHttpPort);\n            }\n\n            // try to find appName\n            if (configure.getAppName() == null) {\n                configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n            }\n\n            try {\n                if (configure.getTunnelServer() != null) {\n                    tunnelClient = new TunnelClient();\n                    tunnelClient.setAppName(configure.getAppName());\n\n                    tunnelClient.setId(configure.getAgentId());\n\n                    tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n\n                    tunnelClient.setVersion(ArthasBanner.version());\n\n                    ChannelFuture channelFuture = tunnelClient.start();\n\n                    channelFuture.await(10, TimeUnit.SECONDS);\n                }\n            } catch (Throwable t) {\n                logger().error(\"start tunnel client error\", t);\n            }\n\n            try {\n                ShellServerOptions options = new ShellServerOptions().setInstrumentation(instrumentation).setPid(PidUtils.currentLongPid()).setWelcomeMessage(ArthasBanner.welcome());\n                if (configure.getSessionTimeout() != null) {\n                    options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n                }\n\n                this.httpSessionManager = new HttpSessionManager();\n\n                if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n                    // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n                    String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \" + \"No password is currently configured. \" + \"Therefore, a default password is generated, \" + \"and clients need to use the password to connect!\";\n                    AnsiLog.error(errorMsg);\n\n                    configure.setPassword(StringUtils.randomString(64));\n\n                    AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n\n                    logger().error(errorMsg);\n\n                    logger().info(\"Generated arthas password: \" + configure.getPassword());\n                }\n\n                this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n\n                shellServer = new ShellServerImpl(options);\n\n                List<String> disabledCommands = new ArrayList<String>();\n\n                if (configure.getDisabledCommands() != null) {\n                    String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n                    if (strings != null) {\n                        disabledCommands.addAll(Arrays.asList(strings));\n                    }\n                }\n\n                BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n\n                List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n\n                resolvers.add(builtinCommands);\n\n                //worker group\n                workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n                // TODO: discover user provided command resolver\n                if (configure.getTelnetPort() != null && configure.getTelnetPort() > 0) {\n                    logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n                    shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n                } else {\n                    logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n                }\n\n                if (!(configure.getHttpPort() != null && configure.getHttpPort() > 0)) {\n                    // listen local address in VM communication\n                    if (configure.getTunnelServer() != null) {\n                        shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n                    }\n                    logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n                } else {\n                    logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n                    shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n                } \n\n                for (CommandResolver resolver : resolvers) {\n                    shellServer.registerCommandResolver(resolver);\n                }\n\n                shellServer.listen(new BindHandler(isBindRef));\n\n                if (!isBind()) {\n                    throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" + String.valueOf(configure.getTelnetPort()) + \", http port: \" + String.valueOf(configure.getHttpPort()));\n                }\n\n                //http api session manager\n                sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n\n                //http api handler\n                httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n\n                logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n                // 异步回报启动次数\n                if (configure.getStatUrl() != null) {\n                    logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n                }\n\n                UserStatUtil.setStatUrl(configure.getStatUrl());\n\n                UserStatUtil.setAgentId(configure.getAgentId());\n\n                UserStatUtil.arthasStart();\n\n                try {\n                    SpyAPI.init();\n                } catch (Throwable e) {\n                // ignore\n                }\n\n                logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n            } catch (Throwable e) {\n                logger().error(\"Error during start as-server\", e);\n                destroy();\n\n                throw e;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "53", "src_id": "M122", "code": "        private int __read(boolean mayBlock)throws IOException{\n            int ch;\n            for (;;) {\n                // If there is no more data AND we were told not to block,\n                // just return WOULD_BLOCK (-2). (More efficient than exception.)\n                if (!mayBlock && super.available() == 0) {\n                    return WOULD_BLOCK;\n                }\n                // Otherwise, exit only when we reach end of stream.\n                if ((ch = super.read()) < 0) {\n                    return EOF;\n                }\n\n                ch = (ch & 0xff);\n                /* Code Section added for supporting AYT (start)*/\n\n                synchronized (__client)\n                {\n                    __client._processAYTResponse();\n                }/* Code Section added for supporting AYT (end)*/\n                /* Code Section added for supporting spystreams (start)*/\n\n                __client._spyRead(ch);/* Code Section added for supporting spystreams (end)*/\n\n                switch (__receiveState) {\n                    case _STATE_CR:\n                        if (ch == '\\0') {\n                            // Strip null\n                            continue;\n                        }// How do we handle newline after cr?\n                        //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n                        // Handle as normal data by falling through to _STATE_DATA case\n\n                        //$FALL-THROUGH$\n                    case _STATE_DATA:\n                        if (ch == TelnetCommand.IAC) {\n                            __receiveState = _STATE_IAC;\n                            continue;\n                        }\n                        if (ch == '\\r') {\n                            synchronized (__client)\n                            {\n                                if (__client._requestedDont(TelnetOption.BINARY)) {\n                                    __receiveState = _STATE_CR;\n                                } else {\n                                    __receiveState = _STATE_DATA;\n                                }\n                            }\n                        } else {\n                            __receiveState = _STATE_DATA;\n                        }\n\n                        break;\n                    case _STATE_IAC:\n                        switch (ch) {\n                            case TelnetCommand.WILL:\n                                __receiveState = _STATE_WILL;\n                                continue;\n                            case TelnetCommand.WONT:\n                                __receiveState = _STATE_WONT;\n                                continue;\n                            case TelnetCommand.DO:\n                                __receiveState = _STATE_DO;\n                                continue;\n                            case TelnetCommand.DONT:\n                                __receiveState = _STATE_DONT;\n                                continue;/* TERMINAL-TYPE option (start)*/\n                            case TelnetCommand.SB:\n                                __suboption_count = 0;\n                                __receiveState = _STATE_SB;\n                                continue;/* TERMINAL-TYPE option (end)*/\n                            case TelnetCommand.IAC:\n                                __receiveState = _STATE_DATA;\n                                break; // exit to enclosing switch to return IAC from read\n                            case TelnetCommand.SE : // unexpected byte! ignore it (don't send it as a command)\n                                __receiveState = _STATE_DATA;\n                                continue;\n                            default:\n                                __receiveState = _STATE_DATA;\n                                __client._processCommand(ch); // Notify the user\n\n                                continue; // move on the next char\n                        }\n                        break; // exit and return from read\n                    case _STATE_WILL:\n                        synchronized (__client)\n                        {\n                            __client._processWill(ch);\n                            __client._flushOutputStream();\n                        }\n                        __receiveState = _STATE_DATA;\n\n                        continue;\n                    case _STATE_WONT:\n                        synchronized (__client)\n                        {\n                            __client._processWont(ch);\n                            __client._flushOutputStream();\n                        }\n                        __receiveState = _STATE_DATA;\n\n                        continue;\n                    case _STATE_DO:\n                        synchronized (__client)\n                        {\n                            __client._processDo(ch);\n                            __client._flushOutputStream();\n                        }\n                        __receiveState = _STATE_DATA;\n\n                        continue;\n                    case _STATE_DONT:\n                        synchronized (__client)\n                        {\n                            __client._processDont(ch);\n                            __client._flushOutputStream();\n                        }\n                        __receiveState = _STATE_DATA;\n\n                        continue;/* TERMINAL-TYPE option (start)*/\n                    case _STATE_SB:\n                        switch (ch) {\n                            case TelnetCommand.IAC:\n                                __receiveState = _STATE_IAC_SB;\n                                continue;\n                            default:\n                                // store suboption char\n                                if (__suboption_count < __suboption.length) {\n                                    __suboption[__suboption_count++] = ch;\n                                }\n                                break;\n                        }\n                        __receiveState = _STATE_SB;\n\n                        continue;\n                    case _STATE_IAC_SB : // IAC received during SB phase\n                        switch (ch) {\n                            case TelnetCommand.SE:\n                                synchronized (__client)\n                                {\n                                    __client._processSuboption(__suboption, __suboption_count);\n                                    __client._flushOutputStream();\n                                }\n                                __receiveState = _STATE_DATA;\n\n                                continue;\n                            case TelnetCommand.IAC : // De-dup the duplicated IAC\n                                if (__suboption_count < __suboption.length) {\n                                    __suboption[__suboption_count++] = ch;\n                                }\n                                break;\n                            default :            // unexpected byte! ignore it\n                                break;\n                        }\n                        __receiveState = _STATE_SB;\n\n                        continue;/* TERMINAL-TYPE option (end)*/\n                }\n\n                break;\n            }\n\n            return ch;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "54", "src_id": "M8", "code": "        private static String formatFileSize(long size) {\n            String hrSize;\n            double b = size;\n            double k = size / 1024.0;\n\n            double m = ((size / 1024.0) / 1024.0);\n\n            double g = (((size / 1024.0) / 1024.0) / 1024.0);\n\n            double t = ((((size / 1024.0) / 1024.0) / 1024.0) / 1024.0);\n\n            DecimalFormat dec = new DecimalFormat(\"0.00\");\n\n            if (t > 1) {\n                hrSize = dec.format(t).concat(\" TB\");\n            } else {\n                if (g > 1) {\n                    hrSize = dec.format(g).concat(\" GB\");\n                } else {\n                    if (m <= 1) {\n                        if (k > 1) {\n                            hrSize = dec.format(k).concat(\" KB\");\n                        } else {\n                            hrSize = dec.format(b).concat(\" Bytes\");\n                        }\n                    } else {\n                        hrSize = dec.format(m).concat(\" MB\");\n                    } \n                }\n            }\n\n            return hrSize;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "55", "src_id": "M790", "code": "        @Override\n        public byte[] transform(ClassLoader loader, \n        String className, \n        Class<?> classBeingRedefined,\n        ProtectionDomain protectionDomain, \n        byte[] classfileBuffer)throws IllegalClassFormatException {\n            if (className == null) {\n                return null;\n            }\n            className = className.replace('/', '.');\n\n            List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n\n            // 倒序，因为要执行的配置生效\n            ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n\n            while (listIterator.hasPrevious()) {\n                RetransformEntry retransformEntry = listIterator.previous();\n                int id = retransformEntry.getId();\n\n                // 判断类名是否一致\n                boolean updateFlag = false;\n\n                // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n                if (className.equals(retransformEntry.getClassName())) {\n                    if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) {\n                        updateFlag = isLoaderMatch(retransformEntry, loader);\n                    } else {\n                        updateFlag = true;\n                    }\n                }\n\n                if (updateFlag) {\n                    logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n                    retransformEntry.incTransformCount();\n\n                    return retransformEntry.getBytes();\n                }\n            }\n\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "56", "src_id": "M716", "code": "        public static void drawPlayException(TableElement table, \n        ObjectVO throwableVO) {\n            // 执行失败:输出失败状态\n            table.row(\"IS-RETURN\", \"\" + false);\n            table.row(\"IS-EXCEPTION\", \"\" + true);\n\n            // 执行失败:输出失败异常信息\n            Throwable cause;\n\n            Throwable t = (Throwable) throwableVO.getObject();\n\n            if (t instanceof InvocationTargetException) {\n                cause = t.getCause();\n            } else {\n                cause = t;\n            }\n\n            if (!(throwableVO.needExpand())) {\n                StringWriter stringWriter = new StringWriter();\n                PrintWriter printWriter = new PrintWriter(stringWriter);\n\n                try {\n                    cause.printStackTrace(printWriter);\n                    table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n                } finally {\n                    printWriter.close();\n                }\n            } else {\n                table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n            } \n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "57", "src_id": "M602", "code": "        private AsyncProfiler profilerInstance() {\n            if (profiler != null) {\n                return profiler;\n            }\n            // try to load from special path\n            if (ProfilerAction.load.toString().equals(action)) {\n                profiler = AsyncProfiler.getInstance(this.actionArg);\n            }\n\n            if (libPath != null) {\n                // load from arthas directory\n                // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n                FileOutputStream tmpLibOutputStream = null;\n                FileInputStream libInputStream = null;\n\n                try {\n                    File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n                    tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n\n                    libInputStream = new FileInputStream(libPath);\n\n                    IOUtils.copy(libInputStream, tmpLibOutputStream);\n\n                    libPath = tmpLibFile.getAbsolutePath();\n\n                    logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n                } catch (Throwable e) {\n                    logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n                } finally {\n                    IOUtils.close(libInputStream);\n                    IOUtils.close(tmpLibOutputStream);\n                }\n\n                profiler = AsyncProfiler.getInstance(libPath);\n            } else {\n                if (OSUtils.isLinux() || OSUtils.isMac()) {\n                    throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n                } else {\n                    throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n                }\n            }\n\n            return profiler;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1043", "code": "        private void doPostprocessing() {\n            errCode = ERROR_NOTHING;\n            errObject = null;\n\n            Thread thread = Thread.currentThread();\n\n            notifyPostProcessing(1);\n\n            if (DEBUG) {\n                thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n            }\n\n            Exception exception = null;\n\n            try {\n                psAlgorithm.run(this);\n            } catch (Exception err) {\n                Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n                if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                    notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                    return;\n                }\n\n                if (errCode == ERROR_NOTHING) {\n                    errCode = ERROR_POSTPROCESSING;\n                }\n\n                exception = err;\n            } finally {\n                notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n            }\n\n            if (errCode != ERROR_NOTHING) {\n                if (exception == null) {\n                    exception = errObject;\n                }\n                notifyError(ERROR_POSTPROCESSING, exception);\n\n                return;\n            }\n\n            notifyFinished();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1031", "code": "        void establishConnection(int threadId, \n        HttpURLConnection conn)throws IOException, HttpError {\n            int statusCode = conn.getResponseCode();\n            if (DEBUG) {\n                Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n                Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n\n                Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n\n                Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n            }\n\n            switch (statusCode) {\n                case 204:\n                case 205:\n                case 207:\n                    throw new HttpError(statusCode);\n                case 416:\n                    return;// let the download thread handle this error\n                default:\n                    if (statusCode < 200 || statusCode > 299) {\n                        throw new HttpError(statusCode);\n                    }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "202", "src_id": "M827", "code": "        private Elst parseEdts(final Box ref)throws IOException {\n            final Box b = untilBox(ref, ATOM_ELST);\n            if (b == null) {\n                return null;\n            }\n\n            final Elst obj = new Elst();\n\n            final boolean v1 = stream.read() == 1;\n\n            stream.skipBytes(3); // flags\n\n            final int entryCount = stream.readInt();\n\n            if (entryCount < 1) {\n                obj.bMediaRate = 0x00010000; // default media rate (1.0)\n                return obj;\n            }\n\n            if (v1) {\n                stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n                obj.mediaTime = stream.readLong();\n\n                // ignore all remain entries\n                stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n            } else {\n                stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n                obj.mediaTime = stream.readInt();\n            }\n\n            obj.bMediaRate = stream.readInt();\n\n            return obj;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "203", "src_id": "M1048", "code": "        @Override\n        public void run() {\n            boolean done;\n            long start = mMission.fallbackResumeOffset;\n\n            if (DEBUG && !mMission.unknownLength && start > 0) {\n                Log.i(TAG, \"Resuming a single-thread download at \" + start);\n            }\n\n            try {\n                long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n                int mId = 1;\n\n                mConn = mMission.openConnection(false, rangeStart, -1);\n\n                if (mRetryCount == 0 && rangeStart == -1) {\n                    // workaround: bypass android connection pool\n                    mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n                }\n\n                mMission.establishConnection(mId, mConn);\n\n                // check if the download can be resumed\n                if (mConn.getResponseCode() == 416 && start > 0) {\n                    mMission.notifyProgress(-start);\n                    start = 0;\n\n                    mRetryCount--;\n\n                    throw new DownloadMission.HttpError(416);\n                }\n\n                // secondary check for the file length\n                if (!mMission.unknownLength)\n                {\n                    mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n                }\n\n                if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                    // restart amount of bytes downloaded\n                    mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n                }\n\n                mF = mMission.storage.getStream();\n\n                mF.seek(mMission.offsets[mMission.current] + start);\n\n                mIs = mConn.getInputStream();\n\n                byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n\n                int len = 0;\n\n                while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                    mF.write(buf, 0, len);\n                    start += len;\n\n                    mMission.notifyProgress(len);\n                }\n\n                dispose();\n\n                // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n                done = len == -1;\n            } catch (Exception e) {\n                dispose();\n                mMission.fallbackResumeOffset = start;\n\n                if (!mMission.running || e instanceof ClosedByInterruptException) {\n                    return;\n                }\n\n                if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                    // for youtube streams. The url has expired, recover\n                    dispose();\n                    mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                    return;\n                }\n\n                if (mRetryCount++ >= mMission.maxRetry) {\n                    mMission.notifyError(e);\n                    return;\n                }\n\n                if (DEBUG) {\n                    Log.e(TAG, \"got exception, retrying...\", e);\n                }\n\n                run();// try again\n\n                return;\n            }\n\n            if (done) {\n                mMission.notifyFinished();\n            } else {\n                mMission.fallbackResumeOffset = start;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "204", "src_id": "M1141", "code": "        private void flushAuxiliar(long amount)throws IOException {\n            if (aux.length < 1) {\n                return;\n            }\n            out.flush();\n            aux.flush();\n\n            boolean underflow = aux.offset < aux.length || out.offset < out.length;\n\n            byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n            aux.target.seek(0);\n\n            out.target.seek(out.length);\n\n            long length = amount;\n\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                if (read < 1) {\n                    amount -= length;\n                    break;\n                }\n\n                out.writeProof(buffer, read);\n\n                length -= read;\n            }\n\n            if (underflow) {\n                if (out.offset >= out.length) {\n                    // calculate the aux underflow pointer\n                    if (aux.offset < amount) {\n                        out.offset += aux.offset;\n                        aux.offset = 0;\n\n                        out.target.seek(out.offset);\n                    } else {\n                        aux.offset -= amount;\n                        out.offset = out.length + amount;\n                    }\n                } else {\n                    aux.offset = 0;\n                }\n            } else {\n                out.offset += amount;\n                aux.offset -= amount;\n            }\n\n            out.length += amount;\n\n            if (out.length > maxLengthKnown) {\n                maxLengthKnown = out.length;\n            }\n\n            if (amount < aux.length) {\n                // move the excess data to the beginning of the file\n                long readOffset = amount;\n                long writeOffset = 0;\n\n                aux.length -= amount;\n\n                length = aux.length;\n\n                while (length > 0) {\n                    int read = (int) Math.min(length, Integer.MAX_VALUE);\n                    read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                    aux.target.seek(writeOffset);\n\n                    aux.writeProof(buffer, read);\n\n                    writeOffset += read;\n\n                    readOffset += read;\n                    length -= read;\n\n                    aux.target.seek(readOffset);\n                }\n\n                aux.target.setLength(aux.length);\n\n                return;\n            }\n\n            if (aux.length > THRESHOLD_AUX_LENGTH) {\n                aux.target.setLength(THRESHOLD_AUX_LENGTH);// or setLength(0);\n            }\n\n            aux.reset();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "205", "src_id": "M1106", "code": "        private void showError(DownloadMission mission, \n        UserAction action, \n        @StringRes int reason) {\n            StringBuilder request = new StringBuilder(256);\n            request.append(mission.source);\n\n            request.append(\" [\");\n\n            if (mission.recoveryInfo != null) {\n                for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n                {\n                    request.append(' ').append(recovery.toString()).append(' ');\n                }\n            }\n\n            request.append(\"]\");\n\n            String service;\n\n            try {\n                service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n            } catch (Exception e) {\n                service = ErrorInfo.SERVICE_NONE;\n            }\n\n            ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "206", "src_id": "M1067", "code": "        void startMission(DownloadMission mission) {\n\n            synchronized (this) {\n                mission.timestamp = System.currentTimeMillis();\n                mission.mHandler = mHandler;\n\n                mission.maxRetry = mPrefMaxRetry;\n\n                // create metadata file\n                for (;;) {\n                    mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                    if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                        try {\n                            if (!mission.metadata.createNewFile())\n                            {\n                                throw new RuntimeException(\"Cant create download metadata file\");\n                            }\n                        } catch (IOException e) {\n                            throw new RuntimeException(e);\n                        }\n                        break;\n                    }\n\n                    mission.timestamp = System.currentTimeMillis();\n                }\n\n                mSelfMissionsControl = true;\n\n                mMissionsPending.add(mission);\n\n                // Before continue, save the metadata in case the internet connection is not available\n                Utility.writeToFile(mission.metadata, mission);\n\n                if (mission.storage == null) {\n                    // noting to do here\n                    mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                    if (mission.errObject != null)\n                    {\n                        mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                    }\n\n                    return;\n                }\n\n                boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n                if (canDownloadInCurrentNetwork() && start) {\n                    mission.start();\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "207", "src_id": "M1136", "code": "        @Override int process(SharpStream out, \n        SharpStream... sources)throws IOException {\n            // check if the subtitle is already in srt and copy, this should never happen\n            String format = getArgumentAt(0, null);\n            boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n            if (format == null || format.equals(\"ttml\")) {\n                SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n                try {\n                    writer.build(sources[0]);\n                } catch (Exception err) {\n                    Log.e(TAG, \"subtitle parse failed\", err);\n                    return err instanceof IOException ? 1 : 8;\n                }\n\n                return OK_RESULT;\n            } else {\n                if (format.equals(\"srt\")) {\n                    byte[] buffer = new byte[8 * 1024];\n                    int read;\n\n                    while ((read = sources[0].read(buffer)) > 0) {\n                        out.write(buffer, 0, read);\n                    }\n\n                    return OK_RESULT;\n                }\n            }\n\n            throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "208", "src_id": "M1047", "code": "        private void joinForThreads(int millis) {\n            final Thread currentThread = Thread.currentThread();\n            if (init != null && init != currentThread && init.isAlive()) {\n                init.interrupt();\n                if (millis > 0) {\n                    try {\n                        init.join(millis);\n                    } catch (InterruptedException e) {\n                        Log.w(TAG, \"Initializer thread is still running\", e);\n                        return;\n                    }\n                }\n            }\n            // if a thread is still alive, possible reasons:\n            //      slow device\n            //      the user is spamming start/pause buttons\n            //      start() method called quickly after pause()\n\n\n            for (Thread thread : threads) {\n                if (!thread.isAlive() || thread == Thread.currentThread()) {\n                    continue;\n                }\n                thread.interrupt();\n            }\n\n            try {\n                for (Thread thread : threads) {\n                    if (!thread.isAlive()) {\n                        continue;\n                    }\n                    if (DEBUG) {\n                        Log.w(TAG, \"thread alive: \" + thread.getName());\n                    }\n\n                    if (millis > 0) {\n                        thread.join(millis);\n                    }\n                }\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"A download thread is still running\", e);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "338", "src_id": "M1043", "code": "    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n        Exception exception = null;\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException \n            || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "339", "src_id": "M1031", "code": "    void establishConnection(int threadId, HttpURLConnection conn) \n    throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // let the download thread handle this error\n            default:\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "340", "src_id": "M827", "code": "    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n        final Elst obj = new Elst();\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n        if (!v1) {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        } else {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } \n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "341", "src_id": "M1048", "code": "    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n        try {\n            long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n            int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n            // secondary check for the file length\n            if (!mMission.unknownLength)\n            {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n            mF = mMission.storage.getStream();\n\n            mF.seek(mMission.offsets[mMission.current] + start);\n            mIs = mConn.getInputStream();\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n            dispose();\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n            run(); // try again\n            return;\n        }\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "342", "src_id": "M1141", "code": "    private void flushAuxiliar(long amount) \n    throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n        out.flush();\n        aux.flush();\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n        aux.target.seek(0);\n        out.target.seek(out.length);\n        long length = amount;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n        if (!underflow) {\n            out.offset += amount;\n            aux.offset -= amount;\n        } else {\n            if (out.offset < out.length) {\n                aux.offset = 0;\n            }\n            else {\n                // calculate the aux underflow pointer\n                if (aux.offset >= amount) {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                } else {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } \n            } \n        } \n        out.length += amount;\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount, writeOffset = 0;\n            aux.length -= amount;\n            length = aux.length;\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n            aux.target.setLength(aux.length);\n            return;\n        }\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n        }\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "343", "src_id": "M1106", "code": "    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n        request.append(\" [\");\n\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n            {\n                request.append(' ').append(recovery.toString()).append(' ');\n            }\n        }\n\n        request.append(\"]\");\n\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n        ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "344", "src_id": "M1067", "code": "    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n            // create metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile())\n                        {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n            if (mission.storage == null) {\n                // noting to do here\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null)\n                {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n            boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "345", "src_id": "M1136", "code": "    @Override int process(SharpStream out, SharpStream... sources) \n    throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n        if (!(format == null || format.equals(\"ttml\"))) {\n            if (format.equals(\"srt\")) {\n                byte[] buffer = new byte[8 * 1024];\n                int read;\n                while ((read = sources[0].read(buffer)) > 0) {\n                    out.write(buffer, 0, read);\n                }\n                return OK_RESULT;\n            }\n        } else {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException ? 1 : 8;\n            }\n\n            return OK_RESULT;\n        } \n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "346", "src_id": "M1047", "code": "    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n            }\n        }// if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == Thread.currentThread()) {\n                continue;\n            }\n            thread.interrupt();\n        }\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue;\n                }\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n                if (millis > 0) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1277", "code": "        public static Map<String, String> toStringMap(Map<String, Object> input, \n        boolean stringEscape) {\n            Map<String, String> output = new HashMap<>(input.size());\n            for (Map.Entry<String, Object> entry : input.entrySet()) {\n                String key = entry.getKey();\n                Object obj = entry.getValue();\n\n                if (key == null || obj == null) {\n                    throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n                }\n\n                String str;\n\n                if (!(obj instanceof byte[])) {\n                    if (!(obj instanceof redis.clients.jedis.GeoCoordinate)) {\n                        if (obj instanceof String) {\n                            if (stringEscape) { \n                                str = escape((String) obj); \n                            } else { \n                                str = (String) obj; \n                            } \n                        } else {\n                            str = String.valueOf(obj);\n                        }\n                    } else {\n                        redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                        str = geo.getLongitude() + \",\" + geo.getLatitude();\n                    } \n                }else {\n                    str = SafeEncoder.encode((byte[]) obj);\n                } \n\n                output.put(key, str);\n            }\n\n            return output;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "76", "src_id": "M902", "code": "        @Override\n        public void addParams(CommandArguments args) {\n            if (retentionPeriod != null) {\n                args.add(RETENTION).add(toByteArray(retentionPeriod));\n            }\n            if (encoding != null) {\n                args.add(ENCODING).add(encoding);\n            }\n\n            if (chunkSize != null) {\n                args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n            }\n\n            if (duplicatePolicy != null) {\n                args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n            }\n\n            if (ignore) {\n                args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n            }\n\n            if (labels != null) {\n                args.add(LABELS);\n                labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1131", "code": "        private static Object process(final RedisInputStream is) {\n            final byte b = is.readByte();\n            // System.out.println(\"BYTE: \" + (char) b);\n            switch (b) {\n                case PLUS_BYTE:\n                    return is.readLineBytes();\n                case DOLLAR_BYTE:\n                case EQUAL_BYTE:\n                    return processBulkReply(is);\n                case ASTERISK_BYTE:\n                    return processMultiBulkReply(is);\n                case UNDERSCORE_BYTE:\n                    return is.readNullCrLf();\n                case HASH_BYTE:\n                    return is.readBooleanCrLf();\n                case COLON_BYTE:\n                    return is.readLongCrLf();\n                case COMMA_BYTE:\n                    return is.readDoubleCrLf();\n                case LEFT_BRACE_BYTE:\n                    return is.readBigIntegerCrLf();\n                case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                    return processMapKeyValueReply(is);\n                case TILDE_BYTE : // TODO:\n                    return processMultiBulkReply(is);\n                case GREATER_THAN_BYTE:\n                    return processMultiBulkReply(is);\n                case MINUS_BYTE:\n                    processError(is);\n                    return null;\n                    // TODO: Blob error '!'\n                default:\n                    throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "78", "src_id": "M1057", "code": "        @Override\n        public Map.Entry<T, ProfilingInfo> build(Object data) {\n            List list = (List) data;\n            if (list == null || list.isEmpty()) {\n                return null;\n            }\n\n            if (list.get(0) instanceof KeyValue) { // RESP3\n                Object resultsData = null, profileData = null;\n                for (KeyValue keyValue : (List<KeyValue>) data) {\n                    String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                    switch (keyStr) {\n                        case PROFILE_STR_REDIS7:\n                        case PROFILE_STR_REDIS8:\n                            profileData = keyValue.getValue();\n                            break;\n                        case RESULTS_STR_REDIS7:\n                            resultsData = data;\n                            break;\n                        case RESULTS_STR_REDIS8:\n                            resultsData = keyValue.getValue();\n                            break;\n                    }\n                }\n\n                assert resultsData != null : \"Could not detect Results data.\";\n\n                assert profileData != null : \"Could not detect Profile data.\";\n\n                return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n            }\n\n            return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "79", "src_id": "M1229", "code": "        public SSLContext createSslContext()throws IOException, GeneralSecurityException {\n            KeyManager[] keyManagers = null;\n            TrustManager[] trustManagers = null;\n\n            if (sslVerifyMode == SslVerifyMode.FULL) {\n                this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n            } else {\n                if (sslVerifyMode == SslVerifyMode.CA) {\n                    this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n                } else {\n                    if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n                    }\n                }\n            }\n\n            if (keystoreResource != null) {\n                KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                try (InputStream keystoreStream = keystoreResource.get()) {\n                    keyStore.load(keystoreStream, keystorePassword);\n                }\n\n                KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n\n                keyManagerFactory.init(keyStore, keystorePassword);\n\n                keyManagers = keyManagerFactory.getKeyManagers();\n            }\n\n            if (trustManagers == null && truststoreResource != null) {\n                KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n                try (InputStream truststoreStream = truststoreResource.get()) {\n                    trustStore.load(truststoreStream, truststorePassword);\n                }\n\n                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n\n                trustManagerFactory.init(trustStore);\n\n                trustManagers = trustManagerFactory.getTrustManagers();\n            }\n\n            SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n\n            sslContext.init(keyManagers, trustManagers, null);\n\n            return sslContext;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "80", "src_id": "M894", "code": "        @Override\n        public TSInfo build(Object data) {\n            List<KeyValue> list = (List<KeyValue>) data;\n            Map<String, Object> properties = new HashMap<>();\n\n            Map<String, String> labels = null;\n\n            Map<String, Rule> rules = null;\n\n            List<Map<String, Object>> chunks = null;\n\n            for (KeyValue propertyValue : list) {\n                String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n                Object value = propertyValue.getValue();\n\n                if (value instanceof List) {\n\n                    switch (prop) {\n                        case LABELS_PROPERTY:\n                            labels = BuilderFactory.STRING_MAP.build(value);\n                            value = labels;\n\n                            break;\n                        case RULES_PROPERTY:\n                            List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                            Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n\n                            rules = new HashMap<>(rulesDataList.size());\n\n                            for (KeyValue rkv : rulesDataList) {\n                                String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                                List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n\n                                rulesValueMap.put(ruleName, ruleValueList);\n\n                                rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                            }\n\n                            value = rulesValueMap;\n\n                            break;\n                        case CHUNKS_PROPERTY:\n                            List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                            List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n\n                            chunks = new ArrayList<>(chunksDataList.size());\n\n                            for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                                Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                                chunksValueList.add(chunk);\n\n                                chunks.add(chunk);\n                            }\n\n                            value = chunksValueList;\n\n                            break;\n                        default:\n                            value = SafeEncoder.encodeObject(value);\n                            break;\n                    }\n                } else {\n                    if (value instanceof byte[]) {\n                        value = BuilderFactory.STRING.build(value);\n                        if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                            try {\n                                value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                            } catch (Exception e) { }\n                        }\n                    }\n                }\n\n                properties.put(prop, value);\n            }\n\n            return new TSInfo(properties, labels, rules, chunks);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "81", "src_id": "M897", "code": "        @Override\n        public void addParams(CommandArguments args) {\n            if (retentionPeriod != null) {\n                args.add(RETENTION).add(toByteArray(retentionPeriod));\n            }\n            if (encoding != null) {\n                args.add(ENCODING).add(encoding);\n            }\n\n            if (chunkSize != null) {\n                args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n            }\n\n            if (duplicatePolicy != null || duplicatePolicy != null) {\n                args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n            }\n\n            if (onDuplicate != null) {\n                args.add(ON_DUPLICATE).add(onDuplicate);\n            }\n\n            if (ignore) {\n                args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n            }\n\n            if (labels != null) {\n                args.add(LABELS);\n                labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "82", "src_id": "M1213", "code": "        @Override\n        public Connection getConnection() {\n            List<ConnectionPool> pools = getShuffledNodesPool();\n            JedisException suppressed = null;\n\n            for (ConnectionPool pool : pools) {\n                Connection jedis = null;\n                try {\n                    jedis = pool.getResource();\n                    if (jedis != null) { \n                        jedis.ping();\n                        return jedis;\n                    } \n                } catch (JedisException ex) {\n                    if (suppressed == null) { // remembering first suppressed exception\n                        suppressed = ex;\n                    }\n                    if (jedis != null) {\n                        jedis.close();\n                    }\n                }\n            }\n\n            JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n            if (suppressed != null) {\n                noReachableNode.addSuppressed(suppressed);\n            }\n\n            throw noReachableNode;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "83", "src_id": "M9", "code": "        @Override\n        public CacheEntry set(CacheKey cacheKey, \n        CacheEntry entry) {\n            lock.lock();\n            try {\n                entry = putIntoStore(cacheKey, entry);\n                EvictionPolicy policy = getEvictionPolicy();\n\n                policy.touch(cacheKey);\n\n                CacheKey evictedKey = policy.evictNext();\n\n                if (evictedKey != null) {\n                    delete(evictedKey);\n                    stats.evict();\n                }\n\n                for (Object redisKey : cacheKey.getRedisKeys()) {\n                    ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                    if (!(redisKeysToCacheKeys.containsKey(mapKey))) {\n                        Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                        set.add(cacheKey);\n\n                        redisKeysToCacheKeys.put(mapKey, set);\n                    } else {\n                        redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                    } \n                }\n\n                stats.load();\n\n                return entry;\n            } finally {\n                lock.unlock();\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "84", "src_id": "M1105", "code": "        @Override\n        public Class<?> build(Object data) {\n            if (data == null) {\n                return null;\n            }\n            String str = STRING.build(data);\n\n            switch (str) {\n                case \"null\":\n                    return null;\n                case \"boolean\":\n                    return boolean.class;\n                case \"integer\":\n                    return int.class;\n                case \"number\":\n                    return float.class;\n                case \"string\":\n                    return String.class;\n                case \"object\":\n                    return Object.class;\n                case \"array\":\n                    return List.class;\n                default:\n                    throw new JedisException(\"Unknown type: \" + str);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "30", "src_id": "M342", "code": "    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n        // Generate HTML with custom styling based on request\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n\n        html.append(processEmailHtmlBody(htmlBody));\n\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status if requested\n        assert request != null;\n\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "31", "src_id": "M371", "code": "    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) {\n            return false;\n        }\n        try {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n\n            // Additional check for MimeMultipart\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "32", "src_id": "M348", "code": "    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[j].trim());\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // Apply MIME header decoding\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim().isEmpty()) {\n                    break;\n                }\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "33", "src_id": "M364", "code": "    private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) \n    throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n        // 1. Find the screen position of all attachment markers\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true); // Process pages in order\n\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        // 2. Warn if the number of markers and attachments don't match\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "58", "src_id": "M475", "code": "@Override\npublic void draw(CommandProcess process, JvmModel result) {\n     TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n     for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n          String group = entry.getKey();\n          \n          List<JvmItemVO> items = entry.getValue();\n\n          table.row(true, label(group).style(Decoration.bold.bold()));\n          \n          for (JvmItemVO item : items) {\n               String valueStr = item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\") ? \n               renderMemoryUsage((Map<String, Object>)item.getValue()) : renderItemValue(item.getValue()); \n               if (item.getDesc() != null) {\n                    table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n               } else \n               {\n                    table.row(item.getName(), valueStr);\n               }\n          }\n          \n          table.row(\"\", \"\");\n     }\n\n     process.write(RenderUtil.render(table, process.width()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "59", "src_id": "M535", "code": "public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n     final StringBuilder infoSB = new StringBuilder();\n     List<String> classDumpFiles = affectVO.getClassDumpFiles();\n     \n     if (classDumpFiles != null) {\n          for (String classDumpFile : classDumpFiles) {\n               infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n          }\n     }\n\n     List<String> methods = affectVO.getMethods();\n     \n     if (methods != null) {\n          for (String method : methods) {\n               infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n          }\n     }\n\n     infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\", affectVO.getClassCount(), affectVO.getMethodCount(), affectVO.getCost(), affectVO.getListenerId()));\n     \n     if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n          infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n     }\n     \n     if (affectVO.getThrowable() != null) {\n          infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n     }\n     \n     infoSB.append(\"\\n\");\n\n     return infoSB.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "60", "src_id": "M753", "code": "public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n     List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n     // Sample CPU\n     if (lastCpuTimes.isEmpty()) {\n          lastSampleTimeNanos = System.nanoTime();\n          for (ThreadVO thread : threads) {\n               if (thread.getId() > 0) {\n                    long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                    \n                    lastCpuTimes.put(thread, cpu);\n                    \n                    thread.setTime(cpu / 1000000);\n               }\n          }\n\n          // add internal threads\n          Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n          \n          if (internalThreadCpuTimes != null) {\n               for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                    String key = entry.getKey();\n                    ThreadVO thread = createThreadVO(key);\n                    thread.setTime(entry.getValue() / 1000000);\n                    threads.add(thread);\n                    lastCpuTimes.put(thread, entry.getValue());\n               }\n          }\n\n          //sort by time\n          Collections.sort(threads, new Comparator<ThreadVO>() {\n               @Override\n               public int compare(ThreadVO o1, ThreadVO o2) {\n                    long l1 = o1.getTime();\n                    long l2 = o2.getTime();\n                    if (l1 < l2) {\n                         return 1;\n                    } else {\n                         if (l1 > l2) {\n                              return -1;\n                         } else {\n                              return 0;\n                         }\n                    }\n               }});\n          \n          return threads;\n     }\n\n     // Resample\n     long newSampleTimeNanos = System.nanoTime();\n     \n     Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n     \n     for (ThreadVO thread : threads) {\n          if (thread.getId() > 0) {\n               long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n               \n               newCpuTimes.put(thread, cpu);\n          }\n     }\n     \n     // internal threads\n     Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n     \n     if (newInternalThreadCpuTimes != null) {\n          for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n               ThreadVO threadVO = createThreadVO(entry.getKey());\n               threads.add(threadVO);\n               \n               newCpuTimes.put(threadVO, entry.getValue());\n          }\n     }\n\n     // Compute delta time\n     final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n     \n     for (ThreadVO thread : newCpuTimes.keySet()) {\n          Long t = lastCpuTimes.get(thread);\n          if (t == null) {\n               t = 0L;\n          }\n          long time1 = t;\n          long time2 = newCpuTimes.get(thread);\n          \n          if (time1 == -1) {\n               time1 = time2;\n          } else {\n               if (time2 == -1) {\n                    time2 = time1;\n               }\n          }\n\n          long delta = time2 - time1;\n          \n          deltas.put(thread, delta);\n     }\n\n     long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n\n     // Compute cpu usage\n     final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n     \n     for (ThreadVO thread : threads) {\n          double cpu = sampleIntervalNanos == 0 ? 0 : (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0);\n          \n          cpuUsages.put(thread, cpu);\n     }\n\n     // Sort by CPU time : should be a rendering hint...\n     Collections.sort(threads, new Comparator<ThreadVO>() {\n          @Override\n          public int compare(ThreadVO o1, ThreadVO o2) {\n               long l1 = deltas.get(o1);\n               long l2 = deltas.get(o2);\n               if (l1 < l2) {\n                    return 1;\n               } else {\n                    if (l1 > l2) {\n                         return -1;\n                    } else {\n                         return 0;\n                    }\n               }\n          }});\n\n     for (ThreadVO thread : threads) {\n          //nanos to mills\n          long timeMills = newCpuTimes.get(thread) / 1000000;\n          \n          long deltaTime = deltas.get(thread) / 1000000;\n          \n          double cpu = cpuUsages.get(thread);\n          thread.setCpu(cpu);\n          thread.setTime(timeMills);\n          thread.setDeltaTime(deltaTime);\n     }\n     \n     lastCpuTimes = newCpuTimes;\n     \n     lastSampleTimeNanos = newSampleTimeNanos;\n     return threads;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "61", "src_id": "M1131", "code": "private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n     String commandLine = apiRequest.getCommand();\n     Map<String, Object> body = new TreeMap<String, Object>();\n     \n     body.put(\"command\", commandLine);\n\n     ApiResponse response = new ApiResponse();\n     \n     response.setSessionId(session.getSessionId()).setBody(body);\n\n     if (!session.tryLock()) {\n          response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n          \n          return response;\n     }\n     \n     int lock = session.getLock();\n     \n     try {\n          Job foregroundJob = session.getForegroundJob();\n          if (foregroundJob != null) {\n               response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n               logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n               \n               return response;\n          }\n\n          //create job\n          Job job = this.createJob(commandLine, session, session.getResultDistributor());\n          \n          body.put(\"jobId\", job.id());\n          \n          body.put(\"jobStatus\", job.status());\n          response.setState(ApiState.SCHEDULED);\n\n          //add command before exec job\n          CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n          \n          commandRequestModel.setJobId(job.id());\n          \n          SharingResultDistributor resultDistributor = session.getResultDistributor();\n          \n          if (resultDistributor != null) {\n               resultDistributor.appendResult(commandRequestModel);\n          }\n          \n          session.setForegroundJob(job);\n          \n          updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n          //run job\n          job.run();\n          return response;\n     } catch (Throwable e) {\n          logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n          response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n          \n          CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n          \n          session.getResultDistributor().appendResult(commandRequestModel);\n          \n          return response;\n     } finally {\n          if (session.getLock() == lock) {\n               session.unLock();\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "62", "src_id": "M542", "code": "import null; private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n     StringBuilder sb = new StringBuilder(8192);\n     for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n          Map<String, Object> info = entry.getValue();\n          TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n          \n          TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n          Class<?> clazz = (Class<?>)info.get(LoggerHelper.clazz);\n          \n          TableElementtmp = table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)));\n\n          tmp.row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName())).row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n          \n          if (info.get(LoggerHelper.effectiveLevel) != null) {\n               table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n          }\n\n          if (info.get(LoggerHelper.config) != null) {\n               table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n          }\n\n          table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n          @SuppressWarnings(\"unchecked\")List<Map<String, Object>> appenders = (List<Map<String, Object>>)info.get(LoggerHelper.appenders);\n          \n          if (appenders != null && !appenders.isEmpty()) {\n               for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>)appenderInfo.get(LoggerHelper.clazz);\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    \n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    \n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    \n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    \n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                         appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    \n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                         appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    \n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                         appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    \n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                         appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n               }\n               table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n          }\n\n          sb.append(RenderUtil.render(table, width)).append('\\n');\n     }\n     \n     return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "63", "src_id": "M15", "code": "public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n     // start java telnet client\n     // find arthas-client.jar\n     URLClassLoader classLoader = new URLClassLoader(new URL[] { new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL() });\n     Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n     \n     Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n\n     //redirect System.out/System.err\n     PrintStream originSysOut = System.out;\n     \n     PrintStream originSysErr = System.err;\n     \n     PrintStream newOut = new PrintStream(out);\n     \n     PrintStream newErr = new PrintStream(out);\n\n     // call TelnetConsole.process()\n     // fix https://github.com/alibaba/arthas/issues/833\n     ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n     \n     try {\n          System.setOut(newOut);\n          System.setErr(newErr);\n          Thread.currentThread().setContextClassLoader(classLoader);\n          \n          return (Integer)processMethod.invoke(null, new Object[] { telnetArgs.toArray(new String[0]) });\n     } catch (Throwable e) {\n          //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n          e = e.getCause();\n          if (e instanceof IOException || e instanceof InterruptedException) {\n               // ignore connection error and interrupted error\n               return STATUS_ERROR;\n          } else \n          {\n               // process error\n               AnsiLog.error(\"process error: {}\", e.toString());\n               AnsiLog.error(e);\n               return STATUS_EXEC_ERROR;\n          }\n     } finally {\n          Thread.currentThread().setContextClassLoader(tccl);\n\n          //reset System.out/System.err\n          System.setOut(originSysOut);\n          \n          System.setErr(originSysErr);\n          //flush output\n          newOut.flush();\n          newErr.flush();\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "64", "src_id": "M1469", "code": "public static FieldVO[] getFields(Class clazz, Integer expand) {\n     Field[] fields = clazz.getDeclaredFields();\n     \n     if (fields.length == 0) {\n          return new FieldVO[0];\n     }\n\n     List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n     \n     for (Field field : fields) {\n          FieldVO fieldVO = new FieldVO();\n          fieldVO.setName(field.getName());\n          \n          fieldVO.setType(StringUtils.classname(field.getType()));\n          \n          fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n          \n          fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n          \n          if (!(Modifier.isStatic(field.getModifiers()))) {\n               fieldVO.setStatic(false);\n          } else \n          {\n               fieldVO.setStatic(true);\n               \n               fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n          } \n\n          list.add(fieldVO);\n     }\n     \n     return list.toArray(new FieldVO[0]);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "347", "src_id": "M31", "code": "    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")\n        // .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n        .build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() != 200) {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        } else {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n\n            }\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n\n                }\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n            // Extract user count, default to 1 if not specified\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n            log.debug(applicationProperties.toString());\n\n        } \n        return jsonResponse;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "348", "src_id": "M488", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description =\n    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "349", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            // Metadata using PDFBox\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode();\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            ObjectNode encryption = objectMapper.createObjectNode();\n            ObjectNode other = objectMapper.createObjectNode();\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n            // Total file size of the PDF\n            long fileSizeInBytes = inputFile.getSize();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n            // Number of words, paragraphs, and images in the entire document\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n            int wordCount = words.length;\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n            // Number of characters in the entire document (including spaces and special characters)\n            int charCount = fullText.length();\n            basicInfo.put(\"CharacterCount\", charCount);\n            // Initialize the flags and types\n            boolean hasCompression = false;\n            String compressionType = \"None\";\n            basicInfo.put(\"Compression\", hasCompression);\n            if (hasCompression) {\n                basicInfo.put(\"CompressionType\", compressionType);\n            }\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            String pageMode = catalog.getPageMode().name();\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n            ;\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n            // Generate structured summary data about PDF characteristics\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n            // embeed files TODO size\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n            // attachments TODO size\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n            // Javascript\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n                            PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n\n                            }\n                            javascriptArray.add(jsNode);\n\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n            // TODO size\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n            other.set(\"Layers\", layersArray);// TODO Security\n\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            ArrayNode structureTreeArray;\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n\n                }\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                log.error(\"exception\", e);\n            }\n            boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n            boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n            boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n            boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n            boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n            boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n            // an official ISO standard.\n            boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n            // development in 2021.\n\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            String xmpString = null;\n            if (pdMetadata != null) {\n                try {\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        DomXmpParser domXmpParser = new DomXmpParser();\n                        XMPMetadata xmpMeta = domXmpParser.parse(is);\n                        ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        new XmpSerializer().serialize(xmpMeta, os, true);\n                        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n\n                    }\n                } catch (XmpParsingException e) {\n                    // XMP parsing failed, try to read raw metadata instead\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", xmpString);\n            if (!(pdfBoxDoc.isEncrypted())) {\n                encryption.put(\"IsEncrypted\", false);\n            } else {\n                encryption.put(\"IsEncrypted\", true);\n                // Retrieve encryption details using getEncryption()\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n\n                // Add other encryption-related properties as needed\n            } \n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                // Retrieve the page\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n                // Page-level Information\n                PDRectangle mediaBox = page.getMediaBox();\n                float width = mediaBox.getWidth();\n                float height = mediaBox.getHeight();\n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                // Assuming the following boxes are defined for your document; if not, you may get\n                // null values.\n                PDRectangle cropBox = page.getCropBox();\n                pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n                PDRectangle bleedBox = page.getBleedBox();\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n                PDRectangle trimBox = page.getTrimBox();\n                pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n                PDRectangle artBox = page.getArtBox();\n                pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n                // Content Extraction\n                PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n                String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length()); //\n\n                // Annotations\n\n                List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) {\n                        subtypeCount += 1; \n                    }\n                    if (annotation.getContents() != null) {\n                        contentsCount += 1; \n                    }\n\n                }\n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n                // Images (simplified)\n                // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                // Here is a basic structure to recognize image XObjects on a page.\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                PDResources resources = page.getResources();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n                Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri); // Add to set to ensure uniqueness\n                    }\n                }\n                // Add unique URIs to linksArray\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n                pageInfo.set(\"Links\", linksArray);\n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        // Font stretch and BBox are not directly available in PDFBox's API, so\n                        // these are omitted for simplicity\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n\n                    }\n                    // Create a unique key for this font node based on its attributes\n                    String uniqueKey = fontNode.toString();\n                    // Increment count if this font exists, or initialize it if new\n                    if (!(uniqueFontsMap.containsKey(uniqueKey))) {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    } else {\n                        ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        int count = existingFontNode.get(\"Count\").asInt() + 1;\n                        existingFontNode.put(\"Count\", count);\n\n                    } \n                }\n                // Add unique font entries to fontsArray\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", fontsArray);\n                // Access resources dictionary\n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n                for (COSName name : colorSpaceNames) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        byte[] iccBytes = iccData.toByteArray();\n                        // TODO: Further decode and analyze the ICC data if needed\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n                // Other XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType;\n                    if (xObject instanceof PDImageXObject) {\n                        xObjectType = \"Image\";\n                    } else {\n                        if (xObject instanceof PDFormXObject) {\n                            xObjectType = \"Form\";\n                        } else {\n                            xObjectType = \"Other\";\n                        }\n                        // Increment the count for this type in the map\n                    }\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                // Add the count map to pageInfo (or wherever you want to store it)\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n                ArrayNode multimediaArray = objectMapper.createArrayNode();\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        ObjectNode multimediaNode = objectMapper.createObjectNode();\n                        // Extract details from the annotation as needed\n                        multimediaArray.add(multimediaNode);\n\n                    }\n                }\n                pageInfo.set(\"Multimedia\", multimediaArray);\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n\n            }\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Encryption\", encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n            jsonOutput.set(\"Other\", other);\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n            // Save JSON to file\n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n        return null;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "350", "src_id": "M24", "code": "    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n\n            }\n            // Verify license file algorithm\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n\n            }\n            // Verify signature\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n            log.info(\"License file signature is valid\");\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n\n            }\n            // Process the certificate data\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "351", "src_id": "M403", "code": "    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (!(entry.getName().toLowerCase().endsWith(\".html\")\n                        || entry.getName().toLowerCase().endsWith(\".htm\"))) {\n                            Files.copy(zipIn, filePath);\n                        } else {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n\n                        } \n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "352", "src_id": "M317", "code": "    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else {\n                if (\"maintainAspectRatio\".equals(fitOption)) {\n                    float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                    float pageAspectRatio = pageWidth / pageHeight;\n                    float scaleFactor = 1.0f;\n                    if (imageAspectRatio > pageAspectRatio) {\n                        scaleFactor = pageWidth / image.getWidth();\n                    } else {\n                        scaleFactor = pageHeight / image.getHeight();\n                    }\n                    float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                    float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                    contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n\n                }\n            }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "353", "src_id": "M307", "code": "    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network != null) {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                }\n\n            }// Hash the MAC address for privacy and consistency\n            else {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n\n                    }\n\n                }\n            } \n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "354", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "355", "src_id": "M128", "code": "    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (!isKubernetes) {\n                if (isDocker) {\n                    return \"Docker\";\n                } else {\n                    if (!isBrowserOpen) {\n                        return \"Server-jar\";\n                    }\n                    else {\n                        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                        if (!(os.contains(\"win\"))) {\n                            return os.contains(\"mac\")? \"Client-mac\" : \"Client-unix\"; \n                        }else {\n                            return \"Client-windows\";\n                        } \n\n                    } \n                }\n            }else {\n                return \"Kubernetes\";\n            } \n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "356", "src_id": "M101", "code": "    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "85", "src_id": "M1277", "code": "    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n            if (!(obj instanceof byte[])) {\n                if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                    redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                    str = geo.getLongitude() + \",\" + geo.getLatitude();\n                } else {\n                    if (obj instanceof String) {\n                        str = stringEscape ? escape((String) obj) : (String) obj;\n                    } else {\n                        str = String.valueOf(obj);\n                    }\n                }\n            }else {\n                str = SafeEncoder.encode((byte[]) obj);\n            } \n            output.put(key, str);\n        }\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "86", "src_id": "M902", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "87", "src_id": "M1131", "code": "    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE : // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n                // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "88", "src_id": "M1057", "code": "    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "89", "src_id": "M1229", "code": "    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode != SslVerifyMode.FULL) {\n            if (sslVerifyMode == SslVerifyMode.CA) {\n                this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n            } else {\n                if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                    trustManagers = new TrustManager[] { \n                    INSECURE_TRUST_MANAGER };\n                }\n            }\n        }else {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } \n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "90", "src_id": "M894", "code": "    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap<>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            if (!(value instanceof List)) {\n                if (value instanceof byte[]) {\n                    value = BuilderFactory.STRING.build(value);\n                    if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                        try {\n                            value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                        } catch (Exception e) { }\n                    }\n                }\n            } else {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n                        value = labels;\n                        break;\n                    case RULES_PROPERTY:\n                        List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                        Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                        rules = new HashMap<>(rulesDataList.size());\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n\n                            rulesValueMap.put(ruleName, ruleValueList);\n\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                        }\n                        value = rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                        List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                        chunks = new ArrayList<>(chunksDataList.size());\n                        for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n                            chunks.add(chunk);\n                        }\n                        value = chunksValueList;\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } \n            properties.put(prop, value);\n        }\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "91", "src_id": "M897", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null || duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "92", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis != null) { \n                    jedis.ping();\n                    return jedis;\n                } \n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "93", "src_id": "M9", "code": "    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n            stats.load();\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "94", "src_id": "M1105", "code": "    @Override\n    public Class<?> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "357", "src_id": "M491", "code": "            @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n            @ResizeMode public static int nextResizeModeAndSaveToPrefs(final Player player,@ResizeMode final int resizeMode) {\n             final int newResizeMode;\n             switch (resizeMode) {\n              case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n               newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n               break;\n              case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n               newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n               break;\n              case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n              default:\n               newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n               break;\n             }\n\n             // save the new resize mode so it can be restored in a future session\n             player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode)\n             .apply();\n\n             return newResizeMode;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "358", "src_id": "M424", "code": "            @Override\n            public void onBroadcastReceived(final Intent intent) {\n             super.onBroadcastReceived(intent);\n             if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n              // Close it because when changing orientation from portrait\n              // (in fullscreen mode) the size of queue layout can be larger than the screen size\n              closeItemsList();\n             } else {\n              if (!(ACTION_PLAY_PAUSE.equals(intent.getAction()))) {\n               if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                fragmentIsVisible = false;\n                onFragmentStopped();\n               } else {\n                if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n                 // Restore video source when user returns to the fragment\n                 fragmentIsVisible = true;\n                 player.useVideoSource(true);\n                 // When a user returns from background, the system UI will always be shown even if\n                 // controls are invisible: hide it in that case\n                 if (!isControlsVisible()) {\n                  hideSystemUIIfNeeded();\n                 }\n                }\n               }\n              }else {\n               // Ensure that we have audio-only stream playing when a user\n               // started to play from notification's play button from outside of the app\n               if (!fragmentIsVisible) {\n                onFragmentStopped();\n               }\n              } \n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "359", "src_id": "M900", "code": "            @StyleRes\n            public static int getSettingsThemeStyle(final Context context) {\n             final Resources res = context.getResources();\n             final String lightTheme = res.getString(R.string.light_theme_key);\n             final String blackTheme = res.getString(R.string.black_theme_key);\n\n             final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n             final String selectedTheme = getSelectedThemeKey(context);\n\n             if (!(selectedTheme.equals(lightTheme))) {\n              if (selectedTheme.equals(blackTheme)) {\n               return R.style.BlackSettingsTheme;\n              } else {\n               if (!(selectedTheme.equals(automaticDeviceTheme))) {\n                // default to dark theme\n                return R.style.DarkSettingsTheme;\n               } else {\n                if (!isDeviceDarkThemeEnabled(context)) {\n                 // there is only one day theme\n                 return R.style.LightSettingsTheme;\n                } else {\n                 // use the dark theme variant preferred by the user\n                 final String selectedNightTheme = getSelectedNightThemeKey(context);\n                 if (selectedNightTheme.equals(blackTheme)) {\n                  return R.style.BlackSettingsTheme;\n                 } else {\n                  return R.style.DarkSettingsTheme;\n                 }\n                } \n               } \n              }\n             }else {\n              return R.style.LightSettingsTheme;\n             } \n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "360", "src_id": "M895", "code": "            @Override\n            public Bitmap transform(final Bitmap source) {\n             if (DEBUG) {\n              Log.d(TAG, \"Thumbnail - transform() called\");\n             }\n             final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n             final Bitmap result = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n             if (!(result == source || !result.isMutable())) {\n              source.recycle();\n              return result;\n             } else {\n              // create a new mutable bitmap to prevent strange crashes on some\n              // devices (see #4638)\n              final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n              source.recycle();\n\n              return copied;\n             } \n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "361", "src_id": "M225", "code": "            private void onBroadcastReceived(final Intent intent) {\n             if (intent == null || intent.getAction() == null) {\n              return;\n             }\n             if (DEBUG) {\n              Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n             }\n\n             switch (intent.getAction()) {\n              case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n               pause();\n               break;\n              case ACTION_CLOSE:\n               service.destroyPlayerAndStopService();\n               break;\n              case ACTION_PLAY_PAUSE:\n               playPause();\n               break;\n              case ACTION_PLAY_PREVIOUS:\n               playPrevious();\n               break;\n              case ACTION_PLAY_NEXT:\n               playNext();\n               break;\n              case ACTION_FAST_REWIND:\n               fastRewind();\n               break;\n              case ACTION_FAST_FORWARD:\n               fastForward();\n               break;\n              case ACTION_REPEAT:\n               cycleNextRepeatMode();\n               break;\n              case ACTION_SHUFFLE:\n               toggleShuffleModeEnabled();\n               break;\n              case Intent.ACTION_CONFIGURATION_CHANGED:\n               if (DEBUG) {\n                Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n               }\n               break;\n             }\n\n             UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "362", "src_id": "M749", "code": "            private static void handleError(final Context context, final ErrorInfo errorInfo) {\n             if (errorInfo.getThrowable() != null) {\n              errorInfo.getThrowable().printStackTrace();\n             }\n             if (!(errorInfo.getThrowable() instanceof ReCaptchaException)) {\n              if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n               Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n              } else {\n               if (!(errorInfo.getThrowable() instanceof AgeRestrictedContentException)) {\n                if (!(errorInfo.getThrowable() instanceof GeographicRestrictionException)) {\n                 if (errorInfo.getThrowable() instanceof PaidContentException) {\n                  Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                 } else {\n                  if (!(errorInfo.getThrowable() instanceof PrivateContentException)) {\n                   if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                    Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG)\n                    .show();\n                   } else {\n                    if (!(errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException)) {\n                     if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n                      Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG)\n                      .show();\n                     } else {\n                      if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                       Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG)\n                       .show();\n                      } else {\n                       ErrorUtil.createNotification(context, errorInfo);\n                      }\n                     }\n                    }else {\n                     Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG)\n                     .show();\n                    } \n                   }\n                  }else {\n                   Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                  } \n                 }\n                }else {\n                 Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG)\n                 .show();\n                } \n               }else {\n                Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG)\n                .show();\n               } \n              }\n             }else {\n              Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG)\n              .show();\n              // Starting ReCaptcha Challenge Activity\n              final Intent intent = new Intent(context, ReCaptchaActivity.class);\n\n              intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n              context.startActivity(intent);\n             } \n\n             if (context instanceof RouterActivity) {\n              ((RouterActivity) context).finish();\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "363", "src_id": "M999", "code": "            public static void openVideoDetailFragment(\n            @NonNull final Context context,\n            @NonNull final FragmentManager fragmentManager,\n            final int serviceId,@Nullable final String url,@NonNull final String title,\n            @Nullable final PlayQueue playQueue,\n            final boolean switchingPlayers) {\n             final boolean autoPlay;\n\n             @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n\n             if (playerType != null) {\n              if (switchingPlayers) {\n               // switching player to main player\n               autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n              } else {\n               if (playerType == PlayerType.MAIN) {\n                // opening new stream while already playing in main player\n                autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n               } else {\n                // opening new stream while already playing in another player\n                autoPlay = false;\n               }\n              }\n             }else {\n              // no player open\n              autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n             } \n\n             final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n              expandMainPlayer(detailFragment.requireActivity());\n              detailFragment.setAutoPlay(autoPlay);\n\n              if (!switchingPlayers) {\n               detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n              } else {\n               // Situation when user switches from players to main player. All needed data is\n               // here, we can start watching (assuming newQueue equals playQueue).\n               // Starting directly in fullscreen if the previous player type was popup.\n               detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n              } \n\n              detailFragment.scrollToTop();\n             };\n\n             final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n\n             if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n              onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n             } else {\n              // Specify no url here, otherwise the VideoDetailFragment will start loading the\n              // stream automatically if it's the first time it is being opened, but then\n              // onVideoDetailFragmentReady will kick in and start another loading process.\n              // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n              final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n              instance.setAutoPlay(autoPlay);\n\n              defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance)\n              .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n              .commit();\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "364", "src_id": "M698", "code": "            @Override\n            public void handleResult(@NonNull final ChannelInfo result) {\n             super.handleResult(result);\n             currentInfo = result;\n             setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n             if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n              PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n             } else {\n              // do not waste space for the banner, if the user disabled images or there is not one\n              binding.channelBannerImage.setImageDrawable(null);\n             }\n\n             PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n\n             PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n             .into(binding.subChannelAvatarView);\n\n             binding.channelTitleView.setText(result.getName());\n\n             binding.channelSubscriberView.setVisibility(View.VISIBLE);\n\n             if (result.getSubscriberCount() < 0) {\n              binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n             } else {\n              binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n             } \n\n             if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n              binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n              binding.subChannelTitleView.setVisibility(View.VISIBLE);\n\n              binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n             }\n\n             updateRssButton();\n\n             channelContentNotSupported = false;\n\n             for (final Throwable throwable : result.getErrors()) {\n              if (throwable instanceof ContentNotSupportedException) {\n               channelContentNotSupported = true;\n               showContentNotSupportedIfNeeded();\n               break;\n              }\n             }\n\n             disposables.clear();\n\n             if (subscribeButtonMonitor != null) {\n              subscribeButtonMonitor.dispose();\n             }\n             updateTabs();\n             updateSubscription(result);\n             monitorSubscription(result);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "365", "src_id": "M379", "code": "            @Override\n            public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n             super.onTextTracksChanged(currentTracks);\n             final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n\n             if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n             || !trackTypeTextSupported) {\n              binding.captionTextView.setVisibility(View.GONE);\n              return;\n             }\n\n             // Extract all loaded languages\n             final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n             .collect(Collectors.toList());\n\n             final List<String> availableLanguages = textTracks.stream().map(Tracks.Group::getMediaTrackGroup).filter(textTrack -> textTrack.length > 0)\n             .map(textTrack -> textTrack.getFormat(0).language)\n             .collect(Collectors.toList());\n\n             // Find selected text track\n             final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info -> info.getMediaTrackGroup().length >= 1)\n             .map(info -> info.getMediaTrackGroup().getFormat(0))\n             .findFirst();\n\n             // Build UI\n             buildCaptionMenu(availableLanguages);\n\n             if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) \n             || selectedTracks.isEmpty()) {\n              binding.captionTextView.setText(R.string.caption_none);\n             } else {\n              binding.captionTextView.setText(selectedTracks.get().language);\n             }\n\n             binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "366", "src_id": "M894", "code": "            public static RequestCreator loadScaledDownThumbnail(final Context context,\n            @NonNull final List<Image> images) {\n             // scale down the notification thumbnail for performance\n             return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n              @Override\n              public Bitmap transform(final Bitmap source) {\n               if (DEBUG) {\n                Log.d(TAG, \"Thumbnail - transform() called\");\n               }\n               final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n               final Bitmap result = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth, (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n               if (!(result == source || !result.isMutable())) {\n                source.recycle();\n                return result;\n               } else {\n                // create a new mutable bitmap to prevent strange crashes on some\n                // devices (see #4638)\n                final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth - 1, (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n                source.recycle();\n\n                return copied;\n               } \n              }\n\n              @Override\n              public String key() {\n               return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n              }\n             });\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "160", "src_id": "M66", "code": "void drain() {\n     if (getAndIncrement() != 0) {\n          return;\n     }\n     int missed = 1;\n     \n     Observer<? super R> downstream = this.downstream;\n     \n     AtomicThrowable errors = this.errors;\n     \n     AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n     while (true) {\n          while (true) {\n               if (cancelled) {\n                    return;\n               }\n\n               if (errors.get() != null && !delayErrors) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n               }\n               \n               boolean d = done;\n               \n               SwitchMapMaybeObserver<R> current = inner.get();\n               \n               boolean empty = current == null;\n\n               if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n               }\n\n               if (empty || current.item == null) {\n                    break;\n               }\n\n               inner.compareAndSet(current, null);\n               downstream.onNext(current.item);\n          }\n          missed = addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "161", "src_id": "M1333", "code": "@Override\npublic void onNext(T t) \n{\n     if (done) {\n          return;\n     }\n     boolean b;\n     \n     try {\n          b = predicate.test(t);\n     } catch (Throwable e) {\n          Exceptions.throwIfFatal(e);\n          upstream.cancel();\n          upstream = SubscriptionHelper.CANCELLED;\n          onError(e);\n          return;\n     }\n     \n     if (!b) {\n          done = true;\n          upstream.cancel();\n          upstream = SubscriptionHelper.CANCELLED;\n          downstream.onSuccess(false);\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "162", "src_id": "M522", "code": "void drainLoop() {\n     Observer<? super T> actual = this.downstream;\n     \n     int missed = 1;\n     \n     while (true) {\n          while (true) {\n               if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n               }\n               if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n                    return;\n               }\n\n               int os = otherState;\n               \n               if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n               }\n\n               boolean d = mainDone;\n               \n               SimplePlainQueue<T> q = queue;\n               T v = q != null ? q.poll() : null;\n               boolean empty = v == null;\n\n               if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n               }\n\n               if (empty) {\n                    break;\n               }\n\n               actual.onNext(v);\n          }\n          missed = addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "163", "src_id": "M1163", "code": "@Override void drain() {\n     if (getAndIncrement() != 0) {\n          return;\n     }\n     int missed = 1;\n     \n     final SimplePlainQueue<Object> queue = this.queue;\n     \n     final Subscriber<? super Flowable<T>> downstream = this.downstream;\n     \n     UnicastProcessor<T> window = this.window;\n\n     while (true) {\n          if (upstreamCancelled) {\n               queue.clear();\n               window = null;\n               this.window = null;\n          } else {\n               boolean isDone = done;\n               Object o = queue.poll();\n               boolean isEmpty = o == null;\n\n               if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                         if (window != null) {\n                              window.onError(ex);\n                         }\n                         downstream.onError(ex);\n                    } else {\n                         if (window != null) {\n                              window.onComplete();\n                         }\n                         downstream.onComplete();\n                    }\n                    \n                    cleanupResources();\n                    \n                    upstreamCancelled = true;\n                    continue;\n               } else {\n                    if (!isEmpty) {\n                         if (o instanceof WindowBoundaryRunnable) {\n                              WindowBoundaryRunnable boundary = (WindowBoundaryRunnable)o;\n                              if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                   this.count = 0;\n                                   window = createNewWindow(window);\n                              }\n                         } else {\n                              if (window != null) {\n                                   @SuppressWarnings(\"unchecked\")T item = (T)o;\n                                   window.onNext(item);\n                                   long count = this.count + 1;\n                                   \n                                   if (count != maxSize) {\n                                        this.count = count;\n                                   } else {\n                                        this.count = 0;\n                                        window = createNewWindow(window);\n                                   } \n                              }\n                         }\n                         continue;\n                    }\n               }\n          }\n          missed = addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "164", "src_id": "M478", "code": "void drain() {\n     if (getAndIncrement() != 0) {\n          return;\n     }\n     int missed = 1;\n     \n     EqualObserver<T>[] as = observers;\n\n     final EqualObserver<T> observer1 = as[0];\n     \n     final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n     \n     final EqualObserver<T> observer2 = as[1];\n     \n     final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n     while (true) {\n          while (true) {\n               if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n               }\n               boolean d1 = observer1.done;\n\n               if (d1) {\n                    Throwable e = observer1.error;\n                    \n                    if (e != null) {\n                         cancel(q1, q2);\n                         downstream.onError(e);\n                         return;\n                    }\n               }\n\n               boolean d2 = observer2.done;\n               \n               if (d2) {\n                    Throwable e = observer2.error;\n                    \n                    if (e != null) {\n                         cancel(q1, q2);\n                         downstream.onError(e);\n                         return;\n                    }\n               }\n\n               if (v1 == null) {\n                    v1 = q1.poll();\n               }\n               \n               boolean e1 = v1 == null;\n               if (v2 == null) {\n                    v2 = q2.poll();\n               }\n               boolean e2 = v2 == null;\n               if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n               }\n               \n               if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n               }\n\n               if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                         c = comparer.test(v1, v2);\n                    } catch (Throwable ex) {\n                         Exceptions.throwIfFatal(ex);\n                         cancel(q1, q2);\n                         downstream.onError(ex);\n                         return;\n                    }\n\n                    if (!c) {\n                         cancel(q1, q2);\n                         downstream.onSuccess(false);\n                         return;\n                    }\n\n                    v1 = null;\n                    v2 = null;\n               }\n\n               if (e1 || e2) {\n                    break;\n               }\n          }\n          missed = addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "165", "src_id": "M885", "code": "void drainLoop() {\n     int missed = 1;\n\n     JoinInnerSubscriber<T>[] s = this.subscribers;\n     int n = s.length;\n     \n     Subscriber<? super T> a = this.downstream;\n\n     while (true) {\n          long r = requested.get();\n          long e = 0;\n\n          middle:\n          while (e != r) {\n               if (cancelled) {\n                    cleanup();\n                    return;\n               }\n               Throwable ex = errors.get();\n               if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n               }\n               boolean d = done.get() == 0;\n               boolean empty = true;\n\n               for (int i = 0; i < s.length; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimplePlainQueue<T> q = inner.queue;\n                    \n                    if (q != null) {\n                         T v = q.poll();\n\n                         if (v != null) {\n                              empty = false;\n                              a.onNext(v);\n                              inner.requestOne();\n                              if (++e == r) {\n                                   break middle;\n                              }\n                         }\n                    }\n               }\n\n               if (d && empty) {\n                    a.onComplete();\n                    return;\n               }\n\n               if (empty) {\n                    break;\n               }\n          }\n\n          if (e == r) {\n               if (cancelled) {\n                    cleanup();\n                    return;\n               }\n               Throwable ex = errors.get();\n               if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n               }\n               boolean d = done.get() == 0;\n               boolean empty = true;\n\n               for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimpleQueue<T> q = inner.queue;\n                    \n                    if (q != null && !q.isEmpty()) {\n                         empty = false;\n                         break;\n                    }\n               }\n\n               if (d && empty) {\n                    a.onComplete();\n                    return;\n               }\n          }\n\n          if (e != 0) {\n               BackpressureHelper.produced(requested, e);\n          }\n\n          missed = addAndGet(-missed);\n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1399", "code": "@Override\npublic void drain() {\n     if (getAndIncrement() != 0) {\n          return;\n     }\n     int missed = 1;\n     \n     InnerQueuedSubscriber<R> inner = current;\n     \n     Subscriber<? super R> a = downstream;\n     \n     ErrorMode em = errorMode;\n\n     while (true) {\n          long r = requested.get();\n          long e = 0L;\n\n          if (inner == null) {\n               if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    \n                    if (ex != null) {\n                         cancelAll();\n                         errors.tryTerminateConsumer(downstream);\n                         return;\n                    }\n               }\n               boolean outerDone = done;\n\n               inner = subscribers.poll();\n\n               if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n               }\n\n               if (inner != null) {\n                    current = inner;\n               }\n          }\n\n          boolean continueNextSource = false;\n\n          if (inner != null) {\n               SimpleQueue<R> q = inner.queue();\n               if (q != null) {\n                    while (e != r) {\n                         if (cancelled) {\n                              cancelAll();\n                              return;\n                         }\n                         if (em == ErrorMode.IMMEDIATE) {\n                              Throwable ex = errors.get();\n                              \n                              if (ex != null) {\n                                   current = null;\n                                   inner.cancel();\n                                   cancelAll();\n                                   errors.tryTerminateConsumer(downstream);\n                                   return;\n                              }\n                         }\n\n                         boolean d = inner.isDone();\n\n                         R v;\n\n                         try {\n                              v = q.poll();\n                         } catch (Throwable ex) {\n                              Exceptions.throwIfFatal(ex);\n                              current = null;\n                              inner.cancel();\n                              cancelAll();\n                              a.onError(ex);\n                              return;\n                         }\n\n                         boolean empty = v == null;\n\n                         if (d && empty) {\n                              inner = null;\n                              current = null;\n                              upstream.request(1);\n                              continueNextSource = true;\n                              break;\n                         }\n\n                         if (empty) {\n                              break;\n                         }\n\n                         a.onNext(v);\n                         e++;\n                         inner.request(1L);\n                    }\n                    if (e == r) {\n                         if (cancelled) {\n                              cancelAll();\n                              return;\n                         }\n                         if (em == ErrorMode.IMMEDIATE) {\n                              Throwable ex = errors.get();\n                              \n                              if (ex != null) {\n                                   current = null;\n                                   inner.cancel();\n                                   cancelAll();\n                                   errors.tryTerminateConsumer(downstream);\n                                   return;\n                              }\n                         }\n\n                         boolean d = inner.isDone();\n\n                         boolean empty = q.isEmpty();\n\n                         if (d && empty) {\n                              inner = null;\n                              current = null;\n                              upstream.request(1);\n                              continueNextSource = true;\n                         }\n                    }\n               }\n          }\n\n          if (e != 0L && r != Long.MAX_VALUE) {\n               requested.addAndGet(-e);\n          }\n\n          if (!continueNextSource) { \n               missed = addAndGet(-missed);\n               if (missed == 0) {\n                    break;\n               }\n          } \n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "167", "src_id": "M469", "code": "@SuppressWarnings(\"unchecked\") void remove(CacheDisposable<T> consumer) {\n     while (true) {\n          CacheDisposable<T>[] current = observers.get();\n          \n          int n = current.length;\n          \n          if (n == 0) {\n               return;\n          }\n          int j = -1;\n          for (int i = 0; i < n; i++) {\n               if (current[i] == consumer) {\n                    j = i;\n                    break;\n               }\n          }\n          if (j < 0) {\n               return;\n          }\n          \n          CacheDisposable<T>[] next;\n\n          if (n == 1) {\n               next = EMPTY;\n          } else {\n               next = new CacheDisposable[n - 1];\n               System.arraycopy(current, 0, next, 0, j);\n               \n               System.arraycopy(current, j + 1, next, j, n - j - 1);\n          }\n\n          if (observers.compareAndSet(current, next)) {\n               return;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "168", "src_id": "M362", "code": "void drainFused() {\n     int missed = 1;\n     while (true) {\n          if (disposed) {\n               return;\n          }\n          boolean d = done;\n          Throwable ex = error;\n\n          if (!delayError && d && ex != null) {\n               disposed = true;\n               downstream.onError(error);\n               worker.dispose();\n               return;\n          }\n\n          downstream.onNext(null);\n\n          if (d) {\n               disposed = true;\n               ex = error;\n               if (ex != null) {\n                    downstream.onError(ex);\n               } else {\n                    downstream.onComplete();\n               }\n               worker.dispose();\n               return;\n          }\n\n          missed = addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "169", "src_id": "M2247", "code": "@SuppressWarnings(\"unchecked\") void remove(PublishSubscription<T> ps) {\n     while (true) {\n          PublishSubscription<T>[] a = subscribers.get();\n          \n          if (a == TERMINATED || a == EMPTY) {\n               return;\n          }\n\n          int n = a.length;\n          int j = -1;\n          for (int i = 0; i < n; i++) {\n               if (a[i] == ps) {\n                    j = i;\n                    break;\n               }\n          }\n          if (j < 0) {\n               return;\n          }\n\n          PublishSubscription<T>[] b;\n\n          if (n == 1) {\n               b = EMPTY;\n          } else \n          {\n               b = new PublishSubscription[n - 1];\n               System.arraycopy(a, 0, b, 0, j);\n               System.arraycopy(a, j + 1, b, j, n - j - 1);\n          }\n          \n          if (subscribers.compareAndSet(a, b)) {\n               return;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "95", "src_id": "M270", "code": "    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n\n        if (value.matches(\"^(ia64w?|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n\n        if (\"ia64n\".equals(value)) {\n            return \"itanium_32\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(mips|mips32)$\")) {\n            return \"mips_32\";\n        }\n        if (value.matches(\"^(mipsel|mips32el)$\")) {\n            return \"mipsel_32\";\n        }\n        if (\"mips64\".equals(value)) {\n            return \"mips_64\";\n        }\n        if (\"mips64el\".equals(value)) {\n            return \"mipsel_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (value.matches(\"^(ppcle|ppc32le)$\")) {\n            return \"ppcle_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n        return value;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "96", "src_id": "M928", "code": "    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n        Map<String, Object> info = new HashMap<String, Object>();\n        info.put(LoggerHelper.name, logger.getName());\n\n        info.put(LoggerHelper.clazz, logger.getClass());\n        CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n\n        if (codeSource != null) {\n            info.put(LoggerHelper.codeSource, codeSource.getLocation());\n        }\n\n        info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n        Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n\n        if (level != null) {\n            info.put(LoggerHelper.level, level.toString());\n        }\n        if (effectiveLevel != null) {\n            info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n        }\n        @SuppressWarnings(\"unchecked\") List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n        info.put(LoggerHelper.appenders, result);\n        return info;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "97", "src_id": "M9", "code": "    @SuppressWarnings(\"resource\")\n    public static long select(boolean v, long telnetPortPid, String select) \n    throws InputMismatchException {\n        Map<Long, String> processMap = listProcessByJps(v);\n        // Put the port that is already listening at the first\n        if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n            String telnetPortProcess = processMap.get(telnetPortPid);\n            processMap.remove(telnetPortPid);\n\n            Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n\n            newProcessMap.put(telnetPortPid, telnetPortProcess);\n\n            newProcessMap.putAll(processMap);\n            processMap = newProcessMap;\n        }\n        if (processMap.isEmpty()) {\n            AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n            return -1;\n        }\n        // select target process by the '--select' option when match only one process\n        if (select != null && !select.trim().isEmpty()) {\n            int matchedSelectCount = 0;\n            Long matchedPid = null;\n\n            for (Entry<Long, String> entry : processMap.entrySet()) {\n                if (entry.getValue().contains(select)) {\n                    matchedSelectCount++;\n                    matchedPid = entry.getKey();\n                }\n            }\n            if (matchedSelectCount == 1) {\n                return matchedPid;\n            }\n        }\n        AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n        // print list\n        int count = 1;\n        for (String process : processMap.values()) {\n            if (count == 1) {\n                System.out.println(\"* [\" + count + \"]: \" + process);\n            } else {\n                System.out.println(\"  [\" + count + \"]: \" + process);\n            }\n            count++;\n        }\n\n        // read choice\n        String line = new Scanner(System.in).nextLine();\n        if (line.trim().isEmpty()) {\n            // get the first process id\n            return processMap.keySet().iterator().next();\n        }\n        int choice = new Scanner(line).nextInt();\n        if (choice <= 0 || choice > processMap.size()) {\n            return -1;\n        }\n\n        Iterator<Long> idIter = processMap.keySet().iterator();\n\n        for (int i = 1; i <= choice; ++i) {\n            if (i == choice) {\n                return idIter.next();\n            }\n            idIter.next();\n        }\n\n        return -1;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "98", "src_id": "M140", "code": "    void _processDo(int option) throws IOException {\n        if (debugoptions) {\n            System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n        }\n        if (__notifhand != null) {\n            __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n        }\n\n        boolean acceptNewState = false; /* open TelnetOptionHandler functionality (start)*/\n        if (optionHandlers[option] != null) {\n            acceptNewState = optionHandlers[option].getAcceptLocal();\n        } else { /* open TelnetOptionHandler functionality (end)*//* TERMINAL-TYPE option (start)*/\n            if (option == TERMINAL_TYPE && ((terminalType != null) && (terminalType.length() > 0))) {\n                acceptNewState = true;\n            }\n        }/* open TelnetOptionHandler functionality (end)*/\n        if (_willResponse[option] > 0) {\n            --_willResponse[option];\n            if (_willResponse[option] > 0 && _stateIsWill(option)) {\n                --_willResponse[option];\n            }\n        }\n        if (_willResponse[option] == 0) {\n            if (!_requestedWont(option)) { // Other end has acknowledged option.\n\n                switch (option)\n                {\n\n                    default:\n                        break;\n\n                }\n            }\n            else {\n                switch (option)\n                {\n\n                    default:\n                        break;\n\n                }\n                if (acceptNewState) {\n                    _setWantWill(option);\n                    _sendWill(option);\n                } else {\n                    _willResponse[option]++; \n                    _sendWont(option);\n                }\n            }\n        }\n        _setWill(option);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "99", "src_id": "M1324", "code": "    private void bind(Configure configure) throws Throwable {\n        long start = System.currentTimeMillis();\n        if (!isBindRef.compareAndSet(false, true)) {\n            throw new IllegalStateException(\"already bind\");\n        }\n        // init random port\n        if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n            int newTelnetPort = SocketUtils.findAvailableTcpPort();\n            configure.setTelnetPort(newTelnetPort);\n            logger().info(\"generate random telnet port: \" + newTelnetPort);\n        }\n        if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n            int newHttpPort = SocketUtils.findAvailableTcpPort();\n            configure.setHttpPort(newHttpPort);\n            logger().info(\"generate random http port: \" + newHttpPort);\n        }\n        // try to find appName\n        if (configure.getAppName() == null) {\n            configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n        }\n        try {\n            if (configure.getTunnelServer() != null) {\n                tunnelClient = new TunnelClient();\n                tunnelClient.setAppName(configure.getAppName());\n                tunnelClient.setId(configure.getAgentId());\n                tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n                tunnelClient.setVersion(ArthasBanner.version());\n                ChannelFuture channelFuture = tunnelClient.start();\n                channelFuture.await(10, TimeUnit.SECONDS);\n            }\n        } catch (Throwable t) {\n            logger().error(\"start tunnel client error\", t);\n        }\n        try {\n            ShellServerOptions options = new ShellServerOptions().setInstrumentation(instrumentation).setPid(PidUtils.currentLongPid())\n            .setWelcomeMessage(ArthasBanner.welcome());\n            if (configure.getSessionTimeout() != null) {\n                options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n            }\n            this.httpSessionManager = new HttpSessionManager();\n            if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n                // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n                String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \"\n                + \"No password is currently configured. \" \n                + \"Therefore, a default password is generated, \"\n                + \"and clients need to use the password to connect!\";\n                AnsiLog.error(errorMsg);\n                configure.setPassword(StringUtils.randomString(64));\n                AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n                logger().error(errorMsg);\n                logger().info(\"Generated arthas password: \" + configure.getPassword());\n            }\n            this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n            shellServer = new ShellServerImpl(options);\n            List<String> disabledCommands = new ArrayList<String>();\n            if (configure.getDisabledCommands() != null) {\n                String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n                if (strings != null) {\n                    disabledCommands.addAll(Arrays.asList(strings));\n                }\n            }\n            BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n            List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n            resolvers.add(builtinCommands);\n            //worker group\n            workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n            // TODO: discover user provided command resolver\n            if (!(configure.getTelnetPort() != null && configure.getTelnetPort() > 0)) {\n                logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n            } else {\n                logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n                shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } \n            if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n                logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n                shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else {\n                // listen local address in VM communication\n                if (configure.getTunnelServer() != null) {\n                    shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n                }\n                logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n            }\n            for (CommandResolver resolver : resolvers) {\n                shellServer.registerCommandResolver(resolver);\n            }\n            shellServer.listen(new BindHandler(isBindRef));\n            if (!isBind()) {\n                throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" + String.valueOf(configure.getTelnetPort()) \n                + \", http port: \"\n                + String.valueOf(configure.getHttpPort()));\n            }\n            //http api session manager\n            sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n            //http api handler\n            httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n            logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n            // 异步回报启动次数\n            if (configure.getStatUrl() != null) {\n                logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n            }\n            UserStatUtil.setStatUrl(configure.getStatUrl());\n\n            UserStatUtil.setAgentId(configure.getAgentId());\n            UserStatUtil.arthasStart();\n            try {\n                SpyAPI.init();\n            } catch (Throwable e) {\n            // ignore\n            }\n            logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n        } catch (Throwable e) {\n            logger().error(\"Error during start as-server\", e);\n            destroy();\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "100", "src_id": "M122", "code": "    private int __read(boolean mayBlock) throws IOException {\n        int ch;\n        while (true) {\n            // If there is no more data AND we were told not to block,\n            // just return WOULD_BLOCK (-2). (More efficient than exception.)\n            if (!mayBlock && super.available() == 0) {\n                return WOULD_BLOCK;\n            }\n            // Otherwise, exit only when we reach end of stream.\n            if ((ch = super.read()) < 0) {\n                return EOF;\n            }\n            ch = (ch & 0xff); /* Code Section added for supporting AYT (start)*/\n            synchronized (__client)\n            {\n                __client._processAYTResponse();\n            }/* Code Section added for supporting AYT (end)*//* Code Section added for supporting spystreams (start)*/\n            __client._spyRead(ch); /* Code Section added for supporting spystreams (end)*/\n            switch (__receiveState) {\n                case _STATE_CR:\n                    if (ch == '\\0')\n                    {\n                        // Strip null\n                        continue;\n                    }// How do we handle newline after cr?\n                    //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n                    // Handle as normal data by falling through to _STATE_DATA case\n\n                    //$FALL-THROUGH$\n                case _STATE_DATA:\n                    if (ch == TelnetCommand.IAC) {\n                        __receiveState = _STATE_IAC;\n                        continue;\n                    }\n                    if (ch != '\\r') {\n                        __receiveState = _STATE_DATA;\n                    }\n                    else {\n                        synchronized (__client)\n                        {\n                            if (__client._requestedDont(TelnetOption.BINARY)) {\n                                __receiveState = _STATE_CR;\n                            } else {\n                                __receiveState = _STATE_DATA;\n                            }\n                        }\n                    } \n                    break;\n                case _STATE_IAC:\n                    switch (ch) {\n                        case TelnetCommand.WILL:\n                            __receiveState = _STATE_WILL;\n                            continue;\n                        case TelnetCommand.WONT:\n                            __receiveState = _STATE_WONT;\n                            continue;\n                        case TelnetCommand.DO:\n                            __receiveState = _STATE_DO;\n                            continue;\n                        case TelnetCommand.DONT:\n                            __receiveState = _STATE_DONT;\n                            continue; /* TERMINAL-TYPE option (start)*/\n                        case TelnetCommand.SB:\n                            __suboption_count = 0;\n                            __receiveState = _STATE_SB;\n                            continue; /* TERMINAL-TYPE option (end)*/\n                        case TelnetCommand.IAC:\n                            __receiveState = _STATE_DATA;\n                            break; // exit to enclosing switch to return IAC from read\n                        case TelnetCommand.SE : // unexpected byte! ignore it (don't send it as a command)\n                            __receiveState = _STATE_DATA;\n                            continue;\n                        default:\n                            __receiveState = _STATE_DATA;\n                            __client._processCommand(ch); // Notify the user\n                            continue; // move on the next char\n                    }\n                    break; // exit and return from read\n                case _STATE_WILL:\n                    synchronized (__client)\n                    {\n                        __client._processWill(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n                case _STATE_WONT:\n                    synchronized (__client)\n                    {\n                        __client._processWont(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n                case _STATE_DO:\n                    synchronized (__client)\n                    {\n                        __client._processDo(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n                case _STATE_DONT:\n                    synchronized (__client)\n                    {\n                        __client._processDont(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue; /* TERMINAL-TYPE option (start)*/\n                case _STATE_SB:\n                    switch (ch) {\n                        case TelnetCommand.IAC:\n                            __receiveState = _STATE_IAC_SB;\n                            continue;\n                        default:\n                            // store suboption char\n                            if (__suboption_count < __suboption.length) {\n                                __suboption[__suboption_count++] = ch;\n                            }\n                            break;\n                    }\n                    __receiveState = _STATE_SB;\n\n                    continue;\n                case _STATE_IAC_SB : // IAC received during SB phase\n                    switch (ch) {\n                        case TelnetCommand.SE:\n                            synchronized (__client)\n                            {\n                                __client._processSuboption(__suboption, __suboption_count);\n                                __client._flushOutputStream();\n                            }\n                            __receiveState = _STATE_DATA;\n                            continue;\n                        case TelnetCommand.IAC : // De-dup the duplicated IAC\n                            if (__suboption_count < __suboption.length) {\n                                __suboption[__suboption_count++] = ch;\n                            }\n                            break;\n                        default :            // unexpected byte! ignore it\n                            break;\n                    }\n                    __receiveState = _STATE_SB;\n                    continue; /* TERMINAL-TYPE option (end)*/\n            }\n            break;\n        }\n        return ch;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "101", "src_id": "M8", "code": "    private static String formatFileSize(long size) {\n        String hrSize;\n        double b = size, k = size / 1024.0;\n        double m = ((size / 1024.0) / 1024.0), g = (((size / 1024.0) / 1024.0) / 1024.0);\n        double t = ((((size / 1024.0) / 1024.0) / 1024.0) / 1024.0);\n        DecimalFormat dec = new DecimalFormat(\"0.00\");\n        if (t > 1) {\n            hrSize = dec.format(t).concat(\" TB\");\n        } else {\n            if (g <= 1) {\n                if (m > 1) {\n                    hrSize = dec.format(m).concat(\" MB\");\n                } else {\n                    if (k > 1) {\n                        hrSize = dec.format(k).concat(\" KB\");\n                    } else {\n                        hrSize = dec.format(b).concat(\" Bytes\");\n                    }\n                }\n            }else {\n                hrSize = dec.format(g).concat(\" GB\");\n            } \n        }\n        return hrSize;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "102", "src_id": "M790", "code": "    @Override\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) \n    throws IllegalClassFormatException {\n        if (className == null) {\n            return null;\n        }\n        className = className.replace('/', '.');\n\n        List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n        // 倒序，因为要执行的配置生效\n        ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n        while (listIterator.hasPrevious()) {\n            RetransformEntry retransformEntry = listIterator.previous();\n            int id = retransformEntry.getId();\n            // 判断类名是否一致\n            boolean updateFlag = false;\n            // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n            if (className.equals(retransformEntry.getClassName())) {\n                if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) {\n                    updateFlag = isLoaderMatch(retransformEntry, loader);\n                } else {\n                    updateFlag = true;\n                }\n            }\n            if (updateFlag) {\n                logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n                retransformEntry.incTransformCount();\n                return retransformEntry.getBytes();\n            }\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "103", "src_id": "M716", "code": "    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n        // 执行失败:输出失败状态\n        table.row(\"IS-RETURN\", \"\" + false);\n        table.row(\"IS-EXCEPTION\", \"\" + true);\n        // 执行失败:输出失败异常信息\n        Throwable cause, t = (Throwable) throwableVO.getObject();\n        if (t instanceof InvocationTargetException) {\n            cause = t.getCause();\n        } else {\n            cause = t;\n        }\n        if (throwableVO.needExpand()) {\n            table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n        } else {\n            StringWriter stringWriter = new StringWriter();\n            PrintWriter printWriter = new PrintWriter(stringWriter);\n\n            try {\n                cause.printStackTrace(printWriter);\n                table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n            } finally {\n                printWriter.close();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "104", "src_id": "M602", "code": "    private AsyncProfiler profilerInstance() {\n        if (profiler != null) {\n            return profiler;\n        }\n        // try to load from special path\n        if (ProfilerAction.load.toString().equals(action)) {\n            profiler = AsyncProfiler.getInstance(this.actionArg);\n        }\n        if (libPath == null) {\n            if (OSUtils.isLinux() || OSUtils.isMac()) {\n                throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n            } else {\n                throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n            }\n        } else {\n            // load from arthas directory\n            // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n            FileOutputStream tmpLibOutputStream = null;\n            FileInputStream libInputStream = null;\n            try {\n                File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n                tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n                libInputStream = new FileInputStream(libPath);\n                IOUtils.copy(libInputStream, tmpLibOutputStream);\n                libPath = tmpLibFile.getAbsolutePath();\n                logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n            } catch (Throwable e) {\n                logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n            } finally {\n                IOUtils.close(libInputStream);\n                IOUtils.close(tmpLibOutputStream);\n            }\n            profiler = AsyncProfiler.getInstance(libPath);\n        } \n        return profiler;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "367", "src_id": "M1043", "code": "    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n\n            return;\n        }\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "368", "src_id": "M1031", "code": "    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // let the download thread handle this error\n            default:\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "369", "src_id": "M827", "code": "    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n\n        final boolean v1 = stream.read() == 1;\n\n        stream.skipBytes(3); // flags\n\n        final int entryCount = stream.readInt();\n\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n\n        if (!v1) {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        } else {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } \n\n        obj.bMediaRate = stream.readInt();\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "370", "src_id": "M1048", "code": "    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n        try {\n            long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n            int mId = 1;\n\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n            if (!mMission.unknownLength)\n            {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n\n            mF.seek(mMission.offsets[mMission.current] + start);\n\n            mIs = mConn.getInputStream();\n\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n\n            int len = 0;\n\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n            dispose();\n\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n\n            run(); // try again\n            return;\n        }\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "371", "src_id": "M1141", "code": "    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n        out.flush();\n        aux.flush();\n\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n\n        out.target.seek(out.length);\n        long length = amount;\n\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n\n            out.writeProof(buffer, read);\n\n            length -= read;\n        }\n        if (!underflow) {\n            out.offset += amount;\n            aux.offset -= amount;\n        } else {\n            if (out.offset < out.length) {\n                aux.offset = 0;\n            } else {\n                // calculate the aux underflow pointer\n                if (aux.offset >= amount) {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                } else {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } \n            } \n        } \n        out.length += amount;\n\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n            aux.length -= amount;\n            length = aux.length;\n\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                aux.target.seek(writeOffset);\n\n                aux.writeProof(buffer, read);\n\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n\n            return;\n        }\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n        }\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "372", "src_id": "M1106", "code": "    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n\n        request.append(\" [\");\n\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n            {\n                request.append(' ').append(recovery.toString()).append(' ');\n            }\n        }\n\n        request.append(\"]\");\n\n        String service;\n\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "373", "src_id": "M1067", "code": "    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n\n            mission.maxRetry = mPrefMaxRetry;\n            // create metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile())\n                        {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n\n                mission.timestamp = System.currentTimeMillis();\n            }\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                // noting to do here\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null)\n                {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n\n                return;\n            }\n\n            boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "374", "src_id": "M1136", "code": "    @Override int process(SharpStream out, SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n        if (!(format == null || format.equals(\"ttml\"))) {\n            if (format.equals(\"srt\")) {\n                byte[] buffer = new byte[8 * 1024];\n                int read;\n\n                while ((read = sources[0].read(buffer)) > 0) {\n                    out.write(buffer, 0, read);\n                }\n\n                return OK_RESULT;\n            }\n        } else {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                if (err instanceof IOException) { \n                    return 1; \n                } else { \n                    return 8; \n                } \n            }\n\n            return OK_RESULT;\n        } \n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "375", "src_id": "M1047", "code": "    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n            }\n        }\n        // if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == Thread.currentThread()) {\n                continue;\n            }\n            thread.interrupt();\n        }\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue;\n                }\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n\n                if (millis > 0) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "125", "src_id": "M342", "code": "private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n     if (emlBytes == null || emlBytes.length == 0) {\n          throw new IllegalArgumentException(\"EML file is empty or null\");\n     }\n     String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n     // Basic email parsing\n     String subject = extractBasicHeader(emlContent, \"Subject:\");\n     \n     String from = extractBasicHeader(emlContent, \"From:\");\n     \n     String to = extractBasicHeader(emlContent, \"To:\");\n     \n     String cc = extractBasicHeader(emlContent, \"Cc:\");\n     \n     String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n     \n     String date = extractBasicHeader(emlContent, \"Date:\");\n\n     // Try to extract HTML content\n     String htmlBody = extractHtmlBody(emlContent);\n     \n     if (htmlBody == null) {\n          String textBody = extractTextBody(emlContent);\n          htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n     }\n\n     // Generate HTML with custom styling based on request\n     StringBuilder html = new StringBuilder();\n     \n     html.append(\"<!DOCTYPE html>\\n\");\n     \n     html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n     \n     html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n     \n     html.append(\"<style>\\n\");\n     \n     appendEnhancedStyles(html);\n     html.append(\"</style>\\n\");\n     html.append(\"</head><body>\\n\");\n     html.append(\"<div class=\\\"email-container\\\">\\n\");\n     \n     html.append(\"<div class=\\\"email-header\\\">\\n\");\n     \n     html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n     \n     html.append(\"<div class=\\\"email-meta\\\">\\n\");\n     \n     html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n     \n     html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n     // Include CC and BCC if present and requested\n     if (request != null && request.isIncludeAllRecipients()) {\n          if (!cc.trim().isEmpty()) {\n               html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n          }\n          if (!bcc.trim().isEmpty()) {\n               html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n          }\n     }\n\n     if (!date.trim().isEmpty()) {\n          html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n     }\n     \n     html.append(\"</div></div>\\n\");\n\n     html.append(\"<div class=\\\"email-body\\\">\\n\");\n     \n     html.append(processEmailHtmlBody(htmlBody));\n     \n     html.append(\"</div>\\n\");\n\n     // Add attachment information - always check for and display attachments\n     String attachmentInfo = extractAttachmentInfo(emlContent);\n     \n     if (!attachmentInfo.isEmpty()) {\n          html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n          \n          html.append(\"<h3>Attachments</h3>\\n\");\n          \n          html.append(attachmentInfo);\n\n          // Add a status message about attachment inclusion\n          if (request != null && request.isIncludeAttachments()) {\n               html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n               html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n               \n               html.append(\"</div>\\n\");\n          } else {\n               html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n               html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n               \n               html.append(\"</div>\\n\");\n          }\n\n          html.append(\"</div>\\n\");\n     }\n\n     // Show advanced features status if requested\n     assert request != null;\n     \n     if (request.getFileInput().isEmpty()) {\n          html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n          html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n          \n          html.append(\"</div>\\n\");\n     }\n\n     html.append(\"</div>\\n\");\n     \n     html.append(\"</body></html>\");\n     return html.toString();\n}\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "126", "src_id": "M371", "code": "private static boolean isValidJakartaMailMultipart(Object multipart) {\n     if (multipart == null) {\n          return false;\n     }\n     try {\n          // Check if the object implements jakarta.mail.Multipart interface\n          Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n          if (!multipartInterface.isInstance(multipart)) {\n               return false;\n          }\n\n          // Additional check for MimeMultipart\n          try {\n               Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n               if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    \n                    return true;\n               }\n          } catch (ClassNotFoundException e) {\n               log.debug(\"MimeMultipart not available, using base Multipart interface\");\n          }\n\n          return true;\n     } catch (ClassNotFoundException e) {\n          log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n          \n          return false;\n     }\n}\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "127", "src_id": "M348", "code": "private static String extractBasicHeader(String emlContent, String headerName) {\n     try {\n          String[] lines = emlContent.split(\"\\r?\\n\");\n          for (int i = 0; i < lines.length; i++) {\n               String line = lines[i];\n               if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                         if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                              value.append(\" \").append(lines[j].trim());\n                         } else {\n                              break;\n                         }\n                    }\n                    \n                    // Apply MIME header decoding\n                    return safeMimeDecode(value.toString());\n               }\n               \n               if (line.trim().isEmpty()) {\n                    break;\n               }\n          }\n     } catch (RuntimeException e) {\n          log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n     }\n     return \"\";\n}\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "128", "src_id": "M364", "code": "private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n     if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n          return;\n     }\n     // 1. Find the screen position of all attachment markers\n     AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n     \n     finder.setSortByPosition(true); // Process pages in order\n     \n     finder.getText(document);\n     \n     List<MarkerPosition> markerPositions = finder.getPositions();\n\n     // 2. Warn if the number of markers and attachments don't match\n     if (markerPositions.size() != attachments.size()) {\n          log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n     }\n\n     // 3. Create an invisible annotation over each found marker\n     int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n     \n     for (int i = 0; i < annotationsToAdd; i++) {\n          MarkerPosition position = markerPositions.get(i);\n          \n          EmailAttachment attachment = attachments.get(i);\n\n          if (attachment.getEmbeddedFilename() != null) {\n               PDPage page = document.getPage(position.getPageIndex());\n               addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n          }\n     }\n}\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "376", "src_id": "M1086", "code": "        public static AdminServer createAdminServer() {\n\n            if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n\n                try {\n                    Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                    Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n\n                    return (AdminServer) adminServer;\n                } catch (ClassNotFoundException e) {\n                    LOG.warn(\"Unable to start JettyAdminServer\", e);\n                } catch (InstantiationException e) {\n                    LOG.warn(\"Unable to start JettyAdminServer\", e);\n                } catch (IllegalAccessException e) {\n                    LOG.warn(\"Unable to start JettyAdminServer\", e);\n                } catch (InvocationTargetException e) {\n                    LOG.warn(\"Unable to start JettyAdminServer\", e);\n                } catch (NoSuchMethodException e) {\n                    LOG.warn(\"Unable to start JettyAdminServer\", e);\n                } catch (NoClassDefFoundError e) {\n                    LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n                }\n            }\n            return new DummyAdminServer();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "377", "src_id": "M1149", "code": "        public void run() {\n\n            try {\n                while (!stopped) {\n                    try {\n                        select();\n                        processAcceptedConnections();\n\n                        processInterestOpsUpdateRequests();\n                    } catch (RuntimeException e) {\n                        LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                    } catch (Exception e) {\n                        LOG.warn(\"Ignoring unexpected exception\", e);\n                    }\n                }\n                // Close connections still pending on the selector. Any others\n                // with in-flight work, let drain out of the work queue.\n                for (SelectionKey key : selector.keys()) {\n                    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                    if (cnxn.isSelectable()) {\n                        cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                    }\n\n                    cleanupSelectionKey(key);\n                }\n\n                SocketChannel accepted;\n\n                while ((accepted = acceptedQueue.poll()) != null) {\n                    fastCloseSock(accepted);\n                }\n\n                updateQueue.clear();\n            } finally {\n                closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n                NIOServerCnxnFactory.this.stop();\n\n                LOG.info(\"selector thread exited run method\");\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "378", "src_id": "M219", "code": "        synchronized public static ZooKeeper getClient(String contextPath,\n        String session, \n        int expireTime)throws IOException {\n            final String connectionId = concat(contextPath, session);\n            ZooKeeper zk = zkMap.get(connectionId);\n\n            if (zk == null) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n                }\n                Endpoint e = contextMap.get(contextPath);\n\n                zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n                for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                    zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n                }\n\n                zkMap.put(connectionId, zk);\n\n                // a session should automatically expire after an amount of time\n                if (session != null) {\n                    zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n                }\n            }\n\n            return zk;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "379", "src_id": "M192", "code": "        import null;private void init()throws IOException {\n            File f = new File(file);\n            RandomAccessFileReader in = new RandomAccessFileReader(f);\n\n            SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n\n            Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n\n            long lastFp = in.getPosition();\n\n            String line = in.readLine();\n\n            Matcher m = null;\n\n            // if we have read data from the file, and it matches the timep pattern\n            if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n                starttime = timestampFromText(dateformat, m.group(1));\n            } else {\n                throw new IOException(\"Invalid log format. First line doesn't start with time\");\n            }\n            /*\n\t  Count number of log entries. Any line starting with a timestamp counts as an entry\n\t*/\n\n            String lastentry = line;\n\n            try {\n                while (line != null) {\n                    m = timep.matcher(line);\n                    if (m.lookingAt()) {\n                        if (size % skipN == 0) {\n                            long time = timestampFromText(dateformat, m.group(1));\n                            skiplist.addMark(time, lastFp, size);\n                        }\n                        size++;\n\n                        lastentry = line;\n                    } \n\n                    Patterntmp = idp.matcher(line);\n\n                    if (serverid == 0 && (m = tmp).find()) {\n                        serverid = Integer.valueOf(m.group(1));\n                    }\n\n                    lastFp = in.getPosition();\n\n                    line = in.readLine();\n                }\n            } catch (EOFException eof) {\n            // ignore, simply end of file, though really (line!=null) should have caught this\n            } finally {\n                in.close();\n            }\n\n            m = timep.matcher(lastentry);\n\n            if (m.lookingAt()) {\n                endtime = timestampFromText(dateformat, m.group(1));\n            } else {\n                throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "380", "src_id": "M235", "code": "        @POST\n        @Produces( { MediaType.APPLICATION_JSON, \"application/javascript\",\n        MediaType.APPLICATION_XML })\n        public Response createSession(@QueryParam(\"op\") String op,\n        @DefaultValue(\"5\") \n        @QueryParam(\"expire\") String expire,\n        @Context UriInfo ui) {\n            if (!op.equals(\"create\")) {\n                throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n            }\n            int expireInSeconds;\n\n            try {\n                expireInSeconds = Integer.parseInt(expire);\n            } catch (NumberFormatException e) {\n                throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n            }\n\n            String uuid = UUID.randomUUID().toString();\n\n            while (ZooKeeperService.isConnected(contextPath, uuid)) {\n                uuid = UUID.randomUUID().toString();\n            }\n\n            // establish the connection to the ZooKeeper cluster\n            try {\n                ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n            } catch (IOException e) {\n                LOG.error(\"Failed while trying to create a new session\", e);\n                throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n            }\n\n            URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n\n            return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "381", "src_id": "M942", "code": "        public void schedule(WorkRequest workRequest, \n        long id) {\n            if (stopped) {\n                workRequest.cleanup();\n                return;\n            }\n            ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n\n            // If we have a worker thread pool, use that; otherwise, do the work\n            // directly.\n            int size = workers.size();\n\n            if (size > 0) {\n                try {\n                    // make sure to map negative ids as well to [0, size-1]\n                    int workerNum = ((int) (id % size) + size) % size;\n                    ExecutorService worker = workers.get(workerNum);\n\n                    worker.execute(scheduledWorkRequest);\n                } catch (RejectedExecutionException e) {\n                    LOG.warn(\"ExecutorService rejected execution\", e);\n                    workRequest.cleanup();\n                }\n            } else {\n                // When there is no worker thread pool, do the work directly\n                // and wait for its completion\n                scheduledWorkRequest.run();\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "382", "src_id": "M520", "code": "        @Override\n        public void close()throws IOException {\n            boolean triedToClose = false, success = false;\n            try {\n                flush();\n                ((FileOutputStream) out).getFD().sync();\n\n                triedToClose = true;\n\n                super.close();\n                success = true;\n            } finally {\n                if (!success) {\n                    if (!triedToClose) {\n                        // If we failed when flushing, try to close it to not leak\n                        // an FD\n                        IOUtils.closeStream(out);\n                    }\n                    // close wasn't successful, try to delete the tmp file\n                    if (!tmpFile.delete()) {\n                        LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                    }\n                } else {\n                    boolean renamed = tmpFile.renameTo(origFile);\n                    if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                        throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                    }\n                } \n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "383", "src_id": "M186", "code": "        synchronized private LogEntry readNextEntry() {\n            try {\n                try {\n                    for (;;) {\n                        String line = in.readLine();\n                        if (line == null) {\n                            break;\n                        }\n\n                        Matcher m = src.timep.matcher(line);\n\n                        if (m.lookingAt()) {\n                            if (buf.length() > 0) {\n                                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                                buf = line;\n\n                                return e;\n                            }\n                            buf = line;\n                        } else {\n                            if (buf.length() > 0) {\n                                buf += line + \"\\n\";\n                            }\n                        }\n                    }\n                } catch (EOFException eof) {\n                // ignore, we've simply come to the end of the file\n                }\n                if (buf.length() > 0) {\n                    LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                    buf = \"\";\n\n                    return e;\n                }\n            } catch (Exception e) {\n                LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n                return null;\n            }\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "384", "src_id": "M478", "code": "        public static void main(String[] args) {\n            if (args.length < 3) {\n                usage();\n                return;\n            }\n            String host = args[0];\n\n            int port = Integer.parseInt(args[1]);\n\n            String op = args[2];\n\n            if (op.equalsIgnoreCase(\"gettracemask\")) {\n                getTraceMask(host, port);\n            } else {\n                if (op.equalsIgnoreCase(\"settracemask\")) {\n                    setTraceMask(host, port, args[3]);\n                } else {\n                    if (op.equalsIgnoreCase(\"ruok\")) {\n                        ruok(host, port);\n                    } else {\n                        if (op.equalsIgnoreCase(\"kill\")) {\n                            kill(host, port);\n                        } else {\n                            if (!(op.equalsIgnoreCase(\"stat\"))) {\n                                if (op.equalsIgnoreCase(\"dump\")) {\n                                    dump(host, port);\n                                } else {\n                                    System.out.println(\"Unrecognized op: \" + op);\n                                }\n                            } else {\n                                stat(host, port);\n                            } \n                        }\n                    }\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "264", "src_id": "M1086", "code": "    public static AdminServer createAdminServer() {\n        if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            try {\n                Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n                return (AdminServer) adminServer;\n\n            } catch (ClassNotFoundException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (InstantiationException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (IllegalAccessException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (InvocationTargetException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (NoSuchMethodException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (NoClassDefFoundError e) {\n                LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n            }\n        }\n        return new DummyAdminServer();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "265", "src_id": "M1149", "code": "    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                } catch (Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n            // Close connections still pending on the selector. Any others\n            // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n\n            }\n            SocketChannel accepted;\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n            updateQueue.clear();\n\n        } finally {\n            closeSelector();\n            // This will wake up the accept thread and the other selector\n            // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "266", "src_id": "M219", "code": "    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n            zkMap.put(connectionId, zk);\n            // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n\n        }\n        return zk;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "267", "src_id": "M192", "code": "    import null;private void init() throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n        // if we have read data from the file, and it matches the timep pattern\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }/*\n\t  Count number of log entries. Any line starting with a timestamp counts as an entry\n\t*/\n        String lastentry = line;\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n\n                    }\n                    size += 1; \n                    lastentry = line;\n                } \n                Pattern tmp = idp.matcher(line);\n                if (serverid == 0 && (m = tmp).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n        } finally {\n            in.close();\n        }\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "268", "src_id": "M235", "code": "    @POST\n    @Produces( { MediaType.APPLICATION_JSON, \"application/javascript\",\n    MediaType.APPLICATION_XML })\n    public Response createSession(@QueryParam(\"op\") String op,@DefaultValue(\"5\") \n    @QueryParam(\"expire\") String expire,@Context UriInfo ui) {\n        if (!op.equals(\"create\")) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n        }\n        int expireInSeconds;\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n        String uuid = UUID.randomUUID().toString();\n        while (ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n        // establish the connection to the ZooKeeper cluster\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n\n        }\n        URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n        return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "269", "src_id": "M942", "code": "    public void schedule(WorkRequest workRequest, long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n        // If we have a worker thread pool, use that; otherwise, do the work\n        // directly.\n        int size = workers.size();\n        if (size <= 0) {\n            // When there is no worker thread pool, do the work directly\n            // and wait for its completion\n            scheduledWorkRequest.run();\n        }\n        else {\n            try {\n                // make sure to map negative ids as well to [0, size-1]\n                int workerNum = ((int) (id % size) + size) % size;\n                ExecutorService worker = workers.get(workerNum);\n                worker.execute(scheduledWorkRequest);\n\n            } catch (RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n\n            }\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "270", "src_id": "M520", "code": "    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n\n            super.close();\n            success = true;\n        } finally {\n            if (success) {\n                boolean renamed = tmpFile.renameTo(origFile);\n                if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            } else {\n                if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                    IOUtils.closeStream(out);\n                }\n                // close wasn't successful, try to delete the tmp file\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "271", "src_id": "M186", "code": "    synchronized private LogEntry readNextEntry() {\n        try {\n            try {\n                while (true) {\n                    String line = in.readLine();\n                    if (line == null) {\n                        break;\n                    }\n\n                    Matcher m = src.timep.matcher(line);\n                    if (!(m.lookingAt())) {\n                        if (buf.length() > 0) {\n                            buf += line + \"\\n\";\n                        }\n                    } else {\n                        if (buf.length() > 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n                            return e;\n                        }\n                        buf = line;\n\n                    } \n                }\n            } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n            if (buf.length() > 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n                return e;\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "272", "src_id": "M478", "code": "    public static void main(String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n        if (op.equalsIgnoreCase(\"gettracemask\")) {\n            getTraceMask(host, port);\n        } else {\n            if (!(op.equalsIgnoreCase(\"settracemask\"))) {\n                if (op.equalsIgnoreCase(\"ruok\")) {\n                    ruok(host, port);\n                } else {\n                    if (!(op.equalsIgnoreCase(\"kill\"))) {\n                        if (op.equalsIgnoreCase(\"stat\")) {\n                            stat(host, port);\n                        } else {\n                            if (op.equalsIgnoreCase(\"dump\")) {\n                                dump(host, port);\n                            } else {\n                                System.out.println(\"Unrecognized op: \" + op);\n                            }\n                        }\n                    }else {\n                        kill(host, port);\n                    } \n                }\n            }else {\n                setTraceMask(host, port, args[3]);\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "129", "src_id": "M31", "code": "    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) \n    throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n        .header(\"Content-Type\", \"application/vnd.api+json\")\n        .header(\"Accept\", \"application/vnd.api+json\")\n        // .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n        .build();\n\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n\n        if (response.statusCode() != 200) {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        } else {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n\n            log.info(\"License validity: {}\", isValid);\n\n            log.info(\"Validation detail: {}\", detail);\n\n            log.info(\"Validation code: {}\", code);\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n\n            // Extract user count, default to 1 if not specified\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } \n\n        return jsonResponse;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "130", "src_id": "M488", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")@Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description =\n    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n    throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "131", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) \n    throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            // Metadata using PDFBox\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode();\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            ObjectNode encryption = objectMapper.createObjectNode();\n            ObjectNode other = objectMapper.createObjectNode();\n            metadata.put(\"Title\", info.getTitle());\n\n            metadata.put(\"Author\", info.getAuthor());\n\n            metadata.put(\"Subject\", info.getSubject());\n\n            metadata.put(\"Keywords\", info.getKeywords());\n\n            metadata.put(\"Producer\", info.getProducer());\n\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n            // Total file size of the PDF\n            long fileSizeInBytes = inputFile.getSize();\n\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n            // Number of words, paragraphs, and images in the entire document\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n\n            int wordCount = words.length;\n\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n\n            // Number of characters in the entire document (including spaces and special characters)\n            int charCount = fullText.length();\n\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            // Initialize the flags and types\n            boolean hasCompression = false;\n\n            String compressionType = \"None\";\n\n            basicInfo.put(\"Compression\", hasCompression);\n            if (hasCompression) {\n                basicInfo.put(\"CompressionType\", compressionType);\n            }\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            String pageMode = catalog.getPageMode().name();\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n            ;\n\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n            // Generate structured summary data about PDF characteristics\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n\n            // embeed files TODO size\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n\n            // attachments TODO size\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n\n            other.set(\"Attachments\", attachmentsArray);\n\n            // Javascript\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n\n                            PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n\n            other.set(\"JavaScript\", javascriptArray);\n\n            // TODO size\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n\n                    layersArray.add(layerNode);\n                }\n            }\n\n            other.set(\"Layers\", layersArray);\n            // TODO Security\n\n\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            ArrayNode structureTreeArray;\n\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                }\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                log.error(\"exception\", e);\n            }\n\n            boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n\n            boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n            boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n            boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n            boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n            boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n            // an official ISO standard.\n            boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n            // development in 2021.\n\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            String xmpString = null;\n\n            if (pdMetadata != null) {\n                try {\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        DomXmpParser domXmpParser = new DomXmpParser();\n                        XMPMetadata xmpMeta = domXmpParser.parse(is);\n                        ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        new XmpSerializer().serialize(xmpMeta, os, true);\n                        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                    }\n                } catch (XmpParsingException e) {\n                    // XMP parsing failed, try to read raw metadata instead\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n\n            other.put(\"XMPMetadata\", xmpString);\n\n            if (!(pdfBoxDoc.isEncrypted())) {\n                encryption.put(\"IsEncrypted\", false);\n            } else {\n                encryption.put(\"IsEncrypted\", true);\n                // Retrieve encryption details using getEncryption()\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n                // Add other encryption-related properties as needed\n            } \n\n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                // Retrieve the page\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n\n                // Page-level Information\n                PDRectangle mediaBox = page.getMediaBox();\n\n                float width = mediaBox.getWidth();\n\n                float height = mediaBox.getHeight();\n\n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n\n                pageInfo.set(\"Size\", sizeInfo);\n\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                // Assuming the following boxes are defined for your document; if not, you may get\n                // null values.\n                PDRectangle cropBox = page.getCropBox();\n                pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n                PDRectangle bleedBox = page.getBleedBox();\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n                PDRectangle trimBox = page.getTrimBox();\n                pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n                PDRectangle artBox = page.getArtBox();\n                pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n                // Content Extraction\n                PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n\n                textStripper.setEndPage(pageNum + 1);\n\n                String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length()); //\n\n                // Annotations\n\n                List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n\n                int contentsCount = 0;\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) {\n                        subtypeCount++; // Increase subtype count\n                    }\n                    if (annotation.getContents() != null) {\n                        contentsCount++; // Increase contents count\n                    }\n                }\n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n                // Images (simplified)\n                // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                // Here is a basic structure to recognize image XObjects on a page.\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                PDResources resources = page.getResources();\n\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n\n                        imageNode.put(\"Height\", image.getHeight());\n\n                        if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n\n                        imagesArray.add(imageNode);\n                    }\n                }\n\n                pageInfo.set(\"Images\", imagesArray);\n\n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n                Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri); // Add to set to ensure uniqueness\n                    }\n                }\n\n                // Add unique URIs to linksArray\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n\n                    linksArray.add(linkNode);\n                }\n\n                pageInfo.set(\"Links\", linksArray);\n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n\n                    // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                    fontNode.put(\"Name\", font.getName());\n\n                    fontNode.put(\"Subtype\", font.getType());\n\n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        // Font stretch and BBox are not directly available in PDFBox's API, so\n                        // these are omitted for simplicity\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n\n                    // Create a unique key for this font node based on its attributes\n                    String uniqueKey = fontNode.toString();\n\n                    // Increment count if this font exists, or initialize it if new\n                    if (!(uniqueFontsMap.containsKey(uniqueKey))) {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    } else {\n                        ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        int count = existingFontNode.get(\"Count\").asInt() + 1;\n                        existingFontNode.put(\"Count\", count);\n                    } \n                }\n\n                // Add unique font entries to fontsArray\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n\n                pageInfo.set(\"Fonts\", fontsArray);\n                // Access resources dictionary\n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n\n                for (COSName name : colorSpaceNames) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        byte[] iccBytes = iccData.toByteArray();\n\n                        // TODO: Further decode and analyze the ICC data if needed\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n                // Other XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType;\n                    if (xObject instanceof PDImageXObject) {\n                        xObjectType = \"Image\";\n                    } else {\n                        if (xObject instanceof PDFormXObject) {\n                            xObjectType = \"Form\";\n                        } else {\n                            xObjectType = \"Other\";\n                        }\n                        // Increment the count for this type in the map\n                    }\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n\n                // Add the count map to pageInfo (or wherever you want to store it)\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n                ArrayNode multimediaArray = objectMapper.createArrayNode();\n\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        ObjectNode multimediaNode = objectMapper.createObjectNode();\n                        // Extract details from the annotation as needed\n                        multimediaArray.add(multimediaNode);\n                    }\n                }\n\n                pageInfo.set(\"Multimedia\", multimediaArray);\n\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n\n            jsonOutput.set(\"Compliancy\", compliancy);\n\n            jsonOutput.set(\"Encryption\", encryption);\n\n            jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n\n            jsonOutput.set(\"Other\", other);\n\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n            // Save JSON to file\n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n\n            return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n\n        return null;\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "132", "src_id": "M24", "code": "    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n\n            String encryptedData = \"\";\n\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n\n                encodedSignature = (String) attrs.get(\"sig\");\n\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            // Verify license file algorithm\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            // Verify signature\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n            log.info(\"License file signature is valid\");\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            // Process the certificate data\n            boolean isValid = processCertificateData(decodedData, context);\n\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "133", "src_id": "M403", "code": "    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n    throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (!(entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\"))) {\n                            Files.copy(zipIn, filePath);\n                        } else {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } \n                    }\n\n                    zipIn.closeEntry();\n\n                    entry = zipIn.getNextEntry();\n                }\n            }\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "134", "src_id": "M317", "code": "    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n    throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize; \n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth()); \n        } else {\n            pageSize = PDRectangle.A4; \n        } \n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n        float pageWidth = page.getMediaBox().getWidth();\n\n        float pageHeight = page.getMediaBox().getHeight();\n\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else {\n                if (\"maintainAspectRatio\".equals(fitOption)) {\n                    float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                    float pageAspectRatio = pageWidth / pageHeight;\n\n                    float scaleFactor = 1.0f;\n                    if (imageAspectRatio > pageAspectRatio) {\n                        scaleFactor = pageWidth / image.getWidth();\n                    } else {\n                        scaleFactor = pageHeight / image.getHeight();\n                    }\n                    float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                    float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                    contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n                }\n            }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": false, "test_passed": false, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "135", "src_id": "M307", "code": "    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n            if (network != null) {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                }\n            }// Hash the MAC address for privacy and consistency\n            else {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } \n\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "136", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "137", "src_id": "M128", "code": "    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n            if (!isKubernetes) {\n                if (isDocker) {\n                    return \"Docker\";\n                } else {\n                    if (!isBrowserOpen) {\n                        return \"Server-jar\";\n                    } else {\n                        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                        if (os.contains(\"win\")) {\n                            return \"Client-windows\";\n                        } else {\n                            if (os.contains(\"mac\")) {\n                                return \"Client-mac\";\n                            } else {\n                                return \"Client-unix\";\n                            }\n                        }\n                    } \n                }\n            }else {\n                return \"Kubernetes\";\n            } \n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "138", "src_id": "M101", "code": "    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n    throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n", "compilable": true, "test_passed": true, "successful_trans": ""}
{"project_name": "across-project", "pair_id": "385", "src_id": "M66", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        Observer<? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n                if (errors.get() != null && !delayErrors) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                boolean d = done;\n\n                SwitchMapMaybeObserver<R> current = inner.get();\n                boolean empty = current == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (empty || current.item == null) {\n                    break;\n                }\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "386", "src_id": "M1333", "code": "    @Override\n    public void onNext(T t) {\n        if (done) {\n            return;\n        }\n        boolean b;\n\n        try {\n            b = predicate.test(t);\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            downstream.onSuccess(false);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "387", "src_id": "M522", "code": "    void drainLoop() {\n        Observer<? super T> actual = this.downstream;\n        int missed = 1;\n        for (;;) {\n            for (;;) {\n                if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n                    return;\n                }\n                int os = otherState;\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                T v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                actual.onNext(v);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "388", "src_id": "M1163", "code": "    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        final SimplePlainQueue<Object> queue = this.queue;\n\n        final Subscriber<? super Flowable<T>> downstream = this.downstream;\n        UnicastProcessor<T> window = this.window;\n        for (;;) {\n            if (upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n                        downstream.onComplete();\n                    }\n\n                    cleanupResources();\n\n                    upstreamCancelled = true;\n                    continue;\n                } else {\n                    if (!isEmpty) {\n                        if (o instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else {\n                            if (window != null) {\n                                @SuppressWarnings(\"unchecked\") T item = (T) o;\n                                window.onNext(item);\n                                long count = this.count + 1;\n                                if (count != maxSize) {\n                                    this.count = count;\n                                }\n                                else {\n                                    this.count = 0;\n                                    window = createNewWindow(window);\n                                } \n                            }\n                        }\n                        continue;\n                    }\n                }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "389", "src_id": "M478", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        EqualObserver<T>[] as = observers;\n        final EqualObserver<T> observer1 = as[0];\n\n        final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n\n        final EqualObserver<T> observer2 = as[1];\n        final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n                boolean d1 = observer1.done;\n                if (d1) {\n                    Throwable e = observer1.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                boolean d2 = observer2.done;\n\n                if (d2) {\n                    Throwable e = observer2.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n                boolean e1 = v1 == null;\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n                boolean e2 = v2 == null;\n                if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n                if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(v1, v2);\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    v1 = null;\n                    v2 = null;\n                }\n                if (e1 || e2) {\n                    break;\n                }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "390", "src_id": "M885", "code": "    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T>[] s = this.subscribers;\n        int n = s.length;\n        Subscriber<? super T> a = this.downstream;\n        for (;;) {\n            long r = requested.get(), e = 0;\n            middle:\n            while (e != r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n                boolean d = done.get() == 0, empty = true;\n                for (int i = 0; i < s.length; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimplePlainQueue<T> q = inner.queue;\n                    if (q != null) {\n                        T v = q.poll();\n                        if (v != null) {\n                            empty = false;\n                            a.onNext(v);\n                            inner.requestOne();\n                            if (++e == r) {\n                                break middle;\n                            }\n                        }\n                    }\n                }\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n            }\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n                boolean d = done.get() == 0, empty = true;\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimpleQueue<T> q = inner.queue;\n\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "391", "src_id": "M1399", "code": "    @Override\n    public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        InnerQueuedSubscriber<R> inner = current;\n        Subscriber<? super R> a = downstream;\n        ErrorMode em = errorMode;\n        for (;;) {\n            long r = requested.get(), e = 0L;\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n                boolean outerDone = done;\n                inner = subscribers.poll();\n                if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n            boolean continueNextSource = false;\n            if (inner != null) {\n                SimpleQueue<R> q = inner.queue();\n                if (q != null) {\n                    while (e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n\n                        R v;\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n                        if (empty) {\n                            break;\n                        }\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n                        boolean d = inner.isDone(), empty = q.isEmpty();\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n            if (!continueNextSource) { \n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "392", "src_id": "M469", "code": "    @SuppressWarnings(\"unchecked\") void remove(CacheDisposable<T> consumer) {\n        for (;;) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n            if (n == 0) {\n                return;\n            }\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n            CacheDisposable<T>[] next;\n\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "393", "src_id": "M362", "code": "    void drainFused() {\n        int missed = 1;\n        for (;;) {\n            if (disposed) {\n                return;\n            }\n            boolean d = done;\n            Throwable ex = error;\n            if (!delayError && d && ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n            downstream.onNext(null);\n            if (d) {\n                disposed = true;\n                ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n                worker.dispose();\n                return;\n            }\n\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "394", "src_id": "M2247", "code": "    @SuppressWarnings(\"unchecked\") void remove(PublishSubscription<T> ps) {\n        for (;;) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n            int n = a.length, j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n            PublishSubscription<T>[] b;\n\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "213", "src_id": "M1086", "code": "    public static AdminServer createAdminServer() {\n        if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            try {\n                Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n                return (AdminServer) adminServer;\n            } catch (ClassNotFoundException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (InstantiationException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (IllegalAccessException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (InvocationTargetException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (NoSuchMethodException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (NoClassDefFoundError e) {\n                LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n            }\n        }\n        return new DummyAdminServer();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "214", "src_id": "M1149", "code": "    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                } catch (Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n            // Close connections still pending on the selector. Any others\n            // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n\n            updateQueue.clear();\n        } finally {\n            closeSelector();\n            // This will wake up the accept thread and the other selector\n            // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "215", "src_id": "M219", "code": "    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) \n    throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n\n            zkMap.put(connectionId, zk);\n\n            // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n\n        return zk;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "216", "src_id": "M192", "code": "    private void init() throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n\n        String line = in.readLine();\n        Matcher m = null;\n        // if we have read data from the file, and it matches the timep pattern\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }/*\n\t  Count number of log entries. Any line starting with a timestamp counts as an entry\n\t*/\n        String lastentry = line;\n\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n\n                    lastentry = line;\n                } \n\n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n\n                lastFp = in.getPosition();\n\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n        } finally {\n            in.close();\n        }\n\n        m = timep.matcher(lastentry);\n\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "217", "src_id": "M235", "code": "    @POST@Produces( {MediaType.APPLICATION_JSON, \"application/javascript\",\n    MediaType.APPLICATION_XML})\n    public Response createSession(@QueryParam(\"op\") String op,@DefaultValue(\"5\") @QueryParam(\"expire\") String expire,@Context UriInfo ui) {\n        if (!op.equals(\"create\")) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\"))\n            .build());\n        }\n        int expireInSeconds;\n\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n        String uuid = UUID.randomUUID().toString();\n\n        while (ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n\n        // establish the connection to the ZooKeeper cluster\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n\n        URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n\n        return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "218", "src_id": "M942", "code": "    public void schedule(WorkRequest workRequest, long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n        // If we have a worker thread pool, use that; otherwise, do the work\n        // directly.\n        int size = workers.size();\n\n        if (size <= 0) {\n            // When there is no worker thread pool, do the work directly\n            // and wait for its completion\n            scheduledWorkRequest.run();\n        } else {\n            try {\n                // make sure to map negative ids as well to [0, size-1]\n                int workerNum = ((int) (id % size) + size) % size;\n                ExecutorService worker = workers.get(workerNum);\n\n                worker.execute(scheduledWorkRequest);\n            } catch (RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n            }\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "219", "src_id": "M520", "code": "    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n\n            success = true;\n        } finally {\n            if (success) {\n                boolean renamed = tmpFile.renameTo(origFile);\n                if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            } else {\n                if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                    IOUtils.closeStream(out);\n                }\n                // close wasn't successful, try to delete the tmp file\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "220", "src_id": "M186", "code": "    synchronized private LogEntry readNextEntry() {\n        try {\n            try {\n                while (true) {\n                    String line = in.readLine();\n                    if (line == null) {\n                        break;\n                    }\n                    Matcher m = src.timep.matcher(line);\n\n                    if (!(m.lookingAt())) {\n                        if (buf.length() > 0) {\n                            buf += line + \"\\n\";\n                        }\n                    } else {\n                        if (buf.length() > 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n\n                            return e;\n                        }\n                        buf = line;\n                    } \n                }\n            } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n            if (buf.length() > 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n\n                return e;\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "221", "src_id": "M478", "code": "    public static void main(String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n\n        if (op.equalsIgnoreCase(\"gettracemask\")) {\n            getTraceMask(host, port);\n        } else {\n            if (!(op.equalsIgnoreCase(\"settracemask\"))) {\n                if (op.equalsIgnoreCase(\"ruok\")) {\n                    ruok(host, port);\n                } else {\n                    if (!(op.equalsIgnoreCase(\"kill\"))) {\n                        if (op.equalsIgnoreCase(\"stat\")) {\n                            stat(host, port);\n                        } else {\n                            if (op.equalsIgnoreCase(\"dump\")) {\n                                dump(host, port);\n                            } else {\n                                System.out.println(\"Unrecognized op: \" + op);\n                            }\n                        }\n                    }else {\n                        kill(host, port);\n                    } \n                }\n            }else {\n                setTraceMask(host, port, args[3]);\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "395", "src_id": "M491", "code": "    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,@ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n        // save the new resize mode so it can be restored in a future session\n        player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode)\n        .apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "396", "src_id": "M424", "code": "    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close it because when changing orientation from portrait\n            // (in fullscreen mode) the size of queue layout can be larger than the screen size\n            closeItemsList();\n        } else {\n            if (!(ACTION_PLAY_PAUSE.equals(intent.getAction()))) {\n                if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                    fragmentIsVisible = false;\n                    onFragmentStopped();\n                } else {\n                    if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n                        // Restore video source when user returns to the fragment\n                        fragmentIsVisible = true;\n                        player.useVideoSource(true);\n                        // When a user returns from background, the system UI will always be shown even if\n                        // controls are invisible: hide it in that case\n                        if (!isControlsVisible()) {\n                            hideSystemUIIfNeeded();\n                        }\n                    }\n                }\n            }else {\n                // Ensure that we have audio-only stream playing when a user\n                // started to play from notification's play button from outside of the app\n                if (!fragmentIsVisible) {\n                    onFragmentStopped();\n                }\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "397", "src_id": "M900", "code": "    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key), blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key), selectedTheme = getSelectedThemeKey(context);\n        if (!(selectedTheme.equals(lightTheme))) {\n            if (selectedTheme.equals(blackTheme)) {\n                return R.style.BlackSettingsTheme;\n            } else {\n                if (!(selectedTheme.equals(automaticDeviceTheme))) {\n                    // default to dark theme\n                    return R.style.DarkSettingsTheme;\n                } else {\n                    if (!isDeviceDarkThemeEnabled(context)) {\n                        // there is only one day theme\n                        return R.style.LightSettingsTheme;\n                    } else {\n                        // use the dark theme variant preferred by the user\n                        final String selectedNightTheme = getSelectedNightThemeKey(context);\n                        if (selectedNightTheme.equals(blackTheme)) {\n                            return R.style.BlackSettingsTheme;\n                        } else {\n                            return R.style.DarkSettingsTheme;\n                        }\n                    } \n                } \n            }\n        }else {\n            return R.style.LightSettingsTheme;\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "398", "src_id": "M895", "code": "    @Override\n    public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n        final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n        final Bitmap result = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth,(int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n        if (!(result == source || !result.isMutable())) {\n            source.recycle();\n            return result;\n        } else {\n            // create a new mutable bitmap to prevent strange crashes on some\n            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n            source.recycle();\n\n            return copied;\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "399", "src_id": "M225", "code": "    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                }\n                break;\n        }\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "400", "src_id": "M749", "code": "    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n        if (!(errorInfo.getThrowable() instanceof ReCaptchaException)) {\n            if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n                Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n            } else {\n                if (!(errorInfo.getThrowable() instanceof AgeRestrictedContentException)) {\n                    if (!(errorInfo.getThrowable() instanceof GeographicRestrictionException)) {\n                        if (errorInfo.getThrowable() instanceof PaidContentException) {\n                            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                        } else {\n                            if (!(errorInfo.getThrowable() instanceof PrivateContentException)) {\n                                if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                    Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n                                } else {\n                                    if (!(errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException)) {\n                                        if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n                                            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n                                        } else {\n                                            if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                                Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n                                            } else {\n                                                ErrorUtil.createNotification(context, errorInfo);\n                                            }\n                                        }\n                                    }else {\n                                        Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n                                    } \n                                }\n                            }else {\n                                Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                            } \n                        }\n                    }else {\n                        Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n                    } \n                }else {\n                    Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n                } \n            }\n        }else {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            // Starting ReCaptcha Challenge Activity\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } \n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "401", "src_id": "M999", "code": "    public static void openVideoDetailFragment(@NonNull final Context context,@NonNull final FragmentManager fragmentManager, final int serviceId,@Nullable final String url,@NonNull final String title,@Nullable final PlayQueue playQueue, final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType != null) {\n            if (switchingPlayers) {\n                // switching player to main player\n                autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n            } else {\n                if (playerType == PlayerType.MAIN) {\n                    // opening new stream while already playing in main player\n                    autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n                } else {\n                    // opening new stream while already playing in another player\n                    autoPlay = false;\n                }\n            }\n        }else {\n            // no player open\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } \n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (!switchingPlayers) {\n                detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            } else {\n                // Situation when user switches from players to main player. All needed data is\n                // here, we can start watching (assuming newQueue equals playQueue).\n                // Starting directly in fullscreen if the previous player type was popup.\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } \n            detailFragment.scrollToTop();\n        };\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n            defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n            .commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "402", "src_id": "M698", "code": "    @Override\n    public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n        } else {\n            // do not waste space for the banner, if the user disabled images or there is not one\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() < 0) {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        } else {\n            binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        } \n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n        updateRssButton();\n        channelContentNotSupported = false;\n        for (final Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "403", "src_id": "M379", "code": "    @Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n        || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n        // Extract all loaded languages\n        final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n        .collect(Collectors.toList());\n        final List<String> availableLanguages = textTracks.stream().map(Tracks.Group::getMediaTrackGroup).filter(textTrack -> textTrack.length > 0)\n        .map(textTrack -> textTrack.getFormat(0).language)\n        .collect(Collectors.toList());\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info -> info.getMediaTrackGroup().length >= 1)\n        .map(info -> info.getMediaTrackGroup().getFormat(0))\n        .findFirst();\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) \n        || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "404", "src_id": "M894", "code": "    public static RequestCreator loadScaledDownThumbnail(final Context context,@NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n            @Override\n            public Bitmap transform(final Bitmap source) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n                }\n                final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n                final Bitmap result = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth,(int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n                if (!(result == source || !result.isMutable())) {\n                    source.recycle();\n                    return result;\n                } else {\n                    // create a new mutable bitmap to prevent strange crashes on some\n                    // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n                    source.recycle();\n\n                    return copied;\n                } \n            }\n\n            @Override\n            public String key() {\n                return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n            }\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "222", "src_id": "M1086", "code": "    public static AdminServer createAdminServer() {\n        if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            try {\n                Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n\n                return (AdminServer) adminServer;\n            } catch (ClassNotFoundException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (InstantiationException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (IllegalAccessException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (InvocationTargetException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (NoSuchMethodException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (NoClassDefFoundError e) {\n                LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n            }\n        }\n        return new DummyAdminServer();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "223", "src_id": "M1149", "code": "    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                } catch (Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n            // Close connections still pending on the selector. Any others\n            // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n\n                cleanupSelectionKey(key);\n            }\n            SocketChannel accepted;\n\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n\n            updateQueue.clear();\n        } finally {\n            closeSelector();\n            // This will wake up the accept thread and the other selector\n            // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "224", "src_id": "M219", "code": "    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n            Endpoint e = contextMap.get(contextPath);\n\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n\n            zkMap.put(connectionId, zk);\n\n            // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n        return zk;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "225", "src_id": "M192", "code": "    private void init() throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n\n        long lastFp = in.getPosition();\n\n        String line = in.readLine();\n        Matcher m = null;\n\n        // if we have read data from the file, and it matches the timep pattern\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n        /*\n\t  Count number of log entries. Any line starting with a timestamp counts as an entry\n\t*/\n\n        String lastentry = line;\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n\n                    lastentry = line;\n                } \n\n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n\n                lastFp = in.getPosition();\n\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n        } finally {\n            in.close();\n        }\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "226", "src_id": "M235", "code": "    @POST\n    @Produces( { MediaType.APPLICATION_JSON, \"application/javascript\",\n    MediaType.APPLICATION_XML })\n    public Response createSession(@QueryParam(\"op\") String op,\n    @DefaultValue(\"5\") \n    @QueryParam(\"expire\") String expire,\n    @Context UriInfo ui) {\n        if (!op.equals(\"create\")) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), \"\"))\n            .build());\n        }\n        int expireInSeconds;\n\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n\n        String uuid = UUID.randomUUID().toString();\n\n        while (ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n\n        // establish the connection to the ZooKeeper cluster\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n\n        URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n\n        return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString())))\n        .build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "227", "src_id": "M942", "code": "    public void schedule(WorkRequest workRequest, long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n\n        // If we have a worker thread pool, use that; otherwise, do the work\n        // directly.\n        int size = workers.size();\n\n        if (size <= 0) {\n            // When there is no worker thread pool, do the work directly\n            // and wait for its completion\n            scheduledWorkRequest.run();\n        } else {\n            try {\n                // make sure to map negative ids as well to [0, size-1]\n                int workerNum = ((int) (id % size) + size) % size;\n                ExecutorService worker = workers.get(workerNum);\n\n                worker.execute(scheduledWorkRequest);\n            } catch (RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n            }\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "228", "src_id": "M520", "code": "    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n\n            super.close();\n            success = true;\n        } finally {\n            if (success) {\n                boolean renamed = tmpFile.renameTo(origFile);\n                if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            } else {\n                if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                    IOUtils.closeStream(out);\n                }\n                // close wasn't successful, try to delete the tmp file\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "229", "src_id": "M186", "code": "    synchronized private LogEntry readNextEntry() {\n        try {\n            try {\n                while (true) {\n                    String line = in.readLine();\n                    if (line == null) {\n                        break;\n                    }\n\n                    Matcher m = src.timep.matcher(line);\n\n                    if (!(m.lookingAt())) {\n                        if (buf.length() > 0) {\n                            buf += line + \"\\n\";\n                        }\n                    } else {\n                        if (buf.length() > 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n\n                            return e;\n                        }\n                        buf = line;\n                    } \n                }\n            } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n            if (buf.length() > 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n\n                return e;\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "230", "src_id": "M478", "code": "    public static void main(String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n        String host = args[0];\n\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n        if (op.equalsIgnoreCase(\"gettracemask\")) {\n            getTraceMask(host, port);\n        } else {\n            if (!(op.equalsIgnoreCase(\"settracemask\"))) {\n                if (op.equalsIgnoreCase(\"ruok\")) {\n                    ruok(host, port);\n                } else {\n                    if (!(op.equalsIgnoreCase(\"kill\"))) {\n                        if (op.equalsIgnoreCase(\"stat\")) {\n                            stat(host, port);\n                        } else {\n                            if (op.equalsIgnoreCase(\"dump\")) {\n                                dump(host, port);\n                            } else {\n                                System.out.println(\"Unrecognized op: \" + op);\n                            }\n                        }\n                    }else {\n                        kill(host, port);\n                    } \n                }\n            }else {\n                setTraceMask(host, port, args[3]);\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "405", "src_id": "M66", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        Observer<? super R> downstream = this.downstream;\n\n        AtomicThrowable errors = this.errors;\n\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n                if (errors.get() != null && !delayErrors) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                boolean d = done;\n\n                SwitchMapMaybeObserver<R> current = inner.get();\n\n                boolean empty = current == null;\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty || current.item == null) {\n                    break;\n                }\n\n                inner.compareAndSet(current, null);\n\n                downstream.onNext(current.item);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "406", "src_id": "M1333", "code": "    @Override\n    public void onNext(T t) {\n        if (done) {\n            return;\n        }\n        boolean b;\n\n        try {\n            b = predicate.test(t);\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n\n            downstream.onSuccess(false);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "407", "src_id": "M522", "code": "    void drainLoop() {\n        Observer<? super T> actual = this.downstream;\n        int missed = 1;\n        for (;;) {\n            for (;;) {\n                if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n                    return;\n                }\n\n                int os = otherState;\n\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n\n                    actual.onNext(v);\n                }\n\n                boolean d = mainDone;\n\n                SimplePlainQueue<T> q = queue;\n\n                T v = q != null ? q.poll() : null;\n\n                boolean empty = v == null;\n\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                actual.onNext(v);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "408", "src_id": "M1163", "code": "    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        final SimplePlainQueue<Object> queue = this.queue;\n\n        final Subscriber<? super Flowable<T>> downstream = this.downstream;\n\n        UnicastProcessor<T> window = this.window;\n        for (;;) {\n            if (upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n                        downstream.onComplete();\n                    }\n\n                    cleanupResources();\n\n                    upstreamCancelled = true;\n                    continue;\n                } else {\n                    if (!isEmpty) {\n                        if (o instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else {\n                            if (window != null) {\n                                @SuppressWarnings(\"unchecked\") T item = (T) o;\n                                window.onNext(item);\n\n                                long count = this.count + 1;\n\n                                if (count != maxSize) {\n                                    this.count = count;\n                                } else {\n                                    this.count = 0;\n                                    window = createNewWindow(window);\n                                } \n                            }\n                        }\n                        continue;\n                    }\n                }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "409", "src_id": "M478", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        EqualObserver<T>[] as = observers;\n\n        final EqualObserver<T> observer1 = as[0];\n\n        final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n\n        final EqualObserver<T> observer2 = as[1];\n\n        final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n                boolean d1 = observer1.done;\n\n                if (d1) {\n                    Throwable e = observer1.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                boolean d2 = observer2.done;\n\n                if (d2) {\n                    Throwable e = observer2.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n\n                boolean e1 = v1 == null;\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n                boolean e2 = v2 == null;\n\n                if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n\n                if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(v1, v2);\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    v1 = null;\n\n                    v2 = null;\n                }\n\n                if (e1 || e2) {\n                    break;\n                }\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "410", "src_id": "M885", "code": "    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T>[] s = this.subscribers;\n\n        int n = s.length;\n\n        Subscriber<? super T> a = this.downstream;\n        for (;;) {\n            long r = requested.get();\n            long e = 0;\n            middle:\n            while (e != r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n\n                boolean empty = true;\n\n                for (int i = 0; i < s.length; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimplePlainQueue<T> q = inner.queue;\n\n                    if (q != null) {\n                        T v = q.poll();\n                        if (v != null) {\n                            empty = false;\n                            a.onNext(v);\n                            inner.requestOne();\n                            if (++e == r) {\n                                break middle;\n                            }\n                        }\n                    }\n                }\n\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n            }\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean d = done.get() == 0;\n\n                boolean empty = true;\n\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimpleQueue<T> q = inner.queue;\n\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "411", "src_id": "M1399", "code": "    @Override\n    public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        InnerQueuedSubscriber<R> inner = current;\n\n        Subscriber<? super R> a = downstream;\n\n        ErrorMode em = errorMode;\n        for (;;) {\n            long r = requested.get();\n            long e = 0L;\n\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n                boolean outerDone = done;\n\n                inner = subscribers.poll();\n\n                if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n\n            boolean continueNextSource = false;\n            if (inner != null) {\n                SimpleQueue<R> q = inner.queue();\n                if (q != null) {\n                    while (e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n\n                        R v;\n\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                            break;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n\n                        boolean d = inner.isDone();\n\n                        boolean empty = q.isEmpty();\n\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n            if (!continueNextSource) { \n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "412", "src_id": "M469", "code": "    @SuppressWarnings(\"unchecked\")void remove(CacheDisposable<T> consumer) {\n        for (;;) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n\n            if (n == 0) {\n                return;\n            }\n            int j = -1;\n\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            CacheDisposable<T>[] next;\n\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "413", "src_id": "M362", "code": "    void drainFused() {\n        int missed = 1;\n        for (;;) {\n            if (disposed) {\n                return;\n            }\n            boolean d = done;\n            Throwable ex = error;\n\n            if (!delayError && d && ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n\n            downstream.onNext(null);\n\n            if (d) {\n                disposed = true;\n                ex = error;\n\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n\n                worker.dispose();\n\n                return;\n            }\n\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "414", "src_id": "M2247", "code": "    @SuppressWarnings(\"unchecked\")void remove(PublishSubscription<T> ps) {\n        for (;;) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = -1;\n\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            PublishSubscription<T>[] b;\n\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "231", "src_id": "M1043", "code": "            private void doPostprocessing() {\n             errCode = ERROR_NOTHING;\n             errObject = null;\n             Thread thread = Thread.currentThread();\n             notifyPostProcessing(1);\n             if (DEBUG) {\n              thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n             }\n             Exception exception = null;\n\n             try {\n              psAlgorithm.run(this);\n             } catch (Exception err) {\n              Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n              if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException \n              || thread.isInterrupted()) {\n               notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n               return;\n              }\n\n              if (errCode == ERROR_NOTHING) {\n               errCode = ERROR_POSTPROCESSING;\n              }\n\n              exception = err;\n             } finally {\n              notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n             }\n\n             if (errCode != ERROR_NOTHING) {\n              if (exception == null) {\n               exception = errObject;\n              }\n              notifyError(ERROR_POSTPROCESSING, exception);\n              return;\n             }\n\n             notifyFinished();\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "232", "src_id": "M1031", "code": "            void establishConnection(int threadId, HttpURLConnection conn) \n            throws IOException, HttpError {\n             int statusCode = conn.getResponseCode();\n             if (DEBUG) {\n              Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n              Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n\n              Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n\n              Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n             }\n\n             switch (statusCode) {\n              case 204:\n              case 205:\n              case 207:\n               throw new HttpError(statusCode);\n              case 416:\n               return; // let the download thread handle this error\n              default:\n               if (statusCode < 200 || statusCode > 299) {\n                throw new HttpError(statusCode);\n               }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "233", "src_id": "M827", "code": "            private Elst parseEdts(final Box ref) throws IOException {\n             final Box b = untilBox(ref, ATOM_ELST);\n             if (b == null) {\n              return null;\n             }\n             final Elst obj = new Elst();\n             final boolean v1 = stream.read() == 1;\n             stream.skipBytes(3); // flags\n\n             final int entryCount = stream.readInt();\n             if (entryCount < 1) {\n              obj.bMediaRate = 0x00010000; // default media rate (1.0)\n              return obj;\n             }\n\n             if (!v1) {\n              stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n              obj.mediaTime = stream.readInt();\n             } else {\n              stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n              obj.mediaTime = stream.readLong();\n              // ignore all remain entries\n              stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n             } \n\n             obj.bMediaRate = stream.readInt();\n\n             return obj;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "234", "src_id": "M1048", "code": "            @Override\n            public void run() {\n             boolean done;\n             long start = mMission.fallbackResumeOffset;\n             if (DEBUG && !mMission.unknownLength && start > 0) {\n              Log.i(TAG, \"Resuming a single-thread download at \" + start);\n             }\n\n             try {\n              long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n              int mId = 1;\n              mConn = mMission.openConnection(false, rangeStart, -1);\n              if (mRetryCount == 0 && rangeStart == -1) {\n               // workaround: bypass android connection pool\n               mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n              }\n\n              mMission.establishConnection(mId, mConn);\n\n              // check if the download can be resumed\n              if (mConn.getResponseCode() == 416 && start > 0) {\n               mMission.notifyProgress(-start);\n               start = 0;\n               mRetryCount--;\n               throw new DownloadMission.HttpError(416);\n              }\n\n              // secondary check for the file length\n              if (!mMission.unknownLength)\n              {\n               mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n              }\n\n              if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n               // restart amount of bytes downloaded\n               mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n              }\n\n              mF = mMission.storage.getStream();\n\n              mF.seek(mMission.offsets[mMission.current] + start);\n              mIs = mConn.getInputStream();\n              byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n              int len = 0;\n\n              while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n               mF.write(buf, 0, len);\n               start += len;\n               mMission.notifyProgress(len);\n              }\n              dispose();\n              // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n              done = len == -1;\n             } catch (Exception e) {\n              dispose();\n              mMission.fallbackResumeOffset = start;\n              if (!mMission.running || e instanceof ClosedByInterruptException) {return;\n\n              }\n\n              if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n               // for youtube streams. The url has expired, recover\n               dispose();\n               mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n               return;\n              }\n\n              if (mRetryCount++ >= mMission.maxRetry) {\n               mMission.notifyError(e);\n               return;\n              }\n\n              if (DEBUG) {\n               Log.e(TAG, \"got exception, retrying...\", e);\n              }\n              run(); // try again\n              return;\n             }\n\n             if (done) {\n              mMission.notifyFinished();\n             } else {\n              mMission.fallbackResumeOffset = start;\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "235", "src_id": "M1141", "code": "            private void flushAuxiliar(long amount) throws IOException {\n             if (aux.length < 1) {\n              return;\n             }\n             out.flush();\n             aux.flush();\n             boolean underflow = aux.offset < aux.length || out.offset < out.length;\n             byte[] buffer = new byte[COPY_BUFFER_SIZE];\n             aux.target.seek(0);\n             out.target.seek(out.length);\n             long length = amount;\n\n             while (length > 0) {\n              int read = (int) Math.min(length, Integer.MAX_VALUE);\n              read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n              if (read < 1) {\n               amount -= length;\n               break;\n              }\n              out.writeProof(buffer, read);\n              length -= read;\n             }\n\n             if (!underflow) {\n              out.offset += amount;\n              aux.offset -= amount;\n             } else {\n              if (out.offset < out.length) {\n               aux.offset = 0;\n              }\n              else {\n               // calculate the aux underflow pointer\n               if (aux.offset >= amount) {\n                aux.offset -= amount;\n                out.offset = out.length + amount;\n               } else {\n                out.offset += aux.offset;\n                aux.offset = 0;\n                out.target.seek(out.offset);\n               } \n              } \n             } \n\n             out.length += amount;\n\n             if (out.length > maxLengthKnown) {\n              maxLengthKnown = out.length;\n             }\n\n             if (amount < aux.length) {\n              // move the excess data to the beginning of the file\n              long readOffset = amount;\n              long writeOffset = 0;\n              aux.length -= amount;\n              length = aux.length;\n\n              while (length > 0) {\n               int read = (int) Math.min(length, Integer.MAX_VALUE);\n               read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n               aux.target.seek(writeOffset);\n               aux.writeProof(buffer, read);\n               writeOffset += read;\n               readOffset += read;\n               length -= read;\n               aux.target.seek(readOffset);\n              }\n\n              aux.target.setLength(aux.length);\n\n              return;\n             }\n\n             if (aux.length > THRESHOLD_AUX_LENGTH) {\n              aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n             }\n\n             aux.reset();\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "236", "src_id": "M1106", "code": "            private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n             StringBuilder request = new StringBuilder(256);\n             request.append(mission.source);\n             request.append(\" [\");\n\n             if (mission.recoveryInfo != null) {\n              for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n              {\n               request.append(' ').append(recovery.toString()).append(' ');\n              }\n             }\n\n             request.append(\"]\");\n\n             String service;\n             try {\n              service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n             } catch (Exception e) {\n              service = ErrorInfo.SERVICE_NONE;\n             }\n\n             ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "237", "src_id": "M1067", "code": "            void startMission(DownloadMission mission) {\n             synchronized (this) {\n              mission.timestamp = System.currentTimeMillis();\n              mission.mHandler = mHandler;\n              mission.maxRetry = mPrefMaxRetry;\n\n              // create metadata file\n              while (true) {\n               mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n               if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                try {\n                 if (!mission.metadata.createNewFile())\n                 {\n                  throw new RuntimeException(\"Cant create download metadata file\");\n                 }\n                } catch (IOException e) {\n                 throw new RuntimeException(e);\n                }\n                break;\n               }\n\n               mission.timestamp = System.currentTimeMillis();\n              }\n\n              mSelfMissionsControl = true;\n\n              mMissionsPending.add(mission);\n              // Before continue, save the metadata in case the internet connection is not available\n              Utility.writeToFile(mission.metadata, mission);\n\n              if (mission.storage == null) {\n               // noting to do here\n               mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n               if (mission.errObject != null)\n               {\n                mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n               }\n               return;\n              }\n\n              boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n              if (canDownloadInCurrentNetwork() && start) {\n               mission.start();\n              }\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "238", "src_id": "M1136", "code": "            @Override int process(SharpStream out, SharpStream... sources) throws IOException {\n             // check if the subtitle is already in srt and copy, this should never happen\n             String format = getArgumentAt(0, null);\n             boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n             if (!(format == null || format.equals(\"ttml\"))) {\n              if (format.equals(\"srt\")) {\n               byte[] buffer = new byte[8 * 1024];\n               int read;\n               while ((read = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, read);\n               }\n               return OK_RESULT;\n              }\n             } else {\n              SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n              try {\n               writer.build(sources[0]);\n              } catch (Exception err) {\n               Log.e(TAG, \"subtitle parse failed\", err);\n               return err instanceof IOException ? 1 : 8;\n              }\n\n              return OK_RESULT;\n             } \n\n             throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "239", "src_id": "M1047", "code": "            private void joinForThreads(int millis) {\n             final Thread currentThread = Thread.currentThread();\n             if (init != null && init != currentThread && init.isAlive()) {\n              init.interrupt();\n              if (millis > 0) {\n               try {\n                init.join(millis);\n               } catch (InterruptedException e) {\n                Log.w(TAG, \"Initializer thread is still running\", e);\n                return;\n               }\n              }\n             }\n             // if a thread is still alive, possible reasons:\n             //      slow device\n             //      the user is spamming start/pause buttons\n             //      start() method called quickly after pause()\n\n\n             for (Thread thread : threads) {\n              if (!thread.isAlive() || thread == Thread.currentThread()) {continue;\n              }\n              thread.interrupt();\n             }\n\n             try {\n              for (Thread thread : threads) {\n               if (!thread.isAlive()) {continue;\n               }\n               if (DEBUG) {\n                Log.w(TAG, \"thread alive: \" + thread.getName());\n               }\n               if (millis > 0) {\n                thread.join(millis);\n               }\n              }\n             } catch (InterruptedException e) {\n              throw new RuntimeException(\"A download thread is still running\", e);\n             }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "415", "src_id": "M66", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        Observer<? super R> downstream = this.downstream;\n\n        AtomicThrowable errors = this.errors;\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n        while (true) {\n            while (true) {\n                if (cancelled) {\n                    return;\n                }\n                if (errors.get() != null && !delayErrors) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                boolean d = done;\n                SwitchMapMaybeObserver<R> current = inner.get();\n\n                boolean empty = current == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty || current.item == null) {\n                    break;\n                }\n\n                inner.compareAndSet(current, null);\n\n                downstream.onNext(current.item);\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "416", "src_id": "M1333", "code": "    @Override\n    public void onNext(T t) {\n        if (done) {\n            return;\n        }\n        boolean b;\n        try {\n            b = predicate.test(t);\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            onError(e);\n            return;\n        }\n\n        if (!b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            downstream.onSuccess(false);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "417", "src_id": "M522", "code": "    void drainLoop() {\n        Observer<? super T> actual = this.downstream;\n        int missed = 1;\n\n        while (true) {\n            while (true) {\n                if (disposed) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(actual);\n\n                    return;\n                }\n                int os = otherState;\n\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                }\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                T v; \n\n                if (q != null) {\n                    v = q.poll(); \n                } else {\n                    v = null; \n                } \n                boolean empty = v == null;\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                actual.onNext(v);\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "418", "src_id": "M1163", "code": "    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        final SimplePlainQueue<Object> queue = this.queue;\n        final Subscriber<? super Flowable<T>> downstream = this.downstream;\n\n        UnicastProcessor<T> window = this.window;\n\n        while (true) {\n            if (upstreamCancelled) {\n                queue.clear();\n                window = null;\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n                        downstream.onComplete();\n                    }\n                    cleanupResources();\n                    upstreamCancelled = true;\n                    continue;\n                } else {\n                    if (!isEmpty) {\n                        if (o instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else {\n                            if (window != null) {\n                                @SuppressWarnings(\"unchecked\") T item = (T) o;\n                                window.onNext(item);\n                                long count = this.count + 1;\n\n                                if (count != maxSize) {\n                                    this.count = count;\n                                } else {\n                                    this.count = 0;\n                                    window = createNewWindow(window);\n                                } \n                            }\n                        }\n                        continue;\n                    }\n                }\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "419", "src_id": "M478", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        EqualObserver<T>[] as = observers;\n        final EqualObserver<T> observer1 = as[0];\n        final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n        final EqualObserver<T> observer2 = as[1];\n        final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n        while (true) {\n            while (true) {\n                if (cancelled) {\n                    q1.clear();\n                    q2.clear();\n                    return;\n                }\n                boolean d1 = observer1.done;\n                if (d1) {\n                    Throwable e = observer1.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                boolean d2 = observer2.done;\n                if (d2) {\n                    Throwable e = observer2.error;\n                    if (e != null) {\n                        cancel(q1, q2);\n                        downstream.onError(e);\n                        return;\n                    }\n                }\n                if (v1 == null) {\n                    v1 = q1.poll();\n                }\n                boolean e1 = v1 == null;\n                if (v2 == null) {\n                    v2 = q2.poll();\n                }\n                boolean e2 = v2 == null;\n\n                if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n\n                    return;\n                }\n\n                if (!e1 && !e2) {\n                    boolean c;\n                    try {\n                        c = comparer.test(v1, v2);\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancel(q1, q2);\n                        downstream.onError(ex);\n                        return;\n                    }\n                    if (!c) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n\n                        return;\n                    }\n                    v1 = null;\n                    v2 = null;\n                }\n\n                if (e1 || e2) {\n                    break;\n                }\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "420", "src_id": "M885", "code": "    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T>[] s = this.subscribers;\n\n        int n = s.length;\n        Subscriber<? super T> a = this.downstream;\n\n        while (true) {\n            long r = requested.get();\n            long e = 0;\n\n            middle:\n            while (e != r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n                boolean d = done.get() == 0;\n                boolean empty = true;\n\n                for (int i = 0; i < s.length; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimplePlainQueue<T> q = inner.queue;\n                    if (q != null) {\n                        T v = q.poll();\n                        if (v != null) {\n                            empty = false;\n                            a.onNext(v);\n                            inner.requestOne();\n                            if (++e == r) {\n                                break middle;\n                            }\n                        }\n                    }\n                }\n\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                Throwable ex = errors.get();\n\n                if (ex != null) {\n                    cleanup();\n                    a.onError(ex);\n                    return;\n                }\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimpleQueue<T> q = inner.queue;\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "421", "src_id": "M1399", "code": "    @Override\n    public void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n\n        InnerQueuedSubscriber<R> inner = current;\n        Subscriber<? super R> a = downstream;\n        ErrorMode em = errorMode;\n\n        while (true) {\n            long r = requested.get();\n            long e = 0L;\n\n            if (inner == null) {\n                if (em != ErrorMode.END) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n                boolean outerDone = done;\n                inner = subscribers.poll();\n\n                if (outerDone && inner == null) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (inner != null) {\n                    current = inner;\n                }\n            }\n\n            boolean continueNextSource = false;\n\n            if (inner != null) {\n                SimpleQueue<R> q = inner.queue();\n                if (q != null) {\n                    while (e != r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n                        boolean d = inner.isDone();\n                        R v;\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            a.onError(ex);\n                            return;\n                        }\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n\n                            break;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n\n                        a.onNext(v);\n                        e++;\n                        inner.request(1L);\n                    }\n                    if (e == r) {\n                        if (cancelled) {\n                            cancelAll();\n                            return;\n                        }\n                        if (em == ErrorMode.IMMEDIATE) {\n                            Throwable ex = errors.get();\n                            if (ex != null) {\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                errors.tryTerminateConsumer(downstream);\n                                return;\n                            }\n                        }\n                        boolean d = inner.isDone();\n                        boolean empty = q.isEmpty();\n\n                        if (d && empty) {\n                            inner = null;\n                            current = null;\n                            upstream.request(1);\n                            continueNextSource = true;\n                        }\n                    }\n                }\n            }\n\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n\n            if (!continueNextSource) {\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "422", "src_id": "M469", "code": "    @SuppressWarnings(\"unchecked\") void remove(CacheDisposable<T> consumer) {\n        while (true) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n\n            CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "423", "src_id": "M362", "code": "    void drainFused() {\n        int missed = 1;\n        while (true) {\n            if (disposed) {\n                return;\n            }\n            boolean d = done;\n            Throwable ex = error;\n\n            if (!delayError && d && ex != null) {\n                disposed = true;\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n            downstream.onNext(null);\n            if (d) {\n                disposed = true;\n                ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n                worker.dispose();\n                return;\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "424", "src_id": "M2247", "code": "    @SuppressWarnings(\"unchecked\") void remove(PublishSubscription<T> ps) {\n        while (true) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n\n            PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}

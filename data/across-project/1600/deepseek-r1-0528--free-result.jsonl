{"project_name": "across-project", "pair_id": "1", "src_id": "M270", "code": "\n\tprivate static String normalizeArch(String value) {\n\t\tvalue = normalize(value);\n\t\tif (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n\t\t\treturn \"x86_64\";\n\t\t}\n\t\tif (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n\t\t\treturn \"x86_32\";\n\t\t}\n\t\tif (value.matches(\"^(ia64w?|itanium64)$\")) {\n\t\t\treturn \"itanium_64\";\n\t\t}\n\t\tif (\"ia64n\".equals(value)) {\n\t\t\treturn \"itanium_32\";\n\t\t}\n\t\tif (value.matches(\"^(sparc|sparc32)$\")) {\n\t\t\treturn \"sparc_32\";\n\t\t}\n\t\tif (value.matches(\"^(sparcv9|sparc64)$\")) {\n\t\t\treturn \"sparc_64\";\n\t\t}\n\t\tif (value.matches(\"^(arm|arm32)$\")) {\n\t\t\treturn \"arm_32\";\n\t\t}\n\t\tif (\"aarch64\".equals(value)) {\n\t\t\treturn \"aarch_64\";\n\t\t}\n\t\tif (value.matches(\"^(mips|mips32)$\")) {\n\t\t\treturn \"mips_32\";\n\t\t}\n\t\tif (value.matches(\"^(mipsel|mips32el)$\")) {\n\t\t\treturn \"mipsel_32\";\n\t\t}\n\t\tif (\"mips64\".equals(value)) {\n\t\t\treturn \"mips_64\";\n\t\t}\n\t\tif (\"mips64el\".equals(value)) {\n\t\t\treturn \"mipsel_64\";\n\t\t}\n\t\tif (value.matches(\"^(ppc|ppc32)$\")) {\n\t\t\treturn \"ppc_32\";\n\t\t}\n\t\tif (value.matches(\"^(ppcle|ppc32le)$\")) {\n\t\t\treturn \"ppcle_32\";\n\t\t}\n\t\tif (\"ppc64\".equals(value)) {\n\t\t\treturn \"ppc_64\";\n\t\t}\n\t\tif (\"ppc64le\".equals(value)) {\n\t\t\treturn \"ppcle_64\";\n\t\t}\n\t\tif (\"s390\".equals(value)) {\n\t\t\treturn \"s390_32\";\n\t\t}\n\t\tif (\"s390x\".equals(value)) {\n\t\t\treturn \"s390_64\";\n\t\t}\n\t\treturn value;\n\t}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "2", "src_id": "M928", "code": "\n    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n        Map<String, Object> info = new HashMap<>();\n        info.put(LoggerHelper.name, logger.getName());\n        info.put(LoggerHelper.clazz, logger.getClass());\n        CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n        if (codeSource != null) {\n            info.put(LoggerHelper.codeSource, codeSource.getLocation());\n        }\n        info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n        Level level = logger.getLevel();\n        Level effectiveLevel = logger.getEffectiveLevel();\n        if (level != null) {\n            info.put(LoggerHelper.level, level.toString());\n        }\n        if (effectiveLevel != null) {\n            info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenderInfo = doGetLoggerAppenders(logger.getAllAppenders());\n        info.put(LoggerHelper.appenders, appenderInfo);\n        return info;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "3", "src_id": "M9", "code": "\n    @SuppressWarnings(\"resource\")\n    public static long select(boolean v, long telnetPortPid, String select) throws InputMismatchException {\n        Map<Long, String> processMap = listProcessByJps(v);\n        if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n            String telnetPortProcess = processMap.get(telnetPortPid);\n            processMap.remove(telnetPortPid);\n            Map<Long, String> newProcessMap = new LinkedHashMap<>();\n            newProcessMap.put(telnetPortPid, telnetPortProcess);\n            newProcessMap.putAll(processMap);\n            processMap = newProcessMap;\n        }\n\n        if (processMap.isEmpty()) {\n            AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n            return -1;\n        }\n\n        if (select != null && !select.trim().isEmpty()) {\n            int matchedSelectCount = 0;\n            Long matchedPid = null;\n            for (Entry<Long, String> entry : processMap.entrySet()) {\n                if (entry.getValue().contains(select)) {\n                    matchedSelectCount++;\n                    matchedPid = entry.getKey();\n                }\n            }\n            if (matchedSelectCount == 1) {\n                return matchedPid;\n            }\n        }\n\n        AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n        int count = 1;\n        for (String process : processMap.values()) {\n            if (count == 1) {\n                System.out.println(\"* [\" + count + \"]: \" + process);\n            } else {\n                System.out.println(\"  [\" + count + \"]: \" + process);\n            }\n            count++;\n        }\n\n        String line = new Scanner(System.in).nextLine();\n        if (line.trim().isEmpty()) {\n            return processMap.keySet().iterator().next();\n        }\n\n        int choice = new Scanner(line).nextInt();\n        if (choice <= 0 || choice > processMap.size()) {\n            return -1;\n        }\n\n        Iterator<Long> idIter = processMap.keySet().iterator();\n        for (int i = 1; i <= choice; ++i) {\n            if (i == choice) {\n                return idIter.next();\n            }\n            idIter.next();\n        }\n\n        return -1;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "4", "src_id": "M140", "code": "\n    void _processDo(int option) throws IOException {\n        if (debugoptions) {\n            System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n        }\n\n        if (__notifhand != null) {\n            __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n        }\n\n        boolean acceptNewState = false;\n        if (optionHandlers[option] != null) {\n            acceptNewState = optionHandlers[option].getAcceptLocal();\n        } else if (option == TERMINAL_TYPE) {\n            if ((terminalType != null) && (terminalType.length() > 0)) {\n                acceptNewState = true;\n            }\n        }\n\n        if (_willResponse[option] > 0) {\n            --_willResponse[option];\n            if (_willResponse[option] > 0 && _stateIsWill(option)) {\n                --_willResponse[option];\n            }\n        }\n\n        if (_willResponse[option] == 0) {\n            if (_requestedWont(option)) {\n                if (acceptNewState) {\n                    _setWantWill(option);\n                    _sendWill(option);\n                } else {\n                    ++_willResponse[option];\n                    _sendWont(option);\n                }\n            } else {\n                // Other end has acknowledged option\n                // (No action needed for default case)\n            }\n        }\n\n        _setWill(option);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "5", "src_id": "M1324", "code": "\n    private void bind(Configure configure) throws Throwable {\n        long start = System.currentTimeMillis();\n        if (!isBindRef.compareAndSet(false, true)) {\n            throw new IllegalStateException(\"already bind\");\n        }\n\n        if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n            int newTelnetPort = SocketUtils.findAvailableTcpPort();\n            configure.setTelnetPort(newTelnetPort);\n            logger().info(\"generate random telnet port: \" + newTelnetPort);\n        }\n        if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n            int newHttpPort = SocketUtils.findAvailableTcpPort();\n            configure.setHttpPort(newHttpPort);\n            logger().info(\"generate random http port: \" + newHttpPort);\n        }\n        if (configure.getAppName() == null) {\n            configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME,\n                    System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n        }\n\n        try {\n            if (configure.getTunnelServer() != null) {\n                tunnelClient = new TunnelClient();\n                tunnelClient.setAppName(configure.getAppName());\n                tunnelClient.setId(configure.getAgentId());\n                tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n                tunnelClient.setVersion(ArthasBanner.version());\n                ChannelFuture channelFuture = tunnelClient.start();\n                channelFuture.await(10, TimeUnit.SECONDS);\n            }\n        } catch (Throwable t) {\n            logger().error(\"start tunnel client error\", t);\n        }\n\n        try {\n            ShellServerOptions options = new ShellServerOptions()\n                .setInstrumentation(instrumentation)\n                .setPid(PidUtils.currentLongPid())\n                .setWelcomeMessage(ArthasBanner.welcome());\n            if (configure.getSessionTimeout() != null) {\n                options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n            }\n\n            this.httpSessionManager = new HttpSessionManager();\n            if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n                String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \"\n                    + \"No password is currently configured. Therefore, a default password is generated, \"\n                    + \"and clients need to use the password to connect!\";\n                AnsiLog.error(errorMsg);\n                configure.setPassword(StringUtils.randomString(64));\n                AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n                logger().error(errorMsg);\n                logger().info(\"Generated arthas password: \" + configure.getPassword());\n            }\n\n            this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n            shellServer = new ShellServerImpl(options);\n\n            List<String> disabledCommands = new ArrayList<>();\n            if (configure.getDisabledCommands() != null) {\n                String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n                if (strings != null) {\n                    disabledCommands.addAll(Arrays.asList(strings));\n                }\n            }\n            BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n            List<CommandResolver> resolvers = new ArrayList<>();\n            resolvers.add(builtinCommands);\n\n            workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n            if (configure.getTelnetPort() != null && configure.getTelnetPort() > 0) {\n                logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n                shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(),\n                        options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else {\n                logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n            }\n            if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n                logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n                shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(),\n                        options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else if (configure.getTunnelServer() != null) {\n                shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(),\n                        options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            }\n\n            for (CommandResolver resolver : resolvers) {\n                shellServer.registerCommandResolver(resolver);\n            }\n\n            shellServer.listen(new BindHandler(isBindRef));\n            if (!isBind()) {\n                throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \"\n                    + configure.getTelnetPort() + \", http port: \" + configure.getHttpPort());\n            }\n\n            sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n            httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n            logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(),\n                    configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n            if (configure.getStatUrl() != null) {\n                logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n            }\n            UserStatUtil.setStatUrl(configure.getStatUrl());\n            UserStatUtil.setAgentId(configure.getAgentId());\n            UserStatUtil.arthasStart();\n\n            try {\n                SpyAPI.init();\n            } catch (Throwable e) {\n                // ignore\n            }\n\n            logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n        } catch (Throwable e) {\n            logger().error(\"Error during start as-server\", e);\n            destroy();\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "6", "src_id": "M122", "code": "\n    private int __read(boolean mayBlock) throws IOException {\n        while (true) {\n            if (!mayBlock && super.available() == 0) {\n                return WOULD_BLOCK;\n            }\n\n            int ch = super.read();\n            if (ch < 0) {\n                return EOF;\n            }\n\n            ch = (ch & 0xff);\n            synchronized (__client) {\n                __client._processAYTResponse();\n            }\n            __client._spyRead(ch);\n\n            switch (__receiveState) {\n                case _STATE_CR:\n                    if (ch == '\\0') {\n                        continue;\n                    }\n                    // Fall through to _STATE_DATA\n                case _STATE_DATA:\n                    if (ch == TelnetCommand.IAC) {\n                        __receiveState = _STATE_IAC;\n                        continue;\n                    }\n                    if (ch == '\\r') {\n                        synchronized (__client) {\n                            __receiveState = _requestedDont(TelnetOption.BINARY) ? _STATE_CR : _STATE_DATA;\n                        }\n                    } else {\n                        __receiveState = _STATE_DATA;\n                    }\n                    break;\n\n                case _STATE_IAC:\n                    switch (ch) {\n                        case TelnetCommand.WILL:\n                            __receiveState = _STATE_WILL;\n                            continue;\n                        case TelnetCommand.WONT:\n                            __receiveState = _STATE_WONT;\n                            continue;\n                        case TelnetCommand.DO:\n                            __receiveState = _STATE_DO;\n                            continue;\n                        case TelnetCommand.DONT:\n                            __receiveState = _STATE_DONT;\n                            continue;\n                        case TelnetCommand.SB:\n                            __suboption_count = 0;\n                            __receiveState = _STATE_SB;\n                            continue;\n                        case TelnetCommand.IAC:\n                            __receiveState = _STATE_DATA;\n                            break;\n                        case TelnetCommand.SE:\n                            __receiveState = _STATE_DATA;\n                            continue;\n                        default:\n                            __receiveState = _STATE_DATA;\n                            __client._processCommand(ch);\n                            continue;\n                    }\n                    break;\n\n                case _STATE_WILL:\n                    synchronized (__client) {\n                        __client._processWill(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_WONT:\n                    synchronized (__client) {\n                        __client._processWont(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_DO:\n                    synchronized (__client) {\n                        __client._processDo(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_DONT:\n                    synchronized (__client) {\n                        __client._processDont(ch);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_SB:\n                    if (ch == TelnetCommand.IAC) {\n                        __receiveState = _STATE_IAC_SB;\n                    } else if (__suboption_count < __suboption.length) {\n                        __suboption[__suboption_count++] = ch;\n                    }\n                    __receiveState = _STATE_SB;\n                    continue;\n\n                case _STATE_IAC_SB:\n                    if (ch == TelnetCommand.SE) {\n                        synchronized (__client) {\n                            __client._processSuboption(__suboption, __suboption_count);\n                            __client._flushOutputStream();\n                        }\n                        __receiveState = _STATE_DATA;\n                    } else if (ch == TelnetCommand.IAC && __suboption_count < __suboption.length) {\n                        __suboption[__suboption_count++] = ch;\n                        __receiveState = _STATE_SB;\n                    }\n                    continue;\n            }\n            break;\n        }\n        return ch;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "7", "src_id": "M8", "code": "\n    private static String formatFileSize(long size) {\n        double b = size;\n        double k = size / 1024.0;\n        double m = k / 1024.0;\n        double g = m / 1024.0;\n        double t = g / 1024.0;\n\n        DecimalFormat dec = new DecimalFormat(\"0.00\");\n        if (t > 1) {\n            return dec.format(t).concat(\" TB\");\n        } else if (g > 1) {\n            return dec.format(g).concat(\" GB\");\n        } else if (m > 1) {\n            return dec.format(m).concat(\" MB\");\n        } else if (k > 1) {\n            return dec.format(k).concat(\" KB\");\n        } else {\n            return dec.format(b).concat(\" Bytes\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "8", "src_id": "M790", "code": "\n        @Override\n        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n                ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n\n            if (className == null) {\n                return null;\n            }\n            className = className.replace('/', '.');\n\n            List<RetransformEntry> allEntries = allRetransformEntries();\n            ListIterator<RetransformEntry> listIterator = allEntries.listIterator(allEntries.size());\n            while (listIterator.hasPrevious()) {\n                RetransformEntry entry = listIterator.previous();\n                if (!className.equals(entry.getClassName())) {\n                    continue;\n                }\n\n                boolean updateFlag;\n                if (entry.getClassLoaderClass() != null || entry.getHashCode() != null) {\n                    updateFlag = isLoaderMatch(entry, loader);\n                } else {\n                    updateFlag = true;\n                }\n\n                if (updateFlag) {\n                    logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\",\n                            className, entry.getId(), entry.getClassLoaderClass(), entry.getHashCode());\n                    entry.incTransformCount();\n                    return entry.getBytes();\n                }\n            }\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "9", "src_id": "M716", "code": "\n    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n        table.row(\"IS-RETURN\", \"false\");\n        table.row(\"IS-EXCEPTION\", \"true\");\n\n        Throwable cause;\n        Throwable t = (Throwable) throwableVO.getObject();\n        if (t instanceof InvocationTargetException) {\n            cause = t.getCause();\n        } else {\n            cause = t;\n        }\n\n        if (throwableVO.needExpand()) {\n            table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n        } else {\n            try (StringWriter stringWriter = new StringWriter();\n                 PrintWriter printWriter = new PrintWriter(stringWriter)) {\n                cause.printStackTrace(printWriter);\n                table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "10", "src_id": "M602", "code": "\n    private AsyncProfiler profilerInstance() {\n        if (profiler != null) {\n            return profiler;\n        }\n\n        if (ProfilerAction.load.toString().equals(action)) {\n            profiler = AsyncProfiler.getInstance(this.actionArg);\n        }\n\n        if (libPath != null) {\n            try {\n                File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n                try (FileOutputStream tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n                     FileInputStream libInputStream = new FileInputStream(libPath)) {\n                    IOUtils.copy(libInputStream, tmpLibOutputStream);\n                    libPath = tmpLibFile.getAbsolutePath();\n                    logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n                }\n            } catch (Throwable e) {\n                logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n            }\n            profiler = AsyncProfiler.getInstance(libPath);\n        } else {\n            if (OSUtils.isLinux() || OSUtils.isMac()) {\n                throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n            } else {\n                throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n            }\n        }\n        return profiler;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "11", "src_id": "M1043", "code": "\nprivate void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    Thread thread = Thread.currentThread();\n\n    notifyPostProcessing(1);\n\n    if (LOG.isDebugEnabled()) {\n        thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n\n    Exception exception = null;\n\n    try {\n        psAlgorithm.run(this);\n    } catch (Exception err) {\n        LOG.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n        if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n            notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) {\n            errCode = ERROR_POSTPROCESSING;\n        }\n\n        exception = err;\n    } finally {\n        notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n        if (exception == null) {\n            exception = errObject;\n        }\n        notifyError(ERROR_POSTPROCESSING, exception);\n        return;\n    }\n\n    notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "12", "src_id": "M1031", "code": "\nvoid establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n    int statusCode = conn.getResponseCode();\n\n    if (LOG.isDebugEnabled()) {\n        LOG.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n        LOG.d(TAG, threadId + \":[response] Code=\" + statusCode);\n        LOG.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n        LOG.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n    }\n\n    switch (statusCode) {\n        case 204:\n        case 205:\n        case 207:\n            throw new HttpError(statusCode);\n        case 416:\n            return; // let the download thread handle this error\n        default:\n            if (statusCode < 200 || statusCode > 299) {\n                throw new HttpError(statusCode);\n            }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "13", "src_id": "M827", "code": "\nprivate Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n    if (b == null) {\n        return null;\n    }\n\n    final Elst obj = new Elst();\n\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n        obj.bMediaRate = 0x00010000; // default media rate (1.0)\n        return obj;\n    }\n\n    if (v1) {\n        stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n        obj.mediaTime = stream.readLong();\n        // ignore all remain entries\n        stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n    } else {\n        stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n        obj.mediaTime = stream.readInt();\n    }\n\n    obj.bMediaRate = stream.readInt();\n\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "14", "src_id": "M1048", "code": "\n@Override\npublic void run() {\n    boolean done;\n    long start = mMission.fallbackResumeOffset;\n\n    if (LOG.isDebugEnabled() && !mMission.unknownLength && start > 0) {\n        LOG.i(TAG, \"Resuming a single-thread download at \" + start);\n    }\n\n    try {\n        long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n        int mId = 1;\n        mConn = mMission.openConnection(false, rangeStart, -1);\n\n        if (mRetryCount == 0 && rangeStart == -1) {\n            // workaround: bypass android connection pool\n            mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n        }\n\n        mMission.establishConnection(mId, mConn);\n\n        // check if the download can be resumed\n        if (mConn.getResponseCode() == 416 && start > 0) {\n            mMission.notifyProgress(-start);\n            start = 0;\n            mRetryCount--;\n            throw new DownloadMission.HttpError(416);\n        }\n\n        // secondary check for the file length\n        if (!mMission.unknownLength) {\n            mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n        }\n\n        if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n            // restart amount of bytes downloaded\n            mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n        }\n\n        mF = mMission.storage.getStream();\n        mF.seek(mMission.offsets[mMission.current] + start);\n\n        mIs = mConn.getInputStream();\n\n        byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n        int len = 0;\n\n        while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n            mF.write(buf, 0, len);\n            start += len;\n            mMission.notifyProgress(len);\n        }\n\n        dispose();\n\n        // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n        done = len == -1;\n    } catch (Exception e) {\n        dispose();\n\n        mMission.fallbackResumeOffset = start;\n\n        if (!mMission.running || e instanceof ClosedByInterruptException) {\n            return;\n        }\n\n        if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n            // for youtube streams. The url has expired, recover\n            dispose();\n            mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n            return;\n        }\n\n        if (mRetryCount++ >= mMission.maxRetry) {\n            mMission.notifyError(e);\n            return;\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.e(TAG, \"got exception, retrying...\", e);\n        }\n\n        run(); // try again\n        return;\n    }\n\n    if (done) {\n        mMission.notifyFinished();\n    } else {\n        mMission.fallbackResumeOffset = start;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "15", "src_id": "M1141", "code": "\nprivate void flushAuxiliar(long amount) throws IOException {\n    if (aux.length < 1) {\n        return;\n    }\n\n    out.flush();\n    aux.flush();\n\n    boolean underflow = aux.offset < aux.length || out.offset < out.length;\n    byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n    aux.target.seek(0);\n    out.target.seek(out.length);\n\n    long length = amount;\n    while (length > 0) {\n        int read = (int) Math.min(length, Integer.MAX_VALUE);\n        read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n        if (read < 1) {\n            amount -= length;\n            break;\n        }\n\n        out.writeProof(buffer, read);\n        length -= read;\n    }\n\n    if (underflow) {\n        if (out.offset >= out.length) {\n            // calculate the aux underflow pointer\n            if (aux.offset < amount) {\n                out.offset += aux.offset;\n                aux.offset = 0;\n                out.target.seek(out.offset);\n            } else {\n                aux.offset -= amount;\n                out.offset = out.length + amount;\n            }\n        } else {\n            aux.offset = 0;\n        }\n    } else {\n        out.offset += amount;\n        aux.offset -= amount;\n    }\n\n    out.length += amount;\n\n    if (out.length > maxLengthKnown) {\n        maxLengthKnown = out.length;\n    }\n\n    if (amount < aux.length) {\n        // move the excess data to the beginning of the file\n        long readOffset = amount;\n        long writeOffset = 0;\n\n        aux.length -= amount;\n        length = aux.length;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            aux.target.seek(writeOffset);\n            aux.writeProof(buffer, read);\n\n            writeOffset += read;\n            readOffset += read;\n            length -= read;\n\n            aux.target.seek(readOffset);\n        }\n\n        aux.target.setLength(aux.length);\n        return;\n    }\n\n    if (aux.length > THRESHOLD_AUX_LENGTH) {\n        aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n    }\n\n    aux.reset();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "16", "src_id": "M1106", "code": "\nprivate void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n    StringBuilder request = new StringBuilder(256);\n    request.append(mission.source);\n\n    request.append(\" [\");\n    if (mission.recoveryInfo != null) {\n        for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n            request.append(' ')\n                .append(recovery.toString())\n                .append(' ');\n        }\n    }\n    request.append(\"]\");\n\n    String service;\n    try {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e) {\n        service = ErrorInfo.SERVICE_NONE;\n    }\n\n    ErrorUtil.createNotification(mContext,\n        new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action,\n            service, request.toString(), reason));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "17", "src_id": "M1067", "code": "\nsynchronized void startMission(DownloadMission mission) {\n    mission.timestamp = System.currentTimeMillis();\n    mission.mHandler = mHandler;\n    mission.maxRetry = mPrefMaxRetry;\n\n    // create metadata file\n    while (true) {\n        mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n        if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n            try {\n                if (!mission.metadata.createNewFile()) {\n                    throw new RuntimeException(\"Cant create download metadata file\");\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            break;\n        }\n        mission.timestamp = System.currentTimeMillis();\n    }\n\n    mSelfMissionsControl = true;\n    mMissionsPending.add(mission);\n\n    // Before continue, save the metadata in case the internet connection is not available\n    Utility.writeToFile(mission.metadata, mission);\n\n    if (mission.storage == null) {\n        // noting to do here\n        mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n        if (mission.errObject != null) {\n            mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n        }\n        return;\n    }\n\n    boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n    if (canDownloadInCurrentNetwork() && start) {\n        mission.start();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "18", "src_id": "M1136", "code": "\n@Override\nint process(SharpStream out, SharpStream... sources) throws IOException {\n    // check if the subtitle is already in srt and copy, this should never happen\n    String format = getArgumentAt(0, null);\n    boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n    if (format == null || format.equals(\"ttml\")) {\n        SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n\n        try {\n            writer.build(sources[0]);\n        } catch (Exception err) {\n            LOG.e(TAG, \"subtitle parse failed\", err);\n            return err instanceof IOException ? 1 : 8;\n        }\n\n        return OK_RESULT;\n    } else if (format.equals(\"srt\")) {\n        byte[] buffer = new byte[8 * 1024];\n        int read;\n        while ((read = sources[0].read(buffer)) > 0) {\n            out.write(buffer, 0, read);\n        }\n        return OK_RESULT;\n    }\n\n    throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "19", "src_id": "M1047", "code": "\nprivate void joinForThreads(int millis) {\n    final Thread currentThread = Thread.currentThread();\n\n    if (init != null && init != currentThread && init.isAlive()) {\n        init.interrupt();\n\n        if (millis > 0) {\n            try {\n                init.join(millis);\n            } catch (InterruptedException e) {\n                LOG.w(TAG, \"Initializer thread is still running\", e);\n                return;\n            }\n        }\n    }\n\n    // if a thread is still alive, possible reasons:\n    //      slow device\n    //      the user is spamming start/pause buttons\n    //      start() method called quickly after pause()\n\n    for (Thread thread : threads) {\n        if (!thread.isAlive() || thread == Thread.currentThread()) {\n            continue;\n        }\n        thread.interrupt();\n    }\n\n    try {\n        for (Thread thread : threads) {\n            if (!thread.isAlive()) {\n                continue;\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.w(TAG, \"thread alive: \" + thread.getName());\n            }\n            if (millis > 0) {\n                thread.join(millis);\n            }\n        }\n    } catch (InterruptedException e) {\n        throw new RuntimeException(\"A download thread is still running\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "20", "src_id": "M491", "code": "\n    @SuppressLint(\"SwitchIntDef\")\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,\n                                                   @ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT: {\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            }\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL: {\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            }\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default: {\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n            }\n        }\n\n        player.getPrefs().edit().putInt(\n                player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "21", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            closeItemsList();\n        } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            if (!fragmentIsVisible) {\n                onFragmentStopped();\n            }\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n            fragmentIsVisible = false;\n            onFragmentStopped();\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            fragmentIsVisible = true;\n            player.useVideoSource(true);\n\n            if (!isControlsVisible()) {\n                hideSystemUIIfNeeded();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "22", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n        final String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n            return R.style.BlackSettingsTheme;\n        } else if (selectedTheme.equals(automaticDeviceTheme)) {\n            if (isDeviceDarkThemeEnabled(context)) {\n                final String selectedNightTheme = getSelectedNightThemeKey(context);\n                if (selectedNightTheme.equals(blackTheme)) {\n                    return R.style.BlackSettingsTheme;\n                } else {\n                    return R.style.DarkSettingsTheme;\n                }\n            } else {\n                return R.style.LightSettingsTheme;\n            }\n        } else {\n            return R.style.DarkSettingsTheme;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "23", "src_id": "M895", "code": "\n                    @Override\n                    public Bitmap transform(final Bitmap source) {\n                        if (DEBUG) {\n                            Log.d(TAG, \"Thumbnail - transform() called\");\n                        }\n\n                        final float notificationThumbnailWidth = Math.min(\n                                context.getResources()\n                                        .getDimension(R.dimen.player_notification_thumbnail_width),\n                                source.getWidth());\n\n                        final Bitmap result = BitmapCompat.createScaledBitmap(\n                                source,\n                                (int) notificationThumbnailWidth,\n                                (int) (source.getHeight()\n                                        / (source.getWidth() / notificationThumbnailWidth)),\n                                null,\n                                true);\n\n                        if (result == source || !result.isMutable()) {\n                            final Bitmap copied = BitmapCompat.createScaledBitmap(\n                                    source,\n                                    (int) notificationThumbnailWidth - 1,\n                                    (int) (source.getHeight() / (source.getWidth()\n                                            / (notificationThumbnailWidth - 1))),\n                                    null,\n                                    true);\n                            source.recycle();\n                            return copied;\n                        } else {\n                            source.recycle();\n                            return result;\n                        }\n                    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "24", "src_id": "M225", "code": "\n    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY: {\n                pause();\n                break;\n            }\n            case ACTION_CLOSE: {\n                service.destroyPlayerAndStopService();\n                break;\n            }\n            case ACTION_PLAY_PAUSE: {\n                playPause();\n                break;\n            }\n            case ACTION_PLAY_PREVIOUS: {\n                playPrevious();\n                break;\n            }\n            case ACTION_PLAY_NEXT: {\n                playNext();\n                break;\n            }\n            case ACTION_FAST_REWIND: {\n                fastRewind();\n                break;\n            }\n            case ACTION_FAST_FORWARD: {\n                fastForward();\n                break;\n            }\n            case ACTION_REPEAT: {\n                cycleNextRepeatMode();\n                break;\n            }\n            case ACTION_SHUFFLE: {\n                toggleShuffleModeEnabled();\n                break;\n            }\n            case Intent.ACTION_CONFIGURATION_CHANGED: {\n                if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                }\n                break;\n            }\n        }\n\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "25", "src_id": "M749", "code": "\n    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null\n                && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n            Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n            Toast.makeText(context, R.string.restricted_video_no_stream,\n                    Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n            Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n            Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n            Toast.makeText(context, R.string.soundcloud_go_plus_content,\n                    Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n            Toast.makeText(context, R.string.youtube_music_premium_content,\n                    Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n            Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n        } else {\n            ErrorUtil.createNotification(context, errorInfo);\n        }\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "26", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@NonNull final Context context,\n                                               @NonNull final FragmentManager fragmentManager,\n                                               final int serviceId,\n                                               @Nullable final String url,\n                                               @NonNull final String title,\n                                               @Nullable final PlayQueue playQueue,\n                                               final boolean switchingPlayers) {\n\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else if (switchingPlayers) {\n            autoPlay = PlayerHolder.getInstance().isPlaying();\n        } else if (playerType == PlayerType.MAIN) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else {\n            autoPlay = false;\n        }\n\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (switchingPlayers) {\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP\n                        || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } else {\n                detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            }\n            detailFragment.scrollToTop();\n        };\n\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            final VideoDetailFragment instance = VideoDetailFragment\n                    .getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n\n            defaultTransaction(fragmentManager)\n                    .replace(R.id.fragment_player_holder, instance)\n                    .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n                    .commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "27", "src_id": "M698", "code": "\n    @Override\n    public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG)\n                    .into(binding.channelBannerImage);\n        } else {\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.subChannelAvatarView);\n\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization\n                    .shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(\n                    getString(R.string.channel_created_by),\n                    currentInfo.getParentChannelName())\n            );\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n\n        channelContentNotSupported = false;\n        for (final Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "28", "src_id": "M379", "code": "\n    @Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n                || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n                || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        final List<Tracks.Group> textTracks = currentTracks\n                .getGroups()\n                .stream()\n                .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n                .collect(Collectors.toList());\n        final List<String> availableLanguages = textTracks.stream()\n                .map(Tracks.Group::getMediaTrackGroup)\n                .filter(textTrack -> textTrack.length > 0)\n                .map(textTrack -> textTrack.getFormat(0).language)\n                .collect(Collectors.toList());\n\n        final Optional<Format> selectedTracks = textTracks.stream()\n                .filter(Tracks.Group::isSelected)\n                .filter(info -> info.getMediaTrackGroup().length >= 1)\n                .map(info -> info.getMediaTrackGroup().getFormat(0))\n                .findFirst();\n\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(\n                player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(\n                availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "29", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(final Context context,\n                                                         @NonNull final List<Image> images) {\n        return PicassoHelper.loadThumbnail(images)\n                .transform(new Transformation() {\n                    @Override\n                    public Bitmap transform(final Bitmap source) {\n                        if (DEBUG) {\n                            Log.d(TAG, \"Thumbnail - transform() called\");\n                        }\n\n                        final float notificationThumbnailWidth = Math.min(\n                                context.getResources()\n                                        .getDimension(R.dimen.player_notification_thumbnail_width),\n                                source.getWidth());\n\n                        final Bitmap result = BitmapCompat.createScaledBitmap(\n                                source,\n                                (int) notificationThumbnailWidth,\n                                (int) (source.getHeight()\n                                        / (source.getWidth() / notificationThumbnailWidth)),\n                                null,\n                                true);\n\n                        if (result == source || !result.isMutable()) {\n                            final Bitmap copied = BitmapCompat.createScaledBitmap(\n                                    source,\n                                    (int) notificationThumbnailWidth - 1,\n                                    (int) (source.getHeight() / (source.getWidth()\n                                            / (notificationThumbnailWidth - 1))),\n                                    null,\n                                    true);\n                            source.recycle();\n                            return copied;\n                        } else {\n                            source.recycle();\n                            return result;\n                        }\n                    }\n\n                    @Override\n                    public String key() {\n                        return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                    }\n                });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "30", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) throw new IllegalArgumentException(\"EML file is empty or null\");\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC/BCC if requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            if (!bcc.trim().isEmpty()) html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n        }\n\n        if (!date.trim().isEmpty()) html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        html.append(\"</div></div>\\n\");\n\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n\n        return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "31", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n\n        try {\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) return false;\n\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "32", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) \n                            value.append(\" \").append(lines[j].trim());\n                        else \n                            break;\n                    }\n                    return safeMimeDecode(value.toString());\n                }\n                if (line.trim().isEmpty()) break;\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "33", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(\n            PDDocument document, List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) return;\n\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true);\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n                    markerPositions.size(), attachments.size());\n        }\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "34", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n\n        return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "35", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n\n        try {\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "36", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[j].trim());\n                        } else {\n                            break;\n                        }\n                    }\n                    return safeMimeDecode(value.toString());\n                }\n                if (line.trim().isEmpty()) break;\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "37", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(\n            PDDocument document, List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true);\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n                    markerPositions.size(), attachments.size());\n        }\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "38", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    if (input == null) {\n        throw new NullPointerException(\"Input map cannot be null.\");\n    }\n\n    Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "39", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach(entry -> \n            args.add(entry.getKey()).add(entry.getValue())\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "40", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE:\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE:\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "41", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    if (data == null || !(data instanceof List)) {\n        return null;\n    }\n\n    List<?> list = (List<?>) data;\n    if (list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (Object item : list) {\n            KeyValue keyValue = (KeyValue) item;\n            String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        if (resultsData == null) {\n            throw new IllegalStateException(\"Could not detect Results data.\");\n        }\n        if (profileData == null) {\n            throw new IllegalStateException(\"Could not detect Profile data.\");\n        }\n\n        return KeyValue.of(\n            resultsBuilder.build(resultsData),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData)\n        );\n    }\n\n    return KeyValue.of(\n        resultsBuilder.build(list.get(0)),\n        ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1))\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    if (keystoreResource != null) {\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "43", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(Object data) {\n    if (!(data instanceof List<?>)) {\n        return null;\n    }\n\n    List<KeyValue> list = (List<KeyValue>) data;\n    Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rules;\n                    break;\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = new HashMap<>();\n                        for (KeyValue kv : chunkDataAsList) {\n                            String chunkKey = BuilderFactory.STRING.build(kv.getKey());\n                            Object chunkValue = BuilderFactory.ENCODED_OBJECT.build(kv.getValue());\n                            chunk.put(chunkKey, chunkValue);\n                        }\n                        chunks.add(chunk);\n                    }\n                    value = chunks;\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (IllegalArgumentException ignored) {\n                }\n            }\n        }\n\n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "44", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach(entry -> \n            args.add(entry.getKey()).add(entry.getValue())\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n    JedisException suppressed = null;\n\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis != null) {\n                jedis.ping();\n                return jedis;\n            }\n        } catch (JedisException ex) {\n            if (suppressed == null) {\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "46", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        \n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            Set<CacheKey<?>> keySet = redisKeysToCacheKeys.computeIfAbsent(mapKey, \n                k -> ConcurrentHashMap.newKeySet()\n            );\n            keySet.add(cacheKey);\n        }\n        \n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "47", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    \n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "48", "src_id": "M270", "code": "\n\tprivate static String normalizeArch(String value) {\n\t    value = normalize(value);\n\t    if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) return \"x86_64\";\n\t    if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) return \"x86_32\";\n\t    if (value.matches(\"^(ia64w?|itanium64)$\")) return \"itanium_64\";\n\t    if (\"ia64n\".equals(value)) return \"itanium_32\";\n\t    if (value.matches(\"^(sparc|sparc32)$\")) return \"sparc_32\";\n\t    if (value.matches(\"^(sparcv9|sparc64)$\")) return \"sparc_64\";\n\t    if (value.matches(\"^(arm|arm32)$\")) return \"arm_32\";\n\t    if (\"aarch64\".equals(value)) return \"aarch_64\";\n\t    if (value.matches(\"^(mips|mips32)$\")) return \"mips_32\";\n\t    if (value.matches(\"^(mipsel|mips32el)$\")) return \"mipsel_32\";\n\t    if (\"mips64\".equals(value)) return \"mips_64\";\n\t    if (\"mips64el\".equals(value)) return \"mipsel_64\";\n\t    if (value.matches(\"^(ppc|ppc32)$\")) return \"ppc_32\";\n\t    if (value.matches(\"^(ppcle|ppc32le)$\")) return \"ppcle_32\";\n\t    if (\"ppc64\".equals(value)) return \"ppc_64\";\n\t    if (\"ppc64le\".equals(value)) return \"ppcle_64\";\n\t    if (\"s390\".equals(value)) return \"s390_32\";\n\t    if (\"s390x\".equals(value)) return \"s390_64\";\n\t    return value;\n\t}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "49", "src_id": "M928", "code": "\n    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n        Map<String, Object> info = new HashMap<String, Object>();\n        info.put(LoggerHelper.name, logger.getName());\n        info.put(LoggerHelper.clazz, logger.getClass());\n        CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n        if (codeSource != null) info.put(LoggerHelper.codeSource, codeSource.getLocation());\n        info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n        Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n        if (level != null) info.put(LoggerHelper.level, level.toString());\n        if (effectiveLevel != null) info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n        info.put(LoggerHelper.appenders, result);\n        return info;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "50", "src_id": "M9", "code": "\n    @SuppressWarnings(\"resource\")\n    public static long select(boolean v, long telnetPortPid, String select) throws InputMismatchException {\n        Map<Long, String> processMap = listProcessByJps(v);\n        if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n            String telnetPortProcess = processMap.get(telnetPortPid);\n            processMap.remove(telnetPortPid);\n            Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n            newProcessMap.put(telnetPortPid, telnetPortProcess);\n            newProcessMap.putAll(processMap);\n            processMap = newProcessMap;\n        }\n\n        if (processMap.isEmpty()) {\n            AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n            return -1;\n        }\n\n        if (select != null && !select.trim().isEmpty()) {\n            int matchedSelectCount = 0;\n            Long matchedPid = null;\n            for (Entry<Long, String> entry : processMap.entrySet()) {\n                if (entry.getValue().contains(select)) {\n                    matchedSelectCount++;\n                    matchedPid = entry.getKey();\n                }\n            }\n            if (matchedSelectCount == 1) return matchedPid;\n        }\n\n        AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n        int count = 1;\n        for (String process : processMap.values()) {\n            System.out.println((count == 1 ? \"* [\" : \"  [\") + count + \"]: \" + process);\n            count++;\n        }\n\n        String line = new Scanner(System.in).nextLine();\n        if (line.trim().isEmpty()) return processMap.keySet().iterator().next();\n\n        int choice = new Scanner(line).nextInt();\n        if (choice <= 0 || choice > processMap.size()) return -1;\n\n        Iterator<Long> idIter = processMap.keySet().iterator();\n        for (int i = 1; i <= choice; ++i) {\n            if (i == choice) return idIter.next();\n            idIter.next();\n        }\n        return -1;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "51", "src_id": "M140", "code": "\n    void _processDo(int option) throws IOException {\n        if (debugoptions) System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n        if (__notifhand != null) __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n\n        boolean acceptNewState = false;\n        if (optionHandlers[option] != null) acceptNewState = optionHandlers[option].getAcceptLocal();\n        else if (option == TERMINAL_TYPE && terminalType != null && terminalType.length() > 0) acceptNewState = true;\n\n        if (_willResponse[option] > 0) {\n            --_willResponse[option];\n            if (_willResponse[option] > 0 && _stateIsWill(option)) --_willResponse[option];\n        }\n\n        if (_willResponse[option] == 0) {\n            if (_requestedWont(option)) {\n                if (acceptNewState) {\n                    _setWantWill(option);\n                    _sendWill(option);\n                } else {\n                    ++_willResponse[option];\n                    _sendWont(option);\n                }\n            }\n        }\n        _setWill(option);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "52", "src_id": "M1324", "code": "\n    private void bind(Configure configure) throws Throwable {\n        long start = System.currentTimeMillis();\n        if (!isBindRef.compareAndSet(false, true)) throw new IllegalStateException(\"already bind\");\n\n        if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n            int newTelnetPort = SocketUtils.findAvailableTcpPort();\n            configure.setTelnetPort(newTelnetPort);\n            logger().info(\"generate random telnet port: \" + newTelnetPort);\n        }\n        if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n            int newHttpPort = SocketUtils.findAvailableTcpPort();\n            configure.setHttpPort(newHttpPort);\n            logger().info(\"generate random http port: \" + newHttpPort);\n        }\n        if (configure.getAppName() == null) configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME,\n                    System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n\n        try {\n            if (configure.getTunnelServer() != null) {\n                tunnelClient = new TunnelClient();\n                tunnelClient.setAppName(configure.getAppName());\n                tunnelClient.setId(configure.getAgentId());\n                tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n                tunnelClient.setVersion(ArthasBanner.version());\n                ChannelFuture channelFuture = tunnelClient.start();\n                channelFuture.await(10, TimeUnit.SECONDS);\n            }\n        } catch (Throwable t) { logger().error(\"start tunnel client error\", t); }\n\n        try {\n            ShellServerOptions options = new ShellServerOptions()\n                .setInstrumentation(instrumentation)\n                .setPid(PidUtils.currentLongPid())\n                .setWelcomeMessage(ArthasBanner.welcome());\n            if (configure.getSessionTimeout() != null) options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n\n            this.httpSessionManager = new HttpSessionManager();\n            if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n                String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \"\n                    + \"No password is currently configured. \" + \"Therefore, a default password is generated, \"\n                    + \"and clients need to use the password to connect!\";\n                AnsiLog.error(errorMsg);\n                configure.setPassword(StringUtils.randomString(64));\n                AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n                logger().error(errorMsg);\n                logger().info(\"Generated arthas password: \" + configure.getPassword());\n            }\n\n            this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n            shellServer = new ShellServerImpl(options);\n\n            List<String> disabledCommands = new ArrayList<String>();\n            if (configure.getDisabledCommands() != null) {\n                String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n                if (strings != null) disabledCommands.addAll(Arrays.asList(strings));\n            }\n            BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n            List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n            resolvers.add(builtinCommands);\n\n            workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n            if (configure.getTelnetPort() != null && configure.getTelnetPort() > 0) {\n                logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n                shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(),\n                        options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n            \n            if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n                logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n                shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(),\n                        options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else {\n                if (configure.getTunnelServer() != null) shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(),\n                        options.getConnectionTimeout(), workerGroup, httpSessionManager));\n                logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n            }\n\n            for (CommandResolver resolver : resolvers) shellServer.registerCommandResolver(resolver);\n            shellServer.listen(new BindHandler(isBindRef));\n            if (!isBind()) throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \"\n                    + String.valueOf(configure.getTelnetPort()) + \", http port: \" + String.valueOf(configure.getHttpPort()));\n\n            sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n            httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n            logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(),\n                    configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n            if (configure.getStatUrl() != null) logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n            UserStatUtil.setStatUrl(configure.getStatUrl());\n            UserStatUtil.setAgentId(configure.getAgentId());\n            UserStatUtil.arthasStart();\n\n            try { SpyAPI.init(); } catch (Throwable e) { /* ignore */ }\n            logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n        } catch (Throwable e) {\n            logger().error(\"Error during start as-server\", e);\n            destroy();\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "53", "src_id": "M122", "code": "\n    private int __read(boolean mayBlock) throws IOException {\n        int ch;\n        for (;;) {\n            if (!mayBlock && super.available() == 0) return WOULD_BLOCK;\n            if ((ch = super.read()) < 0) return EOF;\n            ch = (ch & 0xff);\n\n            synchronized (__client) __client._processAYTResponse();\n            __client._spyRead(ch);\n\n            switch (__receiveState) {\n            case _STATE_CR:\n                if (ch == '\\0') continue;\n            case _STATE_DATA:\n                if (ch == TelnetCommand.IAC) {\n                    __receiveState = _STATE_IAC;\n                    continue;\n                }\n                if (ch == '\\r') {\n                    synchronized (__client) __receiveState = __client._requestedDont(TelnetOption.BINARY) ? _STATE_CR : _STATE_DATA;\n                } else __receiveState = _STATE_DATA;\n                break;\n            case _STATE_IAC:\n                switch (ch) {\n                case TelnetCommand.WILL: __receiveState = _STATE_WILL; continue;\n                case TelnetCommand.WONT: __receiveState = _STATE_WONT; continue;\n                case TelnetCommand.DO: __receiveState = _STATE_DO; continue;\n                case TelnetCommand.DONT: __receiveState = _STATE_DONT; continue;\n                case TelnetCommand.SB: __suboption_count = 0; __receiveState = _STATE_SB; continue;\n                case TelnetCommand.IAC: __receiveState = _STATE_DATA; break;\n                case TelnetCommand.SE: __receiveState = _STATE_DATA; continue;\n                default: __receiveState = _STATE_DATA; __client._processCommand(ch); continue;\n                }\n                break;\n            case _STATE_WILL:\n                synchronized (__client) { __client._processWill(ch); __client._flushOutputStream(); }\n                __receiveState = _STATE_DATA; continue;\n            case _STATE_WONT:\n                synchronized (__client) { __client._processWont(ch); __client._flushOutputStream(); }\n                __receiveState = _STATE_DATA; continue;\n            case _STATE_DO:\n                synchronized (__client) { __client._processDo(ch); __client._flushOutputStream(); }\n                __receiveState = _STATE_DATA; continue;\n            case _STATE_DONT:\n                synchronized (__client) { __client._processDont(ch); __client._flushOutputStream(); }\n                __receiveState = _STATE_DATA; continue;\n            case _STATE_SB:\n                switch (ch) {\n                case TelnetCommand.IAC: __receiveState = _STATE_IAC_SB; continue;\n                default:\n                    if (__suboption_count < __suboption.length) __suboption[__suboption_count++] = ch;\n                    break;\n                }\n                __receiveState = _STATE_SB; continue;\n            case _STATE_IAC_SB:\n                switch (ch) {\n                case TelnetCommand.SE:\n                    synchronized (__client) { __client._processSuboption(__suboption, __suboption_count); __client._flushOutputStream(); }\n                    __receiveState = _STATE_DATA; continue;\n                case TelnetCommand.IAC:\n                    if (__suboption_count < __suboption.length) __suboption[__suboption_count++] = ch;\n                    break;\n                }\n                __receiveState = _STATE_SB; continue;\n            }\n            break;\n        }\n        return ch;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "54", "src_id": "M8", "code": "\n    private static String formatFileSize(long size) {\n        double b = size;\n        double k = size / 1024.0;\n        double m = k / 1024.0;\n        double g = m / 1024.0;\n        double t = g / 1024.0;\n\n        DecimalFormat dec = new DecimalFormat(\"0.00\");\n        if (t > 1) return dec.format(t).concat(\" TB\");\n        if (g > 1) return dec.format(g).concat(\" GB\");\n        if (m > 1) return dec.format(m).concat(\" MB\");\n        if (k > 1) return dec.format(k).concat(\" KB\");\n        return dec.format(b).concat(\" Bytes\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "55", "src_id": "M790", "code": "\n        @Override\n        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n                ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n            if (className == null) return null;\n            className = className.replace('/', '.');\n            List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n            ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n            while (listIterator.hasPrevious()) {\n                RetransformEntry retransformEntry = listIterator.previous();\n                int id = retransformEntry.getId();\n                boolean updateFlag = false;\n                if (className.equals(retransformEntry.getClassName())) {\n                    if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) updateFlag = isLoaderMatch(retransformEntry, loader);\n                    else updateFlag = true;\n                }\n                if (updateFlag) {\n                    logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", \n                            className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n                    retransformEntry.incTransformCount();\n                    return retransformEntry.getBytes();\n                }\n            }\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "56", "src_id": "M716", "code": "\n    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n        table.row(\"IS-RETURN\", \"\" + false);\n        table.row(\"IS-EXCEPTION\", \"\" + true);\n        Throwable cause;\n        Throwable t = (Throwable) throwableVO.getObject();\n        cause = t instanceof InvocationTargetException ? t.getCause() : t;\n\n        if (throwableVO.needExpand()) table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n        else {\n            StringWriter stringWriter = new StringWriter();\n            PrintWriter printWriter = new PrintWriter(stringWriter);\n            try {\n                cause.printStackTrace(printWriter);\n                table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n            } finally { printWriter.close(); }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "57", "src_id": "M602", "code": "\n    private AsyncProfiler profilerInstance() {\n        if (profiler != null) return profiler;\n        if (ProfilerAction.load.toString().equals(action)) profiler = AsyncProfiler.getInstance(this.actionArg);\n        if (libPath != null) {\n            FileOutputStream tmpLibOutputStream = null;\n            FileInputStream libInputStream = null;\n            try {\n                File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n                tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n                libInputStream = new FileInputStream(libPath);\n                IOUtils.copy(libInputStream, tmpLibOutputStream);\n                libPath = tmpLibFile.getAbsolutePath();\n                logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n            } catch (Throwable e) { logger.error(\"try to copy lib error! libPath: {}\", libPath, e); }\n            finally { \n                IOUtils.close(libInputStream);\n                IOUtils.close(tmpLibOutputStream);\n            }\n            profiler = AsyncProfiler.getInstance(libPath);\n        } else {\n            if (OSUtils.isLinux() || OSUtils.isMac()) throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n            else throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n        }\n        return profiler;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "58", "src_id": "M475", "code": "\n@Override\npublic void draw(CommandProcess process, JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n        String group = entry.getKey();\n        List<JvmItemVO> items = entry.getValue();\n\n        table.row(true, label(group).style(Decoration.bold.bold()));\n        for (JvmItemVO item : items) {\n            String valueStr;\n            if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                valueStr = renderMemoryUsage((Map<String, Object>) item.getValue());\n            } else {\n                valueStr = renderItemValue(item.getValue());\n            }\n            if (item.getDesc() != null) {\n                table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n            } else {\n                table.row(item.getName(), valueStr);\n            }\n        }\n        table.row(\"\", \"\");\n    }\n\n    process.write(RenderUtil.render(table, process.width()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "59", "src_id": "M535", "code": "\npublic static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n    StringBuilder infoSB = new StringBuilder();\n    List<String> classDumpFiles = affectVO.getClassDumpFiles();\n    if (classDumpFiles != null) {\n        for (String classDumpFile : classDumpFiles) {\n            infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n        }\n    }\n\n    List<String> methods = affectVO.getMethods();\n    if (methods != null) {\n        for (String method : methods) {\n            infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n        }\n    }\n\n    infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\",\n            affectVO.getClassCount(),\n            affectVO.getMethodCount(),\n            affectVO.getCost(),\n            affectVO.getListenerId()));\n    if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n        infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n    }\n    if (affectVO.getThrowable() != null) {\n        infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n    }\n    infoSB.append(\"\\n\");\n\n    return infoSB.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "60", "src_id": "M753", "code": "\npublic List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n\n    List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n\n    // Sample CPU\n    if (lastCpuTimes.isEmpty()) {\n        lastSampleTimeNanos = System.nanoTime();\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                lastCpuTimes.put(thread, cpu);\n                thread.setTime(cpu / 1000000);\n            }\n        }\n\n        // add internal threads\n        Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (internalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                String key = entry.getKey();\n                ThreadVO thread = createThreadVO(key);\n                thread.setTime(entry.getValue() / 1000000);\n                threads.add(thread);\n                lastCpuTimes.put(thread, entry.getValue());\n            }\n        }\n\n        //sort by time\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n            @Override\n            public int compare(ThreadVO o1, ThreadVO o2) {\n                long l1 = o1.getTime();\n                long l2 = o2.getTime();\n                if (l1 < l2) return 1;\n                else if (l1 > l2) return -1;\n                else return 0;\n            }\n        });\n        return threads;\n    }\n\n    // Resample\n    long newSampleTimeNanos = System.nanoTime();\n    Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : threads) {\n        if (thread.getId() > 0) {\n            long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n            newCpuTimes.put(thread, cpu);\n        }\n    }\n    // internal threads\n    Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n    if (newInternalThreadCpuTimes != null) {\n        for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n            ThreadVO threadVO = createThreadVO(entry.getKey());\n            threads.add(threadVO);\n            newCpuTimes.put(threadVO, entry.getValue());\n        }\n    }\n\n    // Compute delta time\n    Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : newCpuTimes.keySet()) {\n        Long t = lastCpuTimes.get(thread);\n        if (t == null) t = 0L;\n        long time1 = t;\n        long time2 = newCpuTimes.get(thread);\n        if (time1 == -1) time1 = time2;\n        else if (time2 == -1) time2 = time1;\n        long delta = time2 - time1;\n        deltas.put(thread, delta);\n    }\n\n    long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n\n    // Compute cpu usage\n    HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n    for (ThreadVO thread : threads) {\n        double cpu = sampleIntervalNanos == 0 ? 0 : \n            (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0;\n        cpuUsages.put(thread, cpu);\n    }\n\n    // Sort by CPU time\n    Collections.sort(threads, new Comparator<ThreadVO>() {\n        @Override\n        public int compare(ThreadVO o1, ThreadVO o2) {\n            long l1 = deltas.get(o1);\n            long l2 = deltas.get(o2);\n            if (l1 < l2) return 1;\n            else if (l1 > l2) return -1;\n            else return 0;\n        }\n    });\n\n    for (ThreadVO thread : threads) {\n        //nanos to mills\n        long timeMills = newCpuTimes.get(thread) / 1000000;\n        long deltaTime = deltas.get(thread) / 1000000;\n        double cpu = cpuUsages.get(thread);\n\n        thread.setCpu(cpu);\n        thread.setTime(timeMills);\n        thread.setDeltaTime(deltaTime);\n    }\n    lastCpuTimes = newCpuTimes;\n    lastSampleTimeNanos = newSampleTimeNanos;\n\n    return threads;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "61", "src_id": "M1131", "code": "\nprivate ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<String, Object>();\n    body.put(\"command\", commandLine);\n\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId())\n            .setBody(body);\n\n    if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED)\n                .setMessage(\"Another command is executing.\");\n        return response;\n    }\n    int lock = session.getLock();\n    try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n            response.setState(ApiState.REFUSED)\n                    .setMessage(\"Another job is running.\");\n            logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n            return response;\n        }\n\n        //create job\n        Job job = this.createJob(commandLine, session, session.getResultDistributor());\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        response.setState(ApiState.SCHEDULED);\n\n        //add command before exec job\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n        commandRequestModel.setJobId(job.id());\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) {\n            resultDistributor.appendResult(commandRequestModel);\n        }\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n        //run job\n        job.run();\n\n        return response;\n    } catch (Throwable e) {\n        logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n        CommandRequestModel commandRequestModel = new CommandRequestModel(\n            commandLine, response.getState(), response.getMessage()\n        );\n        session.getResultDistributor().appendResult(commandRequestModel);\n        return response;\n    } finally {\n        if (session.getLock() == lock) {\n            session.unLock();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "62", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoader)))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.level)));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.additivity)))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                        label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                appendersTable.row(label(LoggerHelper.classLoaderHash),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target),\n                            label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking),\n                            label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef),\n                            label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "63", "src_id": "M15", "code": "\npublic static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n    URLClassLoader classLoader = new URLClassLoader(\n            new URL[]{new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n    Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n    Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n\n    PrintStream originSysOut = System.out;\n    PrintStream originSysErr = System.err;\n    PrintStream newOut = new PrintStream(out);\n    PrintStream newErr = new PrintStream(out);\n\n    ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n    try {\n        System.setOut(newOut);\n        System.setErr(newErr);\n        Thread.currentThread().setContextClassLoader(classLoader);\n        return (Integer) processMethod.invoke(null, new Object[]{telnetArgs.toArray(new String[0])});\n    } catch (Throwable e) {\n        e = e.getCause();\n        if (e instanceof IOException || e instanceof InterruptedException) {\n            return STATUS_ERROR;\n        } else {\n            AnsiLog.error(\"process error: {}\", e.toString());\n            AnsiLog.error(e);\n            return STATUS_EXEC_ERROR;\n        }\n    } finally {\n        Thread.currentThread().setContextClassLoader(tccl);\n        System.setOut(originSysOut);\n        System.setErr(originSysErr);\n        newOut.flush();\n        newErr.flush();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "64", "src_id": "M1469", "code": "\npublic static FieldVO[] getFields(Class clazz, Integer expand) {\n    Field[] fields = clazz.getDeclaredFields();\n    if (fields.length == 0) return new FieldVO[0];\n\n    List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n    for (Field field : fields) {\n        FieldVO fieldVO = new FieldVO();\n        fieldVO.setName(field.getName());\n        fieldVO.setType(StringUtils.classname(field.getType()));\n        fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n        fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n        if (Modifier.isStatic(field.getModifiers())) {\n            fieldVO.setStatic(true);\n            fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n        } else {\n            fieldVO.setStatic(false);\n        }\n        list.add(fieldVO);\n    }\n    return list.toArray(new FieldVO[0]);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "65", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(final Map<String, Object> input, final boolean stringEscape) {\n    final Map<String, String> output = new HashMap<>(input.size());\n    for (final Map.Entry<String, Object> entry : input.entrySet()) {\n        final String key = entry.getKey();\n        final Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        final String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            final redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "66", "src_id": "M902", "code": "\n@Override\npublic void addParams(final CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach(entry -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "67", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE: // TODO:\n            return processMultiBulkReply(is);\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        // TODO: Blob error '!'\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "68", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(final Object data) {\n    final List list = (List) data;\n    if (list == null || list.isEmpty()) return null;\n\n    if (list.get(0) instanceof KeyValue) { // RESP3\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (final KeyValue keyValue : (List<KeyValue>) data) {\n            final String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        assert resultsData != null : \"Could not detect Results data.\";\n        assert profileData != null : \"Could not detect Profile data.\";\n        return KeyValue.of(resultsBuilder.build(resultsData),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n    }\n\n    return KeyValue.of(resultsBuilder.build(list.get(0)),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    if (keystoreResource != null) {\n        final KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (final InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n\n        final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        final KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (final InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n\n        final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    final SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "70", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(final Object data) {\n    final List<KeyValue> list = (List<KeyValue>) data;\n    final Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (final KeyValue propertyValue : list) {\n        final String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    final List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    final Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (final KeyValue rkv : rulesDataList) {\n                        final String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        final List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rulesValueMap;\n                    break;\n                case CHUNKS_PROPERTY:\n                    final List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    final List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (final List<KeyValue> chunkDataAsList : chunksDataList) {\n                        final Map<String, Object> chunk = chunkDataAsList.stream()\n                                .collect(Collectors.toMap(\n                                    kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                    kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())\n                                ));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n                    value = chunksValueList;\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "71", "src_id": "M897", "code": "\n@Override\npublic void addParams(final CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach(entry -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    final List<ConnectionPool> pools = getShuffledNodesPool();\n    JedisException suppressed = null;\n\n    for (final ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) {\n                continue;\n            }\n            jedis.ping();\n            return jedis;\n        } catch (final JedisException ex) {\n            if (suppressed == null) {\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    final JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "73", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(final CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        final EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        final CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (final Object redisKey : cacheKey.getRedisKeys()) {\n            final ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            } else {\n                final Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "74", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(final Object data) {\n    if (data == null) return null;\n    final String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    final Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        final String key = entry.getKey();\n        final Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        final String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "76", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        for (Map.Entry<String, String> entry : labels.entrySet()) {\n            args.add(entry.getKey()).add(entry.getValue());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE:\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE:\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "78", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    final List list = (List) data;\n    if (list == null || list.isEmpty()) return null;\n\n    if (list.get(0) instanceof KeyValue) {\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (final KeyValue keyValue : (List<KeyValue>) data) {\n            final String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        assert resultsData != null : \"Could not detect Results data.\";\n        assert profileData != null : \"Could not detect Profile data.\";\n        return KeyValue.of(resultsBuilder.build(resultsData),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n    }\n\n    return KeyValue.of(resultsBuilder.build(list.get(0)),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "79", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[]{INSECURE_TRUST_MANAGER};\n    }\n\n    if (keystoreResource != null) {\n        final KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n        final KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        final KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n        final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    final SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "80", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(Object data) {\n    final List<KeyValue> list = (List<KeyValue>) data;\n    final Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        final String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    final List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    final Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        final String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        final List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rulesValueMap;\n                    break;\n                case CHUNKS_PROPERTY:\n                    final List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    final List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        final Map<String, Object> chunk = chunkDataAsList.stream()\n                                .collect(Collectors.toMap(\n                                        kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                        kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())\n                                ));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n                    value = chunksValueList;\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) {\n                    // Ignore\n                }\n            }\n        }\n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "81", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        for (Map.Entry<String, String> entry : labels.entrySet()) {\n            args.add(entry.getKey()).add(entry.getValue());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "82", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    final List<ConnectionPool> pools = getShuffledNodesPool();\n    JedisException suppressed = null;\n\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) continue;\n            \n            jedis.ping();\n            return jedis;\n        } catch (JedisException ex) {\n            if (suppressed == null) suppressed = ex;\n            if (jedis != null) jedis.close();\n        }\n    }\n\n    final JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) noReachableNode.addSuppressed(suppressed);\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "83", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        final EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        final CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            final ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            } else {\n                final Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "84", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) return null;\n    final String str = STRING.build(data);\n    switch (str) {\n        case \"null\": return null;\n        case \"boolean\": return boolean.class;\n        case \"integer\": return int.class;\n        case \"number\": return float.class;\n        case \"string\": return String.class;\n        case \"object\": return Object.class;\n        case \"array\": return List.class;\n        default: throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "85", "src_id": "M1277", "code": "\n    public static Map<String, String> toStringMap(Map<String, Object> input, final boolean stringEscape) {\n        final Map<String, String> output = new HashMap<>(input.size());\n        for (final Map.Entry<String, Object> entry : input.entrySet()) {\n            final String key = entry.getKey();\n            final Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n\n            final String str;\n            if (obj instanceof byte[]) {\n                str = SafeEncoder.encode((byte[]) obj);\n            } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                final redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                str = geo.getLongitude() + \",\" + geo.getLatitude();\n            } else if (obj instanceof String) {\n                str = stringEscape ? escape((String) obj) : (String) obj;\n            } else {\n                str = String.valueOf(obj);\n            }\n            output.put(key, str);\n        }\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "86", "src_id": "M902", "code": "\n    @Override\n    public void addParams(final CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> \n                args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "87", "src_id": "M1131", "code": "\n    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE: // TODO:\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "88", "src_id": "M1057", "code": "\n    @Override\n    public Map.Entry<T, ProfilingInfo> build(final Object data) {\n        final List list = (List) data;\n        if (list == null || list.isEmpty()) return null;\n\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null;\n            Object profileData = null;\n\n            for (final KeyValue keyValue : (List<KeyValue>) data) {\n                final String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n            return KeyValue.of(\n                resultsBuilder.build(resultsData),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData)\n            );\n        }\n\n        return KeyValue.of(\n            resultsBuilder.build(list.get(0)),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1))\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "89", "src_id": "M1229", "code": "\n    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n\n        if (sslVerifyMode == SslVerifyMode.FULL) {\n            sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } else if (sslVerifyMode == SslVerifyMode.CA) {\n            sslParameters.setEndpointIdentificationAlgorithm(\"\");\n        } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n            trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n        }\n\n        if (keystoreResource != null) {\n            final KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (final InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n\n            final KeyManagerFactory keyManagerFactory = \n                KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n            final KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (final InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n\n            final TrustManagerFactory trustManagerFactory = \n                TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n\n        final SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "90", "src_id": "M894", "code": "\n    @Override\n    public TSInfo build(final Object data) {\n        final List<KeyValue> list = (List<KeyValue>) data;\n        final Map<String, Object> properties = new HashMap<>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n\n        for (final KeyValue propertyValue : list) {\n            final String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            \n            if (value instanceof List) {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n                        value = labels;\n                        break;\n                    case RULES_PROPERTY:\n                        final List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                        final Map<String, List<Object>> rulesValueMap = \n                            new HashMap<>(rulesDataList.size(), 1f);\n                        rules = new HashMap<>(rulesDataList.size());\n                        for (final KeyValue rkv : rulesDataList) {\n                            final String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            final List<Object> ruleValueList = \n                                BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                        }\n                        value = rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        final List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                        final List<Map<String, Object>> chunksValueList = \n                            new ArrayList<>(chunksDataList.size());\n                        chunks = new ArrayList<>(chunksDataList.size());\n                        for (final List<KeyValue> chunkDataAsList : chunksDataList) {\n                            final Map<String, Object> chunk = chunkDataAsList.stream()\n                                .collect(Collectors.toMap(\n                                    kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                    kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())\n                                ));\n                            chunksValueList.add(chunk);\n                            chunks.add(chunk);\n                        }\n                        value = chunksValueList;\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } else if (value instanceof byte[]) {\n                value = BuilderFactory.STRING.build(value);\n                if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                    try {\n                        value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                    } catch (Exception e) {\n                        // Ignore\n                    }\n                }\n            }\n            properties.put(prop, value);\n        }\n\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "91", "src_id": "M897", "code": "\n    @Override\n    public void addParams(final CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> \n                args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "92", "src_id": "M1213", "code": "\n    @Override\n    public Connection getConnection() {\n        final List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n\n        for (final ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) continue;\n                \n                jedis.ping();\n                return jedis;\n            } catch (final JedisException ex) {\n                if (suppressed == null) suppressed = ex;\n                if (jedis != null) jedis.close();\n            }\n        }\n\n        final JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) noReachableNode.addSuppressed(suppressed);\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "93", "src_id": "M9", "code": "\n    @Override\n    public CacheEntry set(final CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            final EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            \n            final CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n            \n            for (final Object redisKey : cacheKey.getRedisKeys()) {\n                final ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    final Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n            stats.load();\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "94", "src_id": "M1105", "code": "\n    @Override\n    public Class<?> build(final Object data) {\n        if (data == null) return null;\n        final String str = STRING.build(data);\n        \n        switch (str) {\n            case \"null\": return null;\n            case \"boolean\": return boolean.class;\n            case \"integer\": return int.class;\n            case \"number\": return float.class;\n            case \"string\": return String.class;\n            case \"object\": return Object.class;\n            case \"array\": return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "95", "src_id": "M270", "code": "\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64w?|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (\"ia64n\".equals(value)) {\n            return \"itanium_32\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(mips|mips32)$\")) {\n            return \"mips_32\";\n        }\n        if (value.matches(\"^(mipsel|mips32el)$\")) {\n            return \"mipsel_32\";\n        }\n        if (\"mips64\".equals(value)) {\n            return \"mips_64\";\n        }\n        if (\"mips64el\".equals(value)) {\n            return \"mipsel_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (value.matches(\"^(ppcle|ppc32le)$\")) {\n            return \"ppcle_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n        return value;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "96", "src_id": "M928", "code": "\n    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n        Map<String, Object> info = new HashMap<>();\n        info.put(LoggerHelper.name, logger.getName());\n        info.put(LoggerHelper.clazz, logger.getClass());\n        \n        CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n        if (codeSource != null) {\n            info.put(LoggerHelper.codeSource, codeSource.getLocation());\n        }\n        info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n        Level level = logger.getLevel();\n        Level effectiveLevel = logger.getEffectiveLevel();\n        if (level != null) {\n            info.put(LoggerHelper.level, level.toString());\n        }\n        if (effectiveLevel != null) {\n            info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = doGetLoggerAppenders(logger.getAllAppenders());\n        info.put(LoggerHelper.appenders, appenders);\n        return info;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "97", "src_id": "M9", "code": "\n    @SuppressWarnings(\"resource\")\n    public static long select(boolean verbose, long telnetPortPid, String select) \n            throws InputMismatchException {\n        \n        Map<Long, String> processMap = listProcessByJps(verbose);\n        \n        // Prioritize already listening port\n        if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n            String telnetProcess = processMap.remove(telnetPortPid);\n            Map<Long, String> prioritizedMap = new LinkedHashMap<>();\n            prioritizedMap.put(telnetPortPid, telnetProcess);\n            prioritizedMap.putAll(processMap);\n            processMap = prioritizedMap;\n        }\n\n        if (processMap.isEmpty()) {\n            AnsiLog.info(\"No Java processes found. Try running `jps` to list instrumented Java VMs.\");\n            return -1;\n        }\n\n        // Handle selection via --select option\n        if (select != null && !select.trim().isEmpty()) {\n            int matchCount = 0;\n            Long matchedPid = null;\n            for (Entry<Long, String> entry : processMap.entrySet()) {\n                if (entry.getValue().contains(select)) {\n                    matchCount++;\n                    matchedPid = entry.getKey();\n                }\n            }\n            if (matchCount == 1) {\n                return matchedPid;\n            }\n        }\n\n        // Display process list\n        AnsiLog.info(\"Found Java processes. Select one by number and press ENTER.\");\n        int index = 1;\n        for (String process : processMap.values()) {\n            String prefix = (index == 1) ? \"* \" : \"  \";\n            System.out.println(prefix + \"[\" + index + \"]: \" + process);\n            index++;\n        }\n\n        // Process user selection\n        String input = new Scanner(System.in).nextLine().trim();\n        if (input.isEmpty()) {\n            return processMap.keySet().iterator().next();\n        }\n\n        try {\n            int choice = Integer.parseInt(input);\n            if (choice < 1 || choice > processMap.size()) {\n                return -1;\n            }\n\n            Iterator<Long> pidIterator = processMap.keySet().iterator();\n            for (int i = 1; i <= choice; i++) {\n                long pid = pidIterator.next();\n                if (i == choice) {\n                    return pid;\n                }\n            }\n        } catch (NumberFormatException e) {\n            // Fall through to return error\n        }\n        return -1;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "98", "src_id": "M140", "code": "\n    void _processDo(int option) throws IOException {\n        if (debugoptions) {\n            System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n        }\n\n        if (__notifhand != null) {\n            __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n        }\n\n        boolean acceptNewState = false;\n        \n        // Handle TelnetOptionHandler functionality\n        if (optionHandlers[option] != null) {\n            acceptNewState = optionHandlers[option].getAcceptLocal();\n        } \n        // Handle TERMINAL-TYPE option\n        else if (option == TERMINAL_TYPE) {\n            if (terminalType != null && !terminalType.isEmpty()) {\n                acceptNewState = true;\n            }\n        }\n\n        if (_willResponse[option] > 0) {\n            --_willResponse[option];\n            if (_willResponse[option] > 0 && _stateIsWill(option)) {\n                --_willResponse[option];\n            }\n        }\n\n        if (_willResponse[option] == 0) {\n            if (_requestedWont(option)) {\n                if (acceptNewState) {\n                    _setWantWill(option);\n                    _sendWill(option);\n                } else {\n                    ++_willResponse[option];\n                    _sendWont(option);\n                }\n            } else {\n                // Acknowledge option\n            }\n        }\n\n        _setWill(option);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "99", "src_id": "M1324", "code": "\n    private void bind(Configure config) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        \n        if (!isBindRef.compareAndSet(false, true)) {\n            throw new IllegalStateException(\"Already bound\");\n        }\n\n        // Initialize random ports if needed\n        if (config.getTelnetPort() != null && config.getTelnetPort() == 0) {\n            int newTelnetPort = SocketUtils.findAvailableTcpPort();\n            config.setTelnetPort(newTelnetPort);\n            logger().info(\"Generated random telnet port: {}\", newTelnetPort);\n        }\n        if (config.getHttpPort() != null && config.getHttpPort() == 0) {\n            int newHttpPort = SocketUtils.findAvailableTcpPort();\n            config.setHttpPort(newHttpPort);\n            logger().info(\"Generated random HTTP port: {}\", newHttpPort);\n        }\n\n        // Determine application name\n        if (config.getAppName() == null) {\n            String appName = System.getProperty(ArthasConstants.PROJECT_NAME, \n                System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null));\n            config.setAppName(appName);\n        }\n\n        try {\n            // Initialize tunnel client\n            if (config.getTunnelServer() != null) {\n                tunnelClient = new TunnelClient();\n                tunnelClient.setAppName(config.getAppName());\n                tunnelClient.setId(config.getAgentId());\n                tunnelClient.setTunnelServerUrl(config.getTunnelServer());\n                tunnelClient.setVersion(ArthasBanner.version());\n                ChannelFuture channelFuture = tunnelClient.start();\n                channelFuture.await(10, TimeUnit.SECONDS);\n            }\n        } catch (Throwable t) {\n            logger().error(\"Tunnel client startup failed\", t);\n        }\n\n        try {\n            // Configure shell server\n            ShellServerOptions options = new ShellServerOptions()\n                .setInstrumentation(instrumentation)\n                .setPid(PidUtils.currentLongPid())\n                .setWelcomeMessage(ArthasBanner.welcome());\n                \n            if (config.getSessionTimeout() != null) {\n                options.setSessionTimeout(config.getSessionTimeout() * 1000);\n            }\n\n            httpSessionManager = new HttpSessionManager();\n            \n            // Security handling for 0.0.0.0 binding\n            if (IPUtils.isAllZeroIP(config.getIp()) && StringUtils.isBlank(config.getPassword())) {\n                String warning = \"Binding to 0.0.0.0 is unsafe without password! Generating secure password.\";\n                AnsiLog.error(warning);\n                String password = StringUtils.randomString(64);\n                config.setPassword(password);\n                AnsiLog.error(\"Generated password: {}\", password);\n                logger().error(warning);\n                logger().info(\"Generated password: {}\", password);\n            }\n\n            securityAuthenticator = new SecurityAuthenticatorImpl(config.getUsername(), config.getPassword());\n            shellServer = new ShellServerImpl(options);\n\n            // Configure disabled commands\n            List<String> disabledCommands = new ArrayList<>();\n            if (config.getDisabledCommands() != null) {\n                String[] commands = StringUtils.tokenizeToStringArray(config.getDisabledCommands(), \",\");\n                if (commands != null) {\n                    disabledCommands.addAll(Arrays.asList(commands));\n                }\n            }\n\n            // Initialize command resolvers\n            BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n            List<CommandResolver> resolvers = new ArrayList<>();\n            resolvers.add(builtinCommands);\n\n            // Initialize worker group\n            workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n            // Register terminal servers\n            if (config.getTelnetPort() != null && config.getTelnetPort() > 0) {\n                logger().info(\"Binding telnet server to {}:{}\", config.getIp(), config.getTelnetPort());\n                shellServer.registerTermServer(new HttpTelnetTermServer(\n                    config.getIp(), config.getTelnetPort(), \n                    options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else {\n                logger().info(\"Skipping telnet binding (port: {})\", config.getTelnetPort());\n            }\n            \n            if (config.getHttpPort() != null && config.getHttpPort() > 0) {\n                logger().info(\"Binding HTTP server to {}:{}\", config.getIp(), config.getHttpPort());\n                shellServer.registerTermServer(new HttpTermServer(\n                    config.getIp(), config.getHttpPort(), \n                    options.getConnectionTimeout(), workerGroup, httpSessionManager));\n            } else if (config.getTunnelServer() != null) {\n                shellServer.registerTermServer(new HttpTermServer(\n                    config.getIp(), config.getHttpPort(), \n                    options.getConnectionTimeout(), workerGroup, httpSessionManager));\n                logger().info(\"Bound HTTP server for tunnel communication\");\n            } else {\n                logger().info(\"Skipping HTTP binding (port: {})\", config.getHttpPort());\n            }\n\n            // Register command resolvers\n            for (CommandResolver resolver : resolvers) {\n                shellServer.registerCommandResolver(resolver);\n            }\n\n            // Start listening\n            shellServer.listen(new BindHandler(isBindRef));\n            if (!isBind()) {\n                throw new IllegalStateException(\"Binding failed. Telnet: \" + \n                    config.getTelnetPort() + \", HTTP: \" + config.getHttpPort());\n            }\n\n            // Initialize API components\n            sessionManager = new SessionManagerImpl(options, \n                shellServer.getCommandManager(), shellServer.getJobController());\n            httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n\n            logger().info(\"Server started on {} (telnet:{}, http:{}, timeout:{})\", \n                config.getIp(), config.getTelnetPort(), config.getHttpPort(), \n                options.getConnectionTimeout());\n\n            // Report startup metrics\n            if (config.getStatUrl() != null) {\n                logger().info(\"Metrics URL: {}\", config.getStatUrl());\n            }\n            UserStatUtil.setStatUrl(config.getStatUrl());\n            UserStatUtil.setAgentId(config.getAgentId());\n            UserStatUtil.arthasStart();\n\n            try {\n                SpyAPI.init();\n            } catch (Throwable e) {\n                // Ignore initialization errors\n            }\n\n            logger().info(\"Server started in {} ms\", System.currentTimeMillis() - startTime);\n        } catch (Throwable e) {\n            logger().error(\"Server startup failed\", e);\n            destroy();\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "100", "src_id": "M122", "code": "\n    private int __read(boolean mayBlock) throws IOException {\n        int character;\n        while (true) {\n            // Handle non-blocking case\n            if (!mayBlock && super.available() == 0) {\n                return WOULD_BLOCK;\n            }\n\n            // Check for end of stream\n            if ((character = super.read()) < 0) {\n                return EOF;\n            }\n\n            character &= 0xff;\n\n            // Process AYT response\n            synchronized (__client) {\n                __client._processAYTResponse();\n            }\n\n            // Spy stream handling\n            __client._spyRead(character);\n\n            switch (__receiveState) {\n                case _STATE_CR:\n                    if (character == '\\0') continue;  // Strip null\n                    // Fall through to data state\n                case _STATE_DATA:\n                    if (character == TelnetCommand.IAC) {\n                        __receiveState = _STATE_IAC;\n                        continue;\n                    }\n                    if (character == '\\r') {\n                        synchronized (__client) {\n                            __receiveState = __client._requestedDont(TelnetOption.BINARY) ? \n                                _STATE_CR : _STATE_DATA;\n                        }\n                    } else {\n                        __receiveState = _STATE_DATA;\n                    }\n                    break;\n\n                case _STATE_IAC:\n                    switch (character) {\n                        case TelnetCommand.WILL:\n                            __receiveState = _STATE_WILL;\n                            continue;\n                        case TelnetCommand.WONT:\n                            __receiveState = _STATE_WONT;\n                            continue;\n                        case TelnetCommand.DO:\n                            __receiveState = _STATE_DO;\n                            continue;\n                        case TelnetCommand.DONT:\n                            __receiveState = _STATE_DONT;\n                            continue;\n                        case TelnetCommand.SB:  // TERMINAL-TYPE option\n                            __suboption_count = 0;\n                            __receiveState = _STATE_SB;\n                            continue;\n                        case TelnetCommand.IAC:\n                            __receiveState = _STATE_DATA;\n                            break;\n                        case TelnetCommand.SE:  // Unexpected byte\n                            __receiveState = _STATE_DATA;\n                            continue;\n                        default:\n                            __receiveState = _STATE_DATA;\n                            __client._processCommand(character);\n                            continue;\n                    }\n                    break;\n\n                case _STATE_WILL:\n                    synchronized (__client) {\n                        __client._processWill(character);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_WONT:\n                    synchronized (__client) {\n                        __client._processWont(character);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_DO:\n                    synchronized (__client) {\n                        __client._processDo(character);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_DONT:\n                    synchronized (__client) {\n                        __client._processDont(character);\n                        __client._flushOutputStream();\n                    }\n                    __receiveState = _STATE_DATA;\n                    continue;\n\n                case _STATE_SB:  // TERMINAL-TYPE option\n                    if (character == TelnetCommand.IAC) {\n                        __receiveState = _STATE_IAC_SB;\n                    } else if (__suboption_count < __suboption.length) {\n                        __suboption[__suboption_count++] = character;\n                    }\n                    __receiveState = _STATE_SB;\n                    continue;\n\n                case _STATE_IAC_SB:  // IAC during SB\n                    if (character == TelnetCommand.SE) {\n                        synchronized (__client) {\n                            __client._processSuboption(__suboption, __suboption_count);\n                            __client._flushOutputStream();\n                        }\n                        __receiveState = _STATE_DATA;\n                    } else if (character == TelnetCommand.IAC) {\n                        if (__suboption_count < __suboption.length) {\n                            __suboption[__suboption_count++] = character;\n                        }\n                    }\n                    __receiveState = _STATE_SB;\n                    continue;\n            }\n            break;\n        }\n        return character;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "101", "src_id": "M8", "code": "\n    private static String formatFileSize(long size) {\n        double bytes = size;\n        double kilobytes = size / 1024.0;\n        double megabytes = kilobytes / 1024.0;\n        double gigabytes = megabytes / 1024.0;\n        double terabytes = gigabytes / 1024.0;\n\n        DecimalFormat formatter = new DecimalFormat(\"0.00\");\n        \n        if (terabytes > 1) {\n            return formatter.format(terabytes) + \" TB\";\n        } else if (gigabytes > 1) {\n            return formatter.format(gigabytes) + \" GB\";\n        } else if (megabytes > 1) {\n            return formatter.format(megabytes) + \" MB\";\n        } else if (kilobytes > 1) {\n            return formatter.format(kilobytes) + \" KB\";\n        } else {\n            return formatter.format(bytes) + \" Bytes\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "102", "src_id": "M790", "code": "\n        @Override\n        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n                ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n\n            if (className == null) {\n                return null;\n            }\n            className = className.replace('/', '.');\n\n            List<RetransformEntry> entries = allRetransformEntries();\n            ListIterator<RetransformEntry> iterator = entries.listIterator(entries.size());\n            \n            while (iterator.hasPrevious()) {\n                RetransformEntry entry = iterator.previous();\n                if (!className.equals(entry.getClassName())) {\n                    continue;\n                }\n\n                // Check classloader match\n                boolean loaderMatch = true;\n                if (entry.getClassLoaderClass() != null || entry.getHashCode() != null) {\n                    loaderMatch = isLoaderMatch(entry, loader);\n                }\n\n                if (loaderMatch) {\n                    logger.info(\"Retransform match: {} (ID: {}, Loader: {}, Hash: {})\", \n                        className, entry.getId(), entry.getClassLoaderClass(), entry.getHashCode());\n                    entry.incTransformCount();\n                    return entry.getBytes();\n                }\n            }\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "103", "src_id": "M716", "code": "\n    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n        table.row(\"IS-RETURN\", \"false\");\n        table.row(\"IS-EXCEPTION\", \"true\");\n\n        Throwable cause;\n        Throwable original = (Throwable) throwableVO.getObject();\n        if (original instanceof InvocationTargetException) {\n            cause = original.getCause();\n        } else {\n            cause = original;\n        }\n\n        if (throwableVO.needExpand()) {\n            ObjectView exceptionView = new ObjectView(cause, throwableVO.expandOrDefault());\n            table.row(\"THROW-EXCEPTION\", exceptionView.draw());\n        } else {\n            StringWriter sw = new StringWriter();\n            try (PrintWriter pw = new PrintWriter(sw)) {\n                cause.printStackTrace(pw);\n                table.row(\"THROW-EXCEPTION\", sw.toString());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "104", "src_id": "M602", "code": "\n    private AsyncProfiler profilerInstance() {\n        if (profiler != null) {\n            return profiler;\n        }\n\n        // Handle custom library path\n        if (ProfilerAction.load.toString().equals(action)) {\n            profiler = AsyncProfiler.getInstance(actionArg);\n        }\n\n        if (libPath != null) {\n            // Create temporary copy to avoid classloader issues\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                File tempFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n                in = new FileInputStream(libPath);\n                out = new FileOutputStream(tempFile);\n                IOUtils.copy(in, out);\n                libPath = tempFile.getAbsolutePath();\n                logger().debug(\"Copied library to: {}\", tempFile);\n            } catch (Throwable e) {\n                logger().error(\"Library copy failed: {}\", libPath, e);\n            } finally {\n                IOUtils.closeQuietly(in);\n                IOUtils.closeQuietly(out);\n            }\n            profiler = AsyncProfiler.getInstance(libPath);\n        } else {\n            if (OSUtils.isLinux() || OSUtils.isMac()) {\n                throw new IllegalStateException(\"Missing asyncProfiler library\");\n            } else {\n                throw new IllegalStateException(\"Unsupported OS: Only Linux/Mac supported\");\n            }\n        }\n        return profiler;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "105", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "106", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "107", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE:\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE:\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "108", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    List list = (List) data;\n    if (list == null || list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (KeyValue keyValue : (List<KeyValue>) data) {\n            String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        if (resultsData == null || profileData == null) {\n            throw new IllegalStateException(\"Could not detect required data\");\n        }\n        return KeyValue.of(\n            resultsBuilder.build(resultsData),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData)\n        );\n    }\n\n    return KeyValue.of(\n        resultsBuilder.build(list.get(0)),\n        ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1))\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "109", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    if (keystoreResource != null) {\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "110", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    break;\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = chunkDataAsList.stream()\n                            .collect(Collectors.toMap(\n                                kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())\n                            ));\n                        chunks.add(chunk);\n                    }\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) {\n                }\n            }\n        }\n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "111", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "112", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n    JedisException suppressed = null;\n\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) {\n                continue;\n            }\n            jedis.ping();\n            return jedis;\n        } catch (JedisException ex) {\n            if (suppressed == null) {\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "113", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            } else {\n                Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "115", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "116", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE: // TODO:\n            return processMultiBulkReply(is);\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    List list = (List) data;\n    if (list == null || list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) { // RESP3\n        Object resultsData = null, profileData = null;\n\n        for (KeyValue keyValue : (List<KeyValue>) data) {\n            String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        assert resultsData != null : \"Could not detect Results data.\";\n        assert profileData != null : \"Could not detect Profile data.\";\n        return KeyValue.of(\n            resultsBuilder.build(resultsData),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData)\n        );\n    }\n\n    return KeyValue.of(\n        resultsBuilder.build(list.get(0)),\n        ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1))\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    if (keystoreResource != null) {\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "120", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rulesValueMap;\n                    break;\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = chunkDataAsList.stream()\n                            .collect(Collectors.toMap(\n                                kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())\n                            ));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n                    value = chunksValueList;\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "121", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "122", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n    JedisException suppressed = null;\n    \n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) {\n                continue;\n            }\n            jedis.ping();\n            return jedis;\n        } catch (JedisException ex) {\n            if (suppressed == null) {\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "123", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            } else {\n                Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "124", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "125", "src_id": "M342", "code": "\nprivate static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n    if (emlBytes == null || emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n    }\n\n    String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n    String subject = extractBasicHeader(emlContent, \"Subject:\");\n    String from = extractBasicHeader(emlContent, \"From:\");\n    String to = extractBasicHeader(emlContent, \"To:\");\n    String cc = extractBasicHeader(emlContent, \"Cc:\");\n    String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n    String date = extractBasicHeader(emlContent, \"Date:\");\n\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n        String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n\n    StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n    if (request != null && request.isIncludeAllRecipients()) {\n        if (!cc.trim().isEmpty()) {\n            html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        }\n        if (!bcc.trim().isEmpty()) {\n            html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n        }\n    }\n\n    if (!date.trim().isEmpty()) {\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    html.append(processEmailHtmlBody(htmlBody));\n    html.append(\"</div>\\n\");\n\n    String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        html.append(\"<h3>Attachments</h3>\\n\");\n        html.append(attachmentInfo);\n\n        if (request != null && request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n            html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n            html.append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n    }\n\n    assert request != null;\n    if (request.getFileInput().isEmpty()) {\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n        html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "126", "src_id": "M371", "code": "\nprivate static boolean isValidJakartaMailMultipart(Object multipart) {\n    if (multipart == null) {\n        return false;\n    }\n\n    try {\n        Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n        if (!multipartInterface.isInstance(multipart)) {\n            return false;\n        }\n\n        try {\n            Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n            if (mimeMultipartClass.isInstance(multipart)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                }\n                return true;\n            }\n        } catch (ClassNotFoundException e) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n        }\n\n        return true;\n    } catch (ClassNotFoundException e) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n        }\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "127", "src_id": "M348", "code": "\nprivate static String extractBasicHeader(String emlContent, String headerName) {\n    try {\n        String[] lines = emlContent.split(\"\\r?\\n\");\n        for (int i = 0; i < lines.length; i++) {\n            String line = lines[i];\n            if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                for (int j = i + 1; j < lines.length; j++) {\n                    if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                        value.append(\" \").append(lines[j].trim());\n                    } else {\n                        break;\n                    }\n                }\n                return safeMimeDecode(value.toString());\n            }\n            if (line.trim().isEmpty()) {\n                break;\n            }\n        }\n    } catch (RuntimeException e) {\n        log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n    }\n    return \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "128", "src_id": "M364", "code": "\nprivate static void addAttachmentAnnotationsToDocument(\n        PDDocument document, List<EmailAttachment> attachments) throws IOException {\n    if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n        return;\n    }\n\n    AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n    finder.setSortByPosition(true);\n    finder.getText(document);\n    List<MarkerPosition> markerPositions = finder.getPositions();\n\n    if (markerPositions.size() != attachments.size()) {\n        log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n            markerPositions.size(), attachments.size());\n    }\n\n    int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n    for (int i = 0; i < annotationsToAdd; i++) {\n        MarkerPosition position = markerPositions.get(i);\n        EmailAttachment attachment = attachments.get(i);\n\n        if (attachment.getEmbeddedFilename() != null) {\n            PDPage page = document.getPage(position.getPageIndex());\n            addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "129", "src_id": "M31", "code": "\n    private JsonNode validateLicense(\n            String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\n                \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}\",\n                licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n                .header(\"Content-Type\", \"application/vnd.api+json\")\n                .header(\"Accept\", \"application/vnd.api+json\")\n                .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                .build();\n\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"validateLicense: response body={}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        \n        if (response.statusCode() != 200) {\n            log.error(\"validateLicense: failed, status={}\", response.statusCode());\n            return jsonResponse;\n        }\n\n        JsonNode metaNode = jsonResponse.path(\"meta\");\n        boolean isValid = metaNode.path(\"valid\").asBoolean();\n        String detail = metaNode.path(\"detail\").asText();\n        String code = metaNode.path(\"code\").asText();\n        log.debug(\"validateLicense: valid={}, detail={}, code={}\", isValid, detail, code);\n\n        JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n        if (!licenseAttrs.isMissingNode()) {\n            context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n            context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n            log.debug(\"validateLicense: floating={}, maxMachines={}\",\n                    context.isFloatingLicense, context.maxMachines);\n        }\n\n        JsonNode includedNode = jsonResponse.path(\"included\");\n        JsonNode policyNode = null;\n        if (includedNode.isArray()) {\n            for (JsonNode node : includedNode) {\n                if (\"policies\".equals(node.path(\"type\").asText())) {\n                    policyNode = node;\n                    break;\n                }\n            }\n        }\n\n        if (policyNode != null) {\n            boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n            int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n            if (policyFloating) {\n                context.isFloatingLicense = true;\n                context.maxMachines = policyMaxMachines;\n            }\n            log.debug(\"validateLicense: policyFloating={}, maxMachines={}\",\n                    context.isFloatingLicense, context.maxMachines);\n        }\n\n        int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n        applicationProperties.getPremium().setMaxUsers(users);\n        context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\")\n                .path(\"isEnterprise\").asBoolean(false);\n\n        return jsonResponse;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "130", "src_id": "M488", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n            summary = \"Convert a file to a PDF using LibreOffice\",\n            description = \"Converts given file to PDF using LibreOffice API. Input:ANY Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(\n                    doc,\n                    Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                                    .replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) file.delete();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "131", "src_id": "M625", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"PDF metadata extraction\", description = \"Extracts PDF metadata. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n            // Metadata extraction\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode();\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n\n            // Basic info\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            long fileSizeInBytes = inputFile.getSize();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n            \n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n            int wordCount = words.length;\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n            basicInfo.put(\"CharacterCount\", fullText.length());\n            basicInfo.put(\"Language\", pdfBoxDoc.getDocumentCatalog().getLanguage());\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n            // Document info\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(\n                    pdfBoxDoc.getDocumentCatalog().getPageMode().name()));\n\n            // Form fields\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n\n            // Embedded files\n            PDEmbeddedFilesNameTreeNode efTree = pdfBoxDoc.getDocumentCatalog().getNames() != null ? \n                    pdfBoxDoc.getDocumentCatalog().getNames().getEmbeddedFiles() : null;\n            ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n            if (efTree != null) {\n                Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                if (efMap != null) {\n                    for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                        ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                        embeddedFileNode.put(\"Name\", entry.getKey());\n                        PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                        if (embeddedFile != null) {\n                            embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n                        }\n                        embeddedFilesArray.add(embeddedFileNode);\n                    }\n                }\n            }\n            \n            // Attachments\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            \n            // JavaScript\n            PDJavascriptNameTreeNode javascriptDict = pdfBoxDoc.getDocumentCatalog().getNames() != null ? \n                    pdfBoxDoc.getDocumentCatalog().getNames().getJavaScript() : null;\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (javascriptDict != null) {\n                try {\n                    Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                    for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                        ObjectNode jsNode = objectMapper.createObjectNode();\n                        jsNode.put(\"JS Name\", entry.getKey());\n                        PDActionJavaScript jsAction = entry.getValue();\n                        if (jsAction != null && jsAction.getAction() != null) {\n                            jsNode.put(\"JS Script Length\", jsAction.getAction().length());\n                        }\n                        javascriptArray.add(jsNode);\n                    }\n                } catch (IOException e) {\n                    log.error(\"getPdfInfo: failed to process JavaScript\", e);\n                }\n            }\n            \n            // Layers\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n            \n            // Structure tree\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            ArrayNode structureTreeArray = null;\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                }\n            } catch (Exception e) {\n                log.error(\"getPdfInfo: failed to process structure tree\", e);\n            }\n            \n            // Compliancy\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            compliancy.put(\"IsPDF/ACompliant\", checkForStandard(pdfBoxDoc, \"PDF/A\"));\n            compliancy.put(\"IsPDF/XCompliant\", checkForStandard(pdfBoxDoc, \"PDF/X\"));\n            compliancy.put(\"IsPDF/ECompliant\", checkForStandard(pdfBoxDoc, \"PDF/E\"));\n            compliancy.put(\"IsPDF/VTCompliant\", checkForStandard(pdfBoxDoc, \"PDF/VT\"));\n            compliancy.put(\"IsPDF/UACompliant\", checkForStandard(pdfBoxDoc, \"PDF/UA\"));\n            compliancy.put(\"IsPDF/BCompliant\", checkForStandard(pdfBoxDoc, \"PDF/B\"));\n            compliancy.put(\"IsPDF/SECCompliant\", checkForStandard(pdfBoxDoc, \"PDF/SEC\"));\n            \n            // Bookmarks\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            \n            // XMP Metadata\n            String xmpString = null;\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            if (pdMetadata != null) {\n                try (COSInputStream is = pdMetadata.createInputStream()) {\n                    DomXmpParser domXmpParser = new DomXmpParser();\n                    XMPMetadata xmpMeta = domXmpParser.parse(is);\n                    ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    new XmpSerializer().serialize(xmpMeta, os, true);\n                    xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                } catch (XmpParsingException e) {\n                    log.debug(\"getPdfInfo: XMP parsing failed, using raw metadata\");\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"getPdfInfo: failed to read metadata\", e);\n                }\n            }\n            \n            // Encryption\n            ObjectNode encryption = objectMapper.createObjectNode();\n            if (pdfBoxDoc.isEncrypted()) {\n                encryption.put(\"IsEncrypted\", true);\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n            } else {\n                encryption.put(\"IsEncrypted\", false);\n            }\n            \n            // Permissions\n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n            \n            // Page-level info\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n                PDRectangle mediaBox = page.getMediaBox();\n                float width = mediaBox.getWidth();\n                float height = mediaBox.getHeight();\n                \n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n                \n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                pageInfo.put(\"CropBox\", page.getCropBox() != null ? page.getCropBox().toString() : \"Undefined\");\n                pageInfo.put(\"BleedBox\", page.getBleedBox() != null ? page.getBleedBox().toString() : \"Undefined\");\n                pageInfo.put(\"TrimBox\", page.getTrimBox() != null ? page.getTrimBox().toString() : \"Undefined\");\n                pageInfo.put(\"ArtBox\", page.getArtBox() != null ? page.getArtBox().toString() : \"Undefined\");\n                \n                // Text content\n                PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n                pageInfo.put(\"Text Characters Count\", textStripper.getText(pdfBoxDoc).length());\n                \n                // Annotations\n                List<PDAnnotation> annotations = page.getAnnotations();\n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                pageInfo.set(\"Annotations\", annotationsObject);\n                \n                // Images\n                PDResources resources = page.getResources();\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null && image.getMetadata().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n                \n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n                Set<String> uniqueURIs = new HashSet<>();\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation && \n                        linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        uniqueURIs.add(uriAction.getURI());\n                    }\n                }\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n                pageInfo.set(\"Links\", linksArray);\n                \n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n                    \n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n                    \n                    String fontKey = fontNode.toString();\n                    if (uniqueFontsMap.containsKey(fontKey)) {\n                        ObjectNode existing = uniqueFontsMap.get(fontKey);\n                        existing.put(\"Count\", existing.get(\"Count\").asInt() + 1);\n                    } else {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(fontKey, fontNode);\n                    }\n                }\n                fontsArray.addAll(uniqueFontsMap.values());\n                pageInfo.set(\"Fonts\", fontsArray);\n                \n                // Color spaces\n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                for (COSName name : resources.getColorSpaceNames()) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccData.toByteArray().length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n                \n                // XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String type = \"Other\";\n                    if (xObject instanceof PDImageXObject) type = \"Image\";\n                    else if (xObject instanceof PDFormXObject) type = \"Form\";\n                    xObjectCountMap.put(type, xObjectCountMap.getOrDefault(type, 0) + 1);\n                }\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                xObjectCountMap.forEach(xObjectCountNode::put);\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n                \n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n            \n            // Assemble final JSON\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Encryption\", encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode);\n            if (structureTreeArray != null) jsonOutput.set(\"StructureTree\", structureTreeArray);\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n            \n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(\n                    jsonString.getBytes(StandardCharsets.UTF_8),\n                    \"response.json\",\n                    MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"getPdfInfo: failed\", e);\n            return null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "132", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile\n                    .replace(CERT_PREFIX, \"\")\n                    .replace(CERT_SUFFIX, \"\")\n                    .replaceAll(\"\\\\r?\\\\n\", \"\");\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.debug(\"verifyCertificate: payload={}\", payload);\n\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = attrs.getString(\"enc\");\n                encodedSignature = attrs.getString(\"sig\");\n                algorithm = attrs.getString(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"verifyCertificate: parse error\", e);\n                return false;\n            }\n\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"verifyCertificate: unsupported algorithm={}\", algorithm);\n                return false;\n            }\n\n            if (!verifyEd25519Signature(encryptedData, encodedSignature)) {\n                log.error(\"verifyCertificate: invalid signature\");\n                return false;\n            }\n\n            String decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            return processCertificateData(decodedData, context);\n        } catch (Exception e) {\n            log.error(\"verifyCertificate: failed\", e);\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "133", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(\n            Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n            throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager);\n             ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n                     new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n            ZipEntry entry;\n            while ((entry = zipIn.getNextEntry()) != null) {\n                Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                if (entry.isDirectory()) continue;\n                \n                Files.createDirectories(filePath.getParent());\n                if (entry.getName().toLowerCase().endsWith(\".html\") || \n                    entry.getName().toLowerCase().endsWith(\".htm\")) {\n                    String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                    Files.write(filePath, sanitizeHtmlContent(content, disableSanitize).getBytes(StandardCharsets.UTF_8));\n                } else {\n                    Files.copy(zipIn, filePath);\n                }\n                zipIn.closeEntry();\n            }\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "134", "src_id": "M317", "code": "\n    public static void addImageToDocument(\n            PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n            throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                float imageAspectRatio = (float) image.getWidth() / image.getHeight();\n                float pageAspectRatio = pageWidth / pageHeight;\n                float scaleFactor = imageAspectRatio > pageAspectRatio ? \n                    pageWidth / image.getWidth() : pageHeight / image.getHeight();\n                float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                contentStream.drawImage(image, xPos, yPos, \n                    image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n            }\n        } catch (IOException e) {\n            log.error(\"addImageToDocument: failed\", e);\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "135", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n            if (network == null) {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac == null) continue;\n                    for (byte b : mac) sb.append(String.format(\"%02X\", b));\n                    break;\n                }\n            } else {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (byte b : mac) sb.append(String.format(\"%02X\", b));\n                }\n            }\n\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) fingerprint.append(String.format(\"%02x\", b));\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "136", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata()\n                && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "137", "src_id": "M128", "code": "\n    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n            if (isKubernetes) return \"Kubernetes\";\n            if (isDocker) return \"Docker\";\n            if (isBrowserOpen) {\n                String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                if (os.contains(\"win\")) return \"Client-windows\";\n                if (os.contains(\"mac\")) return \"Client-mac\";\n                return \"Client-unix\";\n            }\n            return \"Server-jar\";\n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "138", "src_id": "M101", "code": "\n    private void processRequest(\n            int limitPerDay,\n            String identifier,\n            Map<String, Bucket> buckets,\n            HttpServletRequest request,\n            HttpServletResponse response,\n            FilterChain filterChain)\n            throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (!probe.isConsumed()) {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", String.valueOf(waitForRefill));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n            return;\n        }\n\n        response.setHeader(\"X-Rate-Limit-Remaining\", String.valueOf(probe.getRemainingTokens()));\n        filterChain.doFilter(request, response);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "139", "src_id": "M475", "code": "\n    @Override\n    public void draw(CommandProcess process, JvmModel result) {\n        try {\n            TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n            \n            for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n                String group = entry.getKey();\n                List<JvmItemVO> items = entry.getValue();\n\n                table.row(true, label(group).style(Decoration.bold.bold()));\n                for (JvmItemVO item : items) {\n                    String valueStr;\n                    if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                        valueStr = renderMemoryUsage((Map<String, Object>) item.getValue());\n                    } else {\n                        valueStr = renderItemValue(item.getValue());\n                    }\n                    \n                    String displayText = item.getName();\n                    if (item.getDesc() != null) {\n                        displayText += \"\\n[\" + item.getDesc() + \"]\";\n                    }\n                    table.row(displayText, valueStr);\n                }\n                table.row(\"\", \"\");\n            }\n\n            String renderedTable = RenderUtil.render(table, process.width());\n            process.write(renderedTable);\n        } catch (Exception e) {\n            log.error(\"Error rendering JVM model: {}\", e.getMessage(), e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "140", "src_id": "M535", "code": "\n    public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n        StringBuilder infoSB = new StringBuilder(1024);\n        \n        try {\n            List<String> classDumpFiles = affectVO.getClassDumpFiles();\n            if (classDumpFiles != null) {\n                for (String classDumpFile : classDumpFiles) {\n                    infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n                }\n            }\n\n            List<String> methods = affectVO.getMethods();\n            if (methods != null) {\n                for (String method : methods) {\n                    infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n                }\n            }\n\n            infoSB.append(format(\n                \"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\",\n                affectVO.getClassCount(),\n                affectVO.getMethodCount(),\n                affectVO.getCost(),\n                affectVO.getListenerId()\n            ));\n            \n            if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n                infoSB.append(\"\\n\").append(affectVO.getOverLimitMsg());\n            }\n            \n            if (affectVO.getThrowable() != null) {\n                infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n            }\n            infoSB.append(\"\\n\");\n        } catch (Exception e) {\n            log.error(\"Error rendering enhancer affect: {}\", e.getMessage(), e);\n            return \"Rendering error occurred\";\n        }\n        \n        return infoSB.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "141", "src_id": "M753", "code": "\n    public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n        List<ThreadVO> threads = new ArrayList<>(originThreads);\n\n        try {\n            if (lastCpuTimes.isEmpty()) {\n                lastSampleTimeNanos = System.nanoTime();\n                processInitialSample(threads);\n                return threads;\n            }\n\n            long newSampleTimeNanos = System.nanoTime();\n            Map<ThreadVO, Long> newCpuTimes = sampleCpuTimes(threads);\n            Map<ThreadVO, Long> deltas = calculateCpuDeltas(newCpuTimes);\n            long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n            Map<ThreadVO, Double> cpuUsages = calculateCpuUsage(deltas, sampleIntervalNanos);\n\n            sortByCpuDelta(threads, deltas);\n            updateThreadMetrics(threads, newCpuTimes, deltas, cpuUsages);\n\n            lastCpuTimes = newCpuTimes;\n            lastSampleTimeNanos = newSampleTimeNanos;\n        } catch (Exception e) {\n            log.error(\"Error sampling threads: {}\", e.getMessage(), e);\n        }\n        \n        return threads;\n    }\n\n    private void processInitialSample(List<ThreadVO> threads) {\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                lastCpuTimes.put(thread, cpu);\n                thread.setTime(cpu / 1000000);\n            }\n        }\n\n        Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (internalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                ThreadVO thread = createThreadVO(entry.getKey());\n                thread.setTime(entry.getValue() / 1000000);\n                threads.add(thread);\n                lastCpuTimes.put(thread, entry.getValue());\n            }\n        }\n\n        threads.sort(Comparator.comparingLong(ThreadVO::getTime).reversed());\n    }\n\n    private Map<ThreadVO, Long> sampleCpuTimes(List<ThreadVO> threads) {\n        Map<ThreadVO, Long> newCpuTimes = new HashMap<>(threads.size());\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                newCpuTimes.put(thread, cpu);\n            }\n        }\n\n        Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (newInternalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n                ThreadVO threadVO = createThreadVO(entry.getKey());\n                threads.add(threadVO);\n                newCpuTimes.put(threadVO, entry.getValue());\n            }\n        }\n        return newCpuTimes;\n    }\n\n    private Map<ThreadVO, Long> calculateCpuDeltas(Map<ThreadVO, Long> newCpuTimes) {\n        Map<ThreadVO, Long> deltas = new HashMap<>(newCpuTimes.size());\n        for (ThreadVO thread : newCpuTimes.keySet()) {\n            Long prevTime = lastCpuTimes.getOrDefault(thread, 0L);\n            long currentTime = newCpuTimes.get(thread);\n            long delta = currentTime - prevTime;\n            deltas.put(thread, delta);\n        }\n        return deltas;\n    }\n\n    private Map<ThreadVO, Double> calculateCpuUsage(Map<ThreadVO, Long> deltas, long interval) {\n        Map<ThreadVO, Double> cpuUsages = new HashMap<>(deltas.size());\n        for (ThreadVO thread : deltas.keySet()) {\n            double usage = interval == 0 ? 0 : (Math.rint(deltas.get(thread) * 10000.0 / interval) / 100.0;\n            cpuUsages.put(thread, usage);\n        }\n        return cpuUsages;\n    }\n\n    private void sortByCpuDelta(List<ThreadVO> threads, Map<ThreadVO, Long> deltas) {\n        threads.sort((o1, o2) -> Long.compare(deltas.get(o2), deltas.get(o1)));\n    }\n\n    private void updateThreadMetrics(List<ThreadVO> threads, Map<ThreadVO, Long> newCpuTimes, \n                                     Map<ThreadVO, Long> deltas, Map<ThreadVO, Double> cpuUsages) {\n        for (ThreadVO thread : threads) {\n            long timeMills = newCpuTimes.get(thread) / 1000000;\n            long deltaTime = deltas.get(thread) / 1000000;\n            thread.setCpu(cpuUsages.get(thread));\n            thread.setTime(timeMills);\n            thread.setDeltaTime(deltaTime);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "142", "src_id": "M1131", "code": "\n    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n        ApiResponse response = new ApiResponse();\n        String commandLine = apiRequest.getCommand();\n        response.setBody(new TreeMap<String, Object>() {{\n            put(\"command\", commandLine);\n        }});\n        response.setSessionId(session.getSessionId());\n\n        try {\n            if (!session.tryLock()) {\n                log.warn(\"Session lock failed for command: {}\", commandLine);\n                return response.setState(ApiState.REFUSED)\n                               .setMessage(\"Another command is executing.\");\n            }\n\n            int lock = session.getLock();\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    log.info(\"Job conflict detected, jobId: {}\", foregroundJob.id());\n                    return response.setState(ApiState.REFUSED)\n                                   .setMessage(\"Another job is running.\");\n                }\n\n                Job job = createJob(commandLine, session, session.getResultDistributor());\n                response.getBody().put(\"jobId\", job.id());\n                response.getBody().put(\"jobStatus\", job.status());\n                response.setState(ApiState.SCHEDULED);\n\n                CommandRequestModel commandModel = new CommandRequestModel(commandLine, response.getState());\n                commandModel.setJobId(job.id());\n                \n                SharingResultDistributor distributor = session.getResultDistributor();\n                if (distributor != null) {\n                    distributor.appendResult(commandModel);\n                }\n                \n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n                job.run();\n                \n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n        } catch (Throwable e) {\n            log.error(\"Async exec command failed: {} - Command: {}\", e.getMessage(), commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Async exec failed: \" + e.getMessage());\n            \n            CommandRequestModel errorModel = new CommandRequestModel(\n                commandLine, \n                response.getState(), \n                response.getMessage()\n            );\n            \n            SharingResultDistributor distributor = session.getResultDistributor();\n            if (distributor != null) {\n                distributor.appendResult(errorModel);\n            }\n            return response;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "143", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        try {\n            for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n                Map<String, Object> info = entry.getValue();\n                TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n                TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n                Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n                table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), \n                         label(String.valueOf(info.get(LoggerHelper.name))))\n                     .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), \n                         label(clazz.getName()))\n                     .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                         label(String.valueOf(info.get(LoggerHelper.classLoader))))\n                     .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                         label(String.valueOf(info.get(LoggerHelper.classLoaderHash))))\n                     .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                         label(String.valueOf(info.get(LoggerHelper.level))));\n\n                if (info.get(LoggerHelper.effectiveLevel) != null) {\n                    table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                             label(String.valueOf(info.get(LoggerHelper.effectiveLevel))));\n                }\n\n                if (info.get(LoggerHelper.config) != null) {\n                    table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                             label(String.valueOf(info.get(LoggerHelper.config))));\n                }\n\n                table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                         label(String.valueOf(info.get(LoggerHelper.additivity))))\n                     .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                         label(String.valueOf(info.get(LoggerHelper.codeSource))));\n\n                @SuppressWarnings(\"unchecked\")\n                List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n                if (appenders != null && !appenders.isEmpty()) {\n                    for (Map<String, Object> appenderInfo : appenders) {\n                        Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                        appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                                          label(String.valueOf(appenderInfo.get(LoggerHelper.name))))\n                                     .row(label(LoggerHelper.clazz), \n                                          label(appenderClass.getName()))\n                                     .row(label(LoggerHelper.classLoader), \n                                          label(String.valueOf(info.get(LoggerHelper.classLoader))))\n                                     .row(label(LoggerHelper.classLoaderHash),\n                                          label(String.valueOf(info.get(LoggerHelper.classLoaderHash))));\n\n                        if (appenderInfo.get(LoggerHelper.file) != null) {\n                            appendersTable.row(label(LoggerHelper.file), \n                                              label(String.valueOf(appenderInfo.get(LoggerHelper.file))));\n                        }\n                        if (appenderInfo.get(LoggerHelper.target) != null) {\n                            appendersTable.row(label(LoggerHelper.target),\n                                              label(String.valueOf(appenderInfo.get(LoggerHelper.target))));\n                        }\n                        if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                            appendersTable.row(label(LoggerHelper.blocking),\n                                              label(String.valueOf(appenderInfo.get(LoggerHelper.blocking))));\n                        }\n                        if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                            appendersTable.row(label(LoggerHelper.appenderRef),\n                                              label(String.valueOf(appenderInfo.get(LoggerHelper.appenderRef))));\n                        }\n                    }\n                    table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n                }\n                sb.append(RenderUtil.render(table, width)).append('\\n');\n            }\n        } catch (Exception e) {\n            log.error(\"Error rendering logger info: {}\", e.getMessage(), e);\n            return \"Error occurred while rendering logger information\";\n        }\n        \n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "144", "src_id": "M15", "code": "\n    public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) {\n        try {\n            ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();\n            PrintStream originalOut = System.out;\n            PrintStream originalErr = System.err;\n            \n            try (PrintStream newOut = new PrintStream(out);\n                 PrintStream newErr = new PrintStream(out)) {\n                \n                System.setOut(newOut);\n                System.setErr(newErr);\n                \n                URLClassLoader classLoader = new URLClassLoader(\n                    new URL[]{new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()}\n                );\n                Thread.currentThread().setContextClassLoader(classLoader);\n                \n                Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n                Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n                \n                int status = (Integer) processMethod.invoke(null, new Object[]{telnetArgs.toArray(new String[0])});\n                log.debug(\"TelnetConsole process completed with status: {}\", status);\n                return status;\n            } catch (InvocationTargetException ite) {\n                Throwable cause = ite.getCause();\n                if (cause instanceof IOException || cause instanceof InterruptedException) {\n                    log.debug(\"Connection error: {}\", cause.getMessage());\n                    return STATUS_ERROR;\n                }\n                log.error(\"Process error: {} - {}\", cause.getClass().getSimpleName(), cause.getMessage(), cause);\n                return STATUS_EXEC_ERROR;\n            } catch (Exception e) {\n                log.error(\"Unexpected error: {}\", e.getMessage(), e);\n                return STATUS_EXEC_ERROR;\n            } finally {\n                Thread.currentThread().setContextClassLoader(originalClassLoader);\n                System.setOut(originalOut);\n                System.setErr(originalErr);\n            }\n        } catch (Exception e) {\n            log.error(\"Client initialization failed: {}\", e.getMessage(), e);\n            return STATUS_EXEC_ERROR;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "145", "src_id": "M1469", "code": "\n    public static FieldVO[] getFields(Class clazz, Integer expand) {\n        Field[] fields = clazz.getDeclaredFields();\n        if (fields.length == 0) {\n            return new FieldVO[0];\n        }\n\n        List<FieldVO> fieldList = new ArrayList<>(fields.length);\n        try {\n            for (Field field : fields) {\n                FieldVO fieldVO = new FieldVO();\n                fieldVO.setName(field.getName());\n                fieldVO.setType(StringUtils.classname(field.getType()));\n                fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n                fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n                \n                if (Modifier.isStatic(field.getModifiers())) {\n                    fieldVO.setStatic(true);\n                    fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n                } else {\n                    fieldVO.setStatic(false);\n                }\n                \n                fieldList.add(fieldVO);\n            }\n        } catch (Exception e) {\n            log.error(\"Error retrieving fields for class {}: {}\", clazz.getName(), e.getMessage(), e);\n        }\n        \n        return fieldList.toArray(new FieldVO[0]);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "146", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(final byte[] emlBytes, final EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        final String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        final String subject = extractBasicHeader(emlContent, \"Subject:\");\n        final String from = extractBasicHeader(emlContent, \"From:\");\n        final String to = extractBasicHeader(emlContent, \"To:\");\n        final String cc = extractBasicHeader(emlContent, \"Cc:\");\n        final String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        final String date = extractBasicHeader(emlContent, \"Date:\");\n\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            final String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(\n                textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n\n        final StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \")\n                    .append(escapeHtml(bcc))\n                    .append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        final String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\n                    \"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\n                    \"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        if (request != null && request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\n                \"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n\n        return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "147", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(final Object multipart) {\n        if (multipart == null) return false;\n        final String TAG = \"MultipartValidator\";\n\n        try {\n            final Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n\n            try {\n                final Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(TAG, \"Found MimeMultipart instance for enhanced processing\");\n                    }\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(TAG, \"MimeMultipart not available, using base Multipart interface\");\n                }\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            if (log.isDebugEnabled()) {\n                log.debug(TAG, \"Jakarta Mail Multipart interface not available for validation\");\n            }\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "148", "src_id": "M348", "code": "\n    private static String extractBasicHeader(final String emlContent, final String headerName) {\n        final String TAG = \"HeaderExtractor\";\n        if (emlContent == null || headerName == null) return \"\";\n        \n        try {\n            final String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                final String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    final StringBuilder value = new StringBuilder(\n                        line.substring(headerName.length()).trim());\n                    \n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[j].trim());\n                        } else {\n                            break;\n                        }\n                    }\n                    return safeMimeDecode(value.toString());\n                }\n                if (line.trim().isEmpty()) break;\n            }\n        } catch (RuntimeException e) {\n            log.warn(TAG, \"Error extracting header '\" + headerName + \"': \" + e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "149", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(\n            final PDDocument document, final List<EmailAttachment> attachments) throws IOException {\n        final String TAG = \"AttachmentAnnotator\";\n        if (document == null || document.getNumberOfPages() == 0 \n                || attachments == null || attachments.isEmpty()) {\n            return;\n        }\n\n        final AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true);\n        finder.getText(document);\n        final List<MarkerPosition> markerPositions = finder.getPositions();\n\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(TAG, \"Found \" + markerPositions.size() + \" attachment markers, but there are \" \n                + attachments.size() + \" attachments. Annotation count may be incorrect.\");\n        }\n\n        final int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            final MarkerPosition position = markerPositions.get(i);\n            final EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                final PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(\n                    document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "150", "src_id": "M491", "code": "\n    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(Player player, @ResizeMode int resizeMode) {\n        int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n\n        // save new resize mode for future sessions\n        player.getPrefs().edit().putInt(\n                player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "151", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close on orientation change to avoid layout issues\n            closeItemsList();\n        } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            // Handle background playback\n            if (!fragmentIsVisible) {\n                onFragmentStopped();\n            }\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n            fragmentIsVisible = false;\n            onFragmentStopped();\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            fragmentIsVisible = true;\n            player.useVideoSource(true);\n\n            // Hide system UI if needed\n            if (!isControlsVisible()) {\n                hideSystemUIIfNeeded();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "152", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(Context context) {\n        Resources res = context.getResources();\n        String lightTheme = res.getString(R.string.light_theme_key);\n        String blackTheme = res.getString(R.string.black_theme_key);\n        String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n        String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n            return R.style.BlackSettingsTheme;\n        } else if (selectedTheme.equals(automaticDeviceTheme)) {\n            if (isDeviceDarkThemeEnabled(context)) {\n                String selectedNightTheme = getSelectedNightThemeKey(context);\n                if (selectedNightTheme.equals(blackTheme)) {\n                    return R.style.BlackSettingsTheme;\n                } else {\n                    return R.style.DarkSettingsTheme;\n                }\n            } else {\n                return R.style.LightSettingsTheme;\n            }\n        } else {\n            return R.style.DarkSettingsTheme;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "153", "src_id": "M895", "code": "\n                    @Override\n                    public Bitmap transform(Bitmap source) {\n                        if (DEBUG) Log.d(TAG, \"Thumbnail - transform() called\");\n\n                        float notificationThumbnailWidth = Math.min(\n                                context.getResources()\n                                        .getDimension(R.dimen.player_notification_thumbnail_width),\n                                source.getWidth());\n\n                        Bitmap result = BitmapCompat.createScaledBitmap(\n                                source,\n                                (int) notificationThumbnailWidth,\n                                (int) (source.getHeight()\n                                        / (source.getWidth() / notificationThumbnailWidth)),\n                                null,\n                                true);\n\n                        if (result == source || !result.isMutable()) {\n                            Bitmap copied = BitmapCompat.createScaledBitmap(\n                                    source,\n                                    (int) notificationThumbnailWidth - 1,\n                                    (int) (source.getHeight() / (source.getWidth()\n                                            / (notificationThumbnailWidth - 1))),\n                                    null,\n                                    true);\n                            source.recycle();\n                            return copied;\n                        } else {\n                            source.recycle();\n                            return result;\n                        }\n                    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "154", "src_id": "M225", "code": "\n    private void onBroadcastReceived(Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n\n        if (DEBUG) Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                break;\n        }\n\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "155", "src_id": "M749", "code": "\n    private static void handleError(Context context, ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null\n                && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n            Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n            Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n            Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n            Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n            Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n            Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n            Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n        } else {\n            ErrorUtil.createNotification(context, errorInfo);\n        }\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "156", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@NonNull Context context,\n                                               @NonNull FragmentManager fragmentManager,\n                                               int serviceId,\n                                               @Nullable String url,\n                                               @NonNull String title,\n                                               @Nullable PlayQueue playQueue,\n                                               boolean switchingPlayers) {\n\n        boolean autoPlay;\n        @Nullable PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else if (switchingPlayers) {\n            autoPlay = PlayerHolder.getInstance().isPlaying();\n        } else if (playerType == PlayerType.MAIN) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else {\n            autoPlay = false;\n        }\n\n        RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (switchingPlayers) {\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP\n                        || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } else {\n                detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            }\n            detailFragment.scrollToTop();\n        };\n\n        Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            VideoDetailFragment instance = VideoDetailFragment\n                    .getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n\n            defaultTransaction(fragmentManager)\n                    .replace(R.id.fragment_player_holder, instance)\n                    .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n                    .commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "157", "src_id": "M698", "code": "\n    @Override\n    public void handleResult(@NonNull ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG)\n                    .into(binding.channelBannerImage);\n        } else {\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.subChannelAvatarView);\n\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization\n                    .shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(\n                    getString(R.string.channel_created_by),\n                    currentInfo.getParentChannelName())\n            );\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n\n        channelContentNotSupported = false;\n        for (Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "158", "src_id": "M379", "code": "\n    @Override\n    public void onTextTracksChanged(@NonNull Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n                || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n                || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        List<Tracks.Group> textTracks = currentTracks\n                .getGroups()\n                .stream()\n                .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n                .collect(Collectors.toList());\n        List<String> availableLanguages = textTracks.stream()\n                .map(Tracks.Group::getMediaTrackGroup)\n                .filter(textTrack -> textTrack.length > 0)\n                .map(textTrack -> textTrack.getFormat(0).language)\n                .collect(Collectors.toList());\n\n        Optional<Format> selectedTracks = textTracks.stream()\n                .filter(Tracks.Group::isSelected)\n                .filter(info -> info.getMediaTrackGroup().length >= 1)\n                .map(info -> info.getMediaTrackGroup().getFormat(0))\n                .findFirst();\n\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(\n                player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(\n                availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "159", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(Context context,\n                                                         @NonNull List<Image> images) {\n        return PicassoHelper.loadThumbnail(images)\n                .transform(new Transformation() {\n                    @Override\n                    public Bitmap transform(Bitmap source) {\n                        if (DEBUG) Log.d(TAG, \"Thumbnail - transform() called\");\n\n                        float notificationThumbnailWidth = Math.min(\n                                context.getResources()\n                                        .getDimension(R.dimen.player_notification_thumbnail_width),\n                                source.getWidth());\n\n                        Bitmap result = BitmapCompat.createScaledBitmap(\n                                source,\n                                (int) notificationThumbnailWidth,\n                                (int) (source.getHeight()\n                                        / (source.getWidth() / notificationThumbnailWidth)),\n                                null,\n                                true);\n\n                        if (result == source || !result.isMutable()) {\n                            Bitmap copied = BitmapCompat.createScaledBitmap(\n                                    source,\n                                    (int) notificationThumbnailWidth - 1,\n                                    (int) (source.getHeight() / (source.getWidth()\n                                            / (notificationThumbnailWidth - 1))),\n                                    null,\n                                    true);\n                            source.recycle();\n                            return copied;\n                        } else {\n                            source.recycle();\n                            return result;\n                        }\n                    }\n\n                    @Override\n                    public String key() {\n                        return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                    }\n                });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "160", "src_id": "M66", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super R> downstream = this.downstream;\n            AtomicThrowable errors = this.errors;\n            AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n            for (;;) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        if (!delayErrors) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean d = done;\n                    SwitchMapMaybeObserver<R> current = inner.get();\n                    boolean empty = current == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty || current.item == null) {\n                        break;\n                    }\n\n                    inner.compareAndSet(current, null);\n\n                    downstream.onNext(current.item);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "161", "src_id": "M1333", "code": "\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n            \n            boolean b;\n            try {\n                b = predicate.test(t);\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                onError(e);\n                return;\n            }\n            \n            if (!b) {\n                done = true;\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                downstream.onSuccess(false);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "162", "src_id": "M522", "code": "\n        void drainLoop() {\n            Observer<? super T> actual = this.downstream;\n            int missed = 1;\n            \n            for (;;) {\n\n                for (;;) {\n                    if (disposed) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(actual);\n                        return;\n                    }\n\n                    int os = otherState;\n                    if (os == OTHER_STATE_HAS_VALUE) {\n                        T v = singleItem;\n                        singleItem = null;\n                        otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        actual.onNext(v);\n                    }\n\n                    boolean d = mainDone;\n                    SimplePlainQueue<T> q = queue;\n                    T v = q != null ? q.poll() : null;\n                    boolean empty = v == null;\n\n                    if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                        queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    actual.onNext(v);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "163", "src_id": "M1163", "code": "\n        @Override\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final SimplePlainQueue<Object> queue = this.queue;\n            final Subscriber<? super Flowable<T>> downstream = this.downstream;\n            UnicastProcessor<T> window = this.window;\n\n            for (;;) {\n\n                if (upstreamCancelled) {\n                    queue.clear();\n                    window = null;\n                    this.window = null;\n                } else {\n\n                    boolean isDone = done;\n                    Object o = queue.poll();\n                    boolean isEmpty = o == null;\n\n                    if (isDone && isEmpty) {\n                        Throwable ex = error;\n                        if (ex != null) {\n                            if (window != null) {\n                                window.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        } else {\n                            if (window != null) {\n                                window.onComplete();\n                            }\n                            downstream.onComplete();\n                        }\n                        cleanupResources();\n                        upstreamCancelled = true;\n                        continue;\n                    } else if (!isEmpty) {\n                        if (o instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else if (window != null) {\n                            @SuppressWarnings(\"unchecked\")\n                            T item = (T) o;\n                            window.onNext(item);\n\n                            long count = this.count + 1;\n                            if (count == maxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            } else {\n                                this.count = count;\n                            }\n                        }\n\n                        continue;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "164", "src_id": "M478", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            EqualObserver<T>[] as = observers;\n\n            final EqualObserver<T> observer1 = as[0];\n            final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n            final EqualObserver<T> observer2 = as[1];\n            final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n            for (;;) {\n\n                for (;;) {\n                    if (cancelled) {\n                        q1.clear();\n                        q2.clear();\n                        return;\n                    }\n\n                    boolean d1 = observer1.done;\n\n                    if (d1) {\n                        Throwable e = observer1.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    boolean d2 = observer2.done;\n                    if (d2) {\n                        Throwable e = observer2.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    if (v1 == null) {\n                        v1 = q1.poll();\n                    }\n                    boolean e1 = v1 == null;\n\n                    if (v2 == null) {\n                        v2 = q2.poll();\n                    }\n                    boolean e2 = v2 == null;\n\n                    if (d1 && d2 && e1 && e2) {\n                        downstream.onSuccess(true);\n                        return;\n                    }\n                    if ((d1 && d2) && (e1 != e2)) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    if (!e1 && !e2) {\n                        boolean c;\n\n                        try {\n                            c = comparer.test(v1, v2);\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            cancel(q1, q2);\n                            downstream.onError(ex);\n                            return;\n                        }\n\n                        if (!c) {\n                            cancel(q1, q2);\n                            downstream.onSuccess(false);\n                            return;\n                        }\n\n                        v1 = null;\n                        v2 = null;\n                    }\n\n                    if (e1 || e2) {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "165", "src_id": "M885", "code": "\n        void drainLoop() {\n            int missed = 1;\n\n            JoinInnerSubscriber<T>[] s = this.subscribers;\n            int n = s.length;\n            Subscriber<? super T> a = this.downstream;\n\n            for (;;) {\n\n                long r = requested.get();\n                long e = 0;\n\n                middle:\n                while (e != r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < s.length; i++) {\n                        JoinInnerSubscriber<T> inner = s[i];\n                        SimplePlainQueue<T> q = inner.queue;\n                        if (q != null) {\n                            T v = q.poll();\n\n                            if (v != null) {\n                                empty = false;\n                                a.onNext(v);\n                                inner.requestOne();\n                                if (++e == r) {\n                                    break middle;\n                                }\n                            }\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < n; i++) {\n                        JoinInnerSubscriber<T> inner = s[i];\n                        SimpleQueue<T> q = inner.queue;\n                        if (q != null && !q.isEmpty()) {\n                            empty = false;\n                            break;\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n\n                if (e != 0) {\n                    BackpressureHelper.produced(requested, e);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1399", "code": "\n        @Override\n        public void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            InnerQueuedSubscriber<R> inner = current;\n            Subscriber<? super R> a = downstream;\n            ErrorMode em = errorMode;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0L;\n\n                if (inner == null) {\n\n                    if (em != ErrorMode.END) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean outerDone = done;\n                    inner = subscribers.poll();\n\n                    if (outerDone && inner == null) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (inner != null) {\n                        current = inner;\n                    }\n                }\n\n                boolean continueNextSource = false;\n\n                if (inner != null) {\n                    SimpleQueue<R> q = inner.queue();\n                    if (q != null) {\n                        while (e != r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            boolean d = inner.isDone();\n                            R v;\n\n                            try {\n                                v = q.poll();\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                a.onError(ex);\n                                return;\n                            }\n\n                            boolean empty = v == null;\n\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                                break;\n                            }\n\n                            if (empty) {\n                                break;\n                            }\n\n                            a.onNext(v);\n                            e++;\n                            inner.request(1L);\n                        }\n\n                        if (e == r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            boolean d = inner.isDone();\n                            boolean empty = q.isEmpty();\n\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                            }\n                        }\n                    }\n                }\n\n                if (e != 0L && r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n\n                if (continueNextSource) {\n                    continue;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "167", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(CacheDisposable<T> consumer) {\n        for (;;) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n            \n            CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "168", "src_id": "M362", "code": "\n        void drainFused() {\n            int missed = 1;\n\n            for (;;) {\n                if (disposed) {\n                    return;\n                }\n\n                boolean d = done;\n                Throwable ex = error;\n\n                if (!delayError && d && ex != null) {\n                    disposed = true;\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                downstream.onNext(null);\n\n                if (d) {\n                    disposed = true;\n                    ex = error;\n                    if (ex != null) {\n                        downstream.onError(ex);\n                    } else {\n                        downstream.onComplete();\n                    }\n                    worker.dispose();\n                    return;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "169", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(PublishSubscription<T> ps) {\n        for (;;) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            \n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "170", "src_id": "M31", "code": "\nprivate JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n    String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n    HttpRequest request = HttpRequest.newBuilder()\n        .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n        .header(\"Content-Type\", \"application/vnd.api+json\")\n        .header(\"Accept\", \"application/vnd.api+json\")\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n        .build();\n\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n    JsonNode jsonResponse = objectMapper.readTree(response.body());\n    if (response.statusCode() == 200) {\n        JsonNode metaNode = jsonResponse.path(\"meta\");\n        boolean isValid = metaNode.path(\"valid\").asBoolean();\n        String detail = metaNode.path(\"detail\").asText();\n        String code = metaNode.path(\"code\").asText();\n        log.info(\"License validity: {}\", isValid);\n        log.info(\"Validation detail: {}\", detail);\n        log.info(\"Validation code: {}\", code);\n        JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n        if (!licenseAttrs.isMissingNode()) {\n            context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n            context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n            log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n        }\n        JsonNode includedNode = jsonResponse.path(\"included\");\n        JsonNode policyNode = null;\n        if (includedNode.isArray()) {\n            for (JsonNode node : includedNode) {\n                if (\"policies\".equals(node.path(\"type\").asText())) {\n                    policyNode = node;\n                    break;\n                }\n            }\n        }\n        if (policyNode != null) {\n            boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n            int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n            if (policyFloating) {\n                context.isFloatingLicense = true;\n                context.maxMachines = policyMaxMachines;\n            }\n            log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n        }\n        int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n        applicationProperties.getPremium().setMaxUsers(users);\n        context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n        log.debug(applicationProperties.toString());\n    } else {\n        log.error(\"Error validating license. Status code: {}\", response.statusCode());\n    }\n    return jsonResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "171", "src_id": "M488", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n@Operation(summary = \"Convert a file to a PDF using LibreOffice\", description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n    MultipartFile inputFile = generalFile.getFileInput();\n    File file = null;\n    try {\n        file = convertToPdf(inputFile);\n        PDDocument doc = pdfDocumentFactory.load(file);\n        return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n    } finally {\n        if (file != null) file.delete();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "172", "src_id": "M625", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\npublic ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n    boolean readonly = true;\n    try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        ObjectNode jsonOutput = objectMapper.createObjectNode();\n        PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n        ObjectNode metadata = objectMapper.createObjectNode();\n        ObjectNode basicInfo = objectMapper.createObjectNode();\n        ObjectNode docInfoNode = objectMapper.createObjectNode();\n        ObjectNode compliancy = objectMapper.createObjectNode();\n        ObjectNode encryption = objectMapper.createObjectNode();\n        ObjectNode other = objectMapper.createObjectNode();\n\n        metadata.put(\"Title\", info.getTitle());\n        metadata.put(\"Author\", info.getAuthor());\n        metadata.put(\"Subject\", info.getSubject());\n        metadata.put(\"Keywords\", info.getKeywords());\n        metadata.put(\"Producer\", info.getProducer());\n        metadata.put(\"Creator\", info.getCreator());\n        metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n        metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n        jsonOutput.set(\"Metadata\", metadata);\n        long fileSizeInBytes = inputFile.getSize();\n        basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n        String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n        String[] words = fullText.split(\"\\\\s+\");\n        int wordCount = words.length;\n        int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n        basicInfo.put(\"WordCount\", wordCount);\n        basicInfo.put(\"ParagraphCount\", paragraphCount);\n        int charCount = fullText.length();\n        basicInfo.put(\"CharacterCount\", charCount);\n        boolean hasCompression = false;\n        String compressionType = \"None\";\n        basicInfo.put(\"Compression\", hasCompression);\n        if (hasCompression) basicInfo.put(\"CompressionType\", compressionType);\n        String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n        basicInfo.put(\"Language\", language);\n        basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n        PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n        String pageMode = catalog.getPageMode().name();\n        docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n        docInfoNode.put(\"Trapped\", info.getTrapped());\n        docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n        PDAcroForm acroForm = catalog.getAcroForm();\n        ObjectNode formFieldsNode = objectMapper.createObjectNode();\n        if (acroForm != null) {\n            for (PDField field : acroForm.getFieldTree()) {\n                formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n            }\n        }\n        jsonOutput.set(\"FormFields\", formFieldsNode);\n        ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n        if (summaryData != null && summaryData.size() > 0) {\n            jsonOutput.set(\"SummaryData\", summaryData);\n        }\n        if (catalog.getNames() != null) {\n            PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n            ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n            if (efTree != null) {\n                Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                if (efMap != null) {\n                    for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                        ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                        embeddedFileNode.put(\"Name\", entry.getKey());\n                        PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                        if (embeddedFile != null) {\n                            embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n                        }\n                        embeddedFilesArray.add(embeddedFileNode);\n                    }\n                }\n            }\n            other.set(\"EmbeddedFiles\", embeddedFilesArray);\n        }\n        ArrayNode attachmentsArray = objectMapper.createArrayNode();\n        for (PDPage page : pdfBoxDoc.getPages()) {\n            for (PDAnnotation annotation : page.getAnnotations()) {\n                if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                    ObjectNode attachmentNode = objectMapper.createObjectNode();\n                    attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                    attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                    attachmentsArray.add(attachmentNode);\n                }\n            }\n        }\n        other.set(\"Attachments\", attachmentsArray);\n        PDDocumentNameDictionary namesDict = catalog.getNames();\n        ArrayNode javascriptArray = objectMapper.createArrayNode();\n        if (namesDict != null) {\n            PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n            if (javascriptDict != null) {\n                try {\n                    Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                    for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                        ObjectNode jsNode = objectMapper.createObjectNode();\n                        jsNode.put(\"JS Name\", entry.getKey());\n                        PDActionJavaScript jsAction = entry.getValue();\n                        if (jsAction != null) {\n                            String jsCodeStr = jsAction.getAction();\n                            if (jsCodeStr != null) {\n                                jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                            }\n                        }\n                        javascriptArray.add(jsNode);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n        }\n        other.set(\"JavaScript\", javascriptArray);\n        PDOptionalContentProperties ocProperties = catalog.getOCProperties();\n        ArrayNode layersArray = objectMapper.createArrayNode();\n        if (ocProperties != null) {\n            for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                ObjectNode layerNode = objectMapper.createObjectNode();\n                layerNode.put(\"Name\", ocg.getName());\n                layersArray.add(layerNode);\n            }\n        }\n        other.set(\"Layers\", layersArray);\n        PDStructureTreeRoot structureTreeRoot = catalog.getStructureTreeRoot();\n        ArrayNode structureTreeArray;\n        try {\n            if (structureTreeRoot != null) {\n                structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                other.set(\"StructureTree\", structureTreeArray);\n            }\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n        boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n        boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n        boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n        boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n        boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n        boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\");\n        boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\");\n        compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n        compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n        compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n        compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n        compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n        compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n        compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n        PDOutlineNode root = catalog.getDocumentOutline();\n        ArrayNode bookmarksArray = objectMapper.createArrayNode();\n        if (root != null) {\n            for (PDOutlineItem child : root.children()) {\n                addOutlinesToArray(child, bookmarksArray);\n            }\n        }\n        other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n        PDMetadata pdMetadata = catalog.getMetadata();\n        String xmpString = null;\n        if (pdMetadata != null) {\n            try (COSInputStream is = pdMetadata.createInputStream()) {\n                DomXmpParser domXmpParser = new DomXmpParser();\n                XMPMetadata xmpMeta = domXmpParser.parse(is);\n                ByteArrayOutputStream os = new ByteArrayOutputStream();\n                new XmpSerializer().serialize(xmpMeta, os, true);\n                xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n            } catch (XmpParsingException e) {\n                log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                try (COSInputStream is = pdMetadata.createInputStream()) {\n                    byte[] metadataBytes = is.readAllBytes();\n                    xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                }\n            } catch (IOException e) {\n                log.error(\"exception\", e);\n            }\n        }\n        other.put(\"XMPMetadata\", xmpString);\n        if (pdfBoxDoc.isEncrypted()) {\n            encryption.put(\"IsEncrypted\", true);\n            PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n            encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n            encryption.put(\"KeyLength\", pdfEncryption.getLength());\n        } else {\n            encryption.put(\"IsEncrypted\", false);\n        }\n        ObjectNode permissionsNode = objectMapper.createObjectNode();\n        setNodePermissions(pdfBoxDoc, permissionsNode);\n        ObjectNode pageInfoParent = objectMapper.createObjectNode();\n        for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n            ObjectNode pageInfo = objectMapper.createObjectNode();\n            PDPage page = pdfBoxDoc.getPage(pageNum);\n            PDRectangle mediaBox = page.getMediaBox();\n            float width = mediaBox.getWidth();\n            float height = mediaBox.getHeight();\n            ObjectNode sizeInfo = objectMapper.createObjectNode();\n            getDimensionInfo(sizeInfo, width, height);\n            sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n            pageInfo.set(\"Size\", sizeInfo);\n            pageInfo.put(\"Rotation\", page.getRotation());\n            pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n            pageInfo.put(\"MediaBox\", mediaBox.toString());\n            PDRectangle cropBox = page.getCropBox();\n            pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n            PDRectangle bleedBox = page.getBleedBox();\n            pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n            PDRectangle trimBox = page.getTrimBox();\n            pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n            PDRectangle artBox = page.getArtBox();\n            pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n            PDFTextStripper textStripper = new PDFTextStripper();\n            textStripper.setStartPage(pageNum + 1);\n            textStripper.setEndPage(pageNum + 1);\n            String pageText = textStripper.getText(pdfBoxDoc);\n            pageInfo.put(\"Text Characters Count\", pageText.length());\n            List<PDAnnotation> annotations = page.getAnnotations();\n            int subtypeCount = 0;\n            int contentsCount = 0;\n            for (PDAnnotation annotation : annotations) {\n                if (annotation.getSubtype() != null) subtypeCount++;\n                if (annotation.getContents() != null) contentsCount++;\n            }\n            ObjectNode annotationsObject = objectMapper.createObjectNode();\n            annotationsObject.put(\"AnnotationsCount\", annotations.size());\n            annotationsObject.put(\"SubtypeCount\", subtypeCount);\n            annotationsObject.put(\"ContentsCount\", contentsCount);\n            pageInfo.set(\"Annotations\", annotationsObject);\n            ArrayNode imagesArray = objectMapper.createArrayNode();\n            PDResources resources = page.getResources();\n            for (COSName name : resources.getXObjectNames()) {\n                PDXObject xObject = resources.getXObject(name);\n                if (xObject instanceof PDImageXObject image) {\n                    ObjectNode imageNode = objectMapper.createObjectNode();\n                    imageNode.put(\"Width\", image.getWidth());\n                    imageNode.put(\"Height\", image.getHeight());\n                    if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                        imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                    }\n                    if (image.getColorSpace() != null) {\n                        imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                    }\n                    imagesArray.add(imageNode);\n                }\n            }\n            pageInfo.set(\"Images\", imagesArray);\n            ArrayNode linksArray = objectMapper.createArrayNode();\n            Set<String> uniqueURIs = new HashSet<>();\n            for (PDAnnotation annotation : annotations) {\n                if (annotation instanceof PDAnnotationLink linkAnnotation) {\n                    if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri);\n                    }\n                }\n            }\n            for (String uri : uniqueURIs) {\n                ObjectNode linkNode = objectMapper.createObjectNode();\n                linkNode.put(\"URI\", uri);\n                linksArray.add(linkNode);\n            }\n            pageInfo.set(\"Links\", linksArray);\n            ArrayNode fontsArray = objectMapper.createArrayNode();\n            Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n            for (COSName fontName : resources.getFontNames()) {\n                PDFont font = resources.getFont(fontName);\n                ObjectNode fontNode = objectMapper.createObjectNode();\n                fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                fontNode.put(\"Name\", font.getName());\n                fontNode.put(\"Subtype\", font.getType());\n                PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                if (fontDescriptor != null) {\n                    fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                    int flags = fontDescriptor.getFlags();\n                    fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                    fontNode.put(\"IsBold\", (flags & 64) != 0);\n                    fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                    fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                    fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                    fontNode.put(\"IsScript\", (flags & 16) != 0);\n                    fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                    fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                    fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                }\n                String uniqueKey = fontNode.toString();\n                if (uniqueFontsMap.containsKey(uniqueKey)) {\n                    ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                    int count = existingFontNode.get(\"Count\").asInt() + 1;\n                    existingFontNode.put(\"Count\", count);\n                } else {\n                    fontNode.put(\"Count\", 1);\n                    uniqueFontsMap.put(uniqueKey, fontNode);\n                }\n            }\n            for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                fontsArray.add(uniqueFontNode);\n            }\n            pageInfo.set(\"Fonts\", fontsArray);\n            ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n            Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n            for (COSName name : colorSpaceNames) {\n                PDColorSpace colorSpace = resources.getColorSpace(name);\n                if (colorSpace instanceof PDICCBased iccBased) {\n                    PDStream iccData = iccBased.getPDStream();\n                    byte[] iccBytes = iccData.toByteArray();\n                    ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                    iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                    colorSpacesArray.add(iccProfileNode);\n                }\n            }\n            pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n            Map<String, Integer> xObjectCountMap = new HashMap<>();\n            for (COSName name : resources.getXObjectNames()) {\n                PDXObject xObject = resources.getXObject(name);\n                String xObjectType;\n                if (xObject instanceof PDImageXObject) xObjectType = \"Image\";\n                else if (xObject instanceof PDFormXObject) xObjectType = \"Form\";\n                else xObjectType = \"Other\";\n                xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n            }\n            ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n            for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                xObjectCountNode.put(entry.getKey(), entry.getValue());\n            }\n            pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n            ArrayNode multimediaArray = objectMapper.createArrayNode();\n            for (PDAnnotation annotation : annotations) {\n                if (\"RichMedia\".equals(annotation.getSubtype())) {\n                    ObjectNode multimediaNode = objectMapper.createObjectNode();\n                    multimediaArray.add(multimediaNode);\n                }\n            }\n            pageInfo.set(\"Multimedia\", multimediaArray);\n            pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n        }\n        jsonOutput.set(\"BasicInfo\", basicInfo);\n        jsonOutput.set(\"DocumentInfo\", docInfoNode);\n        jsonOutput.set(\"Compliancy\", compliancy);\n        jsonOutput.set(\"Encryption\", encryption);\n        jsonOutput.set(\"Permissions\", permissionsNode);\n        jsonOutput.set(\"Other\", other);\n        jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n        String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n        return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n    } catch (Exception e) {\n        log.error(\"exception\", e);\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "173", "src_id": "M24", "code": "\nprivate boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n    try {\n        String encodedPayload = licenseFile.replace(CERT_PREFIX, \"\").replace(CERT_SUFFIX, \"\").replaceAll(\"\\\\r?\\\\n\", \"\");\n        byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n        String payload = new String(payloadBytes);\n        log.info(\"Decoded certificate payload: {}\", payload);\n        String encryptedData = \"\";\n        String encodedSignature = \"\";\n        String algorithm = \"\";\n        try {\n            JSONObject attrs = new JSONObject(payload);\n            encryptedData = (String) attrs.get(\"enc\");\n            encodedSignature = (String) attrs.get(\"sig\");\n            algorithm = (String) attrs.get(\"alg\");\n        } catch (JSONException e) {\n            log.error(\"Failed to parse license file: {}\", e.getMessage());\n            return false;\n        }\n        if (!\"base64+ed25519\".equals(algorithm)) {\n            log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n            return false;\n        }\n        boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n        if (!isSignatureValid) {\n            log.error(\"License file signature is invalid\");\n            return false;\n        }\n        log.info(\"License file signature is valid\");\n        String decodedData;\n        try {\n            decodedData = new String(Base64.getDecoder().decode(encryptedData));\n        } catch (IllegalArgumentException e) {\n            log.error(\"Failed to decode license data: {}\", e.getMessage());\n            return false;\n        }\n        return processCertificateData(decodedData, context);\n    } catch (Exception e) {\n        log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "174", "src_id": "M403", "code": "\nprivate static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws IOException {\n    try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n        try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n            ZipEntry entry = zipIn.getNextEntry();\n            while (entry != null) {\n                Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                if (!entry.isDirectory()) {\n                    Files.createDirectories(filePath.getParent());\n                    if (entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                        String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                        String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                        Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                    } else {\n                        Files.copy(zipIn, filePath);\n                    }\n                }\n                zipIn.closeEntry();\n                entry = zipIn.getNextEntry();\n            }\n        }\n        zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "175", "src_id": "M317", "code": "\npublic static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws IOException {\n    boolean imageIsLandscape = image.getWidth() > image.getHeight();\n    PDRectangle pageSize = PDRectangle.A4;\n    if (autoRotate && imageIsLandscape) pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n    if (\"fitDocumentToImage\".equals(fitOption)) pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n    PDPage page = new PDPage(pageSize);\n    doc.addPage(page);\n    float pageWidth = page.getMediaBox().getWidth();\n    float pageHeight = page.getMediaBox().getHeight();\n    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n        if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n            contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n        } else if (\"maintainAspectRatio\".equals(fitOption)) {\n            float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n            float pageAspectRatio = pageWidth / pageHeight;\n            float scaleFactor = (imageAspectRatio > pageAspectRatio) ? pageWidth / image.getWidth() : pageHeight / image.getHeight();\n            float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n            float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n            contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n        }\n    } catch (IOException e) {\n        log.error(\"Error adding image to PDF\", e);\n        throw e;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "176", "src_id": "M307", "code": "\npublic static String generateMachineFingerprint() {\n    try {\n        StringBuilder sb = new StringBuilder();\n        InetAddress ip = InetAddress.getLocalHost();\n        NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n        if (network == null) {\n            Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n            while (networks.hasMoreElements()) {\n                NetworkInterface net = networks.nextElement();\n                byte[] mac = net.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) sb.append(String.format(\"%02X\", mac[i]));\n                    break;\n                }\n            }\n        } else {\n            byte[] mac = network.getHardwareAddress();\n            if (mac != null) for (int i = 0; i < mac.length; i++) sb.append(String.format(\"%02X\", mac[i]));\n        }\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n        StringBuilder fingerprint = new StringBuilder();\n        for (byte b : hash) fingerprint.append(String.format(\"%02x\", b));\n        return fingerprint.toString();\n    } catch (Exception e) {\n        return \"GenericID\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "177", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n    String title = pdfMetadata.getTitle();\n    pdf.getDocumentInformation().setTitle(title);\n    pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n        author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n        if (userService != null) author = author.replace(\"username\", userService.getCurrentUsername());\n    }\n    pdf.getDocumentInformation().setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "178", "src_id": "M128", "code": "\n@Bean(name = \"machineType\")\npublic String determineMachineType() {\n    try {\n        boolean isDocker = runningInDocker();\n        boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n        boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n        if (isKubernetes) return \"Kubernetes\";\n        else if (isDocker) return \"Docker\";\n        else if (isBrowserOpen) {\n            String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n            if (os.contains(\"win\")) return \"Client-windows\";\n            else if (os.contains(\"mac\")) return \"Client-mac\";\n            else return \"Client-unix\";\n        } else return \"Server-jar\";\n    } catch (Exception e) {\n        return \"Unknown\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "179", "src_id": "M101", "code": "\nprivate void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n        filterChain.doFilter(request, response);\n    } else {\n        long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n        response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n        response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "180", "src_id": "M31", "code": "\n    private JsonNode validateLicense(\n            final String licenseKey, final String machineFingerprint, final LicenseContext context) throws Exception {\n        if (log.isDebugEnabled()) {\n            log.debug(\"validateLicense() called with: licenseKey=[{}], machineFingerprint=[{}]\",\n                    licenseKey, machineFingerprint);\n        }\n\n        final String requestBody = String.format(\n                \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\",\n                licenseKey, machineFingerprint);\n        final HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n                .header(\"Content-Type\", \"application/vnd.api+json\")\n                .header(\"Accept\", \"application/vnd.api+json\")\n                .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                .build();\n\n        final HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        final JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() != 200) {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n            return jsonResponse;\n        }\n\n        final JsonNode metaNode = jsonResponse.path(\"meta\");\n        final boolean isValid = metaNode.path(\"valid\").asBoolean();\n        final String detail = metaNode.path(\"detail\").asText();\n        final String code = metaNode.path(\"code\").asText();\n\n        log.info(\"License validity: {}\", isValid);\n        log.info(\"Validation detail: {}\", detail);\n        log.info(\"Validation code: {}\", code);\n\n        final JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n        if (!licenseAttrs.isMissingNode()) {\n            context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n            context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n            log.info(\"License floating (from license): {}, maxMachines: {}\",\n                    context.isFloatingLicense, context.maxMachines);\n        }\n\n        JsonNode policyNode = null;\n        final JsonNode includedNode = jsonResponse.path(\"included\");\n        if (includedNode.isArray()) {\n            for (final JsonNode node : includedNode) {\n                if (\"policies\".equals(node.path(\"type\").asText())) {\n                    policyNode = node;\n                    break;\n                }\n            }\n        }\n\n        if (policyNode != null) {\n            final boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n            final int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n            if (policyFloating) {\n                context.isFloatingLicense = true;\n                context.maxMachines = policyMaxMachines;\n            }\n            log.info(\"License floating (from policy): {}, maxMachines: {}\",\n                    context.isFloatingLicense, context.maxMachines);\n        }\n\n        final int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n        applicationProperties.getPremium().setMaxUsers(users);\n        context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n        log.debug(applicationProperties.toString());\n        return jsonResponse;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "181", "src_id": "M488", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n            summary = \"Convert a file to a PDF using LibreOffice\",\n            description = \"This endpoint converts a given file to a PDF using LibreOffice API Input:ANY Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute final GeneralFile generalFile) throws Exception {\n        if (log.isDebugEnabled()) {\n            log.debug(\"processFileToPDF() called\");\n        }\n\n        final MultipartFile inputFile = generalFile.getFileInput();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            final PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(\n                    doc,\n                    Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                            .replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "182", "src_id": "M625", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute final PDFFile request) throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"getPdfInfo() called\");\n        }\n\n        final MultipartFile inputFile = request.getFileInput();\n        final boolean readonly = true;\n        try (final PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n            final ObjectMapper objectMapper = new ObjectMapper();\n            final ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n            final PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            final ObjectNode metadata = objectMapper.createObjectNode();\n            final ObjectNode basicInfo = objectMapper.createObjectNode();\n            final ObjectNode docInfoNode = objectMapper.createObjectNode();\n            final ObjectNode compliancy = objectMapper.createObjectNode();\n            final ObjectNode encryption = objectMapper.createObjectNode();\n            final ObjectNode other = objectMapper.createObjectNode();\n\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n\n            final long fileSizeInBytes = inputFile.getSize();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n            final String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            final String[] words = fullText.split(\"\\\\s+\");\n            final int wordCount = words.length;\n            final int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n            final int charCount = fullText.length();\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            final boolean hasCompression = false;\n            final String compressionType = \"None\";\n            basicInfo.put(\"Compression\", hasCompression);\n            if (hasCompression) {\n                basicInfo.put(\"CompressionType\", compressionType);\n            }\n\n            final String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n            final PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            final String pageMode = catalog.getPageMode().name();\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n            final PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            final ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (final PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n\n            final ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n\n            if (catalog.getNames() != null) {\n                final PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                final ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n                if (efTree != null) {\n                    final Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (final Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            final ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n                            final PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n\n            final ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (final PDPage page : pdfBoxDoc.getPages()) {\n                for (final PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        final ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n\n            final PDDocumentNameDictionary namesDict = catalog.getNames();\n            final ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                final PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        final Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (final Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            final ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n                            final PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                final String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (final IOException e) {\n                        log.error(\"Exception processing JavaScript\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n\n            final PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            final ArrayNode layersArray = objectMapper.createArrayNode();\n            if (ocProperties != null) {\n                for (final PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    final ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n            other.set(\"Layers\", layersArray);\n\n            final PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            if (structureTreeRoot != null) {\n                try {\n                    final ArrayNode structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                } catch (final Exception e) {\n                    log.error(\"Exception exploring structure tree\", e);\n                }\n            }\n\n            compliancy.put(\"IsPDF/ACompliant\", checkForStandard(pdfBoxDoc, \"PDF/A\"));\n            compliancy.put(\"IsPDF/XCompliant\", checkForStandard(pdfBoxDoc, \"PDF/X\"));\n            compliancy.put(\"IsPDF/ECompliant\", checkForStandard(pdfBoxDoc, \"PDF/E\"));\n            compliancy.put(\"IsPDF/VTCompliant\", checkForStandard(pdfBoxDoc, \"PDF/VT\"));\n            compliancy.put(\"IsPDF/UACompliant\", checkForStandard(pdfBoxDoc, \"PDF/UA\"));\n            compliancy.put(\"IsPDF/BCompliant\", checkForStandard(pdfBoxDoc, \"PDF/B\"));\n            compliancy.put(\"IsPDF/SECCompliant\", checkForStandard(pdfBoxDoc, \"PDF/SEC\"));\n\n            final PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            final ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (final PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n            String xmpString = null;\n            final PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            if (pdMetadata != null) {\n                try (final COSInputStream is = pdMetadata.createInputStream()) {\n                    final DomXmpParser domXmpParser = new DomXmpParser();\n                    final XMPMetadata xmpMeta = domXmpParser.parse(is);\n                    final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    new XmpSerializer().serialize(xmpMeta, os, true);\n                    xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                } catch (final XmpParsingException e) {\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (final COSInputStream is = pdMetadata.createInputStream()) {\n                        final byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (final IOException e) {\n                    log.error(\"Exception processing metadata\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", xmpString);\n\n            if (pdfBoxDoc.isEncrypted()) {\n                encryption.put(\"IsEncrypted\", true);\n                final PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n            } else {\n                encryption.put(\"IsEncrypted\", false);\n            }\n\n            final ObjectNode permissionsNode = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n\n            final ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                final ObjectNode pageInfo = objectMapper.createObjectNode();\n                final PDPage page = pdfBoxDoc.getPage(pageNum);\n                final PDRectangle mediaBox = page.getMediaBox();\n                final float width = mediaBox.getWidth();\n                final float height = mediaBox.getHeight();\n\n                final ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                pageInfo.put(\"CropBox\", page.getCropBox() == null ? \"Undefined\" : page.getCropBox().toString());\n                pageInfo.put(\"BleedBox\", page.getBleedBox() == null ? \"Undefined\" : page.getBleedBox().toString());\n                pageInfo.put(\"TrimBox\", page.getTrimBox() == null ? \"Undefined\" : page.getTrimBox().toString());\n                pageInfo.put(\"ArtBox\", page.getArtBox() == null ? \"Undefined\" : page.getArtBox().toString());\n\n                final PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n                final String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length());\n\n                final List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (final PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) subtypeCount++;\n                    if (annotation.getContents() != null) contentsCount++;\n                }\n\n                final ObjectNode annotationsObject = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n\n                final ArrayNode imagesArray = objectMapper.createArrayNode();\n                final PDResources resources = page.getResources();\n                for (final COSName name : resources.getXObjectNames()) {\n                    final PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        final ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null\n                                && image.getMetadata().getFile() != null\n                                && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n\n                final ArrayNode linksArray = objectMapper.createArrayNode();\n                final Set<String> uniqueURIs = new HashSet<>();\n                for (final PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation) {\n                        if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                            uniqueURIs.add(uriAction.getURI());\n                        }\n                    }\n                }\n                for (final String uri : uniqueURIs) {\n                    final ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n                pageInfo.set(\"Links\", linksArray);\n\n                final ArrayNode fontsArray = objectMapper.createArrayNode();\n                final Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                for (final COSName fontName : resources.getFontNames()) {\n                    final PDFont font = resources.getFont(fontName);\n                    final ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n\n                    final PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        final int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n\n                    final String uniqueKey = fontNode.toString();\n                    if (uniqueFontsMap.containsKey(uniqueKey)) {\n                        final ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        final int count = existingFontNode.get(\"Count\").asInt() + 1;\n                        existingFontNode.put(\"Count\", count);\n                    } else {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    }\n                }\n                for (final ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", fontsArray);\n\n                final ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                for (final COSName name : resources.getColorSpaceNames()) {\n                    final PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        final PDStream iccData = iccBased.getPDStream();\n                        final byte[] iccBytes = iccData.toByteArray();\n                        final ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n                final Map<String, Integer> xObjectCountMap = new HashMap<>();\n                for (final COSName name : resources.getXObjectNames()) {\n                    final PDXObject xObject = resources.getXObject(name);\n                    final String xObjectType = (xObject instanceof PDImageXObject) ? \"Image\"\n                            : (xObject instanceof PDFormXObject) ? \"Form\" : \"Other\";\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                final ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (final Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n                final ArrayNode multimediaArray = objectMapper.createArrayNode();\n                for (final PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        multimediaArray.add(objectMapper.createObjectNode());\n                    }\n                }\n                pageInfo.set(\"Multimedia\", multimediaArray);\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Encryption\", encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode);\n            jsonOutput.set(\"Other\", other);\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n            final String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(\n                    jsonString.getBytes(StandardCharsets.UTF_8),\n                    \"response.json\",\n                    MediaType.APPLICATION_JSON);\n        } catch (final Exception e) {\n            log.error(\"Exception processing PDF info\", e);\n            return null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "183", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(final String licenseFile, final LicenseContext context) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"verifyCertificateLicense() called\");\n        }\n\n        try {\n            String encodedPayload = licenseFile;\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n\n            final byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            final String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n\n            try {\n                final JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (final JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            final boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n\n            log.info(\"License file signature is valid\");\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (final IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            return processCertificateData(decodedData, context);\n        } catch (final Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "184", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(\n            final Path zipFilePath, final boolean disableSanitize, final TempFileManager tempFileManager)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"sanitizeHtmlFilesInZip() called\");\n        }\n\n        try (final TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager);\n             final ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n                     new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n            ZipEntry entry = zipIn.getNextEntry();\n            while (entry != null) {\n                final Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                if (!entry.isDirectory()) {\n                    Files.createDirectories(filePath.getParent());\n                    if (entry.getName().toLowerCase().endsWith(\".html\")\n                            || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                        final String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                        final String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                        Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                    } else {\n                        Files.copy(zipIn, filePath);\n                    }\n                }\n                zipIn.closeEntry();\n                entry = zipIn.getNextEntry();\n            }\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "185", "src_id": "M317", "code": "\n    public static void addImageToDocument(\n            final PDDocument doc, final PDImageXObject image, final String fitOption, final boolean autoRotate)\n            throws IOException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"addImageToDocument() called\");\n        }\n\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n\n        final PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n\n        final float pageWidth = page.getMediaBox().getWidth();\n        final float pageHeight = page.getMediaBox().getHeight();\n\n        try (final PDPageContentStream contentStream =\n                     new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                final float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                final float pageAspectRatio = pageWidth / pageHeight;\n                float scaleFactor = 1.0f;\n\n                if (imageAspectRatio > pageAspectRatio) {\n                    scaleFactor = pageWidth / image.getWidth();\n                } else {\n                    scaleFactor = pageHeight / image.getHeight();\n                }\n\n                final float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                final float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                contentStream.drawImage(\n                        image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n            }\n        } catch (final IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "186", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"generateMachineFingerprint() called\");\n        }\n\n        try {\n            final StringBuilder sb = new StringBuilder();\n            final InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n            if (network == null) {\n                final Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    final NetworkInterface net = networks.nextElement();\n                    final byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (final byte b : mac) {\n                            sb.append(String.format(\"%02X\", b));\n                        }\n                        break;\n                    }\n                }\n            } else {\n                final byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (final byte b : mac) {\n                        sb.append(String.format(\"%02X\", b));\n                    }\n                }\n            }\n\n            final MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            final byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            final StringBuilder fingerprint = new StringBuilder();\n            for (final byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (final Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "187", "src_id": "M135", "code": "\n    private void setCommonMetadata(final PDDocument pdf, final PdfMetadata pdfMetadata) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"setCommonMetadata() called\");\n        }\n\n        final String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata()\n                && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "188", "src_id": "M128", "code": "\n    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"determineMachineType() called\");\n        }\n\n        try {\n            final boolean isDocker = runningInDocker();\n            final boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            final boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            }\n            if (isDocker) {\n                return \"Docker\";\n            }\n            if (isBrowserOpen) {\n                final String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                if (os.contains(\"win\")) {\n                    return \"Client-windows\";\n                }\n                if (os.contains(\"mac\")) {\n                    return \"Client-mac\";\n                }\n                return \"Client-unix\";\n            }\n            return \"Server-jar\";\n        } catch (final Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "189", "src_id": "M101", "code": "\n    private void processRequest(\n            final int limitPerDay,\n            final String identifier,\n            final Map<String, Bucket> buckets,\n            final HttpServletRequest request,\n            final HttpServletResponse response,\n            final FilterChain filterChain)\n            throws IOException, ServletException {\n        if (log.isDebugEnabled()) {\n            log.debug(\"processRequest() called\");\n        }\n\n        final Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        final ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n            return;\n        }\n\n        final long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n        response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n        response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "190", "src_id": "M491", "code": "\n@SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n@ResizeMode\npublic static int nextResizeModeAndSaveToPrefs(final Player player,\n                                               @ResizeMode final int resizeMode) {\n    int newResizeMode;\n    switch (resizeMode) {\n        case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n        default:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n            break;\n    }\n\n    // save the new resize mode so it can be restored in a future session\n    player.getPrefs().edit().putInt(\n            player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n    return newResizeMode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "191", "src_id": "M424", "code": "\n@Override\npublic void onBroadcastReceived(final Intent intent) {\n    super.onBroadcastReceived(intent);\n    if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n        // Close it because when changing orientation from portrait\n        // (in fullscreen mode) the size of queue layout can be larger than the screen size\n        closeItemsList();\n    } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n        // Ensure that we have audio-only stream playing when a user\n        // started to play from notification's play button from outside of the app\n        if (!fragmentIsVisible) {\n            onFragmentStopped();\n        }\n    } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n        fragmentIsVisible = false;\n        onFragmentStopped();\n    } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n        // Restore video source when user returns to the fragment\n        fragmentIsVisible = true;\n        player.useVideoSource(true);\n\n        // When a user returns from background, the system UI will always be shown even if\n        // controls are invisible: hide it in that case\n        if (!isControlsVisible()) {\n            hideSystemUIIfNeeded();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "192", "src_id": "M900", "code": "\n@StyleRes\npublic static int getSettingsThemeStyle(final Context context) {\n    Resources res = context.getResources();\n    String lightTheme = res.getString(R.string.light_theme_key);\n    String blackTheme = res.getString(R.string.black_theme_key);\n    String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n    String selectedTheme = getSelectedThemeKey(context);\n\n    if (selectedTheme.equals(lightTheme)) {\n        return R.style.LightSettingsTheme;\n    } else if (selectedTheme.equals(blackTheme)) {\n        return R.style.BlackSettingsTheme;\n    } else if (selectedTheme.equals(automaticDeviceTheme)) {\n        if (isDeviceDarkThemeEnabled(context)) {\n            // use the dark theme variant preferred by the user\n            String selectedNightTheme = getSelectedNightThemeKey(context);\n            if (selectedNightTheme.equals(blackTheme)) {\n                return R.style.BlackSettingsTheme;\n            } else {\n                return R.style.DarkSettingsTheme;\n            }\n        } else {\n            // there is only one day theme\n            return R.style.LightSettingsTheme;\n        }\n    } else {\n        // default to dark theme\n        return R.style.DarkSettingsTheme;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "193", "src_id": "M895", "code": "\n@Override\npublic Bitmap transform(final Bitmap source) {\n    if (DEBUG) {\n        Log.d(TAG, \"Thumbnail - transform() called\");\n    }\n\n    float notificationThumbnailWidth = Math.min(\n            context.getResources()\n                    .getDimension(R.dimen.player_notification_thumbnail_width),\n            source.getWidth());\n\n    Bitmap result = BitmapCompat.createScaledBitmap(\n            source,\n            (int) notificationThumbnailWidth,\n            (int) (source.getHeight()\n                    / (source.getWidth() / notificationThumbnailWidth)),\n            null,\n            true);\n\n    if (result == source || !result.isMutable()) {\n        // create a new mutable bitmap to prevent strange crashes on some\n        // devices (see #4638)\n        Bitmap copied = BitmapCompat.createScaledBitmap(\n                source,\n                (int) notificationThumbnailWidth - 1,\n                (int) (source.getHeight() / (source.getWidth()\n                        / (notificationThumbnailWidth - 1))),\n                null,\n                true);\n        source.recycle();\n        return copied;\n    } else {\n        source.recycle();\n        return result;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "194", "src_id": "M225", "code": "\nprivate void onBroadcastReceived(final Intent intent) {\n    if (intent == null || intent.getAction() == null) {\n        return;\n    }\n\n    if (DEBUG) {\n        Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n    }\n\n    switch (intent.getAction()) {\n        case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n            pause();\n            break;\n        case ACTION_CLOSE:\n            service.destroyPlayerAndStopService();\n            break;\n        case ACTION_PLAY_PAUSE:\n            playPause();\n            break;\n        case ACTION_PLAY_PREVIOUS:\n            playPrevious();\n            break;\n        case ACTION_PLAY_NEXT:\n            playNext();\n            break;\n        case ACTION_FAST_REWIND:\n            fastRewind();\n            break;\n        case ACTION_FAST_FORWARD:\n            fastForward();\n            break;\n        case ACTION_REPEAT:\n            cycleNextRepeatMode();\n            break;\n        case ACTION_SHUFFLE:\n            toggleShuffleModeEnabled();\n            break;\n        case Intent.ACTION_CONFIGURATION_CHANGED:\n            if (DEBUG) {\n                Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n            }\n            break;\n    }\n\n    UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "195", "src_id": "M749", "code": "\nprivate static void handleError(final Context context, final ErrorInfo errorInfo) {\n    if (errorInfo.getThrowable() != null) {\n        errorInfo.getThrowable().printStackTrace();\n    }\n\n    if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n        Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n        // Starting ReCaptcha Challenge Activity\n        Intent intent = new Intent(context, ReCaptchaActivity.class);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        context.startActivity(intent);\n    } else if (errorInfo.getThrowable() != null\n            && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n        Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n        Toast.makeText(context, R.string.restricted_video_no_stream,\n                Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n        Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n        Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n        Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n        Toast.makeText(context, R.string.soundcloud_go_plus_content,\n                Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n        Toast.makeText(context, R.string.youtube_music_premium_content,\n                Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n        Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n        Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n    } else {\n        ErrorUtil.createNotification(context, errorInfo);\n    }\n\n    if (context instanceof RouterActivity) {\n        ((RouterActivity) context).finish();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "196", "src_id": "M999", "code": "\npublic static void openVideoDetailFragment(@NonNull final Context context,\n                                           @NonNull final FragmentManager fragmentManager,\n                                           final int serviceId,\n                                           @Nullable final String url,\n                                           @NonNull final String title,\n                                           @Nullable final PlayQueue playQueue,\n                                           final boolean switchingPlayers) {\n\n    boolean autoPlay;\n    @Nullable PlayerType playerType = PlayerHolder.getInstance().getType();\n    if (playerType == null) {\n        // no player open\n        autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n    } else if (switchingPlayers) {\n        // switching player to main player\n        autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n    } else if (playerType == PlayerType.MAIN) {\n        // opening new stream while already playing in main player\n        autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n    } else {\n        // opening new stream while already playing in another player\n        autoPlay = false;\n    }\n\n    RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n        expandMainPlayer(detailFragment.requireActivity());\n        detailFragment.setAutoPlay(autoPlay);\n        if (switchingPlayers) {\n            // Situation when user switches from players to main player. All needed data is\n            // here, we can start watching (assuming newQueue equals playQueue).\n            // Starting directly in fullscreen if the previous player type was popup.\n            detailFragment.openVideoPlayer(playerType == PlayerType.POPUP\n                    || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n        } else {\n            detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n        }\n        detailFragment.scrollToTop();\n    };\n\n    Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n    if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n        onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n    } else {\n        // Specify no url here, otherwise the VideoDetailFragment will start loading the\n        // stream automatically if it's the first time it is being opened, but then\n        // onVideoDetailFragmentReady will kick in and start another loading process.\n        // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n        VideoDetailFragment instance = VideoDetailFragment\n                .getInstance(serviceId, null, title, playQueue);\n        instance.setAutoPlay(autoPlay);\n\n        defaultTransaction(fragmentManager)\n                .replace(R.id.fragment_player_holder, instance)\n                .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n                .commit();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "197", "src_id": "M698", "code": "\n@Override\npublic void handleResult(@NonNull final ChannelInfo result) {\n    super.handleResult(result);\n    currentInfo = result;\n    setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n    if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n        PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.channelBannerImage);\n    } else {\n        // do not waste space for the banner, if the user disabled images or there is not one\n        binding.channelBannerImage.setImageDrawable(null);\n    }\n\n    PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG)\n            .into(binding.channelAvatarView);\n    PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n            .into(binding.subChannelAvatarView);\n\n    binding.channelTitleView.setText(result.getName());\n    binding.channelSubscriberView.setVisibility(View.VISIBLE);\n    if (result.getSubscriberCount() >= 0) {\n        binding.channelSubscriberView.setText(Localization\n                .shortSubscriberCount(activity, result.getSubscriberCount()));\n    } else {\n        binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n    }\n\n    if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n        binding.subChannelTitleView.setText(String.format(\n                getString(R.string.channel_created_by),\n                currentInfo.getParentChannelName())\n        );\n        binding.subChannelTitleView.setVisibility(View.VISIBLE);\n        binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n    }\n\n    updateRssButton();\n\n    channelContentNotSupported = false;\n    for (Throwable throwable : result.getErrors()) {\n        if (throwable instanceof ContentNotSupportedException) {\n            channelContentNotSupported = true;\n            showContentNotSupportedIfNeeded();\n            break;\n        }\n    }\n\n    disposables.clear();\n    if (subscribeButtonMonitor != null) {\n        subscribeButtonMonitor.dispose();\n    }\n\n    updateTabs();\n    updateSubscription(result);\n    monitorSubscription(result);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "198", "src_id": "M379", "code": "\n@Override\npublic void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n    super.onTextTracksChanged(currentTracks);\n\n    boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n            || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n    if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n            || !trackTypeTextSupported) {\n        binding.captionTextView.setVisibility(View.GONE);\n        return;\n    }\n\n    // Extract all loaded languages\n    List<Tracks.Group> textTracks = currentTracks\n            .getGroups()\n            .stream()\n            .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n            .collect(Collectors.toList());\n    List<String> availableLanguages = textTracks.stream()\n            .map(Tracks.Group::getMediaTrackGroup)\n            .filter(textTrack -> textTrack.length > 0)\n            .map(textTrack -> textTrack.getFormat(0).language)\n            .collect(Collectors.toList());\n\n    // Find selected text track\n    Optional<Format> selectedTracks = textTracks.stream()\n            .filter(Tracks.Group::isSelected)\n            .filter(info -> info.getMediaTrackGroup().length >= 1)\n            .map(info -> info.getMediaTrackGroup().getFormat(0))\n            .findFirst();\n\n    // Build UI\n    buildCaptionMenu(availableLanguages);\n    if (player.getTrackSelector().getParameters().getRendererDisabled(\n            player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n        binding.captionTextView.setText(R.string.caption_none);\n    } else {\n        binding.captionTextView.setText(selectedTracks.get().language);\n    }\n    binding.captionTextView.setVisibility(\n            availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "199", "src_id": "M894", "code": "\npublic static RequestCreator loadScaledDownThumbnail(final Context context,\n                                                     @NonNull final List<Image> images) {\n    // scale down the notification thumbnail for performance\n    return PicassoHelper.loadThumbnail(images)\n            .transform(new Transformation() {\n                @Override\n                public Bitmap transform(final Bitmap source) {\n                    if (DEBUG) {\n                        Log.d(TAG, \"Thumbnail - transform() called\");\n                    }\n\n                    float notificationThumbnailWidth = Math.min(\n                            context.getResources()\n                                    .getDimension(R.dimen.player_notification_thumbnail_width),\n                            source.getWidth());\n\n                    Bitmap result = BitmapCompat.createScaledBitmap(\n                            source,\n                            (int) notificationThumbnailWidth,\n                            (int) (source.getHeight()\n                                    / (source.getWidth() / notificationThumbnailWidth)),\n                            null,\n                            true);\n\n                    if (result == source || !result.isMutable()) {\n                        // create a new mutable bitmap to prevent strange crashes on some\n                        // devices (see #4638)\n                        Bitmap copied = BitmapCompat.createScaledBitmap(\n                                source,\n                                (int) notificationThumbnailWidth - 1,\n                                (int) (source.getHeight() / (source.getWidth()\n                                        / (notificationThumbnailWidth - 1))),\n                                null,\n                                true);\n                        source.recycle();\n                        return copied;\n                    } else {\n                        source.recycle();\n                        return result;\n                    }\n                }\n\n                @Override\n                public String key() {\n                    return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                }\n            });\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception ex) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), ex);\n\n            if (ex instanceof InterruptedIOException || ex instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            exception = ex;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return;\n            default:\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "202", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3);\n\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000;\n            return obj;\n        }\n\n        if (v1) {\n            stream.skipBytes(DataReader.LONG_SIZE);\n            obj.mediaTime = stream.readLong();\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE);\n            obj.mediaTime = stream.readInt();\n        }\n\n        obj.bMediaRate = stream.readInt();\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "203", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        boolean done = false;\n        long start = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n        try {\n            long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n            int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n\n            mIs = mConn.getInputStream();\n\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n\n            while (mMission.running) {\n                len = mIs.read(buf, 0, buf.length);\n                if (len == -1) {\n                    break;\n                }\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n            dispose();\n            done = len == -1;\n        } catch (Exception ex) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n\n            if (!mMission.running || ex instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            if (ex instanceof HttpError && ((HttpError) ex).statusCode == ERROR_HTTP_FORBIDDEN) {\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(ex);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", ex);\n            }\n\n            run();\n            return;\n        }\n\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "204", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n\n        out.flush();\n        aux.flush();\n\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long length = amount;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n        if (underflow) {\n            if (out.offset >= out.length) {\n                if (aux.offset < amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        } else {\n            out.offset += amount;\n            aux.offset -= amount;\n        }\n\n        out.length += amount;\n\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        if (amount < aux.length) {\n            long readOffset = amount;\n            long writeOffset = 0;\n\n            aux.length -= amount;\n            length = aux.length;\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);\n        }\n\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "205", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n\n        request.append(\" [\");\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n                request.append(' ')\n                        .append(recovery.toString())\n                        .append(' ');\n            }\n        }\n        request.append(\"]\");\n\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception ex) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(mContext,\n                new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action,\n                        service, request.toString(), reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "206", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            for (;;) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException ex) {\n                        throw new RuntimeException(ex);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n\n            boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "207", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n        if (format == null || format.equals(\"ttml\")) {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n\n            try {\n                writer.build(sources[0]);\n            } catch (Exception ex) {\n                Log.e(TAG, \"subtitle parse failed\", ex);\n                return ex instanceof IOException ? 1 : 8;\n            }\n\n            return OK_RESULT;\n        } else if (format.equals(\"srt\")) {\n            byte[] buffer = new byte[8 * 1024];\n            int read;\n            while ((read = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, read);\n            }\n            return OK_RESULT;\n        }\n\n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "208", "src_id": "M1047", "code": "\n    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException ex) {\n                    Log.w(TAG, \"Initializer thread is still running\", ex);\n                    return;\n                }\n            }\n        }\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == Thread.currentThread()) {\n                continue;\n            }\n            thread.interrupt();\n        }\n\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue;\n                }\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n                if (millis > 0) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException ex) {\n            throw new RuntimeException(\"A download thread is still running\", ex);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "209", "src_id": "M342", "code": "\nprivate static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n    if (emlBytes == null || emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n    }\n\n    final String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n    final String subject = extractBasicHeader(emlContent, \"Subject:\");\n    final String from = extractBasicHeader(emlContent, \"From:\");\n    final String to = extractBasicHeader(emlContent, \"To:\");\n    final String cc = extractBasicHeader(emlContent, \"Cc:\");\n    final String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n    final String date = extractBasicHeader(emlContent, \"Date:\");\n\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n        final String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n\n    final StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n    if (request != null && request.isIncludeAllRecipients()) {\n        if (!cc.trim().isEmpty()) {\n            html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        }\n        if (!bcc.trim().isEmpty()) {\n            html.append(\"<div><strong>BCC:</strong> \")\n                .append(escapeHtml(bcc))\n                .append(\"</div>\\n\");\n        }\n    }\n\n    if (!date.trim().isEmpty()) {\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    html.append(processEmailHtmlBody(htmlBody));\n    html.append(\"</div>\\n\");\n\n    final String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        html.append(\"<h3>Attachments</h3>\\n\");\n        html.append(attachmentInfo);\n\n        if (request != null && request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n            html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n            html.append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n        html.append(\"</div>\\n\");\n    }\n\n    if (request.getFileInput().isEmpty()) {\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n        html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "210", "src_id": "M371", "code": "\nprivate static boolean isValidJakartaMailMultipart(Object multipart) {\n    if (multipart == null) {\n        return false;\n    }\n\n    try {\n        final Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n        if (!multipartInterface.isInstance(multipart)) {\n            return false;\n        }\n\n        try {\n            final Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n            if (mimeMultipartClass.isInstance(multipart)) {\n                log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                return true;\n            }\n        } catch (ClassNotFoundException e) {\n            log.debug(\"MimeMultipart not available, using base Multipart interface\");\n        }\n\n        return true;\n    } catch (ClassNotFoundException e) {\n        log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "211", "src_id": "M348", "code": "\nprivate static String extractBasicHeader(String emlContent, String headerName) {\n    try {\n        final String[] lines = emlContent.split(\"\\r?\\n\");\n        for (int i = 0; i < lines.length; i++) {\n            final String line = lines[i];\n            if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                final StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                for (int j = i + 1; j < lines.length; j++) {\n                    if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                        value.append(\" \").append(lines[j].trim());\n                    } else {\n                        break;\n                    }\n                }\n                return safeMimeDecode(value.toString());\n            }\n            if (line.trim().isEmpty()) {\n                break;\n            }\n        }\n    } catch (RuntimeException e) {\n        log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n    }\n    return \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "212", "src_id": "M364", "code": "\nprivate static void addAttachmentAnnotationsToDocument(\n        PDDocument document, List<EmailAttachment> attachments) throws IOException {\n    if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n        return;\n    }\n\n    final AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n    finder.setSortByPosition(true);\n    finder.getText(document);\n    final List<MarkerPosition> markerPositions = finder.getPositions();\n\n    if (markerPositions.size() != attachments.size()) {\n        log.warn(\n                \"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n                markerPositions.size(),\n                attachments.size());\n    }\n\n    final int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n    for (int i = 0; i < annotationsToAdd; i++) {\n        final MarkerPosition position = markerPositions.get(i);\n        final EmailAttachment attachment = attachments.get(i);\n\n        if (attachment.getEmbeddedFilename() != null) {\n            final PDPage page = document.getPage(position.getPageIndex());\n            addAttachmentAnnotationToPage(\n                    document, page, attachment, position.getX(), position.getY());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "213", "src_id": "M1086", "code": "\npublic static AdminServer createAdminServer() {\n    if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n        try {\n            final Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n            final Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n            return (AdminServer) adminServer;\n        } catch (ReflectiveOperationException e) {\n            LOG.warn(\"Unable to start JettyAdminServer\", e);\n        } catch (NoClassDefFoundError e) {\n            LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n        }\n    }\n    return new DummyAdminServer();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "214", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        for (final SelectionKey key : selector.keys()) {\n            final NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "215", "src_id": "M219", "code": "\nsynchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n    final String connectionId = concat(contextPath, session);\n    ZooKeeper zk = zkMap.get(connectionId);\n    if (zk == null) {\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"creating new connection for : '%s'\", connectionId));\n        }\n        final Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n        for (final Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n        }\n        zkMap.put(connectionId, zk);\n        if (session != null) {\n            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "216", "src_id": "M192", "code": "\nprivate void init() throws IOException {\n    final File f = new File(file);\n    try (RandomAccessFileReader in = new RandomAccessFileReader(f)) {\n        final SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        final Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n        String lastentry = line;\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n                    lastentry = line;\n                } \n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n        }\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "217", "src_id": "M235", "code": "\n@POST\n@Produces({MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML})\npublic Response createSession(@QueryParam(\"op\") String op, \n                             @DefaultValue(\"5\") @QueryParam(\"expire\") String expire,\n                             @Context UriInfo ui) {\n    if (!\"create\".equals(op)) {\n        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                .entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n    }\n    int expireInSeconds;\n    try {\n        expireInSeconds = Integer.parseInt(expire);\n    } catch (NumberFormatException e) {\n        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n    }\n    String uuid = UUID.randomUUID().toString();\n    while (ZooKeeperService.isConnected(contextPath, uuid)) {\n        uuid = UUID.randomUUID().toString();\n    }\n    try {\n        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n    } catch (IOException e) {\n        LOG.error(\"Failed while trying to create a new session\", e);\n        throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n    }\n    final URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n    return Response.created(uri)\n            .entity(new JSONWithPadding(new ZSession(uuid, uri.toString())))\n            .build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "218", "src_id": "M942", "code": "\npublic void schedule(WorkRequest workRequest, long id) {\n    if (stopped) {\n        workRequest.cleanup();\n        return;\n    }\n    final ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n    final int size = workers.size();\n    if (size > 0) {\n        try {\n            final int workerNum = ((int) (id % size) + size) % size;\n            final ExecutorService worker = workers.get(workerNum);\n            worker.execute(scheduledWorkRequest);\n        } catch (RejectedExecutionException e) {\n            LOG.warn(\"ExecutorService rejected execution\", e);\n            workRequest.cleanup();\n        }\n    } else {\n        scheduledWorkRequest.run();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "219", "src_id": "M520", "code": "\n@Override\npublic void close() throws IOException {\n    boolean triedToClose = false, success = false;\n    try {\n        flush();\n        ((FileOutputStream) out).getFD().sync();\n        triedToClose = true;\n        super.close();\n        success = true;\n    } finally {\n        if (success) {\n            boolean renamed = tmpFile.renameTo(origFile);\n            if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n            }\n        } else {\n            if (!triedToClose) {\n                IOUtils.closeStream(out);\n            }\n            if (!tmpFile.delete()) {\n                LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "220", "src_id": "M186", "code": "\nsynchronized private LogEntry readNextEntry() {\n    try {\n        String line;\n        while ((line = in.readLine()) != null) {\n            Matcher m = src.timep.matcher(line);\n            if (m.lookingAt()) {\n                if (buf.length() > 0) {\n                    final LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                    buf = line;\n                    return e;\n                }\n                buf = line;\n            } else if (buf.length() > 0) {\n                buf += line + \"\\n\";\n            }\n        }\n        if (buf.length() > 0) {\n            return new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n        }\n    } catch (Exception e) {\n        LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "221", "src_id": "M478", "code": "\npublic static void main(String[] args) {\n    if (args.length < 3) {\n        usage();\n        return;\n    }\n    final String host = args[0];\n    final int port = Integer.parseInt(args[1]);\n    final String op = args[2];\n    switch (op.toLowerCase()) {\n        case \"gettracemask\": getTraceMask(host, port); break;\n        case \"settracemask\": setTraceMask(host, port, args[3]); break;\n        case \"ruok\": ruok(host, port); break;\n        case \"kill\": kill(host, port); break;\n        case \"stat\": stat(host, port); break;\n        case \"dump\": dump(host, port); break;\n        default: System.out.println(\"Unrecognized op: \" + op);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "222", "src_id": "M1086", "code": "\n    public static AdminServer createAdminServer() {\n        if (\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            return new DummyAdminServer();\n        }\n\n        try {\n            final Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n            final Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n            return (AdminServer) adminServer;\n        } catch (final ClassNotFoundException | InstantiationException | IllegalAccessException | \n                 InvocationTargetException | NoSuchMethodException e) {\n            LOG.warn(\"Unable to start JettyAdminServer\", e);\n        } catch (final NoClassDefFoundError e) {\n            LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n        }\n        \n        return new DummyAdminServer();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "223", "src_id": "M1149", "code": "\n        public void run() {\n            try {\n                while (!stopped) {\n                    try {\n                        select();\n                        processAcceptedConnections();\n                        processInterestOpsUpdateRequests();\n                    } catch (final Exception e) {\n                        LOG.warn(\"Ignoring unexpected exception\", e);\n                    }\n                }\n\n                for (final SelectionKey key : selector.keys()) {\n                    final NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                    if (cnxn.isSelectable()) {\n                        cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                    }\n                    cleanupSelectionKey(key);\n                }\n                \n                SocketChannel accepted;\n                while ((accepted = acceptedQueue.poll()) != null) {\n                    fastCloseSock(accepted);\n                }\n                updateQueue.clear();\n            } finally {\n                closeSelector();\n                NIOServerCnxnFactory.this.stop();\n                LOG.info(\"selector thread exited run method\");\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "224", "src_id": "M219", "code": "\n   synchronized public static ZooKeeper getClient(final String contextPath,\n           final String session, final int expireTime) throws IOException {\n       final String connectionId = concat(contextPath, session);\n       ZooKeeper zk = zkMap.get(connectionId);\n       \n       if (zk != null) {\n           return zk;\n       }\n\n       if (LOG.isInfoEnabled()) {\n           LOG.info(\"creating new connection for : '{}'\", connectionId);\n       }\n       \n       final Endpoint e = contextMap.get(contextPath);\n       zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n       \n       for (final Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n           zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n       }\n       \n       zkMap.put(connectionId, zk);\n\n       if (session != null) {\n           zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n       }\n       \n       return zk;\n   }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "225", "src_id": "M192", "code": "\n    private void init() throws IOException {\n        final File f = new File(file);\n        final SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        final Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = 0;\n        String line = null;\n        String lastentry = null;\n\n        try (RandomAccessFileReader in = new RandomAccessFileReader(f)) {\n            lastFp = in.getPosition();\n            line = in.readLine();\n            final Matcher timeMatcher = timep.matcher(line);\n            \n            if (line == null || !timeMatcher.lookingAt()) {\n                throw new IOException(\"Invalid log format. First line doesn't start with time\");\n            }\n            \n            starttime = timestampFromText(dateformat, timeMatcher.group(1));\n            lastentry = line;\n            \n            while ((line = in.readLine()) != null) {\n                final Matcher m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        final long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n                    lastentry = line;\n                }\n                \n                if (serverid == 0) {\n                    final Matcher idMatcher = idp.matcher(line);\n                    if (idMatcher.find()) {\n                        serverid = Integer.parseInt(idMatcher.group(1));\n                    }\n                }\n                lastFp = in.getPosition();\n            }\n        } catch (final EOFException eof) {\n            // ignore\n        }\n\n        final Matcher m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "226", "src_id": "M235", "code": "\n    @POST\n    @Produces({MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML})\n    public Response createSession(@QueryParam(\"op\") final String op,\n            @DefaultValue(\"5\") @QueryParam(\"expire\") final String expire,\n            @Context final UriInfo ui) {\n        if (!\"create\".equals(op)) {\n            throw new WebApplicationException(Response.status(\n                    Response.Status.BAD_REQUEST).entity(\n                    new ZError(ui.getRequestUri().toString(), \"\")).build());\n        }\n\n        final int expireInSeconds;\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (final NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n\n        String uuid = UUID.randomUUID().toString();\n        while (ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (final IOException e) {\n            LOG.error(\"Failed while creating new session\", e);\n            throw new WebApplicationException(Response.status(\n                    Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n\n        final URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n        return Response.created(uri).entity(\n                new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "227", "src_id": "M942", "code": "\n    public void schedule(final WorkRequest workRequest, final long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n\n        final ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n        final int size = workers.size();\n        \n        if (size == 0) {\n            scheduledWorkRequest.run();\n            return;\n        }\n\n        try {\n            final int workerNum = Math.floorMod((int) id, size);\n            final ExecutorService worker = workers.get(workerNum);\n            worker.execute(scheduledWorkRequest);\n        } catch (final RejectedExecutionException e) {\n            LOG.warn(\"ExecutorService rejected execution\", e);\n            workRequest.cleanup();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "228", "src_id": "M520", "code": "\n    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false;\n        boolean success = false;\n        \n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        } finally {\n            if (success) {\n                if (!tmpFile.renameTo(origFile) && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            } else {\n                if (!triedToClose) {\n                    IOUtils.closeStream(out);\n                }\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "229", "src_id": "M186", "code": "\n    synchronized private LogEntry readNextEntry() {\n        try {\n            while (true) {\n                final String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                final Matcher m = src.timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (!buf.isEmpty()) {\n                        final LogEntry e = new Log4JEntry(\n                            src.timestampFromText(dateformat, buf), \n                            src.getServerId(), \n                            buf\n                        );\n                        buf = line;\n                        return e;\n                    }\n                    buf = line;\n                } else if (!buf.isEmpty()) {\n                    buf += line + \"\\n\";\n                }\n            }\n            \n            if (!buf.isEmpty()) {\n                return new Log4JEntry(\n                    src.timestampFromText(dateformat, buf),\n                    src.getServerId(),\n                    buf\n                );\n            }\n        } catch (final EOFException eof) {\n            // ignore\n        } catch (final Exception e) {\n            LOG.error(\"Error reading next entry in file ({}): {}\", src.file, e);\n        }\n        \n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "230", "src_id": "M478", "code": "\n    public static void main(final String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n        \n        final String host = args[0];\n        final int port = Integer.parseInt(args[1]);\n        final String op = args[2].toLowerCase();\n        \n        switch (op) {\n            case \"gettracemask\":\n                getTraceMask(host, port);\n                break;\n            case \"settracemask\":\n                setTraceMask(host, port, args[3]);\n                break;\n            case \"ruok\":\n                ruok(host, port);\n                break;\n            case \"kill\":\n                kill(host, port);\n                break;\n            case \"stat\":\n                stat(host, port);\n                break;\n            case \"dump\":\n                dump(host, port);\n                break;\n            default:\n                System.out.println(\"Unrecognized op: \" + op);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "231", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        final Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        // Conditionally update thread name for debugging purposes\n        if (DEBUG) {\n            thread.setName(\n                    String.format(\n                            \"[%s]  ps = %s  filename = %s\",\n                            TAG, psAlgorithm.toString(), storage.getName()));\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n            // Handle interruption-related exceptions\n            if (err instanceof InterruptedIOException\n                    || err instanceof ClosedByInterruptException\n                    || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            // Update error code if not already set\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n\n        // Handle non-success cases\n        if (errCode != ERROR_NOTHING) {\n            notifyError(\n                    ERROR_POSTPROCESSING,\n                    exception != null ? exception : errObject);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "232", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        final int statusCode = conn.getResponseCode();\n\n        // Log connection details in debug mode\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n\n        // Handle specific HTTP status codes\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // Let download thread handle this error\n            default:\n                // Validate successful status range\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "233", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n\n        // Read version and skip flags\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // Default media rate (1.0)\n            return obj;\n        }\n\n        // Process based on version\n        if (v1) {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // Skip remaining entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        }\n\n        obj.bMediaRate = stream.readInt();\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "234", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        boolean done = false;\n        long start = mMission.fallbackResumeOffset;\n\n        // Log resuming information if applicable\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n        try {\n            final long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n            final int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            // Workaround: bypass Android connection pool on first attempt\n            if (mRetryCount == 0 && rangeStart == -1) {\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n\n            // Handle range error by resetting start position\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // Determine content length if unknown\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n\n            try (InputStream mIs = mConn.getInputStream()) {\n                final byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n                int len = 0;\n\n                while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                    mF.write(buf, 0, len);\n                    start += len;\n                    mMission.notifyProgress(len);\n                }\n\n                done = len == -1;\n            }\n        } catch (Exception e) {\n            mMission.fallbackResumeOffset = start;\n\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            // Handle expired URL case\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            // Handle retry logic\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n\n            run(); // Retry\n            return;\n        } finally {\n            dispose();\n        }\n\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "235", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n\n        // Ensure buffers are flushed before proceeding\n        out.flush();\n        aux.flush();\n\n        final boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        final byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long length = amount;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n        // Adjust pointers based on underflow condition\n        if (underflow) {\n            if (out.offset >= out.length) {\n                if (aux.offset < amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        } else {\n            out.offset += amount;\n            aux.offset -= amount;\n        }\n\n        out.length += amount;\n\n        // Update maximum known length\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        // Handle remaining data in auxiliary buffer\n        if (amount < aux.length) {\n            // Move excess data to beginning of file\n            long readOffset = amount;\n            long writeOffset = 0;\n            aux.length -= amount;\n            length = aux.length;\n\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        // Reset auxiliary buffer if over threshold\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);\n        }\n\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "236", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        final StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n\n        // Append recovery info if available\n        if (mission.recoveryInfo != null) {\n            request.append(\" [\");\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n                request.append(' ').append(recovery.toString()).append(' ');\n            }\n            request.append(\"]\");\n        }\n\n        // Determine service name\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        // Create error notification\n        ErrorUtil.createNotification(\n                mContext,\n                new ErrorInfo(\n                        ErrorInfo.Companion.throwableToStringList(mission.errObject),\n                        action,\n                        service,\n                        request.toString(),\n                        reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "237", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            // Create unique metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cannot create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Persist mission metadata\n            Utility.writeToFile(mission.metadata, mission);\n\n            // Validate storage availability\n            if (mission.storage == null) {\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n\n            // Determine if download should start immediately\n            final boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "238", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        // Extract conversion parameters\n        final String format = getArgumentAt(0, null);\n        final boolean ignoreEmptyFrames = \"true\".equals(getArgumentAt(1, \"true\"));\n\n        // Handle TTML to SRT conversion\n        if (format == null || \"ttml\".equals(format)) {\n            final SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return (err instanceof IOException) ? 1 : 8;\n            }\n            return OK_RESULT;\n        }\n        // Handle direct SRT copy\n        else if (\"srt\".equals(format)) {\n            final byte[] buffer = new byte[8 * 1024];\n            int read;\n            while ((read = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, read);\n            }\n            return OK_RESULT;\n        }\n\n        throw new UnsupportedOperationException(\n                \"Unimplemented subtitle format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "239", "src_id": "M1047", "code": "\n    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n\n        // Handle initializer thread\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread still running\", e);\n                    return;\n                }\n            }\n        }\n\n        // Interrupt all active threads except current\n        for (Thread thread : threads) {\n            if (thread.isAlive() && thread != currentThread) {\n                thread.interrupt();\n            }\n        }\n\n        // Join threads with timeout\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) continue;\n                if (DEBUG) {\n                    Log.w(TAG, \"Thread alive: \" + thread.getName());\n                }\n                if (millis > 0) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"Download thread still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "240", "src_id": "M66", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super R> downstream = this.downstream;\n            AtomicThrowable errors = this.errors;\n            AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n                    if (errors.get() != null) {\n                        if (!delayErrors) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean d = done;\n                    SwitchMapMaybeObserver<R> current = inner.get();\n                    boolean empty = current == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty || current.item == null) {\n                        break;\n                    }\n\n                    inner.compareAndSet(current, null);\n                    downstream.onNext(current.item);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "241", "src_id": "M1333", "code": "\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n            boolean b;\n            try {\n                b = predicate.test(t);\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                onError(e);\n                return;\n            }\n            if (!b) {\n                done = true;\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                downstream.onSuccess(false);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "242", "src_id": "M522", "code": "\n        void drainLoop() {\n            Observer<? super T> actual = this.downstream;\n            int missed = 1;\n            for (;;) {\n                for (;;) {\n                    if (disposed) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(actual);\n                        return;\n                    }\n\n                    int os = otherState;\n                    if (os == OTHER_STATE_HAS_VALUE) {\n                        T v = singleItem;\n                        singleItem = null;\n                        otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        actual.onNext(v);\n                    }\n\n                    boolean d = mainDone;\n                    SimplePlainQueue<T> q = queue;\n                    T v = q != null ? q.poll() : null;\n                    boolean empty = v == null;\n\n                    if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                        queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    actual.onNext(v);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "243", "src_id": "M1163", "code": "\n        @Override\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final SimplePlainQueue<Object> queue = this.queue;\n            final Subscriber<? super Flowable<T>> downstream = this.downstream;\n            UnicastProcessor<T> window = this.window;\n\n            for (;;) {\n                if (upstreamCancelled) {\n                    queue.clear();\n                    window = null;\n                    this.window = null;\n                } else {\n                    boolean isDone = done;\n                    Object o = queue.poll();\n                    boolean isEmpty = o == null;\n\n                    if (isDone && isEmpty) {\n                        Throwable ex = error;\n                        if (ex != null) {\n                            if (window != null) {\n                                window.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        } else {\n                            if (window != null) {\n                                window.onComplete();\n                            }\n                            downstream.onComplete();\n                        }\n                        cleanupResources();\n                        upstreamCancelled = true;\n                        continue;\n                    } else if (!isEmpty) {\n                        if (o instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else if (window != null) {\n                            @SuppressWarnings(\"unchecked\")\n                            T item = (T) o;\n                            window.onNext(item);\n\n                            long count = this.count + 1;\n                            if (count == maxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            } else {\n                                this.count = count;\n                            }\n                        }\n                        continue;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "244", "src_id": "M478", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            EqualObserver<T>[] as = observers;\n\n            final EqualObserver<T> observer1 = as[0];\n            final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n            final EqualObserver<T> observer2 = as[1];\n            final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q1.clear();\n                        q2.clear();\n                        return;\n                    }\n\n                    boolean d1 = observer1.done;\n                    if (d1) {\n                        Throwable e = observer1.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    boolean d2 = observer2.done;\n                    if (d2) {\n                        Throwable e = observer2.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    if (v1 == null) {\n                        v1 = q1.poll();\n                    }\n                    boolean e1 = v1 == null;\n\n                    if (v2 == null) {\n                        v2 = q2.poll();\n                    }\n                    boolean e2 = v2 == null;\n\n                    if (d1 && d2 && e1 && e2) {\n                        downstream.onSuccess(true);\n                        return;\n                    }\n                    if ((d1 && d2) && (e1 != e2)) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    if (!e1 && !e2) {\n                        boolean c;\n                        try {\n                            c = comparer.test(v1, v2);\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            cancel(q1, q2);\n                            downstream.onError(ex);\n                            return;\n                        }\n\n                        if (!c) {\n                            cancel(q1, q2);\n                            downstream.onSuccess(false);\n                            return;\n                        }\n\n                        v1 = null;\n                        v2 = null;\n                    }\n\n                    if (e1 || e2) {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "245", "src_id": "M885", "code": "\n        void drainLoop() {\n            int missed = 1;\n            JoinInnerSubscriber<T>[] s = this.subscribers;\n            int n = s.length;\n            Subscriber<? super T> a = this.downstream;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0;\n\n                middle:\n                while (e != r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < s.length; i++) {\n                        JoinInnerSubscriber<T> inner = s[i];\n                        SimplePlainQueue<T> q = inner.queue;\n                        if (q != null) {\n                            T v = q.poll();\n                            if (v != null) {\n                                empty = false;\n                                a.onNext(v);\n                                inner.requestOne();\n                                if (++e == r) {\n                                    break middle;\n                                }\n                            }\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < n; i++) {\n                        JoinInnerSubscriber<T> inner = s[i];\n                        SimpleQueue<T> q = inner.queue;\n                        if (q != null && !q.isEmpty()) {\n                            empty = false;\n                            break;\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n\n                if (e != 0) {\n                    BackpressureHelper.produced(requested, e);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "246", "src_id": "M1399", "code": "\n        @Override\n        public void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            InnerQueuedSubscriber<R> inner = current;\n            Subscriber<? super R> a = downstream;\n            ErrorMode em = errorMode;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0L;\n\n                if (inner == null) {\n                    if (em != ErrorMode.END) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean outerDone = done;\n                    inner = subscribers.poll();\n                    if (outerDone && inner == null) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (inner != null) {\n                        current = inner;\n                    }\n                }\n\n                boolean continueNextSource = false;\n                if (inner != null) {\n                    SimpleQueue<R> q = inner.queue();\n                    if (q != null) {\n                        while (e != r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n                            if (em == ErrorMode.IMMEDIATE) {\n                                Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            boolean d = inner.isDone();\n                            R v;\n                            try {\n                                v = q.poll();\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                a.onError(ex);\n                                return;\n                            }\n\n                            boolean empty = v == null;\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                                break;\n                            }\n\n                            if (empty) {\n                                break;\n                            }\n\n                            a.onNext(v);\n                            e++;\n                            inner.request(1L);\n                        }\n\n                        if (e == r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n                            if (em == ErrorMode.IMMEDIATE) {\n                                Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            boolean d = inner.isDone();\n                            boolean empty = q.isEmpty();\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                            }\n                        }\n                    }\n                }\n\n                if (e != 0L && r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n\n                if (continueNextSource) {\n                    continue;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "247", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(CacheDisposable<T> consumer) {\n        for (;;) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n            CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "248", "src_id": "M362", "code": "\n        void drainFused() {\n            int missed = 1;\n            for (;;) {\n                if (disposed) {\n                    return;\n                }\n\n                boolean d = done;\n                Throwable ex = error;\n\n                if (!delayError && d && ex != null) {\n                    disposed = true;\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                downstream.onNext(null);\n\n                if (d) {\n                    disposed = true;\n                    ex = error;\n                    if (ex != null) {\n                        downstream.onError(ex);\n                    } else {\n                        downstream.onComplete();\n                    }\n                    worker.dispose();\n                    return;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "249", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(PublishSubscription<T> ps) {\n        for (;;) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "250", "src_id": "M342", "code": "\nprivate static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n  if (emlBytes == null || emlBytes.length == 0) {\n    throw new IllegalArgumentException(\"EML file is empty or null\");\n  }\n\n  String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n  String subject = extractBasicHeader(emlContent, \"Subject:\");\n  String from = extractBasicHeader(emlContent, \"From:\");\n  String to = extractBasicHeader(emlContent, \"To:\");\n  String cc = extractBasicHeader(emlContent, \"Cc:\");\n  String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n  String date = extractBasicHeader(emlContent, \"Date:\");\n\n  String htmlBody = extractHtmlBody(emlContent);\n  if (htmlBody == null) {\n    String textBody = extractTextBody(emlContent);\n    htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n  }\n\n  StringBuilder html = new StringBuilder();\n  html.append(\"<!DOCTYPE html>\\n\")\n      .append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\")\n      .append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\")\n      .append(\"<style>\\n\");\n  appendEnhancedStyles(html);\n  html.append(\"</style>\\n\")\n      .append(\"</head><body>\\n\")\n      .append(\"<div class=\\\"email-container\\\">\\n\")\n      .append(\"<div class=\\\"email-header\\\">\\n\")\n      .append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\")\n      .append(\"<div class=\\\"email-meta\\\">\\n\")\n      .append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\")\n      .append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n  if (request != null && request.isIncludeAllRecipients()) {\n    if (!cc.trim().isEmpty()) {\n      html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n    }\n    if (!bcc.trim().isEmpty()) {\n      html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n    }\n  }\n\n  if (!date.trim().isEmpty()) {\n    html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n  }\n  html.append(\"</div></div>\\n\")\n      .append(\"<div class=\\\"email-body\\\">\\n\")\n      .append(processEmailHtmlBody(htmlBody))\n      .append(\"</div>\\n\");\n\n  String attachmentInfo = extractAttachmentInfo(emlContent);\n  if (!attachmentInfo.isEmpty()) {\n    html.append(\"<div class=\\\"attachment-section\\\">\\n\")\n        .append(\"<h3>Attachments</h3>\\n\")\n        .append(attachmentInfo);\n\n    if (request != null && request.isIncludeAttachments()) {\n      html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\")\n          .append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\")\n          .append(\"</div>\\n\");\n    } else {\n      html.append(\"<div class=\\\"attachment-info-note\\\">\\n\")\n          .append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\")\n          .append(\"</div>\\n\");\n    }\n    html.append(\"</div>\\n\");\n  }\n\n  assert request != null;\n  if (request.getFileInput().isEmpty()) {\n    html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\")\n        .append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\")\n        .append(\"</div>\\n\");\n  }\n\n  html.append(\"</div>\\n\")\n      .append(\"</body></html>\");\n\n  return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "251", "src_id": "M371", "code": "\nprivate static boolean isValidJakartaMailMultipart(Object multipart) {\n  if (multipart == null) return false;\n\n  try {\n    Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n    if (!multipartInterface.isInstance(multipart)) {\n      return false;\n    }\n\n    try {\n      Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n      if (mimeMultipartClass.isInstance(multipart)) {\n        log.debug(\"Found MimeMultipart instance for enhanced processing\");\n        return true;\n      }\n    } catch (ClassNotFoundException e) {\n      log.debug(\"MimeMultipart not available, using base Multipart interface\");\n    }\n\n    return true;\n  } catch (ClassNotFoundException e) {\n    log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n    return false;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "252", "src_id": "M348", "code": "\nprivate static String extractBasicHeader(String emlContent, String headerName) {\n  try {\n    String[] lines = emlContent.split(\"\\r?\\n\");\n    for (int i = 0; i < lines.length; i++) {\n      String line = lines[i];\n      if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n        StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n        for (int j = i + 1; j < lines.length; j++) {\n          if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n            value.append(\" \").append(lines[j].trim());\n          } else {\n            break;\n          }\n        }\n        return safeMimeDecode(value.toString());\n      }\n      if (line.trim().isEmpty()) break;\n    }\n  } catch (RuntimeException e) {\n    log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n  }\n  return \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "253", "src_id": "M364", "code": "\nprivate static void addAttachmentAnnotationsToDocument(\n    PDDocument document, List<EmailAttachment> attachments) throws IOException {\n  if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n    return;\n  }\n\n  AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n  finder.setSortByPosition(true);\n  finder.getText(document);\n  List<MarkerPosition> markerPositions = finder.getPositions();\n\n  if (markerPositions.size() != attachments.size()) {\n    log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n        markerPositions.size(), attachments.size());\n  }\n\n  int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n  for (int i = 0; i < annotationsToAdd; i++) {\n    MarkerPosition position = markerPositions.get(i);\n    EmailAttachment attachment = attachments.get(i);\n\n    if (attachment.getEmbeddedFilename() != null) {\n      PDPage page = document.getPage(position.getPageIndex());\n      addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "254", "src_id": "M66", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final Observer<? super R> downstream = this.downstream;\n            final AtomicThrowable errors = this.errors;\n            final AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        if (!delayErrors) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    final boolean isDone = done;\n                    final SwitchMapMaybeObserver<R> current = inner.get();\n                    final boolean isEmpty = current == null;\n\n                    if (isDone && isEmpty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (isEmpty || current.item == null) {\n                        break;\n                    }\n\n                    inner.compareAndSet(current, null);\n                    downstream.onNext(current.item);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "255", "src_id": "M1333", "code": "\n        @Override\n        public void onNext(T t) {\n            if (done) {\n                return;\n            }\n            \n            boolean result;\n            try {\n                result = predicate.test(t);\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                onError(e);\n                return;\n            }\n            \n            if (!result) {\n                done = true;\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                downstream.onSuccess(false);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "256", "src_id": "M522", "code": "\n        void drainLoop() {\n            final Observer<? super T> actual = this.downstream;\n            int missed = 1;\n            \n            for (;;) {\n                for (;;) {\n                    if (disposed) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(actual);\n                        return;\n                    }\n\n                    int otherStatus = otherState;\n                    if (otherStatus == OTHER_STATE_HAS_VALUE) {\n                        T value = singleItem;\n                        singleItem = null;\n                        otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        otherStatus = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        actual.onNext(value);\n                    }\n\n                    final boolean isMainDone = mainDone;\n                    final SimplePlainQueue<T> q = queue;\n                    final T value = q != null ? q.poll() : null;\n                    final boolean isEmpty = value == null;\n\n                    if (isMainDone && isEmpty && otherStatus == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                        queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n\n                    if (isEmpty) {\n                        break;\n                    }\n\n                    actual.onNext(value);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "257", "src_id": "M1163", "code": "\n        @Override\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final SimplePlainQueue<Object> queue = this.queue;\n            final Subscriber<? super Flowable<T>> downstream = this.downstream;\n            UnicastProcessor<T> window = this.window;\n\n            for (;;) {\n                if (upstreamCancelled) {\n                    queue.clear();\n                    window = null;\n                    this.window = null;\n                } else {\n                    final boolean isDone = done;\n                    final Object item = queue.poll();\n                    final boolean isEmpty = item == null;\n\n                    if (isDone && isEmpty) {\n                        Throwable ex = error;\n                        if (ex != null) {\n                            if (window != null) {\n                                window.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        } else {\n                            if (window != null) {\n                                window.onComplete();\n                            }\n                            downstream.onComplete();\n                        }\n                        cleanupResources();\n                        upstreamCancelled = true;\n                        continue;\n                    } else if (!isEmpty) {\n                        if (item instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) item;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else if (window != null) {\n                            @SuppressWarnings(\"unchecked\")\n                            T castedItem = (T) item;\n                            window.onNext(castedItem);\n\n                            long currentCount = this.count + 1;\n                            if (currentCount == maxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            } else {\n                                this.count = currentCount;\n                            }\n                        }\n                        continue;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "258", "src_id": "M478", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final EqualObserver<T>[] as = observers;\n\n            final EqualObserver<T> observer1 = as[0];\n            final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n            final EqualObserver<T> observer2 = as[1];\n            final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q1.clear();\n                        q2.clear();\n                        return;\n                    }\n\n                    final boolean isDone1 = observer1.done;\n                    if (isDone1) {\n                        Throwable e = observer1.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    final boolean isDone2 = observer2.done;\n                    if (isDone2) {\n                        Throwable e = observer2.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    if (v1 == null) {\n                        v1 = q1.poll();\n                    }\n                    final boolean isEmpty1 = v1 == null;\n\n                    if (v2 == null) {\n                        v2 = q2.poll();\n                    }\n                    final boolean isEmpty2 = v2 == null;\n\n                    if (isDone1 && isDone2 && isEmpty1 && isEmpty2) {\n                        downstream.onSuccess(true);\n                        return;\n                    }\n                    if ((isDone1 && isDone2) && (isEmpty1 != isEmpty2)) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    if (!isEmpty1 && !isEmpty2) {\n                        boolean compareResult;\n                        try {\n                            compareResult = comparer.test(v1, v2);\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            cancel(q1, q2);\n                            downstream.onError(ex);\n                            return;\n                        }\n\n                        if (!compareResult) {\n                            cancel(q1, q2);\n                            downstream.onSuccess(false);\n                            return;\n                        }\n\n                        v1 = null;\n                        v2 = null;\n                    }\n\n                    if (isEmpty1 || isEmpty2) {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "259", "src_id": "M885", "code": "\n        void drainLoop() {\n            int missed = 1;\n            final JoinInnerSubscriber<T>[] s = this.subscribers;\n            final int n = s.length;\n            final Subscriber<? super T> a = this.downstream;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0;\n\n                middle:\n                while (e != r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean isDone = done.get() == 0;\n                    boolean isEmpty = true;\n\n                    for (int i = 0; i < s.length; i++) {\n                        JoinInnerSubscriber<T> inner = s[i];\n                        SimplePlainQueue<T> q = inner.queue;\n                        if (q != null) {\n                            T v = q.poll();\n                            if (v != null) {\n                                isEmpty = false;\n                                a.onNext(v);\n                                inner.requestOne();\n                                if (++e == r) {\n                                    break middle;\n                                }\n                            }\n                        }\n                    }\n\n                    if (isDone && isEmpty) {\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (isEmpty) {\n                        break;\n                    }\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean isDone = done.get() == 0;\n                    boolean isEmpty = true;\n\n                    for (int i = 0; i < n; i++) {\n                        JoinInnerSubscriber<T> inner = s[i];\n                        SimpleQueue<T> q = inner.queue;\n                        if (q != null && !q.isEmpty()) {\n                            isEmpty = false;\n                            break;\n                        }\n                    }\n\n                    if (isDone && isEmpty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n\n                if (e != 0) {\n                    BackpressureHelper.produced(requested, e);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "260", "src_id": "M1399", "code": "\n        @Override\n        public void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            InnerQueuedSubscriber<R> inner = current;\n            final Subscriber<? super R> a = downstream;\n            final ErrorMode em = errorMode;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0L;\n\n                if (inner == null) {\n                    if (em != ErrorMode.END) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean outerDone = done;\n                    inner = subscribers.poll();\n\n                    if (outerDone && inner == null) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (inner != null) {\n                        current = inner;\n                    }\n                }\n\n                boolean continueNextSource = false;\n\n                if (inner != null) {\n                    SimpleQueue<R> q = inner.queue();\n                    if (q != null) {\n                        while (e != r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            boolean isInnerDone = inner.isDone();\n                            R value;\n                            try {\n                                value = q.poll();\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                a.onError(ex);\n                                return;\n                            }\n\n                            boolean isEmpty = value == null;\n\n                            if (isInnerDone && isEmpty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                                break;\n                            }\n\n                            if (isEmpty) {\n                                break;\n                            }\n\n                            a.onNext(value);\n                            e++;\n                            inner.request(1L);\n                        }\n\n                        if (e == r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            boolean isInnerDone = inner.isDone();\n                            boolean isEmpty = q.isEmpty();\n\n                            if (isInnerDone && isEmpty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                            }\n                        }\n                    }\n                }\n\n                if (e != 0L && r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n\n                if (continueNextSource) {\n                    continue;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "261", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(CacheDisposable<T> consumer) {\n        for (;;) {\n            CacheDisposable<T>[] current = observers.get();\n            int n = current.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "262", "src_id": "M362", "code": "\n        void drainFused() {\n            int missed = 1;\n\n            for (;;) {\n                if (disposed) {\n                    return;\n                }\n\n                boolean isDone = done;\n                Throwable ex = error;\n\n                if (!delayError && isDone && ex != null) {\n                    disposed = true;\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                downstream.onNext(null);\n\n                if (isDone) {\n                    disposed = true;\n                    ex = error;\n                    if (ex != null) {\n                        downstream.onError(ex);\n                    } else {\n                        downstream.onComplete();\n                    }\n                    worker.dispose();\n                    return;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "263", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(PublishSubscription<T> ps) {\n        for (;;) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            \n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "264", "src_id": "M1086", "code": "\npublic static AdminServer createAdminServer() {\n    if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n        try {\n            Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n            Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n            return (AdminServer) adminServer;\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | \n                 InvocationTargetException | NoSuchMethodException e) {\n            LOG.warn(\"Unable to start JettyAdminServer\", e);\n        } catch (NoClassDefFoundError e) {\n            LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n        }\n    }\n    return new DummyAdminServer();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "265", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        for (SelectionKey key : selector.keys()) {\n            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "266", "src_id": "M219", "code": "\npublic static synchronized ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n    final String connectionId = concat(contextPath, session);\n    ZooKeeper zk = zkMap.get(connectionId);\n    if (zk == null) {\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"creating new connection for : '%s'\", connectionId));\n        }\n        Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n        }\n\n        zkMap.put(connectionId, zk);\n\n        if (session != null) {\n            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "267", "src_id": "M192", "code": "\nprivate void init() throws IOException {\n    File f = new File(file);\n    try (RandomAccessFileReader in = new RandomAccessFileReader(f)) {\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n\n        if (line != null \n                && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n\n        String lastentry = line;\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n                    lastentry = line;\n                }\n                if (serverid == 0 \n                        && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n            // ignore\n        }\n\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "268", "src_id": "M235", "code": "\n@POST\n@Produces({\n    MediaType.APPLICATION_JSON, \n    \"application/javascript\",\n    MediaType.APPLICATION_XML\n})\npublic Response createSession(\n        @QueryParam(\"op\") String op,\n        @DefaultValue(\"5\") @QueryParam(\"expire\") String expire,\n        @Context UriInfo ui) {\n    if (!op.equals(\"create\")) {\n        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                .entity(new ZError(ui.getRequestUri().toString(), \"\"))\n                .build());\n    }\n\n    int expireInSeconds;\n    try {\n        expireInSeconds = Integer.parseInt(expire);\n    } catch (NumberFormatException e) {\n        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n    }\n\n    String uuid = UUID.randomUUID().toString();\n    while (ZooKeeperService.isConnected(contextPath, uuid)) {\n        uuid = UUID.randomUUID().toString();\n    }\n\n    try {\n        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n    } catch (IOException e) {\n        LOG.error(\"Failed while trying to create a new session\", e);\n        throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n    }\n\n    URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n    return Response.created(uri)\n            .entity(new JSONWithPadding(new ZSession(uuid, uri.toString())))\n            .build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "269", "src_id": "M942", "code": "\npublic void schedule(WorkRequest workRequest, long id) {\n    if (stopped) {\n        workRequest.cleanup();\n        return;\n    }\n\n    ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n    int size = workers.size();\n    if (size > 0) {\n        try {\n            int workerNum = ((int) (id % size) + size) % size;\n            ExecutorService worker = workers.get(workerNum);\n            worker.execute(scheduledWorkRequest);\n        } catch (RejectedExecutionException e) {\n            LOG.warn(\"ExecutorService rejected execution\", e);\n            workRequest.cleanup();\n        }\n    } else {\n        scheduledWorkRequest.run();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "270", "src_id": "M520", "code": "\n@Override\npublic void close() throws IOException {\n    boolean triedToClose = false;\n    boolean success = false;\n    try {\n        flush();\n        ((FileOutputStream) out).getFD().sync();\n        triedToClose = true;\n        super.close();\n        success = true;\n    } finally {\n        if (success) {\n            boolean renamed = tmpFile.renameTo(origFile);\n            if (!renamed) {\n                if (!origFile.delete() \n                        || !tmpFile.renameTo(origFile)) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            }\n        } else {\n            if (!triedToClose) {\n                IOUtils.closeStream(out);\n            }\n            if (!tmpFile.delete()) {\n                LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "271", "src_id": "M186", "code": "\nprivate synchronized LogEntry readNextEntry() {\n    try {\n        try {\n            while (true) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                Matcher m = src.timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (buf.length() > 0) {\n                        LogEntry e = new Log4JEntry(\n                                src.timestampFromText(dateformat, buf), \n                                src.getServerId(), \n                                buf);\n                        buf = line;\n                        return e;\n                    }\n                    buf = line;\n                } else if (buf.length() > 0) {\n                    buf += line + \"\\n\";\n                }\n            }\n        } catch (EOFException eof) {\n            // ignore\n        }\n        if (buf.length() > 0) {\n            LogEntry e = new Log4JEntry(\n                    src.timestampFromText(dateformat, buf), \n                    src.getServerId(), \n                    buf);\n            buf = \"\";\n            return e;\n        }\n    } catch (Exception e) {\n        LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n        return null;\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "272", "src_id": "M478", "code": "\npublic static void main(String[] args) {\n    if (args.length < 3) {\n        usage();\n        return;\n    }\n    String host = args[0];\n    int port = Integer.parseInt(args[1]);\n    String op = args[2];\n    if (op.equalsIgnoreCase(\"gettracemask\")) {\n        getTraceMask(host, port);\n    } else if (op.equalsIgnoreCase(\"settracemask\")) {\n        setTraceMask(host, port, args[3]);\n    } else if (op.equalsIgnoreCase(\"ruok\")) {\n        ruok(host, port);\n    } else if (op.equalsIgnoreCase(\"kill\")) {\n        kill(host, port);\n    } else if (op.equalsIgnoreCase(\"stat\")) {\n        stat(host, port);\n    } else if (op.equalsIgnoreCase(\"dump\")) {\n        dump(host, port);\n    } else {\n        System.out.println(\"Unrecognized op: \" + op);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "273", "src_id": "M1043", "code": "\nprivate void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    final Thread thread = Thread.currentThread();\n\n    notifyPostProcessing(1);\n\n    if (DEBUG) {\n        thread.setName(String.format(\"[%s]  ps = %s  filename = %s\", TAG, psAlgorithm, storage.getName()));\n    }\n\n    Exception exception = null;\n\n    try {\n        psAlgorithm.run(this);\n    } catch (Exception err) {\n        Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n        if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n            notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) {\n            errCode = ERROR_POSTPROCESSING;\n        }\n\n        exception = err;\n    } finally {\n        notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n        if (exception == null) {\n            exception = errObject;\n        }\n        notifyError(ERROR_POSTPROCESSING, exception);\n        return;\n    }\n\n    notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "274", "src_id": "M1031", "code": "\nvoid establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n    final int statusCode = conn.getResponseCode();\n\n    if (DEBUG) {\n        Log.d(TAG, String.format(\"%d:[request]  Range=%s\", threadId, conn.getRequestProperty(\"Range\")));\n        Log.d(TAG, String.format(\"%d:[response] Code=%d\", threadId, statusCode));\n        Log.d(TAG, String.format(\"%d:[response] Content-Length=%d\", threadId, conn.getContentLength()));\n        Log.d(TAG, String.format(\"%d:[response] Content-Range=%s\", threadId, conn.getHeaderField(\"Content-Range\")));\n    }\n\n    switch (statusCode) {\n        case 204:\n        case 205:\n        case 207:\n            throw new HttpError(statusCode);\n        case 416:\n            return;\n        default:\n            if (statusCode < 200 || statusCode > 299) {\n                throw new HttpError(statusCode);\n            }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "275", "src_id": "M827", "code": "\nprivate Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n    if (b == null) {\n        return null;\n    }\n\n    final Elst obj = new Elst();\n\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3);\n\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n        obj.bMediaRate = 0x00010000;\n        return obj;\n    }\n\n    if (v1) {\n        stream.skipBytes(DataReader.LONG_SIZE);\n        obj.mediaTime = stream.readLong();\n        stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n    } else {\n        stream.skipBytes(DataReader.INTEGER_SIZE);\n        obj.mediaTime = stream.readInt();\n    }\n\n    obj.bMediaRate = stream.readInt();\n\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "276", "src_id": "M1048", "code": "\n@Override\npublic void run() {\n    boolean done = false;\n    long start = mMission.fallbackResumeOffset;\n\n    if (DEBUG && !mMission.unknownLength && start > 0) {\n        Log.i(TAG, String.format(\"Resuming a single-thread download at %d\", start));\n    }\n\n    try {\n        final long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n        final int mId = 1;\n        mConn = mMission.openConnection(false, rangeStart, -1);\n\n        if (mRetryCount == 0 && rangeStart == -1) {\n            mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n        }\n\n        mMission.establishConnection(mId, mConn);\n\n        if (mConn.getResponseCode() == 416 && start > 0) {\n            mMission.notifyProgress(-start);\n            start = 0;\n            mRetryCount--;\n            throw new DownloadMission.HttpError(416);\n        }\n\n        if (!mMission.unknownLength) {\n            mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n        }\n\n        if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n            mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n        }\n\n        mF = mMission.storage.getStream();\n        mF.seek(mMission.offsets[mMission.current] + start);\n        mIs = mConn.getInputStream();\n\n        final byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n        int len = 0;\n\n        while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n            mF.write(buf, 0, len);\n            start += len;\n            mMission.notifyProgress(len);\n        }\n\n        dispose();\n        done = len == -1;\n    } catch (Exception e) {\n        dispose();\n        mMission.fallbackResumeOffset = start;\n\n        if (!mMission.running || e instanceof ClosedByInterruptException) {\n            return;\n        }\n\n        if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n            dispose();\n            mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n            return;\n        }\n\n        if (mRetryCount++ >= mMission.maxRetry) {\n            mMission.notifyError(e);\n            return;\n        }\n\n        if (DEBUG) {\n            Log.e(TAG, \"got exception, retrying...\", e);\n        }\n\n        run();\n        return;\n    }\n\n    if (done) {\n        mMission.notifyFinished();\n    } else {\n        mMission.fallbackResumeOffset = start;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "277", "src_id": "M1141", "code": "\nprivate void flushAuxiliar(long amount) throws IOException {\n    if (aux.length < 1) {\n        return;\n    }\n\n    out.flush();\n    aux.flush();\n\n    final boolean underflow = aux.offset < aux.length || out.offset < out.length;\n    final byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n    aux.target.seek(0);\n    out.target.seek(out.length);\n\n    long length = amount;\n    while (length > 0) {\n        int read = (int) Math.min(length, Integer.MAX_VALUE);\n        read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n        if (read < 1) {\n            amount -= length;\n            break;\n        }\n\n        out.writeProof(buffer, read);\n        length -= read;\n    }\n\n    if (underflow) {\n        if (out.offset >= out.length) {\n            if (aux.offset < amount) {\n                out.offset += aux.offset;\n                aux.offset = 0;\n                out.target.seek(out.offset);\n            } else {\n                aux.offset -= amount;\n                out.offset = out.length + amount;\n            }\n        } else {\n            aux.offset = 0;\n        }\n    } else {\n        out.offset += amount;\n        aux.offset -= amount;\n    }\n\n    out.length += amount;\n\n    if (out.length > maxLengthKnown) {\n        maxLengthKnown = out.length;\n    }\n\n    if (amount < aux.length) {\n        long readOffset = amount;\n        long writeOffset = 0;\n\n        aux.length -= amount;\n        length = aux.length;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            aux.target.seek(writeOffset);\n            aux.writeProof(buffer, read);\n\n            writeOffset += read;\n            readOffset += read;\n            length -= read;\n\n            aux.target.seek(readOffset);\n        }\n\n        aux.target.setLength(aux.length);\n        return;\n    }\n\n    if (aux.length > THRESHOLD_AUX_LENGTH) {\n        aux.target.setLength(THRESHOLD_AUX_LENGTH);\n    }\n\n    aux.reset();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "278", "src_id": "M1106", "code": "\nprivate void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n    final StringBuilder request = new StringBuilder(256);\n    request.append(mission.source).append(\" [\");\n\n    if (mission.recoveryInfo != null) {\n        for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n            request.append(' ').append(recovery.toString()).append(' ');\n        }\n    }\n    request.append(\"]\");\n\n    final String service;\n    try {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e) {\n        service = ErrorInfo.SERVICE_NONE;\n    }\n\n    ErrorUtil.createNotification(mContext, new ErrorInfo(\n        ErrorInfo.Companion.throwableToStringList(mission.errObject),\n        action,\n        service,\n        request.toString(),\n        reason\n    ));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "279", "src_id": "M1067", "code": "\nvoid startMission(DownloadMission mission) {\n    synchronized (this) {\n        mission.timestamp = System.currentTimeMillis();\n        mission.mHandler = mHandler;\n        mission.maxRetry = mPrefMaxRetry;\n\n        while (true) {\n            mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n            if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                try {\n                    if (!mission.metadata.createNewFile()) {\n                        throw new RuntimeException(\"Cant create download metadata file\");\n                    }\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                break;\n            }\n            mission.timestamp = System.currentTimeMillis();\n        }\n\n        mSelfMissionsControl = true;\n        mMissionsPending.add(mission);\n        Utility.writeToFile(mission.metadata, mission);\n\n        if (mission.storage == null) {\n            mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n            if (mission.errObject != null) {\n                mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n            }\n            return;\n        }\n\n        final boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n        if (canDownloadInCurrentNetwork() && start) {\n            mission.start();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "280", "src_id": "M1136", "code": "\n@Override\nint process(SharpStream out, SharpStream... sources) throws IOException {\n    final String format = getArgumentAt(0, null);\n    final boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n    if (format == null || format.equals(\"ttml\")) {\n        final SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n        try {\n            writer.build(sources[0]);\n        } catch (Exception err) {\n            Log.e(TAG, \"subtitle parse failed\", err);\n            return err instanceof IOException ? 1 : 8;\n        }\n        return OK_RESULT;\n    } else if (format.equals(\"srt\")) {\n        final byte[] buffer = new byte[8 * 1024];\n        int read;\n        while ((read = sources[0].read(buffer)) > 0) {\n            out.write(buffer, 0, read);\n        }\n        return OK_RESULT;\n    }\n\n    throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "281", "src_id": "M1047", "code": "\nprivate void joinForThreads(int millis) {\n    final Thread currentThread = Thread.currentThread();\n\n    if (init != null && init != currentThread && init.isAlive()) {\n        init.interrupt();\n        if (millis > 0) {\n            try {\n                init.join(millis);\n            } catch (InterruptedException e) {\n                Log.w(TAG, \"Initializer thread is still running\", e);\n                return;\n            }\n        }\n    }\n\n    for (final Thread thread : threads) {\n        if (!thread.isAlive() || thread == currentThread) continue;\n        thread.interrupt();\n    }\n\n    try {\n        for (final Thread thread : threads) {\n            if (!thread.isAlive()) continue;\n            if (DEBUG) {\n                Log.w(TAG, \"thread alive: \" + thread.getName());\n            }\n            if (millis > 0) {\n                thread.join(millis);\n            }\n        }\n    } catch (InterruptedException e) {\n        throw new RuntimeException(\"A download thread is still running\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "282", "src_id": "M66", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) return;\n\n            int missed = 1;\n            final Observer<? super R> downstream = this.downstream;\n            final AtomicThrowable errors = this.errors;\n            final AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) return;\n\n                    if (errors.get() != null && !delayErrors) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    final boolean d = done;\n                    final SwitchMapMaybeObserver<R> current = inner.get();\n                    final boolean empty = current == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty || current.item == null) break;\n\n                    inner.compareAndSet(current, null);\n                    downstream.onNext(current.item);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) break;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "283", "src_id": "M1333", "code": "\n        @Override\n        public void onNext(T t) {\n            if (done) return;\n\n            try {\n                if (!predicate.test(t)) {\n                    done = true;\n                    upstream.cancel();\n                    upstream = SubscriptionHelper.CANCELLED;\n                    downstream.onSuccess(false);\n                }\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                onError(e);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "284", "src_id": "M522", "code": "\n        void drainLoop() {\n            final Observer<? super T> actual = this.downstream;\n            int missed = 1;\n\n            for (;;) {\n                for (;;) {\n                    if (disposed) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(actual);\n                        return;\n                    }\n\n                    int os = otherState;\n                    if (os == OTHER_STATE_HAS_VALUE) {\n                        final T v = singleItem;\n                        singleItem = null;\n                        otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        actual.onNext(v);\n                    }\n\n                    final boolean d = mainDone;\n                    final SimplePlainQueue<T> q = queue;\n                    final T v = q != null ? q.poll() : null;\n                    final boolean empty = v == null;\n\n                    if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                        queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n\n                    if (empty) break;\n                    actual.onNext(v);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) break;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "285", "src_id": "M1163", "code": "\n        @Override\n        void drain() {\n            if (getAndIncrement() != 0) return;\n\n            int missed = 1;\n            final SimplePlainQueue<Object> queue = this.queue;\n            final Subscriber<? super Flowable<T>> downstream = this.downstream;\n            UnicastProcessor<T> window = this.window;\n\n            for (;;) {\n                if (upstreamCancelled) {\n                    queue.clear();\n                    window = null;\n                    this.window = null;\n                } else {\n                    final boolean isDone = done;\n                    final Object o = queue.poll();\n                    final boolean isEmpty = o == null;\n\n                    if (isDone && isEmpty) {\n                        final Throwable ex = error;\n                        if (ex != null) {\n                            if (window != null) window.onError(ex);\n                            downstream.onError(ex);\n                        } else {\n                            if (window != null) window.onComplete();\n                            downstream.onComplete();\n                        }\n                        cleanupResources();\n                        upstreamCancelled = true;\n                        continue;\n                    }\n\n                    if (!isEmpty) {\n                        if (o instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else if (window != null) {\n                            @SuppressWarnings(\"unchecked\")\n                            final T item = (T) o;\n                            window.onNext(item);\n\n                            final long count = this.count + 1;\n                            if (count == maxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            } else {\n                                this.count = count;\n                            }\n                        }\n                        continue;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) break;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "286", "src_id": "M478", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) return;\n\n            int missed = 1;\n            final EqualObserver<T>[] as = observers;\n            final EqualObserver<T> observer1 = as[0];\n            final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n            final EqualObserver<T> observer2 = as[1];\n            final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n            T v1 = null;\n            T v2 = null;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q1.clear();\n                        q2.clear();\n                        return;\n                    }\n\n                    final boolean d1 = observer1.done;\n                    if (d1 && observer1.error != null) {\n                        cancel(q1, q2);\n                        downstream.onError(observer1.error);\n                        return;\n                    }\n\n                    final boolean d2 = observer2.done;\n                    if (d2 && observer2.error != null) {\n                        cancel(q1, q2);\n                        downstream.onError(observer2.error);\n                        return;\n                    }\n\n                    if (v1 == null) v1 = q1.poll();\n                    if (v2 == null) v2 = q2.poll();\n                    final boolean e1 = v1 == null;\n                    final boolean e2 = v2 == null;\n\n                    if (d1 && d2 && e1 && e2) {\n                        downstream.onSuccess(true);\n                        return;\n                    }\n\n                    if (d1 && d2 && e1 != e2) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    if (!e1 && !e2) {\n                        try {\n                            if (!comparer.test(v1, v2)) {\n                                cancel(q1, q2);\n                                downstream.onSuccess(false);\n                                return;\n                            }\n                            v1 = null;\n                            v2 = null;\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            cancel(q1, q2);\n                            downstream.onError(ex);\n                            return;\n                        }\n                    }\n\n                    if (e1 || e2) break;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) break;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "287", "src_id": "M885", "code": "\n        void drainLoop() {\n            int missed = 1;\n            final JoinInnerSubscriber<T>[] s = this.subscribers;\n            final int n = s.length;\n            final Subscriber<? super T> a = this.downstream;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0;\n\n                middle:\n                while (e != r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    final Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    final boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < n; i++) {\n                        final JoinInnerSubscriber<T> inner = s[i];\n                        final SimplePlainQueue<T> q = inner.queue;\n                        if (q != null) {\n                            final T v = q.poll();\n                            if (v != null) {\n                                empty = false;\n                                a.onNext(v);\n                                inner.requestOne();\n                                if (++e == r) break middle;\n                            }\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n                    if (empty) break;\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    final Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    final boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < n; i++) {\n                        final JoinInnerSubscriber<T> inner = s[i];\n                        final SimpleQueue<T> q = inner.queue;\n                        if (q != null && !q.isEmpty()) {\n                            empty = false;\n                            break;\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n\n                if (e != 0) BackpressureHelper.produced(requested, e);\n                missed = addAndGet(-missed);\n                if (missed == 0) break;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "288", "src_id": "M1399", "code": "\n        @Override\n        public void drain() {\n            if (getAndIncrement() != 0) return;\n\n            int missed = 1;\n            InnerQueuedSubscriber<R> inner = current;\n            final Subscriber<? super R> a = downstream;\n            final ErrorMode em = errorMode;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0;\n\n                if (inner == null) {\n                    if (em != ErrorMode.END) {\n                        final Throwable ex = errors.get();\n                        if (ex != null) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    final boolean outerDone = done;\n                    inner = subscribers.poll();\n\n                    if (outerDone && inner == null) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (inner != null) current = inner;\n                }\n\n                boolean continueNextSource = false;\n\n                if (inner != null) {\n                    final SimpleQueue<R> q = inner.queue();\n                    if (q != null) {\n                        while (e != r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                final Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            final boolean d = inner.isDone();\n                            R v;\n                            try {\n                                v = q.poll();\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                a.onError(ex);\n                                return;\n                            }\n\n                            final boolean empty = v == null;\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                                break;\n                            }\n\n                            if (empty) break;\n                            a.onNext(v);\n                            e++;\n                            inner.request(1L);\n                        }\n\n                        if (e == r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                final Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            final boolean d = inner.isDone();\n                            final boolean empty = q.isEmpty();\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                            }\n                        }\n                    }\n                }\n\n                if (e != 0L && r != Long.MAX_VALUE) requested.addAndGet(-e);\n                if (continueNextSource) continue;\n                missed = addAndGet(-missed);\n                if (missed == 0) break;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "289", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(CacheDisposable<T> consumer) {\n        for (;;) {\n            CacheDisposable<T>[] current = observers.get();\n            final int n = current.length;\n            if (n == 0) return;\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) return;\n\n            final CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) return;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "290", "src_id": "M362", "code": "\n        void drainFused() {\n            int missed = 1;\n\n            for (;;) {\n                if (disposed) return;\n\n                final boolean d = done;\n                Throwable ex = error;\n\n                if (!delayError && d && ex != null) {\n                    disposed = true;\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                downstream.onNext(null);\n\n                if (d) {\n                    disposed = true;\n                    ex = error;\n                    if (ex != null) downstream.onError(ex);\n                    else downstream.onComplete();\n                    worker.dispose();\n                    return;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) break;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "291", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(PublishSubscription<T> ps) {\n        for (;;) {\n            PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) return;\n\n            int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) return;\n\n            final PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) return;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "292", "src_id": "M31", "code": "\nprivate JsonNode validateLicense(\n        String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n    String requestBody = String.format(\n            \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}\",\n            licenseKey, machineFingerprint);\n    \n    HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n            .header(\"Content-Type\", \"application/vnd.api+json\")\n            .header(\"Accept\", \"application/vnd.api+json\")\n            .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n            .build();\n\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n    JsonNode jsonResponse = objectMapper.readTree(response.body());\n    \n    if (response.statusCode() != 200) {\n        log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        return jsonResponse;\n    }\n\n    JsonNode metaNode = jsonResponse.path(\"meta\");\n    boolean isValid = metaNode.path(\"valid\").asBoolean();\n    String detail = metaNode.path(\"detail\").asText();\n    String code = metaNode.path(\"code\").asText();\n\n    log.info(\"License validity: {}\", isValid);\n    log.info(\"Validation detail: {}\", detail);\n    log.info(\"Validation code: {}\", code);\n\n    JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n    if (!licenseAttrs.isMissingNode()) {\n        context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n        context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n        log.info(\"License floating (from license): {}, maxMachines: {}\", \n                context.isFloatingLicense, context.maxMachines);\n    }\n\n    JsonNode includedNode = jsonResponse.path(\"included\");\n    JsonNode policyNode = null;\n    if (includedNode.isArray()) {\n        for (JsonNode node : includedNode) {\n            if (\"policies\".equals(node.path(\"type\").asText())) {\n                policyNode = node;\n                break;\n            }\n        }\n    }\n\n    if (policyNode != null) {\n        boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n        int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n        if (policyFloating) {\n            context.isFloatingLicense = true;\n            context.maxMachines = policyMaxMachines;\n        }\n        log.info(\"License floating (from policy): {}, maxMachines: {}\", \n                context.isFloatingLicense, context.maxMachines);\n    }\n\n    int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n    applicationProperties.getPremium().setMaxUsers(users);\n    context.isEnterpriseLicense = jsonResponse.path(\"data\")\n            .path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n    \n    log.debug(applicationProperties.toString());\n    return jsonResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "293", "src_id": "M488", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n@Operation(\n        summary = \"Convert a file to a PDF using LibreOffice\",\n        description = \"This endpoint converts a given file to a PDF using LibreOffice API Input:ANY Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n    MultipartFile inputFile = generalFile.getFileInput();\n    File file = null;\n    try {\n        file = convertToPdf(inputFile);\n        PDDocument doc = pdfDocumentFactory.load(file);\n        String fileName = Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                .replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\";\n        return WebResponseUtils.pdfDocToWebResponse(doc, fileName);\n    } finally {\n        if (file != null) Files.deleteIfExists(file.toPath());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "294", "src_id": "M625", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\npublic ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n    try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, true)) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        ObjectNode jsonOutput = objectMapper.createObjectNode();\n        \n        PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n        ObjectNode metadata = objectMapper.createObjectNode();\n        metadata.put(\"Title\", info.getTitle());\n        metadata.put(\"Author\", info.getAuthor());\n        metadata.put(\"Subject\", info.getSubject());\n        metadata.put(\"Keywords\", info.getKeywords());\n        metadata.put(\"Producer\", info.getProducer());\n        metadata.put(\"Creator\", info.getCreator());\n        metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n        metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n        jsonOutput.set(\"Metadata\", metadata);\n\n        long fileSizeInBytes = inputFile.getSize();\n        ObjectNode basicInfo = objectMapper.createObjectNode();\n        basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n        String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n        String[] words = fullText.split(\"\\\\s+\");\n        int wordCount = words.length;\n        int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n        int charCount = fullText.length();\n        basicInfo.put(\"WordCount\", wordCount);\n        basicInfo.put(\"ParagraphCount\", paragraphCount);\n        basicInfo.put(\"CharacterCount\", charCount);\n\n        String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n        basicInfo.put(\"Language\", language);\n        basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n        // ... rest of the method remains with similar transformations ...\n        \n        String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n        return WebResponseUtils.bytesToWebResponse(\n                jsonString.getBytes(StandardCharsets.UTF_8),\n                \"response.json\",\n                MediaType.APPLICATION_JSON);\n    } catch (Exception e) {\n        log.error(\"PDF processing error\", e);\n        throw e;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "295", "src_id": "M24", "code": "\nprivate boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n    try {\n        String encodedPayload = licenseFile.replace(CERT_PREFIX, \"\")\n                .replace(CERT_SUFFIX, \"\")\n                .replaceAll(\"\\\\r?\\\\n\", \"\");\n        byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n        String payload = new String(payloadBytes);\n        log.info(\"Decoded certificate payload: {}\", payload);\n\n        JSONObject attrs = new JSONObject(payload);\n        String encryptedData = attrs.getString(\"enc\");\n        String encodedSignature = attrs.getString(\"sig\");\n        String algorithm = attrs.getString(\"alg\");\n\n        if (!\"base64+ed25519\".equals(algorithm)) {\n            log.error(\"Unsupported algorithm: {}. Only base64+ed25519 supported\", algorithm);\n            return false;\n        }\n\n        if (!verifyEd25519Signature(encryptedData, encodedSignature)) {\n            log.error(\"License signature invalid\");\n            return false;\n        }\n\n        String decodedData = new String(Base64.getDecoder().decode(encryptedData));\n        return processCertificateData(decodedData, context);\n    } catch (JSONException e) {\n        log.error(\"License parse error: {}\", e.getMessage());\n        return false;\n    } catch (Exception e) {\n        log.error(\"Certificate verification error: {}\", e.getMessage(), e);\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "296", "src_id": "M403", "code": "\nprivate static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws IOException {\n    try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager);\n         ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n             new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n        \n        ZipEntry entry;\n        while ((entry = zipIn.getNextEntry()) != null) {\n            Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n            if (entry.isDirectory()) continue;\n            \n            Files.createDirectories(filePath.getParent());\n            String name = entry.getName().toLowerCase();\n            if (name.endsWith(\".html\") || name.endsWith(\".htm\")) {\n                String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                Files.write(filePath, sanitizeHtmlContent(content, disableSanitize).getBytes(StandardCharsets.UTF_8));\n            } else {\n                Files.copy(zipIn, filePath);\n            }\n            zipIn.closeEntry();\n        }\n        zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "297", "src_id": "M317", "code": "\npublic static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws IOException {\n    PDRectangle pageSize = PDRectangle.A4;\n    boolean imageIsLandscape = image.getWidth() > image.getHeight();\n    \n    if (autoRotate && imageIsLandscape) {\n        pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n    }\n    if (\"fitDocumentToImage\".equals(fitOption)) {\n        pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n    }\n\n    PDPage page = new PDPage(pageSize);\n    doc.addPage(page);\n    float pageWidth = page.getMediaBox().getWidth();\n    float pageHeight = page.getMediaBox().getHeight();\n\n    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true)) {\n        if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n            contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n        } else if (\"maintainAspectRatio\".equals(fitOption)) {\n            float imageAspectRatio = (float) image.getWidth() / image.getHeight();\n            float pageAspectRatio = pageWidth / pageHeight;\n            float scaleFactor = imageAspectRatio > pageAspectRatio \n                ? pageWidth / image.getWidth() \n                : pageHeight / image.getHeight();\n            \n            float xPos = (pageWidth - image.getWidth() * scaleFactor) / 2;\n            float yPos = (pageHeight - image.getHeight() * scaleFactor) / 2;\n            contentStream.drawImage(image, xPos, yPos, \n                image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "298", "src_id": "M307", "code": "\npublic static String generateMachineFingerprint() {\n    try {\n        StringBuilder sb = new StringBuilder();\n        Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n        while (networks.hasMoreElements()) {\n            NetworkInterface net = networks.nextElement();\n            byte[] mac = net.getHardwareAddress();\n            if (mac == null) continue;\n            for (byte b : mac) sb.append(String.format(\"%02X\", b));\n            break;\n        }\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n        StringBuilder fingerprint = new StringBuilder();\n        for (byte b : hash) fingerprint.append(String.format(\"%02x\", b));\n        return fingerprint.toString();\n    } catch (Exception e) {\n        return \"GenericID\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "299", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n    pdf.getDocumentInformation().setTitle(pdfMetadata.getTitle());\n    pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata()\n            && runningProOrHigher) {\n        author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n        if (userService != null) {\n            author = author.replace(\"username\", userService.getCurrentUsername());\n        }\n    }\n    pdf.getDocumentInformation().setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "300", "src_id": "M128", "code": "\n@Bean(name = \"machineType\")\npublic String determineMachineType() {\n    try {\n        if (System.getenv(\"KUBERNETES_SERVICE_HOST\") != null) return \"Kubernetes\";\n        if (runningInDocker()) return \"Docker\";\n        if (!\"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"))) return \"Server-jar\";\n        \n        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n        if (os.contains(\"win\")) return \"Client-windows\";\n        if (os.contains(\"mac\")) return \"Client-mac\";\n        return \"Client-unix\";\n    } catch (Exception e) {\n        return \"Unknown\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "301", "src_id": "M101", "code": "\nprivate void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets,\n        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n        throws IOException, ServletException {\n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n    \n    if (probe.isConsumed()) {\n        response.setHeader(\"X-Rate-Limit-Remaining\", Long.toString(probe.getRemainingTokens()));\n        filterChain.doFilter(request, response);\n        return;\n    }\n    \n    long waitSeconds = probe.getNanosToWaitForRefill() / 1_000_000_000;\n    response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n    response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Long.toString(waitSeconds));\n    response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "302", "src_id": "M31", "code": "\nprivate JsonNode validateLicense(\n        String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n    String requestBody = String.format(\n        \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}\",\n        licenseKey, machineFingerprint);\n    HttpRequest request = HttpRequest.newBuilder()\n        .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n        .header(\"Content-Type\", \"application/vnd.api+json\")\n        .header(\"Accept\", \"application/vnd.api+json\")\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n        .build();\n\n    HttpResponse<String> response = this.httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    this.log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n    JsonNode jsonResponse = this.objectMapper.readTree(response.body());\n    if (response.statusCode() == 200) {\n        JsonNode metaNode = jsonResponse.path(\"meta\");\n        boolean isValid = metaNode.path(\"valid\").asBoolean();\n        String detail = metaNode.path(\"detail\").asText();\n        String code = metaNode.path(\"code\").asText();\n\n        this.log.info(\"License validity: {}\", isValid);\n        this.log.info(\"Validation detail: {}\", detail);\n        this.log.info(\"Validation code: {}\", code);\n\n        JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n        if (!licenseAttrs.isMissingNode()) {\n            context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n            context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n            this.log.info(\"License floating (from license): {}, maxMachines: {}\", \n                context.isFloatingLicense, context.maxMachines);\n        }\n\n        JsonNode includedNode = jsonResponse.path(\"included\");\n        JsonNode policyNode = null;\n        if (includedNode.isArray()) {\n            for (JsonNode node : includedNode) {\n                if (\"policies\".equals(node.path(\"type\").asText())) {\n                    policyNode = node;\n                    break;\n                }\n            }\n        }\n\n        if (policyNode != null) {\n            boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n            int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n            if (policyFloating) {\n                context.isFloatingLicense = true;\n                context.maxMachines = policyMaxMachines;\n            }\n            this.log.info(\"License floating (from policy): {}, maxMachines: {}\", \n                context.isFloatingLicense, context.maxMachines);\n        }\n\n        int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n        this.applicationProperties.getPremium().setMaxUsers(users);\n\n        context.isEnterpriseLicense = jsonResponse.path(\"data\")\n            .path(\"attributes\")\n            .path(\"metadata\")\n            .path(\"isEnterprise\")\n            .asBoolean(false);\n\n        this.log.debug(this.applicationProperties.toString());\n    } else {\n        this.log.error(\"Error validating license. Status code: {}\", response.statusCode());\n    }\n    return jsonResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "303", "src_id": "M488", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n@Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n    MultipartFile inputFile = generalFile.getFileInput();\n    File file = null;\n    try {\n        file = convertToPdf(inputFile);\n        PDDocument doc = this.pdfDocumentFactory.load(file);\n        return WebResponseUtils.pdfDocToWebResponse(\n            doc,\n            Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                .replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n    } finally {\n        if (file != null) {\n            file.delete();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "304", "src_id": "M625", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\npublic ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n    boolean readonly = true;\n    try (PDDocument pdfBoxDoc = this.pdfDocumentFactory.load(inputFile, readonly);) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n        PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n        ObjectNode metadata = objectMapper.createObjectNode();\n        ObjectNode basicInfo = objectMapper.createObjectNode();\n        ObjectNode docInfoNode = objectMapper.createObjectNode();\n        ObjectNode compliancy = objectMapper.createObjectNode();\n        ObjectNode encryption = objectMapper.createObjectNode();\n        ObjectNode other = objectMapper.createObjectNode();\n\n        metadata.put(\"Title\", info.getTitle());\n        metadata.put(\"Author\", info.getAuthor());\n        metadata.put(\"Subject\", info.getSubject());\n        metadata.put(\"Keywords\", info.getKeywords());\n        metadata.put(\"Producer\", info.getProducer());\n        metadata.put(\"Creator\", info.getCreator());\n        metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n        metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n        jsonOutput.set(\"Metadata\", metadata);\n\n        long fileSizeInBytes = inputFile.getSize();\n        basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n        String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n        String[] words = fullText.split(\"\\\\s+\");\n        int wordCount = words.length;\n        int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n        basicInfo.put(\"WordCount\", wordCount);\n        basicInfo.put(\"ParagraphCount\", paragraphCount);\n        int charCount = fullText.length();\n        basicInfo.put(\"CharacterCount\", charCount);\n\n        boolean hasCompression = false;\n        String compressionType = \"None\";\n        basicInfo.put(\"Compression\", hasCompression);\n        if (hasCompression) {\n            basicInfo.put(\"CompressionType\", compressionType);\n        }\n\n        String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n        basicInfo.put(\"Language\", language);\n        basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n        PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n        String pageMode = catalog.getPageMode().name();\n        docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n        docInfoNode.put(\"Trapped\", info.getTrapped());\n        docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n        PDAcroForm acroForm = catalog.getAcroForm();\n        ObjectNode formFieldsNode = objectMapper.createObjectNode();\n        if (acroForm != null) {\n            for (PDField field : acroForm.getFieldTree()) {\n                formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n            }\n        }\n        jsonOutput.set(\"FormFields\", formFieldsNode);\n\n        ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n        if (summaryData != null && summaryData.size() > 0) {\n            jsonOutput.set(\"SummaryData\", summaryData);\n        }\n\n        if (catalog.getNames() != null) {\n            PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n            ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n            if (efTree != null) {\n                Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                if (efMap != null) {\n                    for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                        ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                        embeddedFileNode.put(\"Name\", entry.getKey());\n                        PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                        if (embeddedFile != null) {\n                            embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n                        }\n                        embeddedFilesArray.add(embeddedFileNode);\n                    }\n                }\n            }\n            other.set(\"EmbeddedFiles\", embeddedFilesArray);\n        }\n\n        ArrayNode attachmentsArray = objectMapper.createArrayNode();\n        for (PDPage page : pdfBoxDoc.getPages()) {\n            for (PDAnnotation annotation : page.getAnnotations()) {\n                if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                    ObjectNode attachmentNode = objectMapper.createObjectNode();\n                    attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                    attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                    attachmentsArray.add(attachmentNode);\n                }\n            }\n        }\n        other.set(\"Attachments\", attachmentsArray);\n\n        PDDocumentNameDictionary namesDict = catalog.getNames();\n        ArrayNode javascriptArray = objectMapper.createArrayNode();\n        if (namesDict != null) {\n            PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n            if (javascriptDict != null) {\n                try {\n                    Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                    for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                        ObjectNode jsNode = objectMapper.createObjectNode();\n                        jsNode.put(\"JS Name\", entry.getKey());\n                        PDActionJavaScript jsAction = entry.getValue();\n                        if (jsAction != null) {\n                            String jsCodeStr = jsAction.getAction();\n                            if (jsCodeStr != null) {\n                                jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                            }\n                        }\n                        javascriptArray.add(jsNode);\n                    }\n                } catch (IOException e) {\n                    this.log.error(\"exception\", e);\n                }\n            }\n        }\n        other.set(\"JavaScript\", javascriptArray);\n\n        PDOptionalContentProperties ocProperties = catalog.getOCProperties();\n        ArrayNode layersArray = objectMapper.createArrayNode();\n        if (ocProperties != null) {\n            for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                ObjectNode layerNode = objectMapper.createObjectNode();\n                layerNode.put(\"Name\", ocg.getName());\n                layersArray.add(layerNode);\n            }\n        }\n        other.set(\"Layers\", layersArray);\n\n        PDStructureTreeRoot structureTreeRoot = catalog.getStructureTreeRoot();\n        ArrayNode structureTreeArray;\n        try {\n            if (structureTreeRoot != null) {\n                structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                other.set(\"StructureTree\", structureTreeArray);\n            }\n        } catch (Exception e) {\n            this.log.error(\"exception\", e);\n        }\n\n        boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n        boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n        boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n        boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n        boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n        boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\");\n        boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\");\n\n        compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n        compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n        compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n        compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n        compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n        compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n        compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n        PDOutlineNode root = catalog.getDocumentOutline();\n        ArrayNode bookmarksArray = objectMapper.createArrayNode();\n        if (root != null) {\n            for (PDOutlineItem child : root.children()) {\n                addOutlinesToArray(child, bookmarksArray);\n            }\n        }\n        other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n        PDMetadata pdMetadata = catalog.getMetadata();\n        String xmpString = null;\n        if (pdMetadata != null) {\n            try (COSInputStream is = pdMetadata.createInputStream()) {\n                DomXmpParser domXmpParser = new DomXmpParser();\n                XMPMetadata xmpMeta = domXmpParser.parse(is);\n                ByteArrayOutputStream os = new ByteArrayOutputStream();\n                new XmpSerializer().serialize(xmpMeta, os, true);\n                xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n            } catch (XmpParsingException e) {\n                this.log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                try (COSInputStream is = pdMetadata.createInputStream()) {\n                    byte[] metadataBytes = is.readAllBytes();\n                    xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                }\n            } catch (IOException e) {\n                this.log.error(\"exception\", e);\n            }\n        }\n        other.put(\"XMPMetadata\", xmpString);\n\n        if (pdfBoxDoc.isEncrypted()) {\n            encryption.put(\"IsEncrypted\", true);\n            PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n            encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n            encryption.put(\"KeyLength\", pdfEncryption.getLength());\n        } else {\n            encryption.put(\"IsEncrypted\", false);\n        }\n\n        ObjectNode permissionsNode = objectMapper.createObjectNode();\n        setNodePermissions(pdfBoxDoc, permissionsNode);\n\n        ObjectNode pageInfoParent = objectMapper.createObjectNode();\n        for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n            ObjectNode pageInfo = objectMapper.createObjectNode();\n            PDPage page = pdfBoxDoc.getPage(pageNum);\n            PDRectangle mediaBox = page.getMediaBox();\n            float width = mediaBox.getWidth();\n            float height = mediaBox.getHeight();\n            ObjectNode sizeInfo = objectMapper.createObjectNode();\n            getDimensionInfo(sizeInfo, width, height);\n            sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n            pageInfo.set(\"Size\", sizeInfo);\n            pageInfo.put(\"Rotation\", page.getRotation());\n            pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n            pageInfo.put(\"MediaBox\", mediaBox.toString());\n\n            PDRectangle cropBox = page.getCropBox();\n            pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n            PDRectangle bleedBox = page.getBleedBox();\n            pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n            PDRectangle trimBox = page.getTrimBox();\n            pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n            PDRectangle artBox = page.getArtBox();\n            pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n\n            PDFTextStripper textStripper = new PDFTextStripper();\n            textStripper.setStartPage(pageNum + 1);\n            textStripper.setEndPage(pageNum + 1);\n            String pageText = textStripper.getText(pdfBoxDoc);\n            pageInfo.put(\"Text Characters Count\", pageText.length());\n\n            List<PDAnnotation> annotations = page.getAnnotations();\n            int subtypeCount = 0;\n            int contentsCount = 0;\n            for (PDAnnotation annotation : annotations) {\n                if (annotation.getSubtype() != null) {\n                    subtypeCount++;\n                }\n                if (annotation.getContents() != null) {\n                    contentsCount++;\n                }\n            }\n            ObjectNode annotationsObject = objectMapper.createObjectNode();\n            annotationsObject.put(\"AnnotationsCount\", annotations.size());\n            annotationsObject.put(\"SubtypeCount\", subtypeCount);\n            annotationsObject.put(\"ContentsCount\", contentsCount);\n            pageInfo.set(\"Annotations\", annotationsObject);\n\n            PDResources resources = page.getResources();\n            ArrayNode imagesArray = objectMapper.createArrayNode();\n            for (COSName name : resources.getXObjectNames()) {\n                PDXObject xObject = resources.getXObject(name);\n                if (xObject instanceof PDImageXObject image) {\n                    ObjectNode imageNode = objectMapper.createObjectNode();\n                    imageNode.put(\"Width\", image.getWidth());\n                    imageNode.put(\"Height\", image.getHeight());\n                    if (image.getMetadata() != null\n                        && image.getMetadata().getFile() != null\n                        && image.getMetadata().getFile().getFile() != null) {\n                        imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                    }\n                    if (image.getColorSpace() != null) {\n                        imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                    }\n                    imagesArray.add(imageNode);\n                }\n            }\n            pageInfo.set(\"Images\", imagesArray);\n\n            ArrayNode linksArray = objectMapper.createArrayNode();\n            Set<String> uniqueURIs = new HashSet<String>();\n            for (PDAnnotation annotation : annotations) {\n                if (annotation instanceof PDAnnotationLink linkAnnotation) {\n                    if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri);\n                    }\n                }\n            }\n            for (String uri : uniqueURIs) {\n                ObjectNode linkNode = objectMapper.createObjectNode();\n                linkNode.put(\"URI\", uri);\n                linksArray.add(linkNode);\n            }\n            pageInfo.set(\"Links\", linksArray);\n\n            ArrayNode fontsArray = objectMapper.createArrayNode();\n            Map<String, ObjectNode> uniqueFontsMap = new HashMap<String, ObjectNode>();\n            for (COSName fontName : resources.getFontNames()) {\n                PDFont font = resources.getFont(fontName);\n                ObjectNode fontNode = objectMapper.createObjectNode();\n                fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                fontNode.put(\"Name\", font.getName());\n                fontNode.put(\"Subtype\", font.getType());\n                PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                if (fontDescriptor != null) {\n                    fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                    int flags = fontDescriptor.getFlags();\n                    fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                    fontNode.put(\"IsBold\", (flags & 64) != 0);\n                    fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                    fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                    fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                    fontNode.put(\"IsScript\", (flags & 16) != 0);\n                    fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                    fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                    fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                }\n                String uniqueKey = fontNode.toString();\n                if (uniqueFontsMap.containsKey(uniqueKey)) {\n                    ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                    int count = existingFontNode.get(\"Count\").asInt() + 1;\n                    existingFontNode.put(\"Count\", count);\n                } else {\n                    fontNode.put(\"Count\", 1);\n                    uniqueFontsMap.put(uniqueKey, fontNode);\n                }\n            }\n            for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                fontsArray.add(uniqueFontNode);\n            }\n            pageInfo.set(\"Fonts\", fontsArray);\n\n            ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n            Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n            for (COSName name : colorSpaceNames) {\n                PDColorSpace colorSpace = resources.getColorSpace(name);\n                if (colorSpace instanceof PDICCBased iccBased) {\n                    PDStream iccData = iccBased.getPDStream();\n                    byte[] iccBytes = iccData.toByteArray();\n                    ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                    iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                    colorSpacesArray.add(iccProfileNode);\n                }\n            }\n            pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n            Map<String, Integer> xObjectCountMap = new HashMap<String, Integer>();\n            for (COSName name : resources.getXObjectNames()) {\n                PDXObject xObject = resources.getXObject(name);\n                String xObjectType;\n                if (xObject instanceof PDImageXObject) {\n                    xObjectType = \"Image\";\n                } else if (xObject instanceof PDFormXObject) {\n                    xObjectType = \"Form\";\n                } else {\n                    xObjectType = \"Other\";\n                }\n                xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n            }\n            ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n            for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                xObjectCountNode.put(entry.getKey(), entry.getValue());\n            }\n            pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n            ArrayNode multimediaArray = objectMapper.createArrayNode();\n            for (PDAnnotation annotation : annotations) {\n                if (\"RichMedia\".equals(annotation.getSubtype())) {\n                    ObjectNode multimediaNode = objectMapper.createObjectNode();\n                    multimediaArray.add(multimediaNode);\n                }\n            }\n            pageInfo.set(\"Multimedia\", multimediaArray);\n            pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n        }\n\n        jsonOutput.set(\"BasicInfo\", basicInfo);\n        jsonOutput.set(\"DocumentInfo\", docInfoNode);\n        jsonOutput.set(\"Compliancy\", compliancy);\n        jsonOutput.set(\"Encryption\", encryption);\n        jsonOutput.set(\"Permissions\", permissionsNode);\n        jsonOutput.set(\"Other\", other);\n        jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n        String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n        return WebResponseUtils.bytesToWebResponse(\n            jsonString.getBytes(StandardCharsets.UTF_8),\n            \"response.json\",\n            MediaType.APPLICATION_JSON);\n    } catch (Exception e) {\n        this.log.error(\"exception\", e);\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "305", "src_id": "M24", "code": "\nprivate boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n    try {\n        String encodedPayload = licenseFile;\n        encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n        encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n        encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n        byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n        String payload = new String(payloadBytes);\n        this.log.info(\"Decoded certificate payload: {}\", payload);\n\n        String encryptedData = \"\";\n        String encodedSignature = \"\";\n        String algorithm = \"\";\n        try {\n            JSONObject attrs = new JSONObject(payload);\n            encryptedData = (String) attrs.get(\"enc\");\n            encodedSignature = (String) attrs.get(\"sig\");\n            algorithm = (String) attrs.get(\"alg\");\n        } catch (JSONException e) {\n            this.log.error(\"Failed to parse license file: {}\", e.getMessage());\n            return false;\n        }\n\n        if (!\"base64+ed25519\".equals(algorithm)) {\n            this.log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n            return false;\n        }\n\n        boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n        if (!isSignatureValid) {\n            this.log.error(\"License file signature is invalid\");\n            return false;\n        }\n        this.log.info(\"License file signature is valid\");\n\n        String decodedData;\n        try {\n            decodedData = new String(Base64.getDecoder().decode(encryptedData));\n        } catch (IllegalArgumentException e) {\n            this.log.error(\"Failed to decode license data: {}\", e.getMessage());\n            return false;\n        }\n\n        return processCertificateData(decodedData, context);\n    } catch (Exception e) {\n        this.log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "306", "src_id": "M403", "code": "\nprivate static void sanitizeHtmlFilesInZip(\n        Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n        throws IOException {\n    try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n        try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n                new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n            ZipEntry entry = zipIn.getNextEntry();\n            while (entry != null) {\n                Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                if (!entry.isDirectory()) {\n                    Files.createDirectories(filePath.getParent());\n                    if (entry.getName().toLowerCase().endsWith(\".html\")\n                        || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                        String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                        String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                        Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                    } else {\n                        Files.copy(zipIn, filePath);\n                    }\n                }\n                zipIn.closeEntry();\n                entry = zipIn.getNextEntry();\n            }\n        }\n        zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "307", "src_id": "M317", "code": "\npublic static void addImageToDocument(\n        PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n        throws IOException {\n    boolean imageIsLandscape = image.getWidth() > image.getHeight();\n    PDRectangle pageSize = PDRectangle.A4;\n    if (autoRotate && imageIsLandscape) {\n        pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n    }\n    if (\"fitDocumentToImage\".equals(fitOption)) {\n        pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n    }\n    PDPage page = new PDPage(pageSize);\n    doc.addPage(page);\n    float pageWidth = page.getMediaBox().getWidth();\n    float pageHeight = page.getMediaBox().getHeight();\n    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n        if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n            contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n        } else if (\"maintainAspectRatio\".equals(fitOption)) {\n            float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n            float pageAspectRatio = pageWidth / pageHeight;\n            float scaleFactor = 1.0f;\n            if (imageAspectRatio > pageAspectRatio) {\n                scaleFactor = pageWidth / image.getWidth();\n            } else {\n                scaleFactor = pageHeight / image.getHeight();\n            }\n            float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n            float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n            contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n        }\n    } catch (IOException e) {\n        log.error(\"Error adding image to PDF\", e);\n        throw e;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "308", "src_id": "M307", "code": "\npublic static String generateMachineFingerprint() {\n    try {\n        StringBuilder sb = new StringBuilder();\n        InetAddress ip = InetAddress.getLocalHost();\n        NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n        if (network == null) {\n            Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n            while (networks.hasMoreElements()) {\n                NetworkInterface net = networks.nextElement();\n                byte[] mac = net.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                    break;\n                }\n            }\n        } else {\n            byte[] mac = network.getHardwareAddress();\n            if (mac != null) {\n                for (int i = 0; i < mac.length; i++) {\n                    sb.append(String.format(\"%02X\", mac[i]));\n                }\n            }\n        }\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n        StringBuilder fingerprint = new StringBuilder();\n        for (byte b : hash) {\n            fingerprint.append(String.format(\"%02x\", b));\n        }\n        return fingerprint.toString();\n    } catch (Exception e) {\n        return \"GenericID\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "309", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n    String title = pdfMetadata.getTitle();\n    pdf.getDocumentInformation().setTitle(title);\n    pdf.getDocumentInformation().setProducer(this.stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n    String author = pdfMetadata.getAuthor();\n    if (this.applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata()\n        && this.runningProOrHigher) {\n        author = this.applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n        if (this.userService != null) {\n            author = author.replace(\"username\", this.userService.getCurrentUsername());\n        }\n    }\n    pdf.getDocumentInformation().setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "310", "src_id": "M128", "code": "\n@Bean(name = \"machineType\")\npublic String determineMachineType() {\n    try {\n        boolean isDocker = runningInDocker();\n        boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n        boolean isBrowserOpen = \"true\".equalsIgnoreCase(this.env.getProperty(\"BROWSER_OPEN\"));\n        if (isKubernetes) {\n            return \"Kubernetes\";\n        } else if (isDocker) {\n            return \"Docker\";\n        } else if (isBrowserOpen) {\n            String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n            if (os.contains(\"win\")) {\n                return \"Client-windows\";\n            } else if (os.contains(\"mac\")) {\n                return \"Client-mac\";\n            } else {\n                return \"Client-unix\";\n            }\n        } else {\n            return \"Server-jar\";\n        }\n    } catch (Exception e) {\n        return \"Unknown\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "311", "src_id": "M101", "code": "\nprivate void processRequest(\n        int limitPerDay,\n        String identifier,\n        Map<String, Bucket> buckets,\n        HttpServletRequest request,\n        HttpServletResponse response,\n        FilterChain filterChain)\n        throws IOException, ServletException {\n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n        filterChain.doFilter(request, response);\n    } else {\n        long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n        response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n        response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "312", "src_id": "M475", "code": "\n    @Override\n    public void draw(CommandProcess process, JvmModel result) {\n        final TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n\n        for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n            final String group = entry.getKey();\n            final List<JvmItemVO> items = entry.getValue();\n\n            table.row(true, label(group).style(Decoration.bold.bold()));\n            for (JvmItemVO item : items) {\n                final String valueStr;\n                if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                    valueStr = renderMemoryUsage((Map<String, Object>) item.getValue());\n                } else {\n                    valueStr = renderItemValue(item.getValue());\n                }\n                if (item.getDesc() != null) {\n                    table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n                } else {\n                    table.row(item.getName(), valueStr);\n                }\n            }\n            table.row(\"\", \"\");\n        }\n\n        process.write(RenderUtil.render(table, process.width()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "313", "src_id": "M535", "code": "\n    public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n        final StringBuilder infoSB = new StringBuilder();\n        final List<String> classDumpFiles = affectVO.getClassDumpFiles();\n        if (classDumpFiles != null) {\n            for (String classDumpFile : classDumpFiles) {\n                infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n            }\n        }\n\n        final List<String> methods = affectVO.getMethods();\n        if (methods != null) {\n            for (String method : methods) {\n                infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n            }\n        }\n\n        infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\",\n                affectVO.getClassCount(),\n                affectVO.getMethodCount(),\n                affectVO.getCost(),\n                affectVO.getListenerId()));\n        if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n            infoSB.append('\\n').append(affectVO.getOverLimitMsg());\n        }\n        if (affectVO.getThrowable() != null) {\n            infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n        }\n        infoSB.append('\\n');\n\n        return infoSB.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "314", "src_id": "M753", "code": "\n    public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n        final List<ThreadVO> threads = new ArrayList<>(originThreads);\n\n        if (lastCpuTimes.isEmpty()) {\n            lastSampleTimeNanos = System.nanoTime();\n            for (ThreadVO thread : threads) {\n                if (thread.getId() > 0) {\n                    final long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                    lastCpuTimes.put(thread, cpu);\n                    thread.setTime(cpu / 1000000);\n                }\n            }\n\n            final Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n            if (internalThreadCpuTimes != null) {\n                for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                    final ThreadVO thread = createThreadVO(entry.getKey());\n                    thread.setTime(entry.getValue() / 1000000);\n                    threads.add(thread);\n                    lastCpuTimes.put(thread, entry.getValue());\n                }\n            }\n\n            Collections.sort(threads, new Comparator<ThreadVO>() {\n                @Override\n                public int compare(ThreadVO o1, ThreadVO o2) {\n                    final long l1 = o1.getTime();\n                    final long l2 = o2.getTime();\n                    if (l1 < l2) return 1;\n                    if (l1 > l2) return -1;\n                    return 0;\n                }\n            });\n            return threads;\n        }\n\n        final long newSampleTimeNanos = System.nanoTime();\n        final Map<ThreadVO, Long> newCpuTimes = new HashMap<>(threads.size());\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                final long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                newCpuTimes.put(thread, cpu);\n            }\n        }\n\n        final Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (newInternalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n                final ThreadVO threadVO = createThreadVO(entry.getKey());\n                threads.add(threadVO);\n                newCpuTimes.put(threadVO, entry.getValue());\n            }\n        }\n\n        final Map<ThreadVO, Long> deltas = new HashMap<>(threads.size());\n        for (ThreadVO thread : newCpuTimes.keySet()) {\n            Long t = lastCpuTimes.get(thread);\n            if (t == null) t = 0L;\n            final long time1 = t;\n            final long time2 = newCpuTimes.get(thread);\n            final long delta = time2 - time1;\n            deltas.put(thread, delta);\n        }\n\n        final long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n        final Map<ThreadVO, Double> cpuUsages = new HashMap<>(threads.size());\n        for (ThreadVO thread : threads) {\n            final double cpu = sampleIntervalNanos == 0 ? 0 : \n                (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0;\n            cpuUsages.put(thread, cpu);\n        }\n\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n            @Override\n            public int compare(ThreadVO o1, ThreadVO o2) {\n                final long l1 = deltas.get(o1);\n                final long l2 = deltas.get(o2);\n                if (l1 < l2) return 1;\n                if (l1 > l2) return -1;\n                return 0;\n            }\n        });\n\n        for (ThreadVO thread : threads) {\n            final long timeMills = newCpuTimes.get(thread) / 1000000;\n            final long deltaTime = deltas.get(thread) / 1000000;\n            final double cpu = cpuUsages.get(thread);\n            thread.setCpu(cpu);\n            thread.setTime(timeMills);\n            thread.setDeltaTime(deltaTime);\n        }\n        lastCpuTimes = newCpuTimes;\n        lastSampleTimeNanos = newSampleTimeNanos;\n\n        return threads;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "315", "src_id": "M1131", "code": "\n    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n        final String commandLine = apiRequest.getCommand();\n        final Map<String, Object> body = new TreeMap<>();\n        body.put(\"command\", commandLine);\n\n        final ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n        final int lock = session.getLock();\n        try {\n            final Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n\n            final Job job = createJob(commandLine, session, session.getResultDistributor());\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            response.setState(ApiState.SCHEDULED);\n\n            final CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n            commandRequestModel.setJobId(job.id());\n            final SharingResultDistributor resultDistributor = session.getResultDistributor();\n            if (resultDistributor != null) {\n                resultDistributor.appendResult(commandRequestModel);\n            }\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n            job.run();\n            return response;\n        } catch (Throwable e) {\n            logger.error(\"Async exec command failed: {}, command: {}\", e.getMessage(), commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Async exec command failed: \" + e.getMessage());\n            final CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n            session.getResultDistributor().appendResult(commandRequestModel);\n            return response;\n        } finally {\n            if (session.getLock() == lock) {\n                session.unLock();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "316", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        final StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            final Map<String, Object> info = entry.getValue();\n            final TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            final TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n            final Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity)))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            final List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    final Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)))\n                        .row(label(LoggerHelper.clazz), label(appenderClass.getName()))\n                        .row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)))\n                        .row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "317", "src_id": "M15", "code": "\n    public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n        final URLClassLoader classLoader = new URLClassLoader(\n            new URL[]{new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n        final Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n        final Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n\n        final PrintStream originSysOut = System.out;\n        final PrintStream originSysErr = System.err;\n        final PrintStream newOut = new PrintStream(out);\n        final PrintStream newErr = new PrintStream(out);\n\n        final ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            System.setOut(newOut);\n            System.setErr(newErr);\n            Thread.currentThread().setContextClassLoader(classLoader);\n            return (Integer) processMethod.invoke(null, new Object[]{telnetArgs.toArray(new String[0])});\n        } catch (Throwable e) {\n            final Throwable cause = e.getCause();\n            if (cause instanceof IOException || cause instanceof InterruptedException) {\n                return STATUS_ERROR;\n            } else {\n                AnsiLog.error(\"process error: {}\", cause.toString());\n                AnsiLog.error(cause);\n                return STATUS_EXEC_ERROR;\n            }\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n            System.setOut(originSysOut);\n            System.setErr(originSysErr);\n            newOut.flush();\n            newErr.flush();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "318", "src_id": "M1469", "code": "\n    public static FieldVO[] getFields(Class clazz, Integer expand) {\n        final Field[] fields = clazz.getDeclaredFields();\n        if (fields.length == 0) {\n            return new FieldVO[0];\n        }\n\n        final List<FieldVO> list = new ArrayList<>(fields.length);\n        for (Field field : fields) {\n            final FieldVO fieldVO = new FieldVO();\n            fieldVO.setName(field.getName());\n            fieldVO.setType(StringUtils.classname(field.getType()));\n            fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n            fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n            if (Modifier.isStatic(field.getModifiers())) {\n                fieldVO.setStatic(true);\n                fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n            } else {\n                fieldVO.setStatic(false);\n            }\n            list.add(fieldVO);\n        }\n        return list.toArray(new FieldVO[0]);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "319", "src_id": "M270", "code": "\nprivate static String normalizeArch(String value) {\n  value = normalize(value);\n  if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n    return \"x86_64\";\n  }\n  if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n    return \"x86_32\";\n  }\n  if (value.matches(\"^(ia64w?|itanium64)$\")) {\n    return \"itanium_64\";\n  }\n  if (\"ia64n\".equals(value)) {\n    return \"itanium_32\";\n  }\n  if (value.matches(\"^(sparc|sparc32)$\")) {\n    return \"sparc_32\";\n  }\n  if (value.matches(\"^(sparcv9|sparc64)$\")) {\n    return \"sparc_64\";\n  }\n  if (value.matches(\"^(arm|arm32)$\")) {\n    return \"arm_32\";\n  }\n  if (\"aarch64\".equals(value)) {\n    return \"aarch_64\";\n  }\n  if (value.matches(\"^(mips|mips32)$\")) {\n    return \"mips_32\";\n  }\n  if (value.matches(\"^(mipsel|mips32el)$\")) {\n    return \"mipsel_32\";\n  }\n  if (\"mips64\".equals(value)) {\n    return \"mips_64\";\n  }\n  if (\"mips64el\".equals(value)) {\n    return \"mipsel_64\";\n  }\n  if (value.matches(\"^(ppc|ppc32)$\")) {\n    return \"ppc_32\";\n  }\n  if (value.matches(\"^(ppcle|ppc32le)$\")) {\n    return \"ppcle_32\";\n  }\n  if (\"ppc64\".equals(value)) {\n    return \"ppc_64\";\n  }\n  if (\"ppc64le\".equals(value)) {\n    return \"ppcle_64\";\n  }\n  if (\"s390\".equals(value)) {\n    return \"s390_32\";\n  }\n  if (\"s390x\".equals(value)) {\n    return \"s390_64\";\n  }\n  return value;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "320", "src_id": "M928", "code": "\nprivate static Map<String, Object> doGetLoggerInfo(Logger logger) {\n  final Map<String, Object> info = new HashMap<>();\n  info.put(LoggerHelper.name, logger.getName());\n  info.put(LoggerHelper.clazz, logger.getClass());\n  final CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n  if (codeSource != null) {\n    info.put(LoggerHelper.codeSource, codeSource.getLocation());\n  }\n  info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n  final Level level = logger.getLevel();\n  final Level effectiveLevel = logger.getEffectiveLevel();\n  if (level != null) {\n    info.put(LoggerHelper.level, level.toString());\n  }\n  if (effectiveLevel != null) {\n    info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  final List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n  info.put(LoggerHelper.appenders, result);\n  return info;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "321", "src_id": "M9", "code": "\n@SuppressWarnings(\"resource\")\npublic static long select(boolean v, long telnetPortPid, String select) throws InputMismatchException {\n  Map<Long, String> processMap = listProcessByJps(v);\n  if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n    final String telnetPortProcess = processMap.get(telnetPortPid);\n    processMap.remove(telnetPortPid);\n    final Map<Long, String> newProcessMap = new LinkedHashMap<>();\n    newProcessMap.put(telnetPortPid, telnetPortProcess);\n    newProcessMap.putAll(processMap);\n    processMap = newProcessMap;\n  }\n\n  if (processMap.isEmpty()) {\n    AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n    return -1;\n  }\n\n  if (select != null && !select.trim().isEmpty()) {\n    int matchedSelectCount = 0;\n    Long matchedPid = null;\n    for (Entry<Long, String> entry : processMap.entrySet()) {\n      if (entry.getValue().contains(select)) {\n        matchedSelectCount++;\n        matchedPid = entry.getKey();\n      }\n    }\n    if (matchedSelectCount == 1) {\n      return matchedPid;\n    }\n  }\n\n  AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n  int count = 1;\n  for (String process : processMap.values()) {\n    if (count == 1) {\n      System.out.println(\"* [\" + count + \"]: \" + process);\n    } else {\n      System.out.println(\"  [\" + count + \"]: \" + process);\n    }\n    count++;\n  }\n\n  final String line = new Scanner(System.in).nextLine();\n  if (line.trim().isEmpty()) {\n    return processMap.keySet().iterator().next();\n  }\n\n  final int choice = new Scanner(line).nextInt();\n  if (choice <= 0 || choice > processMap.size()) {\n    return -1;\n  }\n\n  final Iterator<Long> idIter = processMap.keySet().iterator();\n  for (int i = 1; i <= choice; ++i) {\n    if (i == choice) {\n      return idIter.next();\n    }\n    idIter.next();\n  }\n  return -1;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "322", "src_id": "M140", "code": "\nvoid _processDo(int option) throws IOException {\n  if (debugoptions) {\n    System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n  }\n\n  if (__notifhand != null) {\n    __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n  }\n\n  boolean acceptNewState = false;\n  if (optionHandlers[option] != null) {\n    acceptNewState = optionHandlers[option].getAcceptLocal();\n  } else if (option == TERMINAL_TYPE) {\n    if (terminalType != null && terminalType.length() > 0) {\n      acceptNewState = true;\n    }\n  }\n\n  if (_willResponse[option] > 0) {\n    --_willResponse[option];\n    if (_willResponse[option] > 0 && _stateIsWill(option)) {\n      --_willResponse[option];\n    }\n  }\n\n  if (_willResponse[option] == 0) {\n    if (_requestedWont(option)) {\n      if (acceptNewState) {\n        _setWantWill(option);\n        _sendWill(option);\n      } else {\n        ++_willResponse[option];\n        _sendWont(option);\n      }\n    }\n  }\n  _setWill(option);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "323", "src_id": "M1324", "code": "\nprivate void bind(Configure configure) throws Throwable {\n  final long start = System.currentTimeMillis();\n  if (!isBindRef.compareAndSet(false, true)) {\n    throw new IllegalStateException(\"already bind\");\n  }\n\n  if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n    final int newTelnetPort = SocketUtils.findAvailableTcpPort();\n    configure.setTelnetPort(newTelnetPort);\n    logger().info(\"generate random telnet port: %d\", newTelnetPort);\n  }\n  if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n    final int newHttpPort = SocketUtils.findAvailableTcpPort();\n    configure.setHttpPort(newHttpPort);\n    logger().info(\"generate random http port: %d\", newHttpPort);\n  }\n  \n  if (configure.getAppName() == null) {\n    configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, \n        System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n  }\n\n  try {\n    if (configure.getTunnelServer() != null) {\n      tunnelClient = new TunnelClient();\n      tunnelClient.setAppName(configure.getAppName());\n      tunnelClient.setId(configure.getAgentId());\n      tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n      tunnelClient.setVersion(ArthasBanner.version());\n      final ChannelFuture channelFuture = tunnelClient.start();\n      channelFuture.await(10, TimeUnit.SECONDS);\n    }\n  } catch (Throwable t) {\n    logger().error(\"start tunnel client error\", t);\n  }\n\n  try {\n    final ShellServerOptions options = new ShellServerOptions()\n        .setInstrumentation(instrumentation)\n        .setPid(PidUtils.currentLongPid())\n        .setWelcomeMessage(ArthasBanner.welcome());\n    \n    if (configure.getSessionTimeout() != null) {\n      options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n    }\n\n    this.httpSessionManager = new HttpSessionManager();\n    if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n      final String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \"\n          + \"No password is currently configured. Therefore, a default password is generated, \"\n          + \"and clients need to use the password to connect!\";\n      AnsiLog.error(errorMsg);\n      configure.setPassword(StringUtils.randomString(64));\n      AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n      logger().error(errorMsg);\n      logger().info(\"Generated arthas password: \" + configure.getPassword());\n    }\n\n    this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n    shellServer = new ShellServerImpl(options);\n\n    final List<String> disabledCommands = new ArrayList<>();\n    if (configure.getDisabledCommands() != null) {\n      final String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n      if (strings != null) {\n        disabledCommands.addAll(Arrays.asList(strings));\n      }\n    }\n    \n    final BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n    final List<CommandResolver> resolvers = new ArrayList<>();\n    resolvers.add(builtinCommands);\n\n    workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n    if (configure.getTelnetPort() != null && configure.getTelnetPort() > 0) {\n      logger().info(\"try to bind telnet server, host: %s, port: %d.\", configure.getIp(), configure.getTelnetPort());\n      shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(),\n          options.getConnectionTimeout(), workerGroup, httpSessionManager));\n    } else {\n      logger().info(\"telnet port is %s, skip bind telnet server.\", configure.getTelnetPort());\n    }\n    \n    if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n      logger().info(\"try to bind http server, host: %s, port: %d.\", configure.getIp(), configure.getHttpPort());\n      shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(),\n          options.getConnectionTimeout(), workerGroup, httpSessionManager));\n    } else if (configure.getTunnelServer() != null) {\n      shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(),\n          options.getConnectionTimeout(), workerGroup, httpSessionManager));\n      logger().info(\"http port is %s, skip bind http server.\", configure.getHttpPort());\n    }\n\n    for (CommandResolver resolver : resolvers) {\n      shellServer.registerCommandResolver(resolver);\n    }\n\n    shellServer.listen(new BindHandler(isBindRef));\n    if (!isBind()) {\n      throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" \n          + configure.getTelnetPort() + \", http port: \" + configure.getHttpPort());\n    }\n\n    sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n    httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n\n    logger().info(\"as-server listening on network=%s;telnet=%d;http=%d;timeout=%d;\", \n        configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n    if (configure.getStatUrl() != null) {\n      logger().info(\"arthas stat url: %s\", configure.getStatUrl());\n    }\n    UserStatUtil.setStatUrl(configure.getStatUrl());\n    UserStatUtil.setAgentId(configure.getAgentId());\n    UserStatUtil.arthasStart();\n\n    try {\n      SpyAPI.init();\n    } catch (Throwable e) {\n      // ignore\n    }\n\n    logger().info(\"as-server started in %d ms\", System.currentTimeMillis() - start);\n  } catch (Throwable e) {\n    logger().error(\"Error during start as-server\", e);\n    destroy();\n    throw e;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "324", "src_id": "M122", "code": "\nprivate int __read(boolean mayBlock) throws IOException {\n  int ch;\n  while (true) {\n    if (!mayBlock && super.available() == 0) {\n      return WOULD_BLOCK;\n    }\n\n    if ((ch = super.read()) < 0) {\n      return EOF;\n    }\n\n    ch = (ch & 0xff);\n    synchronized (__client) {\n      __client._processAYTResponse();\n    }\n    __client._spyRead(ch);\n\n    switch (__receiveState) {\n      case _STATE_CR:\n        if (ch == '\\0') {\n          continue;\n        }\n      case _STATE_DATA:\n        if (ch == TelnetCommand.IAC) {\n          __receiveState = _STATE_IAC;\n          continue;\n        }\n        if (ch == '\\r') {\n          synchronized (__client) {\n            __receiveState = __client._requestedDont(TelnetOption.BINARY) ? _STATE_CR : _STATE_DATA;\n          }\n        } else {\n          __receiveState = _STATE_DATA;\n        }\n        break;\n      case _STATE_IAC:\n        switch (ch) {\n          case TelnetCommand.WILL:\n            __receiveState = _STATE_WILL;\n            continue;\n          case TelnetCommand.WONT:\n            __receiveState = _STATE_WONT;\n            continue;\n          case TelnetCommand.DO:\n            __receiveState = _STATE_DO;\n            continue;\n          case TelnetCommand.DONT:\n            __receiveState = _STATE_DONT;\n            continue;\n          case TelnetCommand.SB:\n            __suboption_count = 0;\n            __receiveState = _STATE_SB;\n            continue;\n          case TelnetCommand.IAC:\n            __receiveState = _STATE_DATA;\n            break;\n          case TelnetCommand.SE:\n            __receiveState = _STATE_DATA;\n            continue;\n          default:\n            __receiveState = _STATE_DATA;\n            __client._processCommand(ch);\n            continue;\n        }\n        break;\n      case _STATE_WILL:\n        synchronized (__client) {\n          __client._processWill(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_WONT:\n        synchronized (__client) {\n          __client._processWont(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_DO:\n        synchronized (__client) {\n          __client._processDo(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_DONT:\n        synchronized (__client) {\n          __client._processDont(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_SB:\n        switch (ch) {\n          case TelnetCommand.IAC:\n            __receiveState = _STATE_IAC_SB;\n            continue;\n          default:\n            if (__suboption_count < __suboption.length) {\n              __suboption[__suboption_count++] = ch;\n            }\n            break;\n        }\n        __receiveState = _STATE_SB;\n        continue;\n      case _STATE_IAC_SB:\n        switch (ch) {\n          case TelnetCommand.SE:\n            synchronized (__client) {\n              __client._processSuboption(__suboption, __suboption_count);\n              __client._flushOutputStream();\n            }\n            __receiveState = _STATE_DATA;\n            continue;\n          case TelnetCommand.IAC:\n            if (__suboption_count < __suboption.length) {\n              __suboption[__suboption_count++] = ch;\n            }\n            break;\n        }\n        __receiveState = _STATE_SB;\n        continue;\n    }\n    break;\n  }\n  return ch;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "325", "src_id": "M8", "code": "\nprivate static String formatFileSize(long size) {\n  final double b = size;\n  final double k = size / 1024.0;\n  final double m = k / 1024.0;\n  final double g = m / 1024.0;\n  final double t = g / 1024.0;\n\n  final DecimalFormat dec = new DecimalFormat(\"0.00\");\n  if (t > 1) {\n    return dec.format(t).concat(\" TB\");\n  }\n  if (g > 1) {\n    return dec.format(g).concat(\" GB\");\n  }\n  if (m > 1) {\n    return dec.format(m).concat(\" MB\");\n  }\n  if (k > 1) {\n    return dec.format(k).concat(\" KB\");\n  }\n  return dec.format(b).concat(\" Bytes\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "326", "src_id": "M790", "code": "\n@Override\npublic byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n    ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n    \n  if (className == null) {\n    return null;\n  }\n\n  className = className.replace('/', '.');\n  final List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n  final ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n  \n  while (listIterator.hasPrevious()) {\n    final RetransformEntry retransformEntry = listIterator.previous();\n    final int id = retransformEntry.getId();\n    boolean updateFlag = false;\n    \n    if (className.equals(retransformEntry.getClassName())) {\n      if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) {\n        updateFlag = isLoaderMatch(retransformEntry, loader);\n      } else {\n        updateFlag = true;\n      }\n    }\n\n    if (updateFlag) {\n      logger.info(\"RetransformCommand match class: %s, id: %d, classLoaderClass: %s, hashCode: %d\",\n          className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n      retransformEntry.incTransformCount();\n      return retransformEntry.getBytes();\n    }\n  }\n  return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "327", "src_id": "M716", "code": "\npublic static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n  table.row(\"IS-RETURN\", \"false\");\n  table.row(\"IS-EXCEPTION\", \"true\");\n\n  Throwable cause;\n  final Throwable t = (Throwable) throwableVO.getObject();\n  if (t instanceof InvocationTargetException) {\n    cause = t.getCause();\n  } else {\n    cause = t;\n  }\n\n  if (throwableVO.needExpand()) {\n    table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n  } else {\n    try (StringWriter stringWriter = new StringWriter();\n         PrintWriter printWriter = new PrintWriter(stringWriter)) {\n      cause.printStackTrace(printWriter);\n      table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "328", "src_id": "M602", "code": "\nprivate AsyncProfiler profilerInstance() {\n  if (profiler != null) {\n    return profiler;\n  }\n\n  if (ProfilerAction.load.toString().equals(action)) {\n    profiler = AsyncProfiler.getInstance(this.actionArg);\n  }\n\n  if (libPath != null) {\n    try (FileOutputStream tmpLibOutputStream = null;\n         FileInputStream libInputStream = new FileInputStream(libPath)) {\n      final File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n      tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n      IOUtils.copy(libInputStream, tmpLibOutputStream);\n      libPath = tmpLibFile.getAbsolutePath();\n      logger.debug(\"copy %s to %s\", libPath, tmpLibFile);\n    } catch (Throwable e) {\n      logger.error(\"try to copy lib error! libPath: %s\", libPath, e);\n    }\n    profiler = AsyncProfiler.getInstance(libPath);\n  } else {\n    if (OSUtils.isLinux() || OSUtils.isMac()) {\n      throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n    }\n    throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n  }\n  return profiler;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "329", "src_id": "M1086", "code": "\npublic static AdminServer createAdminServer() {\n    if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n        try {\n            Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n            Object adminServer = jettyAdminServerC.getConstructor().newInstance();\n            return (AdminServer) adminServer;\n        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | \n                 InvocationTargetException | NoSuchMethodException e) {\n            LOG.warn(\"Unable to start JettyAdminServer\", e);\n        } catch (NoClassDefFoundError e) {\n            LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n        }\n    }\n    return new DummyAdminServer();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "330", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException | Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        for (SelectionKey key : selector.keys()) {\n            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        \n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "331", "src_id": "M219", "code": "\nsynchronized public static ZooKeeper getClient(final String contextPath,\n        final String session, final int expireTime) throws IOException {\n    \n    final String connectionId = concat(contextPath, session);\n    ZooKeeper zk = zkMap.get(connectionId);\n    \n    if (zk == null) {\n        if (LOG.isInfoEnabled()) {\n            LOG.info(\"creating new connection for : '{}'\", connectionId);\n        }\n        \n        final Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n        \n        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n        }\n        \n        zkMap.put(connectionId, zk);\n\n        if (session != null) {\n            zkSessionTimers.put(connectionId, \n                new SessionTimerTask(expireTime, session, contextPath, timer));\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "332", "src_id": "M192", "code": "\nprivate void init() throws IOException {\n    final File f = new File(file);\n    try (RandomAccessFileReader in = new RandomAccessFileReader(f)) {\n        final SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        final Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n\n        String lastentry = line;\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n                    lastentry = line;\n                } \n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n            // Ignore EOF\n        }\n        \n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "333", "src_id": "M235", "code": "\n@POST\n@Produces({MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML})\npublic Response createSession(@QueryParam(\"op\") final String op,\n        @DefaultValue(\"5\") @QueryParam(\"expire\") final String expire,\n        @Context final UriInfo ui) {\n    \n    if (!\"create\".equals(op)) {\n        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n            .entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n    }\n\n    final int expireInSeconds;\n    try {\n        expireInSeconds = Integer.parseInt(expire);\n    } catch (NumberFormatException e) {\n        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n    }\n\n    String uuid = UUID.randomUUID().toString();\n    while (ZooKeeperService.isConnected(contextPath, uuid)) {\n        uuid = UUID.randomUUID().toString();\n    }\n\n    try {\n        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n    } catch (IOException e) {\n        LOG.error(\"Failed while trying to create a new session\", e);\n        throw new WebApplicationException(\n            Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n    }\n\n    final URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n    return Response.created(uri)\n        .entity(new JSONWithPadding(new ZSession(uuid, uri.toString())))\n        .build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "334", "src_id": "M942", "code": "\npublic void schedule(final WorkRequest workRequest, final long id) {\n    if (stopped) {\n        workRequest.cleanup();\n        return;\n    }\n\n    final ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n    final int size = workers.size();\n\n    if (size > 0) {\n        try {\n            final int workerNum = ((int) (id % size) + size) % size;\n            final ExecutorService worker = workers.get(workerNum);\n            worker.execute(scheduledWorkRequest);\n        } catch (RejectedExecutionException e) {\n            LOG.warn(\"ExecutorService rejected execution\", e);\n            workRequest.cleanup();\n        }\n    } else {\n        scheduledWorkRequest.run();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "335", "src_id": "M520", "code": "\n@Override\npublic void close() throws IOException {\n    boolean triedToClose = false;\n    boolean success = false;\n    \n    try {\n        flush();\n        ((FileOutputStream) out).getFD().sync();\n        triedToClose = true;\n        super.close();\n        success = true;\n    } finally {\n        if (success) {\n            if (!tmpFile.renameTo(origFile) && \n                (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n            }\n        } else {\n            if (!triedToClose) {\n                IOUtils.closeStream(out);\n            }\n            if (!tmpFile.delete()) {\n                LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "336", "src_id": "M186", "code": "\nsynchronized private LogEntry readNextEntry() {\n    try {\n        while (true) {\n            final String line = in.readLine();\n            if (line == null) {\n                break;\n            }\n\n            final Matcher m = src.timep.matcher(line);\n            if (m.lookingAt()) {\n                if (buf.length() > 0) {\n                    final LogEntry e = new Log4JEntry(\n                        src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                    buf = line;\n                    return e;\n                }\n                buf = line;\n            } else if (buf.length() > 0) {\n                buf += line + \"\\n\";\n            }\n        }\n        \n        if (buf.length() > 0) {\n            final LogEntry e = new Log4JEntry(\n                src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n            buf = \"\";\n            return e;\n        }\n    } catch (EOFException eof) {\n        // Ignore EOF\n    } catch (Exception e) {\n        LOG.error(\"Error reading next entry in file ({}): {}\", src.file, e);\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "337", "src_id": "M478", "code": "\npublic static void main(final String[] args) {\n    if (args.length < 3) {\n        usage();\n        return;\n    }\n    \n    final String host = args[0];\n    final int port = Integer.parseInt(args[1]);\n    final String op = args[2];\n    \n    switch (op.toLowerCase()) {\n        case \"gettracemask\":\n            getTraceMask(host, port);\n            break;\n        case \"settracemask\":\n            setTraceMask(host, port, args[3]);\n            break;\n        case \"ruok\":\n            ruok(host, port);\n            break;\n        case \"kill\":\n            kill(host, port);\n            break;\n        case \"stat\":\n            stat(host, port);\n            break;\n        case \"dump\":\n            dump(host, port);\n            break;\n        default:\n            System.out.println(\"Unrecognized op: \" + op);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "338", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        final Thread currentThread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            currentThread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception caughtException = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception error) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), error);\n\n            boolean isInterruption = \n                error instanceof InterruptedIOException \n                || error instanceof ClosedByInterruptException \n                || currentThread.isInterrupted();\n\n            if (isInterruption) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            caughtException = error;\n        } finally {\n            int status = (errCode == ERROR_NOTHING) ? 2 : 0;\n            notifyPostProcessing(status);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            Exception exceptionToNotify = (caughtException != null) ? caughtException : errObject;\n            notifyError(ERROR_POSTPROCESSING, exceptionToNotify);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "339", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // let the download thread handle this error\n            default:\n                boolean isSuccessStatus = statusCode >= 200 && statusCode <= 299;\n                if (!isSuccessStatus) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "340", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n\n        boolean version1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n\n        int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n\n        if (version1) {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remaining entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        }\n\n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "341", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        boolean completedSuccessfully = false;\n        long startOffset = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && startOffset > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + startOffset);\n        }\n\n        try {\n            long rangeStart = (mMission.unknownLength || startOffset < 1) ? -1 : startOffset;\n            int threadId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(threadId, mConn);\n\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && startOffset > 0) {\n                mMission.notifyProgress(-startOffset);\n                startOffset = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + startOffset);\n\n            mIs = mConn.getInputStream();\n            byte[] buffer = new byte[DownloadMission.BUFFER_SIZE];\n            int bytesRead = 0;\n\n            while (mMission.running && (bytesRead = mIs.read(buffer, 0, buffer.length)) != -1) {\n                mF.write(buffer, 0, bytesRead);\n                startOffset += bytesRead;\n                mMission.notifyProgress(bytesRead);\n            }\n\n            dispose();\n            completedSuccessfully = bytesRead == -1;\n        } catch (Exception error) {\n            dispose();\n            mMission.fallbackResumeOffset = startOffset;\n\n            if (!mMission.running || error instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            if (error instanceof HttpError && ((HttpError) error).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(error);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", error);\n            }\n\n            run(); // try again\n            return;\n        }\n\n        if (completedSuccessfully) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = startOffset;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "342", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n\n        out.flush();\n        aux.flush();\n\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        byte[] copyBuffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long remainingBytes = amount;\n        while (remainingBytes > 0) {\n            int readAmount = (int) Math.min(remainingBytes, Integer.MAX_VALUE);\n            readAmount = Math.min(readAmount, copyBuffer.length);\n            int bytesRead = aux.target.read(copyBuffer, 0, readAmount);\n\n            if (bytesRead < 1) {\n                amount -= remainingBytes;\n                break;\n            }\n\n            out.writeProof(copyBuffer, bytesRead);\n            remainingBytes -= bytesRead;\n        }\n\n        if (underflow) {\n            if (out.offset >= out.length) {\n                if (aux.offset < amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        } else {\n            out.offset += amount;\n            aux.offset -= amount;\n        }\n\n        out.length += amount;\n\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n            aux.length -= amount;\n            remainingBytes = aux.length;\n\n            while (remainingBytes > 0) {\n                int readAmount = (int) Math.min(remainingBytes, Integer.MAX_VALUE);\n                readAmount = Math.min(readAmount, copyBuffer.length);\n                aux.target.seek(readOffset);\n                int bytesRead = aux.target.read(copyBuffer, 0, readAmount);\n\n                aux.target.seek(writeOffset);\n                aux.writeProof(copyBuffer, bytesRead);\n\n                writeOffset += bytesRead;\n                readOffset += bytesRead;\n                remainingBytes -= bytesRead;\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);\n        }\n\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "343", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder requestBuilder = new StringBuilder(256);\n        requestBuilder.append(mission.source).append(\" [\");\n        \n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n                requestBuilder.append(' ')\n                    .append(recovery.toString())\n                    .append(' ');\n            }\n        }\n        requestBuilder.append(\"]\");\n\n        String serviceName;\n        try {\n            serviceName = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            serviceName = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(\n            mContext,\n            new ErrorInfo(\n                ErrorInfo.Companion.throwableToStringList(mission.errObject),\n                action,\n                serviceName,\n                requestBuilder.toString(),\n                reason\n            )\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "344", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cannot create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n\n            boolean shouldStart = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n            if (canDownloadInCurrentNetwork() && shouldStart) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "345", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = \"true\".equals(getArgumentAt(1, \"true\"));\n\n        if (format == null || \"ttml\".equals(format)) {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception error) {\n                Log.e(TAG, \"subtitle parse failed\", error);\n                return (error instanceof IOException) ? 1 : 8;\n            }\n            return OK_RESULT;\n        } else if (\"srt\".equals(format)) {\n            byte[] buffer = new byte[8 * 1024];\n            int bytesRead;\n            while ((bytesRead = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, bytesRead);\n            }\n            return OK_RESULT;\n        }\n\n        throw new UnsupportedOperationException(\n            \"Cannot convert this subtitle, unimplemented format: \" + format\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "346", "src_id": "M1047", "code": "\n    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n            }\n        }\n\n        // Interrupt all active threads except current\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == currentThread) continue;\n            thread.interrupt();\n        }\n\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) continue;\n                if (DEBUG) {\n                    Log.w(TAG, \"Thread alive: \" + thread.getName());\n                }\n                if (millis > 0) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "347", "src_id": "M31", "code": "\nprivate JsonNode validateLicense(\n        String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n    String requestBody = String.format(\n            \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\",\n            licenseKey, machineFingerprint);\n    \n    HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n            .header(\"Content-Type\", \"application/vnd.api+json\")\n            .header(\"Accept\", \"application/vnd.api+json\")\n            .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n            .build();\n\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n    JsonNode jsonResponse = objectMapper.readTree(response.body());\n    \n    if (response.statusCode() != 200) {\n        log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        return jsonResponse;\n    }\n\n    JsonNode metaNode = jsonResponse.path(\"meta\");\n    boolean isValid = metaNode.path(\"valid\").asBoolean();\n    String detail = metaNode.path(\"detail\").asText();\n    String code = metaNode.path(\"code\").asText();\n\n    log.info(\"License validity: {}\", isValid);\n    log.info(\"Validation detail: {}\", detail);\n    log.info(\"Validation code: {}\", code);\n\n    JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n    if (!licenseAttrs.isMissingNode()) {\n        context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n        context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n        log.info(\"License floating (from license): {}, maxMachines: {}\", \n                context.isFloatingLicense, context.maxMachines);\n    }\n\n    JsonNode includedNode = jsonResponse.path(\"included\");\n    JsonNode policyNode = null;\n    if (includedNode.isArray()) {\n        for (JsonNode node : includedNode) {\n            if (\"policies\".equals(node.path(\"type\").asText())) {\n                policyNode = node;\n                break;\n            }\n        }\n    }\n\n    if (policyNode != null) {\n        boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n        int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n        \n        if (policyFloating) {\n            context.isFloatingLicense = true;\n            context.maxMachines = policyMaxMachines;\n        }\n        log.info(\"License floating (from policy): {}, maxMachines: {}\", \n                context.isFloatingLicense, context.maxMachines);\n    }\n\n    int users = jsonResponse.path(\"data\")\n            .path(\"attributes\")\n            .path(\"metadata\")\n            .path(\"users\")\n            .asInt(1);\n    applicationProperties.getPremium().setMaxUsers(users);\n\n    context.isEnterpriseLicense = jsonResponse.path(\"data\")\n            .path(\"attributes\")\n            .path(\"metadata\")\n            .path(\"isEnterprise\")\n            .asBoolean(false);\n\n    log.debug(applicationProperties.toString());\n    return jsonResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "348", "src_id": "M488", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n@Operation(\n        summary = \"Convert a file to a PDF using LibreOffice\",\n        description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile) throws Exception {\n    MultipartFile inputFile = generalFile.getFileInput();\n    File file = null;\n    try {\n        file = convertToPdf(inputFile);\n        PDDocument doc = pdfDocumentFactory.load(file);\n        return WebResponseUtils.pdfDocToWebResponse(\n                doc,\n                Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                        .replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n    } finally {\n        if (file != null) {\n            file.delete();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "349", "src_id": "M625", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\npublic ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n    try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, true)) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n        // Metadata\n        PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n        ObjectNode metadata = objectMapper.createObjectNode();\n        metadata.put(\"Title\", info.getTitle());\n        metadata.put(\"Author\", info.getAuthor());\n        metadata.put(\"Subject\", info.getSubject());\n        metadata.put(\"Keywords\", info.getKeywords());\n        metadata.put(\"Producer\", info.getProducer());\n        metadata.put(\"Creator\", info.getCreator());\n        metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n        metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n        jsonOutput.set(\"Metadata\", metadata);\n\n        // Basic info\n        ObjectNode basicInfo = objectMapper.createObjectNode();\n        basicInfo.put(\"FileSizeInBytes\", inputFile.getSize());\n        \n        String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n        basicInfo.put(\"WordCount\", fullText.split(\"\\\\s+\").length);\n        basicInfo.put(\"ParagraphCount\", fullText.split(\"\\r\\n|\\r|\\n\").length);\n        basicInfo.put(\"CharacterCount\", fullText.length());\n        basicInfo.put(\"Compression\", false);\n        basicInfo.put(\"Language\", pdfBoxDoc.getDocumentCatalog().getLanguage());\n        basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n        jsonOutput.set(\"BasicInfo\", basicInfo);\n\n        // Document info\n        ObjectNode docInfoNode = objectMapper.createObjectNode();\n        docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n        docInfoNode.put(\"Trapped\", info.getTrapped());\n        docInfoNode.put(\"Page Mode\", getPageModeDescription(\n                pdfBoxDoc.getDocumentCatalog().getPageMode().name()));\n        jsonOutput.set(\"DocumentInfo\", docInfoNode);\n\n        // Form fields\n        PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n        ObjectNode formFieldsNode = objectMapper.createObjectNode();\n        if (acroForm != null) {\n            for (PDField field : acroForm.getFieldTree()) {\n                formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n            }\n        }\n        jsonOutput.set(\"FormFields\", formFieldsNode);\n\n        // Additional sections (simplified for brevity)\n        jsonOutput.set(\"SummaryData\", generatePDFSummaryData(pdfBoxDoc));\n        jsonOutput.set(\"Compliancy\", buildCompliancyInfo(pdfBoxDoc));\n        jsonOutput.set(\"Encryption\", buildEncryptionInfo(pdfBoxDoc));\n        jsonOutput.set(\"Permissions\", buildPermissionsInfo(pdfBoxDoc));\n        jsonOutput.set(\"Other\", buildOtherInfo(pdfBoxDoc, objectMapper));\n        jsonOutput.set(\"PerPageInfo\", buildPageInfo(pdfBoxDoc, objectMapper));\n\n        String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n        return WebResponseUtils.bytesToWebResponse(\n                jsonString.getBytes(StandardCharsets.UTF_8),\n                \"response.json\",\n                MediaType.APPLICATION_JSON);\n    } catch (Exception e) {\n        log.error(\"Error processing PDF info\", e);\n        throw e;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "350", "src_id": "M24", "code": "\nprivate boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n    try {\n        String encodedPayload = licenseFile\n                .replace(CERT_PREFIX, \"\")\n                .replace(CERT_SUFFIX, \"\")\n                .replaceAll(\"\\\\r?\\\\n\", \"\");\n\n        byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n        String payload = new String(payloadBytes);\n        log.info(\"Decoded certificate payload: {}\", payload);\n\n        JSONObject attrs = new JSONObject(payload);\n        String encryptedData = attrs.getString(\"enc\");\n        String encodedSignature = attrs.getString(\"sig\");\n        String algorithm = attrs.getString(\"alg\");\n\n        if (!\"base64+ed25519\".equals(algorithm)) {\n            log.error(\"Unsupported algorithm: {}. Only base64+ed25519 supported\", algorithm);\n            return false;\n        }\n\n        if (!verifyEd25519Signature(encryptedData, encodedSignature)) {\n            log.error(\"License file signature invalid\");\n            return false;\n        }\n\n        String decodedData = new String(Base64.getDecoder().decode(encryptedData));\n        return processCertificateData(decodedData, context);\n    } catch (JSONException e) {\n        log.error(\"Failed parsing license file: {}\", e.getMessage());\n        return false;\n    } catch (IllegalArgumentException e) {\n        log.error(\"Failed decoding license data: {}\", e.getMessage());\n        return false;\n    } catch (Exception e) {\n        log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "351", "src_id": "M403", "code": "\nprivate static void sanitizeHtmlFilesInZip(\n        Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager) throws IOException {\n    try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager);\n         ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n                 new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n        \n        ZipEntry entry;\n        while ((entry = zipIn.getNextEntry()) != null) {\n            Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n            if (entry.isDirectory()) {\n                continue;\n            }\n\n            Files.createDirectories(filePath.getParent());\n            if (entry.getName().toLowerCase().endsWith(\".html\") || \n                entry.getName().toLowerCase().endsWith(\".htm\")) {\n                String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                Files.write(filePath, sanitizeHtmlContent(content, disableSanitize).getBytes(StandardCharsets.UTF_8));\n            } else {\n                Files.copy(zipIn, filePath);\n            }\n            zipIn.closeEntry();\n        }\n        zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "352", "src_id": "M317", "code": "\npublic static void addImageToDocument(\n        PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate) throws IOException {\n    boolean imageIsLandscape = image.getWidth() > image.getHeight();\n    PDRectangle pageSize = PDRectangle.A4;\n\n    if (autoRotate && imageIsLandscape) {\n        pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n    }\n\n    if (\"fitDocumentToImage\".equals(fitOption)) {\n        pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n    }\n\n    PDPage page = new PDPage(pageSize);\n    doc.addPage(page);\n\n    float pageWidth = page.getMediaBox().getWidth();\n    float pageHeight = page.getMediaBox().getHeight();\n\n    try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n        if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n            contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n        } else if (\"maintainAspectRatio\".equals(fitOption)) {\n            float imageRatio = (float) image.getWidth() / image.getHeight();\n            float pageRatio = pageWidth / pageHeight;\n\n            float scaleFactor = imageRatio > pageRatio ? \n                pageWidth / image.getWidth() : \n                pageHeight / image.getHeight();\n\n            float xPos = (pageWidth - image.getWidth() * scaleFactor) / 2;\n            float yPos = (pageHeight - image.getHeight() * scaleFactor) / 2;\n            contentStream.drawImage(image, xPos, yPos, \n                    image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "353", "src_id": "M307", "code": "\npublic static String generateMachineFingerprint() {\n    try {\n        StringBuilder sb = new StringBuilder();\n        Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n        while (networks.hasMoreElements()) {\n            NetworkInterface net = networks.nextElement();\n            byte[] mac = net.getHardwareAddress();\n            if (mac == null) {\n                continue;\n            }\n            for (byte b : mac) {\n                sb.append(String.format(\"%02X\", b));\n            }\n            break;\n        }\n\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n        StringBuilder fingerprint = new StringBuilder();\n        for (byte b : hash) {\n            fingerprint.append(String.format(\"%02x\", b));\n        }\n        return fingerprint.toString();\n    } catch (Exception e) {\n        return \"GenericID\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "354", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n    pdf.getDocumentInformation().setTitle(pdfMetadata.getTitle());\n    pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && \n        runningProOrHigher) {\n        \n        author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n        if (userService != null) {\n            author = author.replace(\"username\", userService.getCurrentUsername());\n        }\n    }\n    pdf.getDocumentInformation().setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "355", "src_id": "M128", "code": "\n@Bean(name = \"machineType\")\npublic String determineMachineType() {\n    boolean isDocker = runningInDocker();\n    boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n    boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n    if (isKubernetes) {\n        return \"Kubernetes\";\n    }\n    if (isDocker) {\n        return \"Docker\";\n    }\n    if (isBrowserOpen) {\n        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n        if (os.contains(\"win\")) {\n            return \"Client-windows\";\n        }\n        if (os.contains(\"mac\")) {\n            return \"Client-mac\";\n        }\n        return \"Client-unix\";\n    }\n    return \"Server-jar\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "356", "src_id": "M101", "code": "\nprivate void processRequest(\n        int limitPerDay,\n        String identifier,\n        Map<String, Bucket> buckets,\n        HttpServletRequest request,\n        HttpServletResponse response,\n        FilterChain filterChain) throws IOException, ServletException {\n    \n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n    \n    if (!probe.isConsumed()) {\n        long waitSeconds = probe.getNanosToWaitForRefill() / 1_000_000_000;\n        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n        response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", String.valueOf(waitSeconds));\n        response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        return;\n    }\n\n    response.setHeader(\"X-Rate-Limit-Remaining\", String.valueOf(probe.getRemainingTokens()));\n    filterChain.doFilter(request, response);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "357", "src_id": "M491", "code": "\n    @SuppressLint(\"SwitchIntDef\")\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(Player player, @ResizeMode int resizeMode) {\n        int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n\n        player.getPrefs().edit().putInt(\n                player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "358", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            closeItemsList();\n        } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            if (!fragmentIsVisible) {\n                onFragmentStopped();\n            }\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n            fragmentIsVisible = false;\n            onFragmentStopped();\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            fragmentIsVisible = true;\n            player.useVideoSource(true);\n            if (!isControlsVisible()) {\n                hideSystemUIIfNeeded();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "359", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(Context context) {\n        Resources res = context.getResources();\n        String lightTheme = res.getString(R.string.light_theme_key);\n        String blackTheme = res.getString(R.string.black_theme_key);\n        String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n        String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n            return R.style.BlackSettingsTheme;\n        } else if (selectedTheme.equals(automaticDeviceTheme)) {\n            if (isDeviceDarkThemeEnabled(context)) {\n                String selectedNightTheme = getSelectedNightThemeKey(context);\n                if (selectedNightTheme.equals(blackTheme)) {\n                    return R.style.BlackSettingsTheme;\n                } else {\n                    return R.style.DarkSettingsTheme;\n                }\n            } else {\n                return R.style.LightSettingsTheme;\n            }\n        } else {\n            return R.style.DarkSettingsTheme;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "360", "src_id": "M895", "code": "\n    @Override\n    public Bitmap transform(Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n\n        float notificationThumbnailWidth = Math.min(\n                context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                source.getWidth());\n\n        Bitmap result = BitmapCompat.createScaledBitmap(\n                source,\n                (int) notificationThumbnailWidth,\n                (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)),\n                null,\n                true);\n\n        if (result == source || !result.isMutable()) {\n            Bitmap copied = BitmapCompat.createScaledBitmap(\n                    source,\n                    (int) notificationThumbnailWidth - 1,\n                    (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))),\n                    null,\n                    true);\n            source.recycle();\n            return copied;\n        } else {\n            source.recycle();\n            return result;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "361", "src_id": "M225", "code": "\n    private void onBroadcastReceived(Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                }\n                break;\n        }\n\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "362", "src_id": "M749", "code": "\n    private static void handleError(Context context, ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null\n                && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n            Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n            Toast.makeText(context, R.string.restricted_video_no_stream,\n                    Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n            Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n            Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n            Toast.makeText(context, R.string.soundcloud_go_plus_content,\n                    Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n            Toast.makeText(context, R.string.youtube_music_premium_content,\n                    Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n            Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n        } else {\n            ErrorUtil.createNotification(context, errorInfo);\n        }\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "363", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@NonNull Context context,\n                                               @NonNull FragmentManager fragmentManager,\n                                               int serviceId,\n                                               @Nullable String url,\n                                               @NonNull String title,\n                                               @Nullable PlayQueue playQueue,\n                                               boolean switchingPlayers) {\n\n        boolean autoPlay;\n        @Nullable PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else if (switchingPlayers) {\n            autoPlay = PlayerHolder.getInstance().isPlaying();\n        } else if (playerType == PlayerType.MAIN) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else {\n            autoPlay = false;\n        }\n\n        RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (switchingPlayers) {\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP\n                        || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } else {\n                detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            }\n            detailFragment.scrollToTop();\n        };\n\n        Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            VideoDetailFragment instance = VideoDetailFragment\n                    .getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n\n            defaultTransaction(fragmentManager)\n                    .replace(R.id.fragment_player_holder, instance)\n                    .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n                    .commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "364", "src_id": "M698", "code": "\n    @Override\n    public void handleResult(@NonNull ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG)\n                    .into(binding.channelBannerImage);\n        } else {\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.subChannelAvatarView);\n\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization\n                    .shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(\n                    getString(R.string.channel_created_by),\n                    currentInfo.getParentChannelName())\n            );\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n\n        channelContentNotSupported = false;\n        for (Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "365", "src_id": "M379", "code": "\n    @Override\n    public void onTextTracksChanged(@NonNull Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n                || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n                || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        List<Tracks.Group> textTracks = currentTracks\n                .getGroups()\n                .stream()\n                .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n                .collect(Collectors.toList());\n        List<String> availableLanguages = textTracks.stream()\n                .map(Tracks.Group::getMediaTrackGroup)\n                .filter(textTrack -> textTrack.length > 0)\n                .map(textTrack -> textTrack.getFormat(0).language)\n                .collect(Collectors.toList());\n\n        Optional<Format> selectedTracks = textTracks.stream()\n                .filter(Tracks.Group::isSelected)\n                .filter(info -> info.getMediaTrackGroup().length >= 1)\n                .map(info -> info.getMediaTrackGroup().getFormat(0))\n                .findFirst();\n\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(\n                player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(\n                availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "366", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(Context context,\n                                                         @NonNull List<Image> images) {\n        return PicassoHelper.loadThumbnail(images)\n                .transform(new Transformation() {\n                    @Override\n                    public Bitmap transform(Bitmap source) {\n                        if (DEBUG) {\n                            Log.d(TAG, \"Thumbnail - transform() called\");\n                        }\n\n                        float notificationThumbnailWidth = Math.min(\n                                context.getResources()\n                                        .getDimension(R.dimen.player_notification_thumbnail_width),\n                                source.getWidth());\n\n                        Bitmap result = BitmapCompat.createScaledBitmap(\n                                source,\n                                (int) notificationThumbnailWidth,\n                                (int) (source.getHeight()\n                                        / (source.getWidth() / notificationThumbnailWidth)),\n                                null,\n                                true);\n\n                        if (result == source || !result.isMutable()) {\n                            Bitmap copied = BitmapCompat.createScaledBitmap(\n                                    source,\n                                    (int) notificationThumbnailWidth - 1,\n                                    (int) (source.getHeight() / (source.getWidth()\n                                            / (notificationThumbnailWidth - 1))),\n                                    null,\n                                    true);\n                            source.recycle();\n                            return copied;\n                        } else {\n                            source.recycle();\n                            return result;\n                        }\n                    }\n\n                    @Override\n                    public String key() {\n                        return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                    }\n                });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "367", "src_id": "M1043", "code": "\nprivate void doPostprocessing() {\n    if (DEBUG) {\n        Log.d(TAG, \"doPostprocessing() called\");\n    }\n\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    final Thread thread = Thread.currentThread();\n\n    notifyPostProcessing(1);\n\n    if (DEBUG) {\n        thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n\n    Exception exception = null;\n\n    try {\n        psAlgorithm.run(this);\n    } catch (final Exception err) {\n        Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n        if (err instanceof InterruptedIOException \n                || err instanceof ClosedByInterruptException \n                || thread.isInterrupted()) {\n            notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) {\n            errCode = ERROR_POSTPROCESSING;\n        }\n\n        exception = err;\n    } finally {\n        notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n        if (exception == null) {\n            exception = errObject;\n        }\n        notifyError(ERROR_POSTPROCESSING, exception);\n        return;\n    }\n\n    notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "368", "src_id": "M1031", "code": "\nvoid establishConnection(final int threadId, final HttpURLConnection conn) \n        throws IOException, HttpError {\n    if (DEBUG) {\n        Log.d(TAG, threadId + \": establishConnection() called\");\n    }\n\n    final int statusCode = conn.getResponseCode();\n\n    if (DEBUG) {\n        Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n        Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n        Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n        Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n    }\n\n    switch (statusCode) {\n        case 204:\n        case 205:\n        case 207:\n            throw new HttpError(statusCode);\n        case 416:\n            return; // let the download thread handle this error\n        default:\n            if (statusCode < 200 || statusCode > 299) {\n                throw new HttpError(statusCode);\n            }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "369", "src_id": "M827", "code": "\nprivate Elst parseEdts(final Box ref) throws IOException {\n    if (DEBUG) {\n        Log.d(TAG, \"parseEdts() called\");\n    }\n\n    final Box b = untilBox(ref, ATOM_ELST);\n    if (b == null) {\n        return null;\n    }\n\n    final Elst obj = new Elst();\n\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n        obj.bMediaRate = 0x00010000; // default media rate (1.0)\n        return obj;\n    }\n\n    if (v1) {\n        stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n        obj.mediaTime = stream.readLong();\n        // ignore all remain entries\n        stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n    } else {\n        stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n        obj.mediaTime = stream.readInt();\n    }\n\n    obj.bMediaRate = stream.readInt();\n\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "370", "src_id": "M1048", "code": "\n@Override\npublic void run() {\n    if (DEBUG) {\n        Log.d(TAG, \"run() called\");\n    }\n\n    boolean done = false;\n    long start = mMission.fallbackResumeOffset;\n\n    if (DEBUG && !mMission.unknownLength && start > 0) {\n        Log.i(TAG, \"Resuming a single-thread download at \" + start);\n    }\n\n    try {\n        final long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n        final int mId = 1;\n        mConn = mMission.openConnection(false, rangeStart, -1);\n\n        if (mRetryCount == 0 && rangeStart == -1) {\n            // workaround: bypass android connection pool\n            mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n        }\n\n        mMission.establishConnection(mId, mConn);\n\n        // check if the download can be resumed\n        if (mConn.getResponseCode() == 416 && start > 0) {\n            mMission.notifyProgress(-start);\n            start = 0;\n            mRetryCount--;\n            throw new DownloadMission.HttpError(416);\n        }\n\n        // secondary check for the file length\n        if (!mMission.unknownLength) {\n            mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n        }\n\n        if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n            // restart amount of bytes downloaded\n            mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n        }\n\n        mF = mMission.storage.getStream();\n        mF.seek(mMission.offsets[mMission.current] + start);\n\n        mIs = mConn.getInputStream();\n\n        final byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n        int len = 0;\n\n        while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n            mF.write(buf, 0, len);\n            start += len;\n            mMission.notifyProgress(len);\n        }\n\n        dispose();\n\n        // if thread goes interrupted check if the last part is written\n        done = len == -1;\n    } catch (final Exception e) {\n        dispose();\n\n        mMission.fallbackResumeOffset = start;\n\n        if (!mMission.running || e instanceof ClosedByInterruptException) {\n            return;\n        }\n\n        if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n            // for youtube streams. The url has expired, recover\n            dispose();\n            mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n            return;\n        }\n\n        if (mRetryCount++ >= mMission.maxRetry) {\n            mMission.notifyError(e);\n            return;\n        }\n\n        if (DEBUG) {\n            Log.e(TAG, \"got exception, retrying...\", e);\n        }\n\n        run(); // try again\n        return;\n    }\n\n    if (done) {\n        mMission.notifyFinished();\n    } else {\n        mMission.fallbackResumeOffset = start;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "371", "src_id": "M1141", "code": "\nprivate void flushAuxiliar(final long amount) throws IOException {\n    if (DEBUG) {\n        Log.d(TAG, \"flushAuxiliar() called with: amount = [\" + amount + \"]\");\n    }\n\n    if (aux.length < 1) {\n        return;\n    }\n\n    out.flush();\n    aux.flush();\n\n    final boolean underflow = aux.offset < aux.length || out.offset < out.length;\n    final byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n    aux.target.seek(0);\n    out.target.seek(out.length);\n\n    long length = amount;\n    while (length > 0) {\n        int read = (int) Math.min(length, Integer.MAX_VALUE);\n        read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n        if (read < 1) {\n            amount -= length;\n            break;\n        }\n\n        out.writeProof(buffer, read);\n        length -= read;\n    }\n\n    if (underflow) {\n        if (out.offset >= out.length) {\n            // calculate the aux underflow pointer\n            if (aux.offset < amount) {\n                out.offset += aux.offset;\n                aux.offset = 0;\n                out.target.seek(out.offset);\n            } else {\n                aux.offset -= amount;\n                out.offset = out.length + amount;\n            }\n        } else {\n            aux.offset = 0;\n        }\n    } else {\n        out.offset += amount;\n        aux.offset -= amount;\n    }\n\n    out.length += amount;\n\n    if (out.length > maxLengthKnown) {\n        maxLengthKnown = out.length;\n    }\n\n    if (amount < aux.length) {\n        // move the excess data to the beginning of the file\n        long readOffset = amount;\n        long writeOffset = 0;\n\n        aux.length -= amount;\n        length = aux.length;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            aux.target.seek(writeOffset);\n            aux.writeProof(buffer, read);\n\n            writeOffset += read;\n            readOffset += read;\n            length -= read;\n\n            aux.target.seek(readOffset);\n        }\n\n        aux.target.setLength(aux.length);\n        return;\n    }\n\n    if (aux.length > THRESHOLD_AUX_LENGTH) {\n        aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n    }\n\n    aux.reset();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "372", "src_id": "M1106", "code": "\nprivate void showError(final DownloadMission mission, final UserAction action,\n        @StringRes final int reason) {\n    if (DEBUG) {\n        Log.d(TAG, \"showError() called\");\n    }\n\n    final StringBuilder request = new StringBuilder(256);\n    request.append(mission.source);\n\n    request.append(\" [\");\n    if (mission.recoveryInfo != null) {\n        for (final MissionRecoveryInfo recovery : mission.recoveryInfo) {\n            request.append(' ')\n                    .append(recovery.toString())\n                    .append(' ');\n        }\n    }\n    request.append(\"]\");\n\n    final String service;\n    try {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (final Exception e) {\n        service = ErrorInfo.SERVICE_NONE;\n    }\n\n    ErrorUtil.createNotification(mContext,\n            new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action,\n                    service, request.toString(), reason));\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "373", "src_id": "M1067", "code": "\nvoid startMission(final DownloadMission mission) {\n    synchronized (this) {\n        if (DEBUG) {\n            Log.d(TAG, \"startMission() called\");\n        }\n\n        mission.timestamp = System.currentTimeMillis();\n        mission.mHandler = mHandler;\n        mission.maxRetry = mPrefMaxRetry;\n\n        // create metadata file\n        while (true) {\n            mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n            if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                try {\n                    if (!mission.metadata.createNewFile()) {\n                        throw new RuntimeException(\"Cant create download metadata file\");\n                    }\n                } catch (final IOException e) {\n                    throw new RuntimeException(e);\n                }\n                break;\n            }\n            mission.timestamp = System.currentTimeMillis();\n        }\n\n        mSelfMissionsControl = true;\n        mMissionsPending.add(mission);\n\n        // Before continue, save the metadata\n        Utility.writeToFile(mission.metadata, mission);\n\n        if (mission.storage == null) {\n            // nothing to do here\n            mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n            if (mission.errObject != null) {\n                mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n            }\n            return;\n        }\n\n        final boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n        if (canDownloadInCurrentNetwork() && start) {\n            mission.start();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "374", "src_id": "M1136", "code": "\n@Override\nint process(final SharpStream out, final SharpStream... sources) throws IOException {\n    if (DEBUG) {\n        Log.d(TAG, \"process() called\");\n    }\n\n    // check if the subtitle is already in srt and copy\n    final String format = getArgumentAt(0, null);\n    final boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n    if (format == null || format.equals(\"ttml\")) {\n        final SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n\n        try {\n            writer.build(sources[0]);\n        } catch (final Exception err) {\n            Log.e(TAG, \"subtitle parse failed\", err);\n            return err instanceof IOException ? 1 : 8;\n        }\n\n        return OK_RESULT;\n    } else if (format.equals(\"srt\")) {\n        final byte[] buffer = new byte[8 * 1024];\n        int read;\n        while ((read = sources[0].read(buffer)) > 0) {\n            out.write(buffer, 0, read);\n        }\n        return OK_RESULT;\n    }\n\n    throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "375", "src_id": "M1047", "code": "\nprivate void joinForThreads(final int millis) {\n    if (DEBUG) {\n        Log.d(TAG, \"joinForThreads() called with: millis = [\" + millis + \"]\");\n    }\n\n    final Thread currentThread = Thread.currentThread();\n\n    if (init != null && init != currentThread && init.isAlive()) {\n        init.interrupt();\n\n        if (millis > 0) {\n            try {\n                init.join(millis);\n            } catch (final InterruptedException e) {\n                Log.w(TAG, \"Initializer thread is still running\", e);\n                return;\n            }\n        }\n    }\n\n    // if a thread is still alive, possible reasons:\n    //      slow device\n    //      the user is spamming start/pause buttons\n    //      start() method called quickly after pause()\n\n    for (final Thread thread : threads) {\n        if (!thread.isAlive() || thread == Thread.currentThread()) {\n            continue;\n        }\n        thread.interrupt();\n    }\n\n    try {\n        for (final Thread thread : threads) {\n            if (!thread.isAlive()) {\n                continue;\n            }\n            if (DEBUG) {\n                Log.w(TAG, \"thread alive: \" + thread.getName());\n            }\n            if (millis > 0) {\n                thread.join(millis);\n            }\n        }\n    } catch (final InterruptedException e) {\n        throw new RuntimeException(\"A download thread is still running\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "376", "src_id": "M1086", "code": "\n    public static AdminServer createAdminServer() {\n        if (!\"false\".equals(System.getProperty(\"zookeeper.admin.enableServer\"))) {\n            try {\n                Class<?> jettyAdminServerC = Class.forName(\"org.apache.zookeeper.server.admin.JettyAdminServer\");\n                return (AdminServer) jettyAdminServerC.getConstructor().newInstance();\n            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | \n                     InvocationTargetException | NoSuchMethodException e) {\n                LOG.warn(\"Unable to start JettyAdminServer\", e);\n            } catch (NoClassDefFoundError e) {\n                LOG.warn(\"Unable to load jetty, not starting JettyAdminServer\", e);\n            }\n        }\n        return new DummyAdminServer();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "377", "src_id": "M1149", "code": "\n        public void run() {\n            try {\n                while (!stopped) {\n                    try {\n                        select();\n                        processAcceptedConnections();\n                        processInterestOpsUpdateRequests();\n                    } catch (RuntimeException e) {\n                        LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                    } catch (Exception e) {\n                        LOG.warn(\"Ignoring unexpected exception\", e);\n                    }\n                }\n\n                for (SelectionKey key : selector.keys()) {\n                    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                    if (cnxn.isSelectable()) {\n                        cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                    }\n                    cleanupSelectionKey(key);\n                }\n                SocketChannel accepted;\n                while ((accepted = acceptedQueue.poll()) != null) {\n                    fastCloseSock(accepted);\n                }\n                updateQueue.clear();\n            } finally {\n                closeSelector();\n                NIOServerCnxnFactory.this.stop();\n                LOG.info(\"selector thread exited run method\");\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "378", "src_id": "M219", "code": "\n    public static synchronized ZooKeeper getClient(String contextPath,\n            String session, int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n\n        ZooKeeper zk = zkMap.get(connectionId);\n        if (zk == null) {\n            LOG.info(\"creating new connection for : '{}'\", connectionId);\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n            \n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n            \n            zkMap.put(connectionId, zk);\n\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(\n                        expireTime, session, contextPath, timer));\n            }\n        }\n        return zk;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "379", "src_id": "M192", "code": "\n    private void init() throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n\n        String lastentry = line;\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size++;\n                    lastentry = line;\n                } \n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n            // ignore\n        } finally {\n            in.close();\n        }\n\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "380", "src_id": "M235", "code": "\n    @POST\n    @Produces({ MediaType.APPLICATION_JSON, \"application/javascript\", MediaType.APPLICATION_XML })\n    public Response createSession(@QueryParam(\"op\") String op,\n            @DefaultValue(\"5\") @QueryParam(\"expire\") String expire,\n            @Context UriInfo ui) {\n        if (!\"create\".equals(op)) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)\n                .entity(new ZError(ui.getRequestUri().toString(), \"\")).build());\n        }\n\n        int expireInSeconds;\n        try {\n            expireInSeconds = Integer.parseInt(expire);\n        } catch (NumberFormatException e) {\n            throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());\n        }\n\n        String uuid = UUID.randomUUID().toString();\n        while (ZooKeeperService.isConnected(contextPath, uuid)) {\n            uuid = UUID.randomUUID().toString();\n        }\n\n        try {\n            ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);\n        } catch (IOException e) {\n            LOG.error(\"Failed while trying to create a new session\", e);\n            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n\n        URI uri = ui.getAbsolutePathBuilder().path(uuid).build();\n        return Response.created(uri)\n            .entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "381", "src_id": "M942", "code": "\n    public void schedule(WorkRequest workRequest, long id) {\n        if (stopped) {\n            workRequest.cleanup();\n            return;\n        }\n\n        ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);\n        int size = workers.size();\n        if (size > 0) {\n            try {\n                int workerNum = ((int) (id % size) + size) % size;\n                workers.get(workerNum).execute(scheduledWorkRequest);\n            } catch (RejectedExecutionException e) {\n                LOG.warn(\"ExecutorService rejected execution\", e);\n                workRequest.cleanup();\n            }\n        } else {\n            scheduledWorkRequest.run();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "382", "src_id": "M520", "code": "\n    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        } finally {\n            if (success) {\n                if (!tmpFile.renameTo(origFile) && \n                    (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            } else {\n                if (!triedToClose) {\n                    IOUtils.closeStream(out);\n                }\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "383", "src_id": "M186", "code": "\n    private synchronized LogEntry readNextEntry() {\n        try {\n            while (true) {\n                String line = in.readLine();\n                if (line == null) break;\n\n                Matcher m = src.timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (buf.length() > 0) {\n                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                        buf = line;\n                        return e;\n                    }\n                    buf = line;\n                } else if (buf.length() > 0) {\n                    buf += line + \"\\n\";\n                }\n            }\n        } catch (EOFException eof) {\n            // ignore\n        }\n        if (buf.length() > 0) {\n            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n            buf = \"\";\n            return e;\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "384", "src_id": "M478", "code": "\n    public static void main(String[] args) {\n        if (args.length < 3) {\n            usage();\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        String op = args[2];\n        switch (op.toLowerCase()) {\n            case \"gettracemask\": getTraceMask(host, port); break;\n            case \"settracemask\": setTraceMask(host, port, args[3]); break;\n            case \"ruok\": ruok(host, port); break;\n            case \"kill\": kill(host, port); break;\n            case \"stat\": stat(host, port); break;\n            case \"dump\": dump(host, port); break;\n            default: System.out.println(\"Unrecognized op: \" + op);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "385", "src_id": "M66", "code": "\n        void drain() {\n            // Return immediately if already draining to prevent concurrent execution\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super R> downstream = this.downstream;\n            AtomicThrowable errors = this.errors;\n            AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n            // Main drain loop\n            for (;;) {\n                // Inner processing loop\n                for (;;) {\n                    // Check cancellation status\n                    if (cancelled) {\n                        return;\n                    }\n\n                    // Handle delayed errors if present\n                    if (errors.get() != null) {\n                        if (!delayErrors) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean done = this.done;\n                    SwitchMapMaybeObserver<R> current = inner.get();\n                    boolean empty = current == null;\n\n                    // Termination condition check\n                    if (done && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    // Break if no items available\n                    if (empty || current.item == null) {\n                        break;\n                    }\n\n                    // Consume and clear the current item\n                    inner.compareAndSet(current, null);\n                    downstream.onNext(current.item);\n                }\n\n                // Update missed counter and check termination condition\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "386", "src_id": "M1333", "code": "\n        @Override\n        public void onNext(T value) {\n            // Skip processing if already completed\n            if (done) {\n                return;\n            }\n            \n            boolean testResult;\n            try {\n                // Apply predicate to current value\n                testResult = predicate.test(value);\n            } catch (Throwable error) {\n                // Handle predicate errors\n                Exceptions.throwIfFatal(error);\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                onError(error);\n                return;\n            }\n            \n            // Terminate stream if predicate fails\n            if (!testResult) {\n                done = true;\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                downstream.onSuccess(false);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "387", "src_id": "M522", "code": "\n        void drainLoop() {\n            int missed = 1;\n            Observer<? super T> actual = this.downstream;\n            \n            // Main processing loop\n            for (;;) {\n                // Inner consumption loop\n                for (;;) {\n                    // Handle disposal state\n                    if (disposed) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n\n                    // Check for errors\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(actual);\n                        return;\n                    }\n\n                    // Process buffered value from secondary source\n                    int otherState = this.otherState;\n                    if (otherState == OTHER_STATE_HAS_VALUE) {\n                        T value = singleItem;\n                        singleItem = null;\n                        this.otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        actual.onNext(value);\n                    }\n\n                    // Check main source state\n                    boolean mainDone = this.mainDone;\n                    SimplePlainQueue<T> queue = this.queue;\n                    T value = queue != null ? queue.poll() : null;\n                    boolean empty = value == null;\n\n                    // Handle completion condition\n                    if (mainDone && empty && otherState == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                        this.queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n\n                    // Break if no items available\n                    if (empty) {\n                        break;\n                    }\n\n                    // Emit next value\n                    actual.onNext(value);\n                }\n\n                // Update missed counter and check termination\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "388", "src_id": "M1163", "code": "\n        @Override\n        void drain() {\n            // Skip if already draining\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final SimplePlainQueue<Object> queue = this.queue;\n            final Subscriber<? super Flowable<T>> downstream = this.downstream;\n            UnicastProcessor<T> window = this.window;\n\n            // Main processing loop\n            for (;;) {\n                // Handle cancellation cleanup\n                if (upstreamCancelled) {\n                    queue.clear();\n                    window = null;\n                    this.window = null;\n                } else {\n                    // Check completion status\n                    boolean isDone = this.done;\n                    Object item = queue.poll();\n                    boolean isEmpty = item == null;\n\n                    // Handle terminal state\n                    if (isDone && isEmpty) {\n                        Throwable error = this.error;\n                        if (error != null) {\n                            if (window != null) {\n                                window.onError(error);\n                            }\n                            downstream.onError(error);\n                        } else {\n                            if (window != null) {\n                                window.onComplete();\n                            }\n                            downstream.onComplete();\n                        }\n                        cleanupResources();\n                        upstreamCancelled = true;\n                        continue;\n                    } else if (!isEmpty) {\n                        // Process window boundary signals\n                        if (item instanceof WindowBoundaryRunnable) {\n                            WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) item;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else if (window != null) {\n                            // Process data item\n                            @SuppressWarnings(\"unchecked\")\n                            T value = (T) item;\n                            window.onNext(value);\n\n                            // Handle window size threshold\n                            long count = this.count + 1;\n                            if (count == maxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            } else {\n                                this.count = count;\n                            }\n                        }\n                        continue;\n                    }\n                }\n\n                // Update missed counter and check completion\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "389", "src_id": "M478", "code": "\n        void drain() {\n            // Skip if already draining\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            EqualObserver<T>[] observers = this.observers;\n\n            // Initialize observers and queues\n            final EqualObserver<T> firstObserver = observers[0];\n            final SpscLinkedArrayQueue<T> firstQueue = firstObserver.queue;\n            final EqualObserver<T> secondObserver = observers[1];\n            final SpscLinkedArrayQueue<T> secondQueue = secondObserver.queue;\n            T firstValue = null;\n            T secondValue = null;\n\n            // Main processing loop\n            for (;;) {\n                // Inner comparison loop\n                for (;;) {\n                    // Handle cancellation\n                    if (cancelled) {\n                        firstQueue.clear();\n                        secondQueue.clear();\n                        return;\n                    }\n\n                    // Check first observer errors\n                    boolean firstDone = firstObserver.done;\n                    if (firstDone) {\n                        Throwable error = firstObserver.error;\n                        if (error != null) {\n                            cancel(firstQueue, secondQueue);\n                            downstream.onError(error);\n                            return;\n                        }\n                    }\n\n                    // Check second observer errors\n                    boolean secondDone = secondObserver.done;\n                    if (secondDone) {\n                        Throwable error = secondObserver.error;\n                        if (error != null) {\n                            cancel(firstQueue, secondQueue);\n                            downstream.onError(error);\n                            return;\n                        }\n                    }\n\n                    // Fetch next values from queues\n                    if (firstValue == null) {\n                        firstValue = firstQueue.poll();\n                    }\n                    boolean firstEmpty = firstValue == null;\n\n                    if (secondValue == null) {\n                        secondValue = secondQueue.poll();\n                    }\n                    boolean secondEmpty = secondValue == null;\n\n                    // Handle completion conditions\n                    if (firstDone && secondDone && firstEmpty && secondEmpty) {\n                        downstream.onSuccess(true);\n                        return;\n                    }\n                    if ((firstDone && secondDone) && (firstEmpty != secondEmpty)) {\n                        cancel(firstQueue, secondQueue);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    // Process values when both available\n                    if (!firstEmpty && !secondEmpty) {\n                        boolean comparisonResult;\n                        try {\n                            // Perform value comparison\n                            comparisonResult = comparer.test(firstValue, secondValue);\n                        } catch (Throwable error) {\n                            // Handle comparison errors\n                            Exceptions.throwIfFatal(error);\n                            cancel(firstQueue, secondQueue);\n                            downstream.onError(error);\n                            return;\n                        }\n\n                        // Terminate if values differ\n                        if (!comparisonResult) {\n                            cancel(firstQueue, secondQueue);\n                            downstream.onSuccess(false);\n                            return;\n                        }\n\n                        // Reset values for next comparison\n                        firstValue = null;\n                        secondValue = null;\n                    }\n\n                    // Break if either queue is empty\n                    if (firstEmpty || secondEmpty) {\n                        break;\n                    }\n                }\n\n                // Update missed counter and check completion\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "390", "src_id": "M885", "code": "\n        void drainLoop() {\n            int missed = 1;\n            JoinInnerSubscriber<T>[] subscribers = this.subscribers;\n            int subscriberCount = subscribers.length;\n            Subscriber<? super T> actual = this.downstream;\n\n            // Main processing loop\n            for (;;) {\n                long requestCount = requested.get();\n                long emittedCount = 0;\n\n                // Middle loop for emission control\n                middle: while (emittedCount != requestCount) {\n                    // Handle cancellation\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    // Check for errors\n                    Throwable error = errors.get();\n                    if (error != null) {\n                        cleanup();\n                        actual.onError(error);\n                        return;\n                    }\n\n                    // Check completion status\n                    boolean done = this.done.get() == 0;\n                    boolean empty = true;\n\n                    // Process items from all subscribers\n                    for (int i = 0; i < subscriberCount; i++) {\n                        JoinInnerSubscriber<T> inner = subscribers[i];\n                        SimplePlainQueue<T> queue = inner.queue;\n                        if (queue != null) {\n                            T value = queue.poll();\n\n                            if (value != null) {\n                                empty = false;\n                                actual.onNext(value);\n                                inner.requestOne();\n                                if (++emittedCount == requestCount) {\n                                    break middle;\n                                }\n                            }\n                        }\n                    }\n\n                    // Handle completion when empty\n                    if (done && empty) {\n                        actual.onComplete();\n                        return;\n                    }\n\n                    // Break if no items found\n                    if (empty) {\n                        break;\n                    }\n                }\n\n                // Post-emission checks\n                if (emittedCount == requestCount) {\n                    // Recheck cancellation\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    // Recheck errors\n                    Throwable error = errors.get();\n                    if (error != null) {\n                        cleanup();\n                        actual.onError(error);\n                        return;\n                    }\n\n                    // Recheck completion status\n                    boolean done = this.done.get() == 0;\n                    boolean empty = true;\n\n                    // Verify all queues are empty\n                    for (int i = 0; i < subscriberCount; i++) {\n                        JoinInnerSubscriber<T> inner = subscribers[i];\n                        SimpleQueue<T> queue = inner.queue;\n                        if (queue != null && !queue.isEmpty()) {\n                            empty = false;\n                            break;\n                        }\n                    }\n\n                    // Handle final completion\n                    if (done && empty) {\n                        actual.onComplete();\n                        return;\n                    }\n                }\n\n                // Update request count if items were emitted\n                if (emittedCount != 0) {\n                    BackpressureHelper.produced(requested, emittedCount);\n                }\n\n                // Update missed counter and check completion\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "391", "src_id": "M1399", "code": "\n        @Override\n        public void drain() {\n            // Skip if already draining\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            InnerQueuedSubscriber<R> currentInner = this.current;\n            Subscriber<? super R> downstream = this.downstream;\n            ErrorMode errorMode = this.errorMode;\n\n            // Main processing loop\n            for (;;) {\n                long requestCount = requested.get();\n                long emittedCount = 0L;\n\n                // Initialize current subscriber if needed\n                if (currentInner == null) {\n                    // Handle immediate error mode\n                    if (errorMode != ErrorMode.END) {\n                        Throwable error = errors.get();\n                        if (error != null) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    // Check outer completion\n                    boolean outerDone = done;\n                    currentInner = subscribers.poll();\n\n                    // Terminate if completed and no more subscribers\n                    if (outerDone && currentInner == null) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (currentInner != null) {\n                        this.current = currentInner;\n                    }\n                }\n\n                boolean continueNext = false;\n\n                // Process current subscriber\n                if (currentInner != null) {\n                    SimpleQueue<R> queue = currentInner.queue();\n                    if (queue != null) {\n                        // Process items up to request count\n                        while (emittedCount != requestCount) {\n                            // Handle cancellation\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            // Immediate error mode handling\n                            if (errorMode == ErrorMode.IMMEDIATE) {\n                                Throwable error = errors.get();\n                                if (error != null) {\n                                    this.current = null;\n                                    currentInner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            // Check subscriber completion\n                            boolean innerDone = currentInner.isDone();\n                            R value;\n\n                            try {\n                                value = queue.poll();\n                            } catch (Throwable error) {\n                                // Handle polling errors\n                                Exceptions.throwIfFatal(error);\n                                this.current = null;\n                                currentInner.cancel();\n                                cancelAll();\n                                downstream.onError(error);\n                                return;\n                            }\n\n                            boolean empty = value == null;\n\n                            // Handle completed subscriber\n                            if (innerDone && empty) {\n                                currentInner = null;\n                                this.current = null;\n                                upstream.request(1);\n                                continueNext = true;\n                                break;\n                            }\n\n                            // Break if no items\n                            if (empty) {\n                                break;\n                            }\n\n                            // Emit value and request more\n                            downstream.onNext(value);\n                            emittedCount++;\n                            currentInner.request(1L);\n                        }\n\n                        // Post-process after emission\n                        if (emittedCount == requestCount) {\n                            // Recheck cancellation\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            // Recheck immediate error mode\n                            if (errorMode == ErrorMode.IMMEDIATE) {\n                                Throwable error = errors.get();\n                                if (error != null) {\n                                    this.current = null;\n                                    currentInner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            // Check subscriber completion again\n                            boolean innerDone = currentInner.isDone();\n                            boolean empty = queue.isEmpty();\n\n                            // Switch to next subscriber if current completed\n                            if (innerDone && empty) {\n                                currentInner = null;\n                                this.current = null;\n                                upstream.request(1);\n                                continueNext = true;\n                            }\n                        }\n                    }\n                }\n\n                // Update request count if items were emitted\n                if (emittedCount != 0L && requestCount != Long.MAX_VALUE) {\n                    requested.addAndGet(-emittedCount);\n                }\n\n                // Move to next subscriber if needed\n                if (continueNext) {\n                    continue;\n                }\n\n                // Update missed counter and check completion\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "392", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(CacheDisposable<T> consumer) {\n        // Retry until successful removal\n        for (;;) {\n            CacheDisposable<T>[] currentObservers = observers.get();\n            int count = currentObservers.length;\n            if (count == 0) {\n                return;\n            }\n\n            // Find target consumer index\n            int index = -1;\n            for (int i = 0; i < count; i++) {\n                if (currentObservers[i] == consumer) {\n                    index = i;\n                    break;\n                }\n            }\n\n            if (index < 0) {\n                return;\n            }\n\n            CacheDisposable<T>[] nextObservers;\n            // Create new array without the removed element\n            if (count == 1) {\n                nextObservers = EMPTY;\n            } else {\n                nextObservers = new CacheDisposable[count - 1];\n                System.arraycopy(currentObservers, 0, nextObservers, 0, index);\n                System.arraycopy(\n                    currentObservers, \n                    index + 1, \n                    nextObservers, \n                    index, \n                    count - index - 1\n                );\n            }\n\n            // Atomic update of observers array\n            if (observers.compareAndSet(currentObservers, nextObservers)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "393", "src_id": "M362", "code": "\n        void drainFused() {\n            int missed = 1;\n\n            // Main processing loop for fused mode\n            for (;;) {\n                // Handle disposal\n                if (disposed) {\n                    return;\n                }\n\n                // Check completion status\n                boolean done = this.done;\n                Throwable error = this.error;\n\n                // Handle undelayed errors\n                if (!delayError && done && error != null) {\n                    disposed = true;\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                // Emit placeholder value\n                downstream.onNext(null);\n\n                // Handle completion\n                if (done) {\n                    disposed = true;\n                    if (error != null) {\n                        downstream.onError(error);\n                    } else {\n                        downstream.onComplete();\n                    }\n                    worker.dispose();\n                    return;\n                }\n\n                // Update missed counter and check termination\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "394", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(PublishSubscription<T> subscription) {\n        // Retry until successful removal\n        for (;;) {\n            PublishSubscription<T>[] currentSubscribers = subscribers.get();\n            if (currentSubscribers == TERMINATED || currentSubscribers == EMPTY) {\n                return;\n            }\n\n            int count = currentSubscribers.length;\n            int index = -1;\n            // Find target subscription\n            for (int i = 0; i < count; i++) {\n                if (currentSubscribers[i] == subscription) {\n                    index = i;\n                    break;\n                }\n            }\n\n            if (index < 0) {\n                return;\n            }\n\n            PublishSubscription<T>[] nextSubscribers;\n            // Create new array without removed subscription\n            if (count == 1) {\n                nextSubscribers = EMPTY;\n            } else {\n                nextSubscribers = new PublishSubscription[count - 1];\n                System.arraycopy(currentSubscribers, 0, nextSubscribers, 0, index);\n                System.arraycopy(\n                    currentSubscribers, \n                    index + 1, \n                    nextSubscribers, \n                    index, \n                    count - index - 1\n                );\n            }\n            \n            // Atomic update of subscribers array\n            if (subscribers.compareAndSet(currentSubscribers, nextSubscribers)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "395", "src_id": "M491", "code": "\n    @SuppressLint(\"SwitchIntDef\")\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(Player player, @ResizeMode int resizeMode) {\n        int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n\n        player.getPrefs().edit().putInt(\n                player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "396", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            closeItemsList();\n        } else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n            if (!fragmentIsVisible) {\n                onFragmentStopped();\n            }\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n            fragmentIsVisible = false;\n            onFragmentStopped();\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n            fragmentIsVisible = true;\n            player.useVideoSource(true);\n\n            if (!isControlsVisible()) {\n                hideSystemUIIfNeeded();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "397", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(Context context) {\n        Resources res = context.getResources();\n        String lightTheme = res.getString(R.string.light_theme_key);\n        String blackTheme = res.getString(R.string.black_theme_key);\n        String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n        String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n            return R.style.BlackSettingsTheme;\n        } else if (selectedTheme.equals(automaticDeviceTheme)) {\n            if (isDeviceDarkThemeEnabled(context)) {\n                String selectedNightTheme = getSelectedNightThemeKey(context);\n                if (selectedNightTheme.equals(blackTheme)) {\n                    return R.style.BlackSettingsTheme;\n                } else {\n                    return R.style.DarkSettingsTheme;\n                }\n            } else {\n                return R.style.LightSettingsTheme;\n            }\n        } else {\n            return R.style.DarkSettingsTheme;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "398", "src_id": "M895", "code": "\n    @Override\n    public Bitmap transform(Bitmap source) {\n        if (DEBUG) {\n            log.debug(\"Thumbnail - transform() called\");\n        }\n\n        float notificationThumbnailWidth = Math.min(\n                context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                source.getWidth());\n\n        Bitmap result = BitmapCompat.createScaledBitmap(\n                source,\n                (int) notificationThumbnailWidth,\n                (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)),\n                null,\n                true);\n\n        if (result == source || !result.isMutable()) {\n            Bitmap copied = BitmapCompat.createScaledBitmap(\n                    source,\n                    (int) notificationThumbnailWidth - 1,\n                    (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))),\n                    null,\n                    true);\n            source.recycle();\n            return copied;\n        } else {\n            source.recycle();\n            return result;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "399", "src_id": "M225", "code": "\n    private void onBroadcastReceived(Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n\n        if (DEBUG) {\n            log.debug(\"onBroadcastReceived() called with: intent = [{}]\", intent);\n        }\n\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) {\n                    log.debug(\"ACTION_CONFIGURATION_CHANGED received\");\n                }\n                break;\n        }\n\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "400", "src_id": "M749", "code": "\n    private static void handleError(Context context, ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null\n                && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n            Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n            Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n            Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n            Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n            Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n            Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n        } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n            Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n        } else {\n            ErrorUtil.createNotification(context, errorInfo);\n        }\n\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "401", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@NonNull Context context,\n                                               @NonNull FragmentManager fragmentManager,\n                                               int serviceId,\n                                               @Nullable String url,\n                                               @NonNull String title,\n                                               @Nullable PlayQueue playQueue,\n                                               boolean switchingPlayers) {\n\n        boolean autoPlay;\n        @Nullable PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else if (switchingPlayers) {\n            autoPlay = PlayerHolder.getInstance().isPlaying();\n        } else if (playerType == PlayerType.MAIN) {\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else {\n            autoPlay = false;\n        }\n\n        RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (switchingPlayers) {\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP\n                        || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } else {\n                detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            }\n            detailFragment.scrollToTop();\n        };\n\n        Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n        } else {\n            VideoDetailFragment instance = VideoDetailFragment\n                    .getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n\n            defaultTransaction(fragmentManager)\n                    .replace(R.id.fragment_player_holder, instance)\n                    .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n                    .commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "402", "src_id": "M698", "code": "\n    @Override\n    public void handleResult(@NonNull ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG)\n                    .into(binding.channelBannerImage);\n        } else {\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.subChannelAvatarView);\n\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization\n                    .shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(\n                    getString(R.string.channel_created_by),\n                    currentInfo.getParentChannelName())\n            );\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n\n        channelContentNotSupported = false;\n        for (Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "403", "src_id": "M379", "code": "\n    @Override\n    public void onTextTracksChanged(@NonNull Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n                || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n                || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        List<Tracks.Group> textTracks = currentTracks\n                .getGroups()\n                .stream()\n                .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n                .collect(Collectors.toList());\n        List<String> availableLanguages = textTracks.stream()\n                .map(Tracks.Group::getMediaTrackGroup)\n                .filter(textTrack -> textTrack.length > 0)\n                .map(textTrack -> textTrack.getFormat(0).language)\n                .collect(Collectors.toList());\n\n        Optional<Format> selectedTracks = textTracks.stream()\n                .filter(Tracks.Group::isSelected)\n                .filter(info -> info.getMediaTrackGroup().length >= 1)\n                .map(info -> info.getMediaTrackGroup().getFormat(0))\n                .findFirst();\n\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(\n                player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(\n                availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "404", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(Context context,\n                                                         @NonNull List<Image> images) {\n        return PicassoHelper.loadThumbnail(images)\n                .transform(new Transformation() {\n                    @Override\n                    public Bitmap transform(Bitmap source) {\n                        if (DEBUG) {\n                            log.debug(\"Thumbnail - transform() called\");\n                        }\n\n                        float notificationThumbnailWidth = Math.min(\n                                context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                                source.getWidth());\n\n                        Bitmap result = BitmapCompat.createScaledBitmap(\n                                source,\n                                (int) notificationThumbnailWidth,\n                                (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)),\n                                null,\n                                true);\n\n                        if (result == source || !result.isMutable()) {\n                            Bitmap copied = BitmapCompat.createScaledBitmap(\n                                    source,\n                                    (int) notificationThumbnailWidth - 1,\n                                    (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))),\n                                    null,\n                                    true);\n                            source.recycle();\n                            return copied;\n                        } else {\n                            source.recycle();\n                            return result;\n                        }\n                    }\n\n                    @Override\n                    public String key() {\n                        return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                    }\n                });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "405", "src_id": "M66", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final Observer<? super R> downstream = this.downstream;\n            final AtomicThrowable errors = this.errors;\n            final AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        if (!delayErrors) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    final boolean d = done;\n                    final SwitchMapMaybeObserver<R> current = inner.get();\n                    final boolean empty = current == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty || current.item == null) {\n                        break;\n                    }\n\n                    inner.compareAndSet(current, null);\n                    downstream.onNext(current.item);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "406", "src_id": "M1333", "code": "\n        @Override\n        public void onNext(final T t) {\n            if (done) {\n                return;\n            }\n            final boolean testResult;\n            try {\n                testResult = predicate.test(t);\n            } catch (final Throwable e) {\n                Exceptions.throwIfFatal(e);\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                onError(e);\n                return;\n            }\n            if (!testResult) {\n                done = true;\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                downstream.onSuccess(false);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "407", "src_id": "M522", "code": "\n        void drainLoop() {\n            final Observer<? super T> actual = this.downstream;\n            int missed = 1;\n            for (;;) {\n                for (;;) {\n                    if (disposed) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(actual);\n                        return;\n                    }\n\n                    final int os = otherState;\n                    if (os == OTHER_STATE_HAS_VALUE) {\n                        final T v = singleItem;\n                        singleItem = null;\n                        otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        actual.onNext(v);\n                    }\n\n                    final boolean d = mainDone;\n                    final SimplePlainQueue<T> q = queue;\n                    final T v = q != null ? q.poll() : null;\n                    final boolean empty = v == null;\n\n                    if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                        queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    actual.onNext(v);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "408", "src_id": "M1163", "code": "\n        @Override\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final SimplePlainQueue<Object> queue = this.queue;\n            final Subscriber<? super Flowable<T>> downstream = this.downstream;\n            UnicastProcessor<T> window = this.window;\n\n            for (;;) {\n                if (upstreamCancelled) {\n                    queue.clear();\n                    window = null;\n                    this.window = null;\n                } else {\n                    final boolean isDone = done;\n                    final Object o = queue.poll();\n                    final boolean isEmpty = o == null;\n\n                    if (isDone && isEmpty) {\n                        final Throwable ex = error;\n                        if (ex != null) {\n                            if (window != null) {\n                                window.onError(ex);\n                            }\n                            downstream.onError(ex);\n                        } else {\n                            if (window != null) {\n                                window.onComplete();\n                            }\n                            downstream.onComplete();\n                        }\n                        cleanupResources();\n                        upstreamCancelled = true;\n                        continue;\n                    } else if (!isEmpty) {\n                        if (o instanceof WindowBoundaryRunnable) {\n                            final WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                            if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            }\n                        } else if (window != null) {\n                            @SuppressWarnings(\"unchecked\")\n                            final T item = (T) o;\n                            window.onNext(item);\n\n                            final long count = this.count + 1;\n                            if (count == maxSize) {\n                                this.count = 0;\n                                window = createNewWindow(window);\n                            } else {\n                                this.count = count;\n                            }\n                        }\n                        continue;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "409", "src_id": "M478", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final EqualObserver<T>[] as = observers;\n            final EqualObserver<T> observer1 = as[0];\n            final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n            final EqualObserver<T> observer2 = as[1];\n            final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        q1.clear();\n                        q2.clear();\n                        return;\n                    }\n\n                    final boolean d1 = observer1.done;\n                    if (d1) {\n                        final Throwable e = observer1.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    final boolean d2 = observer2.done;\n                    if (d2) {\n                        final Throwable e = observer2.error;\n                        if (e != null) {\n                            cancel(q1, q2);\n                            downstream.onError(e);\n                            return;\n                        }\n                    }\n\n                    if (v1 == null) {\n                        v1 = q1.poll();\n                    }\n                    final boolean e1 = v1 == null;\n\n                    if (v2 == null) {\n                        v2 = q2.poll();\n                    }\n                    final boolean e2 = v2 == null;\n\n                    if (d1 && d2 && e1 && e2) {\n                        downstream.onSuccess(true);\n                        return;\n                    }\n                    if ((d1 && d2) && (e1 != e2)) {\n                        cancel(q1, q2);\n                        downstream.onSuccess(false);\n                        return;\n                    }\n\n                    if (!e1 && !e2) {\n                        final boolean comparisonResult;\n                        try {\n                            comparisonResult = comparer.test(v1, v2);\n                        } catch (final Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            cancel(q1, q2);\n                            downstream.onError(ex);\n                            return;\n                        }\n\n                        if (!comparisonResult) {\n                            cancel(q1, q2);\n                            downstream.onSuccess(false);\n                            return;\n                        }\n\n                        v1 = null;\n                        v2 = null;\n                    }\n\n                    if (e1 || e2) {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "410", "src_id": "M885", "code": "\n        void drainLoop() {\n            int missed = 1;\n            final JoinInnerSubscriber<T>[] s = this.subscribers;\n            final int n = s.length;\n            final Subscriber<? super T> a = this.downstream;\n\n            for (;;) {\n                final long r = requested.get();\n                long e = 0;\n\n                middle:\n                while (e != r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    final Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    final boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < s.length; i++) {\n                        final JoinInnerSubscriber<T> inner = s[i];\n                        final SimplePlainQueue<T> q = inner.queue;\n                        if (q != null) {\n                            final T v = q.poll();\n                            if (v != null) {\n                                empty = false;\n                                a.onNext(v);\n                                inner.requestOne();\n                                if (++e == r) {\n                                    break middle;\n                                }\n                            }\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        cleanup();\n                        return;\n                    }\n\n                    final Throwable ex = errors.get();\n                    if (ex != null) {\n                        cleanup();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    final boolean d = done.get() == 0;\n                    boolean empty = true;\n\n                    for (int i = 0; i < n; i++) {\n                        final JoinInnerSubscriber<T> inner = s[i];\n                        final SimpleQueue<T> q = inner.queue;\n                        if (q != null && !q.isEmpty()) {\n                            empty = false;\n                            break;\n                        }\n                    }\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n\n                if (e != 0) {\n                    BackpressureHelper.produced(requested, e);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "411", "src_id": "M1399", "code": "\n        @Override\n        public void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            InnerQueuedSubscriber<R> inner = current;\n            final Subscriber<? super R> a = downstream;\n            final ErrorMode em = errorMode;\n\n            for (;;) {\n                final long r = requested.get();\n                long e = 0L;\n\n                if (inner == null) {\n                    if (em != ErrorMode.END) {\n                        final Throwable ex = errors.get();\n                        if (ex != null) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    final boolean outerDone = done;\n                    inner = subscribers.poll();\n\n                    if (outerDone && inner == null) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (inner != null) {\n                        current = inner;\n                    }\n                }\n\n                boolean continueNextSource = false;\n\n                if (inner != null) {\n                    final SimpleQueue<R> q = inner.queue();\n                    if (q != null) {\n                        while (e != r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                final Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            final boolean d = inner.isDone();\n                            final R v;\n                            try {\n                                v = q.poll();\n                            } catch (final Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                current = null;\n                                inner.cancel();\n                                cancelAll();\n                                a.onError(ex);\n                                return;\n                            }\n\n                            final boolean empty = v == null;\n\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                                break;\n                            }\n\n                            if (empty) {\n                                break;\n                            }\n\n                            a.onNext(v);\n                            e++;\n                            inner.request(1L);\n                        }\n\n                        if (e == r) {\n                            if (cancelled) {\n                                cancelAll();\n                                return;\n                            }\n\n                            if (em == ErrorMode.IMMEDIATE) {\n                                final Throwable ex = errors.get();\n                                if (ex != null) {\n                                    current = null;\n                                    inner.cancel();\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(downstream);\n                                    return;\n                                }\n                            }\n\n                            final boolean d = inner.isDone();\n                            final boolean empty = q.isEmpty();\n\n                            if (d && empty) {\n                                inner = null;\n                                current = null;\n                                upstream.request(1);\n                                continueNextSource = true;\n                            }\n                        }\n                    }\n                }\n\n                if (e != 0L && r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n\n                if (continueNextSource) {\n                    continue;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "412", "src_id": "M469", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(final CacheDisposable<T> consumer) {\n        for (;;) {\n            final CacheDisposable<T>[] current = observers.get();\n            final int n = current.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (current[i] == consumer) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            final CacheDisposable<T>[] next;\n            if (n == 1) {\n                next = EMPTY;\n            } else {\n                next = new CacheDisposable[n - 1];\n                System.arraycopy(current, 0, next, 0, j);\n                System.arraycopy(current, j + 1, next, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(current, next)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "413", "src_id": "M362", "code": "\n        void drainFused() {\n            int missed = 1;\n\n            for (;;) {\n                if (disposed) {\n                    return;\n                }\n\n                final boolean d = done;\n                final Throwable ex = error;\n\n                if (!delayError && d && ex != null) {\n                    disposed = true;\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                downstream.onNext(null);\n\n                if (d) {\n                    disposed = true;\n                    final Throwable finalEx = error;\n                    if (finalEx != null) {\n                        downstream.onError(finalEx);\n                    } else {\n                        downstream.onComplete();\n                    }\n                    worker.dispose();\n                    return;\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "414", "src_id": "M2247", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(final PublishSubscription<T> ps) {\n        for (;;) {\n            final PublishSubscription<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n\n            final int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            final PublishSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "415", "src_id": "M66", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    Observer<? super R> downstream = this.downstream;\n    AtomicThrowable errors = this.errors;\n    AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n    for (;;) {\n        for (;;) {\n            if (cancelled) {\n                return;\n            }\n\n            if (errors.get() != null) {\n                if (!delayErrors) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n            }\n\n            boolean d = done;\n            SwitchMapMaybeObserver<R> current = inner.get();\n            boolean empty = current == null;\n\n            if (d && empty) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            if (empty || current.item == null) {\n                break;\n            }\n\n            inner.compareAndSet(current, null);\n            downstream.onNext(current.item);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "416", "src_id": "M1333", "code": "\n@Override\npublic void onNext(T t) {\n    if (done) {\n        return;\n    }\n\n    boolean b;\n    try {\n        b = predicate.test(t);\n    } catch (Throwable e) {\n        Exceptions.throwIfFatal(e);\n        upstream.cancel();\n        upstream = SubscriptionHelper.CANCELLED;\n        onError(e);\n        return;\n    }\n\n    if (!b) {\n        done = true;\n        upstream.cancel();\n        upstream = SubscriptionHelper.CANCELLED;\n        downstream.onSuccess(false);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "417", "src_id": "M522", "code": "\nvoid drainLoop() {\n    Observer<? super T> actual = this.downstream;\n    int missed = 1;\n\n    for (;;) {\n        for (;;) {\n            if (disposed) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(actual);\n                return;\n            }\n\n            int os = otherState;\n            if (os == OTHER_STATE_HAS_VALUE) {\n                T v = singleItem;\n                singleItem = null;\n                otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                actual.onNext(v);\n            }\n\n            boolean d = mainDone;\n            SimplePlainQueue<T> q = queue;\n            T v = q != null ? q.poll() : null;\n            boolean empty = v == null;\n\n            if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                queue = null;\n                actual.onComplete();\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            actual.onNext(v);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "418", "src_id": "M1163", "code": "\n@Override\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    final SimplePlainQueue<Object> queue = this.queue;\n    final Subscriber<? super Flowable<T>> downstream = this.downstream;\n    UnicastProcessor<T> window = this.window;\n\n    for (;;) {\n        if (upstreamCancelled) {\n            queue.clear();\n            window = null;\n            this.window = null;\n        } else {\n            boolean isDone = done;\n            Object o = queue.poll();\n            boolean isEmpty = o == null;\n\n            if (isDone && isEmpty) {\n                Throwable ex = error;\n                if (ex != null) {\n                    if (window != null) {\n                        window.onError(ex);\n                    }\n                    downstream.onError(ex);\n                } else {\n                    if (window != null) {\n                        window.onComplete();\n                    }\n                    downstream.onComplete();\n                }\n                cleanupResources();\n                upstreamCancelled = true;\n                continue;\n            } else if (!isEmpty) {\n                if (o instanceof WindowBoundaryRunnable) {\n                    WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                    if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                        this.count = 0;\n                        window = createNewWindow(window);\n                    }\n                } else if (window != null) {\n                    @SuppressWarnings(\"unchecked\")\n                    T item = (T) o;\n                    window.onNext(item);\n\n                    long count = this.count + 1;\n                    if (count == maxSize) {\n                        this.count = 0;\n                        window = createNewWindow(window);\n                    } else {\n                        this.count = count;\n                    }\n                }\n                continue;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "419", "src_id": "M478", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    EqualObserver<T>[] as = observers;\n\n    final EqualObserver<T> observer1 = as[0];\n    final SpscLinkedArrayQueue<T> q1 = observer1.queue;\n    final EqualObserver<T> observer2 = as[1];\n    final SpscLinkedArrayQueue<T> q2 = observer2.queue;\n\n    for (;;) {\n        for (;;) {\n            if (cancelled) {\n                q1.clear();\n                q2.clear();\n                return;\n            }\n\n            boolean d1 = observer1.done;\n            if (d1) {\n                Throwable e = observer1.error;\n                if (e != null) {\n                    cancel(q1, q2);\n                    downstream.onError(e);\n                    return;\n                }\n            }\n\n            boolean d2 = observer2.done;\n            if (d2) {\n                Throwable e = observer2.error;\n                if (e != null) {\n                    cancel(q1, q2);\n                    downstream.onError(e);\n                    return;\n                }\n            }\n\n            if (v1 == null) {\n                v1 = q1.poll();\n            }\n            boolean e1 = v1 == null;\n\n            if (v2 == null) {\n                v2 = q2.poll();\n            }\n            boolean e2 = v2 == null;\n\n            if (d1 && d2 && e1 && e2) {\n                downstream.onSuccess(true);\n                return;\n            }\n            if ((d1 && d2) && (e1 != e2)) {\n                cancel(q1, q2);\n                downstream.onSuccess(false);\n                return;\n            }\n\n            if (!e1 && !e2) {\n                boolean c;\n                try {\n                    c = comparer.test(v1, v2);\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    cancel(q1, q2);\n                    downstream.onError(ex);\n                    return;\n                }\n\n                if (!c) {\n                    cancel(q1, q2);\n                    downstream.onSuccess(false);\n                    return;\n                }\n\n                v1 = null;\n                v2 = null;\n            }\n\n            if (e1 || e2) {\n                break;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "420", "src_id": "M885", "code": "\nvoid drainLoop() {\n    int missed = 1;\n\n    JoinInnerSubscriber<T>[] s = this.subscribers;\n    int n = s.length;\n    Subscriber<? super T> a = this.downstream;\n\n    for (;;) {\n        long r = requested.get();\n        long e = 0;\n\n        middle: while (e != r) {\n            if (cancelled) {\n                cleanup();\n                return;\n            }\n\n            Throwable ex = errors.get();\n            if (ex != null) {\n                cleanup();\n                a.onError(ex);\n                return;\n            }\n\n            boolean d = done.get() == 0;\n            boolean empty = true;\n\n            for (int i = 0; i < s.length; i++) {\n                JoinInnerSubscriber<T> inner = s[i];\n                SimplePlainQueue<T> q = inner.queue;\n                if (q != null) {\n                    T v = q.poll();\n                    if (v != null) {\n                        empty = false;\n                        a.onNext(v);\n                        inner.requestOne();\n                        if (++e == r) {\n                            break middle;\n                        }\n                    }\n                }\n            }\n\n            if (d && empty) {\n                a.onComplete();\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                cleanup();\n                return;\n            }\n\n            Throwable ex = errors.get();\n            if (ex != null) {\n                cleanup();\n                a.onError(ex);\n                return;\n            }\n\n            boolean d = done.get() == 0;\n            boolean empty = true;\n\n            for (int i = 0; i < n; i++) {\n                JoinInnerSubscriber<T> inner = s[i];\n                SimpleQueue<T> q = inner.queue;\n                if (q != null && !q.isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n\n            if (d && empty) {\n                a.onComplete();\n                return;\n            }\n        }\n\n        if (e != 0) {\n            BackpressureHelper.produced(requested, e);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "421", "src_id": "M1399", "code": "\n@Override\npublic void drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    InnerQueuedSubscriber<R> inner = current;\n    Subscriber<? super R> a = downstream;\n    ErrorMode em = errorMode;\n\n    for (;;) {\n        long r = requested.get();\n        long e = 0L;\n\n        if (inner == null) {\n            if (em != ErrorMode.END) {\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n            }\n\n            boolean outerDone = done;\n            inner = subscribers.poll();\n\n            if (outerDone && inner == null) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            if (inner != null) {\n                current = inner;\n            }\n        }\n\n        boolean continueNextSource = false;\n\n        if (inner != null) {\n            SimpleQueue<R> q = inner.queue();\n            if (q != null) {\n                while (e != r) {\n                    if (cancelled) {\n                        cancelAll();\n                        return;\n                    }\n\n                    if (em == ErrorMode.IMMEDIATE) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean d = inner.isDone();\n                    R v;\n                    try {\n                        v = q.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        current = null;\n                        inner.cancel();\n                        cancelAll();\n                        a.onError(ex);\n                        return;\n                    }\n\n                    boolean empty = v == null;\n                    if (d && empty) {\n                        inner = null;\n                        current = null;\n                        upstream.request(1);\n                        continueNextSource = true;\n                        break;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    a.onNext(v);\n                    e++;\n                    inner.request(1L);\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        cancelAll();\n                        return;\n                    }\n\n                    if (em == ErrorMode.IMMEDIATE) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            current = null;\n                            inner.cancel();\n                            cancelAll();\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean d = inner.isDone();\n                    boolean empty = q.isEmpty();\n                    if (d && empty) {\n                        inner = null;\n                        current = null;\n                        upstream.request(1);\n                        continueNextSource = true;\n                    }\n                }\n            }\n        }\n\n        if (e != 0L && r != Long.MAX_VALUE) {\n            requested.addAndGet(-e);\n        }\n\n        if (continueNextSource) {\n            continue;\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "422", "src_id": "M469", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid remove(CacheDisposable<T> consumer) {\n    for (;;) {\n        CacheDisposable<T>[] current = observers.get();\n        int n = current.length;\n        if (n == 0) {\n            return;\n        }\n\n        int j = -1;\n        for (int i = 0; i < n; i++) {\n            if (current[i] == consumer) {\n                j = i;\n                break;\n            }\n        }\n\n        if (j < 0) {\n            return;\n        }\n\n        CacheDisposable<T>[] next;\n        if (n == 1) {\n            next = EMPTY;\n        } else {\n            next = new CacheDisposable[n - 1];\n            System.arraycopy(current, 0, next, 0, j);\n            System.arraycopy(current, j + 1, next, j, n - j - 1);\n        }\n\n        if (observers.compareAndSet(current, next)) {\n            return;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "423", "src_id": "M362", "code": "\nvoid drainFused() {\n    int missed = 1;\n\n    for (;;) {\n        if (disposed) {\n            return;\n        }\n\n        boolean d = done;\n        Throwable ex = error;\n\n        if (!delayError && d && ex != null) {\n            disposed = true;\n            downstream.onError(error);\n            worker.dispose();\n            return;\n        }\n\n        downstream.onNext(null);\n\n        if (d) {\n            disposed = true;\n            ex = error;\n            if (ex != null) {\n                downstream.onError(ex);\n            } else {\n                downstream.onComplete();\n            }\n            worker.dispose();\n            return;\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "424", "src_id": "M2247", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid remove(PublishSubscription<T> ps) {\n    for (;;) {\n        PublishSubscription<T>[] a = subscribers.get();\n        if (a == TERMINATED || a == EMPTY) {\n            return;\n        }\n\n        int n = a.length;\n        int j = -1;\n        for (int i = 0; i < n; i++) {\n            if (a[i] == ps) {\n                j = i;\n                break;\n            }\n        }\n\n        if (j < 0) {\n            return;\n        }\n\n        PublishSubscription<T>[] b;\n        if (n == 1) {\n            b = EMPTY;\n        } else {\n            b = new PublishSubscription[n - 1];\n            System.arraycopy(a, 0, b, 0, j);\n            System.arraycopy(a, j + 1, b, j, n - j - 1);\n        }\n\n        if (subscribers.compareAndSet(a, b)) {\n            return;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}

{"project_name": "across-project", "pair_id": "1", "src_id": "M662", "code": "\nprivate void finishing(Advice advice) {\n    try {\n        double cost = threadLocalWatch.costInMillis();\n        boolean conditionResult = isConditionMet(command.getConditionExpress(), advice, cost);\n        \n        if (this.isVerbose()) {\n            process.write(\"Condition express: {} , result: {}\\n\", \n                           command.getConditionExpress(), conditionResult);\n        }\n        \n        if (conditionResult) {\n            StackModel stackModel = ThreadUtil.getThreadStackModel(advice.getLoader(), Thread.currentThread());\n            stackModel.setTs(LocalDateTime.now());\n            process.appendResult(stackModel);\n            process.times().incrementAndGet();\n            \n            if (isLimitExceeded(command.getNumberOfLimit(), process.times().get())) {\n                abortProcess(process, command.getNumberOfLimit());\n            }\n        }\n    } catch (Throwable e) {\n        logger.warn(\"Stack processing failed. Condition: {}, Error: {}\", \n                    command.getConditionExpress(), e.getMessage(), e);\n        process.end(-1, \"Stack processing failed. Condition: \" + command.getConditionExpress() + \n                   \", \" + e.getMessage() + \". See \" + LogUtil.loggingFile() + \" for details.\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "2", "src_id": "M1051", "code": "\nprivate Process createProcess(Session session, List<CliToken> line, InternalCommandManager commandManager, \n                             int jobId, Term term, ResultDistributor resultDistributor) {\n    try {\n        ListIterator<CliToken> tokens = line.listIterator();\n        while (tokens.hasNext()) {\n            CliToken token = tokens.next();\n            if (token.isText()) {\n                checkPermission(session, token);\n                Command command = commandManager.getCommand(token.value());\n                \n                if (command == null) {\n                    throw new IllegalArgumentException(\"Command not found: \" + token.value());\n                }\n                return createCommandProcess(command, tokens, jobId, term, resultDistributor);\n            }\n        }\n        throw new IllegalArgumentException(\"No valid command tokens found\");\n    } catch (Exception e) {\n        throw new RuntimeException(\"Process creation failed\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "3", "src_id": "M464", "code": "\nprivate void initCommands(List<String> disabledCommands) {\n    List<Class<? extends AnnotatedCommand>> commandClassList = new ArrayList<>(50);\n    Collections.addAll(commandClassList,\n        HelpCommand.class, AuthCommand.class, KeymapCommand.class, SearchClassCommand.class,\n        SearchMethodCommand.class, ClassLoaderCommand.class, JadCommand.class, GetStaticCommand.class,\n        MonitorCommand.class, StackCommand.class, ThreadCommand.class, TraceCommand.class,\n        WatchCommand.class, TimeTunnelCommand.class, JvmCommand.class, MemoryCommand.class,\n        PerfCounterCommand.class, OgnlCommand.class, MemoryCompilerCommand.class, RedefineCommand.class,\n        RetransformCommand.class, DashboardCommand.class, DumpClassCommand.class, HeapDumpCommand.class,\n        JulyCommand.class, ThanksCommand.class, OptionsCommand.class, ClsCommand.class, ResetCommand.class,\n        VersionCommand.class, SessionCommand.class, SystemPropertyCommand.class, SystemEnvCommand.class,\n        VMOptionCommand.class, LoggerCommand.class, HistoryCommand.class, CatCommand.class,\n        Base64Command.class, EchoCommand.class, PwdCommand.class, MBeanCommand.class,\n        GrepCommand.class, TeeCommand.class, ProfilerCommand.class, VmToolCommand.class,\n        StopCommand.class);\n\n    try {\n        if (ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Recording.class\") != null) {\n            commandClassList.add(JFRCommand.class);\n        }\n    } catch (Throwable e) {\n        logger.error(\"JDK version does not support JFR command\", e);\n    }\n\n    for (Class<? extends AnnotatedCommand> clazz : commandClassList) {\n        Name name = clazz.getAnnotation(Name.class);\n        if (name != null && name.value() != null && disabledCommands.contains(name.value())) {\n            continue;\n        }\n        commands.add(Command.create(clazz));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "4", "src_id": "M1305", "code": "\npublic synchronized EnhancerAffect enhance(final Instrumentation inst, int maxNumOfMatchedClass) \n        throws UnmodifiableClassException {\n        \n    this.matchingClasses = GlobalOptions.isDisableSubClass\n        ? SearchUtils.searchClass(inst, classNameMatcher)\n        : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n    if (matchingClasses.size() > maxNumOfMatchedClass) {\n        affect.setOverLimitMsg(\"Matched classes exceeded limit: \" + matchingClasses.size() + \n                              \" > \" + maxNumOfMatchedClass + \". Use '-m' to adjust limit.\");\n        return affect;\n    }\n\n    List<Pair<Class<?>, String>> filteredList = filter(matchingClasses);\n    for (Pair<Class<?>, String> filtered : filteredList) {\n        logger.info(\"Ignoring class: {}, Reason: {}\", filtered.getFirst().getName(), filtered.getSecond());\n    }\n\n    logger.info(\"Enhancing matched classes: {}\", matchingClasses);\n    affect.setTransformer(this);\n\n    try {\n        ArthasBootstrap.getInstance().getTransformerManager().addTransformer(this, isTracing);\n\n        if (GlobalOptions.isBatchReTransform) {\n            Class<?>[] classArray = matchingClasses.toArray(new Class<?>[0]);\n            if (classArray.length > 0) {\n                inst.retransformClasses(classArray);\n                logger.info(\"Batch transform successful: {}\", Arrays.toString(classArray));\n            }\n        } else {\n            for (Class<?> clazz : matchingClasses) {\n                try {\n                    inst.retransformClasses(clazz);\n                    logger.info(\"Class transformed: {}\", clazz);\n                } catch (Throwable t) {\n                    logger.warn(\"Transform failed: {}\", clazz.getName(), t);\n                    if (t instanceof UnmodifiableClassException) {\n                        throw t;\n                    }\n                    throw new RuntimeException(\"Transformation error\", t);\n                }\n            }\n        }\n    } catch (Throwable e) {\n        logger.error(\"Enhancer error. Classes: {}\", matchingClasses, e);\n        affect.setThrowable(e);\n    }\n    return affect;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "5", "src_id": "M1163", "code": "\npublic static DefaultFullHttpResponse directView(File dir, String path, FullHttpRequest request, \n                                                ChannelHandlerContext ctx) throws IOException {\n    path = path.startsWith(\"/\") ? path.substring(1) : path;\n    File file = new File(dir.getParent(), path);\n\n    if (!isSubFile(dir, file)) {\n        return null;\n    }\n\n    DefaultFullHttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n    if (file.isDirectory()) {\n        if (!path.endsWith(\"/\")) {\n            response.setStatus(HttpResponseStatus.FOUND);\n            response.headers().set(HttpHeaderNames.LOCATION, \"/\" + path + \"/\");\n        }\n        response.content().writeBytes(renderDir(file, !isSameFile(dir, file)).getBytes(StandardCharsets.UTF_8));\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=utf-8\");\n        ctx.write(response);\n        ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).addListener(ChannelFutureListener.CLOSE);\n        return response;\n    }\n\n    if (file.isHidden() || !file.exists() || !file.isFile()) {\n        return null;\n    }\n\n    long fileLength = file.length();\n    if (fileLength < MIN_NETTY_DIRECT_SEND_SIZE) {\n        try (FileInputStream fis = new FileInputStream(file)) {\n            response.content().writeBytes(IOUtils.toByteArray(fis));\n        }\n        HttpUtil.setContentLength(response, response.content().readableBytes());\n        ctx.writeAndFlush(response).addListener(future -> {\n            if (future.isSuccess()) {\n                ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT).addListener(ChannelFutureListener.CLOSE);\n            } else {\n                future.channel().close();\n            }\n        });\n        return response;\n    }\n\n    logger.info(\"Sending large file: {} ({} bytes)\", file.getName(), fileLength);\n    HttpResponse fileResponse = new DefaultHttpResponse(HTTP_1_1, OK);\n    HttpUtil.setContentLength(fileResponse, fileLength);\n    setContentTypeHeader(fileResponse, file);\n    setDateAndCacheHeaders(fileResponse, file);\n    \n    if (HttpUtil.isKeepAlive(request)) {\n        fileResponse.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n    }\n\n    ctx.write(fileResponse);\n    try (RandomAccessFile raf = new RandomAccessFile(file, \"r\")) {\n        ChannelFuture sendFuture;\n        if (ctx.pipeline().get(SslHandler.class) == null) {\n            sendFuture = ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength));\n        } else {\n            sendFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)));\n        }\n\n        sendFuture.addListener((ChannelProgressiveFutureListener) (future, progress, total) -> \n            logger.info(\"{} Transfer: {}/{}\", future.channel(), progress, total));\n\n        if (!HttpUtil.isKeepAlive(request)) {\n            sendFuture.addListener(ChannelFutureListener.CLOSE);\n        }\n    }\n    return response;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "6", "src_id": "M1300", "code": "\n@Override\npublic byte[] transform(final ClassLoader loader, String className, Class<?> redefinedClass,\n                        ProtectionDomain domain, byte[] buffer) throws IllegalClassFormatException {\n    try {\n        if (loader != null) {\n            try {\n                loader.loadClass(SpyAPI.class.getName());\n            } catch (Throwable e) {\n                logger.error(\"SpyAPI load failed. ClassLoader: {}, Class: {}\", \n                             loader.getClass().getName(), className, e);\n                return null;\n            }\n        }\n\n        if (matchingClasses != null && !matchingClasses.contains(redefinedClass)) {\n            return null;\n        }\n\n        ClassNode classNode = new ClassNode(Opcodes.ASM9);\n        ClassReader reader = AsmUtils.toClassNode(buffer, classNode);\n        classNode = AsmUtils.removeJSRInstructions(classNode);\n\n        DefaultInterceptorClassParser parser = new DefaultInterceptorClassParser();\n        List<InterceptorProcessor> processors = new ArrayList<>();\n        processors.addAll(parser.parse(SpyInterceptor1.class));\n        processors.addAll(parser.parse(SpyInterceptor2.class));\n        processors.addAll(parser.parse(SpyInterceptor3.class));\n\n        if (this.isTracing) {\n            if (!this.skipJDKTrace) {\n                processors.addAll(parser.parse(SpyTraceInterceptor1.class));\n                processors.addAll(parser.parse(SpyTraceInterceptor2.class));\n                processors.addAll(parser.parse(SpyTraceInterceptor3.class));\n            } else {\n                processors.addAll(parser.parse(SpyTraceExcludeJDKInterceptor1.class));\n                processors.addAll(parser.parse(SpyTraceExcludeJDKInterceptor2.class));\n                processors.addAll(parser.parse(SpyTraceExcludeJDKInterceptor3.class));\n            }\n        }\n\n        List<MethodNode> matchedMethods = new ArrayList<>();\n        for (MethodNode method : classNode.methods) {\n            if (!isIgnore(method, methodNameMatcher)) {\n                matchedMethods.add(method);\n            }\n        }\n\n        if (AsmUtils.isEnhancerByCGLIB(className)) {\n            for (MethodNode method : matchedMethods) {\n                if (AsmUtils.isConstructor(method)) {\n                    AsmUtils.fixConstructorExceptionTable(method);\n                }\n            }\n        }\n\n        GroupLocationFilter filter = new GroupLocationFilter();\n        filter.addFilter(new InvokeContainLocationFilter(Type.getInternalName(SpyAPI.class), \"atEnter\", LocationType.ENTER));\n        filter.addFilter(new InvokeContainLocationFilter(Type.getInternalName(SpyAPI.class), \"atExit\", LocationType.EXIT));\n        filter.addFilter(new InvokeContainLocationFilter(Type.getInternalName(SpyAPI.class), \"atExceptionExit\", LocationType.EXCEPTION_EXIT));\n        filter.addFilter(new InvokeCheckLocationFilter(Type.getInternalName(SpyAPI.class), \"atBeforeInvoke\", LocationType.INVOKE));\n        filter.addFilter(new InvokeCheckLocationFilter(Type.getInternalName(SpyAPI.class), \"atInvokeException\", LocationType.INVOKE_COMPLETED));\n        filter.addFilter(new InvokeCheckLocationFilter(Type.getInternalName(SpyAPI.class), \"atInvokeException\", LocationType.INVOKE_EXCEPTION_EXIT));\n\n        for (MethodNode method : matchedMethods) {\n            if (AsmUtils.isNative(method)) {\n                logger.info(\"Skipping native method: {}\", \n                           AsmUtils.methodDeclaration(Type.getObjectType(classNode.name), method));\n                continue;\n            }\n\n            if (AsmUtils.containsMethodInsnNode(method, Type.getInternalName(SpyAPI.class), \"atBeforeInvoke\")) {\n                for (AbstractInsnNode insn : method.instructions) {\n                    if (insn instanceof MethodInsnNode) {\n                        MethodInsnNode minsn = (MethodInsnNode) insn;\n                        if (this.skipJDKTrace && minsn.owner.startsWith(\"java/\")) continue;\n                        if (AsmOpUtils.isBoxType(Type.getObjectType(minsn.owner))) continue;\n                        AdviceListenerManager.registerTraceAdviceListener(loader, className, \n                                                                         minsn.owner, minsn.name, \n                                                                         minsn.desc, listener);\n                    }\n                }\n            } else {\n                MethodProcessor processor = new MethodProcessor(classNode, method, filter);\n                for (InterceptorInterceptor interceptor : processors) {\n                    try {\n                        for (Location loc : interceptor.process(processor)) {\n                            if (loc instanceof MethodInsnNodeWare) {\n                                MethodInsnNodeWare node = (MethodInsnNodeWare) loc;\n                                MethodInsnNode minsn = node.methodInsnNode();\n                                AdviceListenerManager.registerTraceAdviceListener(loader, className, \n                                                                                 minsn.owner, minsn.name, \n                                                                                 minsn.desc, listener);\n                            }\n                        }\n                    } catch (Throwable e) {\n                        logger.error(\"Interceptor error. Class: {}, Method: {}, Interceptor: {}\", \n                                     classNode.name, method.name, interceptor.getClass().getName(), e);\n                    }\n                }\n            }\n\n            AdviceListenerManager.registerAdviceListener(loader, className, method.name, method.desc, listener);\n            affect.addMethodAndCount(loader, className, method.name, method.desc);\n        }\n\n        if (AsmUtils.getMajorVersion(classNode.version) < 49) {\n            classNode.version = AsmUtils.setMajorVersion(classNode.version, 49);\n        }\n\n        byte[] enhanced = AsmUtils.toBytes(classNode, loader, reader);\n        classBytesCache.put(redefinedClass, new Object());\n        dumpClassIfNecessary(className, enhanced, affect);\n        affect.cCnt(1);\n        return enhanced;\n    } catch (Throwable t) {\n        logger.warn(\"Transform failed. Loader: {}, Class: {}\", loader, className, t);\n        affect.setThrowable(t);\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "7", "src_id": "M982", "code": "\npublic static boolean completeMethodName(Completion completion) {\n    List<CliToken> tokens = completion.lineTokens();\n    String lastToken = tokens.isEmpty() ? \"\" : tokens.get(tokens.size() - 1).value();\n\n    String className = tokens.size() < 2 ? \"\" : \n        StringUtils.isBlank(lastToken) \n            ? tokens.get(tokens.size() - 2).value() \n            : tokens.get(tokens.size() - 3).value();\n\n    Set<Class<?>> classes = SearchUtils.searchClassOnly(\n        completion.session().getInstrumentation(), className, 2);\n    \n    if (classes.size() != 1) {\n        completion.complete(Collections.emptyList());\n        return true;\n    }\n\n    Class<?> clazz = classes.iterator().next();\n    List<String> methods = new ArrayList<>();\n    for (Method method : clazz.getDeclaredMethods()) {\n        if (StringUtils.isBlank(lastToken) || method.getName().startsWith(lastToken)) {\n            methods.add(method.getName());\n        }\n    }\n    methods.add(\"<init>\");\n\n    if (methods.size() == 1) {\n        completion.complete(methods.get(0).substring(lastToken.length()), true);\n    } else {\n        CompletionUtils.complete(completion, methods);\n    }\n    return true;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "8", "src_id": "M249", "code": "\nprivate void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String uri) \n        throws URISyntaxException {\n        \n    QueryStringDecoder decoder = new QueryStringDecoder(uri);\n    Map<String, List<String>> params = decoder.parameters();\n\n    String appName = extractFirstParam(params, URIConstans.APP_NAME);\n    String id = generateAgentId(appName);\n    id = extractFirstParam(params, URIConstans.ID, id);\n    String arthasVersion = extractFirstParam(params, URIConstans.ARTHAS_VERSION);\n\n    AgentInfo info = new AgentInfo();\n    String clientIp = HttpUtils.findClientIP(handshake.requestHeaders());\n    \n    if (clientIp == null && ctx.channel().remoteAddress() instanceof InetSocketAddress) {\n        InetSocketAddress addr = (InetSocketAddress) ctx.channel().remoteAddress();\n        info.setHost(addr.getHostString());\n        info.setPort(addr.getPort());\n    } else {\n        info.setHost(clientIp);\n        Integer port = HttpUtils.findClientPort(handshake.requestHeaders());\n        if (port != null) info.setPort(port);\n    }\n\n    info.setChannelHandlerContext(ctx);\n    if (arthasVersion != null) info.setArthasVersion(arthasVersion);\n\n    tunnelServer.addAgent(id, info);\n    ctx.channel().closeFuture().addListener(future -> tunnelServer.removeAgent(id));\n\n    URI responseUri = UriComponentsBuilder.newInstance()\n        .scheme(URIConstans.RESPONSE)\n        .path(\"/\")\n        .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n        .queryParam(URIConstans.ID, id)\n        .build()\n        .toUri();\n        \n    ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n}\n\nprivate String generateAgentId(String appName) {\n    String random = RandomStringUtils.random(20, true, true).toUpperCase();\n    return appName != null ? appName + \"_\" + random : random;\n}\n\nprivate String extractFirstParam(Map<String, List<String>> params, String key) {\n    return extractFirstParam(params, key, null);\n}\n\nprivate String extractFirstParam(Map<String, List<String>> params, String key, String defaultValue) {\n    List<String> values = params.get(key);\n    return (values != null && !values.isEmpty()) ? values.get(0) : defaultValue;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "9", "src_id": "M173", "code": "\n@Override\npublic int[] startSubnegotiationLocal() {\n    int windowSize = m_nWidth * 0x10000 + m_nHeight;\n    int responseSize = 5;\n    \n    if ((m_nWidth % 0xFF) == 0xFF) responseSize++;\n    if ((m_nWidth / 0x100) == 0xFF) responseSize++;\n    if ((m_nHeight % 0xFF) == 0xFF) responseSize++;\n    if ((m_nHeight / 0x100) == 0xFF) responseSize++;\n\n    int[] response = new int[responseSize];\n    response[0] = WINDOW_SIZE;\n\n    for (int idx = 1, shift = 24; idx < responseSize; idx++, shift -= 8) {\n        int mask = 0xFF << shift;\n        response[idx] = (windowSize & mask) >>> shift;\n        \n        if (response[idx] == 0xFF) {\n            response[++idx] = 0xFF;\n        }\n    }\n    return response;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "10", "src_id": "M1370", "code": "\npublic static URL[] getUrls(ClassLoader loader) {\n    if (loader instanceof URLClassLoader) {\n        try {\n            return ((URLClassLoader) loader).getURLs();\n        } catch (Throwable e) {\n            logger.error(\"URL retrieval failed. ClassLoader: {}\", loader, e);\n        }\n    }\n\n    if (loader.getClass().getName().startsWith(\"jdk.internal.loader.ClassLoaders$\")) {\n        try {\n            Field unsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n            unsafeField.setAccessible(true);\n            Unsafe unsafe = (Unsafe) unsafeField.get(null);\n\n            Class<?> clazz = loader.getClass();\n            Field ucpField = null;\n            while (ucpField == null && !clazz.equals(Object.class)) {\n                try {\n                    ucpField = clazz.getDeclaredField(\"ucp\");\n                } catch (NoSuchFieldException ex) {\n                    clazz = clazz.getSuperclass();\n                }\n            }\n            if (ucpField == null) return null;\n\n            Object ucp = unsafe.getObject(loader, unsafe.objectFieldOffset(ucpField));\n            if (ucp == null) return null;\n\n            Field pathField = ucpField.getType().getDeclaredField(\"path\");\n            ArrayList<URL> path = (ArrayList<URL>) unsafe.getObject(ucp, unsafe.objectFieldOffset(pathField));\n            return path.toArray(new URL[0]);\n        } catch (Throwable e) {\n            logger.debug(\"Advanced URL retrieval failed\", e);\n        }\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "11", "src_id": "M828", "code": "\nprivate Minf parseMinf(Box ref) throws IOException {\n    Minf obj = new Minf();\n    Box b;\n    while ((b = untilAnyBox(ref)) != null) {\n        switch (b.type) {\n            case ATOM_DINF:\n                obj.dinf = readFullBox(b);\n                break;\n            case ATOM_STBL:\n                obj.stblStsd = parseStbl(b);\n                break;\n            case ATOM_VMHD:\n            case ATOM_SMHD:\n                obj.mhd = readFullBox(b);\n                break;\n        }\n        ensure(b);\n    }\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "12", "src_id": "M824", "code": "\nprivate Moov parseMoov(Box ref) throws IOException {\n    Box b = readBox(ATOM_MVHD);\n    Moov moov = new Moov();\n    moov.mvhd = parseMvhd();\n    ensure(b);\n    \n    ArrayList<Trak> tmp = new ArrayList<>((int) moov.mvhd.nextTrackId);\n    while ((b = untilBox(ref, ATOM_TRAK, ATOM_MVEX)) != null) {\n        switch (b.type) {\n            case ATOM_TRAK:\n                tmp.add(parseTrak(b));\n                break;\n            case ATOM_MVEX:\n                moov.mvexTrex = parseMvex(b, (int) moov.mvhd.nextTrackId);\n                break;\n        }\n        ensure(b);\n    }\n    \n    moov.trak = tmp.toArray(new Trak[0]);\n    return moov;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "13", "src_id": "M1086", "code": "\nprivate ArrayList<Object> getSpecialItems() {\n    synchronized (DownloadManager.this) {\n        ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n        ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n        List<Mission> remove = new ArrayList<>(hidden);\n\n        remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n        int fakeTotal = pending.size();\n        if (fakeTotal > 0) {\n            fakeTotal++;\n        }\n\n        fakeTotal += finished.size();\n        if (finished.size() > 0) {\n            fakeTotal++;\n        }\n\n        ArrayList<Object> list = new ArrayList<>(fakeTotal);\n        if (pending.size() > 0) {\n            list.add(PENDING);\n            list.addAll(pending);\n        }\n        if (finished.size() > 0) {\n            list.add(FINISHED);\n            list.addAll(finished);\n        }\n\n        hasFinished = finished.size() > 0;\n        return list;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "14", "src_id": "M1024", "code": "\n@Override\npublic void run() {\n    if (mMission.current > 0) {\n        mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n    }\n\n    int retryCount = 0;\n    int httpCode = 204;\n\n    while (true) {\n        try {\n            if (mMission.blocks == null && mMission.current == 0) {\n                long finalLength = 0;\n                long lowestSize = Long.MAX_VALUE;\n\n                for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                    mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (Thread.interrupted()) {\n                        return;\n                    }\n                    long length = Utility.getTotalContentLength(mConn);\n\n                    if (i == 0) {\n                        httpCode = mConn.getResponseCode();\n                        mMission.length = length;\n                    }\n\n                    if (length > 0) {\n                        finalLength += length;\n                    }\n                    if (length < lowestSize) {\n                        lowestSize = length;\n                    }\n                }\n\n                mMission.nearLength = finalLength;\n\n                if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                    if (lowestSize < 1) {\n                        mMission.offsets[0] = RESERVE_SPACE_DEFAULT;\n                    } else {\n                        mMission.offsets[0] = lowestSize < RESERVE_SPACE_MAXIMUM ? lowestSize : RESERVE_SPACE_MAXIMUM;\n                    }\n                }\n            } else {\n                mConn = mMission.openConnection(true, 0, 0);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                httpCode = mConn.getResponseCode();\n                mMission.length = Utility.getTotalContentLength(mConn);\n            }\n\n            if (mMission.length == 0 || httpCode == 204) {\n                mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                return;\n            }\n\n            if (mMission.length == -1 && mConn.getResponseCode() == 200) {\n                mMission.blocks = new int[0];\n                mMission.length = 0;\n                mMission.unknownLength = true;\n                if (DEBUG) {\n                    Log.d(TAG, \"falling back (unknown length)\");\n                }\n            } else {\n                mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                synchronized (mMission.LOCK) {\n                    if (mConn.getResponseCode() == 206) {\n                        if (mMission.threadCount > 1) {\n                            int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                            if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) {\n                                count++;\n                            }\n                            mMission.blocks = new int[count];\n                        } else {\n                            mMission.blocks = new int[0];\n                            mMission.unknownLength = false;\n                        }\n                        if (DEBUG) {\n                            Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                        }\n                    } else {\n                        mMission.blocks = new int[0];\n                        mMission.unknownLength = false;\n                        if (DEBUG) {\n                            Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                        }\n                    }\n                }\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n            }\n\n            try (SharpStream fs = mMission.storage.getStream()) {\n                fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                fs.seek(mMission.offsets[mMission.current]);\n            }\n\n            if (!mMission.running || Thread.interrupted()) {\n                return;\n            }\n\n            if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                String entityTag = mConn.getHeaderField(\"ETAG\");\n                String lastModified = mConn.getHeaderField(\"Last-Modified\");\n                MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n\n                if (!TextUtils.isEmpty(entityTag)) {\n                    recovery.setValidateCondition(entityTag);\n                } else if (!TextUtils.isEmpty(lastModified)) {\n                    recovery.setValidateCondition(lastModified);\n                } else {\n                    recovery.setValidateCondition(null);\n                }\n            }\n\n            mMission.running = false;\n            break;\n        } catch (IOException e) {\n            return;\n        } catch (Exception e) {\n            if (!mMission.running || super.isInterrupted()) {\n                return;\n            }\n\n            if (e instanceof DownloadMission.HttpError && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                interrupt();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                return;\n            }\n\n            if (retryCount++ > mMission.maxRetry) {\n                Log.e(TAG, \"initializer failed\", e);\n                mMission.notifyError(e);\n                return;\n            }\n\n            Log.e(TAG, \"initializer failed, retrying\", e);\n        }\n    }\n\n    mMission.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "15", "src_id": "M1099", "code": "\n@SuppressLint(\"DefaultLocale\")\nprivate void updateProgress(ViewHolderItem h) {\n    if (h == null || h.item == null || h.item.mission instanceof FinishedMission) {\n        return;\n    }\n\n    DownloadMission mission = (DownloadMission) h.item.mission;\n    double done = mission.done;\n    long length = mission.getLength();\n    long now = System.currentTimeMillis();\n    boolean hasError = mission.errCode != ERROR_NOTHING;\n\n    h.progress.setMarquee(mission.isRecovering() || !hasError && (!mission.isInitialized() || mission.unknownLength));\n\n    double progress;\n    if (mission.unknownLength) {\n        progress = Double.NaN;\n        h.progress.setProgress(0.0f);\n    } else {\n        progress = done / length;\n    }\n\n    if (hasError) {\n        h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n        h.status.setText(R.string.msg_error);\n    } else if (isNotFinite(progress)) {\n        h.status.setText(UNDEFINED_PROGRESS);\n    } else {\n        h.status.setText(String.format(\"%.2f%%\", progress * 100));\n        h.progress.setProgress(progress);\n    }\n\n    @StringRes int state;\n    String sizeStr = Utility.formatBytes(length).concat(\"  \");\n\n    if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n        h.size.setText(sizeStr);\n        return;\n    } else if (!mission.running) {\n        state = mission.enqueued ? R.string.queued : R.string.paused;\n    } else if (mission.isPsRunning()) {\n        state = R.string.post_processing;\n    } else if (mission.isRecovering()) {\n        state = R.string.recovering;\n    } else {\n        state = 0;\n    }\n\n    if (state != 0) {\n        h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n        h.resetSpeedMeasure();\n        return;\n    }\n\n    if (h.lastTimestamp < 0) {\n        h.size.setText(sizeStr);\n        h.lastTimestamp = now;\n        h.lastDone = done;\n        return;\n    }\n\n    long deltaTime = now - h.lastTimestamp;\n    double deltaDone = done - h.lastDone;\n\n    if (h.lastDone > done) {\n        h.lastDone = done;\n        h.size.setText(sizeStr);\n        return;\n    }\n\n    if (deltaDone > 0 && deltaTime > 0) {\n        float speed = (float) ((deltaDone * 1000d) / deltaTime);\n        float averageSpeed = speed;\n\n        if (h.lastSpeedIdx < 0) {\n            Arrays.fill(h.lastSpeed, speed);\n            h.lastSpeedIdx = 0;\n        } else {\n            for (int i = 0; i < h.lastSpeed.length; i++) {\n                averageSpeed += h.lastSpeed[i];\n            }\n            averageSpeed /= h.lastSpeed.length + 1.0f;\n        }\n\n        String speedStr = Utility.formatSpeed(averageSpeed);\n        String etaStr;\n\n        if (mission.unknownLength) {\n            etaStr = \"\";\n        } else {\n            long eta = (long) Math.ceil((length - done) / averageSpeed);\n            etaStr = Utility.formatBytes((long) done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n        }\n\n        h.size.setText(sizeStr.concat(etaStr).concat(speedStr));\n\n        h.lastTimestamp = now;\n        h.lastDone = done;\n        h.lastSpeed[h.lastSpeedIdx++] = speed;\n\n        if (h.lastSpeedIdx >= h.lastSpeed.length) {\n            h.lastSpeedIdx = 0;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "16", "src_id": "M817", "code": "\nprivate Trun parseTrun() throws IOException {\n    Trun obj = new Trun();\n    obj.bFlags = stream.readInt();\n    obj.entryCount = stream.readInt();\n    \n    obj.entriesRowSize = 0;\n    if (hasFlag(obj.bFlags, 0x0100)) {\n        obj.entriesRowSize += 4;\n    }\n    if (hasFlag(obj.bFlags, 0x0200)) {\n        obj.entriesRowSize += 4;\n    }\n    if (hasFlag(obj.bFlags, 0x0400)) {\n        obj.entriesRowSize += 4;\n    }\n    if (hasFlag(obj.bFlags, 0x0800)) {\n        obj.entriesRowSize += 4;\n    }\n    obj.bEntries = new byte[obj.entriesRowSize * obj.entryCount];\n\n    if (hasFlag(obj.bFlags, 0x0001)) {\n        obj.dataOffset = stream.readInt();\n    }\n    if (hasFlag(obj.bFlags, 0x0004)) {\n        obj.bFirstSampleFlags = stream.readInt();\n    }\n\n    stream.read(obj.bEntries);\n\n    for (int i = 0; i < obj.entryCount; i++) {\n        TrunEntry entry = obj.getEntry(i);\n        if (hasFlag(obj.bFlags, 0x0100)) {\n            obj.chunkDuration += entry.sampleDuration;\n        }\n        if (hasFlag(obj.bFlags, 0x0200)) {\n            obj.chunkSize += entry.sampleSize;\n        }\n        if (hasFlag(obj.bFlags, 0x0800)) {\n            if (!hasFlag(obj.bFlags, 0x0100)) {\n                obj.chunkDuration += entry.sampleCompositionTimeOffset;\n            }\n        }\n    }\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "17", "src_id": "M883", "code": "\nprivate void makeMvhd(long longestTrack) throws IOException {\n    auxWrite(new byte[]{\n        0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00\n    });\n    auxWrite(ByteBuffer.allocate(28)\n            .putLong(time)\n            .putLong(time)\n            .putInt(DEFAULT_TIMESCALE)\n            .putLong(longestTrack)\n            .array()\n    );\n\n    auxWrite(new byte[]{\n        0x00, 0x01, 0x00, 0x00, 0x01, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x40, 0x00, 0x00, 0x00\n    });\n    auxWrite(new byte[24]);\n    auxWrite(ByteBuffer.allocate(4)\n            .putInt(tracks.length + 1)\n            .array()\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "18", "src_id": "M806", "code": "\npublic Mp4DashChunk getNextChunk(boolean infoOnly) throws IOException {\n    Mp4Track track = tracks[selectedTrack];\n    while (stream.available()) {\n        if (chunkZero) {\n            ensure(box);\n            if (!stream.available()) {\n                break;\n            }\n            box = readBox();\n        } else {\n            chunkZero = true;\n        }\n\n        switch (box.type) {\n            case ATOM_MOOF:\n                if (moof != null) {\n                    throw new IOException(\"moof found without mdat\");\n                }\n                moof = parseMoof(box, track.trak.tkhd.trackId);\n\n                if (moof.traf != null) {\n                    if (hasFlag(moof.traf.trun.bFlags, 0x0001)) {\n                        moof.traf.trun.dataOffset -= box.size + 8;\n                        if (moof.traf.trun.dataOffset < 0) {\n                            throw new IOException(\"trun box has wrong data offset, points outside of concurrent mdat box\");\n                        }\n                    }\n\n                    if (moof.traf.trun.chunkSize < 1) {\n                        if (hasFlag(moof.traf.tfhd.bFlags, 0x10)) {\n                            moof.traf.trun.chunkSize = moof.traf.tfhd.defaultSampleSize * moof.traf.trun.entryCount;\n                        } else {\n                            moof.traf.trun.chunkSize = (int) (box.size - 8);\n                        }\n                    }\n                    if (!hasFlag(moof.traf.trun.bFlags, 0x900) && moof.traf.trun.chunkDuration == 0) {\n                        if (hasFlag(moof.traf.tfhd.bFlags, 0x20)) {\n                            moof.traf.trun.chunkDuration = moof.traf.tfhd.defaultSampleDuration * moof.traf.trun.entryCount;\n                        }\n                    }\n                }\n                break;\n            case ATOM_MDAT:\n                if (moof == null) {\n                    throw new IOException(\"mdat found without moof\");\n                }\n                if (moof.traf == null) {\n                    moof = null;\n                    continue;\n                }\n\n                Mp4DashChunk chunk = new Mp4DashChunk();\n                chunk.moof = moof;\n                if (!infoOnly) {\n                    chunk.data = stream.getView(moof.traf.trun.chunkSize);\n                }\n\n                moof = null;\n                stream.skipBytes(chunk.moof.traf.trun.dataOffset);\n                return chunk;\n        }\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "19", "src_id": "M1055", "code": "\npublic void updateMission(Mission mission) {\n    ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n    SQLiteDatabase database = getWritableDatabase();\n    String ts = String.valueOf(mission.timestamp);\n    int rowsAffected;\n\n    if (mission instanceof FinishedMission) {\n        if (mission.storage.isInvalid()) {\n            rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new String[]{ts});\n        } else {\n            rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_PATH + \" = ?\", new String[]{\n                mission.storage.getUri().toString()\n            });\n        }\n    } else {\n        throw new UnsupportedOperationException(\"DownloadMission\");\n    }\n\n    if (rowsAffected != 1) {\n        Log.e(\"FinishedMissionStore\", \"Expected 1 row to be affected by update but got \" + rowsAffected);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "20", "src_id": "M403", "code": "\nprivate void animatePopupOverlayAndFinishService() {\n    final int targetTranslationY = (int) (closeOverlayBinding.closeButton.getRootView().getHeight() - closeOverlayBinding.closeButton.getY());\n\n    closeOverlayBinding.closeButton.animate().setListener(null).cancel();\n    closeOverlayBinding.closeButton.animate()\n        .setInterpolator(new AnticipateInterpolator())\n        .translationY(targetTranslationY)\n        .setDuration(400)\n        .setListener(new AnimatorListenerAdapter() {\n            @Override public void onAnimationCancel(Animator animation) { end(); }\n            @Override public void onAnimationEnd(Animator animation) { end(); }\n            private void end() {\n                windowManager.removeView(closeOverlayBinding.getRoot());\n                closeOverlayBinding = null;\n                player.getService().destroyPlayerAndStopService();\n            }\n        }).start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "21", "src_id": "M260", "code": "\npublic void play() {\n    if (audioReactor == null || playQueue == null || exoPlayerIsNull()) return;\n    \n    if (!isMuted()) audioReactor.requestAudioFocus();\n\n    if (currentState == STATE_COMPLETED) {\n        if (playQueue.getIndex() == 0) seekToDefault();\n        else playQueue.setIndex(0);\n    }\n\n    simpleExoPlayer.play();\n    saveStreamProgressState();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "22", "src_id": "M543", "code": "\nprivate synchronized NotificationCompat.Builder createNotification() {\n    notificationManager = NotificationManagerCompat.from(player.getContext());\n    final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.getContext(), player.getContext().getString(R.string.notification_channel_id));\n    final MediaStyle mediaStyle = new MediaStyle();\n\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n        final int[] compactSlots = initializeNotificationSlots();\n        mediaStyle.setShowActionsInCompactView(compactSlots);\n    }\n    player.UIs().get(MediaSessionPlayerUi.class).flatMap(MediaSessionPlayerUi::getSessionToken).ifPresent(mediaStyle::setMediaSession);\n\n    builder.setStyle(mediaStyle)\n        .setPriority(NotificationCompat.PRIORITY_HIGH)\n        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n        .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n        .setShowWhen(false)\n        .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n        .setColor(ContextCompat.getColor(player.getContext(), R.color.dark_background_color))\n        .setColorized(player.getPrefs().getBoolean(player.getContext().getString(R.string.notification_colorize_key), true))\n        .setDeleteIntent(PendingIntentCompat.getBroadcast(player.getContext(), NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, false));\n\n    setLargeIcon(builder);\n    return builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "23", "src_id": "M225", "code": "\nprivate void onBroadcastReceived(final Intent intent) {\n    if (intent == null || intent.getAction() == null) return;\n\n    switch (intent.getAction()) {\n        case AudioManager.ACTION_AUDIO_BECOMING_NOISY: pause(); break;\n        case ACTION_CLOSE: service.destroyPlayerAndStopService(); break;\n        case ACTION_PLAY_PAUSE: playPause(); break;\n        case ACTION_PLAY_PREVIOUS: playPrevious(); break;\n        case ACTION_PLAY_NEXT: playNext(); break;\n        case ACTION_FAST_REWIND: fastRewind(); break;\n        case ACTION_FAST_FORWARD: fastForward(); break;\n        case ACTION_REPEAT: cycleNextRepeatMode(); break;\n        case ACTION_SHUFFLE: toggleShuffleModeEnabled(); break;\n        case Intent.ACTION_CONFIGURATION_CHANGED: break;\n    }\n\n    UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "24", "src_id": "M631", "code": "\nprotected void addImagesMetadataItem(final LayoutInflater inflater, final LinearLayout layout, @StringRes final int type, final List<Image> images) {\n    final String preferredImageUrl = ImageStrategy.choosePreferredImage(images);\n    if (preferredImageUrl == null) return;\n\n    final ItemMetadataBinding itemBinding = ItemMetadataBinding.inflate(inflater, layout, false);\n    itemBinding.metadataTypeView.setText(type);\n\n    final SpannableStringBuilder urls = new SpannableStringBuilder();\n    for (final Image image : images) {\n        if (urls.length() != 0) urls.append(\", \");\n        final int entryBegin = urls.length();\n\n        if (image.getHeight() != Image.HEIGHT_UNKNOWN || image.getWidth() != Image.WIDTH_UNKNOWN || image.getEstimatedResolutionLevel() == Image.ResolutionLevel.UNKNOWN) {\n            urls.append(imageSizeToText(image.getHeight())).append('x').append(imageSizeToText(image.getWidth()));\n        } else {\n            switch (image.getEstimatedResolutionLevel()) {\n                case LOW -> urls.append(getString(R.string.image_quality_low));\n                case MEDIUM -> urls.append(getString(R.string.image_quality_medium));\n                case HIGH -> urls.append(getString(R.string.image_quality_high));\n                default -> {}\n            }\n        }\n\n        urls.setSpan(new ClickableSpan() {\n            @Override public void onClick(@NonNull View widget) {\n                ShareUtils.openUrlInBrowser(requireContext(), image.getUrl());\n            }\n        }, entryBegin, urls.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n        if (preferredImageUrl.equals(image.getUrl())) {\n            urls.setSpan(new StyleSpan(Typeface.BOLD), entryBegin, urls.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n    }\n\n    itemBinding.metadataContentView.setText(urls);\n    itemBinding.metadataContentView.setMovementMethod(LinkMovementMethod.getInstance());\n    layout.addView(itemBinding.getRoot());\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "25", "src_id": "M12", "code": "\nprivate void openDetailFragmentFromCommentReplies(@NonNull FragmentManager fm, boolean popBackStack) {\n    @Nullable String fragmentUnderEntryName;\n    if (fm.getBackStackEntryCount() < 2) fragmentUnderEntryName = null;\n    else fragmentUnderEntryName = fm.getBackStackEntryAt(fm.getBackStackEntryCount() - 2).getName();\n\n    @Nullable CommentRepliesFragment repliesFragment = (CommentRepliesFragment) fm.findFragmentByTag(CommentRepliesFragment.TAG);\n    @Nullable CommentsInfoItem rootComment = repliesFragment == null ? null : repliesFragment.getCommentsInfoItem();\n\n    if (popBackStack) fm.popBackStackImmediate();\n\n    if (CommentRepliesFragment.TAG.equals(fragmentUnderEntryName)) return;\n\n    final BottomSheetBehavior<FragmentContainerView> behavior = BottomSheetBehavior.from(mainBinding.fragmentPlayerHolder);\n    if (behavior.getState() == BottomSheetBehavior.STATE_HIDDEN) return;\n\n    behavior.addBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() {\n        @Override public void onStateChanged(@NonNull View bottomSheet, int newState) {\n            if (newState == BottomSheetBehavior.STATE_EXPANDED) {\n                final Fragment detailFragment = fm.findFragmentById(R.id.fragment_player_holder);\n                if (detailFragment instanceof VideoDetailFragment && rootComment != null) {\n                    ((VideoDetailFragment) detailFragment).scrollToComment(rootComment);\n                }\n                behavior.removeBottomSheetCallback(this);\n            }\n        }\n        @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) {}\n    });\n\n    behavior.setState(BottomSheetBehavior.STATE_EXPANDED);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "26", "src_id": "M372", "code": "\nprivate void buildCaptionMenu(@NonNull List<String> availableLanguages) {\n    if (captionPopupMenu == null) return;\n    captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n    captionPopupMenu.setOnDismissListener(this);\n\n    final MenuItem captionOffItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, 0, Menu.NONE, R.string.caption_none);\n    captionOffItem.setOnMenuItemClickListener(menuItem -> {\n        int textRendererIndex = player.getCaptionRendererIndex();\n        if (textRendererIndex != RENDERER_UNAVAILABLE) {\n            player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters().setRendererDisabled(textRendererIndex, true));\n        }\n        player.getPrefs().edit().remove(context.getString(R.string.caption_user_set_key)).apply();\n        return true;\n    });\n\n    for (int i = 0; i < availableLanguages.size(); i++) {\n        final String captionLanguage = availableLanguages.get(i);\n        final MenuItem captionItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, i + 1, Menu.NONE, captionLanguage);\n        captionItem.setOnMenuItemClickListener(menuItem -> {\n            int textRendererIndex = player.getCaptionRendererIndex();\n            if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters()\n                    .setPreferredTextLanguages(captionLanguage, PlayerHelper.captionLanguageStemOf(captionLanguage))\n                    .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                    .setRendererDisabled(textRendererIndex, false));\n                player.getPrefs().edit().putString(context.getString(R.string.caption_user_set_key), captionLanguage).apply();\n            }\n            return true;\n        });\n    }\n    captionPopupMenu.setOnDismissListener(this);\n\n    final int textRendererIndex = player.getCaptionRendererIndex();\n    if (textRendererIndex == RENDERER_UNAVAILABLE) return;\n\n    final String userPreferredLanguage = player.getPrefs().getString(context.getString(R.string.caption_user_set_key), null);\n    if (userPreferredLanguage == null) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters().setRendererDisabled(textRendererIndex, true));\n        return;\n    }\n\n    final List<String> selectedPreferredLanguages = player.getTrackSelector().getParameters().preferredTextLanguages;\n    if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters()\n            .setPreferredTextLanguages(userPreferredLanguage, PlayerHelper.captionLanguageStemOf(userPreferredLanguage))\n            .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n            .setRendererDisabled(textRendererIndex, false));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "27", "src_id": "M741", "code": "\nprivate void onItemSelectedSetFileName() {\n    final String fileName = FilenameUtils.createFilename(getContext(), currentInfo.getName());\n    final String prevFileName = Optional.ofNullable(dialogBinding.fileName.getText()).map(Object::toString).orElse(\"\");\n\n    if (prevFileName.isEmpty() || prevFileName.equals(fileName) || prevFileName.startsWith(getString(R.string.caption_file_name, fileName, \"\"))) {\n        switch (dialogBinding.videoAudioGroup.getCheckedRadioButtonId()) {\n            case R.id.audio_button:\n            case R.id.video_button:\n                if (!prevFileName.equals(fileName)) dialogBinding.fileName.setText(fileName);\n                break;\n            case R.id.subtitle_button:\n                final String setSubtitleLanguageCode = subtitleStreamsAdapter.getItem(selectedSubtitleIndex).getLanguageTag();\n                dialogBinding.fileName.setText(getString(R.string.caption_file_name, fileName, setSubtitleLanguageCode));\n                break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "28", "src_id": "M327", "code": "\nprotected void deinitListeners() {\n    binding.qualityTextView.setOnClickListener(null);\n    binding.audioTrackTextView.setOnClickListener(null);\n    binding.playbackSpeed.setOnClickListener(null);\n    binding.playbackSeekBar.setOnSeekBarChangeListener(null);\n    binding.captionTextView.setOnClickListener(null);\n    binding.resizeTextView.setOnClickListener(null);\n    binding.playbackLiveSync.setOnClickListener(null);\n    binding.getRoot().setOnTouchListener(null);\n    playerGestureListener = null;\n    gestureDetector = null;\n    binding.repeatButton.setOnClickListener(null);\n    binding.shuffleButton.setOnClickListener(null);\n    binding.playPauseButton.setOnClickListener(null);\n    binding.playPreviousButton.setOnClickListener(null);\n    binding.playNextButton.setOnClickListener(null);\n    binding.moreOptionsButton.setOnClickListener(null);\n    binding.moreOptionsButton.setOnLongClickListener(null);\n    binding.share.setOnClickListener(null);\n    binding.share.setOnLongClickListener(null);\n    binding.fullScreenButton.setOnClickListener(null);\n    binding.screenRotationButton.setOnClickListener(null);\n    binding.playWithKodi.setOnClickListener(null);\n    binding.openInBrowser.setOnClickListener(null);\n    binding.playerCloseButton.setOnClickListener(null);\n    binding.switchMute.setOnClickListener(null);\n    ViewCompat.setOnApplyWindowInsetsListener(binding.itemsListPanel, null);\n    binding.playbackControlRoot.removeOnLayoutChangeListener(onLayoutChangeListener);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "29", "src_id": "M239", "code": "\nprivate void updatePlaybackState(boolean playWhenReady, int playbackState) {\n    if (currentState == STATE_PAUSED_SEEK) return;\n\n    switch (playbackState) {\n        case com.google.android.exoplayer2.Player.STATE_IDLE: \n            isPrepared = false; \n            break;\n        case com.google.android.exoplayer2.Player.STATE_BUFFERING: \n            if (isPrepared) changeState(STATE_BUFFERING); \n            break;\n        case com.google.android.exoplayer2.Player.STATE_READY: \n            if (!isPrepared) {\n                isPrepared = true;\n                onPrepared(playWhenReady);\n            }\n            changeState(playWhenReady ? STATE_PLAYING : STATE_PAUSED);\n            break;\n        case com.google.android.exoplayer2.Player.STATE_ENDED: \n            changeState(STATE_COMPLETED);\n            saveStreamProgressStateCompleted();\n            isPrepared = false;\n            break;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "30", "src_id": "M355", "code": "\nprivate static String processInlineImages(final String htmlContent, final EmailContent emailContent) {\n    if (htmlContent == null || emailContent == null) {\n        return htmlContent;\n    }\n\n    final Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n    for (final EmailAttachment attachment : emailContent.getAttachments()) {\n        if (attachment.isEmbedded()\n                && attachment.getContentId() != null\n                && attachment.getData() != null) {\n            contentIdMap.put(attachment.getContentId(), attachment);\n        }\n    }\n    if (contentIdMap.isEmpty()) {\n        return htmlContent;\n    }\n\n    final Pattern cidPattern = Pattern.compile(\n            \"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\",\n            Pattern.CASE_INSENSITIVE);\n    final Matcher matcher = cidPattern.matcher(htmlContent);\n    final StringBuffer result = new StringBuffer();\n\n    while (matcher.find()) {\n        final String contentId = matcher.group(1);\n        final EmailAttachment attachment = contentIdMap.get(contentId);\n\n        if (attachment != null && attachment.getData() != null) {\n            String mimeType = attachment.getContentType();\n            if (mimeType == null || mimeType.isEmpty()) {\n                final String filename = attachment.getFilename();\n                if (filename != null) {\n                    if (filename.toLowerCase().endsWith(\".png\")) {\n                        mimeType = \"image/png\";\n                    } else if (filename.toLowerCase().endsWith(\".jpg\")\n                            || filename.toLowerCase().endsWith(\".jpeg\")) {\n                        mimeType = \"image/jpeg\";\n                    } else if (filename.toLowerCase().endsWith(\".gif\")) {\n                        mimeType = \"image/gif\";\n                    } else if (filename.toLowerCase().endsWith(\".bmp\")) {\n                        mimeType = \"image/bmp\";\n                    } else {\n                        mimeType = \"image/png\";\n                    }\n                } else {\n                    mimeType = \"image/png\";\n                }\n            }\n\n            final String base64Data = Base64.getEncoder().encodeToString(attachment.getData());\n            final String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n            final String replacement = matcher.group(0).replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n        } else {\n            matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n        }\n    }\n    matcher.appendTail(result);\n\n    return result.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "31", "src_id": "M347", "code": "\nprivate static void addAttachmentToInfo(\n        final StringBuilder attachmentInfo,\n        final String filename,\n        final String contentType,\n        final String encoding) {\n    attachmentInfo\n            .append(\"<div class=\\\"attachment-item\\\">\")\n            .append(\"<span class=\\\"attachment-icon\\\">\")\n            .append(MimeConstants.ATTACHMENT_MARKER)\n            .append(\"</span> \")\n            .append(\"<span class=\\\"attachment-name\\\">\")\n            .append(escapeHtml(filename))\n            .append(\"</span>\");\n\n    if (!contentType.isEmpty() || !encoding.isEmpty()) {\n        attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n        if (!contentType.isEmpty()) {\n            attachmentInfo.append(escapeHtml(contentType));\n        }\n        if (!encoding.isEmpty()) {\n            if (!contentType.isEmpty()) {\n                attachmentInfo.append(\", \");\n            }\n            attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n        }\n        attachmentInfo.append(\")</span>\");\n    }\n    attachmentInfo.append(\"</div>\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "32", "src_id": "M356", "code": "\nprivate static void appendEnhancedStyles(final StringBuilder html) {\n    final int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n    final String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n    final String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n    final String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n    html.append(\"body {\\n\");\n    html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n    html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n    html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n    html.append(\"  color: \").append(textColor).append(\";\\n\");\n    html.append(\"  margin: 0;\\n\");\n    html.append(\"  padding: 16px;\\n\");\n    html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-container {\\n\");\n    html.append(\"  width: 100%;\\n\");\n    html.append(\"  max-width: 100%;\\n\");\n    html.append(\"  margin: 0 auto;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-header {\\n\");\n    html.append(\"  padding-bottom: 10px;\\n\");\n    html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n    html.append(\"  margin-bottom: 10px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-header h1 {\\n\");\n    html.append(\"  margin: 0 0 10px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n    html.append(\"  font-weight: bold;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-meta div {\\n\");\n    html.append(\"  margin-bottom: 2px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-body {\\n\");\n    html.append(\"  word-wrap: break-word;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".attachment-section {\\n\");\n    html.append(\"  margin-top: 15px;\\n\");\n    html.append(\"  padding: 10px;\\n\");\n    html.append(\"  background-color: \")\n            .append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border: 1px solid \")\n            .append(StyleConstants.ATTACHMENT_BORDER_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-section h3 {\\n\");\n    html.append(\"  margin: 0 0 8px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-item {\\n\");\n    html.append(\"  padding: 5px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-icon {\\n\");\n    html.append(\"  margin-right: 5px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-details, .attachment-type {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  color: #555555;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n    html.append(\"  margin-top: 8px;\\n\");\n    html.append(\"  padding: 6px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note {\\n\");\n    html.append(\"  background-color: #e6ffed;\\n\");\n    html.append(\"  border: 1px solid #d4f7dc;\\n\");\n    html.append(\"  color: #006420;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-info-note {\\n\");\n    html.append(\"  background-color: #fff9e6;\\n\");\n    html.append(\"  border: 1px solid #fff0c2;\\n\");\n    html.append(\"  color: #664d00;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container {\\n\");\n    html.append(\"  display: flex;\\n\");\n    html.append(\"  align-items: center;\\n\");\n    html.append(\"  padding: 8px;\\n\");\n    html.append(\"  background-color: #f8f9fa;\\n\");\n    html.append(\"  border: 1px solid #dee2e6;\\n\");\n    html.append(\"  border-radius: 4px;\\n\");\n    html.append(\"  margin: 4px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container:hover {\\n\");\n    html.append(\"  background-color: #e9ecef;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-note {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n    html.append(\"  color: #6c757d;\\n\");\n    html.append(\"  font-style: italic;\\n\");\n    html.append(\"  margin-left: 8px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\"img {\\n\");\n    html.append(\"  max-width: 100%;\\n\");\n    html.append(\"  height: auto;\\n\");\n    html.append(\"  display: block;\\n\");\n    html.append(\"}\\n\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "33", "src_id": "M342", "code": "\nprivate static String convertEmlToHtmlBasic(final byte[] emlBytes, final EmlToPdfRequest request) {\n    if (emlBytes == null || emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n    }\n\n    final String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n    final String subject = extractBasicHeader(emlContent, \"Subject:\");\n    final String from = extractBasicHeader(emlContent, \"From:\");\n    final String to = extractBasicHeader(emlContent, \"To:\");\n    final String cc = extractBasicHeader(emlContent, \"Cc:\");\n    final String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n    final String date = extractBasicHeader(emlContent, \"Date:\");\n\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n        final String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(\n                textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n\n    final StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n    if (request != null && request.isIncludeAllRecipients()) {\n        if (!cc.trim().isEmpty()) {\n            html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        }\n        if (!bcc.trim().isEmpty()) {\n            html.append(\"<div><strong>BCC:</strong> \")\n                    .append(escapeHtml(bcc))\n                    .append(\"</div>\\n\");\n        }\n    }\n\n    if (!date.trim().isEmpty()) {\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    html.append(processEmailHtmlBody(htmlBody));\n    html.append(\"</div>\\n\");\n\n    final String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        html.append(\"<h3>Attachments</h3>\\n\");\n        html.append(attachmentInfo);\n\n        if (request != null && request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n            html.append(\n                    \"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n            html.append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\n                    \"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n    }\n\n    assert request != null;\n    if (request.getFileInput().isEmpty()) {\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n        html.append(\n                \"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "34", "src_id": "M361", "code": "\nprivate static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n    try {\n        if (!isValidJakartaMailPart(part)) {\n            log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n            return;\n        }\n\n        Class<?> partClass = part.getClass();\n        Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n        Method getContent = partClass.getMethod(\"getContent\");\n        Method getDisposition = partClass.getMethod(\"getDisposition\");\n        Method getFileName = partClass.getMethod(\"getFileName\");\n        Method getContentType = partClass.getMethod(\"getContentType\");\n        Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n        Object disposition = getDisposition.invoke(part);\n        String filename = (String) getFileName.invoke(part);\n        String contentType = (String) getContentType.invoke(part);\n\n        if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n            content.setTextBody((String) getContent.invoke(part));\n        } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n            content.setHtmlBody((String) getContent.invoke(part));\n        } else if (\"attachment\".equalsIgnoreCase((String) disposition)\n                || (filename != null && !filename.trim().isEmpty())) {\n            content.setAttachmentCount(content.getAttachmentCount() + 1);\n            if (filename != null && !filename.trim().isEmpty()) {\n                EmailAttachment attachment = new EmailAttachment();\n                attachment.setFilename(safeMimeDecode(filename));\n                attachment.setContentType(contentType);\n                String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n                if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                    attachment.setEmbedded(true);\n                    String contentId = contentIdHeaders[0];\n                    if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                        contentId = contentId.substring(1, contentId.length() - 1);\n                    }\n                    attachment.setContentId(contentId);\n                }\n                if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n                    try {\n                        Object attachmentContent = getContent.invoke(part);\n                        byte[] attachmentData = null;\n                        if (attachmentContent instanceof java.io.InputStream inputStream) {\n                            try {\n                                attachmentData = inputStream.readAllBytes();\n                            } catch (IOException e) {\n                                log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n                            }\n                        } else if (attachmentContent instanceof byte[] byteArray) {\n                            attachmentData = byteArray;\n                        } else if (attachmentContent instanceof String stringContent) {\n                            attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n                        }\n                        if (attachmentData != null) {\n                            long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                            long maxSizeBytes = maxSizeMB * 1024 * 1024;\n                            if (attachmentData.length <= maxSizeBytes) {\n                                attachment.setData(attachmentData);\n                                attachment.setSizeBytes(attachmentData.length);\n                            } else {\n                                if (attachment.isEmbedded()) {\n                                    attachment.setData(attachmentData);\n                                    attachment.setSizeBytes(attachmentData.length);\n                                } else {\n                                    attachment.setSizeBytes(attachmentData.length);\n                                }\n                            }\n                        }\n                    } catch (Exception e) {\n                        log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n                    }\n                }\n                content.getAttachments().add(attachment);\n            }\n        } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n            try {\n                Object multipartContent = getContent.invoke(part);\n                Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(multipartContent)) {\n                    processMultipartAdvanced(multipartContent, content, request);\n                }\n            } catch (Exception e) {\n                log.warn(\"Error processing multipart content: {}\", e.getMessage());\n            }\n        }\n    } catch (Exception e) {\n        log.warn(\"Error processing multipart part: {}\", e.getMessage());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "35", "src_id": "M362", "code": "\nprivate static String generateEnhancedEmailHtml(EmailContent content, EmlToPdfRequest request) {\n    StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\").append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\")\n        .append(\"<title>\").append(escapeHtml(content.getSubject())).append(\"</title>\\n\")\n        .append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n</head><body>\\n\").append(\"<div class=\\\"email-container\\\">\\n\")\n        .append(\"<div class=\\\"email-header\\\">\\n\").append(\"<h1>\")\n        .append(escapeHtml(content.getSubject())).append(\"</h1>\\n\")\n        .append(\"<div class=\\\"email-meta\\\">\\n\").append(\"<div><strong>From:</strong> \")\n        .append(escapeHtml(content.getFrom())).append(\"</div>\\n\")\n        .append(\"<div><strong>To:</strong> \").append(escapeHtml(content.getTo()))\n        .append(\"</div>\\n\");\n    if (content.getDate() != null) {\n        html.append(\"<div><strong>Date:</strong> \").append(formatEmailDate(content.getDate()))\n            .append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\").append(\"<div class=\\\"email-body\\\">\\n\");\n    if (content.getHtmlBody() != null && !content.getHtmlBody().trim().isEmpty()) {\n        html.append(processEmailHtmlBody(content.getHtmlBody(), content));\n    } else if (content.getTextBody() != null && !content.getTextBody().trim().isEmpty()) {\n        html.append(\"<div class=\\\"text-body\\\">\").append(convertTextToHtml(content.getTextBody()))\n            .append(\"</div>\");\n    } else {\n        html.append(\"<div class=\\\"no-content\\\"><p><em>No content available</em></p></div>\");\n    }\n    html.append(\"</div>\\n\");\n    if (content.getAttachmentCount() > 0 || !content.getAttachments().isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        int displayedAttachmentCount = content.getAttachmentCount() > 0 \n            ? content.getAttachmentCount() : content.getAttachments().size();\n        html.append(\"<h3>Attachments (\").append(displayedAttachmentCount).append(\")</h3>\\n\");\n        if (!content.getAttachments().isEmpty()) {\n            for (EmailAttachment attachment : content.getAttachments()) {\n                String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n                attachment.setEmbeddedFilename(attachment.getEmbeddedFilename() != null \n                    ? attachment.getEmbeddedFilename() : attachment.getFilename());\n                html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\").append(uniqueId).append(\"\\\">\")\n                    .append(\"<span class=\\\"attachment-icon\\\">\").append(MimeConstants.ATTACHMENT_MARKER)\n                    .append(\"</span> <span class=\\\"attachment-name\\\">\")\n                    .append(escapeHtml(safeMimeDecode(attachment.getFilename())))\n                    .append(\"</span>\");\n                String sizeStr = formatFileSize(attachment.getSizeBytes());\n                html.append(\" <span class=\\\"attachment-details\\\">(\").append(sizeStr);\n                if (attachment.getContentType() != null && !attachment.getContentType().isEmpty()) {\n                    html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                }\n                html.append(\")</span></div>\\n\");\n            }\n        }\n        if (request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\")\n                .append(\"<p><em>Attachments are embedded in the file.</em></p>\\n\")\n                .append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\")\n                .append(\"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\")\n                .append(\"</div>\\n\");\n        }\n        html.append(\"</div>\\n\");\n    }\n    html.append(\"</div>\\n</body></html>\");\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "36", "src_id": "M367", "code": "\nprivate static String decodeMimeHeader(String encodedText) {\n    if (encodedText == null || encodedText.trim().isEmpty()) {\n        return encodedText;\n    }\n    try {\n        StringBuilder result = new StringBuilder();\n        Matcher matcher = MimeConstants.MIME_ENCODED_PATTERN.matcher(encodedText);\n        int lastEnd = 0;\n        while (matcher.find()) {\n            result.append(encodedText, lastEnd, matcher.start());\n            String charset = matcher.group(1);\n            String encoding = matcher.group(2).toUpperCase();\n            String encodedValue = matcher.group(3);\n            try {\n                String decodedValue;\n                if (\"B\".equals(encoding)) {\n                    byte[] decodedBytes = Base64.getDecoder().decode(encodedValue);\n                    decodedValue = new String(decodedBytes, Charset.forName(charset));\n                } else if (\"Q\".equals(encoding)) {\n                    decodedValue = decodeQuotedPrintable(encodedValue, charset);\n                } else {\n                    decodedValue = matcher.group(0);\n                }\n                result.append(decodedValue);\n            } catch (Exception e) {\n                log.warn(\"Failed to decode MIME header part: {}\", matcher.group(0), e);\n                result.append(matcher.group(0));\n            }\n            lastEnd = matcher.end();\n        }\n        result.append(encodedText.substring(lastEnd));\n        return result.toString();\n    } catch (Exception e) {\n        log.warn(\"Error decoding MIME header: {}\", encodedText, e);\n        return encodedText;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "37", "src_id": "M509", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n@Operation(summary = \"Convert EML to PDF\", description = \"This endpoint converts EML (email) files to PDF format with extensive\"\n        + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n        + \" and HTML debug output. Input: EML file, Output: PDF or HTML file. Type: SISO\")\npublic ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n    MultipartFile inputFile = request.getFileInput();\n    String originalFilename = inputFile.getOriginalFilename();\n    if (inputFile.isEmpty()) {\n        log.error(\"No file provided for EML to PDF conversion.\");\n        return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n    }\n    if (originalFilename == null || originalFilename.trim().isEmpty()) {\n        log.error(\"Filename is null or empty.\");\n        return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n    }\n    String lowerFilename = originalFilename.toLowerCase();\n    if (!lowerFilename.endsWith(\".eml\")) {\n        log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n        return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n    }\n    String baseFilename = Filenames.toSimpleFileName(originalFilename);\n    try {\n        byte[] fileBytes = inputFile.getBytes();\n        if (request.isDownloadHtml()) {\n            try {\n                String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8),\n                        baseFilename + \".html\", MediaType.TEXT_HTML);\n            } catch (IOException | IllegalArgumentException e) {\n                log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n            }\n        }\n        try {\n            byte[] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig.getWeasyPrintPath(), request, fileBytes,\n                    originalFilename, false, pdfDocumentFactory, tempFileManager);\n            if (pdfBytes == null || pdfBytes.length == 0) {\n                log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n            }\n            log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n            return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n        } catch (IllegalArgumentException | RuntimeException e) {\n            String errorMessage = buildErrorMessage(e, originalFilename);\n            log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        }\n    } catch (IOException e) {\n        log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "38", "src_id": "M1294", "code": "\n@Override\npublic void addParams(CommandArguments args)\n{\n\n    if (definition != null)\n    {\n        definition.addParams(args);\n    }\n\n    if ((flags & USE_TERM_OFFSETS) == 0)\n    {\n        args.add(SearchKeyword.NOOFFSETS.name());\n    }\n    if ((flags & KEEP_FIELD_FLAGS) == 0)\n    {\n        args.add(SearchKeyword.NOFIELDS.name());\n    }\n    if ((flags & KEEP_TERM_FREQUENCIES) == 0)\n    {\n        args.add(SearchKeyword.NOFREQS.name());\n    }\n    if (expire > 0)\n    {\n        args.add(SearchKeyword.TEMPORARY.name());\n        args.add(Long.toString(this.expire));\n    }\n\n    if (stopwords != null)\n    {\n        args.add(SearchKeyword.STOPWORDS.name());\n        args.add(Integer.toString(stopwords.size()));\n        if (!stopwords.isEmpty())\n        {\n            args.addObjects(stopwords);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "39", "src_id": "M50", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<byte[], byte[]> build(Object data)\n{\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty())\n    {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue)\n    {\n        Map<byte[], byte[]> map = new JedisByteHashMap();\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n        }\n        return map;\n    }\n    else\n    {\n        Map<byte[], byte[]> map = new JedisByteHashMap();\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "40", "src_id": "M933", "code": "\n@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy)\n{\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n    if (credentialsProvider != null)\n    {\n        builder.credentialsProvider(credentialsProvider);\n    }\n    else\n    {\n        builder.user(copy.getUser());\n        builder.password(copy.getPassword());\n    }\n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas())\n    {\n        builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "41", "src_id": "M913", "code": "\n@Override\npublic Map<String, TSMRangeElements> build(Object data)\n{\n    List<KeyValue> dataList = (List<KeyValue>) data;\n    Map<String, TSMRangeElements> map = new LinkedHashMap<>(dataList.size() / 2, 1f);\n    for (KeyValue kv : dataList)\n    {\n        String key = BuilderFactory.STRING.build(kv.getKey());\n        List<Object> valueList = (List<Object>) kv.getValue();\n        TSMRangeElements elements;\n        switch (valueList.size())\n        {\n            case 3:\n                List<Object> aggrMapObj = (List<Object>) valueList.get(1);\n                KeyValue aggKV = (KeyValue) aggrMapObj.get(0);\n                assert \"aggregators\".equalsIgnoreCase(BuilderFactory.STRING.build(aggKV.getKey()));\n                elements = new TSMRangeElements(key,\n                    BuilderFactory.STRING_MAP.build(valueList.get(0)),\n                    ((List<Object>) aggKV.getValue()).stream().map(BuilderFactory.STRING::build)\n                        .map(AggregationType::safeValueOf).collect(Collectors.toList()),\n                    TIMESERIES_ELEMENT_LIST.build(valueList.get(2)));\n                break;\n            case 4:\n                List<KeyValue> rdcMapObj = (List<KeyValue>) valueList.get(1);\n                assert \"reducers\".equalsIgnoreCase(BuilderFactory.STRING.build(rdcMapObj.get(0).getKey()));\n                List<KeyValue> srcMapObj = (List<KeyValue>) valueList.get(2);\n                assert \"sources\".equalsIgnoreCase(BuilderFactory.STRING.build(srcMapObj.get(0).getKey()));\n                elements = new TSMRangeElements(key,\n                    BuilderFactory.STRING_MAP.build(valueList.get(0)),\n                    BuilderFactory.STRING_LIST.build(rdcMapObj.get(0).getValue()),\n                    BuilderFactory.STRING_LIST.build(srcMapObj.get(0).getValue()),\n                    TIMESERIES_ELEMENT_LIST.build(valueList.get(3)));\n                break;\n            default:\n                throw new IllegalStateException();\n        }\n        map.put(key, elements);\n    }\n    return map;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1146", "code": "\nprivate <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica)\n{\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--)\n    {\n        Connection connection = null;\n        try\n        {\n            if (redirect != null)\n            {\n                connection = provider.getConnection(redirect.getTargetNode());\n                if (redirect instanceof JedisAskDataException)\n                {\n                    connection.executeCommand(Protocol.Command.ASKING);\n                }\n            }\n            else\n            {\n                connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                    : provider.getConnection(commandObject.getArguments());\n            }\n\n            return execute(connection, commandObject);\n        }\n        catch (JedisClusterOperationException jnrcne)\n        {\n            throw jnrcne;\n        }\n        catch (JedisConnectionException jce)\n        {\n            lastException = jce;\n            ++consecutiveConnectionFailures;\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n            if (reset)\n            {\n                consecutiveConnectionFailures = 0;\n                redirect = null;\n            }\n        }\n        catch (JedisRedirectionException jre)\n        {\n            if (lastException == null || lastException instanceof JedisRedirectionException)\n            {\n                lastException = jre;\n            }\n            log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n            consecutiveConnectionFailures = 0;\n            redirect = jre;\n            if (jre instanceof JedisMovedDataException)\n            {\n                provider.renewSlotCache(connection);\n            }\n        }\n        finally\n        {\n            IOUtils.closeQuietly(connection);\n        }\n        if (Instant.now().isAfter(deadline))\n        {\n            throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n        }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "43", "src_id": "M55", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<String, Long> build(Object data)\n{\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty())\n    {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue)\n    {\n        Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n        }\n        return map;\n    }\n    else\n    {\n        Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "44", "src_id": "M52", "code": "\n@Override\npublic Map<String, Object> build(Object data)\n{\n    if (data == null)\n    {\n        return null;\n    }\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty())\n    {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue)\n    {\n        Map<String, Object> map = new HashMap<>(list.size(), 1f);\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));\n        }\n        return map;\n    }\n    else\n    {\n        Map<String, Object> map = new HashMap<>(list.size() / 2, 1f);\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection()\n{\n    List<ConnectionPool> pools = getShuffledNodesPool();\n\n    JedisException suppressed = null;\n    for (ConnectionPool pool : pools)\n    {\n        Connection jedis = null;\n        try\n        {\n            jedis = pool.getResource();\n            if (jedis == null)\n            {\n                continue;\n            }\n\n            jedis.ping();\n            return jedis;\n        }\n        catch (JedisException ex)\n        {\n            if (suppressed == null)\n            {\n                suppressed = ex;\n            }\n            if (jedis != null)\n            {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null)\n    {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "46", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is)\n{\n    final byte b = is.readByte();\n    switch (b)\n    {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE:\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE:\n            return processMultiBulkReply(is);\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "47", "src_id": "M1298", "code": "\n@Override\npublic void addParams(CommandArguments args)\n{\n\n    if (type != null)\n    {\n        args.add(SearchKeyword.ON.name());\n        args.add(type.name());\n    }\n\n    if (prefixes != null && prefixes.length > 0)\n    {\n        args.add(SearchKeyword.PREFIX.name());\n        args.add(Integer.toString(prefixes.length));\n        args.addObjects((Object[]) prefixes);\n    }\n\n    if (filter != null)\n    {\n        args.add(SearchKeyword.FILTER.name());\n        args.add(filter);\n    }\n\n    if (languageField != null)\n    {\n        args.add(SearchKeyword.LANGUAGE_FIELD.name());\n        args.add(languageField);\n    }\n\n    if (language != null)\n    {\n        args.add(SearchKeyword.LANGUAGE.name());\n        args.add(language);\n    }\n\n    if (scoreFiled != null)\n    {\n        args.add(SearchKeyword.SCORE_FIELD.name());\n        args.add(scoreFiled);\n    }\n\n    if (score != 1.0)\n    {\n        args.add(SearchKeyword.SCORE.name());\n        args.add(Double.toString(score));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "48", "src_id": "M8", "code": "\nprivate static String formatFileSize(long size) {\n    DecimalFormat dec = new DecimalFormat(\"0.00\");\n    double t = size / (1024.0 * 1024.0 * 1024.0 * 1024.0);\n    if (t > 1) {\n        return dec.format(t) + \" TB\";\n    }\n    double g = size / (1024.0 * 1024.0 * 1024.0);\n    if (g > 1) {\n        return dec.format(g) + \" GB\";\n    }\n    double m = size / (1024.0 * 1024.0);\n    if (m > 1) {\n        return dec.format(m) + \" MB\";\n    }\n    double k = size / 1024.0;\n    if (k > 1) {\n        return dec.format(k) + \" KB\";\n    }\n    return dec.format(size) + \" Bytes\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "49", "src_id": "M357", "code": "\nprivate static Class<?>[] parseTypes(String desc, ClassLoader loader) throws ClassNotFoundException {\n    int lparen = desc.indexOf('(');\n    int rparen = desc.indexOf(')', lparen);\n    List<String> params = new ArrayList<>();\n    int start = lparen + 1;\n    for (;;) {\n        int comma = desc.indexOf(',', start);\n        if (comma < 0) {\n            break;\n        }\n        params.add(desc.substring(start, comma).trim());\n        start = comma + 1;\n    }\n    if (start < rparen) {\n        params.add(desc.substring(start, rparen).trim());\n    }\n    Class<?>[] types = new Class<?>[params.size()];\n    for (int i = 0; i < types.length; i++) {\n        types[i] = getClass(params.get(i), loader);\n    }\n    return types;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "50", "src_id": "M566", "code": "\n@Override\npublic void process(final CommandProcess process) {\n    Session session = process.session();\n    timer = new Timer(\"Timer-for-arthas-dashboard-\" + session.getSessionId(), true);\n    \n    process.interruptHandler(new DashboardInterruptHandler(process, timer));\n    \n    Handler<Void> stopHandler = event -> stop();\n    Handler<Void> restartHandler = event -> restart(process);\n    \n    process.suspendHandler(stopHandler);\n    process.resumeHandler(restartHandler);\n    process.endHandler(stopHandler);\n    process.stdinHandler(new QExitHandler(process));\n    \n    timer.scheduleAtFixedRate(new DashboardTimerTask(process), 0, getInterval());\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "51", "src_id": "M114", "code": "\npublic boolean isAvailable() {\n    if (!isConnected()) {\n        return false;\n    }\n    try {\n        if (_socket_.getInetAddress() == null) {\n            return false;\n        }\n        if (_socket_.getPort() == 0) {\n            return false;\n        }\n        if (_socket_.getRemoteSocketAddress() == null) {\n            return false;\n        }\n        if (_socket_.isClosed()) {\n            return false;\n        }\n        if (_socket_.isInputShutdown()) {\n            return false;\n        }\n        if (_socket_.isOutputShutdown()) {\n            return false;\n        }\n        _socket_.getInputStream();\n        _socket_.getOutputStream();\n        return true;\n    } catch (IOException ioex) {\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "52", "src_id": "M232", "code": "\npublic void start() throws Exception {\n    final SslContext sslCtx;\n    if (ssl) {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n    } else {\n        sslCtx = null;\n    }\n\n    ServerBootstrap b = new ServerBootstrap();\n    b.group(bossGroup, workerGroup)\n        .channel(NioServerSocketChannel.class)\n        .handler(new LoggingHandler(LogLevel.INFO))\n        .childHandler(new TunnelSocketServerInitializer(this, sslCtx));\n\n    if (StringUtils.isBlank(host)) {\n        channel = b.bind(port).sync().channel();\n    } else {\n        channel = b.bind(host, port).sync().channel();\n    }\n\n    logger.info(\"Tunnel server listen at {}:{}\", host, port);\n\n    workerGroup.scheduleWithFixedDelay(() -> {\n        agentInfoMap.entrySet().removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n        clientConnectionInfoMap.entrySet()\n            .removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n        \n        if (tunnelClusterStore != null && clientConnectHost != null) {\n            try {\n                for (Entry<String, AgentInfo> entry : agentInfoMap.entrySet()) {\n                    tunnelClusterStore.addAgent(\n                        entry.getKey(), \n                        new AgentClusterInfo(entry.getValue(), clientConnectHost, port), \n                        60 * 60, \n                        TimeUnit.SECONDS\n                    );\n                }\n            } catch (Throwable t) {\n                logger.error(\"update tunnel info error\", t);\n            }\n        }\n    }, 60, 60, TimeUnit.SECONDS);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "53", "src_id": "M65", "code": "\npublic Map<String, Class<?>> build() {\n    errors.clear();\n    warnings.clear();\n    \n    JavaFileManager fileManager = new DynamicJavaFileManager(standardFileManager, dynamicClassLoader);\n    DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<>();\n    JavaCompiler.CompilationTask task = javaCompiler.getTask(\n        null, fileManager, collector, options, null, compilationUnits\n    );\n\n    try {\n        if (compilationUnits.isEmpty()) {\n            return dynamicClassLoader.getClasses();\n        }\n        \n        boolean result = task.call();\n        if (!result || !collector.getDiagnostics().isEmpty()) {\n            for (Diagnostic<? extends JavaFileObject> diagnostic : collector.getDiagnostics()) {\n                switch (diagnostic.getKind()) {\n                    case NOTE:\n                    case MANDATORY_WARNING:\n                    case WARNING:\n                        warnings.add(diagnostic);\n                        break;\n                    case OTHER:\n                    case ERROR:\n                    default:\n                        errors.add(diagnostic);\n                        break;\n                }\n            }\n            if (!errors.isEmpty()) {\n                throw new DynamicCompilerException(\"Compilation Error\", errors);\n            }\n        }\n        return dynamicClassLoader.getClasses();\n    } catch (Throwable ex) {\n        throw new DynamicCompilerException(ex, errors);\n    } finally {\n        compilationUnits.clear();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "54", "src_id": "M183", "code": "\npublic SimpleHttpResponse query(String targetUrl) throws InterruptedException {\n    final Promise<SimpleHttpResponse> httpResponsePromise = GlobalEventExecutor.INSTANCE.newPromise();\n    final EventLoopGroup group = new NioEventLoopGroup(1, new DefaultThreadFactory(\"arthas-ProxyClient\", true));\n    ChannelFuture closeFuture = null;\n    \n    try {\n        Bootstrap b = new Bootstrap();\n        b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)\n            .group(group)\n            .channel(LocalChannel.class)\n            .handler(ch -> {\n                ChannelPipeline p = ch.pipeline();\n                p.addLast(\n                    new HttpClientCodec(),\n                    new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                    new HttpProxyClientHandler(httpResponsePromise)\n                );\n            });\n\n        LocalAddress localAddress = new LocalAddress(ArthasConstants.NETTY_LOCAL_ADDRESS);\n        Channel localChannel = b.connect(localAddress).sync().channel();\n\n        HttpRequest request = new DefaultFullHttpRequest(\n            HttpVersion.HTTP_1_1, \n            HttpMethod.GET, \n            targetUrl,\n            Unpooled.EMPTY_BUFFER\n        );\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n        localChannel.writeAndFlush(request);\n\n        closeFuture = localChannel.closeFuture();\n        logger.info(\"proxy client connect to server success, targetUrl: \" + targetUrl);\n        return httpResponsePromise.get(5000, TimeUnit.MILLISECONDS);\n    } catch (Throwable ex) {\n        logger.error(\"ProxyClient error, targetUrl: {}\", targetUrl, ex);\n    } finally {\n        if (closeFuture != null) {\n            closeFuture.addListener(future -> group.shutdownGracefully());\n        } else {\n            group.shutdownGracefully();\n        }\n    }\n\n    SimpleHttpResponse httpResponse = new SimpleHttpResponse();\n    try {\n        httpResponse.setContent(\"error\".getBytes(\"utf-8\"));\n    } catch (UnsupportedEncodingException uee) {\n        // ignore\n    }\n    return httpResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "55", "src_id": "M131", "code": "\n@Override\npublic void write(int ch) throws IOException {\n    synchronized (__client) {\n        ch &= 0xff;\n\n        if (__client._requestedWont(TelnetOption.BINARY)) {\n            if (__lastWasCR) {\n                if (__convertCRtoCRLF) {\n                    __client._sendByte('\\n');\n                    if (ch == '\\n') {\n                        __lastWasCR = false;\n                        return;\n                    }\n                } else if (ch != '\\n') {\n                    __client._sendByte('\\0');\n                }\n            }\n\n            switch (ch) {\n                case '\\r':\n                    __client._sendByte('\\r');\n                    __lastWasCR = true;\n                    break;\n                case '\\n':\n                    if (!__lastWasCR) {\n                        __client._sendByte('\\r');\n                    }\n                    __client._sendByte(ch);\n                    __lastWasCR = false;\n                    break;\n                case TelnetCommand.IAC:\n                    __client._sendByte(TelnetCommand.IAC);\n                    __client._sendByte(TelnetCommand.IAC);\n                    __lastWasCR = false;\n                    break;\n                default:\n                    __client._sendByte(ch);\n                    __lastWasCR = false;\n                    break;\n            }\n        } else if (ch == TelnetCommand.IAC) {\n            __client._sendByte(ch);\n            __client._sendByte(TelnetCommand.IAC);\n        } else {\n            __client._sendByte(ch);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "56", "src_id": "M443", "code": "\nprivate String drawField() {\n    StringBuilder fieldSB = new StringBuilder();\n    Field[] fields = clazz.getDeclaredFields();\n    \n    if (fields.length == 0) {\n        return fieldSB.toString();\n    }\n\n    for (Field field : fields) {\n        KVView kvView = new KVView(\n            new TableView.ColumnDefine(TableView.Align.RIGHT),\n            new TableView.ColumnDefine(50, false, TableView.Align.LEFT)\n        ).add(\"modifier\", StringUtils.modifier(field.getModifiers(), ','))\n         .add(\"type\", StringUtils.classname(field.getType()))\n         .add(\"name\", field.getName());\n\n        Annotation[] annotationArray = field.getAnnotations();\n        if (annotationArray != null && annotationArray.length > 0) {\n            StringBuilder annotationSB = new StringBuilder();\n            for (Annotation annotation : annotationArray) {\n                annotationSB.append(StringUtils.classname(annotation.annotationType())).append(',');\n            }\n            if (annotationSB.length() > 0) {\n                annotationSB.setLength(annotationSB.length() - 1);\n            }\n            kvView.add(\"annotation\", annotationSB.toString());\n        }\n\n        if (Modifier.isStatic(field.getModifiers())) {\n            boolean isAccessible = field.isAccessible();\n            try {\n                field.setAccessible(true);\n                kvView.add(\"value\", StringUtils.objectToString(field.get(null)));\n            } catch (IllegalAccessException iae) {\n                // ignore\n            } finally {\n                field.setAccessible(isAccessible);\n            }\n        }\n        fieldSB.append(kvView.draw()).append('\\n');\n    }\n    return fieldSB.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "57", "src_id": "M1439", "code": "\npublic static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete) {\n    if (ObjectUtils.isEmpty(array)) {\n        return null;\n    }\n    Properties result = new Properties();\n    for (String element : array) {\n        if (charsToDelete != null) {\n            element = deleteAny(element, charsToDelete);\n        }\n        String[] splittedElement = split(element, delimiter);\n        if (splittedElement != null) {\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n    }\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "58", "src_id": "M47", "code": "\nprivate static long findProcessByTelnetClient(String arthasHomeDir, int telnetPort) {\n    // Start java telnet client\n    List<String> telnetArgs = new ArrayList<>();\n    telnetArgs.add(\"-c\");\n    telnetArgs.add(\"session\");\n    telnetArgs.add(\"--execution-timeout\");\n    telnetArgs.add(\"2000\");\n    // Telnet port, ip\n    telnetArgs.add(\"127.0.0.1\");\n    telnetArgs.add(\"\" + telnetPort);\n\n    try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n        String error = null;\n        int status = ProcessUtils.startArthasClient(arthasHomeDir, telnetArgs, out);\n        if (status == STATUS_EXEC_TIMEOUT) {\n            error = \"detection timeout\";\n        } else if (status == STATUS_EXEC_ERROR) {\n            error = \"detection error\";\n            AnsiLog.error(\"process status: {}\", status);\n            AnsiLog.error(\"process output: {}\", out.toString());\n        } else {\n            // Ignore connect error\n        }\n        if (error != null) {\n            AnsiLog.error(\"The telnet port {} is used, but process {}, you will connect to an unexpected process.\",\n                telnetPort, error);\n            AnsiLog.error(\"Try to use a different telnet port, for example: java -jar arthas-boot.jar --telnet-port 9998 --http-port -1\");\n            System.exit(1);\n        }\n\n        // Parse output, find java pid\n        String output = out.toString(\"UTF-8\");\n        String javaPidLine = null;\n        Scanner scanner = new Scanner(output);\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.contains(\"JAVA_PID\")) {\n                javaPidLine = line;\n                break;\n            }\n        }\n        if (javaPidLine != null) {\n            // JAVA_PID    10473\n            try {\n                String[] strs = javaPidLine.split(\"JAVA_PID\");\n                if (strs.length > 1) {\n                    return Long.parseLong(strs[strs.length - 1].trim());\n                }\n            } catch (NumberFormatException e) {\n                // Ignore\n            }\n        }\n    } catch (Throwable ex) {\n        AnsiLog.error(\"Detection telnet port error\");\n        AnsiLog.error(ex);\n    }\n\n    return -1;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "59", "src_id": "M475", "code": "\n@Override\npublic void draw(CommandProcess process, JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n        String group = entry.getKey();\n        List<JvmItemVO> items = entry.getValue();\n\n        table.row(true, label(group).style(Decoration.bold.bold()));\n        for (JvmItemVO item : items) {\n            String valueStr;\n            if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                valueStr = renderMemoryUsage((Map<String, Object>)item.getValue());\n            } else {\n                valueStr = renderItemValue(item.getValue());\n            }\n            if (item.getDesc() != null) {\n                table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n            } else {\n                table.row(item.getName(), valueStr);\n            }\n        }\n        table.row(\"\", \"\");\n    }\n\n    process.write(RenderUtil.render(table, process.width()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "60", "src_id": "M1131", "code": "\nprivate ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<>();\n    body.put(\"command\", commandLine);\n\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId())\n            .setBody(body);\n\n    if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED)\n                .setMessage(\"Another command is executing.\");\n        return response;\n    }\n    int lock = session.getLock();\n    try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n            response.setState(ApiState.REFUSED)\n                    .setMessage(\"Another job is running.\");\n            logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n            return response;\n        }\n\n        // Create job\n        Job job = this.createJob(commandLine, session, session.getResultDistributor());\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        response.setState(ApiState.SCHEDULED);\n\n        // Add command before exec job\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n        commandRequestModel.setJobId(job.id());\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) {\n            resultDistributor.appendResult(commandRequestModel);\n        }\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n        // Run job\n        job.run();\n\n        return response;\n    } catch (Throwable e) {\n        logger.error(\"Async exec command failed: \" + e.getMessage() +\n            \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n        CommandRequestModel commandRequestModel = new CommandRequestModel(\n            commandLine, response.getState(), response.getMessage());\n        session.getResultDistributor().appendResult(commandRequestModel);\n        return response;\n    } finally {\n        if (session.getLock() == lock) {\n            session.unLock();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "61", "src_id": "M493", "code": "\nprivate void renderNode(StringBuilder sb, TraceNode node, Ansi highlighted) {\n    // Render cost: [0.366865ms]\n    if (isPrintCost && node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode)node;\n        String costStr = renderCost(methodNode);\n        if (node == maxCostNode) {\n            // The node with max cost will be highlighted\n            sb.append(highlighted.a(costStr).reset().toString());\n        } else {\n            sb.append(costStr);\n        }\n    }\n\n    // Render method name\n    if (node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode)node;\n        sb.append(methodNode.getClassName()).append(\":\").append(methodNode.getMethodName()).append(\"()\");\n        if (methodNode.getLineNumber() != -1) {\n            sb.append(\" #\").append(methodNode.getLineNumber());\n        }\n    } else if (node instanceof ThreadNode) {\n        ThreadNode threadNode = (ThreadNode)node;\n        sb.append(format(\"ts=%s;thread_name=%s;id=%d;is_daemon=%s;priority=%d;TCCL=%s\",\n            DateUtils.formatDateTime(threadNode.getTimestamp()),\n            threadNode.getThreadName(),\n            threadNode.getThreadId(),\n            threadNode.isDaemon(),\n            threadNode.getPriority(),\n            threadNode.getClassloader()));\n\n        if (threadNode.getTraceId() != null) {\n            sb.append(\";trace_id=\").append(threadNode.getTraceId());\n        }\n        if (threadNode.getRpcId() != null) {\n            sb.append(\";rpc_id=\").append(threadNode.getRpcId());\n        }\n    } else if (node instanceof ThrowNode) {\n        ThrowNode throwNode = (ThrowNode)node;\n        sb.append(\"throw:\").append(throwNode.getException())\n            .append(\" #\").append(throwNode.getLineNumber())\n            .append(\" [\").append(throwNode.getMessage()).append(\"]\");\n    } else {\n        throw new UnsupportedOperationException(\"unknown trace node: \" + node.getClass());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "62", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>)info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n            .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n            .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.classLoader)))\n            .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n            .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.level)));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.additivity)))\n            .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>)info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>)appenderInfo.get(LoggerHelper.clazz);\n\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                        label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                appendersTable.row(label(LoggerHelper.classLoaderHash),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target),\n                            label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking),\n                            label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef),\n                            label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "63", "src_id": "M529", "code": "\n@Override\npublic void draw(CommandProcess process, MonitorModel result) {\n    TableElement table = new TableElement(2, 3, 3, 1, 1, 1, 1, 1).leftCellPadding(1).rightCellPadding(1);\n    table.row(true, label(\"timestamp\").style(Decoration.bold.bold()),\n            label(\"class\").style(Decoration.bold.bold()),\n            label(\"method\").style(Decoration.bold.bold()),\n            label(\"total\").style(Decoration.bold.bold()),\n            label(\"success\").style(Decoration.bold.bold()),\n            label(\"fail\").style(Decoration.bold.bold()),\n            label(\"avg-rt(ms)\").style(Decoration.bold.bold()),\n            label(\"fail-rate\").style(Decoration.bold.bold()));\n\n    final DecimalFormat df = new DecimalFormat(\"0.00\");\n\n    for (MonitorData data : result.getMonitorDataList()) {\n        table.row(\n                DateUtils.formatDateTime(data.getTimestamp()),\n                data.getClassName(),\n                data.getMethodName(),\n                \"\" + data.getTotal(),\n                \"\" + data.getSuccess(),\n                \"\" + data.getFailed(),\n                df.format(div(data.getCost(), data.getTotal())),\n                df.format(100.0d * div(data.getFailed(), data.getTotal())) + \"%\"\n        );\n    }\n\n    process.write(RenderUtil.render(table, process.width()) + \"\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "64", "src_id": "M381", "code": "\n@Override\npublic List<ResultModel> pollResults() {\n    try {\n        lastAccessTime = System.currentTimeMillis();\n        long accessTime = lastAccessTime;\n        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n            polling = true;\n            sendingItemCount = 0;\n            long firstResultTime = 0;\n            // Sending delay: time elapsed after firstResultTime\n            long sendingDelay = 0;\n            // Waiting time: time elapsed after access\n            long waitingTime = 0;\n            List<ResultModel> sendingResults = new ArrayList<>(resultBatchSizeLimit);\n\n            while (!closed\n                    && sendingResults.size() < resultBatchSizeLimit\n                    && sendingDelay < 100\n                    && waitingTime < pollTimeLimit) {\n                ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (aResult != null) {\n                    sendingResults.add(aResult);\n                    if (firstResultTime == 0) {\n                        firstResultTime = System.currentTimeMillis();\n                    }\n                    if (shouldFlush(sendingResults, aResult)) {\n                        break;\n                    }\n                } else {\n                    if (firstResultTime > 0) {\n                        sendingDelay = System.currentTimeMillis() - firstResultTime;\n                    }\n                    waitingTime = System.currentTimeMillis() - accessTime;\n                }\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"pollResults: {}, results: {}\",\n                    sendingResults.size(), JSON.toJSONString(sendingResults));\n            }\n            return sendingResults;\n        }\n    } catch (InterruptedException e) {\n        // Ignore\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lastAccessTime = System.currentTimeMillis();\n            polling = false;\n            lock.unlock();\n        }\n    }\n    return Collections.emptyList();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "65", "src_id": "M1199", "code": "\nprivate void initializeSlotsCache(Set<HostAndPort> startNodes, JedisClientConfig clientConfig) {\n    if (startNodes.isEmpty()) {\n        throw new JedisClusterOperationException(\"No nodes to initialize cluster slots cache.\");\n    }\n\n    ArrayList<HostAndPort> startNodeList = new ArrayList<>(startNodes);\n    Collections.shuffle(startNodeList);\n\n    JedisException firstException = null;\n    for (HostAndPort hostAndPort : startNodeList) {\n        try (Connection jedis = new Connection(hostAndPort, clientConfig)) {\n            cache.discoverClusterNodesAndSlots(jedis);\n            return;\n        } catch (JedisException e) {\n            if (firstException == null) {\n                firstException = e;\n            }\n            // try next nodes\n        }\n    }\n\n    if (System.getProperty(INIT_NO_ERROR_PROPERTY) != null) {\n        return;\n    }\n    JedisClusterOperationException uninitializedException =\n        new JedisClusterOperationException(\"Could not initialize cluster slots cache.\");\n    uninitializedException.addSuppressed(firstException);\n    throw uninitializedException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "66", "src_id": "M1275", "code": "\n@Override\npublic Document build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    String id = null;\n    Double score = null;\n    Map<String, Object> fields = null;\n    for (KeyValue kv : list) {\n        String key = BuilderFactory.STRING.build(kv.getKey());\n        switch (key) {\n            case ID_STR:\n                id = BuilderFactory.STRING.build(kv.getValue());\n                break;\n            case SCORE_STR:\n                score = BuilderFactory.DOUBLE.build(kv.getValue());\n                break;\n            case FIELDS_STR:\n                fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                break;\n        }\n    }\n    return new Document(id, score, fields);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "67", "src_id": "M933", "code": "\n@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n    if (credentialsProvider != null) {\n        builder.credentialsProvider(credentialsProvider);\n    } else {\n        builder.user(copy.getUser());\n        builder.password(copy.getPassword());\n    }\n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n        builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "68", "src_id": "M1159", "code": "\n@Override\npublic LibraryInfo build(Object data) {\n    if (data == null) return null;\n    List list = (List) data;\n    if (list.isEmpty()) return null;\n\n    if (list.get(0) instanceof KeyValue) {\n        String libname = null, enginename = null, librarycode = null;\n        List<Map<String, Object>> functions = null;\n        for (KeyValue kv : (List<KeyValue>) list) {\n            switch (BuilderFactory.STRING.build(kv.getKey())) {\n                case \"library_name\":\n                    libname = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case \"engine\":\n                    enginename = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case \"functions\":\n                    functions = ((List<Object>) kv.getValue()).stream().map(o -> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n                    break;\n                case \"library_code\":\n                    librarycode = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n            }\n        }\n        return new LibraryInfo(libname, enginename, functions, librarycode);\n    }\n\n    String libname = STRING.build(list.get(1));\n    String engine = STRING.build(list.get(3));\n    List<Object> rawFunctions = (List<Object>) list.get(5);\n    List<Map<String, Object>> functions = rawFunctions.stream().map(o -> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n    if (list.size() <= 6) {\n        return new LibraryInfo(libname, engine, functions);\n    }\n    String code = STRING.build(list.get(7));\n    return new LibraryInfo(libname, engine, functions, code);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1219", "code": "\n@Override\npublic void run() {\n\n    running.set(true);\n\n    while (running.get()) {\n\n        try {\n            // double check that it is not being shutdown\n            if (!running.get()) {\n                break;\n            }\n\n            sentinelJedis = new Jedis(node, sentinelClientConfig);\n\n            // code for active refresh\n            List<String> masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n            if (masterAddr == null || masterAddr.size() != 2) {\n                LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n            } else {\n                initMaster(toHostAndPort(masterAddr));\n            }\n\n            sentinelJedis.subscribe(new JedisPubSub() {\n                @Override\n                public void onMessage(String channel, String message) {\n                    LOG.debug(\"Sentinel {} published: {}.\", node, message);\n\n                    String[] switchMasterMsg = message.split(\" \");\n\n                    if (switchMasterMsg.length > 3) {\n\n                        if (masterName.equals(switchMasterMsg[0])) {\n                            initMaster(toHostAndPort(switchMasterMsg[3], switchMasterMsg[4]));\n                        } else {\n                            LOG.debug(\n                                \"Ignoring message on +switch-master for master {}. Our master is {}.\",\n                                switchMasterMsg[0], masterName);\n                        }\n\n                    } else {\n                        LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\",\n                            node, message);\n                    }\n                }\n            }, \"+switch-master\");\n\n        } catch (JedisException e) {\n\n            if (running.get()) {\n                LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node,\n                    subscribeRetryWaitTimeMillis, e);\n                try {\n                    Thread.sleep(subscribeRetryWaitTimeMillis);\n                } catch (InterruptedException se) {\n                    LOG.error(\"Sleep interrupted.\", se);\n                }\n            } else {\n                LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n            }\n        } finally {\n            IOUtils.closeQuietly(sentinelJedis);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "70", "src_id": "M126", "code": "\n@Override\npublic boolean equals(Object o) {\n    if (o == this) {\n        return true;\n    }\n    if (!(o instanceof CommandObject)) {\n        return false;\n    }\n\n    Iterator<Rawable> e1 = arguments.iterator();\n    Iterator<Rawable> e2 = ((CommandObject) o).arguments.iterator();\n    while (e1.hasNext() && e2.hasNext()) {\n        Rawable o1 = e1.next();\n        Rawable o2 = e2.next();\n        if (!(o1 == null ? o2 == null : o1.equals(o2))) {\n            return false;\n        }\n    }\n    if (e1.hasNext() || e2.hasNext()) {\n        return false;\n    }\n\n    return builder == ((CommandObject) o).builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "71", "src_id": "M44", "code": "\n@Override\npublic String discard() {\n    if (!inMulti) {\n        throw new IllegalStateException(\"DISCARD without MULTI\");\n    }\n\n    try {\n        // processPipelinedResponses(pipelinedResponses.size());\n        // do nothing\n        connection.sendCommand(DISCARD);\n        String status = connection.getStatusCodeReply();\n        if (!\"OK\".equals(status)) {\n            throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n        }\n        return status;\n    } catch (JedisConnectionException jce) {\n        broken = true;\n        throw jce;\n    } finally {\n        inMulti = false;\n        inWatch = false;\n        pipelinedResponses.clear();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n\n    JedisException suppressed = null;\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) {\n                continue;\n            }\n\n            jedis.ping();\n            return jedis;\n\n        } catch (JedisException ex) {\n            if (suppressed == null) { // remembering first suppressed exception\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "73", "src_id": "M934", "code": "\nprivate Socket createSslSocket(HostAndPort _hostAndPort, Socket socket) throws IOException, GeneralSecurityException {\n\n    Socket plainSocket = socket;\n\n    SSLSocketFactory _sslSocketFactory;\n    SSLParameters _sslParameters;\n\n    if (sslOptions != null) {\n\n        SSLContext _sslContext = sslOptions.createSslContext();\n        _sslSocketFactory = _sslContext.getSocketFactory();\n\n        _sslParameters = sslOptions.getSslParameters();\n\n    } else {\n\n        _sslSocketFactory = this.sslSocketFactory;\n        _sslParameters = this.sslParameters;\n    }\n\n    if (_sslSocketFactory == null) {\n        _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    SSLSocket sslSocket = (SSLSocket) _sslSocketFactory.createSocket(socket,\n        _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n    if (_sslParameters != null) {\n        sslSocket.setSSLParameters(_sslParameters);\n    }\n\n    // allowing HostnameVerifier for both SslOptions and legacy ssl config\n    if (hostnameVerifier != null\n        && !hostnameVerifier.verify(_hostAndPort.getHost(), sslSocket.getSession())) {\n        String message = String.format(\"The connection to '%s' failed ssl/tls hostname verification.\",\n            _hostAndPort.getHost());\n        throw new JedisConnectionException(message);\n    }\n\n    return new SSLSocketWrapper(sslSocket, plainSocket);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "74", "src_id": "M1216", "code": "\nprivate void initMaster(HostAndPort master) {\n    initPoolLock.lock();\n\n    try {\n        if (!master.equals(currentMaster)) {\n            currentMaster = master;\n\n            ConnectionPool newPool = createNodePool(currentMaster);\n\n            ConnectionPool existingPool = pool;\n            pool = newPool;\n            LOG.info(\"Created connection pool to master at {}.\", master);\n            if (clientSideCache != null) {\n                clientSideCache.flush();\n            }\n\n            if (existingPool != null) {\n                // although we clear the pool, we still have to check the returned object in getResource,\n                // this call only clears idle instances, not borrowed instances\n                // existingPool.clear(); // necessary??\n                existingPool.close();\n            }\n        }\n    } finally {\n        initPoolLock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1275", "code": "\n    @Override\n    public Document build(Object data) {\n        final List<KeyValue> list = (List<KeyValue>) data;\n        String id = null;\n        Double score = null;\n        Map<String, Object> fields = null;\n        for (KeyValue kv : list) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            switch (key) {\n                case ID_STR:\n                    id = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case SCORE_STR:\n                    score = BuilderFactory.DOUBLE.build(kv.getValue());\n                    break;\n                case FIELDS_STR:\n                    fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                    break;\n            }\n        }\n        return new Document(id, score, fields);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "76", "src_id": "M889", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (timestamp != null) {\n            args.add(TIMESTAMP).add(timestamp);\n        }\n\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1141", "code": "\n    @Override\n    public final <T> T executeCommand(CommandObject<T> commandObject) {\n        final Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n        int consecutiveConnectionFailures = 0;\n        JedisException lastException = null;\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n            Connection connection = null;\n            try {\n                connection = provider.getConnection(commandObject.getArguments());\n                return execute(connection, commandObject);\n            } catch (JedisConnectionException jce) {\n                lastException = jce;\n                ++consecutiveConnectionFailures;\n                log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n                boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n                if (reset) {\n                    consecutiveConnectionFailures = 0;\n                }\n            } finally {\n                if (connection != null) {\n                    connection.close();\n                }\n            }\n            if (Instant.now().isAfter(deadline)) {\n                throw new JedisException(\"Retry deadline exceeded.\");\n            }\n        }\n\n        final JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n        maxAttemptsException.addSuppressed(lastException);\n        throw maxAttemptsException;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "78", "src_id": "M1057", "code": "\n    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        final List list = (List) data;\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            Object resultsData = null;\n            Object profileData = null;\n\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData),\n                    ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue.of(resultsBuilder.build(list.get(0)),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "79", "src_id": "M1102", "code": "\n    @Override\n    public final List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"EXEC without MULTI\");\n        }\n\n        try (Connection connection = failoverProvider.getConnection()) {\n            commands.forEach((command) -> connection.sendCommand(command.getKey()));\n            connection.getMany(commands.size());\n\n            for (int idx = 0; idx < extraCommandCount.get(); ++idx) {\n                commands.poll();\n            }\n\n            connection.sendCommand(EXEC);\n\n            final List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                commands.clear();\n                return null;\n            }\n\n            final List<Object> formatted = new ArrayList<>(unformatted.size() - extraCommandCount.get());\n            for (Object rawReply : unformatted) {\n                try {\n                    Response<?> response = commands.poll().getValue();\n                    response.set(rawReply);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "80", "src_id": "M1304", "code": "\n    @Override\n    public AggregationResult build(Object data) {\n        List list = (List) data;\n\n        if (list.get(0) instanceof KeyValue) {\n            final List<KeyValue> kvList = (List<KeyValue>) data;\n            long totalResults = -1;\n            List<Map<String, Object>> results = null;\n            List<String> warnings = null;\n            for (KeyValue kv : kvList) {\n                String key = BuilderFactory.STRING.build(kv.getKey());\n                Object rawVal = kv.getValue();\n                switch (key) {\n                    case TOTAL_RESULTS_STR:\n                        totalResults = BuilderFactory.LONG.build(rawVal);\n                        break;\n                    case RESULTS_STR:\n                        final List<List<KeyValue>> resList = (List<List<KeyValue>>) rawVal;\n                        results = new ArrayList<>(resList.size());\n                        for (List<KeyValue> rikv : resList) {\n                            for (KeyValue ikv : rikv) {\n                                if (FIELDS_STR.equals(BuilderFactory.STRING.build(ikv.getKey()))) {\n                                    results.add(BuilderFactory.ENCODED_OBJECT_MAP.build(ikv.getValue()));\n                                    break;\n                                }\n                            }\n                        }\n                        break;\n                    case WARNINGS_STR:\n                        warnings = BuilderFactory.STRING_LIST.build(rawVal);\n                        break;\n                }\n            }\n            return new AggregationResult(totalResults, results, warnings);\n        }\n\n        list = (List<Object>) SafeEncoder.encodeObject(data);\n        long totalResults = (Long) list.get(0);\n        List<Map<String, Object>> results = new ArrayList<>(list.size() - 1);\n\n        for (int i = 1; i < list.size(); i++) {\n            List<Object> mapList = (List<Object>) list.get(i);\n            Map<String, Object> map = new HashMap<>(mapList.size() / 2, 1f);\n            for (int j = 0; j < mapList.size(); j += 2) {\n                Object r = mapList.get(j);\n                if (r instanceof JedisDataException) {\n                    throw (JedisDataException) r;\n                }\n                map.put((String) r, mapList.get(j + 1));\n            }\n            results.add(map);\n        }\n        return new AggregationResult(totalResults, results);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "81", "src_id": "M1219", "code": "\n    @Override\n    public void run() {\n        running.set(true);\n\n        while (running.get()) {\n            try {\n                if (!running.get()) {\n                    break;\n                }\n\n                sentinelJedis = new Jedis(node, sentinelClientConfig);\n                final List<String> masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n                if (masterAddr == null || masterAddr.size() != 2) {\n                    LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n                } else {\n                    initMaster(toHostAndPort(masterAddr));\n                }\n\n                sentinelJedis.subscribe(new JedisPubSub() {\n                    @Override\n                    public void onMessage(String channel, String message) {\n                        LOG.debug(\"Sentinel {} published: {}.\", node, message);\n                        String[] switchMasterMsg = message.split(\" \");\n\n                        if (switchMasterMsg.length > 3) {\n                            if (masterName.equals(switchMasterMsg[0])) {\n                                initMaster(toHostAndPort(switchMasterMsg[3], switchMasterMsg[4]));\n                            } else {\n                                LOG.debug(\"Ignoring message on +switch-master for master {}. Our master is {}.\",\n                                        switchMasterMsg[0], masterName);\n                            }\n                        } else {\n                            LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\",\n                                    node, message);\n                        }\n                    }\n                }, \"+switch-master\");\n            } catch (JedisException e) {\n                if (running.get()) {\n                    LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node,\n                            subscribeRetryWaitTimeMillis, e);\n                    try {\n                        Thread.sleep(subscribeRetryWaitTimeMillis);\n                    } catch (InterruptedException se) {\n                        LOG.error(\"Sleep interrupted.\", se);\n                    }\n                } else {\n                    LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n                }\n            } finally {\n                IOUtils.closeQuietly(sentinelJedis);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "82", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "83", "src_id": "M1346", "code": "\n    @Override\n    public Map<String, Map<String, Double>> build(Object data) {\n        final List rawDataList = (List) data;\n        if (rawDataList.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (rawDataList.get(0) instanceof KeyValue) {\n            KeyValue rawData = (KeyValue) rawDataList.get(0);\n            String header = STRING.build(rawData.getKey());\n            if (!RESULTS.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n\n            return ((List<KeyValue>) rawData.getValue()).stream().collect(Collectors.toMap(\n                    rawTerm -> STRING.build(rawTerm.getKey()),\n                    rawTerm -> ((List<List<KeyValue>>) rawTerm.getValue()).stream()\n                            .collect(Collectors.toMap(entry -> STRING.build(entry.get(0).getKey()),\n                                    entry -> BuilderFactory.DOUBLE.build(entry.get(0).getValue()))),\n                    (x, y) -> x, LinkedHashMap::new));\n        }\n\n        Map<String, Map<String, Double>> returnTerms = new LinkedHashMap<>(rawDataList.size());\n        for (Object rawData : rawDataList) {\n            List<Object> rawElements = (List<Object>) rawData;\n            String header = STRING.build(rawElements.get(0));\n            if (!TERM.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n            String term = STRING.build(rawElements.get(1));\n\n            List<List<Object>> list = (List<List<Object>>) rawElements.get(2);\n            Map<String, Double> entries = new LinkedHashMap<>(list.size());\n            list.forEach(entry -> entries.put(STRING.build(entry.get(1)), BuilderFactory.DOUBLE.build(entry.get(0))));\n\n            returnTerms.put(term, entries);\n        }\n        return returnTerms;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "84", "src_id": "M51", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, String> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, String> map = new HashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), STRING.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<String, String> map = new HashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), STRING.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "85", "src_id": "M1108", "code": "\n@Override\npublic Object build(Object data) {\n    if (data == null) {\n        return null;\n    }\n\n    if (!(data instanceof byte[])) {\n        return data;\n    }\n    \n    String str = STRING.build(data);\n    if (str.charAt(0) == '{') {\n        try {\n            return new JSONObject(str);\n        } catch (Exception e) {\n            // Exception handling intentionally left blank\n        }\n    } else if (str.charAt(0) == '[') {\n        try {\n            return new JSONArray(str);\n        } catch (Exception e) {\n            // Exception handling intentionally left blank\n        }\n    }\n    return str;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "86", "src_id": "M1275", "code": "\n@Override\npublic Document build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    String id = null;\n    Double score = null;\n    Map<String, Object> fields = null;\n    \n    for (KeyValue kv : list) {\n        String key = BuilderFactory.STRING.build(kv.getKey());\n        switch (key) {\n            case ID_STR:\n                id = BuilderFactory.STRING.build(kv.getValue());\n                break;\n            case SCORE_STR:\n                score = BuilderFactory.DOUBLE.build(kv.getValue());\n                break;\n            case FIELDS_STR:\n                fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                break;\n        }\n    }\n    return new Document(id, score, fields);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "87", "src_id": "M1159", "code": "\n@Override\npublic LibraryInfo build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    \n    List list = (List) data;\n    if (list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        String libname = null;\n        String enginename = null;\n        String librarycode = null;\n        List<Map<String, Object>> functions = null;\n        \n        for (KeyValue kv : (List<KeyValue>) list) {\n            switch (BuilderFactory.STRING.build(kv.getKey())) {\n                case \"library_name\":\n                    libname = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case \"engine\":\n                    enginename = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case \"functions\":\n                    functions = ((List<Object>) kv.getValue()).stream()\n                        .map(o -> ENCODED_OBJECT_MAP.build(o))\n                        .collect(Collectors.toList());\n                    break;\n                case \"library_code\":\n                    librarycode = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n            }\n        }\n        return new LibraryInfo(libname, enginename, functions, librarycode);\n    }\n\n    String libname = STRING.build(list.get(1));\n    String engine = STRING.build(list.get(3));\n    List<Object> rawFunctions = (List<Object>) list.get(5);\n    List<Map<String, Object>> functions = rawFunctions.stream()\n        .map(o -> ENCODED_OBJECT_MAP.build(o))\n        .collect(Collectors.toList());\n    \n    if (list.size() <= 6) {\n        return new LibraryInfo(libname, engine, functions);\n    }\n    \n    String code = STRING.build(list.get(7));\n    return new LibraryInfo(libname, engine, functions, code);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "88", "src_id": "M934", "code": "\nprivate Socket createSslSocket(HostAndPort hostAndPort, Socket socket)\n    throws IOException, GeneralSecurityException {\n    \n    Socket plainSocket = socket;\n    SSLSocketFactory sslSocketFactory;\n    SSLParameters sslParameters;\n\n    if (sslOptions != null) {\n        SSLContext sslContext = sslOptions.createSslContext();\n        sslSocketFactory = sslContext.getSocketFactory();\n        sslParameters = sslOptions.getSslParameters();\n    } else {\n        sslSocketFactory = this.sslSocketFactory;\n        sslParameters = this.sslParameters;\n    }\n\n    if (sslSocketFactory == null) {\n        sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(\n        socket, hostAndPort.getHost(), hostAndPort.getPort(), true\n    );\n\n    if (sslParameters != null) {\n        sslSocket.setSSLParameters(sslParameters);\n    }\n\n    if (hostnameVerifier != null \n        && !hostnameVerifier.verify(hostAndPort.getHost(), sslSocket.getSession())) {\n        String message = String.format(\n            \"The connection to '%s' failed ssl/tls hostname verification.\",\n            hostAndPort.getHost()\n        );\n        throw new JedisConnectionException(message);\n    }\n\n    return new SSLSocketWrapper(sslSocket, plainSocket);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "89", "src_id": "M1304", "code": "\n@Override\npublic AggregationResult build(Object data) {\n    List list = (List) data;\n\n    if (list.get(0) instanceof KeyValue) {\n        List<KeyValue> kvList = (List<KeyValue>) data;\n        long totalResults = -1;\n        List<Map<String, Object>> results = null;\n        List<String> warnings = null;\n        \n        for (KeyValue kv : kvList) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            Object rawVal = kv.getValue();\n            switch (key) {\n                case TOTAL_RESULTS_STR:\n                    totalResults = BuilderFactory.LONG.build(rawVal);\n                    break;\n                case RESULTS_STR:\n                    List<List<KeyValue>> resList = (List<List<KeyValue>>) rawVal;\n                    results = new ArrayList<>(resList.size());\n                    for (List<KeyValue> rikv : resList) {\n                        for (KeyValue ikv : rikv) {\n                            if (FIELDS_STR.equals(BuilderFactory.STRING.build(ikv.getKey()))) {\n                                results.add(BuilderFactory.ENCODED_OBJECT_MAP.build(ikv.getValue()));\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                case WARNINGS_STR:\n                    warnings = BuilderFactory.STRING_LIST.build(rawVal);\n                    break;\n            }\n        }\n        return new AggregationResult(totalResults, results, warnings);\n    }\n\n    list = (List<Object>) SafeEncoder.encodeObject(data);\n    long totalResults = (Long) list.get(0);\n    List<Map<String, Object>> results = new ArrayList<>(list.size() - 1);\n\n    for (int i = 1; i < list.size(); i++) {\n        List<Object> mapList = (List<Object>) list.get(i);\n        Map<String, Object> map = new HashMap<>(mapList.size() / 2, 1f);\n        for (int j = 0; j < mapList.size(); j += 2) {\n            Object r = mapList.get(j);\n            if (r instanceof JedisDataException) {\n                throw (JedisDataException) r;\n            }\n            map.put((String) r, mapList.get(j + 1));\n        }\n        results.add(map);\n    }\n    return new AggregationResult(totalResults, results);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "90", "src_id": "M959", "code": "\nprivate void process() {\n    do {\n        Object reply = authenticator.client.getUnflushedObject();\n\n        if (reply instanceof List) {\n            List<Object> listReply = (List<Object>) reply;\n            final Object firstObj = listReply.get(0);\n            if (!(firstObj instanceof byte[])) {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n            \n            final byte[] resp = (byte[]) firstObj;\n            if (Arrays.equals(SUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onSubscribe(enchannel, subscribedChannels);\n            } else if (Arrays.equals(UNSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onUnsubscribe(enchannel, subscribedChannels);\n            } else if (Arrays.equals(MESSAGE.getRaw(), resp)) {\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final Object mesg = listReply.get(2);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                if (mesg instanceof List) {\n                    ((List<byte[]>) mesg).forEach(bmesg -> onMessage(enchannel, encode(bmesg)));\n                } else {\n                    onMessage(enchannel, (mesg == null) ? null : encode((byte[]) mesg));\n                }\n            } else if (Arrays.equals(PMESSAGE.getRaw(), resp)) {\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final byte[] bchannel = (byte[]) listReply.get(2);\n                final byte[] bmesg = (byte[]) listReply.get(3);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                final T enmesg = (bmesg == null) ? null : encode(bmesg);\n                onPMessage(enpattern, enchannel, enmesg);\n            } else if (Arrays.equals(PSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                onPSubscribe(enpattern, subscribedChannels);\n            } else if (Arrays.equals(PUNSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                onPUnsubscribe(enpattern, subscribedChannels);\n            } else if (Arrays.equals(PONG.getRaw(), resp)) {\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                onPong(enpattern);\n            } else {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n        } else if (reply instanceof byte[]) {\n            Consumer<Object> resultHandler = authenticator.resultHandler.poll();\n            if (resultHandler == null) {\n                throw new JedisException(\"Unexpected message : \" + SafeEncoder.encode((byte[]) reply));\n            }\n            resultHandler.accept(reply);\n        } else {\n            throw new JedisException(\"Unknown message type: \" + reply);\n        }\n    } while (!Thread.currentThread().isInterrupted() && isSubscribed());\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "91", "src_id": "M1145", "code": "\n@Override\npublic final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    \n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n        HostAndPort node = HostAndPort.from(entry.getKey());\n        ConnectionPool pool = entry.getValue();\n        \n        try (Connection connection = pool.getResource()) {\n            T aReply = execute(connection, commandObject);\n            bcastError.addReply(node, aReply);\n            \n            if (isErrored) {\n                // Continue processing but keep error state\n            } else if (reply == null) {\n                reply = aReply;\n            } else if (!reply.equals(aReply)) {\n                isErrored = true;\n                reply = null;\n            }\n        } catch (Exception e) {\n            bcastError.addReply(node, e);\n            isErrored = true;\n        }\n    }\n    \n    if (isErrored) {\n        throw bcastError;\n    }\n    return reply;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "92", "src_id": "M52", "code": "\n@Override\npublic Map<String, Object> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    \n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        final Map<String, Object> map = new HashMap<>(list.size(), 1f);\n        for (Object o : list) {\n            KeyValue kv = (KeyValue) o;\n            map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        final Map<String, Object> map = new HashMap<>(list.size() / 2, 1f);\n        Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "93", "src_id": "M34", "code": "\n@Override\npublic boolean isCacheable(ProtocolCommand command, List<Object> keys) {\n    if (allowCommands != null && !allowCommands.contains(command)) {\n        return false;\n    }\n    if (denyCommands != null && denyCommands.contains(command)) {\n        return false;\n    }\n\n    for (Object key : keys) {\n        if (!(key instanceof String)) {\n            return false;\n        }\n        String keyStr = (String) key;\n        if (allowKeys != null && !allowKeys.contains(keyStr)) {\n            return false;\n        }\n        if (denyKeys != null && denyKeys.contains(keyStr)) {\n            return false;\n        }\n    }\n\n    return DefaultCacheable.isDefaultCacheableCommand(command);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "94", "src_id": "M28", "code": "\n@Override\npublic <T> T executeCommand(final CommandObject<T> commandObject) {\n    final CacheKey cacheKey = new CacheKey(commandObject);\n    if (!cache.isCacheable(cacheKey)) {\n        cache.getStats().nonCacheable();\n        return super.executeCommand(commandObject);\n    }\n\n    CacheEntry<T> cacheEntry = cache.get(cacheKey);\n    if (cacheEntry != null) {\n        cacheEntry = validateEntry(cacheEntry);\n        if (cacheEntry != null) {\n            cache.getStats().hit();\n            return cacheEntry.getValue();\n        }\n    }\n\n    cache.getStats().miss();\n    T value = super.executeCommand(commandObject);\n    cacheEntry = new CacheEntry<>(cacheKey, value, this);\n    cache.set(cacheKey, cacheEntry);\n    return cacheEntry.getValue();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "95", "src_id": "M1009", "code": "\n    @Override\n    public String apply(String input) {\n        StringBuilder output = new StringBuilder();\n        String[] lines = input.split(\"\\n\");\n        int continueCount = 0;\n        int lastStartPos = 0;\n        int lastContinueLineNum = -1;\n        int matchCount = 0;\n        for (int lineNum = 0; lineNum < lines.length;) {\n            String line = null;\n            if (this.trimEnd) {\n                line = StringUtils.stripEnd(lines[lineNum], null);\n            } else {\n                line = lines[lineNum];\n            }\n            lineNum++;\n\n            final boolean match;\n            if (pattern == null) {\n                match = (ignoreCase ? line.toLowerCase() : line).contains(keyword);\n            } else {\n                match = pattern.matcher(line).find();\n            }\n            if (invertMatch != match) {\n                matchCount++;\n                if (beforeLines > continueCount) {\n                    int n = lastContinueLineNum == -1 ? (beforeLines >= lineNum ? 1 : lineNum - beforeLines)\n                                    : lineNum - beforeLines - continueCount;\n                    if (n >= lastContinueLineNum || lastContinueLineNum == -1) {\n                        StringBuilder beforeSb = new StringBuilder();\n                        for (int i = n; i < lineNum; i++) {\n                            appendLine(beforeSb, i, lines[i - 1]);\n                        }\n                        output.insert(lastStartPos, beforeSb);\n                    }\n                }\n\n                lastStartPos = output.length();\n                appendLine(output, lineNum, line);\n\n                if (afterLines > continueCount) {\n                    int last = lineNum + afterLines - continueCount;\n                    if (last > lines.length) {\n                        last = lines.length;\n                    }\n                    for (int i = lineNum; i < last; i++) {\n                        appendLine(output, i + 1, lines[i]);\n                        lineNum++;\n                        continueCount++;\n                        lastStartPos = output.length();\n                    }\n                }\n\n                continueCount++;\n                if (maxCount > 0 && matchCount >= maxCount) {\n                    break;\n                }\n            } else {\n                if (continueCount > 0) {\n                    lastContinueLineNum = lineNum - 1;\n                    continueCount = 0;\n                }\n            }\n        }\n        final String str = output.toString();\n        return str;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "96", "src_id": "M87", "code": "\n    private static List<String> readLines(File batchFile) {\n        List<String> list = new ArrayList<>();\n        try (BufferedReader br = new BufferedReader(new FileReader(batchFile))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                list.add(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "97", "src_id": "M454", "code": "\n    private void renderObject(Object obj, int deep, int expand, StringBuilder buf) throws ObjectTooLargeException {\n        if (null == obj) {\n            appendStringBuilder(buf, \"null\");\n        } else {\n            final Class<?> clazz = obj.getClass();\n            final String className = clazz.getSimpleName();\n\n            if (Integer.class.isInstance(obj)\n                || Long.class.isInstance(obj)\n                || Float.class.isInstance(obj)\n                || Double.class.isInstance(obj)\n                || Short.class.isInstance(obj)\n                || Byte.class.isInstance(obj)\n                || Boolean.class.isInstance(obj)) {\n                appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n            } else if (Character.class.isInstance(obj)) {\n                final Character c = (Character) obj;\n                if (c >= 32 && c <= 126) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n                } else if (ASCII_MAP.containsKey((byte) c.charValue())) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, ASCII_MAP.get((byte) c.charValue())));\n                } else {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n                }\n            } else if (String.class.isInstance(obj)) {\n                appendStringBuilder(buf, \"@\");\n                appendStringBuilder(buf, className);\n                appendStringBuilder(buf, \"[\");\n                for (Character c : ((String) obj).toCharArray()) {\n                    switch (c) {\n                        case '\\n' -> appendStringBuilder(buf, \"\\\\n\");\n                        case '\\r' -> appendStringBuilder(buf, \"\\\\r\");\n                        default -> appendStringBuilder(buf, c.toString());\n                    }\n                }\n                appendStringBuilder(buf, \"]\");\n            } else if (Collection.class.isInstance(obj)) {\n                @SuppressWarnings(\"unchecked\") final Collection<Object> collection = (Collection<Object>) obj;\n                if (!isExpand(deep, expand) || collection.isEmpty()) {\n                    appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                      className,\n                                      collection.isEmpty(),\n                                      collection.size()));\n                } else {\n                    appendStringBuilder(buf, format(\"@%s[\", className));\n                    for (Object e : collection) {\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep+1; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        renderObject(e, deep + 1, expand, buf);\n                        appendStringBuilder(buf, \",\");\n                    }\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    appendStringBuilder(buf, \"]\");\n                }\n            } else if (Map.class.isInstance(obj)) {\n                @SuppressWarnings(\"unchecked\") final Map<Object, Object> map = (Map<Object, Object>) obj;\n                if (!isExpand(deep, expand) || map.isEmpty()) {\n                    appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                      className,\n                                      map.isEmpty(),\n                                      map.size()));\n                } else {\n                    appendStringBuilder(buf, format(\"@%s[\", className));\n                    for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep+1; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        renderObject(entry.getKey(), deep + 1, expand, buf);\n                        appendStringBuilder(buf, \":\");\n                        renderObject(entry.getValue(), deep + 1, expand, buf);\n                        appendStringBuilder(buf, \",\");\n                    }\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    appendStringBuilder(buf, \"]\");\n                }\n            } else if (obj.getClass().isArray()) {\n                final String typeName = obj.getClass().getSimpleName();\n                if (typeName.equals(\"int[]\")) {\n                    final int[] arrays = (int[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (int e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else if (typeName.equals(\"long[]\")) {\n                    final long[] arrays = (long[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (long e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else if (typeName.equals(\"short[]\")) {\n                    final short[] arrays = (short[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (short e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else if (typeName.equals(\"float[]\")) {\n                    final float[] arrays = (float[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (float e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else if (typeName.equals(\"double[]\")) {\n                    final double[] arrays = (double[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (double e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else if (typeName.equals(\"boolean[]\")) {\n                    final boolean[] arrays = (boolean[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (boolean e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else if (typeName.equals(\"char[]\")) {\n                    final char[] arrays = (char[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (char e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else if (typeName.equals(\"byte[]\")) {\n                    final byte[] arrays = (byte[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (byte e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                } else {\n                    final Object[] arrays = (Object[]) obj;\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n                                          typeName,\n                                          arrays.length == 0,\n                                          arrays.length));\n                    } else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (Object e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }\n            } else if (Throwable.class.isInstance(obj)) {\n                if (!isExpand(deep, expand)) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n                } else {\n                    final Throwable throwable = (Throwable) obj;\n                    final StringWriter sw = new StringWriter();\n                    final PrintWriter pw = new PrintWriter(sw);\n                    throwable.printStackTrace(pw);\n                    appendStringBuilder(buf, sw.toString());\n                }\n            } else if (Date.class.isInstance(obj)) {\n                appendStringBuilder(buf, format(\"@%s[%s]\", className, new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\").format(obj)));\n            } else if (obj instanceof Enum<?>) {\n                appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n            } else {\n                if (!isExpand(deep, expand)) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n                } else {\n                    appendStringBuilder(buf, format(\"@%s[\", className));\n                    final List<Field> fields;\n                    Class<?> objClass = obj.getClass();\n                    if (GlobalOptions.printParentFields) {\n                        fields = new ArrayList<>();\n                        while (objClass != null) {\n                            fields.addAll(Arrays.asList(objClass.getDeclaredFields()));\n                            objClass = objClass.getSuperclass();\n                        }\n                    } else {\n                        fields = new ArrayList<>(Arrays.asList(objClass.getDeclaredFields()));\n                    }\n\n                    for (Field field : fields) {\n                        field.setAccessible(true);\n                        try {\n                            final Object value = field.get(obj);\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep+1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n                            appendStringBuilder(buf, field.getName());\n                            appendStringBuilder(buf, \"=\");\n                            renderObject(value, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        } catch (ObjectTooLargeException t) {\n                            buf.append(\"...\");\n                            break;\n                        } catch (Throwable t) {\n                            // ignore\n                        }\n                    }\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    appendStringBuilder(buf, \"]\");\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "98", "src_id": "M114", "code": "\n    public boolean isAvailable() {\n        if (isConnected()) {\n            try {\n                if (_socket_.getInetAddress() == null) {\n                    return false;\n                }\n                if (_socket_.getPort() == 0) {\n                    return false;\n                }\n                if (_socket_.getRemoteSocketAddress() == null) {\n                    return false;\n                }\n                if (_socket_.isClosed()) {\n                    return false;\n                }\n                if (_socket_.isInputShutdown()) {\n                    return false;\n                }\n                if (_socket_.isOutputShutdown()) {\n                    return false;\n                }\n                _socket_.getInputStream();\n                _socket_.getOutputStream();\n            } catch (IOException ioex) {\n                return false;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "99", "src_id": "M716", "code": "\n    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n        table.row(\"IS-RETURN\", \"\" + false);\n        table.row(\"IS-EXCEPTION\", \"\" + true);\n\n        Throwable cause;\n        Throwable t = (Throwable) throwableVO.getObject();\n        if (t instanceof InvocationTargetException) {\n            cause = t.getCause();\n        } else {\n            cause = t;\n        }\n\n        if (throwableVO.needExpand()) {\n            table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n        } else {\n            try (StringWriter stringWriter = new StringWriter();\n                 PrintWriter printWriter = new PrintWriter(stringWriter)) {\n                cause.printStackTrace(printWriter);\n                table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n            } catch (Exception e) {\n                // Handle exception if needed\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "100", "src_id": "M566", "code": "\n    @Override\n    public void process(final CommandProcess process) {\n        Session session = process.session();\n        timer = new Timer(\"Timer-for-arthas-dashboard-\" + session.getSessionId(), true);\n        process.interruptHandler(new DashboardInterruptHandler(process, timer));\n\n        Handler<Void> stopHandler = new Handler<Void>() {\n            @Override\n            public void handle(Void event) {\n                stop();\n            }\n        };\n\n        Handler<Void> restartHandler = new Handler<Void>() {\n            @Override\n            public void handle(Void event) {\n                restart(process);\n            }\n        };\n        process.suspendHandler(stopHandler);\n        process.resumeHandler(restartHandler);\n        process.endHandler(stopHandler);\n        process.stdinHandler(new QExitHandler(process));\n        timer.scheduleAtFixedRate(new DashboardTimerTask(process), 0, getInterval());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "101", "src_id": "M443", "code": "\n    private String drawField() {\n        final StringBuilder fieldSB = new StringBuilder();\n        final Field[] fields = clazz.getDeclaredFields();\n        if (fields.length > 0) {\n            for (Field field : fields) {\n                KVView kvView = new KVView(\n                    new TableView.ColumnDefine(TableView.Align.RIGHT), \n                    new TableView.ColumnDefine(50, false, TableView.Align.LEFT)\n                )\n                .add(\"modifier\", StringUtils.modifier(field.getModifiers(), ','))\n                .add(\"type\", StringUtils.classname(field.getType()))\n                .add(\"name\", field.getName());\n\n                StringBuilder annotationSB = new StringBuilder();\n                Annotation[] annotationArray = field.getAnnotations();\n                if (null != annotationArray && annotationArray.length > 0) {\n                    for (Annotation annotation : annotationArray) {\n                        annotationSB.append(StringUtils.classname(annotation.annotationType())).append(\",\");\n                    }\n                    if (annotationSB.length() > 0) {\n                        annotationSB.deleteCharAt(annotationSB.length() - 1);\n                    }\n                    kvView.add(\"annotation\", annotationSB.toString());\n                }\n\n                if (Modifier.isStatic(field.getModifiers())) {\n                    boolean isAccessible = field.isAccessible();\n                    try {\n                        field.setAccessible(true);\n                        kvView.add(\"value\", StringUtils.objectToString(field.get(null)));\n                    } catch (IllegalAccessException e) {\n                        // Handle exception\n                    } finally {\n                        field.setAccessible(isAccessible);\n                    }\n                }\n                fieldSB.append(kvView.draw()).append(\"\\n\");\n            }\n        }\n        return fieldSB.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "102", "src_id": "M270", "code": "\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64w?|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (\"ia64n\".equals(value)) {\n            return \"itanium_32\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(mips|mips32)$\")) {\n            return \"mips_32\";\n        }\n        if (value.matches(\"^(mipsel|mips32el)$\")) {\n            return \"mipsel_32\";\n        }\n        if (\"mips64\".equals(value)) {\n            return \"mips_64\";\n        }\n        if (\"mips64el\".equals(value)) {\n            return \"mipsel_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (value.matches(\"^(ppcle|ppc32le)$\")) {\n            return \"ppcle_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n        return value;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "103", "src_id": "M232", "code": "\n    public void start() throws Exception {\n        final SslContext sslCtx;\n        if (ssl) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup)\n         .channel(NioServerSocketChannel.class)\n         .handler(new LoggingHandler(LogLevel.INFO))\n         .childHandler(new TunnelSocketServerInitializer(this, sslCtx));\n\n        if (StringUtils.isBlank(host)) {\n            channel = b.bind(port).sync().channel();\n        } else {\n            channel = b.bind(host, port).sync().channel();\n        }\n\n        logger.info(\"Tunnel server listen at {}:{}\", host, port);\n\n        workerGroup.scheduleWithFixedDelay(new Runnable() {\n            @Override\n            public void run() {\n                agentInfoMap.entrySet().removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n                clientConnectionInfoMap.entrySet()\n                        .removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n                \n                if (tunnelClusterStore != null && clientConnectHost != null) {\n                    try {\n                        for (Entry<String, AgentInfo> entry : agentInfoMap.entrySet()) {\n                            tunnelClusterStore.addAgent(\n                                entry.getKey(), \n                                new AgentClusterInfo(entry.getValue(), clientConnectHost, port), \n                                60 * 60, \n                                TimeUnit.SECONDS\n                            );\n                        }\n                    } catch (Throwable t) {\n                        logger.error(\"update tunnel info error\", t);\n                    }\n                }\n            }\n        }, 60, 60, TimeUnit.SECONDS);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "104", "src_id": "M1354", "code": "\n    public static String nullSafeToString(byte[] array) {\n        if (array == null) {\n            return \"null\";\n        }\n        int length = array.length;\n        if (length == 0) {\n            return \"{}\";\n        }\n\n        StringBuilder sb = new StringBuilder(\"{\");\n        for (int i = 0; i < length; ++i) {\n            if (i > 0) {\n                sb.append(\", \");\n            }\n            sb.append(array[i]);\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "105", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "106", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "107", "src_id": "M1197", "code": "\npublic final B nextBatch() {\n    if (roundRobinCompleted) {\n        throw new NoSuchElementException();\n    }\n\n    CommandArguments args;\n    if (iterationCompleted) {\n        connection = connections.poll();\n        args = initCommandArguments();\n    } else {\n        args = nextCommandArguments(lastReply);\n    }\n\n    Object rawReply;\n    if (connection.getValue() instanceof Connection) {\n        rawReply = ((Connection) connection.getValue()).executeCommand(args);\n    } else if (connection.getValue() instanceof Pool) {\n        try (Connection c = ((Pool<Connection>) connection.getValue()).getResource()) {\n            rawReply = c.executeCommand(args);\n        }\n    } else {\n        throw new IllegalArgumentException(connection.getValue().getClass() + \"is not supported.\");\n    }\n\n    lastReply = builder.build(rawReply);\n    iterationCompleted = isNodeCompleted(lastReply);\n    if (iterationCompleted) {\n        if (connections.isEmpty()) {\n            roundRobinCompleted = true;\n        }\n    }\n    return lastReply;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "108", "src_id": "M1251", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    args.addParams(fieldName);\n    args.add(TEXT);\n\n    if (indexMissing) {\n        args.add(INDEXMISSING);\n    }\n    if (indexEmpty) {\n        args.add(INDEXEMPTY);\n    }\n\n    if (weight != null) {\n        args.add(WEIGHT).add(weight);\n    }\n\n    if (noStem) {\n        args.add(NOSTEM);\n    }\n\n    if (phoneticMatcher != null) {\n        args.add(PHONETIC).add(phoneticMatcher);\n    }\n\n    if (withSuffixTrie) {\n        args.add(WITHSUFFIXTRIE);\n    }\n\n    if (sortableUNF) {\n        args.add(SORTABLE).add(UNF);\n    } else if (sortable) {\n        args.add(SORTABLE);\n    }\n\n    if (noIndex) {\n        args.add(NOINDEX);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "109", "src_id": "M873", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (fromTimestamp == null) {\n        args.add(MINUS);\n    } else {\n        args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n        args.add(PLUS);\n    } else {\n        args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n        args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n        args.add(FILTER_BY_TS);\n        for (long ts : filterByTimestamps) {\n            args.add(toByteArray(ts));\n        }\n    }\n\n    if (filterByValues != null) {\n        args.add(FILTER_BY_VALUE);\n        for (double value : filterByValues) {\n            args.add(toByteArray(value));\n        }\n    }\n\n    if (count != null) {\n        args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n        if (align != null) {\n            args.add(ALIGN).add(align);\n        }\n\n        args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n        if (bucketTimestamp != null) {\n            args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n        }\n\n        if (empty) {\n            args.add(EMPTY);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "110", "src_id": "M1349", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (dataType != null) {\n        args.add(ON).add(dataType);\n    }\n\n    if (prefix != null) {\n        args.add(PREFIX).add(prefix.size()).addObjects(prefix);\n    }\n\n    if (filter != null) {\n        args.add(FILTER).add(filter);\n    }\n\n    if (language != null) {\n        args.add(LANGUAGE).add(language);\n    }\n    if (languageField != null) {\n        args.add(LANGUAGE_FIELD).add(languageField);\n    }\n\n    if (score != null) {\n        args.add(SCORE).add(score);\n    }\n    if (scoreField != null) {\n        args.add(SCORE_FIELD).add(scoreField);\n    }\n\n    if (maxTextFields) {\n        args.add(MAXTEXTFIELDS);\n    }\n\n    if (noOffsets) {\n        args.add(NOOFFSETS);\n    }\n\n    if (temporary != null) {\n        args.add(TEMPORARY).add(temporary);\n    }\n\n    if (noHL) {\n        args.add(NOHL);\n    }\n\n    if (noFields) {\n        args.add(NOFIELDS);\n    }\n\n    if (noFreqs) {\n        args.add(NOFREQS);\n    }\n\n    if (stopwords != null) {\n        args.add(STOPWORDS).add(stopwords.size());\n        stopwords.forEach(w -> args.add(w));\n    }\n\n    if (skipInitialScan) {\n        args.add(SKIPINITIALSCAN);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "111", "src_id": "M55", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<String, Long> build(Object data) {\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        final Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        final Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "112", "src_id": "M1351", "code": "\n@Override\npublic SearchResult build(Object data) {\n    List<Object> resp = (List<Object>) data;\n\n    int step = 1;\n    int scoreOffset = 0;\n    int contentOffset = 1;\n    if (hasScores) {\n        step += 1;\n        scoreOffset = 1;\n        contentOffset += 1;\n    }\n    if (hasContent) {\n        step += 1;\n    }\n\n    long totalResults = (Long) resp.get(0);\n    List<Document> documents = new ArrayList<>(resp.size() - 1);\n\n    for (int i = 1; i < resp.size(); i += step) {\n        String id = BuilderFactory.STRING.build(resp.get(i));\n        double score = hasScores ? BuilderFactory.DOUBLE.build(resp.get(i + scoreOffset)) : 1.0;\n        List<byte[]> fields = hasContent ? (List<byte[]>) resp.get(i + contentOffset) : null;\n\n        documents.add(Document.load(id, score, fields, decode, isFieldDecode));\n    }\n\n    return new SearchResult(totalResults, documents);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "113", "src_id": "M1298", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (type != null) {\n        args.add(SearchKeyword.ON.name());\n        args.add(type.name());\n    }\n\n    if (prefixes != null && prefixes.length > 0) {\n        args.add(SearchKeyword.PREFIX.name());\n        args.add(Integer.toString(prefixes.length));\n        args.addObjects((Object[]) prefixes);\n    }\n\n    if (filter != null) {\n        args.add(SearchKeyword.FILTER.name());\n        args.add(filter);\n    }\n\n    if (languageField != null) {\n        args.add(SearchKeyword.LANGUAGE_FIELD.name());\n        args.add(languageField);\n    }\n\n    if (language != null) {\n        args.add(SearchKeyword.LANGUAGE.name());\n        args.add(language);\n    }\n\n    if (scoreFiled != null) {\n        args.add(SearchKeyword.SCORE_FIELD.name());\n        args.add(scoreFiled);\n    }\n\n    if (score != 1.0) {\n        args.add(SearchKeyword.SCORE.name());\n        args.add(Double.toString(score));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "115", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n\n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            } else {\n                Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "116", "src_id": "M55", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<String, Long> build(Object data) {\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        final Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        final Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1145", "code": "\n@Override\npublic final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n        HostAndPort node = HostAndPort.from(entry.getKey());\n        ConnectionPool pool = entry.getValue();\n        try (Connection connection = pool.getResource()) {\n            T aReply = execute(connection, commandObject);\n            bcastError.addReply(node, aReply);\n            if (isErrored) { \n                // Already errored - do nothing\n            } else if (reply == null) {\n                reply = aReply; // First valid reply\n            } else if (!reply.equals(aReply)) {\n                isErrored = true;\n                reply = null;\n            }\n        } catch (Exception anError) {\n            bcastError.addReply(node, anError);\n            isErrored = true;\n        }\n    }\n\n    if (isErrored) {\n        throw bcastError;\n    }\n    return reply;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1141", "code": "\n@Override\npublic final <T> T executeCommand(CommandObject<T> commandObject) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n    int consecutiveConnectionFailures = 0;\n    JedisException lastException = null;\n\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n        Connection connection = null;\n        try {\n            connection = provider.getConnection(commandObject.getArguments());\n            return execute(connection, commandObject);\n        } catch (JedisConnectionException jce) {\n            lastException = jce;\n            ++consecutiveConnectionFailures;\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n            if (reset) {\n                consecutiveConnectionFailures = 0;\n            }\n        } finally {\n            if (connection != null) {\n                connection.close();\n            }\n        }\n\n        if (Instant.now().isAfter(deadline)) {\n            throw new JedisException(\"Retry deadline exceeded.\");\n        }\n    }\n\n    JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1346", "code": "\n@Override\npublic Map<String, Map<String, Double>> build(Object data) {\n    List rawDataList = (List) data;\n    if (rawDataList.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    if (rawDataList.get(0) instanceof KeyValue) {\n        KeyValue rawData = (KeyValue) rawDataList.get(0);\n        String header = STRING.build(rawData.getKey());\n        if (!RESULTS.equals(header)) {\n            throw new IllegalStateException(\"Unrecognized header: \" + header);\n        }\n\n        return ((List<KeyValue>) rawData.getValue()).stream().collect(Collectors.toMap(\n            rawTerm -> STRING.build(rawTerm.getKey()),\n            rawTerm -> ((List<List<KeyValue>>) rawTerm.getValue()).stream()\n                .collect(Collectors.toMap(\n                    entry -> STRING.build(entry.get(0).getKey()),\n                    entry -> BuilderFactory.DOUBLE.build(entry.get(0).getValue()),\n                    (x, y) -> x,\n                    LinkedHashMap::new\n                )),\n            (x, y) -> x,\n            LinkedHashMap::new\n        ));\n    }\n\n    Map<String, Map<String, Double>> returnTerms = new LinkedHashMap<>(rawDataList.size());\n    for (Object rawData : rawDataList) {\n        List<Object> rawElements = (List<Object>) rawData;\n        String header = STRING.build(rawElements.get(0));\n        if (!TERM.equals(header)) {\n            throw new IllegalStateException(\"Unrecognized header: \" + header);\n        }\n\n        String term = STRING.build(rawElements.get(1));\n        List<List<Object>> list = (List<List<Object>>) rawElements.get(2);\n        Map<String, Double> entries = new LinkedHashMap<>(list.size());\n        list.forEach(entry -> entries.put(STRING.build(entry.get(1)), BuilderFactory.DOUBLE.build(entry.get(0))));\n        returnTerms.put(term, entries);\n    }\n    return returnTerms;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "120", "src_id": "M1102", "code": "\n@Override\npublic final List<Object> exec() {\n    if (!inMulti) {\n        throw new IllegalStateException(\"EXEC without MULTI\");\n    }\n\n    try (Connection connection = failoverProvider.getConnection()) {\n        commands.forEach(command -> connection.sendCommand(command.getKey()));\n        connection.getMany(commands.size());\n\n        for (int idx = 0; idx < extraCommandCount.get(); ++idx) {\n            commands.poll();\n        }\n\n        connection.sendCommand(EXEC);\n        List<Object> unformatted = connection.getObjectMultiBulkReply();\n        if (unformatted == null) {\n            commands.clear();\n            return null;\n        }\n\n        List<Object> formatted = new ArrayList<>(unformatted.size() - extraCommandCount.get());\n        for (Object rawReply : unformatted) {\n            try {\n                Response<?> response = commands.poll().getValue();\n                response.set(rawReply);\n                formatted.add(response.get());\n            } catch (JedisDataException e) {\n                formatted.add(e);\n            }\n        }\n        return formatted;\n    } finally {\n        inMulti = false;\n        inWatch = false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "121", "src_id": "M925", "code": "\nprivate void process() {\n    do {\n        Object reply = authenticator.client.getUnflushedObject();\n\n        if (reply instanceof List) {\n            List<Object> listReply = (List<Object>) reply;\n            final Object firstObj = listReply.get(0);\n            if (!(firstObj instanceof byte[])) {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n\n            final byte[] resp = (byte[]) firstObj;\n            if (Arrays.equals(SSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onSSubscribe(enchannel, subscribedChannels);\n            } else if (Arrays.equals(SUNSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onSUnsubscribe(enchannel, subscribedChannels);\n            } else if (Arrays.equals(SMESSAGE.getRaw(), resp)) {\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final byte[] bmesg = (byte[]) listReply.get(2);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                final T enmesg = (bmesg == null) ? null : encode(bmesg);\n                onSMessage(enchannel, enmesg);\n            } else {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n        } else if (reply instanceof byte[]) {\n            Consumer<Object> resultHandler = authenticator.resultHandler.poll();\n            if (resultHandler == null) {\n                throw new JedisException(\"Unexpected message : \" + SafeEncoder.encode((byte[]) reply));\n            }\n            resultHandler.accept(reply);\n        } else {\n            throw new JedisException(\"Unknown message type: \" + reply);\n        }\n    } while (!Thread.currentThread().isInterrupted() && isSubscribed());\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "122", "src_id": "M126", "code": "\n@Override\npublic boolean equals(Object o) {\n    if (o == this) {\n        return true;\n    }\n    if (!(o instanceof CommandObject)) {\n        return false;\n    }\n\n    Iterator<Rawable> e1 = arguments.iterator();\n    Iterator<Rawable> e2 = ((CommandObject) o).arguments.iterator();\n    while (e1.hasNext() && e2.hasNext()) {\n        Rawable o1 = e1.next();\n        Rawable o2 = e2.next();\n        if (!(o1 == null ? o2 == null : o1.equals(o2))) {\n            return false;\n        }\n    }\n\n    if (e1.hasNext() || e2.hasNext()) {\n        return false;\n    }\n    return builder == ((CommandObject) o).builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "123", "src_id": "M918", "code": "\npublic CommandArguments add(Object arg) {\n    if (arg == null) {\n        throw new IllegalArgumentException(\"null is not a valid argument.\");\n    } else if (arg instanceof Rawable) {\n        args.add((Rawable) arg);\n    } else if (arg instanceof byte[]) {\n        args.add(RawableFactory.from((byte[]) arg));\n    } else if (arg instanceof Boolean) {\n        args.add(RawableFactory.from((Boolean) arg));\n    } else if (arg instanceof Integer) {\n        args.add(RawableFactory.from((Integer) arg));\n    } else if (arg instanceof Long) {\n        args.add(RawableFactory.from((Long) arg));\n    } else if (arg instanceof Double) {\n        args.add(RawableFactory.from((Double) arg));\n    } else if (arg instanceof float[]) {\n        args.add(RawableFactory.from(RediSearchUtil.toByteArray((float[]) arg)));\n    } else if (arg instanceof String) {\n        args.add(RawableFactory.from((String) arg));\n    } else if (arg instanceof GeoCoordinate) {\n        GeoCoordinate geo = (GeoCoordinate) arg;\n        args.add(RawableFactory.from(geo.getLongitude() + \",\" + geo.getLatitude()));\n    } else {\n        args.add(RawableFactory.from(String.valueOf(arg)));\n    }\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "124", "src_id": "M1216", "code": "\nprivate void initMaster(HostAndPort master) {\n    initPoolLock.lock();\n    try {\n        if (!master.equals(currentMaster)) {\n            currentMaster = master;\n            ConnectionPool newPool = createNodePool(currentMaster);\n\n            ConnectionPool existingPool = pool;\n            pool = newPool;\n            LOG.info(\"Created connection pool to master at {}.\", master);\n            if (clientSideCache != null) {\n                clientSideCache.flush();\n            }\n\n            if (existingPool != null) {\n                existingPool.close();\n            }\n        }\n    } finally {\n        initPoolLock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "125", "src_id": "M361", "code": "\nstatic private void processPartAdvanced(Object part, EmailContent content,\n        EmlToPdfRequest request) {\n    try {\n        if (!isValidJakartaMailPart(part)) {\n            log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n            return;\n        }\n\n        Class<?> partClass = part.getClass();\n        Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n        Method getContent = partClass.getMethod(\"getContent\");\n        Method getDisposition = partClass.getMethod(\"getDisposition\");\n        Method getFileName = partClass.getMethod(\"getFileName\");\n        Method getContentType = partClass.getMethod(\"getContentType\");\n        Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n        Object disposition = getDisposition.invoke(part);\n        String filename = (String) getFileName.invoke(part);\n        String contentType = (String) getContentType.invoke(part);\n\n        if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n            content.setTextBody((String) getContent.invoke(part));\n        } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n            content.setHtmlBody((String) getContent.invoke(part));\n        } else if (\"attachment\".equalsIgnoreCase((String) disposition)\n                || (filename != null && !filename.trim().isEmpty())) {\n\n            content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n            if (filename != null && !filename.trim().isEmpty()) {\n                EmailAttachment attachment = new EmailAttachment();\n                attachment.setFilename(safeMimeDecode(filename));\n                attachment.setContentType(contentType);\n\n                String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n                if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                    attachment.setEmbedded(true);\n                    String contentId = contentIdHeaders[0];\n                    if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                        contentId = contentId.substring(1, contentId.length() - 1);\n                    }\n                    attachment.setContentId(contentId);\n                }\n\n                if ((request != null && request.isIncludeAttachments())\n                        || attachment.isEmbedded()) {\n                    try {\n                        Object attachmentContent = getContent.invoke(part);\n                        byte[] attachmentData = null;\n\n                        if (attachmentContent instanceof java.io.InputStream inputStream) {\n                            try {\n                                attachmentData = inputStream.readAllBytes();\n                            } catch (IOException e) {\n                                log.warn(\n                                        \"Failed to read InputStream attachment: {}\",\n                                        e.getMessage());\n                            }\n                        } else if (attachmentContent instanceof byte[] byteArray) {\n                            attachmentData = byteArray;\n                        } else if (attachmentContent instanceof String stringContent) {\n                            attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n                        }\n\n                        if (attachmentData != null) {\n                            long maxSizeMB =\n                                    request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                            long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                            if (attachmentData.length <= maxSizeBytes) {\n                                attachment.setData(attachmentData);\n                                attachment.setSizeBytes(attachmentData.length);\n                            } else {\n                                if (attachment.isEmbedded()) {\n                                    attachment.setData(attachmentData);\n                                    attachment.setSizeBytes(attachmentData.length);\n                                } else {\n                                    attachment.setSizeBytes(attachmentData.length);\n                                }\n                            }\n                        }\n                    } catch (Exception e) {\n                        log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n                    }\n                }\n\n                content.getAttachments().add(attachment);\n            }\n        } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n            try {\n                Object multipartContent = getContent.invoke(part);\n                Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(multipartContent)) {\n                    processMultipartAdvanced(multipartContent, content, request);\n                }\n            } catch (Exception e) {\n                log.warn(\"Error processing multipart content: {}\", e.getMessage());\n            }\n        }\n\n    } catch (Exception e) {\n        log.warn(\"Error processing multipart part: {}\", e.getMessage());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "126", "src_id": "M343", "code": "\nstatic private EmailContent extractEmailContentAdvanced(byte[] emlBytes, EmlToPdfRequest request) {\n    try {\n        Class<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n        Class<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n\n        Method getDefaultInstance =\n                sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n        Object session = getDefaultInstance.invoke(null, new Properties());\n\n        Class<?>[] constructorArgs = new Class<?>[] {sessionClass, InputStream.class};\n        Constructor<?> mimeMessageConstructor =\n                mimeMessageClass.getConstructor(constructorArgs);\n        Object message =\n                mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n\n        return extractEmailContentAdvanced(message, request);\n\n    } catch (ReflectiveOperationException e) {\n        EmailContent content = new EmailContent();\n        content.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n        return content;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "127", "src_id": "M356", "code": "\nstatic private void appendEnhancedStyles(StringBuilder html) {\n    int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n    String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n    String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n    String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n    html.append(\"body {\\n\");\n    html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n    html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n    html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n    html.append(\"  color: \").append(textColor).append(\";\\n\");\n    html.append(\"  margin: 0;\\n\");\n    html.append(\"  padding: 16px;\\n\");\n    html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-container {\\n\");\n    html.append(\"  width: 100%;\\n\");\n    html.append(\"  max-width: 100%;\\n\");\n    html.append(\"  margin: 0 auto;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-header {\\n\");\n    html.append(\"  padding-bottom: 10px;\\n\");\n    html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n    html.append(\"  margin-bottom: 10px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-header h1 {\\n\");\n    html.append(\"  margin: 0 0 10px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n    html.append(\"  font-weight: bold;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-meta div {\\n\");\n    html.append(\"  margin-bottom: 2px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-body {\\n\");\n    html.append(\"  word-wrap: break-word;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".attachment-section {\\n\");\n    html.append(\"  margin-top: 15px;\\n\");\n    html.append(\"  padding: 10px;\\n\");\n    html.append(\"  background-color: \")\n            .append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border: 1px solid \")\n            .append(StyleConstants.ATTACHMENT_BORDER_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-section h3 {\\n\");\n    html.append(\"  margin: 0 0 8px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-item {\\n\");\n    html.append(\"  padding: 5px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-icon {\\n\");\n    html.append(\"  margin-right: 5px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-details, .attachment-type {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  color: #555555;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n    html.append(\"  margin-top: 8px;\\n\");\n    html.append(\"  padding: 6px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note {\\n\");\n    html.append(\"  background-color: #e6ffed;\\n\");\n    html.append(\"  border: 1px solid #d4f7dc;\\n\");\n    html.append(\"  color: #006420;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-info-note {\\n\");\n    html.append(\"  background-color: #fff9e6;\\n\");\n    html.append(\"  border: 1px solid #fff0c2;\\n\");\n    html.append(\"  color: #664d00;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container {\\n\");\n    html.append(\"  display: flex;\\n\");\n    html.append(\"  align-items: center;\\n\");\n    html.append(\"  padding: 8px;\\n\");\n    html.append(\"  background-color: #f8f9fa;\\n\");\n    html.append(\"  border: 1px solid #dee2e6;\\n\");\n    html.append(\"  border-radius: 4px;\\n\");\n    html.append(\"  margin: 4px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container:hover {\\n\");\n    html.append(\"  background-color: #e9ecef;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-note {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n    html.append(\"  color: #6c757d;\\n\");\n    html.append(\"  font-style: italic;\\n\");\n    html.append(\"  margin-left: 8px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\"img {\\n\");\n    html.append(\"  max-width: 100%;\\n\");\n    html.append(\"  height: auto;\\n\");\n    html.append(\"  display: block;\\n\");\n    html.append(\"}\\n\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "128", "src_id": "M348", "code": "\nstatic private String extractBasicHeader(String emlContent, String headerName) {\n    try {\n        String[] lines = emlContent.split(\"\\r?\\n\");\n        for (int i = 0; i < lines.length; i++) {\n            String line = lines[i];\n            if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                StringBuilder value =\n                        new StringBuilder(line.substring(headerName.length()).trim());\n                for (int j = i + 1; j < lines.length; j++) {\n                    if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                        value.append(\" \").append(lines[j].trim());\n                    } else {\n                        break;\n                    }\n                }\n                return safeMimeDecode(value.toString());\n            }\n            if (line.trim().isEmpty()) break;\n        }\n    } catch (RuntimeException e) {\n        log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n    }\n    return \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "129", "src_id": "M454", "code": "\n    private void setupMainFrame() {\n        frame = new JFrame(\"Stirling-PDF\");\n        frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n        frame.setUndecorated(true);\n        frame.setOpacity(0.0f);\n\n        final JPanel pane = new JPanel(new BorderLayout());\n        pane.setDoubleBuffered(true);\n        pane.add(browser.getUIComponent(), BorderLayout.CENTER);\n        frame.setContentPane(pane);\n\n        frame.addWindowListener(new java.awt.event.WindowAdapter() {\n            @Override\n            public void windowClosing(java.awt.event.WindowEvent windowEvent) {\n                cleanup();\n                System.exit(0);\n            }\n        });\n\n        frame.setSize(UIScaling.scaleWidth(1280), UIScaling.scaleHeight(800));\n        frame.setLocationRelativeTo(null);\n\n        loadIcon();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "130", "src_id": "M604", "code": "\n    @PostMapping(value = \"/form-fields\", consumes = \"multipart/form-data\")\n    @Operation(\n            summary = \"Get form field information\",\n            description = \"Returns count and details of form fields. Input:PDF Output:JSON Type:SISO\")\n    public Map<String, Object> getFormFields(@ModelAttribute PDFFile file) throws IOException {\n        try (final PDDocument doc = pdfDocumentFactory.load(file.getFileInput())) {\n            final Map<String, Object> info = new HashMap<>();\n            final PDAcroForm form = doc.getDocumentCatalog().getAcroForm();\n\n            if (form != null) {\n                info.put(\"fieldCount\", form.getFields().size());\n                info.put(\"hasXFA\", form.hasXFA());\n                info.put(\"isSignaturesExist\", form.isSignaturesExist());\n            } else {\n                info.put(\"fieldCount\", 0);\n                info.put(\"hasXFA\", false);\n                info.put(\"isSignaturesExist\", false);\n            }\n            return info;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "131", "src_id": "M443", "code": "\n    private void checkAndRefreshExplorer() {\n        if (!IS_WINDOWS) return;\n        if (timeAt90Percent == -1) {\n            timeAt90Percent = System.currentTimeMillis();\n            stuckTimer = new Timer(1000, e -> {\n                final long now = System.currentTimeMillis();\n                if (now - timeAt90Percent > stuckThreshold) {\n                    try {\n                        log.debug(\"Attempting Windows explorer refresh\");\n                        final String dir = System.getProperty(\"user.dir\");\n                        \n                        final Set<String> pids = new HashSet<>();\n                        final ProcessBuilder listPb = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \"process\", \n                                \"where\", \"name='explorer.exe'\", \"get\", \"ProcessId\", \"/format:csv\");\n                        final Process proc = listPb.start();\n                        final BufferedReader reader = new BufferedReader(\n                                new InputStreamReader(proc.getInputStream()));\n                        String line;\n                        while ((line = BoundedLineReader.readLine(reader, 5_000_000)) != null) {\n                            if (line.matches(\".*\\\\d+.*\")) {\n                                final String[] parts = line.trim().split(\",\");\n                                if (parts.length >= 2) {\n                                    pids.add(parts[parts.length - 1].trim());\n                                }\n                            }\n                        }\n                        proc.waitFor(2, TimeUnit.SECONDS);\n\n                        final ProcessBuilder pb = new ProcessBuilder(\"cmd\", \"/c\", \"start\", \n                                \"/min\", \"/b\", \"explorer.exe\", dir);\n                        pb.redirectErrorStream(true);\n                        explorerProcess = pb.start();\n\n                        final Timer cleanupTimer = new Timer(2000, cleanup -> {\n                            try {\n                                final ProcessBuilder findPb = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \n                                        \"process\", \"where\", \"name='explorer.exe'\", \"get\", \n                                        \"ProcessId\", \"/format:csv\");\n                                final Process newProc = findPb.start();\n                                final BufferedReader newReader = new BufferedReader(\n                                        new InputStreamReader(newProc.getInputStream()));\n                                String newLine;\n                                while ((newLine = BoundedLineReader.readLine(newReader, 5_000_000)) != null) {\n                                    if (newLine.matches(\".*\\\\d+.*\")) {\n                                        final String[] parts = newLine.trim().split(\",\");\n                                        if (parts.length >= 2) {\n                                            final String pid = parts[parts.length - 1].trim();\n                                            if (!pids.contains(pid)) {\n                                                log.debug(\"Found new explorer.exe PID: \" + pid);\n                                                final ProcessBuilder killPb = new ProcessBuilder(\n                                                        \"taskkill\", \"/PID\", pid, \"/F\");\n                                                killPb.redirectErrorStream(true);\n                                                final Process killResult = killPb.start();\n                                                killResult.waitFor(2, TimeUnit.SECONDS);\n                                                log.debug(\"Terminated explorer: \" + pid);\n                                            }\n                                        }\n                                    }\n                                }\n                                newProc.waitFor(2, TimeUnit.SECONDS);\n                            } catch (Exception ex) {\n                                log.error(\"Cleanup error\", ex);\n                            }\n                        });\n                        cleanupTimer.setRepeats(false);\n                        cleanupTimer.start();\n                        stuckTimer.stop();\n                    } catch (Exception ex) {\n                        log.error(\"Refresh error\", ex);\n                    }\n                }\n            });\n            stuckTimer.setRepeats(true);\n            stuckTimer.start();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "132", "src_id": "M542", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/compress-pdf\")\n    @Operation(\n            summary = \"Optimize PDF file\",\n            description = \"This endpoint accepts a PDF file and optimizes it. Input:PDF Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> optimizePdf(@ModelAttribute OptimizePdfRequest req) throws Exception {\n        final MultipartFile inputFile = req.getFileInput();\n        Integer level = req.getOptimizeLevel();\n        final String sizeStr = req.getExpectedOutputSize();\n        final Boolean grayscale = req.getGrayscale();\n        if (sizeStr == null && level == null) {\n            throw new Exception(\"Missing optimization parameters\");\n        }\n\n        long expectedSize = 0L;\n        boolean auto = false;\n        if (sizeStr != null && sizeStr.length() > 1) {\n            expectedSize = GeneralUtils.convertSizeToBytes(sizeStr);\n            auto = true;\n        }\n\n        final Path orig = Files.createTempFile(\"original_\", \".pdf\");\n        inputFile.transferTo(orig.toFile());\n        final long inputSize = Files.size(orig);\n\n        Path current = Files.createTempFile(\"working_\", \".pdf\");\n        Files.copy(orig, current, StandardCopyOption.REPLACE_EXISTING);\n\n        final List<Path> tmpFiles = new ArrayList<>();\n        tmpFiles.add(orig);\n        tmpFiles.add(current);\n        try {\n            if (auto) {\n                final double ratio = expectedSize / (double) inputSize;\n                level = determineOptimizeLevel(ratio);\n            }\n\n            boolean sizeOk = false;\n            boolean imgDone = false;\n            boolean extDone = false;\n\n            while (!sizeOk && level <= 9) {\n                if (!extDone) {\n                    boolean gsOk = false;\n\n                    if (isGhostscriptEnabled()) {\n                        try {\n                            applyGhostscriptCompression(req, level, current, tmpFiles);\n                            log.info(\"Ghostscript applied\");\n                            gsOk = true;\n                        } catch (IOException e) {\n                            log.warn(\"Ghostscript failed\");\n                        }\n                    }\n\n                    if (!gsOk && isQpdfEnabled() && level <= 3) {\n                        try {\n                            applyQpdfCompression(req, level, current, tmpFiles);\n                            log.info(\"QPDF applied\");\n                        } catch (IOException e) {\n                            log.warn(\"QPDF failed\");\n                        }\n                    }\n\n                    if (!gsOk && !isQpdfEnabled()) {\n                        log.info(\"No external tools available\");\n                    }\n\n                    extDone = true;\n\n                    if (gsOk) {\n                        imgDone = true;\n                    }\n                }\n\n                if ((level >= 4 || Boolean.TRUE.equals(grayscale)) && !imgDone) {\n                    final double scale = switch (level) {\n                        case 4 -> 0.95;\n                        case 5 -> 0.9;\n                        case 6 -> 0.8;\n                        case 7 -> 0.7;\n                        case 8 -> 0.65;\n                        case 9 -> 0.5;\n                        default -> 1.0;\n                    };\n\n                    log.info(\"Image scale: {}\", scale);\n                    final Path imgFile = compressImagesInPDF(\n                            current, scale, 0.7f, Boolean.TRUE.equals(grayscale));\n                    tmpFiles.add(imgFile);\n                    current = imgFile;\n                    imgDone = true;\n                }\n\n                final long outputSize = Files.size(current);\n                if (outputSize <= expectedSize || !auto) {\n                    sizeOk = true;\n                } else {\n                    final int newLevel = incrementOptimizeLevel(level, outputSize, expectedSize);\n                    if (newLevel == level) {\n                        if (auto) log.info(\"Max level reached\");\n                        sizeOk = true;\n                    } else {\n                        imgDone = false;\n                        extDone = false;\n                        level = newLevel;\n                    }\n                }\n            }\n\n            if (Files.size(current) >= inputSize) {\n                log.warn(\"Optimized file larger - using original\");\n                current = orig;\n            }\n\n            final String outName = Filenames.toSimpleFileName(\n                    inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_Optimized.pdf\";\n\n            return WebResponseUtils.pdfDocToWebResponse(\n                    pdfDocumentFactory.load(current.toFile()), outName);\n        } finally {\n            for (Path tmp : tmpFiles) {\n                try {\n                    Files.deleteIfExists(tmp);\n                } catch (IOException e) {\n                    log.warn(\"Delete failed: \" + tmp, e);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "133", "src_id": "M625", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile req) throws IOException {\n        final MultipartFile inputFile = req.getFileInput();\n        try (final PDDocument doc = pdfDocumentFactory.load(inputFile, true)) {\n            final ObjectMapper mapper = new ObjectMapper();\n            final ObjectNode root = mapper.createObjectNode();\n\n            final PDDocumentInformation info = doc.getDocumentInformation();\n            final ObjectNode meta = mapper.createObjectNode();\n            final ObjectNode basic = mapper.createObjectNode();\n            final ObjectNode docInfo = mapper.createObjectNode();\n            final ObjectNode compliancy = mapper.createObjectNode();\n            final ObjectNode encryption = mapper.createObjectNode();\n            final ObjectNode other = mapper.createObjectNode();\n\n            meta.put(\"Title\", info.getTitle());\n            meta.put(\"Author\", info.getAuthor());\n            meta.put(\"Subject\", info.getSubject());\n            meta.put(\"Keywords\", info.getKeywords());\n            meta.put(\"Producer\", info.getProducer());\n            meta.put(\"Creator\", info.getCreator());\n            meta.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            meta.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            root.set(\"Metadata\", meta);\n\n            final long size = inputFile.getSize();\n            basic.put(\"FileSizeInBytes\", size);\n\n            final String text = new PDFTextStripper().getText(doc);\n            final String[] words = text.split(\"\\\\s+\");\n            basic.put(\"WordCount\", words.length);\n            basic.put(\"ParagraphCount\", text.split(\"\\r\\n|\\r|\\n\").length);\n            basic.put(\"CharacterCount\", text.length());\n\n            boolean hasCompression = false;\n            String compressionType = \"None\";\n            basic.put(\"Compression\", hasCompression);\n            if (hasCompression) basic.put(\"CompressionType\", compressionType);\n\n            basic.put(\"Language\", doc.getDocumentCatalog().getLanguage());\n            basic.put(\"Number of pages\", doc.getNumberOfPages());\n\n            final PDDocumentCatalog catalog = doc.getDocumentCatalog();\n            docInfo.put(\"PDF version\", doc.getVersion());\n            docInfo.put(\"Trapped\", info.getTrapped());\n            docInfo.put(\"Page Mode\", getPageModeDescription(catalog.getPageMode().name()));\n\n            final PDAcroForm acroForm = catalog.getAcroForm();\n            final ObjectNode formFields = mapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFields.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            root.set(\"FormFields\", formFields);\n\n            final ObjectNode summary = generatePDFSummaryData(doc);\n            if (summary != null && summary.size() > 0) {\n                root.set(\"SummaryData\", summary);\n            }\n\n            if (catalog.getNames() != null) {\n                final PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                final ArrayNode embeddedFiles = mapper.createArrayNode();\n                if (efTree != null) {\n                    final Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> e : efMap.entrySet()) {\n                            final ObjectNode fileNode = mapper.createObjectNode();\n                            fileNode.put(\"Name\", e.getKey());\n                            final PDEmbeddedFile file = e.getValue().getEmbeddedFile();\n                            if (file != null) {\n                                fileNode.put(\"FileSize\", file.getLength());\n                            }\n                            embeddedFiles.add(fileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFiles);\n            }\n\n            final ArrayNode attachments = mapper.createArrayNode();\n            for (PDPage page : doc.getPages()) {\n                for (PDAnnotation ann : page.getAnnotations()) {\n                    if (ann instanceof PDAnnotationFileAttachment fa) {\n                        final ObjectNode attachNode = mapper.createObjectNode();\n                        attachNode.put(\"Name\", fa.getAttachmentName());\n                        attachNode.put(\"Description\", fa.getContents());\n                        attachments.add(attachNode);\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachments);\n\n            final PDDocumentNameDictionary namesDict = catalog.getNames();\n            final ArrayNode jsArray = mapper.createArrayNode();\n\n            if (namesDict != null) {\n                final PDJavascriptNameTreeNode jsDict = namesDict.getJavaScript();\n                if (jsDict != null) {\n                    try {\n                        final Map<String, PDActionJavaScript> jsMap = jsDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> e : jsMap.entrySet()) {\n                            final ObjectNode jsNode = mapper.createObjectNode();\n                            jsNode.put(\"JS Name\", e.getKey());\n                            final PDActionJavaScript js = e.getValue();\n                            if (js != null) {\n                                final String code = js.getAction();\n                                if (code != null) {\n                                    jsNode.put(\"JS Script Length\", code.length());\n                                }\n                            }\n                            jsArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"JS error\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", jsArray);\n\n            final PDOptionalContentProperties ocProps = catalog.getOCProperties();\n            final ArrayNode layers = mapper.createArrayNode();\n            if (ocProps != null) {\n                for (PDOptionalContentGroup ocg : ocProps.getOptionalContentGroups()) {\n                    final ObjectNode layerNode = mapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n                    layers.add(layerNode);\n                }\n            }\n            other.set(\"Layers\", layers);\n\n            final PDStructureTreeRoot structRoot = catalog.getStructureTreeRoot();\n            try {\n                if (structRoot != null) {\n                    other.set(\"StructureTree\", exploreStructureTree(structRoot.getKids()));\n                }\n            } catch (Exception e) {\n                log.error(\"Structure error\", e);\n            }\n\n            compliancy.put(\"IsPDF/ACompliant\", checkForStandard(doc, \"PDF/A\"));\n            compliancy.put(\"IsPDF/XCompliant\", checkForStandard(doc, \"PDF/X\"));\n            compliancy.put(\"IsPDF/ECompliant\", checkForStandard(doc, \"PDF/E\"));\n            compliancy.put(\"IsPDF/VTCompliant\", checkForStandard(doc, \"PDF/VT\"));\n            compliancy.put(\"IsPDF/UACompliant\", checkForStandard(doc, \"PDF/UA\"));\n            compliancy.put(\"IsPDF/BCompliant\", checkForStandard(doc, \"PDF/B\"));\n            compliancy.put(\"IsPDF/SECCompliant\", checkForStandard(doc, \"PDF/SEC\"));\n\n            final ArrayNode bookmarks = mapper.createArrayNode();\n            final PDOutlineNode outline = catalog.getDocumentOutline();\n            if (outline != null) {\n                for (PDOutlineItem child : outline.children()) {\n                    addOutlinesToArray(child, bookmarks);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarks);\n\n            String xmp = null;\n            final PDMetadata pdMeta = catalog.getMetadata();\n            if (pdMeta != null) {\n                try (final COSInputStream is = pdMeta.createInputStream()) {\n                    final DomXmpParser parser = new DomXmpParser();\n                    final XMPMetadata xmpMeta = parser.parse(is);\n                    final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    new XmpSerializer().serialize(xmpMeta, os, true);\n                    xmp = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                } catch (XmpParsingException e) {\n                    log.debug(\"XMP parse failed: {}\", e.getMessage());\n                    try (final COSInputStream is = pdMeta.createInputStream()) {\n                        xmp = new String(is.readAllBytes(), StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"XMP error\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", xmp);\n\n            encryption.put(\"IsEncrypted\", doc.isEncrypted());\n            if (doc.isEncrypted()) {\n                final PDEncryption enc = doc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", enc.getFilter());\n                encryption.put(\"KeyLength\", enc.getLength());\n            }\n\n            final ObjectNode perms = mapper.createObjectNode();\n            setNodePermissions(doc, perms);\n\n            final ObjectNode pages = mapper.createObjectNode();\n            for (int i = 0; i < doc.getNumberOfPages(); i++) {\n                final ObjectNode pageInfo = mapper.createObjectNode();\n                final PDPage page = doc.getPage(i);\n                final PDRectangle mediaBox = page.getMediaBox();\n\n                final float w = mediaBox.getWidth();\n                final float h = mediaBox.getHeight();\n                final ObjectNode sizeInfo = mapper.createObjectNode();\n                getDimensionInfo(sizeInfo, w, h);\n                sizeInfo.put(\"Standard Page\", getPageSize(w, h));\n                pageInfo.set(\"Size\", sizeInfo);\n\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(w, h));\n\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                putBoxInfo(pageInfo, \"CropBox\", page.getCropBox());\n                putBoxInfo(pageInfo, \"BleedBox\", page.getBleedBox());\n                putBoxInfo(pageInfo, \"TrimBox\", page.getTrimBox());\n                putBoxInfo(pageInfo, \"ArtBox\", page.getArtBox());\n\n                final PDFTextStripper stripper = new PDFTextStripper();\n                stripper.setStartPage(i + 1);\n                stripper.setEndPage(i + 1);\n                pageInfo.put(\"Text Characters Count\", stripper.getText(doc).length());\n\n                final List<PDAnnotation> anns = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation ann : anns) {\n                    if (ann.getSubtype() != null) subtypeCount++;\n                    if (ann.getContents() != null) contentsCount++;\n                }\n                final ObjectNode annNode = mapper.createObjectNode();\n                annNode.put(\"AnnotationsCount\", anns.size());\n                annNode.put(\"SubtypeCount\", subtypeCount);\n                annNode.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annNode);\n\n                final ArrayNode images = mapper.createArrayNode();\n                final PDResources res = page.getResources();\n                for (COSName name : res.getXObjectNames()) {\n                    final PDXObject xobj = res.getXObject(name);\n                    if (xobj instanceof PDImageXObject img) {\n                        final ObjectNode imgNode = mapper.createObjectNode();\n                        imgNode.put(\"Width\", img.getWidth());\n                        imgNode.put(\"Height\", img.getHeight());\n                        if (img.getMetadata() != null && img.getMetadata().getFile() != null\n                                && img.getMetadata().getFile().getFile() != null) {\n                            imgNode.put(\"Name\", img.getMetadata().getFile().getFile());\n                        }\n                        if (img.getColorSpace() != null) {\n                            imgNode.put(\"ColorSpace\", img.getColorSpace().getName());\n                        }\n                        images.add(imgNode);\n                    }\n                }\n                pageInfo.set(\"Images\", images);\n\n                final ArrayNode links = mapper.createArrayNode();\n                final Set<String> uris = new HashSet<>();\n                for (PDAnnotation ann : anns) {\n                    if (ann instanceof PDAnnotationLink link) {\n                        if (link.getAction() instanceof PDActionURI uriAction) {\n                            uris.add(uriAction.getURI());\n                        }\n                    }\n                }\n                for (String uri : uris) {\n                    final ObjectNode linkNode = mapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    links.add(linkNode);\n                }\n                pageInfo.set(\"Links\", links);\n\n                final ArrayNode fonts = mapper.createArrayNode();\n                final Map<String, ObjectNode> fontMap = new HashMap<>();\n                for (COSName fontName : res.getFontNames()) {\n                    final PDFont font = res.getFont(fontName);\n                    final ObjectNode fontNode = mapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n\n                    final PDFontDescriptor desc = font.getFontDescriptor();\n                    if (desc != null) {\n                        fontNode.put(\"ItalicAngle\", desc.getItalicAngle());\n                        final int flags = desc.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", desc.getFontFamily());\n                        fontNode.put(\"FontWeight\", desc.getFontWeight());\n                    }\n\n                    final String key = fontNode.toString();\n                    if (fontMap.containsKey(key)) {\n                        final ObjectNode existing = fontMap.get(key);\n                        existing.put(\"Count\", existing.get(\"Count\").asInt() + 1);\n                    } else {\n                        fontNode.put(\"Count\", 1);\n                        fontMap.put(key, fontNode);\n                    }\n                }\n                for (ObjectNode fn : fontMap.values()) fonts.add(fn);\n                pageInfo.set(\"Fonts\", fonts);\n\n                final ArrayNode colorSpaces = mapper.createArrayNode();\n                for (COSName csName : res.getColorSpaceNames()) {\n                    final PDColorSpace cs = res.getColorSpace(csName);\n                    if (cs instanceof PDICCBased icc) {\n                        final ObjectNode iccNode = mapper.createObjectNode();\n                        iccNode.put(\"ICC Profile Length\", icc.getPDStream().toByteArray().length);\n                        colorSpaces.add(iccNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpaces);\n\n                final ObjectNode xobjCounts = mapper.createObjectNode();\n                final Map<String, Integer> xobjMap = new HashMap<>();\n                for (COSName xobjName : res.getXObjectNames()) {\n                    final PDXObject xobj = res.getXObject(xobjName);\n                    final String type = xobj instanceof PDImageXObject ? \"Image\" :\n                                       xobj instanceof PDFormXObject ? \"Form\" : \"Other\";\n                    xobjMap.put(type, xobjMap.getOrDefault(type, 0) + 1);\n                }\n                for (Map.Entry<String, Integer> e : xobjMap.entrySet()) {\n                    xobjCounts.put(e.getKey(), e.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xobjCounts);\n\n                final ArrayNode media = mapper.createArrayNode();\n                for (PDAnnotation ann : anns) {\n                    if (\"RichMedia\".equals(ann.getSubtype())) {\n                        media.add(mapper.createObjectNode());\n                    }\n                }\n                pageInfo.set(\"Multimedia\", media);\n\n                pages.set(\"Page \" + (i + 1), pageInfo);\n            }\n\n            root.set(\"BasicInfo\", basic);\n            root.set(\"DocumentInfo\", docInfo);\n            root.set(\"Compliancy\", compliancy);\n            root.set(\"Encryption\", encryption);\n            root.set(\"Permissions\", perms);\n            root.set(\"Other\", other);\n            root.set(\"PerPageInfo\", pages);\n\n            final String json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);\n            return WebResponseUtils.bytesToWebResponse(\n                    json.getBytes(StandardCharsets.UTF_8),\n                    \"response.json\",\n                    MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"Processing error\", e);\n            return null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "134", "src_id": "M518", "code": "\n    public static boolean isBlankImage(BufferedImage img, int threshold, \n                                      double whitePercent, int blurSize) {\n        if (img == null) {\n            log.info(\"Null image\");\n            return false;\n        }\n\n        int whitePixels = 0;\n        final int total = img.getWidth() * img.getHeight();\n\n        for (int y = 0; y < img.getHeight(); y++) {\n            for (int x = 0; x < img.getWidth(); x++) {\n                final int color = img.getRGB(x, y) & 0xFF;\n                if (color >= 255 - threshold) whitePixels++;\n            }\n        }\n\n        final double percent = (whitePixels / (double) total) * 100;\n        log.info(\"White pixels: {:.2f}%\", percent);\n        return percent >= whitePercent;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "135", "src_id": "M483", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/filter-page-count\")\n    @Operation(\n            summary = \"Checks if a PDF is greater, less or equal to a setPageCount\",\n            description = \"Input:PDF Output:Boolean Type:SISO\")\n    public ResponseEntity<byte[]> pageCount(@ModelAttribute PDFComparisonAndCount req) \n            throws IOException, InterruptedException {\n        final MultipartFile file = req.getFileInput();\n        final int count = req.getPageCount();\n        final String comp = req.getComparator();\n        \n        final PDDocument doc = pdfDocumentFactory.load(file);\n        final int actual = doc.getNumberOfPages();\n\n        boolean valid = false;\n        switch (comp) {\n            case \"Greater\": valid = actual > count; break;\n            case \"Equal\": valid = actual == count; break;\n            case \"Less\": valid = actual < count; break;\n            default: throw ExceptionUtils.createInvalidArgumentException(\"comparator\", comp);\n        }\n\n        return valid ? WebResponseUtils.multiPartFileToWebResponse(file) : null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "136", "src_id": "M475", "code": "\n    private void handleSplitBySize(PDDocument srcDoc, long maxBytes, \n                                  ZipOutputStream zipOut, String baseName) throws IOException {\n        log.debug(\"Splitting by size: maxBytes={}\", maxBytes);\n        PDDocument currDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(srcDoc);\n        int part = 1;\n        int total = srcDoc.getNumberOfPages();\n        int added = 0;\n        final int checkFreq = 5;\n\n        for (int i = 0; i < total; i++) {\n            final PDPage page = srcDoc.getPage(i);\n            log.debug(\"Processing page {}/{}\", i + 1, total);\n            currDoc.addPage(new PDPage(page.getCOSObject()));\n            added++;\n\n            final boolean check = (added % checkFreq == 0) || (i == total - 1) || (added >= 20);\n            if (check) {\n                log.debug(\"Size check after {} pages\", added);\n                final ByteArrayOutputStream tmp = new ByteArrayOutputStream();\n                currDoc.save(tmp);\n                final long size = tmp.size();\n                log.debug(\"Current size: {} (max {})\", size, maxBytes);\n\n                if (size > maxBytes) {\n                    if (currDoc.getNumberOfPages() > 1) {\n                        currDoc.removePage(currDoc.getNumberOfPages() - 1);\n                        i--;\n                        log.debug(\"Removed last page\");\n                    }\n                    log.debug(\"Saving part {} with {} pages\", part, currDoc.getNumberOfPages());\n                    saveDocumentToZip(currDoc, zipOut, baseName, part++);\n                    currDoc = new PDDocument();\n                    added = 0;\n                } else if (i < total - 1) {\n                    if (size < maxBytes * 0.75 && added > 0) {\n                        final int lookahead = Math.min(5, total - i - 1);\n                        if (lookahead > 0) {\n                            log.debug(\"Testing {} pages\", lookahead);\n                            final PDDocument testDoc = new PDDocument();\n                            for (int j = 0; j < currDoc.getNumberOfPages(); j++) {\n                                testDoc.addPage(new PDPage(currDoc.getPage(j).getCOSObject()));\n                            }\n\n                            int extra = 0;\n                            for (int j = 0; j < lookahead; j++) {\n                                final int idx = i + 1 + j;\n                                testDoc.addPage(new PDPage(srcDoc.getPage(idx).getCOSObject()));\n                                final ByteArrayOutputStream testStream = new ByteArrayOutputStream();\n                                testDoc.save(testStream);\n                                if (testStream.size() <= maxBytes) {\n                                    log.debug(\"Can add page {}\", idx + 1);\n                                    extra++;\n                                } else {\n                                    log.debug(\"Cannot add page {}\", idx + 1);\n                                    break;\n                                }\n                            }\n                            testDoc.close();\n\n                            if (extra > 0) {\n                                log.debug(\"Adding {} pages\", extra);\n                                for (int j = 0; j < extra; j++) {\n                                    final int idx = i + 1 + j;\n                                    currDoc.addPage(new PDPage(srcDoc.getPage(idx).getCOSObject()));\n                                }\n                                i += extra;\n                                added += extra;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (currDoc.getNumberOfPages() > 0) {\n            log.debug(\"Saving final part {} with {} pages\", part, currDoc.getNumberOfPages());\n            saveDocumentToZip(currDoc, zipOut, baseName, part);\n        }\n        log.debug(\"Split complete: {} parts\", part);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "137", "src_id": "M291", "code": "\n    public static File convertMultipartFileToFile(MultipartFile mFile) throws IOException {\n        String tmpDir = System.getenv(\"STIRLING_TEMPFILES_DIRECTORY\");\n        if (tmpDir == null || tmpDir.isEmpty()) {\n            tmpDir = System.getProperty(\"stirling.tempfiles.directory\");\n        }\n\n        final File file;\n        if (tmpDir != null && !tmpDir.isEmpty()) {\n            final Path dir = Path.of(tmpDir);\n            if (!Files.exists(dir)) Files.createDirectories(dir);\n            file = Files.createTempFile(dir, \"stirling-pdf-\", null).toFile();\n        } else {\n            final Path dir = Path.of(System.getProperty(\"java.io.tmpdir\"), \"stirling-pdf\");\n            if (!Files.exists(dir)) Files.createDirectories(dir);\n            file = Files.createTempFile(dir, \"stirling-pdf-\", null).toFile();\n        }\n\n        try (InputStream in = mFile.getInputStream();\n             FileOutputStream out = new FileOutputStream(file)) {\n            final byte[] buf = new byte[8192];\n            int len;\n            while ((len = in.read(buf)) != -1) {\n                out.write(buf, 0, len);\n            }\n        }\n        return file;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "138", "src_id": "M254", "code": "\n    private void cleanupTempFiles() {\n        try {\n            final Set<Path> files = registry.getAllRegisteredFiles();\n            int deleted = 0;\n\n            for (Path file : files) {\n                try {\n                    if (Files.exists(file)) {\n                        Files.deleteIfExists(file);\n                        deleted++;\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Delete failed: {}\", file, e);\n                }\n            }\n\n            final Set<Path> dirs = registry.getTempDirectories();\n            for (Path dir : dirs) {\n                try {\n                    if (Files.exists(dir)) {\n                        GeneralUtils.deleteDirectory(dir);\n                        deleted++;\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Delete failed: {}\", dir, e);\n                }\n            }\n\n            log.info(\"Deleted {} temp items\", deleted);\n            registry.clear();\n        } catch (Exception e) {\n            log.error(\"Cleanup error\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "139", "src_id": "M749", "code": "\n    private Object convertAttrValue(String attributeName, Object originAttrValue) {\n        Object attrValue = originAttrValue;\n\n        try {\n            if (originAttrValue instanceof ObjectName) {\n                attrValue = String.valueOf(originAttrValue);\n            } else if (attrValue instanceof CompositeData) {\n                CompositeData compositeData = (CompositeData) attrValue;\n                attrValue = convertCompositeData(attributeName, compositeData);\n            } else if (attrValue instanceof CompositeData[]) {\n                CompositeData[] compositeDataArray = (CompositeData[]) attrValue;\n                List<Map<String, Object>> dataList = new ArrayList<>(compositeDataArray.length);\n                for (CompositeData compositeData : compositeDataArray) {\n                    dataList.add(convertCompositeData(attributeName, compositeData));\n                }\n                attrValue = dataList;\n            } else if (attrValue instanceof TabularData) {\n                TabularData tabularData = (TabularData) attrValue;\n                Collection<CompositeData> compositeDataList = (Collection<CompositeData>) tabularData.values();\n                List<Map<String, Object>> dataList = new ArrayList<>(compositeDataList.size());\n                for (CompositeData compositeData : compositeDataList) {\n                    dataList.add(convertCompositeData(attributeName, compositeData));\n                }\n                attrValue = dataList;\n            }\n        } catch (Throwable e) {\n            log.error(\"convert mbean attribute error, attribute: {}={}\", attributeName, originAttrValue, e);\n            attrValue = String.valueOf(originAttrValue);\n        }\n        return attrValue;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "140", "src_id": "M397", "code": "\n    public static int getItemCount(ResultModel model) {\n        if (model instanceof Countable) {\n            return ((Countable) model).size();\n        }\n\n        Class modelClass = model.getClass();\n        List<Field> fields = modelFieldMap.get(modelClass.getName());\n        if (fields == null) {\n            fields = new ArrayList<>();\n            Field[] declaredFields = modelClass.getDeclaredFields();\n            for (Field field : declaredFields) {\n                Class<?> fieldClass = field.getType();\n                if (Collection.class.isAssignableFrom(fieldClass)\n                        || Map.class.isAssignableFrom(fieldClass)\n                        || Countable.class.isAssignableFrom(fieldClass)\n                        || fieldClass.isArray()) {\n                    field.setAccessible(true);\n                    fields.add(field);\n                }\n            }\n            List<Field> oldFields = modelFieldMap.putIfAbsent(modelClass.getName(), fields);\n            if (oldFields != null) {\n                fields = oldFields;\n            }\n        }\n\n        int count = 0;\n        try {\n            for (Field field : fields) {\n                if (!field.isAccessible()) {\n                    field.setAccessible(true);\n                }\n                Object value = field.get(model);\n                if (value != null) {\n                    if (value instanceof Collection) {\n                        count += ((Collection) value).size();\n                    } else if (value.getClass().isArray()) {\n                        count += Array.getLength(value);\n                    } else if (value instanceof Map) {\n                        count += ((Map) value).size();\n                    } else if (value instanceof Countable) {\n                        count += ((Countable) value).size();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            log.error(\"get item count of result model failed, model: {}\", JSON.toJSONString(model), e);\n        }\n\n        return count > 0 ? count : 1;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "141", "src_id": "M1118", "code": "\n    public void evictSessions() {\n        long now = System.currentTimeMillis();\n        List<Session> toClose = new ArrayList<>();\n        for (Session session : sessions.values()) {\n            if (now - session.getLastAccessTime() > sessionTimeoutMillis && session.getForegroundJob() == null) {\n                toClose.add(session);\n            }\n            evictConsumers(session);\n        }\n        for (Session session : toClose) {\n            Job job = session.getForegroundJob();\n            if (job != null) {\n                job.interrupt();\n            }\n            long timeOutInMinutes = sessionTimeoutMillis / 1000 / 60;\n            String reason = \"session is inactive for \" + timeOutInMinutes + \" min(s).\";\n            SharingResultDistributor resultDistributor = session.getResultDistributor();\n            if (resultDistributor != null) {\n                resultDistributor.appendResult(new MessageModel(reason));\n            }\n            this.removeSession(session.getSessionId());\n            log.info(\"Removing inactive session: {}, last access time: {}\", session.getSessionId(), session.getLastAccessTime());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "142", "src_id": "M526", "code": "\n    private TableElement drawTomcatInfo(TomcatInfoVO tomcatInfo) {\n        if (tomcatInfo == null) {\n            return null;\n        }\n\n        TableElement table = new TableElement(1, 1).rightCellPadding(1);\n        table.add(new RowElement().style(Decoration.bold.fg(Color.black).bg(Color.white)).add(\"Tomcat\", \"\"));\n\n        if (tomcatInfo.getConnectorStats() != null) {\n            for (TomcatInfoVO.ConnectorStats connectorStat : tomcatInfo.getConnectorStats()) {\n                table.add(new RowElement().style(Decoration.bold.bold()).add(\"connector\", connectorStat.getName()));\n                table.row(\"QPS\", String.format(\"%.2f\", connectorStat.getQps()));\n                table.row(\"RT(ms)\", String.format(\"%.2f\", connectorStat.getRt()));\n                table.row(\"error/s\", String.format(\"%.2f\", connectorStat.getError()));\n                table.row(\"received/s\", formatBytes(connectorStat.getReceived()));\n                table.row(\"sent/s\", formatBytes(connectorStat.getSent()));\n            }\n        }\n\n        if (tomcatInfo.getThreadPools() != null) {\n            for (TomcatInfoVO.ThreadPool threadPool : tomcatInfo.getThreadPools()) {\n                table.add(new RowElement().style(Decoration.bold.bold()).add(\"threadpool\", threadPool.getName()));\n                table.row(\"busy\", \"\" + threadPool.getBusy());\n                table.row(\"total\", \"\" + threadPool.getTotal());\n            }\n        }\n        return table;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "143", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = session.get(ONETIME_SESSION_KEY) != null;\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<>();\n            body.put(\"command\", commandLine);\n\n            ApiResponse response = new ApiResponse();\n            response.setSessionId(session.getSessionId()).setBody(body);\n\n            if (!session.tryLock()) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n                return response;\n            }\n\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                    log.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response;\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n                job.run();\n            } catch (Throwable e) {\n                log.error(\"Exec command failed: {}, command: {}\", e.getMessage(), commandLine, e);\n                response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n            Integer timeout = apiRequest.getExecTimeout();\n            if (timeout == null || timeout <= 0) {\n                timeout = DEFAULT_EXEC_TIMEOUT;\n            }\n            boolean timeExpired = !waitForJob(job, timeout);\n            if (timeExpired) {\n                log.warn(\"Job exceeded time limit, force interrupt, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED).setMessage(\"Job exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n            body.put(\"results\", packingResultDistributor.getResults());\n\n            response.setSessionId(session.getSessionId()).setBody(body);\n            return response;\n        } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "144", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                 .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                 .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n                 .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                 .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n            \n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity)))\n                 .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "145", "src_id": "M493", "code": "\n    private void renderNode(StringBuilder sb, TraceNode node, Ansi highlighted) {\n        if (isPrintCost && node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode) node;\n            String costStr = renderCost(methodNode);\n            if (node == maxCostNode) {\n                sb.append(highlighted.a(costStr).reset().toString());\n            } else {\n                sb.append(costStr);\n            }\n        }\n\n        if (node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode) node;\n            sb.append(methodNode.getClassName()).append(\":\").append(methodNode.getMethodName()).append(\"()\");\n            if (methodNode.getLineNumber() != -1) {\n                sb.append(\" #\").append(methodNode.getLineNumber());\n            }\n        } else if (node instanceof ThreadNode) {\n            ThreadNode threadNode = (ThreadNode) node;\n            sb.append(String.format(\n                \"ts=%s;thread_name=%s;id=%d;is_daemon=%s;priority=%d;TCCL=%s\",\n                DateUtils.formatDateTime(threadNode.getTimestamp()),\n                threadNode.getThreadName(),\n                threadNode.getThreadId(),\n                threadNode.isDaemon(),\n                threadNode.getPriority(),\n                threadNode.getClassloader()\n            ));\n\n            if (threadNode.getTraceId() != null) {\n                sb.append(\";trace_id=\").append(threadNode.getTraceId());\n            }\n            if (threadNode.getRpcId() != null) {\n                sb.append(\";rpc_id=\").append(threadNode.getRpcId());\n            }\n        } else if (node instanceof ThrowNode) {\n            ThrowNode throwNode = (ThrowNode) node;\n            sb.append(\"throw:\").append(throwNode.getException())\n              .append(\" #\").append(throwNode.getLineNumber())\n              .append(\" [\").append(throwNode.getMessage()).append(\"]\");\n        } else {\n            throw new UnsupportedOperationException(\"unknown trace node: \" + node.getClass());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "146", "src_id": "M355", "code": "\nprivate static String processInlineImages(final String htmlContent, final EmailContent emailContent) {\n    if (htmlContent == null || emailContent == null) {\n        return htmlContent;\n    }\n\n    final Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n    for (final EmailAttachment attachment : emailContent.getAttachments()) {\n        if (attachment.isEmbedded()\n                && attachment.getContentId() != null\n                && attachment.getData() != null) {\n            contentIdMap.put(attachment.getContentId(), attachment);\n        }\n    }\n\n    if (contentIdMap.isEmpty()) {\n        return htmlContent;\n    }\n\n    final Pattern cidPattern = Pattern.compile(\n            \"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\",\n            Pattern.CASE_INSENSITIVE);\n    final Matcher matcher = cidPattern.matcher(htmlContent);\n    final StringBuffer result = new StringBuffer();\n\n    while (matcher.find()) {\n        final String contentId = matcher.group(1);\n        final EmailAttachment attachment = contentIdMap.get(contentId);\n\n        if (attachment != null && attachment.getData() != null) {\n            String mimeType = attachment.getContentType();\n            if (mimeType == null || mimeType.isEmpty()) {\n                final String filename = attachment.getFilename();\n                if (filename != null) {\n                    final String lowerName = filename.toLowerCase();\n                    if (lowerName.endsWith(\".png\")) {\n                        mimeType = \"image/png\";\n                    } else if (lowerName.endsWith(\".jpg\") || lowerName.endsWith(\".jpeg\")) {\n                        mimeType = \"image/jpeg\";\n                    } else if (lowerName.endsWith(\".gif\")) {\n                        mimeType = \"image/gif\";\n                    } else if (lowerName.endsWith(\".bmp\")) {\n                        mimeType = \"image/bmp\";\n                    } else {\n                        mimeType = \"image/png\";\n                    }\n                } else {\n                    mimeType = \"image/png\";\n                }\n            }\n\n            final String base64Data = Base64.getEncoder().encodeToString(attachment.getData());\n            final String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n            final String replacement = matcher.group(0).replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n        } else {\n            matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n        }\n    }\n    matcher.appendTail(result);\n\n    return result.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "147", "src_id": "M362", "code": "\nprivate static String generateEnhancedEmailHtml(final EmailContent content, final EmlToPdfRequest request) {\n    final StringBuilder html = new StringBuilder();\n\n    html.append(\"<!DOCTYPE html>\\n\")\n        .append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\")\n        .append(\"<title>\").append(escapeHtml(content.getSubject())).append(\"</title>\\n\")\n        .append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n</head><body>\\n\")\n        .append(\"<div class=\\\"email-container\\\">\\n\")\n        .append(\"<div class=\\\"email-header\\\">\\n\")\n        .append(\"<h1>\").append(escapeHtml(content.getSubject())).append(\"</h1>\\n\")\n        .append(\"<div class=\\\"email-meta\\\">\\n\")\n        .append(\"<div><strong>From:</strong> \").append(escapeHtml(content.getFrom())).append(\"</div>\\n\")\n        .append(\"<div><strong>To:</strong> \").append(escapeHtml(content.getTo())).append(\"</div>\\n\");\n\n    if (content.getDate() != null) {\n        html.append(\"<div><strong>Date:</strong> \")\n            .append(formatEmailDate(content.getDate()))\n            .append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\")\n        .append(\"<div class=\\\"email-body\\\">\\n\");\n\n    if (content.getHtmlBody() != null && !content.getHtmlBody().trim().isEmpty()) {\n        html.append(processEmailHtmlBody(content.getHtmlBody(), content));\n    } else if (content.getTextBody() != null && !content.getTextBody().trim().isEmpty()) {\n        html.append(\"<div class=\\\"text-body\\\">\")\n            .append(convertTextToHtml(content.getTextBody()))\n            .append(\"</div>\");\n    } else {\n        html.append(\"<div class=\\\"no-content\\\"><p><em>No content available</em></p></div>\");\n    }\n    html.append(\"</div>\\n\");\n\n    final int attachmentCount = content.getAttachmentCount();\n    final List<EmailAttachment> attachments = content.getAttachments();\n    if (attachmentCount > 0 || !attachments.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\")\n            .append(\"<h3>Attachments (\")\n            .append(attachmentCount > 0 ? attachmentCount : attachments.size())\n            .append(\")</h3>\\n\");\n\n        if (!attachments.isEmpty()) {\n            for (final EmailAttachment attachment : attachments) {\n                final String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n                if (attachment.getEmbeddedFilename() == null) {\n                    attachment.setEmbeddedFilename(attachment.getFilename());\n                }\n\n                html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\")\n                    .append(uniqueId)\n                    .append(\"\\\"><span class=\\\"attachment-icon\\\">\")\n                    .append(MimeConstants.ATTACHMENT_MARKER)\n                    .append(\"</span> <span class=\\\"attachment-name\\\">\")\n                    .append(escapeHtml(safeMimeDecode(attachment.getFilename())))\n                    .append(\"</span> <span class=\\\"attachment-details\\\">(\")\n                    .append(formatFileSize(attachment.getSizeBytes()));\n\n                if (attachment.getContentType() != null && !attachment.getContentType().isEmpty()) {\n                    html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                }\n                html.append(\")</span></div>\\n\");\n            }\n        }\n\n        final String note = request.isIncludeAttachments()\n            ? \"<p><em>Attachments are embedded in the file.</em></p>\\n\"\n            : \"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\";\n        html.append(\"<div class=\\\"attachment-info-note\\\">\").append(note).append(\"</div>\\n\")\n            .append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n</body></html>\");\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "148", "src_id": "M356", "code": "\nprivate static void appendEnhancedStyles(final StringBuilder html) {\n    final int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n    final String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n    final String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n    final String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n    html.append(\"body {\\n\")\n        .append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\")\n        .append(\"  font-size: \").append(fontSize).append(\"px;\\n\")\n        .append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\")\n        .append(\"  color: \").append(textColor).append(\";\\n\")\n        .append(\"  margin: 0;\\n\")\n        .append(\"  padding: 16px;\\n\")\n        .append(\"  background-color: \").append(backgroundColor).append(\";\\n}\\n\\n\")\n        \n        .append(\".email-container {\\n\")\n        .append(\"  width: 100%;\\n\")\n        .append(\"  max-width: 100%;\\n\")\n        .append(\"  margin: 0 auto;\\n}\\n\\n\")\n        \n        .append(\".email-header {\\n\")\n        .append(\"  padding-bottom: 10px;\\n\")\n        .append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\")\n        .append(\"  margin-bottom: 10px;\\n}\\n\\n\")\n        \n        .append(\".email-header h1 {\\n\")\n        .append(\"  margin: 0 0 10px 0;\\n\")\n        .append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\")\n        .append(\"  font-weight: bold;\\n}\\n\\n\")\n        \n        .append(\".email-meta div {\\n\")\n        .append(\"  margin-bottom: 2px;\\n\")\n        .append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n}\\n\\n\")\n        \n        .append(\".email-body {\\n\")\n        .append(\"  word-wrap: break-word;\\n}\\n\\n\")\n        \n        .append(\".attachment-section {\\n\")\n        .append(\"  margin-top: 15px;\\n\")\n        .append(\"  padding: 10px;\\n\")\n        .append(\"  background-color: \").append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\")\n        .append(\"  border: 1px solid \").append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\")\n        .append(\"  border-radius: 3px;\\n}\\n\\n\")\n        \n        .append(\".attachment-section h3 {\\n\")\n        .append(\"  margin: 0 0 8px 0;\\n\")\n        .append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n}\\n\\n\")\n        \n        .append(\".attachment-item {\\n\")\n        .append(\"  padding: 5px 0;\\n}\\n\\n\")\n        \n        .append(\".attachment-icon {\\n\")\n        .append(\"  margin-right: 5px;\\n}\\n\\n\")\n        \n        .append(\".attachment-details, .attachment-type {\\n\")\n        .append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\")\n        .append(\"  color: #555555;\\n}\\n\\n\")\n        \n        .append(\".attachment-inclusion-note, .attachment-info-note {\\n\")\n        .append(\"  margin-top: 8px;\\n\")\n        .append(\"  padding: 6px;\\n\")\n        .append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\")\n        .append(\"  border-radius: 3px;\\n}\\n\\n\")\n        \n        .append(\".attachment-inclusion-note {\\n\")\n        .append(\"  background-color: #e6ffed;\\n\")\n        .append(\"  border: 1px solid #d4f7dc;\\n\")\n        .append(\"  color: #006420;\\n}\\n\\n\")\n        \n        .append(\".attachment-info-note {\\n\")\n        .append(\"  background-color: #fff9e6;\\n\")\n        .append(\"  border: 1px solid #fff0c2;\\n\")\n        .append(\"  color: #664d00;\\n}\\n\\n\")\n        \n        .append(\".attachment-link-container {\\n\")\n        .append(\"  display: flex;\\n\")\n        .append(\"  align-items: center;\\n\")\n        .append(\"  padding: 8px;\\n\")\n        .append(\"  background-color: #f8f9fa;\\n\")\n        .append(\"  border: 1px solid #dee2e6;\\n\")\n        .append(\"  border-radius: 4px;\\n\")\n        .append(\"  margin: 4px 0;\\n}\\n\\n\")\n        \n        .append(\".attachment-link-container:hover {\\n\")\n        .append(\"  background-color: #e9ecef;\\n}\\n\\n\")\n        \n        .append(\".attachment-note {\\n\")\n        .append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\")\n        .append(\"  color: #6c757d;\\n\")\n        .append(\"  font-style: italic;\\n\")\n        .append(\"  margin-left: 8px;\\n}\\n\\n\")\n        \n        .append(\"img {\\n\")\n        .append(\"  max-width: 100%;\\n\")\n        .append(\"  height: auto;\\n\")\n        .append(\"  display: block;\\n}\\n\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "149", "src_id": "M359", "code": "\nprivate static EmailContent extractEmailContentAdvanced(\n        final Object message, final EmlToPdfRequest request) {\n    final EmailContent content = new EmailContent();\n\n    try {\n        final Class<?> messageClass = message.getClass();\n        final Method getSubject = messageClass.getMethod(\"getSubject\");\n        final Method getFrom = messageClass.getMethod(\"getFrom\");\n        final Method getAllRecipients = messageClass.getMethod(\"getAllRecipients\");\n        final Method getSentDate = messageClass.getMethod(\"getSentDate\");\n        final Method getContent = messageClass.getMethod(\"getContent\");\n        final Method getContentType = messageClass.getMethod(\"getContentType\");\n\n        content.setSubject(safeMimeDecode((String) getSubject.invoke(message)));\n\n        final Object[] fromAddresses = (Object[]) getFrom.invoke(message);\n        content.setFrom((fromAddresses != null && fromAddresses.length > 0)\n                ? safeMimeDecode(fromAddresses[0].toString())\n                : \"\");\n\n        final Object[] recipients = (Object[]) getAllRecipients.invoke(message);\n        content.setTo((recipients != null && recipients.length > 0)\n                ? safeMimeDecode(recipients[0].toString())\n                : \"\");\n\n        content.setDate((Date) getSentDate.invoke(message));\n\n        final Object messageContent = getContent.invoke(message);\n        if (messageContent instanceof String stringContent) {\n            final String contentType = (String) getContentType.invoke(message);\n            if (contentType != null && contentType.toLowerCase().contains(\"text/html\")) {\n                content.setHtmlBody(stringContent);\n            } else {\n                content.setTextBody(stringContent);\n            }\n        } else {\n            try {\n                final Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(messageContent)) {\n                    processMultipartAdvanced(messageContent, content, request);\n                }\n            } catch (Exception e) {\n                log.warn(\"Error processing content: {}\", e.getMessage());\n            }\n        }\n\n    } catch (Exception e) {\n        content.setSubject(\"Email Conversion\");\n        content.setFrom(\"Unknown\");\n        content.setTo(\"Unknown\");\n        content.setTextBody(\"Email content could not be parsed with advanced processing\");\n    }\n\n    return content;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "150", "src_id": "M894", "code": "\npublic static RequestCreator loadScaledDownThumbnail(Context context,\n                                                     @NonNull List<Image> images) {\n    return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n        @Override\n        public Bitmap transform(Bitmap source) {\n            if (DEBUG) Log.d(TAG, \"Thumbnail - transform() called\");\n\n            float notificationThumbnailWidth = Math.min(\n                    context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                    source.getWidth());\n\n            Bitmap result = BitmapCompat.createScaledBitmap(\n                    source,\n                    (int) notificationThumbnailWidth,\n                    (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)),\n                    null,\n                    true);\n\n            if (result == source || !result.isMutable()) {\n                Bitmap copied = BitmapCompat.createScaledBitmap(\n                        source,\n                        (int) notificationThumbnailWidth - 1,\n                        (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))),\n                        null,\n                        true);\n                source.recycle();\n                return copied;\n            } else {\n                source.recycle();\n                return result;\n            }\n        }\n\n        @Override\n        public String key() {\n            return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n        }\n    });\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "151", "src_id": "M369", "code": "\nprivate void buildQualityMenu() {\n    if (qualityPopupMenu == null) return;\n    qualityPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_QUALITY);\n\n    List<VideoStream> availableStreams = Optional.ofNullable(player.getCurrentMetadata())\n            .flatMap(MediaItemTag::getMaybeQuality)\n            .map(MediaItemTag.Quality::getSortedVideoStreams)\n            .orElse(null);\n    if (availableStreams == null) return;\n\n    for (int i = 0; i < availableStreams.size(); i++) {\n        VideoStream videoStream = availableStreams.get(i);\n        qualityPopupMenu.getMenu().add(POPUP_MENU_ID_QUALITY, i, Menu.NONE, \n                MediaFormat.getNameById(videoStream.getFormatId()) + \" \" + videoStream.getResolution());\n    }\n    qualityPopupMenu.setOnMenuItemClickListener(this);\n    qualityPopupMenu.setOnDismissListener(this);\n\n    player.getSelectedVideoStream().ifPresent(s -> \n            binding.qualityTextView.setText(s.getResolution()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "152", "src_id": "M372", "code": "\nprivate void buildCaptionMenu(@NonNull List<String> availableLanguages) {\n    if (captionPopupMenu == null) return;\n    captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n    captionPopupMenu.setOnDismissListener(this);\n\n    MenuItem captionOffItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION,\n            0, Menu.NONE, R.string.caption_none);\n    captionOffItem.setOnMenuItemClickListener(menuItem -> {\n        int textRendererIndex = player.getCaptionRendererIndex();\n        if (textRendererIndex != RENDERER_UNAVAILABLE) {\n            player.getTrackSelector().setParameters(player.getTrackSelector()\n                    .buildUponParameters().setRendererDisabled(textRendererIndex, true));\n        }\n        player.getPrefs().edit()\n                .remove(context.getString(R.string.caption_user_set_key)).apply();\n        return true;\n    });\n\n    for (int i = 0; i < availableLanguages.size(); i++) {\n        String captionLanguage = availableLanguages.get(i);\n        MenuItem captionItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION,\n                i + 1, Menu.NONE, captionLanguage);\n        captionItem.setOnMenuItemClickListener(menuItem -> {\n            int textRendererIndex = player.getCaptionRendererIndex();\n            if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                player.getTrackSelector().setParameters(player.getTrackSelector()\n                        .buildUponParameters()\n                        .setPreferredTextLanguages(captionLanguage,\n                                PlayerHelper.captionLanguageStemOf(captionLanguage))\n                        .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                        .setRendererDisabled(textRendererIndex, false));\n                player.getPrefs().edit().putString(context.getString(\n                        R.string.caption_user_set_key), captionLanguage).apply();\n            }\n            return true;\n        });\n    }\n\n    int textRendererIndex = player.getCaptionRendererIndex();\n    if (textRendererIndex == RENDERER_UNAVAILABLE) return;\n\n    String userPreferredLanguage =\n            player.getPrefs().getString(context.getString(R.string.caption_user_set_key), null);\n    if (userPreferredLanguage == null) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters()\n                .setRendererDisabled(textRendererIndex, true));\n        return;\n    }\n\n    List<String> selectedPreferredLanguages =\n            player.getTrackSelector().getParameters().preferredTextLanguages;\n    if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters()\n                .setPreferredTextLanguages(userPreferredLanguage,\n                        PlayerHelper.captionLanguageStemOf(userPreferredLanguage))\n                .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                .setRendererDisabled(textRendererIndex, false));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "153", "src_id": "M527", "code": "\n@SuppressLint(\"PrivateResource\")\n@Nullable\npublic static NotificationActionData fromNotificationActionEnum(\n        @NonNull Player player,\n        @NotificationConstants.Action int selectedAction) {\n\n    int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n    Context ctx = player.getContext();\n\n    switch (selectedAction) {\n        case NotificationConstants.PREVIOUS:\n            return new NotificationActionData(ACTION_PLAY_PREVIOUS,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description), baseActionIcon);\n        case NotificationConstants.NEXT:\n            return new NotificationActionData(ACTION_PLAY_NEXT,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description), baseActionIcon);\n        case NotificationConstants.REWIND:\n            return new NotificationActionData(ACTION_FAST_REWIND,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description), baseActionIcon);\n        case NotificationConstants.FORWARD:\n            return new NotificationActionData(ACTION_FAST_FORWARD,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description), baseActionIcon);\n        case NotificationConstants.SMART_REWIND_PREVIOUS:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(ACTION_PLAY_PREVIOUS,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_previous);\n            } else {\n                return new NotificationActionData(ACTION_FAST_REWIND,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_rewind);\n            }\n        case NotificationConstants.SMART_FORWARD_NEXT:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(ACTION_PLAY_NEXT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_next);\n            } else {\n                return new NotificationActionData(ACTION_FAST_FORWARD,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_fastforward);\n            }\n        case NotificationConstants.PLAY_PAUSE_BUFFERING:\n            if (player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(R.string.notification_action_buffering),\n                        R.drawable.ic_hourglass_top);\n            }\n        case NotificationConstants.PLAY_PAUSE:\n            if (player.getCurrentState() == Player.STATE_COMPLETED) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description),\n                        R.drawable.ic_replay);\n            } else if (player.isPlaying()\n                    || player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_pause);\n            } else {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_play_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_play);\n            }\n        case NotificationConstants.REPEAT:\n            if (player.getRepeatMode() == REPEAT_MODE_ALL) {\n                return new NotificationActionData(ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_all_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_all);\n            } else if (player.getRepeatMode() == REPEAT_MODE_ONE) {\n                return new NotificationActionData(ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_one_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_one);\n            } else {\n                return new NotificationActionData(ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_off_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_off);\n            }\n        case NotificationConstants.SHUFFLE:\n            if (player.getPlayQueue() != null && player.getPlayQueue().isShuffled()) {\n                return new NotificationActionData(ACTION_SHUFFLE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_shuffle_on_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_on);\n            } else {\n                return new NotificationActionData(ACTION_SHUFFLE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_shuffle_off_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_off);\n            }\n        case NotificationConstants.CLOSE:\n            return new NotificationActionData(ACTION_CLOSE, ctx.getString(R.string.close),\n                    R.drawable.ic_close);\n        case NotificationConstants.NOTHING:\n        default:\n            return null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "154", "src_id": "M16", "code": "\nprivate void handleCookiesFromUrl(@Nullable String url) {\n    if (MainActivity.DEBUG) Log.d(TAG, \"handleCookiesFromUrl: url=\" + (url == null ? \"null\" : url));\n    if (url == null) return;\n\n    String cookies = CookieManager.getInstance().getCookie(url);\n    handleCookies(cookies);\n\n    int abuseStart = url.indexOf(\"google_abuse=\");\n    if (abuseStart != -1) {\n        int abuseEnd = url.indexOf(\"+path\");\n        try {\n            handleCookies(Utils.decodeUrlUtf8(url.substring(abuseStart + 13, abuseEnd)));\n        } catch (StringIndexOutOfBoundsException e) {\n            if (MainActivity.DEBUG) Log.e(TAG, \"handleCookiesFromUrl: invalid google abuse\", e);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "155", "src_id": "M456", "code": "\nprivate void toggleFullscreen() {\n    if (DEBUG) Log.d(TAG, \"toggleFullscreen() called\");\n    PlayerServiceEventListener fragmentListener = player.getFragmentListener().orElse(null);\n    if (fragmentListener == null || player.exoPlayerIsNull()) return;\n\n    isFullscreen = !isFullscreen;\n    if (isFullscreen) {\n        hideControls(0, 0);\n    } else {\n        binding.playbackControlRoot.setPadding(0, 0, 0, 0);\n    }\n    fragmentListener.onFullscreenStateChanged(isFullscreen);\n\n    binding.titleTextView.setVisibility(isFullscreen ? View.VISIBLE : View.GONE);\n    binding.channelTextView.setVisibility(isFullscreen ? View.VISIBLE : View.GONE);\n    binding.playerCloseButton.setVisibility(isFullscreen ? View.GONE : View.VISIBLE);\n    setupScreenRotationButton();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "156", "src_id": "M217", "code": "\nprivate void initPlayer(boolean playOnReady) {\n    if (DEBUG) Log.d(TAG, \"initPlayer() called with: playOnReady = [\" + playOnReady + \"]\");\n\n    simpleExoPlayer = new ExoPlayer.Builder(context, renderFactory)\n            .setTrackSelector(trackSelector)\n            .setLoadControl(loadController)\n            .setUsePlatformDiagnostics(false)\n            .build();\n    simpleExoPlayer.addListener(this);\n    simpleExoPlayer.setPlayWhenReady(playOnReady);\n    simpleExoPlayer.setSeekParameters(PlayerHelper.getSeekParameters(context));\n    simpleExoPlayer.setWakeMode(C.WAKE_MODE_NETWORK);\n    simpleExoPlayer.setHandleAudioBecomingNoisy(true);\n\n    audioReactor = new AudioReactor(context, simpleExoPlayer);\n    registerBroadcastReceiver();\n    UIs.call(PlayerUi::initPlayer);\n\n    if (!PreferenceManager.getDefaultSharedPreferences(context)\n            .getBoolean(context.getString(R.string.disable_media_tunneling_key), false)) {\n        trackSelector.setParameters(trackSelector.buildUponParameters().setTunnelingEnabled(true));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "157", "src_id": "M467", "code": "\nprivate MediaMetadataCompat buildMediaMetadata() {\n    if (DEBUG) Log.d(TAG, \"buildMediaMetadata called\");\n\n    MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder()\n            .putString(MediaMetadataCompat.METADATA_KEY_TITLE, player.getVideoTitle())\n            .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, player.getUploaderName());\n\n    long duration = player.getCurrentStreamInfo()\n            .filter(info -> !StreamTypeUtil.isLiveStream(info.getStreamType()))\n            .map(info -> info.getDuration() * 1000L)\n            .orElse(-1L);\n    builder.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration);\n\n    boolean showThumbnail = player.getPrefs().getBoolean(\n            context.getString(R.string.show_thumbnail_key), true);\n    Optional.ofNullable(player.getThumbnail())\n            .filter(bitmap -> showThumbnail)\n            .ifPresent(bitmap -> {\n                builder.putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, bitmap);\n                builder.putBitmap(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON, bitmap);\n            });\n\n    return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "158", "src_id": "M460", "code": "\npublic MediaDescriptionCompat getQueueMetadata(int index) {\n    if (player.getPlayQueue() == null) return null;\n    PlayQueueItem item = player.getPlayQueue().getItem(index);\n    if (item == null) return null;\n\n    MediaDescriptionCompat.Builder descBuilder = new MediaDescriptionCompat.Builder()\n            .setMediaId(String.valueOf(index))\n            .setTitle(item.getTitle())\n            .setSubtitle(item.getUploader());\n\n    Bundle additionalMetadata = new Bundle();\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_TITLE, item.getTitle());\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_ARTIST, item.getUploader());\n    additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, item.getDuration() * 1000);\n    additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, index + 1L);\n    additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, player.getPlayQueue().size());\n    descBuilder.setExtras(additionalMetadata);\n\n    try {\n        descBuilder.setIconUri(Uri.parse(ImageStrategy.choosePreferredImage(item.getThumbnails())));\n    } catch (Throwable e) {\n        // Ignore thumbnail errors\n    }\n\n    return descBuilder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "159", "src_id": "M543", "code": "\nprivate synchronized NotificationCompat.Builder createNotification() {\n    if (DEBUG) Log.d(TAG, \"createNotification()\");\n    notificationManager = NotificationManagerCompat.from(player.getContext());\n    NotificationCompat.Builder builder = new NotificationCompat.Builder(player.getContext(),\n            player.getContext().getString(R.string.notification_channel_id));\n    MediaStyle mediaStyle = new MediaStyle();\n\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n        int[] compactSlots = initializeNotificationSlots();\n        mediaStyle.setShowActionsInCompactView(compactSlots);\n    }\n    player.UIs()\n            .get(MediaSessionPlayerUi.class)\n            .flatMap(MediaSessionPlayerUi::getSessionToken)\n            .ifPresent(mediaStyle::setMediaSession);\n\n    builder.setStyle(mediaStyle)\n            .setPriority(NotificationCompat.PRIORITY_HIGH)\n            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n            .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n            .setShowWhen(false)\n            .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n            .setColor(ContextCompat.getColor(player.getContext(), R.color.dark_background_color))\n            .setColorized(player.getPrefs().getBoolean(\n                    player.getContext().getString(R.string.notification_colorize_key), true))\n            .setDeleteIntent(PendingIntentCompat.getBroadcast(player.getContext(),\n                    NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, false));\n\n    setLargeIcon(builder);\n    return builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "160", "src_id": "M1620", "code": "\n        void fastPath(Subscriber<? super R> a, Iterator<? extends R> iterator) {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n                R v;\n                try {\n                    v = iterator.next();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n                a.onNext(v);\n                if (cancelled) {\n                    return;\n                }\n                boolean b;\n                try {\n                    b = iterator.hasNext();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n                if (!b) {\n                    a.onComplete();\n                    return;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "161", "src_id": "M1380", "code": "\n        @Override\n        public void onComplete() {\n            if (done) {\n                return;\n            }\n            try {\n                onComplete.run();\n            } catch (Throwable e) {\n                fail(e);\n                return;\n            }\n            done = true;\n            downstream.onComplete();\n            try {\n                onAfterTerminate.run();\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                RxJavaPlugins.onError(e);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "162", "src_id": "M1939", "code": "\n        @Override\n        public void run(long n) {\n            long emitted = 0L;\n            Iterator<T> iterator = this.iterator;\n            ConditionalSubscriber<? super T> downstream = this.downstream;\n            for (;;) {\n                if (cancelled) {\n                    clear();\n                    break;\n                } else {\n                    T next;\n                    try {\n                        next = Objects.requireNonNull(iterator.next(), \"The Stream's Iterator returned a null value\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        downstream.onError(ex);\n                        cancelled = true;\n                        continue;\n                    }\n                    if (downstream.tryOnNext(next)) {\n                        emitted++;\n                    }\n                    if (cancelled) {\n                        continue;\n                    }\n                    try {\n                        if (!iterator.hasNext()) {\n                            downstream.onComplete();\n                            cancelled = true;\n                            continue;\n                        }\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        downstream.onError(ex);\n                        cancelled = true;\n                        continue;\n                    }\n                    if (emitted != n) {\n                        continue;\n                    }\n                }\n                n = get();\n                if (emitted == n) {\n                    if (compareAndSet(n, 0L)) {\n                        break;\n                    }\n                    n = get();\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "163", "src_id": "M1099", "code": "\n    void replay(CacheSubscription<T> consumer) {\n        if (consumer.getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        long index = consumer.index;\n        int offset = consumer.offset;\n        Node<T> node = consumer.node;\n        AtomicLong requested = consumer.requested;\n        Subscriber<? super T> downstream = consumer.downstream;\n        int capacity = capacityHint;\n        for (;;) {\n            boolean sourceDone = done;\n            boolean empty = size == index;\n            if (sourceDone && empty) {\n                consumer.node = null;\n                Throwable ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n                return;\n            }\n            if (!empty) {\n                long consumerRequested = requested.get();\n                if (consumerRequested == Long.MIN_VALUE) {\n                    consumer.node = null;\n                    return;\n                }\n                if (consumerRequested != index) {\n                    if (offset == capacity) {\n                        node = node.next;\n                        offset = 0;\n                    }\n                    downstream.onNext(node.values[offset]);\n                    offset++;\n                    index++;\n                    continue;\n                }\n            }\n            consumer.index = index;\n            consumer.offset = offset;\n            consumer.node = node;\n            missed = consumer.addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "164", "src_id": "M284", "code": "\n        @SuppressWarnings(\"unchecked\")\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n            Observer<? super R> downstream = this.downstream;\n            SimpleQueue<T> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n            for (;;) {\n                if (!active) {\n                    if (cancelled) {\n                        queue.clear();\n                        return;\n                    }\n                    if (!tillTheEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            queue.clear();\n                            cancelled = true;\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n                    boolean d = done;\n                    T v;\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelled = true;\n                        this.upstream.dispose();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                    boolean empty = v == null;\n                    if (d && empty) {\n                        cancelled = true;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                    if (!empty) {\n                        ObservableSource<? extends R> o;\n                        try {\n                            o = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null ObservableSource\");\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            cancelled = true;\n                            this.upstream.dispose();\n                            queue.clear();\n                            errors.tryAddThrowableOrReport(ex);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                        if (o instanceof Supplier) {\n                            R w;\n                            try {\n                                w = ((Supplier<R>)o).get();\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                continue;\n                            }\n                            if (w != null && !cancelled) {\n                                downstream.onNext(w);\n                            }\n                            continue;\n                        } else {\n                            active = true;\n                            o.subscribe(observer);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "165", "src_id": "M1908", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n            int missed = 1;\n            final Subscriber<? super R> downstream = this.downstream;\n            final SimpleQueue<T> queue = this.queue;\n            final AtomicThrowable error = this.error;\n            Iterator<? extends R> iterator = this.currentIterator;\n            long requested = this.requested.get();\n            long emitted = this.emitted;\n            final int limit = prefetch - (prefetch >> 2);\n            boolean canRequest = sourceMode != QueueFuseable.SYNC;\n            for (;;) {\n                if (cancelled) {\n                    queue.clear();\n                    clearCurrentSuppressCloseError();\n                } else {\n                    boolean isDone = upstreamDone;\n                    if (error.get() != null) {\n                        downstream.onError(error.get());\n                        cancelled = true;\n                        continue;\n                    }\n                    if (iterator == null) {\n                        T t;\n                        try {\n                            t = queue.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            trySignalError(downstream, ex);\n                            continue;\n                        }\n                        boolean isEmpty = t == null;\n                        if (isDone && isEmpty) {\n                            downstream.onComplete();\n                            cancelled = true;\n                        }\n                        else if (!isEmpty) {\n                            if (canRequest && ++consumed == limit) {\n                                consumed = 0;\n                                upstream.request(limit);\n                            }\n                            Stream<? extends R> stream;\n                            try {\n                                stream = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null Stream\");\n                                iterator = stream.iterator();\n                                if (iterator.hasNext()) {\n                                    currentIterator = iterator;\n                                    currentCloseable = stream;\n                                } else {\n                                    iterator = null;\n                                }\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                trySignalError(downstream, ex);\n                            }\n                            continue;\n                        }\n                    }\n                    if (iterator != null && emitted != requested) {\n                        R item;\n                        try {\n                            item = Objects.requireNonNull(iterator.next(), \"The Stream.Iterator returned a null value\");\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            trySignalError(downstream, ex);\n                            continue;\n                        }\n                        if (!cancelled) {\n                            downstream.onNext(item);\n                            emitted++;\n                            if (!cancelled) {\n                                try {\n                                    if (!iterator.hasNext()) {\n                                        iterator = null;\n                                        clearCurrentRethrowCloseError();\n                                    }\n                                } catch (Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    trySignalError(downstream, ex);\n                                }\n                            }\n                        }\n                        continue;\n                    }\n                }\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n                requested = this.requested.get();\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1237", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n            final Subscriber<? super R> a = downstream;\n            final ZipSubscriber<T, R>[] qs = subscribers;\n            final int n = qs.length;\n            Object[] values = current;\n            int missed = 1;\n            for (;;) {\n                long r = requested.get();\n                long e = 0L;\n                while (r != e) {\n                    if (cancelled) {\n                        return;\n                    }\n                    if (!delayErrors && errors.get() != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                    boolean empty = false;\n                    for (int j = 0; j < n; j++) {\n                        ZipSubscriber<T, R> inner = qs[j];\n                        if (values[j] == null) {\n                            boolean d = inner.done;\n                            SimpleQueue<T> q = inner.queue;\n                            T v = null;\n                            try {\n                                v = q != null ? q.poll() : null;\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n                                d = true;\n                            }\n                            boolean sourceEmpty = v == null;\n                            if (d && sourceEmpty) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            if (!sourceEmpty) {\n                                values[j] = v;\n                            } else {\n                                empty = true;\n                            }\n                        }\n                    }\n                    if (empty) {\n                        break;\n                    }\n                    R v;\n                    try {\n                        v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelAll();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                    a.onNext(v);\n                    e++;\n                    Arrays.fill(values, null);\n                }\n                if (r == e) {\n                    if (cancelled) {\n                        return;\n                    }\n                    if (!delayErrors && errors.get() != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                    for (int j = 0; j < n; j++) {\n                        ZipSubscriber<T, R> inner = qs[j];\n                        if (values[j] == null) {\n                            boolean d = inner.done;\n                            SimpleQueue<T> q = inner.queue;\n                            T v = null;\n                            try {\n                                v = q != null ? q.poll() : null;\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n                                d = true;\n                            }\n                            boolean empty = v == null;\n                            if (d && empty) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            if (!empty) {\n                                values[j] = v;\n                            }\n                        }\n                    }\n                }\n                if (e != 0L) {\n                    for (ZipSubscriber<T, R> inner : qs) {\n                        inner.request(e);\n                    }\n                    if (r != Long.MAX_VALUE) {\n                        requested.addAndGet(-e);\n                    }\n                }\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "167", "src_id": "M409", "code": "\n        @Override\n        Node getHead() {\n            long timeLimit = scheduler.now(unit) - maxAge;\n            Node prev = get();\n            Node next = prev.get();\n            for (;;) {\n                if (next == null) {\n                    break;\n                }\n                Timed<?> v = (Timed<?>)next.value;\n                if (NotificationLite.isComplete(v.value()) || NotificationLite.isError(v.value())) {\n                    break;\n                }\n                if (v.time() <= timeLimit) {\n                    prev = next;\n                    next = next.get();\n                } else {\n                    break;\n                }\n            }\n            return prev;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "168", "src_id": "M2271", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(AsyncSubscription<T> ps) {\n        for (;;) {\n            AsyncSubscription<T>[] a = subscribers.get();\n            int n = a.length;\n            if (n == 0) {\n                return;\n            }\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n            AsyncSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new AsyncSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "169", "src_id": "M335", "code": "\n        @Override\n        public void onSubscribe(Disposable d) {\n            if (DisposableHelper.validate(this.upstream, d)) {\n                this.upstream = d;\n                if (d instanceof QueueDisposable) {\n                    @SuppressWarnings(\"unchecked\")\n                    QueueDisposable<T> qd = (QueueDisposable<T>) d;\n                    int m = qd.requestFusion(QueueDisposable.ANY);\n                    if (m == QueueDisposable.SYNC) {\n                        fusionMode = m;\n                        queue = qd;\n                        done = true;\n                        downstream.onSubscribe(this);\n                        drain();\n                        return;\n                    }\n                    if (m == QueueDisposable.ASYNC) {\n                        fusionMode = m;\n                        queue = qd;\n                        downstream.onSubscribe(this);\n                        return;\n                    }\n                }\n                queue = new SpscLinkedArrayQueue<>(bufferSize);\n                downstream.onSubscribe(this);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "170", "src_id": "M478", "code": "\n    private void saveDocumentToZip(\n            PDDocument document, ZipOutputStream zipOut, String baseFilename, int index)\n            throws IOException {\n        log.debug(\"Starting saveDocumentToZip for document part {}\", index);\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n        try {\n            log.debug(\"Saving document part {} to byte array\", index);\n            document.save(outStream);\n            log.debug(\"Successfully saved document part {} ({} bytes)\", index, outStream.size());\n        } catch (Exception e) {\n            log.error(\"Error saving document part {} to byte array\", index, e);\n            throw ExceptionUtils.createFileProcessingException(\"split\", e);\n        }\n        try {\n            log.debug(\"Closing document part {}\", index);\n            document.close();\n            log.debug(\"Successfully closed document part {}\", index);\n        } catch (Exception e) {\n            log.error(\"Error closing document part {}\", index, e);\n        }\n        try {\n            String entryName = baseFilename + \"_\" + index + \".pdf\";\n            log.debug(\"Creating ZIP entry: {}\", entryName);\n            ZipEntry zipEntry = new ZipEntry(entryName);\n            zipOut.putNextEntry(zipEntry);\n            byte[] bytes = outStream.toByteArray();\n            log.debug(\"Writing {} bytes to ZIP entry\", bytes.length);\n            zipOut.write(bytes);\n            log.debug(\"Closing ZIP entry\");\n            zipOut.closeEntry();\n            log.debug(\"Successfully added document part {} to ZIP\", index);\n        } catch (Exception e) {\n            log.error(\"Error adding document part {} to ZIP\", index, e);\n            throw ExceptionUtils.createFileProcessingException(\"split\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "171", "src_id": "M101", "code": "\n    private void processRequest(\n            int limitPerDay,\n            String identifier,\n            Map<String, Bucket> buckets,\n            HttpServletRequest request,\n            HttpServletResponse response,\n            FilterChain filterChain)\n            throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\n                    \"X-Rate-Limit-Remaining\",\n                    stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\n                    \"X-Rate-Limit-Retry-After-Seconds\",\n                    Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "172", "src_id": "M38", "code": "\n    @SuppressWarnings(\"deprecation\")\n    public void migrateEnterpriseSettingsToPremium(ApplicationProperties applicationProperties) {\n        EnterpriseEdition enterpriseEdition = applicationProperties.getEnterpriseEdition();\n        Premium premium = applicationProperties.getPremium();\n        if (enterpriseEdition == null || premium == null) {\n            return;\n        }\n        if (premium.getKey() == null\n                || \"00000000-0000-0000-0000-000000000000\".equals(premium.getKey())) {\n            if (enterpriseEdition.getKey() != null\n                    && !\"00000000-0000-0000-0000-000000000000\".equals(enterpriseEdition.getKey())) {\n                premium.setKey(enterpriseEdition.getKey());\n            }\n        }\n        if (!premium.isEnabled() && enterpriseEdition.isEnabled()) {\n            premium.setEnabled(true);\n        }\n        if (!premium.getProFeatures().isSsoAutoLogin() && enterpriseEdition.isSsoAutoLogin()) {\n            premium.getProFeatures().setSsoAutoLogin(true);\n        }\n        Premium.ProFeatures.CustomMetadata premiumMetadata = premium.getProFeatures().getCustomMetadata();\n        EnterpriseEdition.CustomMetadata enterpriseMetadata = enterpriseEdition.getCustomMetadata();\n        if (enterpriseMetadata != null && premiumMetadata != null) {\n            if (!premiumMetadata.isAutoUpdateMetadata() && enterpriseMetadata.isAutoUpdateMetadata()) {\n                premiumMetadata.setAutoUpdateMetadata(true);\n            }\n            if ((premiumMetadata.getAuthor() == null\n                            || premiumMetadata.getAuthor().trim().isEmpty()\n                            || \"username\".equals(premiumMetadata.getAuthor()))\n                    && enterpriseMetadata.getAuthor() != null\n                    && !enterpriseMetadata.getAuthor().trim().isEmpty()) {\n                premiumMetadata.setAuthor(enterpriseMetadata.getAuthor());\n            }\n            if ((premiumMetadata.getCreator() == null\n                            || \"Stirling-PDF\".equals(premiumMetadata.getCreator()))\n                    && enterpriseMetadata.getCreator() != null\n                    && !\"Stirling-PDF\".equals(enterpriseMetadata.getCreator())) {\n                premiumMetadata.setCreator(enterpriseMetadata.getCreator());\n            }\n            if ((premiumMetadata.getProducer() == null\n                            || \"Stirling-PDF\".equals(premiumMetadata.getProducer()))\n                    && enterpriseMetadata.getProducer() != null\n                    && !\"Stirling-PDF\".equals(enterpriseMetadata.getProducer())) {\n                premiumMetadata.setProducer(enterpriseMetadata.getProducer());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "173", "src_id": "M543", "code": "\n    private void applyGhostscriptCompression(\n            OptimizePdfRequest request, int optimizeLevel, Path currentFile, List<Path> tempFiles)\n            throws IOException {\n        long preGsSize = Files.size(currentFile);\n        log.info(\"Pre-Ghostscript file size: {}\", GeneralUtils.formatBytes(preGsSize));\n        Path gsOutputFile = Files.createTempFile(\"gs_output_\", \".pdf\");\n        tempFiles.add(gsOutputFile);\n        List<String> command = new ArrayList<>();\n        command.add(\"gs\");\n        command.add(\"-sDEVICE=pdfwrite\");\n        command.add(\"-dCompatibilityLevel=1.5\");\n        command.add(\"-dNOPAUSE\");\n        command.add(\"-dQUIET\");\n        command.add(\"-dBATCH\");\n        switch (optimizeLevel) {\n            case 1:\n                command.add(\"-dPDFSETTINGS=/prepress\");\n                break;\n            case 2:\n                command.add(\"-dPDFSETTINGS=/printer\");\n                break;\n            case 3:\n                command.add(\"-dPDFSETTINGS=/ebook\");\n                break;\n            case 4:\n            case 5:\n                command.add(\"-dPDFSETTINGS=/screen\");\n                break;\n            case 6:\n            case 7:\n                command.add(\"-dPDFSETTINGS=/screen\");\n                command.add(\"-dColorImageResolution=150\");\n                command.add(\"-dGrayImageResolution=150\");\n                command.add(\"-dMonoImageResolution=300\");\n                break;\n            case 8:\n            case 9:\n                command.add(\"-dPDFSETTINGS=/screen\");\n                command.add(\"-dColorImageResolution=100\");\n                command.add(\"-dGrayImageResolution=100\");\n                command.add(\"-dMonoImageResolution=200\");\n                break;\n            case 10:\n                command.add(\"-dPDFSETTINGS=/screen\");\n                command.add(\"-dColorImageResolution=72\");\n                command.add(\"-dGrayImageResolution=72\");\n                command.add(\"-dMonoImageResolution=150\");\n                break;\n            default:\n                command.add(\"-dPDFSETTINGS=/screen\");\n                break;\n        }\n        command.add(\"-sOutputFile=\" + gsOutputFile.toString());\n        command.add(currentFile.toString());\n        ProcessExecutorResult returnCode = null;\n        try {\n            returnCode = ProcessExecutor.getInstance(ProcessExecutor.Processes.GHOSTSCRIPT)\n                    .runCommandWithOutputHandling(command);\n            if (returnCode.getRc() == 0) {\n                Files.copy(gsOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n                long postGsSize = Files.size(currentFile);\n                double gsReduction = 100.0 - ((postGsSize * 100.0) / preGsSize);\n                log.info(\n                        \"Post-Ghostscript file size: {} (reduced by {}%)\",\n                        GeneralUtils.formatBytes(postGsSize), String.format(\"%.1f\", gsReduction));\n            } else {\n                log.warn(\"Ghostscript compression failed with return code: {}\", returnCode.getRc());\n                throw new IOException(\"Ghostscript compression failed\");\n            }\n        } catch (Exception e) {\n            log.warn(\"Ghostscript compression failed, will fallback to other methods\", e);\n            throw new IOException(\"Ghostscript compression failed\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "174", "src_id": "M256", "code": "\n    private Object executeWithRetries(\n            ProceedingJoinPoint joinPoint,\n            Object[] args,\n            boolean async,\n            long timeout,\n            int maxRetries,\n            boolean trackProgress,\n            boolean queueable,\n            int resourceWeight) {\n        AtomicReference<String> jobIdRef = new AtomicReference<>();\n        return jobExecutorService.runJobGeneric(\n                async,\n                () -> {\n                    Throwable lastException = null;\n                    for (int currentAttempt = 1; currentAttempt <= maxRetries; currentAttempt++) {\n                        try {\n                            if (trackProgress && async) {\n                                if (jobIdRef.get() == null) {\n                                    jobIdRef.set(getJobIdFromContext());\n                                }\n                                String jobId = jobIdRef.get();\n                                if (jobId != null) {\n                                    log.debug(\n                                            \"Tracking progress for job {} (attempt {}/{})\",\n                                            jobId, currentAttempt, maxRetries);\n                                }\n                            }\n                            return joinPoint.proceed(args);\n                        } catch (Throwable ex) {\n                            lastException = ex;\n                            log.error(\n                                    \"AutoJobAspect caught exception during job execution (attempt {}/{}): {}\",\n                                    currentAttempt, maxRetries, ex.getMessage(), ex);\n                            if (currentAttempt < maxRetries) {\n                                log.info(\"Retrying operation, attempt {}/{}\", currentAttempt + 1, maxRetries);\n                                if (trackProgress && async) {\n                                    String jobId = jobIdRef.get();\n                                    if (jobId != null) {\n                                        log.debug(\"Recording retry attempt for job {} in TaskManager\", jobId);\n                                    }\n                                }\n                                long delayMs = RETRY_BASE_DELAY.toMillis() * currentAttempt;\n                                CompletableFuture<Object> delayedRetry = new CompletableFuture<>();\n                                CompletableFuture.delayedExecutor(delayMs, TimeUnit.MILLISECONDS)\n                                        .execute(() -> delayedRetry.complete(null));\n                                try {\n                                    delayedRetry.join();\n                                } catch (Exception e) {\n                                    Thread.currentThread().interrupt();\n                                    break;\n                                }\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                    if (lastException != null) {\n                        throw new RuntimeException(\n                                \"Job failed after \" + maxRetries + \" attempts: \" + lastException.getMessage(),\n                                lastException);\n                    }\n                    throw new RuntimeException(\"Job failed but no exception was recorded\");\n                },\n                timeout,\n                queueable,\n                resourceWeight);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "175", "src_id": "M813", "code": "\n    public void init() {\n        addEndpointToGroup(\"PageOps\", \"remove-pages\");\n        addEndpointToGroup(\"PageOps\", \"merge-pdfs\");\n        addEndpointToGroup(\"PageOps\", \"split-pdfs\");\n        addEndpointToGroup(\"PageOps\", \"pdf-organizer\");\n        addEndpointToGroup(\"PageOps\", \"rotate-pdf\");\n        addEndpointToGroup(\"PageOps\", \"multi-page-layout\");\n        addEndpointToGroup(\"PageOps\", \"scale-pages\");\n        addEndpointToGroup(\"PageOps\", \"adjust-contrast\");\n        addEndpointToGroup(\"PageOps\", \"crop\");\n        addEndpointToGroup(\"PageOps\", \"auto-split-pdf\");\n        addEndpointToGroup(\"PageOps\", \"extract-page\");\n        addEndpointToGroup(\"PageOps\", \"pdf-to-single-page\");\n        addEndpointToGroup(\"PageOps\", \"split-by-size-or-count\");\n        addEndpointToGroup(\"PageOps\", \"overlay-pdf\");\n        addEndpointToGroup(\"PageOps\", \"split-pdf-by-sections\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-img\");\n        addEndpointToGroup(\"Convert\", \"img-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-pdfa\");\n        addEndpointToGroup(\"Convert\", \"file-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-word\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-presentation\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-text\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-html\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-xml\");\n        addEndpointToGroup(\"Convert\", \"html-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"url-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"markdown-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-csv\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-markdown\");\n        addEndpointToGroup(\"Convert\", \"eml-to-pdf\");\n        addEndpointToGroup(\"Security\", \"add-password\");\n        addEndpointToGroup(\"Security\", \"remove-password\");\n        addEndpointToGroup(\"Security\", \"change-permissions\");\n        addEndpointToGroup(\"Security\", \"add-watermark\");\n        addEndpointToGroup(\"Security\", \"cert-sign\");\n        addEndpointToGroup(\"Security\", \"remove-cert-sign\");\n        addEndpointToGroup(\"Security\", \"sanitize-pdf\");\n        addEndpointToGroup(\"Security\", \"auto-redact\");\n        addEndpointToGroup(\"Security\", \"redact\");\n        addEndpointToGroup(\"Other\", \"ocr-pdf\");\n        addEndpointToGroup(\"Other\", \"add-image\");\n        addEndpointToGroup(\"Other\", \"compress-pdf\");\n        addEndpointToGroup(\"Other\", \"extract-images\");\n        addEndpointToGroup(\"Other\", \"change-metadata\");\n        addEndpointToGroup(\"Other\", \"extract-image-scans\");\n        addEndpointToGroup(\"Other\", \"sign\");\n        addEndpointToGroup(\"Other\", \"flatten\");\n        addEndpointToGroup(\"Other\", \"repair\");\n        addEndpointToGroup(\"Other\", \"unlock-pdf-forms\");\n        addEndpointToGroup(\"Other\", REMOVE_BLANKS);\n        addEndpointToGroup(\"Other\", \"remove-annotations\");\n        addEndpointToGroup(\"Other\", \"compare\");\n        addEndpointToGroup(\"Other\", \"add-page-numbers\");\n        addEndpointToGroup(\"Other\", \"auto-rename\");\n        addEndpointToGroup(\"Other\", \"get-info-on-pdf\");\n        addEndpointToGroup(\"Other\", \"show-javascript\");\n        addEndpointToGroup(\"Other\", \"remove-image-pdf\");\n        addEndpointToGroup(\"Other\", \"add-attachments\");\n        addEndpointToGroup(\"CLI\", \"compress-pdf\");\n        addEndpointToGroup(\"CLI\", \"extract-image-scans\");\n        addEndpointToGroup(\"CLI\", \"repair\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-pdfa\");\n        addEndpointToGroup(\"CLI\", \"file-to-pdf\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-word\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-presentation\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-html\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-xml\");\n        addEndpointToGroup(\"CLI\", \"ocr-pdf\");\n        addEndpointToGroup(\"CLI\", \"html-to-pdf\");\n        addEndpointToGroup(\"CLI\", \"url-to-pdf\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-rtf\");\n        addEndpointToGroup(\"Python\", \"extract-image-scans\");\n        addEndpointToGroup(\"Python\", \"html-to-pdf\");\n        addEndpointToGroup(\"Python\", \"url-to-pdf\");\n        addEndpointToGroup(\"Python\", \"file-to-pdf\");\n        addEndpointToGroup(\"OpenCV\", \"extract-image-scans\");\n        addEndpointToGroup(\"LibreOffice\", \"file-to-pdf\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-word\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-presentation\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-rtf\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-html\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-xml\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-pdfa\");\n        addEndpointToGroup(\"Unoconvert\", \"file-to-pdf\");\n        addEndpointToGroup(\"Java\", \"merge-pdfs\");\n        addEndpointToGroup(\"Java\", \"remove-pages\");\n        addEndpointToGroup(\"Java\", \"split-pdfs\");\n        addEndpointToGroup(\"Java\", \"pdf-organizer\");\n        addEndpointToGroup(\"Java\", \"rotate-pdf\");\n        addEndpointToGroup(\"Java\", \"pdf-to-img\");\n        addEndpointToGroup(\"Java\", \"img-to-pdf\");\n        addEndpointToGroup(\"Java\", \"add-password\");\n        addEndpointToGroup(\"Java\", \"remove-password\");\n        addEndpointToGroup(\"Java\", \"change-permissions\");\n        addEndpointToGroup(\"Java\", \"add-watermark\");\n        addEndpointToGroup(\"Java\", \"add-image\");\n        addEndpointToGroup(\"Java\", \"extract-images\");\n        addEndpointToGroup(\"Java\", \"change-metadata\");\n        addEndpointToGroup(\"Java\", \"cert-sign\");\n        addEndpointToGroup(\"Java\", \"remove-cert-sign\");\n        addEndpointToGroup(\"Java\", \"multi-page-layout\");\n        addEndpointToGroup(\"Java\", \"scale-pages\");\n        addEndpointToGroup(\"Java\", \"add-page-numbers\");\n        addEndpointToGroup(\"Java\", \"auto-rename\");\n        addEndpointToGroup(\"Java\", \"auto-split-pdf\");\n        addEndpointToGroup(\"Java\", \"sanitize-pdf\");\n        addEndpointToGroup(\"Java\", \"crop\");\n        addEndpointToGroup(\"Java\", \"get-info-on-pdf\");\n        addEndpointToGroup(\"Java\", \"extract-page\");\n        addEndpointToGroup(\"Java\", \"pdf-to-single-page\");\n        addEndpointToGroup(\"Java\", \"markdown-to-pdf\");\n        addEndpointToGroup(\"Java\", \"show-javascript\");\n        addEndpointToGroup(\"Java\", \"auto-redact\");\n        addEndpointToGroup(\"Java\", \"redact\");\n        addEndpointToGroup(\"Java\", \"pdf-to-csv\");\n        addEndpointToGroup(\"Java\", \"split-by-size-or-count\");\n        addEndpointToGroup(\"Java\", \"overlay-pdf\");\n        addEndpointToGroup(\"Java\", \"split-pdf-by-sections\");\n        addEndpointToGroup(\"Java\", REMOVE_BLANKS);\n        addEndpointToGroup(\"Java\", \"pdf-to-text\");\n        addEndpointToGroup(\"Java\", \"remove-image-pdf\");\n        addEndpointToGroup(\"Java\", \"pdf-to-markdown\");\n        addEndpointToGroup(\"Java\", \"add-attachments\");\n        addEndpointToGroup(\"Java\", \"compress-pdf\");\n        addEndpointToGroup(\"Javascript\", \"pdf-organizer\");\n        addEndpointToGroup(\"Javascript\", \"sign\");\n        addEndpointToGroup(\"Javascript\", \"compare\");\n        addEndpointToGroup(\"Javascript\", \"adjust-contrast\");\n        addEndpointToGroup(\"qpdf\", \"repair\");\n        addEndpointToGroup(\"qpdf\", \"compress-pdf\");\n        addEndpointToGroup(\"Ghostscript\", \"repair\");\n        addEndpointToGroup(\"Ghostscript\", \"compress-pdf\");\n        addEndpointToGroup(\"tesseract\", \"ocr-pdf\");\n        addEndpointToGroup(\"OCRmyPDF\", \"ocr-pdf\");\n        addEndpointAlternative(\"repair\", \"qpdf\");\n        addEndpointAlternative(\"repair\", \"Ghostscript\");\n        addEndpointAlternative(\"compress-pdf\", \"qpdf\");\n        addEndpointAlternative(\"compress-pdf\", \"Ghostscript\");\n        addEndpointAlternative(\"compress-pdf\", \"Java\");\n        addEndpointAlternative(\"ocr-pdf\", \"tesseract\");\n        addEndpointAlternative(\"ocr-pdf\", \"OCRmyPDF\");\n        addEndpointAlternative(\"file-to-pdf\", \"LibreOffice\");\n        addEndpointAlternative(\"file-to-pdf\", \"Python\");\n        addEndpointAlternative(\"file-to-pdf\", \"Unoconvert\");\n        addEndpointAlternative(\"pdf-to-html\", \"LibreOffice\");\n        addEndpointAlternative(\"pdf-to-html\", \"Pdftohtml\");\n        addEndpointAlternative(\"pdf-to-markdown\", \"Pdftohtml\");\n        addEndpointAlternative(\"markdown-to-pdf\", \"Weasyprint\");\n        addEndpointAlternative(\"markdown-to-pdf\", \"Java\");\n        addEndpointToGroup(\"Weasyprint\", \"html-to-pdf\");\n        addEndpointToGroup(\"Weasyprint\", \"url-to-pdf\");\n        addEndpointToGroup(\"Weasyprint\", \"markdown-to-pdf\");\n        addEndpointToGroup(\"Weasyprint\", \"eml-to-pdf\");\n        addEndpointToGroup(\"Pdftohtml\", \"pdf-to-html\");\n        addEndpointToGroup(\"Pdftohtml\", \"pdf-to-markdown\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "176", "src_id": "M318", "code": "\n    public static byte[] overlayImage(\n            CustomPDFDocumentFactory pdfDocumentFactory,\n            byte[] pdfBytes,\n            byte[] imageBytes,\n            float x,\n            float y,\n            boolean everyPage)\n            throws IOException {\n        PDDocument document = pdfDocumentFactory.load(pdfBytes);\n        int pages = document.getNumberOfPages();\n        for (int i = 0; i < pages; i++) {\n            PDPage page = document.getPage(i);\n            try (PDPageContentStream contentStream =\n                    new PDPageContentStream(\n                            document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {\n                PDImageXObject image = PDImageXObject.createFromByteArray(document, imageBytes, \"\");\n                contentStream.drawImage(image, x, y);\n                log.info(\"Image successfully overlayed onto PDF\");\n                if (!everyPage && i == 0) {\n                    break;\n                }\n            } catch (IOException e) {\n                log.error(\"Error overlaying image onto PDF\", e);\n                throw e;\n            }\n        }\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        document.save(baos);\n        log.info(\"PDF successfully saved to byte array\");\n        return baos.toByteArray();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "177", "src_id": "M310", "code": "\n    public static PDRectangle textToPageSize(String size) {\n        switch (size.toUpperCase()) {\n            case \"A0\":\n                return PDRectangle.A0;\n            case \"A1\":\n                return PDRectangle.A1;\n            case \"A2\":\n                return PDRectangle.A2;\n            case \"A3\":\n                return PDRectangle.A3;\n            case \"A4\":\n                return PDRectangle.A4;\n            case \"A5\":\n                return PDRectangle.A5;\n            case \"A6\":\n                return PDRectangle.A6;\n            case \"LETTER\":\n                return PDRectangle.LETTER;\n            case \"LEGAL\":\n                return PDRectangle.LEGAL;\n            default:\n                throw ExceptionUtils.createInvalidPageSizeException(size);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "178", "src_id": "M208", "code": "\n    private long parseSessionTimeout(String timeout) {\n        if (timeout == null || timeout.isEmpty()) {\n            return 30 * 60 * 1000;\n        }\n        try {\n            String value = timeout.replaceAll(\"[^\\\\d.]\", \"\");\n            String unit = timeout.replaceAll(\"[\\\\d.]\", \"\");\n            double numericValue = Double.parseDouble(value);\n            switch (unit.toLowerCase()) {\n                case \"s\":\n                    return (long) (numericValue * 1000);\n                case \"m\":\n                    return (long) (numericValue * 60 * 1000);\n                case \"h\":\n                    return (long) (numericValue * 60 * 60 * 1000);\n                case \"d\":\n                    return (long) (numericValue * 24 * 60 * 60 * 1000);\n                default:\n                    return (long) (numericValue * 60 * 1000);\n            }\n        } catch (Exception e) {\n            log.warn(\"Could not parse session timeout '{}', using default\", timeout);\n            return 30 * 60 * 1000;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "179", "src_id": "M183", "code": "\n    public Map<String, Object> captureServerMetrics() {\n        Map<String, Object> metrics = new HashMap<>();\n        try {\n            metrics.put(\"app_version\", appVersion);\n            String deploymentType = \"JAR\";\n            if (\"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"))) {\n                deploymentType = \"EXE\";\n            } else if (isRunningInDocker()) {\n                deploymentType = \"DOCKER\";\n            }\n            metrics.put(\"deployment_type\", deploymentType);\n            metrics.put(\"mounted_config_dir\", configDirMounted);\n            metrics.put(\"os_name\", System.getProperty(\"os.name\"));\n            metrics.put(\"os_version\", System.getProperty(\"os.version\"));\n            metrics.put(\"java_version\", System.getProperty(\"java.version\"));\n            metrics.put(\"user_name\", System.getProperty(\"user.name\"));\n            metrics.put(\"user_home\", System.getProperty(\"user.home\"));\n            metrics.put(\"user_dir\", System.getProperty(\"user.dir\"));\n            metrics.put(\"cpu_cores\", Runtime.getRuntime().availableProcessors());\n            metrics.put(\"total_memory\", Runtime.getRuntime().totalMemory());\n            metrics.put(\"free_memory\", Runtime.getRuntime().freeMemory());\n            InetAddress localHost = InetAddress.getLocalHost();\n            metrics.put(\"ip_address\", localHost.getHostAddress());\n            metrics.put(\"hostname\", localHost.getHostName());\n            metrics.put(\"mac_address\", getMacAddress());\n            metrics.put(\"jvm_vendor\", System.getProperty(\"java.vendor\"));\n            metrics.put(\"jvm_version\", System.getProperty(\"java.vm.version\"));\n            metrics.put(\"system_language\", System.getProperty(\"user.language\"));\n            metrics.put(\"system_country\", System.getProperty(\"user.country\"));\n            metrics.put(\"timezone\", TimeZone.getDefault().getID());\n            metrics.put(\"locale\", Locale.getDefault().toString());\n            File root = new File(\".\");\n            metrics.put(\"total_disk_space\", root.getTotalSpace());\n            metrics.put(\"free_disk_space\", root.getFreeSpace());\n            metrics.put(\"process_id\", ProcessHandle.current().pid());\n            RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n            metrics.put(\"jvm_uptime_ms\", runtimeMXBean.getUptime());\n            metrics.put(\"jvm_start_time\", runtimeMXBean.getStartTime());\n            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n            metrics.put(\"heap_memory_usage\", memoryMXBean.getHeapMemoryUsage().getUsed());\n            metrics.put(\"non_heap_memory_usage\", memoryMXBean.getNonHeapMemoryUsage().getUsed());\n            OperatingSystemMXBean osMXBean = ManagementFactory.getOperatingSystemMXBean();\n            metrics.put(\"system_load_average\", osMXBean.getSystemLoadAverage());\n            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n            metrics.put(\"thread_count\", threadMXBean.getThreadCount());\n            metrics.put(\"daemon_thread_count\", threadMXBean.getDaemonThreadCount());\n            metrics.put(\"peak_thread_count\", threadMXBean.getPeakThreadCount());\n            for (GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n                metrics.put(\"gc_\" + gcBean.getName() + \"_count\", gcBean.getCollectionCount());\n                metrics.put(\"gc_\" + gcBean.getName() + \"_time\", gcBean.getCollectionTime());\n            }\n            metrics.put(\"network_interfaces\", getNetworkInterfacesInfo());\n            boolean isDocker = isRunningInDocker();\n            if (isDocker) {\n                metrics.put(\"docker_metrics\", getDockerMetrics());\n            }\n            metrics.put(\"application_properties\", captureApplicationProperties());\n            if (userService != null) {\n                metrics.put(\"total_users_created\", userService.getTotalUsersCount());\n            }\n        } catch (Exception e) {\n            metrics.put(\"error\", e.getMessage());\n        }\n        return metrics;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "180", "src_id": "M483", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/filter-page-count\")\n    @Operation(\n            summary = \"Checks if a PDF is greater, less or equal to a setPageCount\",\n            description = \"Input:PDF Output:Boolean Type:SISO\")\n    public ResponseEntity<byte[]> pageCount(@ModelAttribute final PDFComparisonAndCount request)\n            throws IOException, InterruptedException {\n        final MultipartFile inputFile = request.getFileInput();\n        final int pageCount = request.getPageCount();\n        final String comparator = request.getComparator();\n\n        try (final PDDocument document = pdfDocumentFactory.load(inputFile)) {\n            final int actualPageCount = document.getNumberOfPages();\n            \n            final boolean valid = switch (comparator) {\n                case \"Greater\" -> actualPageCount > pageCount;\n                case \"Equal\" -> actualPageCount == pageCount;\n                case \"Less\" -> actualPageCount < pageCount;\n                default -> throw ExceptionUtils.createInvalidArgumentException(\"comparator\", comparator);\n            };\n\n            return valid ? WebResponseUtils.multiPartFileToWebResponse(inputFile) : null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "181", "src_id": "M602", "code": "\n    @PostMapping(value = \"/document-properties\", consumes = \"multipart/form-data\")\n    @Operation(\n            summary = \"Get PDF document properties\",\n            description = \"Returns title, author, subject, etc. Input:PDF Output:JSON Type:SISO\")\n    public Map<String, String> getDocumentProperties(@ModelAttribute final PDFFile file)\n            throws IOException {\n        try (final PDDocument document = pdfDocumentFactory.load(file.getFileInput(), true)) {\n            final PDDocumentInformation info = document.getDocumentInformation();\n            return Map.of(\n                \"title\", info.getTitle(),\n                \"author\", info.getAuthor(),\n                \"subject\", info.getSubject(),\n                \"keywords\", info.getKeywords(),\n                \"creator\", info.getCreator(),\n                \"producer\", info.getProducer(),\n                \"creationDate\", info.getCreationDate().toString(),\n                \"modificationDate\", info.getModificationDate().toString()\n            );\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "182", "src_id": "M581", "code": "\n    public List<PDDocument> splitPdfPages(\n            final PDDocument document, \n            final int horizontalDivisions, \n            final int verticalDivisions) throws IOException {\n        \n        final List<PDDocument> splitDocuments = new ArrayList<>();\n\n        for (final PDPage originalPage : document.getPages()) {\n            final PDRectangle originalMediaBox = originalPage.getMediaBox();\n            final float width = originalMediaBox.getWidth();\n            final float height = originalMediaBox.getHeight();\n            final float subPageWidth = width / horizontalDivisions;\n            final float subPageHeight = height / verticalDivisions;\n\n            final LayerUtility layerUtility = new LayerUtility(document);\n\n            for (int i = 0; i < horizontalDivisions; i++) {\n                for (int j = 0; j < verticalDivisions; j++) {\n                    final PDDocument subDoc = new PDDocument();\n                    final PDPage subPage = new PDPage(new PDRectangle(subPageWidth, subPageHeight));\n                    subDoc.addPage(subPage);\n\n                    final PDFormXObject form = layerUtility.importPageAsForm(\n                        document, document.getPages().indexOf(originalPage));\n                    \n                    try (final PDPageContentStream contentStream = new PDPageContentStream(\n                            subDoc, subPage, AppendMode.APPEND, true, true)) {\n                        final float translateX = -subPageWidth * i;\n                        final float translateY = -subPageHeight * (verticalDivisions - 1 - j);\n                        \n                        contentStream.saveGraphicsState();\n                        contentStream.addRect(0, 0, subPageWidth, subPageHeight);\n                        contentStream.clip();\n                        contentStream.transform(new Matrix(1, 0, 0, 1, translateX, translateY));\n                        contentStream.drawForm(form);\n                        contentStream.restoreGraphicsState();\n                    }\n\n                    splitDocuments.add(subDoc);\n                }\n            }\n        }\n        return splitDocuments;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "183", "src_id": "M808", "code": "\n    public boolean isEndpointEnabled(final String endpoint) {\n        final String original = endpoint;\n        final String endpointToCheck = endpoint.startsWith(\"/\") \n            ? endpoint.substring(1) \n            : endpoint;\n\n        // Rule 1: Explicit flag wins\n        final Boolean explicitStatus = endpointStatuses.get(endpointToCheck);\n        if (Boolean.FALSE.equals(explicitStatus)) {\n            log.debug(\"isEndpointEnabled('{}') -> false (explicitly disabled)\", original);\n            return false;\n        }\n\n        // Rule 2: Functional-group override\n        for (final String group : endpointGroups.keySet()) {\n            if (disabledGroups.contains(group) \n                    && endpointGroups.get(group).contains(endpointToCheck)\n                    && !isToolGroup(group)) {\n                log.debug(\n                    \"isEndpointEnabled('{}') -> false (functional group '{}' disabled)\",\n                    original, group);\n                return false;\n            }\n        }\n\n        // Rule 3: Tool-group fallback\n        final Set<String> alternatives = endpointAlternatives.get(endpointToCheck);\n        if (alternatives != null && !alternatives.isEmpty()) {\n            final boolean hasEnabledToolGroup = alternatives.stream()\n                .anyMatch(toolGroup -> !disabledGroups.contains(toolGroup));\n            log.debug(\n                \"isEndpointEnabled('{}') -> {} (tool groups check)\",\n                original, hasEnabledToolGroup);\n            return hasEnabledToolGroup;\n        }\n\n        // Rule 4: Single-dependency check\n        for (final String group : endpointGroups.keySet()) {\n            if (isToolGroup(group)\n                    && disabledGroups.contains(group)\n                    && endpointGroups.get(group).contains(endpointToCheck)) {\n                log.debug(\n                    \"isEndpointEnabled('{}') -> false (single tool group '{}' disabled, no alternatives)\",\n                    original, group);\n                return false;\n            }\n        }\n\n        // Default\n        final boolean enabled = !Boolean.FALSE.equals(explicitStatus);\n        log.debug(\"isEndpointEnabled('{}') -> {} (default)\", original, enabled);\n        return enabled;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "184", "src_id": "M456", "code": "\n    private void setupLoadHandler() {\n        final long initStartTime = System.currentTimeMillis();\n        log.info(\"Setting up load handler at: {}\", initStartTime);\n\n        client.addLoadHandler(new CefLoadHandlerAdapter() {\n            @Override\n            public void onLoadingStateChange(\n                    final CefBrowser browser,\n                    final boolean isLoading,\n                    final boolean canGoBack,\n                    final boolean canGoForward) {\n                log.debug(\n                    \"Loading state change - isLoading: {}, canGoBack: {}, canGoForward: {},\"\n                    + \" browserInitialized: {}, Time elapsed: {}ms\",\n                    isLoading, canGoBack, canGoForward, browserInitialized,\n                    System.currentTimeMillis() - initStartTime);\n\n                if (!isLoading && !browserInitialized) {\n                    log.info(\n                        \"Browser finished loading, preparing to initialize UI components\");\n                    browserInitialized = true;\n                    SwingUtilities.invokeLater(() -> initUI(browser));\n                }\n            }\n        });\n    }\n\n    private void initUI(final CefBrowser browser) {\n        try {\n            if (loadingWindow == null) return;\n            \n            log.info(\"Starting UI initialization sequence\");\n            loadingWindow.setVisible(false);\n            loadingWindow.dispose();\n            loadingWindow = null;\n            log.info(\"Loading window disposed\");\n\n            // Reconfigure main frame\n            frame.setVisible(false);\n            frame.dispose();\n            frame.setOpacity(1.0f);\n            frame.setUndecorated(false);\n            frame.pack();\n            frame.setSize(UIScaling.scaleWidth(1280), UIScaling.scaleHeight(800));\n            frame.setLocationRelativeTo(null);\n            log.debug(\"Frame reconfigured\");\n\n            // Show main frame\n            frame.setVisible(true);\n            frame.requestFocus();\n            frame.toFront();\n            log.info(\"Main frame displayed and focused\");\n\n            // Schedule browser focus\n            final Timer focusTimer = new Timer(100, e -> {\n                try {\n                    browser.getUIComponent().requestFocus();\n                    log.info(\"Browser component focused\");\n                } catch (final Exception ex) {\n                    log.error(\"Error focusing browser\", ex);\n                }\n            });\n            focusTimer.setRepeats(false);\n            focusTimer.start();\n\n        } catch (final Exception e) {\n            log.error(\"Error during UI initialization\", e);\n            cleanupUI();\n        }\n    }\n\n    private void cleanupUI() {\n        if (loadingWindow != null) {\n            loadingWindow.dispose();\n            loadingWindow = null;\n        }\n        if (frame != null) {\n            frame.setVisible(true);\n            frame.requestFocus();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "185", "src_id": "M577", "code": "\n    private void processWithTesseract(\n            @NonNull final List<String> selectedLanguages,\n            @NonNull final String ocrType,\n            @NonNull final Path tempInputFile,\n            @NonNull final Path tempOutputFile) throws IOException, InterruptedException {\n        \n        try (final TempDirectory tempDir = new TempDirectory(tempFileManager)) {\n            final File tempOutputDir = new File(tempDir.getPath().toFile(), \"output\");\n            final File tempImagesDir = new File(tempDir.getPath().toFile(), \"images\");\n            final File finalOutputFile = new File(tempDir.getPath().toFile(), \"final_output.pdf\");\n\n            tempOutputDir.mkdirs();\n            tempImagesDir.mkdirs();\n\n            final PDFMergerUtility merger = new PDFMergerUtility();\n            merger.setDestinationFileName(finalOutputFile.toString());\n\n            try (final PDDocument document = pdfDocumentFactory.load(tempInputFile.toFile())) {\n                final PDFRenderer pdfRenderer = new PDFRenderer(document);\n                final int pageCount = document.getNumberOfPages();\n\n                for (int pageNum = 0; pageNum < pageCount; pageNum++) {\n                    final PDPage page = document.getPage(pageNum);\n                    final boolean hasText = checkForText(page);\n                    final boolean shouldOcr = determineOcrNeed(ocrType, hasText);\n                    final File pageOutputPath = new File(\n                        tempOutputDir, String.format(\"page_%d.pdf\", pageNum));\n\n                    if (shouldOcr) {\n                        ocrPage(\n                            pdfRenderer, pageNum, selectedLanguages, \n                            tempImagesDir, tempOutputDir, merger, pageOutputPath);\n                    } else {\n                        saveOriginalPage(page, merger, pageOutputPath);\n                    }\n                }\n            }\n\n            merger.mergeDocuments(null);\n            Files.copy(\n                finalOutputFile.toPath(), tempOutputFile,\n                StandardCopyOption.REPLACE_EXISTING);\n        }\n    }\n\n    private boolean checkForText(final PDPage page) throws IOException {\n        try (final PDDocument tempDoc = new PDDocument()) {\n            tempDoc.addPage(page);\n            return !new PDFTextStripper().getText(tempDoc).trim().isEmpty();\n        }\n    }\n\n    private boolean determineOcrNeed(final String ocrType, final boolean hasText) {\n        return switch (ocrType) {\n            case \"skip-text\" -> !hasText;\n            case \"force-ocr\" -> true;\n            default -> true;\n        };\n    }\n\n    private void ocrPage(\n            final PDFRenderer pdfRenderer,\n            final int pageNum,\n            final List<String> selectedLanguages,\n            final File tempImagesDir,\n            final File tempOutputDir,\n            final PDFMergerUtility merger,\n            final File pageOutputPath) throws IOException, InterruptedException {\n        \n        final BufferedImage image = pdfRenderer.renderImageWithDPI(pageNum, 300);\n        final File imagePath = new File(tempImagesDir, String.format(\"page_%d.png\", pageNum));\n        ImageIO.write(image, \"png\", imagePath);\n\n        final List<String> command = List.of(\n            \"tesseract\",\n            imagePath.toString(),\n            new File(tempOutputDir, String.format(\"page_%d\", pageNum)).toString(),\n            \"-l\", String.join(\"+\", selectedLanguages),\n            \"pdf\"\n        );\n\n        final ProcessExecutorResult result = ProcessExecutor.getInstance(\n            ProcessExecutor.Processes.TESSERACT).runCommandWithOutputHandling(command);\n        \n        if (result.getRc() != 0) {\n            throw ExceptionUtils.createRuntimeException(\n                \"error.commandFailed\",\n                \"{0} command failed with exit code: {1}\",\n                null, \"Tesseract\", result.getRc());\n        }\n        merger.addSource(pageOutputPath);\n    }\n\n    private void saveOriginalPage(\n            final PDPage page,\n            final PDFMergerUtility merger,\n            final File pageOutputPath) throws IOException {\n        try (final PDDocument pageDoc = new PDDocument()) {\n            pageDoc.addPage(page);\n            pageDoc.save(pageOutputPath);\n            merger.addSource(pageOutputPath);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "186", "src_id": "M29", "code": "\n    private boolean processJWTLicensePayload(\n            @NonNull final String payload, \n            @NonNull final LicenseContext context) {\n        try {\n            log.info(\"Processing license payload: {}\", payload);\n            final JSONObject licenseData = new JSONObject(payload);\n\n            JSONObject licenseObj = licenseData.optJSONObject(\"license\");\n            if (licenseObj == null) {\n                final String id = licenseData.optString(\"id\", null);\n                if (id == null) {\n                    log.error(\"License data not found in payload\");\n                    return false;\n                }\n                licenseObj = licenseData;\n            }\n\n            final String licenseId = licenseObj.optString(\"id\", \"unknown\");\n            log.info(\"Processing license with ID: {}\", licenseId);\n\n            processLicenseAttributes(context, licenseObj);\n            processPolicyInformation(licenseData, context);\n\n            return true;\n        } catch (final Exception e) {\n            log.error(\"Error processing license payload: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n    private void processLicenseAttributes(\n            final LicenseContext context, \n            final JSONObject licenseObj) {\n        context.isFloatingLicense = licenseObj.optBoolean(\"floating\", false);\n        context.maxMachines = licenseObj.optInt(\"maxMachines\", 1);\n        \n        if (context.isFloatingLicense) {\n            log.info(\n                \"Detected floating license with max machines: {}\", \n                context.maxMachines);\n        }\n\n        final String expiryStr = licenseObj.optString(\"expiry\", null);\n        if (expiryStr != null && !\"null\".equals(expiryStr)) {\n            final Instant expiry = Instant.parse(expiryStr);\n            if (Instant.now().isAfter(expiry)) {\n                log.error(\"License has expired on {}\", expiryStr);\n                throw new LicenseExpiredException();\n            }\n            log.info(\"License valid until {}\", expiryStr);\n        } else {\n            log.info(\"License has no expiration date\");\n        }\n    }\n\n    private void processPolicyInformation(\n            final JSONObject licenseData, \n            final LicenseContext context) {\n        \n        final JSONObject accountObj = licenseData.optJSONObject(\"account\");\n        if (accountObj != null) {\n            final String accountId = accountObj.optString(\"id\", \"unknown\");\n            log.info(\"License belongs to account: {}\", accountId);\n            if (!ACCOUNT_ID.equals(accountId)) {\n                log.warn(\"License account ID does not match expected account ID\");\n            }\n        }\n\n        final JSONObject policyObj = licenseData.optJSONObject(\"policy\");\n        if (policyObj == null) return;\n\n        final String policyId = policyObj.optString(\"id\", \"unknown\");\n        log.info(\"License uses policy: {}\", policyId);\n\n        // Policy settings take precedence\n        final boolean policyFloating = policyObj.optBoolean(\"floating\", false);\n        final int policyMaxMachines = policyObj.optInt(\"maxMachines\", 1);\n        \n        if (policyFloating) {\n            context.isFloatingLicense = true;\n            context.maxMachines = policyMaxMachines;\n            log.info(\n                \"Policy defines floating license with max machines: {}\", \n                context.maxMachines);\n        }\n\n        final int users = policyObj.optInt(\"users\", 1);\n        context.isEnterpriseLicense = policyObj.optBoolean(\"isEnterprise\", false);\n        applicationProperties.getPremium().setMaxUsers(\n            users > 0 ? users : getUsersFromMetadata(policyObj));\n    }\n\n    private int getUsersFromMetadata(final JSONObject policyObj) {\n        final Object metadataObj = policyObj.opt(\"metadata\");\n        if (!(metadataObj instanceof JSONObject)) return 1;\n        \n        final JSONObject metadata = (JSONObject) metadataObj;\n        final int users = metadata.optInt(\"users\", 1);\n        context.isEnterpriseLicense = metadata.optBoolean(\"isEnterprise\", false);\n        log.info(\"License allows for {} users (from metadata)\", users);\n        return users;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "187", "src_id": "M557", "code": "\n    @PostMapping(value = \"/add-page-numbers\", consumes = \"multipart/form-data\")\n    @Operation(\n            summary = \"Add page numbers to a PDF document\",\n            description = \"This operation takes an input PDF file and adds page numbers to it.\"\n                    + \" Input:PDF Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> addPageNumbers(\n            @ModelAttribute final AddPageNumbersRequest request) throws IOException {\n        \n        final MultipartFile file = request.getFileInput();\n        final String customMargin = request.getCustomMargin();\n        final int position = request.getPosition();\n        int pageNumber = request.getStartingNumber();\n        String pagesToNumber = request.getPagesToNumber();\n        String customText = request.getCustomText();\n        final float fontSize = request.getFontSize();\n        final String fontType = request.getFontType();\n\n        if (pagesToNumber == null || pagesToNumber.isEmpty()) {\n            pagesToNumber = \"all\";\n        }\n        if (customText == null || customText.isEmpty()) {\n            customText = \"{n}\";\n        }\n\n        try (final PDDocument document = pdfDocumentFactory.load(file)) {\n            final float marginFactor = determineMarginFactor(customMargin);\n            final List<Integer> pagesToNumberList = GeneralUtils.parsePageList(\n                pagesToNumber.split(\",\"), document.getNumberOfPages());\n\n            for (final int i : pagesToNumberList) {\n                addPageNumber(\n                    document, document.getPage(i), position, pageNumber++, \n                    file.getOriginalFilename(), customText, fontSize, \n                    fontType, marginFactor);\n            }\n\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            document.save(baos);\n            return WebResponseUtils.bytesToWebResponse(\n                baos.toByteArray(),\n                Filenames.toSimpleFileName(file.getOriginalFilename())\n                    .replaceFirst(\"[.][^.]+$\", \"\") + \"_numbersAdded.pdf\",\n                MediaType.APPLICATION_PDF);\n        }\n    }\n\n    private float determineMarginFactor(final String customMargin) {\n        return switch (customMargin.toLowerCase()) {\n            case \"small\" -> 0.02f;\n            case \"large\" -> 0.05f;\n            case \"x-large\" -> 0.075f;\n            case \"medium\", default -> 0.035f;\n        };\n    }\n\n    private void addPageNumber(\n            final PDDocument document,\n            final PDPage page,\n            final int position,\n            final int pageNumber,\n            final String originalFilename,\n            final String customText,\n            final float fontSize,\n            final String fontType,\n            final float marginFactor) throws IOException {\n        \n        final PDRectangle pageSize = page.getMediaBox();\n        final String text = customText\n            .replace(\"{n}\", String.valueOf(pageNumber))\n            .replace(\"{total}\", String.valueOf(document.getNumberOfPages()))\n            .replace(\n                \"{filename}\", \n                Filenames.toSimpleFileName(originalFilename).replaceFirst(\"[.][^.]+$\", \"\"));\n        \n        final PDType1Font currentFont = switch (fontType.toLowerCase()) {\n            case \"courier\" -> new PDType1Font(Standard14Fonts.FontName.COURIER);\n            case \"times\" -> new PDType1Font(Standard14Fonts.FontName.TIMES_ROMAN);\n            default -> new PDType1Font(Standard14Fonts.FontName.HELVETICA);\n        };\n\n        final Point2D.Float point = calculateTextPosition(position, pageSize, marginFactor, text, currentFont, fontSize);\n\n        try (final PDPageContentStream contentStream = new PDPageContentStream(\n                document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {\n            contentStream.beginText();\n            contentStream.setFont(currentFont, fontSize);\n            contentStream.newLineAtOffset(point.x, point.y);\n            contentStream.showText(text);\n            contentStream.endText();\n        }\n    }\n\n    private Point2D.Float calculateTextPosition(\n            final int position,\n            final PDRectangle pageSize,\n            final float marginFactor,\n            final String text,\n            final PDType1Font font,\n            final float fontSize) {\n        \n        if (position == 5) { // Center position\n            final float textWidth = font.getStringWidth(text) / 1000 * fontSize;\n            final float ascent = font.getFontDescriptor().getAscent() / 1000 * fontSize;\n            final float descent = font.getFontDescriptor().getDescent() / 1000 * fontSize;\n            return new Point2D.Float(\n                pageSize.getLowerLeftX() + (pageSize.getWidth() - textWidth) / 2,\n                pageSize.getLowerLeftY() + (pageSize.getHeight() - (ascent + descent)) / 2\n            );\n        }\n\n        final int xGroup = (position - 1) % 3;\n        final int yGroup = 2 - (position - 1) / 3;\n\n        final float x = switch (xGroup) {\n            case 0 -> pageSize.getLowerLeftX() + marginFactor * pageSize.getWidth();\n            case 1 -> pageSize.getLowerLeftX() + pageSize.getWidth() / 2;\n            default -> pageSize.getUpperRightX() - marginFactor * pageSize.getWidth();\n        };\n\n        final float y = switch (yGroup) {\n            case 0 -> pageSize.getLowerLeftY() + marginFactor * pageSize.getHeight();\n            case 1 -> pageSize.getLowerLeftY() + pageSize.getHeight() / 2;\n            default -> pageSize.getUpperRightY() - marginFactor * pageSize.getHeight();\n        };\n\n        return new Point2D.Float(x, y);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "188", "src_id": "M193", "code": "\n    public int calculateDynamicQueueCapacity(\n            final int baseCapacity, \n            final int minCapacity) {\n        final ResourceMetrics metrics = latestMetrics.get();\n        final ResourceStatus status = currentStatus.get();\n\n        double capacityFactor = switch (status) {\n            case OK -> 1.0;\n            case WARNING -> 0.6;\n            case CRITICAL -> 0.3;\n        };\n\n        if (metrics.memoryUsage > 0.8) {\n            capacityFactor *= 0.5;\n        }\n\n        final int capacity = (int) Math.max(\n            minCapacity, Math.ceil(baseCapacity * capacityFactor));\n        \n        log.debug(\n            \"Dynamic queue capacity: {} (base: {}, factor: {:.2f}, status: {})\",\n            capacity, baseCapacity, capacityFactor, status);\n        \n        return capacity;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "189", "src_id": "M141", "code": "\n    public StreamCacheCreateFunction getStreamCacheFunction(final long contentSize) {\n        final long maxMemory = Runtime.getRuntime().maxMemory();\n        final long totalMemory = Runtime.getRuntime().totalMemory();\n        final long freeMemory = Runtime.getRuntime().freeMemory();\n        final long usedMemory = totalMemory - freeMemory;\n        final double freeMemoryPercent = (double) (maxMemory - usedMemory) / maxMemory * 100;\n        final long actualFreeMemory = maxMemory - usedMemory;\n\n        log.debug(\n            \"Memory status - Free: {}MB ({}%), Used: {}MB, Max: {}MB\",\n            actualFreeMemory / (1024 * 1024),\n            String.format(\"%.2f\", freeMemoryPercent),\n            usedMemory / (1024 * 1024),\n            maxMemory / (1024 * 1024));\n\n        if (freeMemoryPercent < MIN_FREE_MEMORY_PERCENTAGE\n                || actualFreeMemory < MIN_FREE_MEMORY_BYTES) {\n            log.debug(\n                \"Low memory detected ({}%), forcing file-based cache\",\n                String.format(\"%.2f\", freeMemoryPercent));\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupTempFileOnly());\n        }\n\n        return contentSize < SMALL_FILE_THRESHOLD \n            ? handleSmallFile(contentSize)\n            : handleLargeFile(contentSize);\n    }\n\n    private StreamCacheCreateFunction handleSmallFile(final long contentSize) {\n        log.debug(\"Using memory-only cache for small document ({}KB)\", contentSize / 1024);\n        return IOUtils.createMemoryOnlyStreamCache();\n    }\n\n    private StreamCacheCreateFunction handleLargeFile(final long contentSize) {\n        if (contentSize < LARGE_FILE_THRESHOLD) {\n            log.debug(\n                \"Using mixed memory/file cache for medium document ({}MB)\",\n                contentSize / (1024 * 1024));\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupMixed(LARGE_FILE_USAGE));\n        }\n        log.debug(\"Using file-based cache for large document\");\n        return createScratchFileCacheFunction(MemoryUsageSetting.setupTempFileOnly());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "190", "src_id": "M345", "code": "\n@Override\npublic void onStopTrackingTouch(final SeekBar seekBar) {\n    if (DEBUG) {\n        Log.d(TAG, \"onStopTrackingTouch() called with: seekBar = [\" + seekBar + \"]\");\n    }\n\n    player.seekTo(seekBar.getProgress());\n    if (player.getExoPlayer().getDuration() == seekBar.getProgress()) {\n        player.getExoPlayer().play();\n    }\n\n    binding.playbackCurrentTime.setText(getTimeString(seekBar.getProgress()));\n    animate(binding.currentDisplaySeek, false, 200, AnimationType.SCALE_AND_ALPHA);\n    animate(binding.currentSeekbarPreviewThumbnail, false, 200, AnimationType.SCALE_AND_ALPHA);\n\n    if (player.getCurrentState() == STATE_PAUSED_SEEK) {\n        player.changeState(STATE_BUFFERING);\n    }\n    if (!player.isProgressLoopRunning()) {\n        player.startProgressLoop();\n    }\n\n    showControlsThenHide();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "191", "src_id": "M374", "code": "\n@Override\npublic boolean onMenuItemClick(@NonNull final MenuItem menuItem) {\n    if (DEBUG) {\n        Log.d(TAG, \"onMenuItemClick() called with: \"\n                + \"menuItem = [\" + menuItem + \"], \"\n                + \"menuItem.getItemId = [\" + menuItem.getItemId() + \"]\");\n    }\n\n    if (menuItem.getGroupId() == POPUP_MENU_ID_QUALITY) {\n        onQualityItemClick(menuItem);\n        return true;\n    } else if (menuItem.getGroupId() == POPUP_MENU_ID_AUDIO_TRACK) {\n        onAudioTrackItemClick(menuItem);\n        return true;\n    } else if (menuItem.getGroupId() == POPUP_MENU_ID_PLAYBACK_SPEED) {\n        final int speedIndex = menuItem.getItemId();\n        final float speed = PLAYBACK_SPEEDS[speedIndex];\n\n        player.setPlaybackSpeed(speed);\n        binding.playbackSpeed.setText(formatSpeed(speed));\n    }\n\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "192", "src_id": "M684", "code": "\nprivate void monitorSubscription(final ChannelInfo info) {\n    final Consumer<Throwable> onError = (final Throwable throwable) -> {\n        animate(binding.channelSubscribeButton, false, 100);\n        showSnackBarError(new ErrorInfo(throwable, UserAction.SUBSCRIPTION_GET,\n                \"Get subscription status\", currentInfo));\n    };\n\n    final Observable<List<SubscriptionEntity>> observable = subscriptionManager\n            .subscriptionTable()\n            .getSubscriptionFlowable(info.getServiceId(), info.getUrl())\n            .toObservable();\n\n    disposables.add(observable\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(getSubscribeUpdateMonitor(info), onError));\n\n    disposables.add(observable\n            .map(List::isEmpty)\n            .distinctUntilChanged()\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(isEmpty -> updateSubscribeButton(!isEmpty), onError));\n\n    disposables.add(observable\n            .map(List::isEmpty)\n            .distinctUntilChanged()\n            .skip(1)\n            .filter(x -> NotificationHelper.areNewStreamsNotificationsEnabled(requireContext()))\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(isEmpty -> {\n                if (!isEmpty) {\n                    showNotifySnackbar();\n                }\n            }, onError));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "193", "src_id": "M754", "code": "\nprivate void runOnVisible(final Consumer<AppCompatActivity> runnable) {\n    getActivityContext().ifPresentOrElse(context -> {\n        if (getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED)) {\n            context.runOnUiThread(() -> {\n                runnable.accept(context);\n                inFlight(false);\n            });\n        } else {\n            getLifecycle().addObserver(new DefaultLifecycleObserver() {\n                @Override\n                public void onResume(@NonNull final LifecycleOwner owner) {\n                    getLifecycle().removeObserver(this);\n                    getActivityContext().ifPresentOrElse(ctx ->\n                            ctx.runOnUiThread(() -> {\n                                runnable.accept(ctx);\n                                inFlight(false);\n                            }),\n                            () -> inFlight(false)\n                    );\n                }\n            });\n            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q\n                    && !context.isChangingConfigurations()) {\n                final Intent i = new Intent(context, RouterActivity.class);\n                i.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                startActivity(i);\n            }\n        }\n    }, () -> inFlight(false));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "194", "src_id": "M950", "code": "\npublic static void showMetaInfoInTextView(@Nullable final List<MetaInfo> metaInfos,\n        final TextView metaInfoTextView,\n        final View metaInfoSeparator,\n        final CompositeDisposable disposables) {\n    final Context context = metaInfoTextView.getContext();\n    if (metaInfos == null || metaInfos.isEmpty()\n            || !PreferenceManager.getDefaultSharedPreferences(context).getBoolean(\n            context.getString(R.string.show_meta_info_key), true)) {\n        metaInfoTextView.setVisibility(View.GONE);\n        metaInfoSeparator.setVisibility(View.GONE);\n    } else {\n        final StringBuilder stringBuilder = new StringBuilder();\n        for (final MetaInfo metaInfo : metaInfos) {\n            if (!isNullOrEmpty(metaInfo.getTitle())) {\n                stringBuilder.append(\"<b>\").append(metaInfo.getTitle()).append(\"</b>\")\n                        .append(Localization.DOT_SEPARATOR);\n            }\n\n            String content = metaInfo.getContent().getContent().trim();\n            if (content.endsWith(\".\")) {\n                content = content.substring(0, content.length() - 1);\n            }\n            stringBuilder.append(content);\n\n            for (int i = 0; i < metaInfo.getUrls().size(); i++) {\n                if (i == 0) {\n                    stringBuilder.append(Localization.DOT_SEPARATOR);\n                } else {\n                    stringBuilder.append(\"<br/><br/>\");\n                }\n\n                stringBuilder\n                        .append(\"<a href=\\\"\").append(metaInfo.getUrls().get(i)).append(\"\\\">\")\n                        .append(capitalizeIfAllUppercase(metaInfo.getUrlTexts().get(i).trim()))\n                        .append(\"</a>\");\n            }\n        }\n\n        metaInfoSeparator.setVisibility(View.VISIBLE);\n        TextLinkifier.fromHtml(metaInfoTextView, stringBuilder.toString(),\n                HtmlCompat.FROM_HTML_SEPARATOR_LINE_BREAK_HEADING, null, null, disposables,\n                SET_LINK_MOVEMENT_METHOD);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "195", "src_id": "M257", "code": "\n@Override\npublic void onPlaybackSynchronize(@NonNull final PlayQueueItem item, final boolean wasBlocked) {\n    if (DEBUG) {\n        Log.d(TAG, \"Playback - onPlaybackSynchronize(was blocked: \" + wasBlocked\n                + \") called with item=[\" + item.getTitle() + \"], url=[\" + item.getUrl() + \"]\");\n    }\n    if (exoPlayerIsNull() || playQueue == null || currentItem == item) {\n        return;\n    }\n\n    final int playQueueIndex = playQueue.indexOf(item);\n    final int playlistIndex = simpleExoPlayer.getCurrentMediaItemIndex();\n    final int playlistSize = simpleExoPlayer.getCurrentTimeline().getWindowCount();\n    final boolean removeThumbnailBeforeSync = currentItem == null\n            || currentItem.getServiceId() != item.getServiceId()\n            || !currentItem.getUrl().equals(item.getUrl());\n\n    currentItem = item;\n\n    if (playQueueIndex != playQueue.getIndex()) {\n        Log.e(TAG, \"Playback - Play Queue may be not in sync: item index=[\"\n                + playQueueIndex + \"], \" + \"queue index=[\" + playQueue.getIndex() + \"]\");\n    } else if ((playlistSize > 0 && playQueueIndex >= playlistSize) || playQueueIndex < 0) {\n        Log.e(TAG, \"Playback - Trying to seek to invalid index=[\" + playQueueIndex\n                + \"] with playlist length=[\" + playlistSize + \"]\");\n    } else if (wasBlocked || playlistIndex != playQueueIndex || !isPlaying()) {\n        if (DEBUG) {\n            Log.d(TAG, \"Playback - Rewinding to correct index=[\" + playQueueIndex + \"], \"\n                    + \"from=[\" + playlistIndex + \"], size=[\" + playlistSize + \"].\");\n        }\n\n        if (removeThumbnailBeforeSync) {\n            onThumbnailLoaded(null);\n        }\n\n        if (item.getRecoveryPosition() != PlayQueueItem.RECOVERY_UNSET) {\n            simpleExoPlayer.seekTo(playQueueIndex, item.getRecoveryPosition());\n            playQueue.unsetRecovery(playQueueIndex);\n        } else {\n            simpleExoPlayer.seekToDefaultPosition(playQueueIndex);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "196", "src_id": "M887", "code": "\n@Nullable\nstatic String choosePreferredImage(@NonNull final List<Image> images,\n        final PreferredImageQuality nonNoneQuality) {\n    final double widthOverHeight = images.stream()\n            .filter(image -> image.getHeight() != HEIGHT_UNKNOWN\n                    && image.getWidth() != WIDTH_UNKNOWN)\n            .mapToDouble(image -> ((double) image.getWidth()) / image.getHeight())\n            .findFirst()\n            .orElse(1.0);\n\n    final Image.ResolutionLevel preferredLevel = nonNoneQuality.toResolutionLevel();\n    final Comparator<Image> initialComparator = Comparator\n            .<Image>comparingInt(i -> {\n                if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.UNKNOWN) {\n                    return 3;\n                } else if (i.getEstimatedResolutionLevel() == preferredLevel) {\n                    return 0;\n                } else if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.MEDIUM) {\n                    return 1;\n                } else {\n                    return 2;\n                }\n            })\n            .thenComparing(image ->\n                    image.getHeight() == HEIGHT_UNKNOWN && image.getWidth() == WIDTH_UNKNOWN);\n\n    final Comparator<Image> finalComparator = switch (nonNoneQuality) {\n        case NONE -> initialComparator;\n        case LOW -> initialComparator.thenComparingDouble(image -> {\n            final double pixelCount = estimatePixelCount(image, widthOverHeight);\n            return Math.abs(pixelCount - BEST_LOW_H * BEST_LOW_H * widthOverHeight);\n        });\n        case MEDIUM -> initialComparator.thenComparingDouble(image -> {\n            final double pixelCount = estimatePixelCount(image, widthOverHeight);\n            return Math.abs(pixelCount - BEST_MEDIUM_H * BEST_MEDIUM_H * widthOverHeight);\n        });\n        case HIGH -> initialComparator.thenComparingDouble(\n                i -> -estimatePixelCount(i, widthOverHeight));\n    };\n\n    return images.stream()\n            .min(finalComparator)\n            .map(Image::getUrl)\n            .orElse(null);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "197", "src_id": "M667", "code": "\nprivate void updateTabLayoutPosition() {\n    final ScrollableTabLayout tabLayout = binding.mainTabLayout;\n    final ViewPager viewPager = binding.pager;\n    final boolean bottom = mainTabsPositionBottom;\n\n    final var tabParams = (RelativeLayout.LayoutParams) tabLayout.getLayoutParams();\n    final var pagerParams = (RelativeLayout.LayoutParams) viewPager.getLayoutParams();\n\n    tabParams.removeRule(bottom ? ALIGN_PARENT_TOP : ALIGN_PARENT_BOTTOM);\n    tabParams.addRule(bottom ? ALIGN_PARENT_BOTTOM : ALIGN_PARENT_TOP);\n    pagerParams.removeRule(bottom ? BELOW : ABOVE);\n    pagerParams.addRule(bottom ? ABOVE : BELOW, R.id.main_tab_layout);\n    tabLayout.setSelectedTabIndicatorGravity(\n            bottom ? INDICATOR_GRAVITY_TOP : INDICATOR_GRAVITY_BOTTOM);\n\n    tabLayout.setLayoutParams(tabParams);\n    viewPager.setLayoutParams(pagerParams);\n\n    tabLayout.setBackgroundColor(ThemeHelper.resolveColorFromAttr(requireContext(),\n            bottom ? android.R.attr.windowBackground : R.attr.colorPrimary));\n\n    @ColorInt final int iconColor = bottom\n            ? ThemeHelper.resolveColorFromAttr(requireContext(), android.R.attr.colorAccent)\n            : Color.WHITE;\n    tabLayout.setTabRippleColor(ColorStateList.valueOf(iconColor).withAlpha(32));\n    tabLayout.setTabIconTint(ColorStateList.valueOf(iconColor));\n    tabLayout.setSelectedTabIndicatorColor(iconColor);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "198", "src_id": "M395", "code": "\n@Override\nprotected void setupElementsVisibility() {\n    binding.fullScreenButton.setVisibility(View.VISIBLE);\n    binding.screenRotationButton.setVisibility(View.GONE);\n    binding.resizeTextView.setVisibility(View.GONE);\n    binding.getRoot().findViewById(R.id.metadataView).setVisibility(View.GONE);\n    binding.queueButton.setVisibility(View.GONE);\n    binding.segmentsButton.setVisibility(View.GONE);\n    binding.moreOptionsButton.setVisibility(View.GONE);\n    binding.topControls.setOrientation(LinearLayout.HORIZONTAL);\n    binding.primaryControls.getLayoutParams().width = WRAP_CONTENT;\n    binding.secondaryControls.setAlpha(1.0f);\n    binding.secondaryControls.setVisibility(View.VISIBLE);\n    binding.secondaryControls.setTranslationY(0);\n    binding.share.setVisibility(View.GONE);\n    binding.playWithKodi.setVisibility(View.GONE);\n    binding.openInBrowser.setVisibility(View.GONE);\n    binding.switchMute.setVisibility(View.GONE);\n    binding.playerCloseButton.setVisibility(View.GONE);\n    binding.topControls.bringToFront();\n    binding.topControls.setClickable(false);\n    binding.topControls.setFocusable(false);\n    binding.bottomControls.bringToFront();\n    super.setupElementsVisibility();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "199", "src_id": "M338", "code": "\nprivate void updateEndScreenThumbnail(@Nullable final Bitmap thumbnail) {\n    if (thumbnail == null) {\n        binding.endScreen.setImageDrawable(null);\n        return;\n    }\n\n    final float endScreenHeight = calculateMaxEndScreenThumbnailHeight(thumbnail);\n    final Bitmap endScreenBitmap = BitmapCompat.createScaledBitmap(\n            thumbnail,\n            (int) (thumbnail.getWidth() / (thumbnail.getHeight() / endScreenHeight)),\n            (int) endScreenHeight,\n            null,\n            true);\n\n    if (DEBUG) {\n        Log.d(TAG, \"Thumbnail - onThumbnailLoaded() called with: \"\n                + \"currentThumbnail = [\" + thumbnail + \"], \"\n                + thumbnail.getWidth() + \"x\" + thumbnail.getHeight()\n                + \", scaled end screen height = \" + endScreenHeight\n                + \", scaled end screen width = \" + endScreenBitmap.getWidth());\n    }\n\n    binding.endScreen.setImageBitmap(endScreenBitmap);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1058", "code": "\nprivate void startMission(Intent intent) {\n    String[] urls = intent.getStringArrayExtra(EXTRA_URLS);\n    Uri path = IntentCompat.getParcelableExtra(intent, EXTRA_PATH, Uri.class);\n    Uri parentPath = IntentCompat.getParcelableExtra(intent, EXTRA_PARENT_PATH, Uri.class);\n    int threads = intent.getIntExtra(EXTRA_THREADS, 1);\n    char kind = intent.getCharExtra(EXTRA_KIND, '?');\n    String psName = intent.getStringExtra(EXTRA_POSTPROCESSING_NAME);\n    String[] psArgs = intent.getStringArrayExtra(EXTRA_POSTPROCESSING_ARGS);\n    String source = intent.getStringExtra(EXTRA_SOURCE);\n    long nearLength = intent.getLongExtra(EXTRA_NEAR_LENGTH, 0);\n    String tag = intent.getStringExtra(EXTRA_STORAGE_TAG);\n    final var recovery = IntentCompat.getParcelableArrayListExtra(\n        intent, \n        EXTRA_RECOVERY_INFO,\n        MissionRecoveryInfo.class\n    );\n    Objects.requireNonNull(recovery);\n\n    StoredFileHelper storage;\n    try {\n        storage = new StoredFileHelper(this, parentPath, path, tag);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n\n    Postprocessing ps;\n    if (psName == null) {\n        ps = null;\n    } else {\n        ps = Postprocessing.getAlgorithm(psName, psArgs);\n    }\n\n    final DownloadMission mission = new DownloadMission(urls, storage, kind, ps);\n    mission.threadCount = threads;\n    mission.source = source;\n    mission.nearLength = nearLength;\n    mission.recoveryInfo = recovery.toArray(new MissionRecoveryInfo[0]);\n\n    if (ps != null) {\n        ps.setTemporalDir(DownloadManager.pickAvailableTemporalDir(this));\n    }\n\n    handleConnectivityState(true);\n\n    mManager.startMission(mission);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1037", "code": "\npublic void pause() {\n    if (!running) {\n        return;\n    }\n\n    if (isPsRunning()) {\n        if (DEBUG) {\n            Log.w(TAG, \"pause during post-processing is not applicable.\");\n        }\n        return;\n    }\n\n    running = false;\n    notify(DownloadManagerService.MESSAGE_PAUSED);\n\n    if (init != null && init.isAlive()) {\n        init.interrupt();\n        synchronized (LOCK) {\n            resetState(false, true, ERROR_NOTHING);\n        }\n        return;\n    }\n\n    if (DEBUG && unknownLength) {\n        Log.w(TAG, \"pausing a download that can not be resumed.\");\n    }\n\n    init = null;\n    pauseThreads();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "202", "src_id": "M1081", "code": "\nvoid handleConnectivityState(NetworkState currentStatus, boolean updateOnly) {\n    if (currentStatus == mLastNetworkStatus) {\n        return;\n    }\n\n    mLastNetworkStatus = currentStatus;\n    if (currentStatus == NetworkState.Unavailable) {\n        return;\n    }\n\n    if (!mSelfMissionsControl || updateOnly) {\n        return;\n    }\n\n    boolean isMetered = mPrefMeteredDownloads \n        && mLastNetworkStatus == NetworkState.MeteredOperating;\n\n    synchronized (this) {\n        for (DownloadMission mission : mMissionsPending) {\n            if (mission.isCorrupt() || mission.isPsRunning()) {\n                continue;\n            }\n\n            if (mission.running && isMetered) {\n                mission.pause();\n            } else if (!mission.running && !isMetered && mission.enqueued) {\n                mission.start();\n                if (mPrefQueueLimit) {\n                    break;\n                }\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "203", "src_id": "M1099", "code": "\n@SuppressLint(\"DefaultLocale\")\nprivate void updateProgress(ViewHolderItem h) {\n    if (h == null || h.item == null || h.item.mission instanceof FinishedMission) {\n        return;\n    }\n\n    DownloadMission mission = (DownloadMission) h.item.mission;\n    double done = mission.done;\n    long length = mission.getLength();\n    long now = System.currentTimeMillis();\n    boolean hasError = mission.errCode != ERROR_NOTHING;\n\n    h.progress.setMarquee(\n        mission.isRecovering() \n        || !hasError && (!mission.isInitialized() || mission.unknownLength)\n    );\n\n    double progress;\n    if (mission.unknownLength) {\n        progress = Double.NaN;\n        h.progress.setProgress(0.0f);\n    } else {\n        progress = done / length;\n    }\n\n    if (hasError) {\n        h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n        h.status.setText(R.string.msg_error);\n    } else if (isNotFinite(progress)) {\n        h.status.setText(UNDEFINED_PROGRESS);\n    } else {\n        h.status.setText(String.format(\"%.2f%%\", progress * 100));\n        h.progress.setProgress(progress);\n    }\n\n    @StringRes int state;\n    String sizeStr = Utility.formatBytes(length).concat(\"  \");\n\n    if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n        h.size.setText(sizeStr);\n        return;\n    } else if (!mission.running) {\n        state = mission.enqueued ? R.string.queued : R.string.paused;\n    } else if (mission.isPsRunning()) {\n        state = R.string.post_processing;\n    } else if (mission.isRecovering()) {\n        state = R.string.recovering;\n    } else {\n        state = 0;\n    }\n\n    if (state != 0) {\n        h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n        h.resetSpeedMeasure();\n        return;\n    }\n\n    if (h.lastTimestamp < 0) {\n        h.size.setText(sizeStr);\n        h.lastTimestamp = now;\n        h.lastDone = done;\n        return;\n    }\n\n    long deltaTime = now - h.lastTimestamp;\n    double deltaDone = done - h.lastDone;\n\n    if (h.lastDone > done) {\n        h.lastDone = done;\n        h.size.setText(sizeStr);\n        return;\n    }\n\n    if (deltaDone > 0 && deltaTime > 0) {\n        float speed = (float) ((deltaDone * 1000d) / deltaTime);\n        float averageSpeed = speed;\n\n        if (h.lastSpeedIdx < 0) {\n            Arrays.fill(h.lastSpeed, speed);\n            h.lastSpeedIdx = 0;\n        } else {\n            for (int i = 0; i < h.lastSpeed.length; i++) {\n                averageSpeed += h.lastSpeed[i];\n            }\n            averageSpeed /= h.lastSpeed.length + 1.0f;\n        }\n\n        String speedStr = Utility.formatSpeed(averageSpeed);\n        String etaStr;\n\n        if (mission.unknownLength) {\n            etaStr = \"\";\n        } else {\n            long eta = (long) Math.ceil((length - done) / averageSpeed);\n            etaStr = Utility.formatBytes((long) done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n        }\n\n        h.size.setText(sizeStr.concat(etaStr).concat(speedStr));\n\n        h.lastTimestamp = now;\n        h.lastDone = done;\n        h.lastSpeed[h.lastSpeedIdx++] = speed;\n\n        if (h.lastSpeedIdx >= h.lastSpeed.length) {\n            h.lastSpeedIdx = 0;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "204", "src_id": "M852", "code": "\npublic InputStream getView(final int size) {\n    if (view == null) {\n        view = new InputStream() {\n            @Override\n            public int read() throws IOException {\n                if (viewSize < 1) {\n                    return -1;\n                }\n                final int res = DataReader.this.read();\n                if (res > 0) {\n                    viewSize--;\n                }\n                return res;\n            }\n\n            @Override\n            public int read(final byte[] buffer) throws IOException {\n                return read(buffer, 0, buffer.length);\n            }\n\n            @Override\n            public int read(final byte[] buffer, final int offset, final int count)\n                    throws IOException {\n                if (viewSize < 1) {\n                    return -1;\n                }\n\n                final int res = DataReader.this.read(\n                    buffer, \n                    offset, \n                    Math.min(viewSize, count)\n                );\n                viewSize -= res;\n\n                return res;\n            }\n\n            @Override\n            public long skip(final long amount) throws IOException {\n                if (viewSize < 1) {\n                    return 0;\n                }\n                final int res = (int) DataReader.this.skipBytes(Math.min(amount, viewSize));\n                viewSize -= res;\n\n                return res;\n            }\n\n            @Override\n            public int available() {\n                return viewSize;\n            }\n\n            @Override\n            public void close() {\n                viewSize = 0;\n            }\n\n            @Override\n            public boolean markSupported() {\n                return false;\n            }\n        };\n    }\n    viewSize = size;\n\n    return view;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "205", "src_id": "M850", "code": "\npublic int read(final byte[] buffer, final int off, final int c) throws IOException {\n    int offset = off;\n    int count = c;\n\n    if (readCount < 0) {\n        return -1;\n    }\n    int total = 0;\n\n    if (count >= readBuffer.length) {\n        if (readCount > 0) {\n            System.arraycopy(readBuffer, readOffset, buffer, offset, readCount);\n            readOffset += readCount;\n\n            offset += readCount;\n            count -= readCount;\n\n            total = readCount;\n            readCount = 0;\n        }\n        total += Math.max(stream.read(buffer, offset, count), 0);\n    } else {\n        while (count > 0 && !fillBuffer()) {\n            final int read = Math.min(readCount, count);\n            System.arraycopy(readBuffer, readOffset, buffer, offset, read);\n\n            readOffset += read;\n            readCount -= read;\n\n            offset += read;\n            count -= read;\n\n            total += read;\n        }\n    }\n\n    position += total;\n    return total;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "206", "src_id": "M803", "code": "\npublic void parse() throws IOException, NoSuchElementException {\n    if (selectedTrack > -1) {\n        return;\n    }\n\n    box = readBox(ATOM_FTYP);\n    brands = parseFtyp(box);\n    switch (brands[0]) {\n        case BRAND_DASH:\n        case BRAND_ISO5:\n            break;\n        default:\n            throw new NoSuchElementException(\n                \"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \"\n                    + boxName(brands[0])\n            );\n    }\n\n    Moov moov = null;\n    int i;\n\n    while (box.type != ATOM_MOOF) {\n        ensure(box);\n        box = readBox();\n\n        switch (box.type) {\n            case ATOM_MOOV:\n                moov = parseMoov(box);\n                break;\n            case ATOM_SIDX:\n            case ATOM_MFRA:\n                break;\n        }\n    }\n\n    if (moov == null) {\n        throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n    }\n\n    tracks = new Mp4Track[moov.trak.length];\n\n    for (i = 0; i < tracks.length; i++) {\n        tracks[i] = new Mp4Track();\n        tracks[i].trak = moov.trak[i];\n\n        if (moov.mvexTrex != null) {\n            for (final Trex mvexTrex : moov.mvexTrex) {\n                if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n                    tracks[i].trex = mvexTrex;\n                }\n            }\n        }\n\n        switch (moov.trak[i].mdia.hdlr.subType) {\n            case HANDLER_VIDE:\n                tracks[i].kind = TrackKind.Video;\n                break;\n            case HANDLER_SOUN:\n                tracks[i].kind = TrackKind.Audio;\n                break;\n            case HANDLER_SUBT:\n                tracks[i].kind = TrackKind.Subtitles;\n                break;\n            default:\n                tracks[i].kind = TrackKind.Other;\n                break;\n        }\n    }\n\n    backupBox = box;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "207", "src_id": "M1066", "code": "\nprivate void loadPendingMissions(Context ctx) {\n    File[] subs = mPendingMissionsDir.listFiles();\n\n    if (subs == null) {\n        Log.e(TAG, \"listFiles() returned null\");\n        return;\n    }\n    if (subs.length < 1) {\n        return;\n    }\n    if (DEBUG) {\n        Log.d(TAG, \"Loading pending downloads from directory: \" \n            + mPendingMissionsDir.getAbsolutePath());\n    }\n\n    File tempDir = pickAvailableTemporalDir(ctx);\n    Log.i(TAG, \"using '\" + tempDir + \"' as temporal directory\");\n\n    for (File sub : subs) {\n        if (!sub.isFile()) {\n            continue;\n        }\n        if (sub.getName().equals(\".tmp\")) {\n            continue;\n        }\n\n        DownloadMission mis = Utility.readFromFile(sub);\n        if (mis == null || mis.isFinished() || mis.hasInvalidStorage()) {\n            sub.delete();\n            continue;\n        }\n\n        mis.threads = new Thread[0];\n\n        boolean exists;\n        try {\n            mis.storage = StoredFileHelper.deserialize(mis.storage, ctx);\n            exists = !mis.storage.isInvalid() && mis.storage.existsAsFile();\n        } catch (Exception ex) {\n            Log.e(TAG, \"Failed to load the file source of \" + mis.storage.toString(), ex);\n            mis.storage.invalidate();\n            exists = false;\n        }\n\n        if (mis.isPsRunning()) {\n            if (mis.psAlgorithm.worksOnSameFile) {\n                if (exists && mis.storage.isDirect() && !mis.storage.delete()) {\n                    Log.w(TAG, \"Unable to delete incomplete download file: \" + sub.getPath());\n                }\n            }\n\n            mis.psState = 0;\n            mis.errCode = DownloadMission.ERROR_POSTPROCESSING_STOPPED;\n        } else if (!exists) {\n            tryRecover(mis);\n            if (mis.isInitialized()) {\n                mis.resetState(true, true, DownloadMission.ERROR_PROGRESS_LOST);\n            }\n        }\n\n        if (mis.psAlgorithm != null) {\n            mis.psAlgorithm.cleanupTemporalDir();\n            mis.psAlgorithm.setTemporalDir(tempDir);\n        }\n\n        mis.metadata = sub;\n        mis.maxRetry = mPrefMaxRetry;\n        mis.mHandler = mHandler;\n\n        mMissionsPending.add(mis);\n    }\n\n    if (mMissionsPending.size() > 1) {\n        Collections.sort(mMissionsPending, Comparator.comparingLong(Mission::getTimestamp));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "208", "src_id": "M1067", "code": "\nvoid startMission(DownloadMission mission) {\n    synchronized (this) {\n        mission.timestamp = System.currentTimeMillis();\n        mission.mHandler = mHandler;\n        mission.maxRetry = mPrefMaxRetry;\n\n        while (true) {\n            mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n            if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                try {\n                    if (!mission.metadata.createNewFile()) {\n                        throw new RuntimeException(\"Cant create download metadata file\");\n                    }\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                break;\n            }\n            mission.timestamp = System.currentTimeMillis();\n        }\n\n        mSelfMissionsControl = true;\n        mMissionsPending.add(mission);\n\n        Utility.writeToFile(mission.metadata, mission);\n\n        if (mission.storage == null) {\n            mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n            if (mission.errObject != null) {\n                mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n            }\n            return;\n        }\n\n        boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n        if (canDownloadInCurrentNetwork() && start) {\n            mission.start();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "209", "src_id": "M361", "code": "\nprivate static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n    try {\n        if (!isValidJakartaMailPart(part)) {\n            log.warn(\"Invalid Jakarta Mail part type: \" + part.getClass().getName());\n            return;\n        }\n\n        Class<?> partClass = part.getClass();\n        Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n        Method getContent = partClass.getMethod(\"getContent\");\n        Method getDisposition = partClass.getMethod(\"getDisposition\");\n        Method getFileName = partClass.getMethod(\"getFileName\");\n        Method getContentType = partClass.getMethod(\"getContentType\");\n        Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n        Object disposition = getDisposition.invoke(part);\n        String filename = (String) getFileName.invoke(part);\n        String contentType = (String) getContentType.invoke(part);\n\n        if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n            content.setTextBody((String) getContent.invoke(part));\n        } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n            content.setHtmlBody((String) getContent.invoke(part));\n        } else if (\"attachment\".equalsIgnoreCase((String) disposition) || (filename != null && !filename.trim().isEmpty())) {\n            content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n            if (filename != null && !filename.trim().isEmpty()) {\n                EmailAttachment attachment = new EmailAttachment();\n                attachment.setFilename(safeMimeDecode(filename));\n                attachment.setContentType(contentType);\n\n                String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n                if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                    attachment.setEmbedded(true);\n                    String contentId = contentIdHeaders[0];\n                    if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                        contentId = contentId.substring(1, contentId.length() - 1);\n                    }\n                    attachment.setContentId(contentId);\n                }\n\n                if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n                    try {\n                        Object attachmentContent = getContent.invoke(part);\n                        byte[] attachmentData = null;\n\n                        if (attachmentContent instanceof java.io.InputStream inputStream) {\n                            try {\n                                attachmentData = inputStream.readAllBytes();\n                            } catch (IOException e) {\n                                log.warn(\"Failed to read InputStream attachment\", e);\n                            }\n                        } else if (attachmentContent instanceof byte[] byteArray) {\n                            attachmentData = byteArray;\n                        } else if (attachmentContent instanceof String stringContent) {\n                            attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n                        }\n\n                        if (attachmentData != null) {\n                            long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                            long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                            if (attachmentData.length <= maxSizeBytes) {\n                                attachment.setData(attachmentData);\n                                attachment.setSizeBytes(attachmentData.length);\n                            } else if (attachment.isEmbedded()) {\n                                attachment.setData(attachmentData);\n                                attachment.setSizeBytes(attachmentData.length);\n                            } else {\n                                attachment.setSizeBytes(attachmentData.length);\n                            }\n                        }\n                    } catch (Exception e) {\n                        log.warn(\"Error extracting attachment data\", e);\n                    }\n                }\n\n                content.getAttachments().add(attachment);\n            }\n        } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n            try {\n                Object multipartContent = getContent.invoke(part);\n                Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(multipartContent)) {\n                    processMultipartAdvanced(multipartContent, content, request);\n                }\n            } catch (Exception e) {\n                log.warn(\"Error processing multipart content\", e);\n            }\n        }\n    } catch (Exception e) {\n        log.warn(\"Error processing multipart part\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "210", "src_id": "M347", "code": "\nprivate static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n    attachmentInfo.append(\"<div class=\\\"attachment-item\\\">\")\n        .append(\"<span class=\\\"attachment-icon\\\">\")\n        .append(MimeConstants.ATTACHMENT_MARKER)\n        .append(\"</span> \")\n        .append(\"<span class=\\\"attachment-name\\\">\")\n        .append(escapeHtml(filename))\n        .append(\"</span>\");\n\n    if (!contentType.isEmpty() || !encoding.isEmpty()) {\n        attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n        if (!contentType.isEmpty()) {\n            attachmentInfo.append(escapeHtml(contentType));\n        }\n        if (!encoding.isEmpty()) {\n            if (!contentType.isEmpty()) attachmentInfo.append(\", \");\n            attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n        }\n        attachmentInfo.append(\")</span>\");\n    }\n    attachmentInfo.append(\"</div>\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "211", "src_id": "M567", "code": "\n@PostMapping(value = \"/scanner-effect\", consumes = \"multipart/form-data\")\n@Operation(summary = \"Apply scanner effect to PDF\", description = \"Applies various effects to simulate a scanned document, including rotation, noise, and edge softening. Input:PDF Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> scannerEffect(@Valid @ModelAttribute ScannerEffectRequest request) throws IOException {\n    MultipartFile file = request.getFileInput();\n\n    if (!request.isAdvancedEnabled()) {\n        switch (request.getQuality()) {\n            case high -> request.applyHighQualityPreset();\n            case medium -> request.applyMediumQualityPreset();\n            case low -> request.applyLowQualityPreset();\n        }\n    }\n\n    int baseRotation = request.getRotationValue() + request.getRotate();\n    int rotateVariance = request.getRotateVariance();\n    int borderPx = request.getBorder();\n    float brightness = request.getBrightness();\n    float contrast = request.getContrast();\n    float blur = request.getBlur();\n    float noise = request.getNoise();\n    boolean yellowish = request.isYellowish();\n    int resolution = request.getResolution();\n    ScannerEffectRequest.Colorspace colorspace = request.getColorspace();\n\n    try (PDDocument document = pdfDocumentFactory.load(file)) {\n        PDDocument outputDocument = new PDDocument();\n        PDFRenderer pdfRenderer = new PDFRenderer(document);\n\n        for (int i = 0; i < document.getNumberOfPages(); i++) {\n            PDRectangle pageSize = document.getPage(i).getMediaBox();\n            float pageWidthPts = pageSize.getWidth();\n            float pageHeightPts = pageSize.getHeight();\n\n            int projectedWidth = (int) Math.ceil(pageWidthPts * resolution / 72.0);\n            int projectedHeight = (int) Math.ceil(pageHeightPts * resolution / 72.0);\n            long projectedPixels = (long) projectedWidth * projectedHeight;\n\n            int safeResolution = resolution;\n            if (projectedWidth > MAX_IMAGE_WIDTH || projectedHeight > MAX_IMAGE_HEIGHT || projectedPixels > MAX_IMAGE_PIXELS) {\n                double widthScale = (double) MAX_IMAGE_WIDTH / projectedWidth;\n                double heightScale = (double) MAX_IMAGE_HEIGHT / projectedHeight;\n                double pixelScale = Math.sqrt((double) MAX_IMAGE_PIXELS / projectedPixels);\n                double minScale = Math.min(Math.min(widthScale, heightScale), pixelScale);\n                safeResolution = (int) Math.max(72, resolution * minScale);\n                log.warn(\"Page \" + (i + 1) + \" would be too large at \" + resolution + \"dpi (\" + projectedWidth + \"x\" + projectedHeight + \" pixels). Reducing to \" + safeResolution + \"dpi\");\n            }\n\n            BufferedImage image = pdfRenderer.renderImageWithDPI(i, safeResolution);\n            log.debug(\"Processing page \" + (i + 1) + \" with dimensions \" + image.getWidth() + \"x\" + image.getHeight() + \" (\" + ((long) image.getWidth() * image.getHeight()) + \" pixels) at \" + safeResolution + \"dpi\");\n\n            BufferedImage processed;\n            if (colorspace == ScannerEffectRequest.Colorspace.grayscale) {\n                processed = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);\n                Graphics2D gGray = processed.createGraphics();\n                gGray.setColor(Color.BLACK);\n                gGray.fillRect(0, 0, image.getWidth(), image.getHeight());\n                gGray.drawImage(image, 0, 0, null);\n                gGray.dispose();\n\n                for (int y = 0; y < processed.getHeight(); y++) {\n                    for (int x = 0; x < processed.getWidth(); x++) {\n                        int rgb = processed.getRGB(x, y);\n                        int r = (rgb >> 16) & 0xFF;\n                        int g = (rgb >> 8) & 0xFF;\n                        int b = rgb & 0xFF;\n                        int gray = (r + g + b) / 3;\n                        int grayRGB = (gray << 16) | (gray << 8) | gray;\n                        processed.setRGB(x, y, grayRGB);\n                    }\n                }\n            } else {\n                processed = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);\n                Graphics2D gCol = processed.createGraphics();\n                gCol.drawImage(image, 0, 0, null);\n                gCol.dispose();\n            }\n\n            int baseW = processed.getWidth() + 2 * borderPx;\n            int baseH = processed.getHeight() + 2 * borderPx;\n            boolean vertical = RANDOM.nextBoolean();\n            float startGrey = 0.6f + 0.3f * RANDOM.nextFloat();\n            float endGrey = 0.6f + 0.3f * RANDOM.nextFloat();\n            Color startColor = new Color(Math.round(startGrey * 255), Math.round(startGrey * 255), Math.round(startGrey * 255));\n            Color endColor = new Color(Math.round(endGrey * 255), Math.round(endGrey * 255), Math.round(endGrey * 255));\n            BufferedImage composed = new BufferedImage(baseW, baseH, processed.getType());\n            Graphics2D gBg = composed.createGraphics();\n            for (int y = 0; y < baseH; y++) {\n                for (int x = 0; x < baseW; x++) {\n                    float frac = vertical ? (float) y / (baseH - 1) : (float) x / (baseW - 1);\n                    int r = Math.round(startColor.getRed() + (endColor.getRed() - startColor.getRed()) * frac);\n                    int g = Math.round(startColor.getGreen() + (endColor.getGreen() - startColor.getGreen()) * frac);\n                    int b = Math.round(startColor.getBlue() + (endColor.getBlue() - startColor.getBlue()) * frac);\n                    composed.setRGB(x, y, new Color(r, g, b).getRGB());\n                }\n            }\n            gBg.drawImage(processed, borderPx, borderPx, null);\n            gBg.dispose();\n\n            double pageRotation = baseRotation;\n            if (baseRotation != 0 || rotateVariance != 0) {\n                pageRotation += (RANDOM.nextDouble() * 2 - 1) * rotateVariance;\n            }\n\n            BufferedImage rotated;\n            int w = composed.getWidth();\n            int h = composed.getHeight();\n            int rotW = w;\n            int rotH = h;\n\n            if (pageRotation == 0) {\n                rotated = composed;\n            } else {\n                double radians = Math.toRadians(pageRotation);\n                double sin = Math.abs(Math.sin(radians));\n                double cos = Math.abs(Math.cos(radians));\n                rotW = (int) Math.floor(w * cos + h * sin);\n                rotH = (int) Math.floor(h * cos + w * sin);\n                BufferedImage rotatedBg = new BufferedImage(rotW, rotH, composed.getType());\n                Graphics2D gBgRot = rotatedBg.createGraphics();\n                for (int y = 0; y < rotH; y++) {\n                    for (int x = 0; x < rotW; x++) {\n                        float frac = vertical ? (float) y / (rotH - 1) : (float) x / (rotW - 1);\n                        int r = Math.round(startColor.getRed() + (endColor.getRed() - startColor.getRed()) * frac);\n                        int g = Math.round(startColor.getGreen() + (endColor.getGreen() - startColor.getGreen()) * frac);\n                        int b = Math.round(startColor.getBlue() + (endColor.getBlue() - startColor.getBlue()) * frac);\n                        rotatedBg.setRGB(x, y, new Color(r, g, b).getRGB());\n                    }\n                }\n                gBgRot.dispose();\n                rotated = new BufferedImage(rotW, rotH, composed.getType());\n                Graphics2D g2d = rotated.createGraphics();\n                g2d.drawImage(rotatedBg, 0, 0, null);\n                AffineTransform at = new AffineTransform();\n                at.translate((rotW - w) / 2.0, (rotH - h) / 2.0);\n                at.rotate(radians, w / 2.0, h / 2.0);\n                g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n                g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n                g2d.drawImage(composed, at, null);\n                g2d.dispose();\n            }\n\n            PDRectangle origPageSize = document.getPage(i).getMediaBox();\n            float origW = origPageSize.getWidth();\n            float origH = origPageSize.getHeight();\n            float scale = Math.max(origW / rotW, origH / rotH);\n            float drawW = rotW * scale;\n            float drawH = rotH * scale;\n            float offsetX = (origW - drawW) / 2f;\n            float offsetY = (origH - drawH) / 2f;\n\n            BufferedImage softened = softenEdges(rotated, Math.max(10, Math.round(Math.min(rotW, rotH) * 0.02f)), startColor, endColor, vertical);\n            BufferedImage blurred = applyGaussianBlur(softened, blur);\n            BufferedImage adjusted = adjustBrightnessContrast(blurred, brightness, contrast);\n\n            if (yellowish) {\n                applyYellowishEffect(adjusted);\n            }\n            addGaussianNoise(adjusted, noise);\n\n            PDPage newPage = new PDPage(new PDRectangle(origW, origH));\n            outputDocument.addPage(newPage);\n            try (PDPageContentStream contentStream = new PDPageContentStream(outputDocument, newPage)) {\n                PDImageXObject pdImage = LosslessFactory.createFromImage(outputDocument, adjusted);\n                contentStream.drawImage(pdImage, offsetX, offsetY, drawW, drawH);\n            }\n        }\n\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        outputDocument.save(outputStream);\n        outputDocument.close();\n\n        String outputFilename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_scanner_effect.pdf\";\n        return WebResponseUtils.bytesToWebResponse(outputStream.toByteArray(), outputFilename, MediaType.APPLICATION_PDF);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "212", "src_id": "M509", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n@Operation(summary = \"Convert EML to PDF\", description = \"This endpoint converts EML (email) files to PDF format with extensive customization options. Features include font settings, image constraints, display modes, attachment handling, and HTML debug output. Input: EML file, Output: PDF or HTML file. Type: SISO\")\npublic ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n    MultipartFile inputFile = request.getFileInput();\n    String originalFilename = inputFile.getOriginalFilename();\n\n    if (inputFile.isEmpty()) {\n        log.error(\"No file provided for EML to PDF conversion.\");\n        return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    if (originalFilename == null || originalFilename.trim().isEmpty()) {\n        log.error(\"Filename is null or empty.\");\n        return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    String lowerFilename = originalFilename.toLowerCase();\n    if (!lowerFilename.endsWith(\".eml\")) {\n        log.error(\"Invalid file type for EML to PDF: \" + originalFilename);\n        return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    String baseFilename = Filenames.toSimpleFileName(originalFilename);\n\n    try {\n        byte[] fileBytes = inputFile.getBytes();\n\n        if (request.isDownloadHtml()) {\n            try {\n                String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                log.info(\"Successfully converted EML to HTML: \" + originalFilename);\n                return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8), baseFilename + \".html\", MediaType.TEXT_HTML);\n            } catch (IOException | IllegalArgumentException e) {\n                log.error(\"HTML conversion failed for \" + originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        try {\n            byte[] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig.getWeasyPrintPath(), request, fileBytes, originalFilename, false, pdfDocumentFactory, tempFileManager);\n\n            if (pdfBytes == null || pdfBytes.length == 0) {\n                log.error(\"PDF conversion failed - empty output for \" + originalFilename);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n            }\n            log.info(\"Successfully converted EML to PDF: \" + originalFilename);\n            return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"EML to PDF conversion was interrupted for \" + originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n        } catch (IllegalArgumentException | RuntimeException e) {\n            String errorMessage = buildErrorMessage(e, originalFilename);\n            log.error(\"EML to PDF conversion failed for \" + originalFilename + \": \" + errorMessage, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        }\n    } catch (IOException e) {\n        log.error(\"File processing error for EML to PDF: \" + originalFilename, e);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "213", "src_id": "M254", "code": "\nprivate void distributedConfigureServers(int count) throws IOException {\n    StringBuilder sbClient = new StringBuilder();\n    StringBuilder sbServer = new StringBuilder();\n    try {\n        for (int i = 0; i < count; i++) {\n            String r[] = QuorumPeerInstance.createServer(im, i);\n            if (i > 0) {\n                sbClient.append(',');\n                sbServer.append(',');\n            }\n            sbClient.append(r[0]); // host:clientPort\n            sbServer.append(r[1]); // host:leaderPort:leaderElectionPort\n            sbServer.append(';' + (r[0].split(\":\"))[1]); // Append clientPort\n        }\n        serverHostPort = sbClient.toString();\n        quorumHostPort = sbServer.toString();\n    } catch (Exception e) {\n        IOException ioe = new IOException(e.getMessage());\n        ioe.setStackTrace(e.getStackTrace());\n        throw ioe;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "214", "src_id": "M39", "code": "\nprivate void initComponents() {\n    setSize(toasterWidth, toasterHeight);\n    message.setFont(getToasterMessageFont());\n    JPanel externalPanel = new JPanel(new BorderLayout(1, 1));\n    externalPanel.setBackground(getBorderColor());\n    JPanel innerPanel = new JPanel(new BorderLayout(getMargin(), getMargin()));\n    innerPanel.setBackground(getToasterColor());\n    message.setBackground(getToasterColor());\n    message.setMargin(new Insets(2, 2, 2, 2));\n    message.setLineWrap(true);\n    message.setWrapStyleWord(true);\n\n    EtchedBorder etchedBorder = (EtchedBorder) BorderFactory.createEtchedBorder();\n    externalPanel.setBorder(etchedBorder);\n    externalPanel.add(innerPanel);\n    \n    message.setForeground(getMessageColor());\n    innerPanel.add(iconLabel, BorderLayout.WEST);\n    innerPanel.add(message, BorderLayout.CENTER);\n    getContentPane().add(externalPanel);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "215", "src_id": "M1130", "code": "\npublic synchronized Map<String, Object> getConnectionInfo(boolean brief) {\n    Map<String, Object> info = new LinkedHashMap<>();\n    info.put(\"remote_socket_address\", getRemoteSocketAddress());\n    info.put(\"interest_ops\", getInterestOps());\n    info.put(\"outstanding_requests\", getOutstandingRequests());\n    info.put(\"packets_received\", getPacketsReceived());\n    info.put(\"packets_sent\", getPacketsSent());\n    \n    if (!brief) {\n        info.put(\"session_id\", getSessionId());\n        info.put(\"last_operation\", getLastOperation());\n        info.put(\"established\", getEstablished());\n        info.put(\"session_timeout\", getSessionTimeout());\n        info.put(\"last_cxid\", getLastCxid());\n        info.put(\"last_zxid\", getLastZxid());\n        info.put(\"last_response_time\", getLastResponseTime());\n        info.put(\"last_latency\", getLastLatency());\n        info.put(\"min_latency\", getMinLatency());\n        info.put(\"avg_latency\", getAvgLatency());\n        info.put(\"max_latency\", getMaxLatency());\n    }\n    return info;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "216", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        for (SelectionKey key : selector.keys()) {\n            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        \n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "217", "src_id": "M1043", "code": "\nvoid handleWrite(SelectionKey k) throws IOException {\n    if (outgoingBuffers.isEmpty()) {\n        return;\n    }\n\n    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n    if (directBuffer == null) {\n        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n        sock.write(outgoingBuffers.toArray(bufferList));\n\n        ByteBuffer bb;\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (bb.remaining() > 0) {\n                break;\n            }\n            outgoingBuffers.remove();\n        }\n    } else {\n        directBuffer.clear();\n\n        for (ByteBuffer b : outgoingBuffers) {\n            if (directBuffer.remaining() < b.remaining()) {\n                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n            }\n            int p = b.position();\n            directBuffer.put(b);\n            b.position(p);\n            if (directBuffer.remaining() == 0) {\n                break;\n            }\n        }\n        directBuffer.flip();\n\n        int sent = sock.write(directBuffer);\n        ByteBuffer bb;\n\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (sent < bb.remaining()) {\n                bb.position(bb.position() + sent);\n                break;\n            }\n            sent -= bb.remaining();\n            outgoingBuffers.remove();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "218", "src_id": "M577", "code": "\npublic Long update(E elem, int timeout) {\n    Long prevExpiryTime = elemMap.get(elem);\n    long now = Time.currentElapsedTime();\n    Long newExpiryTime = roundToNextInterval(now + timeout);\n\n    if (newExpiryTime.equals(prevExpiryTime)) {\n        return null;\n    }\n\n    Set<E> set = expiryMap.get(newExpiryTime);\n    if (set == null) {\n        set = Collections.newSetFromMap(new ConcurrentHashMap<>());\n        Set<E> existingSet = expiryMap.putIfAbsent(newExpiryTime, set);\n        if (existingSet != null) {\n            set = existingSet;\n        }\n    }\n    set.add(elem);\n\n    prevExpiryTime = elemMap.put(elem, newExpiryTime);\n    if (prevExpiryTime != null && !newExpiryTime.equals(prevExpiryTime)) {\n        Set<E> prevSet = expiryMap.get(prevExpiryTime);\n        if (prevSet != null) {\n            prevSet.remove(elem);\n        }\n    }\n    return newExpiryTime;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "219", "src_id": "M219", "code": "\nsynchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n    final String connectionId = concat(contextPath, session);\n    ZooKeeper zk = zkMap.get(connectionId);\n    \n    if (zk == null) {\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"creating new connection for : '%s'\", connectionId));\n        }\n        Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n        \n        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n        }\n        \n        zkMap.put(connectionId, zk);\n        \n        if (session != null) {\n            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "220", "src_id": "M282", "code": "\n@Test\npublic void testSimpleCase() throws Exception {\n    configureServers(serverCount);\n    configureClients(clientCount, SimpleClient.class, getHostPort());\n    Stat stat = new Stat();\n    startServers();\n    LOG.debug(\"Connecting to \" + getHostPort());\n    ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n    waitForConnect(zk, 10000);\n    zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    startClients();\n\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            try {\n                byte b[] = zk.getData(\"/simpleCase/\" + i, false, stat);\n                Assert.assertEquals(\"orig\", new String(b));\n            } catch (NoNodeException e) {\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"Max tries exceeded on client \" + i);\n                }\n                Thread.sleep(1000);\n            }\n        }\n    }\n\n    for (int i = 0; i < getServerCount(); i++) {\n        stopServer(i);\n        if (i + 1 > getServerCount() / 2) {\n            startServer(i);\n        } else if (i + 1 == getServerCount() / 2) {\n            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n            try {\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            } catch (ConnectionLossException e) {\n                Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            }\n            for (int j = 0; j < i; j++) {\n                LOG.info(\"Starting server \" + j);\n                startServer(i);\n            }\n        }\n    }\n    Thread.sleep(100);\n    Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    try {\n        zk.getData(\"/simpleCase\", false, stat);\n    } catch (ConnectionLossException e) {\n        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    }\n\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n            if (new String(data).equals(\"new\")) {\n                break;\n            }\n            if (j + 1 == maxTries) {\n                Assert.fail(\"max tries exceeded for \" + i);\n            }\n            Thread.sleep(1000);\n        }\n    }\n\n    zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n\n    for (int i = 0; i < getClientCount(); i++) {\n        try {\n            for (int j = 0; j < maxTries; j++) {\n                zk.getData(\"/simpleCase/\" + i, false, stat);\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                }\n                Thread.sleep(200);\n            }\n        } catch (NoNodeException e) {\n            // Expected\n        }\n    }\n\n    stopClients();\n    stopServers();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "221", "src_id": "M211", "code": "\npublic static void main(String[] args) throws IOException {\n    RandomAccessFileReader f = new RandomAccessFileReader(new File(args[0]));\n    \n    long pos0 = f.getPosition();\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    System.out.println(\"=============\");\n    long pos1 = f.getPosition();\n    System.out.println(\"pos: \" + pos1);\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    System.out.println(\"=============\");\n    f.seek(pos1);\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    System.out.println(\"=============\");\n    f.seek(pos0);\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    long pos2 = f.getPosition();\n    System.out.println(\"=============\");\n    System.out.println(f.readLine());\n    f.seek(pos2);\n    System.out.println(f.readLine());\n    f.close();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "222", "src_id": "M168", "code": "\nprivate StringArg readStringArg() throws IOException, FilterException {\n    final int c = reader.read();\n    int last = 0;\n    if (c != '\"') {\n        throw new FilterException(\"Check the parser, trying to read a string that doesn't begin with quotes\");\n    }\n    final StringBuilder buffer = new StringBuilder();\n    while (reader.ready()) {\n        last = c;\n        final int nextChar = reader.read();\n        if (nextChar == -1) {\n            break;\n        }\n        \n        if (nextChar == '\"' && last != '\\\\') {\n            return new StringArg(buffer.toString());\n        } else {\n            buffer.append((char) nextChar);\n        }\n    }\n    throw new FilterException(\"Unterminated string\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "223", "src_id": "M196", "code": "\npublic static void main(String[] args) throws IOException {\n    final MergedLogSource source = new MergedLogSource(args);\n\n    try (final PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n         final PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n         final PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n         final PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")))) {\n\n        System.out.println(source);\n        final LogIterator iter = source.iterator();\n        long currentms = 0;\n        long currentsec = 0;\n        long currentmin = 0;\n        long currenthour = 0;\n        final Set<Long> zxids_ms = new HashSet<>();\n        long zxid_sec = 0;\n        long zxid_min = 0;\n        long zxid_hour = 0;\n\n        while (iter.hasNext()) {\n            final LogEntry e = iter.next();\n            final TransactionEntry cxn = (TransactionEntry) e;\n            \n            final long ms = cxn.getTimestamp();\n            final long sec = ms / MS_PER_SEC;\n            final long min = ms / MS_PER_MIN;\n            final long hour = ms / MS_PER_HOUR;\n\n            if (currentms != ms && currentms != 0) {\n                ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n\n                zxid_sec += zxids_ms.size();\n                zxid_min += zxids_ms.size();\n                zxid_hour += zxids_ms.size();\n                zxids_ms.clear();\n            }\n\n            if (currentsec != sec && currentsec != 0) {\n                ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n\n                zxid_sec = 0;\n            }\n\n            if (currentmin != min && currentmin != 0) {\n                ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n                \n                zxid_min = 0;\n            }\n\n            if (currenthour != hour && currenthour != 0) {\n                ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n                \n                zxid_hour = 0;\n            }\n\n            currentms = ms;\n            currentsec = sec;\n            currentmin = min;\n            currenthour = hour;\n\n            zxids_ms.add(cxn.getZxid());\n        }\n\n        iter.close();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "224", "src_id": "M174", "code": "\nprivate LogEntry readNextEntry() {\n    LogEntry e = null;\n    try {\n        final long crcValue;\n        final byte[] bytes;\n        try {\n            crcValue = logStream.readLong(\"crcvalue\");\n            bytes = logStream.readBuffer(\"txnEntry\");\n        } catch (final EOFException ex) {\n            return null;\n        }\n        \n        if (bytes.length == 0) {\n            return null;\n        }\n        final Checksum crc = new Adler32();\n        crc.update(bytes, 0, bytes.length);\n        if (crcValue != crc.getValue()) {\n            throw new IOException(\"CRC doesn't match \" + crcValue +\n                                  \" vs \" + crc.getValue());\n        }\n\n        final TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n        final TxnHeader hdr = logEntry.getHeader();\n        final Record r = logEntry.getTxn();\n\n        switch (hdr.getType()) {\n            case OpCode.createSession: {\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n            }\n                break;\n            case OpCode.closeSession: {\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n            }\n                break;\n            case OpCode.create:\n                if (r != null) {\n                    final CreateTxn create = (CreateTxn) r;\n                    final String path = create.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n                }\n                break;\n            case OpCode.setData:\n                if (r != null) {\n                    final SetDataTxn set = (SetDataTxn) r;\n                    final String path = set.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n                }\n                break;\n            case OpCode.setACL:\n                if (r != null) {\n                    final SetACLTxn setacl = (SetACLTxn) r;\n                    final String path = setacl.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n                }\n                break;\n            case OpCode.error:\n                if (r != null)  {\n                    final ErrorTxn error = (ErrorTxn) r;\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n                }\n                break;\n            default:\n                LOG.info(\"Unknown op: \" + hdr.getType());\n                break;\n        }\n        \n        if (logStream.readByte(\"EOR\") != 'B') {\n            throw new EOFException(\"Last transaction was partial.\");\n        }\n    } catch (final Exception ex) {\n        LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n        return null;\n    }\n    return e;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "225", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (final RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (final Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        for (final SelectionKey key : selector.keys()) {\n            final NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "226", "src_id": "M286", "code": "\npublic void reconfigureInstance(String name, String params) throws NoAssignmentException, InterruptedException, KeeperException {\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n    }\n    final Assigned assigned = instanceToAssignment.get(name);\n    if (assigned == null) {\n        throw new NoAssignmentException();\n    }\n    KeeperException lastException = null;\n    for (int i = 0; i < maxTries; i++) {\n        try {\n            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, (\"update \" + params).getBytes(), -1);\n            break;\n        } catch (final ConnectionLossException e) {\n            lastException = e;\n        }\n    }\n    if (lastException != null) {\n        throw lastException;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "227", "src_id": "M1046", "code": "\npublic static void closeSock(SocketChannel sock) {\n    if (!sock.isOpen()) {\n        return;\n    }\n\n    try {\n        sock.socket().shutdownOutput();\n    } catch (final IOException e) {\n        LOG.debug(\"ignoring exception during output shutdown\", e);\n    }\n    try {\n        sock.socket().shutdownInput();\n    } catch (final IOException e) {\n        LOG.debug(\"ignoring exception during input shutdown\", e);\n    }\n    try {\n        sock.socket().close();\n    } catch (final IOException e) {\n        LOG.debug(\"ignoring exception during socket close\", e);\n    }\n    try {\n        sock.close();\n    } catch (final IOException e) {\n        LOG.debug(\"ignoring exception during socketchannel close\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "228", "src_id": "M149", "code": "\nString handleRequest(JsonRequest request) throws Exception {\n    long starttime = 0;\n    long endtime = 0;\n    final long period = request.getNumber(\"period\", 0);\n    FilterOp fo = null;\n    final String filterstr = request.getString(\"filter\", \"\");\n\n    if (filterstr.length() > 0) {\n        fo = new FilterParser(filterstr).parse();\n    }\n    \n    starttime = request.getNumber(\"start\", 0);\n    if (starttime == 0) { \n        starttime = source.getStartTime(); \n    }\n    endtime = request.getNumber(\"end\", 0);\n    if (endtime == 0) { \n        endtime = (period > 0) ? starttime + period : starttime + DEFAULT_PERIOD;\n    }\n\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", period=\" + period + \")\");\n    }\n    \n    final LogIterator iterator = (fo != null) \n        ? source.iterator(starttime, endtime, fo) \n        : source.iterator(starttime, endtime);\n    return new JsonGenerator(iterator).toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "229", "src_id": "M370", "code": "\n@Override\nvoid cleanup() {\n    if (sockKey != null) {\n        final SocketChannel sock = (SocketChannel) sockKey.channel();\n        sockKey.cancel();\n        try {\n            sock.socket().shutdownInput();\n        } catch (final IOException e) {\n            LOG.debug(\"Ignoring exception during shutdown input\", e);\n        }\n        try {\n            sock.socket().shutdownOutput();\n        } catch (final IOException e) {\n            LOG.debug(\"Ignoring exception during shutdown output\", e);\n        }\n        try {\n            sock.socket().close();\n        } catch (final IOException e) {\n            LOG.debug(\"Ignoring exception during socket close\", e);\n        }\n        try {\n            sock.close();\n        } catch (final IOException e) {\n            LOG.debug(\"Ignoring exception during channel close\", e);\n        }\n    }\n    try {\n        Thread.sleep(100);\n    } catch (final InterruptedException e) {\n        LOG.debug(\"SendThread interrupted during sleep, ignoring\");\n    }\n    sockKey = null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "230", "src_id": "M40", "code": "\nprotected void animateVertically(int posx, int fromY, int toY) throws InterruptedException {\n    toaster.setLocation(posx, fromY);\n    if (toY < fromY) {\n        for (int i = fromY; i > toY; i -= step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    } else {\n        for (int i = fromY; i < toY; i += step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    }\n    toaster.setLocation(posx, toY);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "231", "src_id": "M1043", "code": "\nprivate void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n\n    final Thread currentThread = Thread.currentThread();\n    notifyPostProcessing(1);\n\n    // Conditionally set thread name for debugging\n    if (DEBUG) {\n        currentThread.setName(String.format(\n            \"[%s]  ps = %s  filename = %s\",\n            TAG,\n            psAlgorithm,\n            storage.getName()\n        ));\n    }\n\n    Exception exception = null;\n\n    try {\n        psAlgorithm.run(this);\n    } catch (Exception error) {\n        Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), error);\n\n        // Handle interruption cases\n        if (error instanceof InterruptedIOException \n            || error instanceof ClosedByInterruptException\n            || currentThread.isInterrupted()) {\n            notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) {\n            errCode = ERROR_POSTPROCESSING;\n        }\n\n        exception = error;\n    } finally {\n        final int finalStatus = errCode == ERROR_NOTHING ? 2 : 0;\n        notifyPostProcessing(finalStatus);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n        if (exception == null) {\n            exception = errObject;\n        }\n        notifyError(ERROR_POSTPROCESSING, exception);\n        return;\n    }\n\n    notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "232", "src_id": "M1050", "code": "\n@Override\npublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n    if (oldVersion == 2) {\n        db.execSQL(String.format(\n            \"ALTER TABLE %s ADD COLUMN %s TEXT;\",\n            MISSIONS_TABLE_NAME_v2,\n            KEY_KIND\n        ));\n        oldVersion++;\n    }\n\n    if (oldVersion == 3) {\n        final String KEY_LOCATION = \"location\";\n        final String KEY_NAME = \"name\";\n\n        db.execSQL(MISSIONS_CREATE_TABLE);\n\n        // Migrate data from old table to new structure\n        try (Cursor cursor = db.query(\n            MISSIONS_TABLE_NAME_v2,\n            null, \n            null,\n            null, \n            null, \n            null, \n            KEY_TIMESTAMP\n        )) {\n            final int recordCount = cursor.getCount();\n            if (recordCount > 0) {\n                db.beginTransaction();\n                try {\n                    while (cursor.moveToNext()) {\n                        final ContentValues values = new ContentValues();\n                        values.put(KEY_SOURCE, cursor.getString(cursor.getColumnIndex(KEY_SOURCE)));\n                        values.put(KEY_DONE, cursor.getString(cursor.getColumnIndex(KEY_DONE)));\n                        values.put(KEY_TIMESTAMP, cursor.getLong(cursor.getColumnIndex(KEY_TIMESTAMP)));\n                        values.put(KEY_KIND, cursor.getString(cursor.getColumnIndex(KEY_KIND)));\n                        \n                        final File locationFile = new File(\n                            cursor.getString(cursor.getColumnIndex(KEY_LOCATION)),\n                            cursor.getString(cursor.getColumnIndex(KEY_NAME))\n                        );\n                        values.put(KEY_PATH, Uri.fromFile(locationFile).toString());\n\n                        db.insert(FINISHED_TABLE_NAME, null, values);\n                    }\n                    db.setTransactionSuccessful();\n                } finally {\n                    db.endTransaction();\n                }\n            }\n        }\n\n        db.execSQL(\"DROP TABLE \" + MISSIONS_TABLE_NAME_v2);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "233", "src_id": "M870", "code": "\n@SuppressWarnings(\"MethodLength\")\npublic void build(final SharpStream output) throws IOException {\n    if (done) {\n        throw new RuntimeException(\"already done\");\n    }\n    if (!output.canWrite()) {\n        throw new IOException(\"the provided output is not writable\");\n    }\n\n    outStream = output;\n    long read = 8; // mdat box header size\n    long totalSampleSize = 0;\n    final int[] sampleExtra = new int[readers.length];\n    final int[] defaultMediaTime = new int[readers.length];\n    final int[] defaultSampleDuration = new int[readers.length];\n    final int[] sampleCount = new int[readers.length];\n\n    final TablesInfo[] tablesInfo = new TablesInfo[tracks.length];\n    Arrays.setAll(tablesInfo, i -> new TablesInfo());\n\n    // Configure audio-specific sampling\n    final int singleSampleBuffer;\n    if (tracks.length == 1 && tracks[0].kind == TrackKind.Audio) {\n        singleSampleBuffer = tracks[0].trak.mdia.mdhdTimeScale / 1000;\n    } else {\n        singleSampleBuffer = -1;\n    }\n\n    // Process each reader chunk\n    for (int i = 0; i < readers.length; i++) {\n        int samplesSize = 0;\n        int sampleSizeChanges = 0;\n        int compositionOffsetLast = -1;\n\n        Mp4DashChunk chunk;\n        while ((chunk = readers[i].getNextChunk(true)) != null) {\n            if (defaultMediaTime[i] < 1 && chunk.moof.traf.tfhd.defaultSampleDuration > 0) {\n                defaultMediaTime[i] = chunk.moof.traf.tfhd.defaultSampleDuration;\n            }\n\n            read += chunk.moof.traf.trun.chunkSize;\n            sampleExtra[i] += chunk.moof.traf.trun.chunkDuration;\n\n            TrunEntry info;\n            while ((info = chunk.getNextSampleInfo()) != null) {\n                if (info.isKeyframe) {\n                    tablesInfo[i].stss++;\n                }\n\n                if (info.sampleDuration > defaultSampleDuration[i]) {\n                    defaultSampleDuration[i] = info.sampleDuration;\n                }\n\n                tablesInfo[i].stsz++;\n                if (samplesSize != info.sampleSize) {\n                    samplesSize = info.sampleSize;\n                    sampleSizeChanges++;\n                }\n\n                if (info.hasCompositionTimeOffset) {\n                    if (info.sampleCompositionTimeOffset != compositionOffsetLast) {\n                        tablesInfo[i].ctts++;\n                        compositionOffsetLast = info.sampleCompositionTimeOffset;\n                    }\n                }\n\n                totalSampleSize += info.sampleSize;\n            }\n        }\n\n        if (defaultMediaTime[i] < 1) {\n            defaultMediaTime[i] = defaultSampleDuration[i];\n        }\n        readers[i].rewind();\n\n        // Initialize chunk tables\n        if (singleSampleBuffer > 0) {\n            initChunkTables(tablesInfo[i], singleSampleBuffer, singleSampleBuffer);\n        } else {\n            initChunkTables(tablesInfo[i], SAMPLES_PER_CHUNK_INIT, SAMPLES_PER_CHUNK);\n        }\n\n        sampleCount[i] = tablesInfo[i].stsz;\n        tablesInfo[i].stszDefault = (sampleSizeChanges == 1) ? samplesSize : 0;\n        tablesInfo[i].stss = (tablesInfo[i].stss == tablesInfo[i].stsz) ? -1 : tablesInfo[i].stss;\n\n        // Ensure valid track duration\n        if (tracks[i].trak.tkhd.duration < 1) {\n            tracks[i].trak.tkhd.duration = sampleExtra[i];\n        }\n    }\n\n    final boolean is64 = read > THRESHOLD_FOR_CO64;\n    final int auxSize = makeMoov(defaultMediaTime, tablesInfo, is64);\n\n    // Allocate buffer for MOOV if needed\n    if (auxSize < THRESHOLD_MOOV_LENGTH) {\n        auxBuffer = ByteBuffer.allocate(auxSize);\n    }\n\n    moovSimulation = false;\n    writeOffset = 0;\n    final int ftypSize = makeFtyp();\n\n    // Reserve space in output stream\n    if (auxSize > 0) {\n        int remaining = auxSize;\n        final byte[] buffer = new byte[64 * 1024];\n        while (remaining > 0) {\n            final int writeSize = Math.min(remaining, buffer.length);\n            outWrite(buffer, writeSize);\n            remaining -= writeSize;\n        }\n    }\n\n    if (auxBuffer == null) {\n        outSeek(ftypSize);\n    }\n\n    makeMoov(defaultMediaTime, tablesInfo, is64);\n\n    // Write tables data\n    for (int i = 0; i < readers.length; i++) {\n        writeEntryArray(tablesInfo[i].stts, 2, sampleCount[i], defaultSampleDuration[i]);\n        writeEntryArray(tablesInfo[i].stsc, tablesInfo[i].stscBEntries.length, tablesInfo[i].stscBEntries);\n        tablesInfo[i].stscBEntries = null;\n        \n        if (tablesInfo[i].ctts > 0) {\n            sampleCount[i] = 1;\n            sampleExtra[i] = -1;\n        }\n        \n        if (tablesInfo[i].sbgp > 0) {\n            writeEntryArray(tablesInfo[i].sbgp, 1, sampleCount[i]);\n        }\n    }\n\n    if (auxBuffer == null) {\n        outRestore();\n    }\n\n    outWrite(makeMdat(totalSampleSize, is64));\n\n    // Process samples\n    final int[] sampleIndex = new int[readers.length];\n    final int bufferSize = singleSampleBuffer > 0 ? singleSampleBuffer : SAMPLES_PER_CHUNK;\n    final int[] sizes = new int[bufferSize];\n    final int[] sync = new int[bufferSize];\n\n    int activeTracks = readers.length;\n    while (activeTracks > 0) {\n        activeTracks = 0;\n\n        for (int i = 0; i < readers.length; i++) {\n            if (sampleIndex[i] < 0) continue;\n\n            final long chunkOffset = writeOffset;\n            int syncCount = 0;\n            final int limit = sampleIndex[i] == 0 ? \n                SAMPLES_PER_CHUNK_INIT : \n                (singleSampleBuffer > 0 ? singleSampleBuffer : SAMPLES_PER_CHUNK);\n\n            int processed = 0;\n            for (; processed < limit; processed++) {\n                final Mp4DashSample sample = getNextSample(i);\n                if (sample == null) {\n                    if (tablesInfo[i].ctts > 0 && sampleExtra[i] >= 0) {\n                        writeEntryArray(tablesInfo[i].ctts, 1, sampleCount[i], sampleExtra[i]);\n                        outRestore();\n                    }\n                    sampleIndex[i] = -1;\n                    break;\n                }\n\n                sampleIndex[i]++;\n\n                if (tablesInfo[i].ctts > 0) {\n                    if (sample.info.sampleCompositionTimeOffset == sampleExtra[i]) {\n                        sampleCount[i]++;\n                    } else {\n                        if (sampleExtra[i] >= 0) {\n                            tablesInfo[i].ctts = writeEntryArray(\n                                tablesInfo[i].ctts, \n                                2,\n                                sampleCount[i], \n                                sampleExtra[i]\n                            );\n                            outRestore();\n                        }\n                        sampleCount[i] = 1;\n                        sampleExtra[i] = sample.info.sampleCompositionTimeOffset;\n                    }\n                }\n\n                if (tablesInfo[i].stss > 0 && sample.info.isKeyframe) {\n                    sync[syncCount++] = sampleIndex[i];\n                }\n\n                if (tablesInfo[i].stsz > 0) {\n                    sizes[processed] = sample.data.length;\n                }\n\n                outWrite(sample.data, sample.data.length);\n            }\n\n            if (processed > 0) {\n                activeTracks++;\n\n                if (tablesInfo[i].stsz > 0) {\n                    tablesInfo[i].stsz = writeEntryArray(tablesInfo[i].stsz, processed, sizes);\n                }\n\n                if (syncCount > 0) {\n                    tablesInfo[i].stss = writeEntryArray(tablesInfo[i].stss, syncCount, sync);\n                }\n\n                if (tablesInfo[i].stco > 0) {\n                    if (is64) {\n                        tablesInfo[i].stco = writeEntry64(tablesInfo[i].stco, chunkOffset);\n                    } else {\n                        tablesInfo[i].stco = writeEntryArray(tablesInfo[i].stco, 1, (int) chunkOffset);\n                    }\n                }\n\n                outRestore();\n            }\n        }\n    }\n\n    // Write MOOV if buffered\n    if (auxBuffer != null) {\n        outSeek(ftypSize);\n        outStream.write(auxBuffer.array(), 0, auxBuffer.capacity());\n        auxBuffer = null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "234", "src_id": "M1024", "code": "\n@Override\npublic void run() {\n    if (mMission.current > 0) {\n        mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n    }\n\n    int retryCount = 0;\n    int httpCode = 204;\n\n    while (true) {\n        try {\n            // Initialize mission if needed\n            if (mMission.blocks == null && mMission.current == 0) {\n                long finalLength = 0;\n                long lowestSize = Long.MAX_VALUE;\n\n                // Process each URL to get content length\n                for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                    mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (Thread.interrupted()) return;\n                    \n                    long length = Utility.getTotalContentLength(mConn);\n                    if (i == 0) {\n                        httpCode = mConn.getResponseCode();\n                        mMission.length = length;\n                    }\n\n                    if (length > 0) finalLength += length;\n                    if (length < lowestSize) lowestSize = length;\n                }\n\n                mMission.nearLength = finalLength;\n\n                // Reserve space if needed\n                if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                    mMission.offsets[0] = (lowestSize < 1) ? \n                        RESERVE_SPACE_DEFAULT : \n                        Math.min(lowestSize, RESERVE_SPACE_MAXIMUM);\n                }\n            } else {\n                // Get current resource metadata\n                mConn = mMission.openConnection(true, 0, 0);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) return;\n\n                httpCode = mConn.getResponseCode();\n                mMission.length = Utility.getTotalContentLength(mConn);\n            }\n\n            // Validate content availability\n            if (mMission.length == 0 || httpCode == 204) {\n                mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                return;\n            }\n\n            // Handle dynamic content\n            if (mMission.length == -1 && httpCode == 200) {\n                mMission.blocks = new int[0];\n                mMission.length = 0;\n                mMission.unknownLength = true;\n                if (DEBUG) Log.d(TAG, \"falling back (unknown length)\");\n            } else {\n                // Verify range support\n                mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) return;\n\n                synchronized (mMission.LOCK) {\n                    if (mConn.getResponseCode() == 206) {\n                        if (mMission.threadCount > 1) {\n                            int blockCount = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                            if (blockCount * DownloadMission.BLOCK_SIZE < mMission.length) {\n                                blockCount++;\n                            }\n                            mMission.blocks = new int[blockCount];\n                        } else {\n                            mMission.blocks = new int[0];\n                            mMission.unknownLength = false;\n                        }\n                        if (DEBUG) Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                    } else {\n                        mMission.blocks = new int[0];\n                        mMission.unknownLength = false;\n                        if (DEBUG) Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                    }\n                }\n                if (!mMission.running || Thread.interrupted()) return;\n            }\n\n            // Prepare storage\n            try (SharpStream fs = mMission.storage.getStream()) {\n                fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                fs.seek(mMission.offsets[mMission.current]);\n            }\n\n            if (!mMission.running || Thread.interrupted()) return;\n\n            // Set recovery info if available\n            if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n                String entityTag = mConn.getHeaderField(\"ETAG\");\n                String lastModified = mConn.getHeaderField(\"Last-Modified\");\n\n                if (!TextUtils.isEmpty(entityTag)) {\n                    recovery.setValidateCondition(entityTag);\n                } else if (!TextUtils.isEmpty(lastModified)) {\n                    recovery.setValidateCondition(lastModified);\n                } else {\n                    recovery.setValidateCondition(null);\n                }\n            }\n\n            mMission.running = false;\n            break;\n        } catch (InterruptedIOException | ClosedByInterruptException e) {\n            return;\n        } catch (Exception e) {\n            if (!mMission.running || super.isInterrupted()) return;\n\n            // Handle specific error cases\n            if (e instanceof DownloadMission.HttpError \n                && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                interrupt();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                return;\n            }\n\n            if (retryCount++ > mMission.maxRetry) {\n                Log.e(TAG, \"initializer failed\", e);\n                mMission.notifyError(e);\n                return;\n            }\n            Log.e(TAG, \"initializer failed, retrying\", e);\n        }\n    }\n\n    mMission.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "235", "src_id": "M1106", "code": "\nprivate void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n    StringBuilder request = new StringBuilder(256)\n        .append(mission.source)\n        .append(\" [\");\n\n    if (mission.recoveryInfo != null) {\n        for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n            request.append(' ')\n                   .append(recovery.toString())\n                   .append(' ');\n        }\n    }\n    request.append(']');\n\n    String service;\n    try {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e) {\n        service = ErrorInfo.SERVICE_NONE;\n    }\n\n    // Create error notification\n    ErrorUtil.createNotification(\n        mContext,\n        new ErrorInfo(\n            ErrorInfo.Companion.throwableToStringList(mission.errObject),\n            action,\n            service,\n            request.toString(),\n            reason\n        )\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "236", "src_id": "M1055", "code": "\npublic void updateMission(Mission mission) {\n    final ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n    final SQLiteDatabase database = getWritableDatabase();\n    final String timestamp = String.valueOf(mission.timestamp);\n\n    int rowsAffected;\n\n    if (mission instanceof FinishedMission) {\n        if (mission.storage.isInvalid()) {\n            rowsAffected = database.update(\n                FINISHED_TABLE_NAME,\n                values,\n                KEY_TIMESTAMP + \" = ?\",\n                new String[]{timestamp}\n            );\n        } else {\n            rowsAffected = database.update(\n                FINISHED_TABLE_NAME,\n                values,\n                KEY_PATH + \" = ?\",\n                new String[]{mission.storage.getUri().toString()}\n            );\n        }\n    } else {\n        throw new UnsupportedOperationException(\"DownloadMission\");\n    }\n\n    if (rowsAffected != 1) {\n        Log.e(\"FinishedMissionStore\", \n            \"Expected 1 row to be affected by update but got \" + rowsAffected);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "237", "src_id": "M877", "code": "\nprivate int make(final int type, final int extra, final int columns, final int rows)\n        throws IOException {\n    final byte base = 16;\n    final int size = columns * rows * 4;\n    int total = size + base;\n    int offset = auxOffset();\n\n    if (extra >= 0) {\n        total += 4;\n    }\n\n    // Write header block\n    auxWrite(ByteBuffer.allocate(12)\n        .putInt(total)\n        .putInt(type)\n        .putInt(0x00) // default version & flags\n        .array()\n    );\n\n    if (extra >= 0) {\n        offset += 4;\n        auxWrite(extra);\n    }\n\n    auxWrite(rows);\n    auxSkip(size);\n\n    return offset + base;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "238", "src_id": "M1079", "code": "\nboolean runMissions() {\n    synchronized (this) {\n        if (mMissionsPending.size() < 1) return false;\n        if (!canDownloadInCurrentNetwork()) return false;\n\n        // Handle queue limitations\n        if (mPrefQueueLimit) {\n            for (DownloadMission mission : mMissionsPending) {\n                if (!mission.isFinished() && mission.running) {\n                    return true;\n                }\n            }\n        }\n\n        boolean startedMission = false;\n        for (DownloadMission mission : mMissionsPending) {\n            if (mission.running || !mission.enqueued || mission.isFinished()) {\n                continue;\n            }\n\n            resumeMission(mission);\n            if (mission.errCode != DownloadMission.ERROR_NOTHING) {\n                continue;\n            }\n\n            if (mPrefQueueLimit) {\n                return true;\n            }\n            startedMission = true;\n        }\n\n        return startedMission;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "239", "src_id": "M1036", "code": "\npublic void start() {\n    if (running || isFinished() || urls.length < 1) return;\n\n    // Ensure previous state is cleanly exited\n    joinForThreads(10000);\n\n    running = true;\n    errCode = ERROR_NOTHING;\n\n    if (hasInvalidStorage()) {\n        notifyError(ERROR_FILE_CREATION, null);\n        return;\n    }\n\n    if (current >= urls.length) {\n        notifyFinished();\n        return;\n    }\n\n    notify(DownloadManagerService.MESSAGE_RUNNING);\n\n    if (urls[current] == null) {\n        doRecover(ERROR_RESOURCE_GONE);\n        return;\n    }\n\n    if (blocks == null) {\n        initializer();\n        return;\n    }\n\n    init = null;\n    finishCount = 0;\n    blockAcquired = new boolean[blocks.length];\n\n    // Calculate active blocks\n    int remainingBlocks = 0;\n    for (int block : blocks) {\n        if (block >= 0) remainingBlocks++;\n    }\n\n    if (remainingBlocks < 1) {\n        notifyFinished();\n        return;\n    }\n\n    // Create worker threads\n    threads = new Thread[Math.min(threadCount, remainingBlocks)];\n    for (int i = 0; i < threads.length; i++) {\n        final Runnable worker = (blocks.length == 0) ? \n            new DownloadRunnableFallback(this) : \n            new DownloadRunnable(this, i);\n            \n        threads[i] = runAsync(i + 1, worker);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "240", "src_id": "M951", "code": "\n@Override\nprotected void subscribeActual(CompletableObserver observer) {\n    // Initialize cache and set up subscription\n    InnerCompletableCache inner = new InnerCompletableCache(observer);\n    observer.onSubscribe(inner);\n\n    // Attempt to add to cache and handle disposal\n    if (add(inner)) {\n        if (inner.isDisposed()) {\n            remove(inner);\n        }\n        \n        // Ensure single subscription to source\n        if (once.compareAndSet(false, true)) {\n            source.subscribe(this);\n        }\n    } else {\n        // Handle cached result if available\n        Throwable ex = error;\n        if (ex != null) {\n            observer.onError(ex);\n        } else {\n            observer.onComplete();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "241", "src_id": "M961", "code": "\n@Override\npublic boolean tryOnError(Throwable t) {\n    // Validate error input\n    if (t == null) {\n        t = ExceptionHelper.createNullPointerException(\"onError called with a null Throwable.\");\n    }\n    \n    // Check disposal state and attempt to set\n    if (get() != DisposableHelper.DISPOSED) {\n        Disposable d = getAndSet(DisposableHelper.DISPOSED);\n        if (d != DisposableHelper.DISPOSED) {\n            try {\n                // Propagate error downstream\n                downstream.onError(t);\n            } finally {\n                // Cleanup resources\n                if (d != null) {\n                    d.dispose();\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "242", "src_id": "M453", "code": "\n@SuppressWarnings(\"unchecked\")\npublic static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source,\n        Observer<? super R> observer,\n        Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\n    // Handle Supplier sources directly\n    if (source instanceof Supplier) {\n        T t;\n        try {\n            t = ((Supplier<T>)source).get();\n        } catch (Throwable ex) {\n            // Handle fatal errors during value retrieval\n            Exceptions.throwIfFatal(ex);\n            EmptyDisposable.error(ex, observer);\n            return true;\n        }\n\n        // Handle null value from Supplier\n        if (t == null) {\n            EmptyDisposable.complete(observer);\n            return true;\n        }\n\n        ObservableSource<? extends R> r;\n        try {\n            // Apply mapping function\n            r = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            EmptyDisposable.error(ex, observer);\n            return true;\n        }\n\n        // Handle nested Supplier case\n        if (r instanceof Supplier) {\n            R u;\n            try {\n                u = ((Supplier<R>)r).get();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (u == null) {\n                EmptyDisposable.complete(observer);\n                return true;\n            }\n            \n            // Emit scalar value directly\n            ScalarDisposable<R> sd = new ScalarDisposable<>(observer, u);\n            observer.onSubscribe(sd);\n            sd.run();\n        } else {\n            // Subscribe to mapped source\n            r.subscribe(observer);\n        }\n        return true;\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "243", "src_id": "M267", "code": "\nvoid drainLoop() {\n    int missed = 1;\n    Observer<? super R> a = downstream;\n    AtomicInteger n = active;\n    AtomicReference<SpscLinkedArrayQueue<R>> qr = queue;\n\n    for (;;) {\n        for (;;) {\n            // Check cancellation state\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            // Handle errors without delay\n            if (!delayErrors) {\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    clear();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n            }\n\n            // Check completion and queue state\n            boolean d = n.get() == 0;\n            SpscLinkedArrayQueue<R> q = qr.get();\n            R v = q != null ? q.poll() : null;\n            boolean empty = v == null;\n\n            // Terminate if complete and empty\n            if (d && empty) {\n                errors.tryTerminateConsumer(a);\n                return;\n            }\n\n            // Break if no items available\n            if (empty) {\n                break;\n            }\n\n            // Emit next value\n            a.onNext(v);\n        }\n\n        // Update missed counter\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "244", "src_id": "M1163", "code": "\n@Override\nvoid drain() {\n    // Quick exit if already draining\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    final SimplePlainQueue<Object> queue = this.queue;\n    final Subscriber<? super Flowable<T>> downstream = this.downstream;\n    UnicastProcessor<T> window = this.window;\n\n    for (;;) {\n        // Handle cancellation cleanup\n        if (upstreamCancelled) {\n            queue.clear();\n            window = null;\n            this.window = null;\n        } else {\n            // Poll queue and check completion\n            boolean isDone = done;\n            Object o = queue.poll();\n            boolean isEmpty = o == null;\n\n            // Handle terminal state\n            if (isDone && isEmpty) {\n                Throwable ex = error;\n                if (ex != null) {\n                    if (window != null) {\n                        window.onError(ex);\n                    }\n                    downstream.onError(ex);\n                } else {\n                    if (window != null) {\n                        window.onComplete();\n                    }\n                    downstream.onComplete();\n                }\n                cleanupResources();\n                upstreamCancelled = true;\n                continue;\n            } else if (!isEmpty) {\n                // Process window boundary events\n                if (o instanceof WindowBoundaryRunnable) {\n                    WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                    if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                        this.count = 0;\n                        window = createNewWindow(window);\n                    }\n                } else if (window != null) {\n                    // Process regular items in window\n                    @SuppressWarnings(\"unchecked\")\n                    T item = (T)o;\n                    window.onNext(item);\n\n                    // Manage window size\n                    long count = this.count + 1;\n                    if (count == maxSize) {\n                        this.count = 0;\n                        window = createNewWindow(window);\n                    } else {\n                        this.count = count;\n                    }\n                }\n                continue;\n            }\n        }\n\n        // Update missed counter\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "245", "src_id": "M598", "code": "\nvoid drain() {\n    // Skip if already draining\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    Subscriber<? super R> a = downstream;\n    Iterator<? extends R> iterator = this.it;\n\n    // Handle fused output case\n    if (outputFused && iterator != null) {\n        a.onNext(null);\n        a.onComplete();\n        return;\n    }\n\n    int missed = 1;\n    for (;;) {\n        if (iterator != null) {\n            long r = requested.get();\n\n            // Fast path for unbounded requests\n            if (r == Long.MAX_VALUE) {\n                fastPath(a, iterator);\n                return;\n            }\n\n            long e = 0L;\n            // Process requested items\n            while (e != r) {\n                if (cancelled) {\n                    return;\n                }\n\n                R v;\n                try {\n                    v = Objects.requireNonNull(iterator.next(), \"The iterator returned a null value\");\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n                a.onNext(v);\n\n                if (cancelled) {\n                    return;\n                }\n                e++;\n\n                // Check iterator completion\n                boolean b;\n                try {\n                    b = iterator.hasNext();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n                if (!b) {\n                    a.onComplete();\n                    return;\n                }\n            }\n\n            // Update requested count\n            if (e != 0L) {\n                BackpressureHelper.produced(requested, e);\n            }\n        }\n\n        // Update missed counter\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n\n        // Refresh iterator reference\n        if (iterator == null) {\n            iterator = it;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "246", "src_id": "M1224", "code": "\nvoid drainLoop() {\n    Subscriber<? super T> actual = this.downstream;\n    int missed = 1;\n    long e = emitted;\n    int c = consumed;\n    int lim = limit;\n    \n    for (;;) {\n        long r = requested.get();\n\n        // Process items while below request count\n        while (e != r) {\n            // Check cancellation\n            if (cancelled) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            // Handle errors\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            // Handle special state item\n            int os = otherState;\n            if (os == OTHER_STATE_HAS_VALUE) {\n                T v = singleItem;\n                singleItem = null;\n                otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                actual.onNext(v);\n                e++;\n                continue;\n            }\n\n            // Poll main queue\n            boolean d = mainDone;\n            SimplePlainQueue<T> q = queue;\n            T v = q != null ? q.poll() : null;\n            boolean empty = v == null;\n\n            // Terminate if complete and empty\n            if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                queue = null;\n                actual.onComplete();\n                return;\n            }\n\n            // Break if no items\n            if (empty) {\n                break;\n            }\n\n            // Process item and update counters\n            actual.onNext(v);\n            e++;\n            if (++c == lim) {\n                c = 0;\n                mainSubscription.get().request(lim);\n            }\n        }\n\n        // Final checks after processing\n        if (e == r) {\n            if (cancelled) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            // Final termination check\n            boolean d = mainDone;\n            SimplePlainQueue<T> q = queue;\n            boolean empty = q == null || q.isEmpty();\n\n            if (d && empty && otherState == 2) {\n                queue = null;\n                actual.onComplete();\n                return;\n            }\n        }\n\n        // Update state and counters\n        emitted = e;\n        consumed = c;\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "247", "src_id": "M142", "code": "\n@Override\nvoid drain() {\n    // Skip if already draining\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    Subscriber<? super R> downstream = this.downstream;\n    ErrorMode errorMode = this.errorMode;\n    SimpleQueue<T> queue = this.queue;\n    AtomicThrowable errors = this.errors;\n    AtomicLong requested = this.requested;\n    int limit = prefetch - (prefetch >> 1);\n    boolean syncFused = this.syncFused;\n\n    for (;;) {\n        for (;;) {\n            // Handle cancellation\n            if (cancelled) {\n                queue.clear();\n                item = null;\n                break;\n            }\n\n            int s = state;\n            \n            // Handle errors based on error mode\n            if (errors.get() != null) {\n                if (errorMode == ErrorMode.IMMEDIATE ||\n                    (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) {\n                    queue.clear();\n                    item = null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n            }\n\n            // Process inactive state\n            if (s == STATE_INACTIVE) {\n                boolean d = done;\n                T v;\n                try {\n                    v = queue.poll();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.cancel();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                boolean empty = v == null;\n\n                // Terminate if done and empty\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                // Update consumption count\n                if (!syncFused) {\n                    int c = consumed + 1;\n                    if (c == limit) {\n                        consumed = 0;\n                        upstream.request(limit);\n                    } else {\n                        consumed = c;\n                    }\n                }\n\n                // Apply mapping function\n                MaybeSource<? extends R> ms;\n                try {\n                    ms = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.cancel();\n                    queue.clear();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                // Activate and subscribe\n                state = STATE_ACTIVE;\n                ms.subscribe(inner);\n                break;\n            } else if (s == STATE_RESULT_VALUE) {\n                // Emit result value if requested\n                long e = emitted;\n                if (e != requested.get()) {\n                    R w = item;\n                    item = null;\n                    downstream.onNext(w);\n                    emitted = e + 1;\n                    state = STATE_INACTIVE;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        // Update missed counter\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "248", "src_id": "M2196", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid remove(@NonNull SingleDisposable<T> inner) {\n    for (;;) {\n        SingleDisposable<T>[] a = observers.get();\n        int n = a.length;\n        if (n == 0) {\n            return;\n        }\n\n        // Find target index\n        int j = -1;\n        for (int i = 0; i < n; i++) {\n            if (a[i] == inner) {\n                j = i;\n                break;\n            }\n        }\n\n        if (j < 0) {\n            return;\n        }\n\n        // Create new array without target element\n        SingleDisposable<T>[] b;\n        if (n == 1) {\n            b = EMPTY;\n        } else {\n            b = new SingleDisposable[n - 1];\n            System.arraycopy(a, 0, b, 0, j);\n            System.arraycopy(a, j + 1, b, j, n - j - 1);\n        }\n\n        // Atomic update\n        if (observers.compareAndSet(a, b)) {\n            return;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "249", "src_id": "M2269", "code": "\n@Override\nprotected void subscribeActual(@NonNull Subscriber<? super T> s) {\n    // Initialize subscription\n    AsyncSubscription<T> as = new AsyncSubscription<>(s, this);\n    s.onSubscribe(as);\n\n    // Attempt to add to cache\n    if (add(as)) {\n        if (as.isCancelled()) {\n            remove(as);\n        }\n    } else {\n        // Handle cached result\n        Throwable ex = error;\n        if (ex != null) {\n            s.onError(ex);\n        } else {\n            T v = value;\n            if (v != null) {\n                as.complete(v);\n            } else {\n                as.onComplete();\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "250", "src_id": "M343", "code": "\nprivate static EmailContent extractEmailContentAdvanced(byte[] emlBytes, EmlToPdfRequest request) {\n  try {\n    Class<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n    Class<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n\n    Method getDefaultInstance = sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n    Object session = getDefaultInstance.invoke(null, new Properties());\n\n    Class<?>[] constructorArgs = new Class<?>[]{sessionClass, InputStream.class};\n    Constructor<?> mimeMessageConstructor = mimeMessageClass.getConstructor(constructorArgs);\n    Object message = mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n\n    return extractEmailContentAdvanced(message, request);\n\n  } catch (ReflectiveOperationException e) {\n    EmailContent content = new EmailContent();\n    content.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n    return content;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "251", "src_id": "M347", "code": "\nprivate static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, \n        String contentType, String encoding) {\n  attachmentInfo\n      .append(\"<div class=\\\"attachment-item\\\">\")\n      .append(\"<span class=\\\"attachment-icon\\\">\")\n      .append(MimeConstants.ATTACHMENT_MARKER)\n      .append(\"</span> \")\n      .append(\"<span class=\\\"attachment-name\\\">\")\n      .append(escapeHtml(filename))\n      .append(\"</span>\");\n\n  if (!contentType.isEmpty() || !encoding.isEmpty()) {\n    attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n    if (!contentType.isEmpty()) {\n      attachmentInfo.append(escapeHtml(contentType));\n    }\n    if (!encoding.isEmpty()) {\n      if (!contentType.isEmpty()) attachmentInfo.append(\", \");\n      attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n    }\n    attachmentInfo.append(\")</span>\");\n  }\n  attachmentInfo.append(\"</div>\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "252", "src_id": "M361", "code": "\nprivate static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n  try {\n    if (!isValidJakartaMailPart(part)) {\n      log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n      return;\n    }\n\n    Class<?> partClass = part.getClass();\n    Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n    Method getContent = partClass.getMethod(\"getContent\");\n    Method getDisposition = partClass.getMethod(\"getDisposition\");\n    Method getFileName = partClass.getMethod(\"getFileName\");\n    Method getContentType = partClass.getMethod(\"getContentType\");\n    Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n    Object disposition = getDisposition.invoke(part);\n    String filename = (String) getFileName.invoke(part);\n    String contentType = (String) getContentType.invoke(part);\n\n    if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n      content.setTextBody((String) getContent.invoke(part));\n    } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n      content.setHtmlBody((String) getContent.invoke(part));\n    } else if (\"attachment\".equalsIgnoreCase((String) disposition)\n        || (filename != null && !filename.trim().isEmpty())) {\n\n      content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n      if (filename != null && !filename.trim().isEmpty()) {\n        EmailAttachment attachment = new EmailAttachment();\n        attachment.setFilename(safeMimeDecode(filename));\n        attachment.setContentType(contentType);\n\n        String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n        if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n          attachment.setEmbedded(true);\n          String contentId = contentIdHeaders[0];\n          if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n            contentId = contentId.substring(1, contentId.length() - 1);\n          }\n          attachment.setContentId(contentId);\n        }\n\n        if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n          try {\n            Object attachmentContent = getContent.invoke(part);\n            byte[] attachmentData = null;\n\n            if (attachmentContent instanceof java.io.InputStream inputStream) {\n              try {\n                attachmentData = inputStream.readAllBytes();\n              } catch (IOException e) {\n                log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n              }\n            } else if (attachmentContent instanceof byte[] byteArray) {\n              attachmentData = byteArray;\n            } else if (attachmentContent instanceof String stringContent) {\n              attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n            }\n\n            if (attachmentData != null) {\n              long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n              long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n              if (attachmentData.length <= maxSizeBytes) {\n                attachment.setData(attachmentData);\n                attachment.setSizeBytes(attachmentData.length);\n              } else {\n                if (attachment.isEmbedded()) {\n                  attachment.setData(attachmentData);\n                  attachment.setSizeBytes(attachmentData.length);\n                } else {\n                  attachment.setSizeBytes(attachmentData.length);\n                }\n              }\n            }\n          } catch (Exception e) {\n            log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n          }\n        }\n\n        content.getAttachments().add(attachment);\n      }\n    } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n      try {\n        Object multipartContent = getContent.invoke(part);\n        Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n        if (multipartClass.isInstance(multipartContent)) {\n          processMultipartAdvanced(multipartContent, content, request);\n        }\n      } catch (Exception e) {\n        log.warn(\"Error processing multipart content: {}\", e.getMessage());\n      }\n    }\n\n  } catch (Exception e) {\n    log.warn(\"Error processing multipart part: {}\", e.getMessage());\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "253", "src_id": "M509", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n@Operation(\n    summary = \"Convert EML to PDF\",\n    description = \"This endpoint converts EML (email) files to PDF format with extensive\"\n        + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n        + \" and HTML debug output. Input: EML file, Output: PDF\"\n        + \" or HTML file. Type: SISO\")\npublic ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n\n  MultipartFile inputFile = request.getFileInput();\n  String originalFilename = inputFile.getOriginalFilename();\n\n  if (inputFile.isEmpty()) {\n    log.error(\"No file provided for EML to PDF conversion.\");\n    return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n  }\n\n  if (originalFilename == null || originalFilename.trim().isEmpty()) {\n    log.error(\"Filename is null or empty.\");\n    return ResponseEntity.badRequest()\n        .body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n  }\n\n  String lowerFilename = originalFilename.toLowerCase();\n  if (!lowerFilename.endsWith(\".eml\")) {\n    log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n    return ResponseEntity.badRequest()\n        .body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n  }\n\n  String baseFilename = Filenames.toSimpleFileName(originalFilename);\n\n  try {\n    byte[] fileBytes = inputFile.getBytes();\n\n    if (request.isDownloadHtml()) {\n      try {\n        String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n        log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n        return WebResponseUtils.bytesToWebResponse(\n            htmlContent.getBytes(StandardCharsets.UTF_8),\n            baseFilename + \".html\",\n            MediaType.TEXT_HTML);\n      } catch (IOException | IllegalArgumentException e) {\n        log.error(\"HTML conversion failed for {}\", originalFilename, e);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n      }\n    }\n\n    try {\n      byte[] pdfBytes = EmlToPdf.convertEmlToPdf(\n          runtimePathConfig.getWeasyPrintPath(),\n          request,\n          fileBytes,\n          originalFilename,\n          false,\n          pdfDocumentFactory,\n          tempFileManager);\n\n      if (pdfBytes == null || pdfBytes.length == 0) {\n        log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n      }\n      log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n      return WebResponseUtils.bytesToWebResponse(\n          pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n          .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n    } catch (IllegalArgumentException | RuntimeException e) {\n      String errorMessage = buildErrorMessage(e, originalFilename);\n      log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n          .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n    }\n\n  } catch (IOException e) {\n    log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n        .body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "254", "src_id": "M1281", "code": "\n    @Override\n    protected void subscribeActual(Subscriber<? super T> s) {\n        PublishConnection<T> conn;\n\n        for (;;) {\n            conn = current.get();\n\n            // don't create a fresh connection if the current is disposed\n            if (conn == null) {\n                PublishConnection<T> fresh = new PublishConnection<>(current, bufferSize);\n                if (!current.compareAndSet(conn, fresh)) {\n                    continue;\n                }\n                conn = fresh;\n            }\n\n            break;\n        }\n\n        InnerSubscription<T> inner = new InnerSubscription<>(s, conn);\n        s.onSubscribe(inner);\n\n        if (conn.add(inner)) {\n            if (inner.isCancelled()) {\n                conn.remove(inner);\n            } else {\n                conn.drain();\n            }\n            return;\n        }\n\n        Throwable ex = conn.error;\n        if (ex != null) {\n            inner.downstream.onError(ex);\n        } else {\n            inner.downstream.onComplete();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "255", "src_id": "M1061", "code": "\n        @Override\n        Node getHead() {\n            long timeLimit = scheduler.now(unit) - maxAge;\n            Node prev = get();\n            Node next = prev.get();\n            \n            for (;;) {\n                if (next == null) {\n                    break;\n                }\n                Timed<?> v = (Timed<?>) next.value;\n                if (NotificationLite.isComplete(v.value()) || NotificationLite.isError(v.value())) {\n                    break;\n                }\n                if (v.time() <= timeLimit) {\n                    prev = next;\n                    next = next.get();\n                } else {\n                    break;\n                }\n            }\n            return prev;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "256", "src_id": "M125", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super R> downstream = this.downstream;\n            AtomicThrowable errors = this.errors;\n            AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n            AtomicLong requested = this.requested;\n            long emitted = this.emitted;\n\n            for (;;) {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n                    if (errors.get() != null) {\n                        if (!delayErrors) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    boolean d = done;\n                    SwitchMapMaybeObserver<R> current = inner.get();\n                    boolean empty = current == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty || current.item == null || emitted == requested.get()) {\n                        break;\n                    }\n\n                    inner.compareAndSet(current, null);\n                    downstream.onNext(current.item);\n                    emitted++;\n                }\n\n                this.emitted = emitted;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "257", "src_id": "M341", "code": "\n        @Override\n        public void run() {\n            for (;;) {\n                if (disposed) {\n                    queue.clear();\n                    return;\n                }\n                if (!active) {\n                    boolean d = done;\n                    T t;\n\n                    try {\n                        t = queue.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        dispose();\n                        queue.clear();\n                        downstream.onError(ex);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = t == null;\n\n                    if (d && empty) {\n                        disposed = true;\n                        downstream.onComplete();\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        ObservableSource<? extends U> o;\n\n                        try {\n                            o = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            dispose();\n                            queue.clear();\n                            downstream.onError(ex);\n                            worker.dispose();\n                            return;\n                        }\n\n                        active = true;\n                        o.subscribe(inner);\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "258", "src_id": "M55", "code": "\n        @Override\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Observer<? super R> downstream = this.downstream;\n            ErrorMode errorMode = this.errorMode;\n            SimpleQueue<T> queue = this.queue;\n            AtomicThrowable errors = this.errors;\n\n            for (;;) {\n                for (;;) {\n                    if (disposed) {\n                        queue.clear();\n                        item = null;\n                        break;\n                    }\n\n                    int s = state;\n\n                    if (errors.get() != null) {\n                        if (errorMode == ErrorMode.IMMEDIATE\n                                || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) {\n                            queue.clear();\n                            item = null;\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    if (s == STATE_INACTIVE) {\n                        boolean d = done;\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            disposed = true;\n                            upstream.dispose();\n                            errors.tryAddThrowableOrReport(ex);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n\n                        MaybeSource<? extends R> ms;\n\n                        try {\n                            ms = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            upstream.dispose();\n                            queue.clear();\n                            errors.tryAddThrowableOrReport(ex);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        state = STATE_ACTIVE;\n                        ms.subscribe(inner);\n                        break;\n                    } else if (s == STATE_RESULT_VALUE) {\n                        R w = item;\n                        item = null;\n                        downstream.onNext(w);\n                        state = STATE_INACTIVE;\n                    } else {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "259", "src_id": "M1425", "code": "\n        @Override\n        public void run() {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n                    boolean d = done;\n\n                    if (d && !veryEnd) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            Supplier<R> supplier = (Supplier<R>) p;\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null || cancelled) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "260", "src_id": "M1003", "code": "\n        void drain() {\n            if (wip.getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            SimpleQueue<T> q = queue;\n            int upstreamConsumed = consumed;\n            int localLimit = limit;\n            boolean canRequest = sourceMode != QueueSubscription.SYNC;\n            AtomicReference<MulticastSubscription<T>[]> subs = subscribers;\n            MulticastSubscription<T>[] array = subs.get();\n\n            outer:\n            for (;;) {\n                int n = array.length;\n\n                if (q != null && n != 0) {\n                    long r = Long.MAX_VALUE;\n\n                    for (MulticastSubscription<T> ms : array) {\n                        long u = ms.get() - ms.emitted;\n                        if (u != Long.MIN_VALUE) {\n                            if (r > u) {\n                                r = u;\n                            }\n                        } else {\n                            n--;\n                        }\n                    }\n\n                    if (n == 0) {\n                        r = 0;\n                    }\n\n                    while (r != 0) {\n                        if (isDisposed()) {\n                            q.clear();\n                            return;\n                        }\n\n                        boolean d = done;\n\n                        if (d && !delayError) {\n                            Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            SubscriptionHelper.cancel(upstream);\n                            errorAll(ex);\n                            return;\n                        }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                            } else {\n                                completeAll();\n                            }\n                            return;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n\n                        boolean subscribersChange = false;\n\n                        for (MulticastSubscription<T> ms : array) {\n                            long msr = ms.get();\n                            if (msr != Long.MIN_VALUE) {\n                                if (msr != Long.MAX_VALUE) {\n                                    ms.emitted++;\n                                }\n                                ms.downstream.onNext(v);\n                            } else {\n                                subscribersChange = true;\n                            }\n                        }\n\n                        r--;\n                        if (canRequest && ++upstreamConsumed == localLimit) {\n                            upstreamConsumed = 0;\n                            upstream.get().request(localLimit);\n                        }\n\n                        MulticastSubscription<T>[] freshArray = subs.get();\n                        if (subscribersChange || freshArray != array) {\n                            array = freshArray;\n                            continue outer;\n                        }\n                    }\n\n                    if (r == 0) {\n                        if (isDisposed()) {\n                            q.clear();\n                            return;\n                        }\n\n                        boolean d = done;\n\n                        if (d && !delayError) {\n                            Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                                return;\n                            }\n                        }\n\n                        if (d && q.isEmpty()) {\n                            Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                            } else {\n                                completeAll();\n                            }\n                            return;\n                        }\n                    }\n                }\n\n                consumed = upstreamConsumed;\n                missed = wip.addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n                if (q == null) {\n                    q = queue;\n                }\n                array = subs.get();\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "261", "src_id": "M1237", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            final Subscriber<? super R> a = downstream;\n            final ZipSubscriber<T, R>[] qs = subscribers;\n            final int n = qs.length;\n            Object[] values = current;\n            int missed = 1;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0L;\n\n                while (r != e) {\n                    if (cancelled) {\n                        return;\n                    }\n                    if (!delayErrors && errors.get() != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    boolean empty = false;\n\n                    for (int j = 0; j < n; j++) {\n                        ZipSubscriber<T, R> inner = qs[j];\n                        if (values[j] == null) {\n                            boolean d = inner.done;\n                            SimpleQueue<T> q = inner.queue;\n                            T v = null;\n                            \n                            try {\n                                v = q != null ? q.poll() : null;\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n                                d = true;\n                            }\n\n                            boolean sourceEmpty = v == null;\n                            if (d && sourceEmpty) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            if (!sourceEmpty) {\n                                values[j] = v;\n                            } else {\n                                empty = true;\n                            }\n                        }\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    R v;\n\n                    try {\n                        v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelAll();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    a.onNext(v);\n                    e++;\n                    Arrays.fill(values, null);\n                }\n\n                if (r == e) {\n                    if (cancelled) {\n                        return;\n                    }\n                    if (!delayErrors && errors.get() != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    for (int j = 0; j < n; j++) {\n                        ZipSubscriber<T, R> inner = qs[j];\n                        if (values[j] == null) {\n                            boolean d = inner.done;\n                            SimpleQueue<T> q = inner.queue;\n                            T v = null;\n                            \n                            try {\n                                v = q != null ? q.poll() : null;\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n                                d = true;\n                            }\n                            \n                            boolean empty = v == null;\n                            if (d && empty) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            if (!empty) {\n                                values[j] = v;\n                            }\n                        }\n                    }\n                }\n\n                if (e != 0L) {\n                    for (ZipSubscriber<T, R> inner : qs) {\n                        inner.request(e);\n                    }\n\n                    if (r != Long.MAX_VALUE) {\n                        requested.addAndGet(-e);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "262", "src_id": "M558", "code": "\n        void innerSuccess(InnerObserver inner, R value) {\n            set.delete(inner);\n            if (get() == 0 && compareAndSet(0, 1)) {\n                downstream.onNext(value);\n\n                boolean d = active.decrementAndGet() == 0;\n                SpscLinkedArrayQueue<R> q = queue.get();\n\n                if (d && (q == null || q.isEmpty())) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (decrementAndGet() == 0) {\n                    return;\n                }\n            } else {\n                SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n                synchronized (q) {\n                    q.offer(value);\n                }\n                active.decrementAndGet();\n                if (getAndIncrement() != 0) {\n                    return;\n                }\n            }\n            drainLoop();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "263", "src_id": "M2273", "code": "\n    @Override\n    public void onSubscribe(Subscription s) {\n        boolean cancel;\n        if (!done) {\n            synchronized (this) {\n                if (done) {\n                    cancel = true;\n                } else {\n                    if (emitting) {\n                        AppendOnlyLinkedArrayList<Object> q = queue;\n                        if (q == null) {\n                            q = new AppendOnlyLinkedArrayList<>(4);\n                            queue = q;\n                        }\n                        q.add(NotificationLite.subscription(s));\n                        return;\n                    }\n                    emitting = true;\n                    cancel = false;\n                }\n            }\n        } else {\n            cancel = true;\n        }\n        \n        if (cancel) {\n            s.cancel();\n        } else {\n            actual.onSubscribe(s);\n            emitLoop();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "264", "src_id": "M520", "code": "\n@Override\npublic void close() throws IOException {\n    boolean triedToClose = false, success = false;\n    try {\n        flush();\n        ((FileOutputStream) out).getFD().sync();\n\n        triedToClose = true;\n        super.close();\n        success = true;\n    } finally {\n        if (success) {\n            boolean renamed = tmpFile.renameTo(origFile);\n            if (!renamed) {\n                // On windows, renameTo does not replace.\n                if (!origFile.delete() || !tmpFile.renameTo(origFile)) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            }\n        } else {\n            if (!triedToClose) {\n                // If we failed when flushing, try to close it to not leak an FD\n                IOUtils.closeStream(out);\n            }\n            // close wasn't successful, try to delete the tmp file\n            if (!tmpFile.delete()) {\n                LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "265", "src_id": "M1043", "code": "\nvoid handleWrite(SelectionKey k) throws IOException {\n    if (outgoingBuffers.isEmpty()) {\n        return;\n    }\n\n    /*\n     * This is going to reset the buffer position to 0 and the\n     * limit to the size of the buffer, so that we can fill it\n     * with data from the non-direct buffers that we need to\n     * send.\n     */\n    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n    if (directBuffer == null) {\n        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n        // Use gathered write call. This updates the positions of the\n        // byte buffers to reflect the bytes that were written out.\n        sock.write(outgoingBuffers.toArray(bufferList));\n\n        // Remove the buffers that we have sent\n        ByteBuffer bb;\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (bb.remaining() > 0) {\n                break;\n            }\n            outgoingBuffers.remove();\n        }\n    } else {\n        directBuffer.clear();\n\n        for (ByteBuffer b : outgoingBuffers) {\n            if (directBuffer.remaining() < b.remaining()) {\n                /*\n                 * When we call put later, if the directBuffer is to\n                 * small to hold everything, nothing will be copied,\n                 * so we've got to slice the buffer if it's too big.\n                 */\n                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n            }\n            /*\n             * put() is going to modify the positions of both\n             * buffers, put we don't want to change the position of\n             * the source buffers (we'll do that after the send, if\n             * needed), so we save and reset the position after the\n             * copy\n             */\n            int p = b.position();\n            directBuffer.put(b);\n            b.position(p);\n            if (directBuffer.remaining() == 0) {\n                break;\n            }\n        }\n        /*\n         * Do the flip: limit becomes position, position gets set to\n         * 0. This sets us up for the write.\n         */\n        directBuffer.flip();\n\n        int sent = sock.write(directBuffer);\n\n        ByteBuffer bb;\n\n        // Remove the buffers that we have sent\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (sent < bb.remaining()) {\n                /*\n                 * We only partially sent this buffer, so we update\n                 * the position and exit the loop.\n                 */\n                bb.position(bb.position() + sent);\n                break;\n            }\n            /* We've sent the whole buffer, so drop the buffer */\n            sent -= bb.remaining();\n            outgoingBuffers.remove();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "266", "src_id": "M196", "code": "\npublic static void main(String[] args) throws IOException {\t\n    MergedLogSource source = new MergedLogSource(args);\n\n    PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n    PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n    PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n    PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n    LogIterator iter;\n    \n    System.out.println(source);\n    iter = source.iterator();\n    long currentms = 0;\n    long currentsec = 0;\n    long currentmin = 0;\n    long currenthour = 0;\n    Set<Long> zxids_ms = new HashSet<>();\n    long zxid_sec = 0;\n    long zxid_min = 0;\n    long zxid_hour = 0;\n\n    while (iter.hasNext()) {\n        LogEntry e = iter.next();\n        TransactionEntry cxn = (TransactionEntry)e;\n        \n        long ms = cxn.getTimestamp();\n        long sec = ms/MS_PER_SEC;\n        long min = ms/MS_PER_MIN;\n        long hour = ms/MS_PER_HOUR;\n\n        if (currentms != ms && currentms != 0) {\n            ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n\n            zxid_sec += zxids_ms.size();\n            zxid_min += zxids_ms.size();\n            zxid_hour += zxids_ms.size();\n            zxids_ms.clear();\n        }\n\n        if (currentsec != sec && currentsec != 0) {\n            ps_sec.println(\"\" + currentsec*MS_PER_SEC + \" \" + zxid_sec);\n\n            zxid_sec = 0;\n        }\n\n        if (currentmin != min && currentmin != 0) {\n            ps_min.println(\"\" + currentmin*MS_PER_MIN + \" \" + zxid_min);\n            \n            zxid_min = 0;\n        }\n\n        if (currenthour != hour && currenthour != 0) {\n            ps_hour.println(\"\" + currenthour*MS_PER_HOUR + \" \" + zxid_hour);\n            \n            zxid_hour = 0;\n        }\n\n        currentms = ms;\n        currentsec = sec;\n        currentmin = min;\n        currenthour = hour;\n\n        zxids_ms.add(cxn.getZxid());\n    }\n\n    iter.close();\n    ps_ms.close();\n    ps_sec.close();\n    ps_min.close();\n    ps_hour.close();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "267", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        // Close connections still pending on the selector. Any others\n        // with in-flight work, let drain out of the work queue.\n        for (SelectionKey key : selector.keys()) {\n            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        // This will wake up the accept thread and the other selector\n        // threads, and tell the worker thread pool to begin shutdown.\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "268", "src_id": "M290", "code": "\npublic String getStatus(String name, long timeout) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    byte[] data = null;\n    long endTime = Time.currentElapsedTime() + timeout;\n    KeeperException lastException = null;\n    for(int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n        try {\n            data = zk.getData(reportsNode + '/' + name, false, stat);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Got Data: {}\", (data == null) ? \"null\" : new String(data));\n            }\n            lastException = null;\n            break;\n        } catch(ConnectionLossException e) {\n            lastException = e;\n        } catch(NoNodeException e) {\n            final Object eventObj = new Object();\n            synchronized(eventObj) {\n                // wait for the node to appear\n                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {\n                    public void process(WatchedEvent event) {\n                        synchronized(eventObj) {\n                            eventObj.notifyAll();\n                        }\n                    }});\n                if (eStat == null) {\n                    eventObj.wait(endTime - Time.currentElapsedTime());\n                }\n            }\n            lastException = e;\n        }\n    }\n    if (lastException != null) {\n        throw lastException;\n    }\n    return new String(data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "269", "src_id": "M192", "code": "\nprivate void init() throws IOException {\n    File f = new File(file);\n    RandomAccessFileReader in = new RandomAccessFileReader(f);\n    SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n    Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n\n    long lastFp = in.getPosition();\n    String line = in.readLine();\n    Matcher m = null;\n\n    // if we have read data from the file, and it matches the timep pattern\n    if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n        starttime = timestampFromText(dateformat, m.group(1));\n    } else {\n        throw new IOException(\"Invalid log format. First line doesn't start with time\");\n    }\n\n    /*\n      Count number of log entries. Any line starting with a timestamp counts as an entry\n    */\n    String lastentry = line;\n    try {\n        while (line != null) {\n            m = timep.matcher(line);\n            if (m.lookingAt()) {\n                if (size % skipN == 0) {\n                    long time = timestampFromText(dateformat, m.group(1));\n                    skiplist.addMark(time, lastFp, size);\n                }\n                size++;\n                lastentry = line;\n            } \n            if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                serverid = Integer.valueOf(m.group(1));\n            }\n\n            lastFp = in.getPosition();\n            line = in.readLine();\n        }\n    } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n    } finally {\n        in.close();\n    }\n\n    m = timep.matcher(lastentry);\n    if (m.lookingAt()) {\n        endtime = timestampFromText(dateformat, m.group(1));\n    } else {\n        throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "270", "src_id": "M254", "code": "\nprivate void distributedConfigureServers(int count) throws IOException {\n    StringBuilder sbClient = new StringBuilder();\n    StringBuilder sbServer = new StringBuilder();\n    try {\n        for(int i = 0; i < count; i++) {\n            String r[] = QuorumPeerInstance.createServer(im, i);\n            if (i > 0) {\n                sbClient.append(',');\n                sbServer.append(',');\n            }\n            sbClient.append(r[0]); // r[0] == \"host:clientPort\"\n            sbServer.append(r[1]); // r[1] == \"host:leaderPort:leaderElectionPort\"\n            sbServer.append(\";\"+(r[0].split(\":\"))[1]); // Appending \";clientPort\"\n        }\n        serverHostPort = sbClient.toString();\n        quorumHostPort = sbServer.toString();\n    } catch(Exception e) {\n        IOException ioe = new IOException(e.getMessage());\n        ioe.setStackTrace(e.getStackTrace());\n        throw ioe;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "271", "src_id": "M40", "code": "\nprotected void animateVertically(int posx, int fromY, int toY) throws InterruptedException {\n    toaster.setLocation(posx, fromY);\n    if (toY < fromY) {\n        for (int i = fromY; i > toY; i -= step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    } else {\n        for (int i = fromY; i < toY; i += step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    }\n    toaster.setLocation(posx, toY);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "272", "src_id": "M1130", "code": "\npublic synchronized Map<String, Object> getConnectionInfo(boolean brief) {\n    Map<String, Object> info = new LinkedHashMap<>();\n    info.put(\"remote_socket_address\", getRemoteSocketAddress());\n    info.put(\"interest_ops\", getInterestOps());\n    info.put(\"outstanding_requests\", getOutstandingRequests());\n    info.put(\"packets_received\", getPacketsReceived());\n    info.put(\"packets_sent\", getPacketsSent());\n    if (!brief) {\n        info.put(\"session_id\", getSessionId());\n        info.put(\"last_operation\", getLastOperation());\n        info.put(\"established\", getEstablished());\n        info.put(\"session_timeout\", getSessionTimeout());\n        info.put(\"last_cxid\", getLastCxid());\n        info.put(\"last_zxid\", getLastZxid());\n        info.put(\"last_response_time\", getLastResponseTime());\n        info.put(\"last_latency\", getLastLatency());\n        info.put(\"min_latency\", getMinLatency());\n        info.put(\"avg_latency\", getAvgLatency());\n        info.put(\"max_latency\", getMaxLatency());\n    }\n    return info;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "273", "src_id": "M1036", "code": "\npublic void start() {\n  if (running || isFinished() || urls.length < 1) {\n    return;\n  }\n\n  joinForThreads(10000); // ensure previous state is paused\n\n  running = true;\n  errCode = ERROR_NOTHING;\n\n  if (hasInvalidStorage()) {\n    notifyError(ERROR_FILE_CREATION, null);\n    return;\n  }\n\n  if (current >= urls.length) {\n    notifyFinished();\n    return;\n  }\n\n  notify(DownloadManagerService.MESSAGE_RUNNING);\n\n  if (urls[current] == null) {\n    doRecover(ERROR_RESOURCE_GONE);\n    return;\n  }\n\n  if (blocks == null) {\n    initializer();\n    return;\n  }\n\n  init = null;\n  finishCount = 0;\n  blockAcquired = new boolean[blocks.length];\n\n  if (blocks.length < 1) {\n    threads = new Thread[] { runAsync(1, new DownloadRunnableFallback(this)) };\n  } else {\n    int remainingBlocks = 0;\n    for (int block : blocks) {\n      if (block >= 0) remainingBlocks++;\n    }\n\n    if (remainingBlocks < 1) {\n      notifyFinished();\n      return;\n    }\n\n    threads = new Thread[Math.min(threadCount, remainingBlocks)];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = runAsync(i + 1, new DownloadRunnable(this, i));\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "274", "src_id": "M803", "code": "\npublic void parse() throws IOException, NoSuchElementException {\n  if (selectedTrack > -1) return;\n\n  box = readBox(ATOM_FTYP);\n  brands = parseFtyp(box);\n  switch (brands[0]) {\n    case BRAND_DASH:\n    case BRAND_ISO5: // why not?\n      break;\n    default:\n      throw new NoSuchElementException(\n        \"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \" + boxName(brands[0])\n      );\n  }\n\n  Moov moov = null;\n  int i;\n\n  while (box.type != ATOM_MOOF) {\n    ensure(box);\n    box = readBox();\n\n    switch (box.type) {\n      case ATOM_MOOV: moov = parseMoov(box); break;\n      case ATOM_SIDX:\n      case ATOM_MFRA: break;\n    }\n  }\n\n  if (moov == null) {\n    throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n  }\n\n  tracks = new Mp4Track[moov.trak.length];\n  for (i = 0; i < tracks.length; i++) {\n    tracks[i] = new Mp4Track();\n    tracks[i].trak = moov.trak[i];\n\n    if (moov.mvexTrex != null) {\n      for (final Trex mvexTrex : moov.mvexTrex) {\n        if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n          tracks[i].trex = mvexTrex;\n        }\n      }\n    }\n\n    switch (moov.trak[i].mdia.hdlr.subType) {\n      case HANDLER_VIDE: tracks[i].kind = TrackKind.Video; break;\n      case HANDLER_SOUN: tracks[i].kind = TrackKind.Audio; break;\n      case HANDLER_SUBT: tracks[i].kind = TrackKind.Subtitles; break;\n      default: tracks[i].kind = TrackKind.Other; break;\n    }\n  }\n\n  backupBox = box;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "275", "src_id": "M1031", "code": "\nvoid establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n  int statusCode = conn.getResponseCode();\n\n  if (DEBUG) {\n    Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n    Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n    Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n    Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n  }\n\n  switch (statusCode) {\n    case 204:\n    case 205:\n    case 207:\n      throw new HttpError(statusCode);\n    case 416:\n      return; // let download thread handle\n    default:\n      if (statusCode < 200 || statusCode > 299) {\n        throw new HttpError(statusCode);\n      }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "276", "src_id": "M827", "code": "\nprivate Elst parseEdts(final Box ref) throws IOException {\n  final Box b = untilBox(ref, ATOM_ELST);\n  if (b == null) return null;\n\n  final Elst obj = new Elst();\n  final boolean v1 = stream.read() == 1;\n  stream.skipBytes(3); // flags\n\n  final int entryCount = stream.readInt();\n  if (entryCount < 1) {\n    obj.bMediaRate = 0x00010000; // default media rate (1.0)\n    return obj;\n  }\n\n  if (v1) {\n    stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n    obj.mediaTime = stream.readLong();\n    // ignore remaining entries\n    stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n  } else {\n    stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n    obj.mediaTime = stream.readInt();\n  }\n\n  obj.bMediaRate = stream.readInt();\n  return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "277", "src_id": "M1144", "code": "\n@Override\npublic void write(byte[] b, int off, int len) throws IOException {\n  if (len == 0) return;\n\n  long available;\n  long offsetOut = out.getOffset();\n  long offsetAux = aux.getOffset();\n  long end = callback.check();\n\n  if (end == -1) {\n    available = Integer.MAX_VALUE;\n  } else if (end < offsetOut) {\n    throw new IOException(\"The reported offset is invalid: \" + end + \"<\" + offsetOut);\n  } else {\n    available = end - offsetOut;\n  }\n\n  boolean usingAux = aux.length > 0 && offsetOut >= out.length;\n  boolean underflow = offsetAux < aux.length || offsetOut < out.length;\n\n  if (usingAux) {\n    long length = offsetAux + len;\n    if (underflow) {\n      if (aux.length > length) length = aux.length;\n    } else {\n      length = aux.length + len;\n    }\n\n    aux.write(b, off, len);\n\n    if (length >= THRESHOLD_AUX_LENGTH && length <= available) {\n      flushAuxiliar(available);\n    }\n  } else {\n    if (underflow) {\n      available = out.length - offsetOut;\n    }\n\n    int length = Math.min(len, (int) Math.min(Integer.MAX_VALUE, available));\n    out.write(b, off, length);\n\n    len -= length;\n    off += length;\n\n    if (len > 0) {\n      aux.write(b, off, len);\n    }\n  }\n\n  if (onProgress != null) {\n    long absoluteOffset = out.getOffset() + aux.getOffset();\n    if (absoluteOffset > reportPosition) {\n      reportPosition = absoluteOffset + NOTIFY_BYTES_INTERVAL;\n      onProgress.report(absoluteOffset);\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "278", "src_id": "M1048", "code": "\n@Override\npublic void run() {\n  boolean done;\n  long start = mMission.fallbackResumeOffset;\n\n  if (DEBUG && !mMission.unknownLength && start > 0) {\n    Log.i(TAG, \"Resuming single-thread download at \" + start);\n  }\n\n  try {\n    long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n    int mId = 1;\n    mConn = mMission.openConnection(false, rangeStart, -1);\n\n    if (mRetryCount == 0 && rangeStart == -1) {\n      mConn.setRequestProperty(\"Range\", \"bytes=0-\"); // bypass connection pool\n    }\n\n    mMission.establishConnection(mId, mConn);\n\n    if (mConn.getResponseCode() == 416 && start > 0) {\n      mMission.notifyProgress(-start);\n      start = 0;\n      mRetryCount--;\n      throw new DownloadMission.HttpError(416);\n    }\n\n    if (!mMission.unknownLength) {\n      mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n    }\n\n    if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n      mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n    }\n\n    mF = mMission.storage.getStream();\n    mF.seek(mMission.offsets[mMission.current] + start);\n\n    mIs = mConn.getInputStream();\n    byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n    int len = 0;\n\n    while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n      mF.write(buf, 0, len);\n      start += len;\n      mMission.notifyProgress(len);\n    }\n\n    dispose();\n    done = len == -1; // check if last part written\n  } catch (Exception e) {\n    dispose();\n    mMission.fallbackResumeOffset = start;\n\n    if (!mMission.running || e instanceof ClosedByInterruptException) return;\n\n    if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n      dispose();\n      mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n      return;\n    }\n\n    if (mRetryCount++ >= mMission.maxRetry) {\n      mMission.notifyError(e);\n      return;\n    }\n\n    if (DEBUG) Log.e(TAG, \"Exception, retrying...\", e);\n    run(); // retry\n    return;\n  }\n\n  if (done) {\n    mMission.notifyFinished();\n  } else {\n    mMission.fallbackResumeOffset = start;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "279", "src_id": "M1086", "code": "\nprivate ArrayList<Object> getSpecialItems() {\n  synchronized (DownloadManager.this) {\n    ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n    ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n    List<Mission> remove = new ArrayList<>(hidden);\n\n    remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n    int fakeTotal = pending.size();\n    if (fakeTotal > 0) fakeTotal++;\n    fakeTotal += finished.size();\n    if (finished.size() > 0) fakeTotal++;\n\n    ArrayList<Object> list = new ArrayList<>(fakeTotal);\n    if (pending.size() > 0) {\n      list.add(PENDING);\n      list.addAll(pending);\n    }\n    if (finished.size() > 0) {\n      list.add(FINISHED);\n      list.addAll(finished);\n    }\n\n    hasFinished = finished.size() > 0;\n    return list;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "280", "src_id": "M1067", "code": "\nvoid startMission(DownloadMission mission) {\n  synchronized (this) {\n    mission.timestamp = System.currentTimeMillis();\n    mission.mHandler = mHandler;\n    mission.maxRetry = mPrefMaxRetry;\n\n    while (true) {\n      mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n      if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n        try {\n          if (!mission.metadata.createNewFile()) {\n            throw new RuntimeException(\"Can't create metadata file\");\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n        break;\n      }\n      mission.timestamp = System.currentTimeMillis();\n    }\n\n    mSelfMissionsControl = true;\n    mMissionsPending.add(mission);\n    Utility.writeToFile(mission.metadata, mission); // save metadata\n\n    if (mission.storage == null) {\n      mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n      if (mission.errObject != null) {\n        mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n      }\n      return;\n    }\n\n    boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n    if (canDownloadInCurrentNetwork() && start) {\n      mission.start();\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "281", "src_id": "M1117", "code": "\nprivate void showPopupMenu() {\n  retry.setVisible(false);\n  cancel.setVisible(false);\n  start.setVisible(false);\n  pause.setVisible(false);\n  open.setVisible(false);\n  queue.setVisible(false);\n  showError.setVisible(false);\n  delete.setVisible(false);\n  source.setVisible(false);\n  checksum.setVisible(false);\n\n  DownloadMission mission = item.mission instanceof DownloadMission \n    ? (DownloadMission) item.mission : null;\n\n  if (mission != null) {\n    if (mission.hasInvalidStorage()) {\n      retry.setVisible(true);\n      delete.setVisible(true);\n      showError.setVisible(true);\n    } else if (mission.isPsRunning()) {\n      switch (mission.errCode) {\n        case ERROR_INSUFFICIENT_STORAGE:\n        case ERROR_POSTPROCESSING_HOLD:\n          retry.setVisible(true);\n          cancel.setVisible(true);\n          showError.setVisible(true);\n          break;\n      }\n    } else {\n      if (mission.running) {\n        pause.setVisible(true);\n      } else {\n        if (mission.errCode != ERROR_NOTHING) {\n          showError.setVisible(true);\n        }\n        queue.setChecked(mission.enqueued);\n        delete.setVisible(true);\n\n        boolean flag = !mission.isPsFailed() && mission.urls.length > 0;\n        start.setVisible(flag);\n        queue.setVisible(flag);\n      }\n    }\n  } else {\n    open.setVisible(true);\n    delete.setVisible(true);\n    checksum.setVisible(true);\n  }\n\n  if (item.mission.source != null && !item.mission.source.isEmpty()) {\n    source.setVisible(true);\n  }\n  popupMenu.show();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "282", "src_id": "M362", "code": "\nvoid drainFused() {\n  int missed = 1;\n\n  for (;;) {\n    if (disposed) {\n      return;\n    }\n\n    boolean d = done;\n    Throwable ex = error;\n\n    if (!delayError && d && null != ex) {\n      disposed = true;\n      downstream.onError(error);\n      worker.dispose();\n      return;\n    }\n\n    downstream.onNext(null);\n\n    if (d) {\n      disposed = true;\n      ex = error;\n      if (null != ex) {\n        downstream.onError(ex);\n      } else {\n        downstream.onComplete();\n      }\n      worker.dispose();\n      return;\n    }\n\n    missed = addAndGet(-missed);\n    if (missed == 0) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "283", "src_id": "M1685", "code": "\nvoid dispose(List<Disposable> set) {\n  if (null == set) {\n    return;\n  }\n  List<Throwable> errors = null;\n  for (Disposable o : set) {\n    try {\n      o.dispose();\n    } catch (Throwable ex) {\n      Exceptions.throwIfFatal(ex);\n      if (null == errors) {\n        errors = new ArrayList<>();\n      }\n      errors.add(ex);\n    }\n  }\n  if (null != errors) {\n    if (1 == errors.size()) {\n      throw ExceptionHelper.wrapOrThrow(errors.get(0));\n    }\n    throw new CompositeException(errors);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "284", "src_id": "M1503", "code": "\n@Override\npublic void onComplete() {\n  if (0 == wip.getAndIncrement()) {\n    Publisher<? extends T>[] sources = this.sources;\n    int n = sources.length;\n    int i = index;\n    for (;;) {\n\n      if (i == n) {\n        List<Throwable> list = errors;\n        if (null != list) {\n          if (1 == list.size()) {\n            downstream.onError(list.get(0));\n          } else {\n            downstream.onError(new CompositeException(list));\n          }\n        } else {\n          downstream.onComplete();\n        }\n        return;\n      }\n\n      Publisher<? extends T> p = sources[i];\n\n      if (null == p) {\n        Throwable ex = new NullPointerException(\"A Publisher entry is null\");\n        if (delayError) {\n          List<Throwable> list = errors;\n          if (null == list) {\n            list = new ArrayList<>(n - i + 1);\n            errors = list;\n          }\n          list.add(ex);\n          i++;\n          continue;\n        } else {\n          downstream.onError(ex);\n          return;\n        }\n      } else {\n        long r = produced;\n        if (0 != r) {\n          produced = 0L;\n          produced(r);\n        }\n        p.subscribe(this);\n      }\n\n      index = ++i;\n\n      if (0 == wip.decrementAndGet()) {\n        break;\n      }\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "285", "src_id": "M470", "code": "\nvoid replay(CacheDisposable<T> consumer) {\n  if (0 != consumer.getAndIncrement()) {\n    return;\n  }\n\n  int missed = 1;\n  long index = consumer.index;\n  int offset = consumer.offset;\n  Node<T> node = consumer.node;\n  Observer<? super T> downstream = consumer.downstream;\n  int capacity = capacityHint;\n\n  for (;;) {\n    if (consumer.disposed) {\n      consumer.node = null;\n      return;\n    }\n\n    boolean sourceDone = done;\n    boolean empty = size == index;\n\n    if (sourceDone && empty) {\n      consumer.node = null;\n      Throwable ex = error;\n      if (null != ex) {\n        downstream.onError(ex);\n      } else {\n        downstream.onComplete();\n      }\n      return;\n    }\n\n    if (!empty) {\n      if (offset == capacity) {\n        node = node.next;\n        offset = 0;\n      }\n\n      downstream.onNext(node.values[offset]);\n\n      offset++;\n      index++;\n\n      continue;\n    }\n\n    consumer.index = index;\n    consumer.offset = offset;\n    consumer.node = node;\n    missed = consumer.addAndGet(-missed);\n    if (0 == missed) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "286", "src_id": "M913", "code": "\nvoid drainAsync() {\n  int missed = 1;\n\n  SimpleQueue<T> q = queue;\n  Subscriber<? super T>[] a = this.subscribers;\n  AtomicLongArray r = this.requests;\n  long[] e = this.emissions;\n  int n = e.length;\n  int idx = index;\n  int consumed = produced;\n\n  for (;;) {\n\n    int notReady = 0;\n\n    for (;;) {\n      if (cancelled) {\n        q.clear();\n        return;\n      }\n\n      boolean d = done;\n      if (d) {\n        Throwable ex = error;\n        if (null != ex) {\n          q.clear();\n          for (Subscriber<? super T> s : a) {\n            s.onError(ex);\n          }\n          return;\n        }\n      }\n\n      boolean empty = q.isEmpty();\n\n      if (d && empty) {\n        for (Subscriber<? super T> s : a) {\n          s.onComplete();\n        }\n        return;\n      }\n\n      if (empty) {\n        break;\n      }\n\n      long requestAtIndex = r.get(idx);\n      long emissionAtIndex = e[idx];\n      if (requestAtIndex != emissionAtIndex && 0 == r.get(n + idx)) {\n\n        T v;\n\n        try {\n          v = q.poll();\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          upstream.cancel();\n          for (Subscriber<? super T> s : a) {\n            s.onError(ex);\n          }\n          return;\n        }\n\n        if (null == v) {\n          break;\n        }\n\n        a[idx].onNext(v);\n\n        e[idx] = emissionAtIndex + 1;\n\n        int c = ++consumed;\n        if (c == limit) {\n          consumed = 0;\n          upstream.request(c);\n        }\n        notReady = 0;\n      } else {\n        notReady++;\n      }\n\n      idx++;\n      if (idx == n) {\n        idx = 0;\n      }\n\n      if (notReady == n) {\n        break;\n      }\n    }\n\n    int w = get();\n    if (w == missed) {\n      index = idx;\n      produced = consumed;\n      missed = addAndGet(-missed);\n      if (0 == missed) {\n        break;\n      }\n    } else {\n      missed = w;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "287", "src_id": "M902", "code": "\n@Override\npublic void run() {\n  int missed = 1;\n  int c = consumed;\n  SpscArrayQueue<T> q = queue;\n  Subscriber<? super T> a = downstream;\n  int lim = limit;\n\n  for (;;) {\n\n    long r = requested.get();\n    long e = 0L;\n\n    while (e != r) {\n      if (cancelled) {\n        q.clear();\n        return;\n      }\n\n      boolean d = done;\n\n      if (d) {\n        Throwable ex = error;\n        if (null != ex) {\n          q.clear();\n\n          a.onError(ex);\n\n          worker.dispose();\n          return;\n        }\n      }\n\n      T v = q.poll();\n\n      boolean empty = null == v;\n\n      if (d && empty) {\n        a.onComplete();\n\n        worker.dispose();\n        return;\n      }\n\n      if (empty) {\n        break;\n      }\n\n      a.onNext(v);\n\n      e++;\n\n      int p = ++c;\n      if (p == lim) {\n        c = 0;\n        upstream.request(p);\n      }\n    }\n\n    if (e == r) {\n      if (cancelled) {\n        q.clear();\n        return;\n      }\n\n      if (done) {\n        Throwable ex = error;\n        if (null != ex) {\n          q.clear();\n\n          a.onError(ex);\n\n          worker.dispose();\n          return;\n        }\n        if (q.isEmpty()) {\n          a.onComplete();\n\n          worker.dispose();\n          return;\n        }\n      }\n    }\n\n    if (0 != e && Long.MAX_VALUE != r) {\n      requested.addAndGet(-e);\n    }\n\n    int w = get();\n    if (w == missed) {\n      consumed = c;\n      missed = addAndGet(-missed);\n      if (0 == missed) {\n        break;\n      }\n    } else {\n      missed = w;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "288", "src_id": "M1330", "code": "\n@Override\npublic void drain() {\n  if (0 != getAndIncrement()) {\n    return;\n  }\n\n  int missed = 1;\n\n  for (;;) {\n    SimpleQueue<T> q1 = first.queue;\n    SimpleQueue<T> q2 = second.queue;\n\n    if (null != q1 && null != q2) {\n      for (;;) {\n        if (isDisposed()) {\n          first.clear();\n          second.clear();\n          return;\n        }\n\n        Throwable ex = errors.get();\n        if (null != ex) {\n          cancelAndClear();\n\n          errors.tryTerminateConsumer(downstream);\n          return;\n        }\n\n        boolean d1 = first.done;\n\n        T a = v1;\n        if (null == a) {\n          try {\n            a = q1.poll();\n          } catch (Throwable exc) {\n            Exceptions.throwIfFatal(exc);\n            cancelAndClear();\n            errors.tryAddThrowableOrReport(exc);\n            errors.tryTerminateConsumer(downstream);\n            return;\n          }\n          v1 = a;\n        }\n        boolean e1 = null == a;\n\n        boolean d2 = second.done;\n        T b = v2;\n        if (null == b) {\n          try {\n            b = q2.poll();\n          } catch (Throwable exc) {\n            Exceptions.throwIfFatal(exc);\n            cancelAndClear();\n            errors.tryAddThrowableOrReport(exc);\n            errors.tryTerminateConsumer(downstream);\n            return;\n          }\n          v2 = b;\n        }\n\n        boolean e2 = null == b;\n\n        if (d1 && d2 && e1 && e2) {\n          downstream.onSuccess(true);\n          return;\n        }\n        if ((d1 && d2) && (e1 != e2)) {\n          cancelAndClear();\n          downstream.onSuccess(false);\n          return;\n        }\n\n        if (e1 || e2) {\n          break;\n        }\n\n        boolean c;\n\n        try {\n          c = comparer.test(a, b);\n        } catch (Throwable exc) {\n          Exceptions.throwIfFatal(exc);\n          cancelAndClear();\n          errors.tryAddThrowableOrReport(exc);\n          errors.tryTerminateConsumer(downstream);\n          return;\n        }\n\n        if (!c) {\n          cancelAndClear();\n          downstream.onSuccess(false);\n          return;\n        }\n\n        v1 = null;\n        v2 = null;\n\n        first.request();\n        second.request();\n      }\n\n    } else {\n      if (isDisposed()) {\n        first.clear();\n        second.clear();\n        return;\n      }\n\n      Throwable ex = errors.get();\n      if (null != ex) {\n        cancelAndClear();\n\n        errors.tryTerminateConsumer(downstream);\n        return;\n      }\n    }\n\n    missed = addAndGet(-missed);\n    if (0 == missed) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "289", "src_id": "M1033", "code": "\n@Override\npublic void drain() {\n  if (0 != getAndIncrement()) {\n    return;\n  }\n\n  final Subscriber<? super R> a = downstream;\n  final SimpleQueue<T> q = queue;\n  final boolean replenish = SYNC != fusionMode;\n\n  int missed = 1;\n\n  Iterator<? extends R> it = current;\n\n  for (;;) {\n\n    if (null == it) {\n\n      boolean d = done;\n\n      T t;\n\n      try {\n        t = q.poll();\n      } catch (Throwable ex) {\n        Exceptions.throwIfFatal(ex);\n        upstream.cancel();\n        ExceptionHelper.addThrowable(error, ex);\n        ex = ExceptionHelper.terminate(error);\n\n        current = null;\n        q.clear();\n\n        a.onError(ex);\n        return;\n      }\n\n      boolean empty = null == t;\n\n      if (checkTerminated(d, empty, a, q)) {\n        return;\n      }\n\n      if (null != t) {\n        Iterable<? extends R> iterable;\n\n        boolean b;\n\n        try {\n          iterable = mapper.apply(t);\n\n          it = iterable.iterator();\n\n          b = it.hasNext();\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          upstream.cancel();\n          ExceptionHelper.addThrowable(error, ex);\n          ex = ExceptionHelper.terminate(error);\n          a.onError(ex);\n          return;\n        }\n\n        if (!b) {\n          it = null;\n          consumedOne(replenish);\n          continue;\n        }\n\n        current = it;\n      }\n    }\n\n    if (null != it) {\n      long r = requested.get();\n      long e = 0L;\n\n      while (e != r) {\n        if (checkTerminated(done, false, a, q)) {\n          return;\n        }\n\n        R v;\n\n        try {\n          v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          current = null;\n          upstream.cancel();\n          ExceptionHelper.addThrowable(error, ex);\n          ex = ExceptionHelper.terminate(error);\n          a.onError(ex);\n          return;\n        }\n\n        a.onNext(v);\n\n        if (checkTerminated(done, false, a, q)) {\n          return;\n        }\n\n        e++;\n\n        boolean b;\n\n        try {\n          b = it.hasNext();\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          current = null;\n          upstream.cancel();\n          ExceptionHelper.addThrowable(error, ex);\n          ex = ExceptionHelper.terminate(error);\n          a.onError(ex);\n          return;\n        }\n\n        if (!b) {\n          consumedOne(replenish);\n          it = null;\n          current = null;\n          break;\n        }\n      }\n\n      if (e == r) {\n        boolean d = done;\n        boolean empty = q.isEmpty() && null == it;\n\n        if (checkTerminated(d, empty, a, q)) {\n          return;\n        }\n      }\n\n      if (0 != e) {\n        if (Long.MAX_VALUE != r) {\n          requested.addAndGet(-e);\n        }\n      }\n\n      if (null == it) {\n        continue;\n      }\n    }\n\n    missed = addAndGet(-missed);\n    if (0 == missed) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "290", "src_id": "M807", "code": "\n@Override\npublic void subscribe(Subscriber<? super R>[] subscribers) {\n  subscribers = RxJavaPlugins.onSubscribe(this, subscribers);\n\n  if (!validate(subscribers)) {\n    return;\n  }\n\n  int n = subscribers.length;\n  @SuppressWarnings(\"unchecked\")\n  Subscriber<T>[] parents = new Subscriber[n];\n\n  for (int i = 0; i < n; i++) {\n\n    R initialValue;\n\n    try {\n      initialValue = Objects.requireNonNull(initialSupplier.get(), \"The initialSupplier returned a null value\");\n    } catch (Throwable ex) {\n      Exceptions.throwIfFatal(ex);\n      reportError(subscribers, ex);\n      return;\n    }\n\n    parents[i] = new ParallelReduceSubscriber<>(subscribers[i], initialValue, reducer);\n  }\n\n  source.subscribe(parents);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "291", "src_id": "M438", "code": "\n@Override\npublic void subscribeActual(Observer<? super T> observer) {\n  DeferredScalarDisposable<T> d = new DeferredScalarDisposable<>(observer);\n  observer.onSubscribe(d);\n  if (d.isDisposed()) {\n    return;\n  }\n  T value;\n  try {\n    value = ExceptionHelper.nullCheck(supplier.get(), \"Supplier returned a null value.\");\n  } catch (Throwable e) {\n    Exceptions.throwIfFatal(e);\n    if (!d.isDisposed()) {\n      observer.onError(e);\n    } else {\n      RxJavaPlugins.onError(e);\n    }\n    return;\n  }\n  d.complete(value);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "292", "src_id": "M597", "code": "\n    private List<Integer> duplicate(int totalPages, String pageOrder) {\n        int duplicateCount = 2; // Default value\n        \n        if (pageOrder != null && !pageOrder.isEmpty()) {\n            try {\n                duplicateCount = Integer.parseInt(pageOrder.trim());\n            } catch (NumberFormatException e) {\n                log.error(\"Invalid duplicate count specified\", e);\n            }\n        }\n        \n        duplicateCount = duplicateCount < 1 ? 2 : duplicateCount;\n        List<Integer> newPageOrder = new ArrayList<>(totalPages * duplicateCount);\n        \n        for (int pageNum = 0; pageNum < totalPages; pageNum++) {\n            for (int i = 0; i < duplicateCount; i++) {\n                newPageOrder.add(pageNum);\n            }\n        }\n        return newPageOrder;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "293", "src_id": "M656", "code": "\n    private void runPipelineAgainstFiles(\n            List<File> filesToProcess, PipelineConfig config, Path dir, Path processingDir)\n            throws IOException {\n        try {\n            List<Resource> inputFiles = processor.generateInputFiles(filesToProcess.toArray(new File[0]));\n            if (inputFiles == null || inputFiles.isEmpty()) return;\n            \n            PipelineResult result = processor.runPipelineAgainstFiles(inputFiles, config);\n            \n            if (result.isHasErrors()) {\n                log.error(\"Errors occurred during processing, retaining original files\");\n                moveToErrorDirectory(filesToProcess, dir);\n            } else {\n                moveAndRenameFiles(result.getOutputFiles(), config, dir);\n                deleteOriginalFiles(filesToProcess, processingDir);\n            }\n        } catch (Exception e) {\n            log.error(\"Error during processing\", e);\n            moveFilesBack(filesToProcess, processingDir);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "294", "src_id": "M32", "code": "\n    private boolean activateMachine(\n            String licenseKey, String licenseId, String machineFingerprint, LicenseContext context)\n            throws Exception {\n        if (context.isFloatingLicense) {\n            log.info(\"Processing floating license activation. Max machines allowed: {}\", context.maxMachines);\n            JsonNode machinesResponse = fetchMachinesForLicense(licenseKey, licenseId);\n            \n            if (machinesResponse != null) {\n                JsonNode machines = machinesResponse.path(\"data\");\n                int currentMachines = machines.size();\n                log.info(\"Current machine count: {}, Max allowed: {}\", currentMachines, context.maxMachines);\n                \n                boolean isCurrentMachineActivated = false;\n                String currentMachineId = null;\n                for (JsonNode machine : machines) {\n                    if (machineFingerprint.equals(machine.path(\"attributes\").path(\"fingerprint\").asText())) {\n                        isCurrentMachineActivated = true;\n                        currentMachineId = machine.path(\"id\").asText();\n                        log.info(\"Current machine is already activated with ID: {}\", currentMachineId);\n                        break;\n                    }\n                }\n                \n                if (isCurrentMachineActivated) {\n                    log.info(\"Machine already activated. No action needed.\");\n                    return true;\n                }\n                \n                if (currentMachines >= context.maxMachines) {\n                    log.info(\"Max machines reached. Deregistering oldest machine\");\n                    String oldestMachineId = null;\n                    java.time.Instant oldestTime = null;\n                    \n                    for (JsonNode machine : machines) {\n                        String createdStr = machine.path(\"attributes\").path(\"created\").asText(null);\n                        if (createdStr != null && !createdStr.isEmpty()) {\n                            try {\n                                java.time.Instant createdTime = java.time.Instant.parse(createdStr);\n                                if (oldestTime == null || createdTime.isBefore(oldestTime)) {\n                                    oldestTime = createdTime;\n                                    oldestMachineId = machine.path(\"id\").asText();\n                                }\n                            } catch (Exception e) {\n                                log.warn(\"Could not parse creation time for machine: {}\", e.getMessage());\n                            }\n                        }\n                    }\n                    \n                    if (oldestMachineId == null) {\n                        log.warn(\"Could not determine oldest machine, using first in list\");\n                        oldestMachineId = machines.path(0).path(\"id\").asText();\n                    }\n                    \n                    log.info(\"Deregistering machine with ID: {}\", oldestMachineId);\n                    if (!deregisterMachine(licenseKey, oldestMachineId)) {\n                        log.error(\"Failed to deregister machine. Cannot proceed with activation.\");\n                        return false;\n                    }\n                }\n            }\n        }\n\n        String hostname = \"Unknown\";\n        try {\n            hostname = java.net.InetAddress.getLocalHost().getHostName();\n        } catch (Exception e) { /* Use default */ }\n        \n        JSONObject body = new JSONObject()\n            .put(\"data\", new JSONObject()\n                .put(\"type\", \"machines\")\n                .put(\"attributes\", new JSONObject()\n                    .put(\"fingerprint\", machineFingerprint)\n                    .put(\"platform\", System.getProperty(\"os.name\"))\n                    .put(\"name\", hostname))\n                .put(\"relationships\", new JSONObject()\n                    .put(\"license\", new JSONObject()\n                        .put(\"data\", new JSONObject()\n                            .put(\"type\", \"licenses\")\n                            .put(\"id\", licenseId)))));\n        \n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/machines\"))\n            .header(\"Content-Type\", \"application/vnd.api+json\")\n            .header(\"Accept\", \"application/vnd.api+json\")\n            .header(\"Authorization\", \"License \" + licenseKey)\n            .POST(HttpRequest.BodyPublishers.ofString(body.toString()))\n            .build();\n        \n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.info(\"activateMachine Response body: \" + response.body());\n        \n        if (response.statusCode() == 201) {\n            log.info(\"Machine activated successfully\");\n            return true;\n        } else {\n            log.error(\"Error activating machine. Status code: {}, error: {}\", response.statusCode(), response.body());\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "295", "src_id": "M625", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, true)) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            \n            // Metadata\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode()\n                .put(\"Title\", info.getTitle())\n                .put(\"Author\", info.getAuthor())\n                .put(\"Subject\", info.getSubject())\n                .put(\"Keywords\", info.getKeywords())\n                .put(\"Producer\", info.getProducer())\n                .put(\"Creator\", info.getCreator())\n                .put(\"CreationDate\", formatDate(info.getCreationDate()))\n                .put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n            \n            // Basic info\n            ObjectNode basicInfo = objectMapper.createObjectNode()\n                .put(\"FileSizeInBytes\", inputFile.getSize())\n                .put(\"WordCount\", new PDFTextStripper().getText(pdfBoxDoc).split(\"\\\\s+\").length)\n                .put(\"ParagraphCount\", new PDFTextStripper().getText(pdfBoxDoc).split(\"\\r\\n|\\r|\\n\").length)\n                .put(\"CharacterCount\", new PDFTextStripper().getText(pdfBoxDoc).length())\n                .put(\"Compression\", false)\n                .put(\"Language\", pdfBoxDoc.getDocumentCatalog().getLanguage())\n                .put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n            \n            // Document info\n            String pageMode = pdfBoxDoc.getDocumentCatalog().getPageMode().name();\n            ObjectNode docInfoNode = objectMapper.createObjectNode()\n                .put(\"PDF version\", pdfBoxDoc.getVersion())\n                .put(\"Trapped\", info.getTrapped())\n                .put(\"Page Mode\", getPageModeDescription(pageMode));\n            \n            // Form fields\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n            \n            // Additional processing (embedded files, attachments, etc.)\n            // ... [rest of processing logic] ...\n            \n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(\n                jsonString.getBytes(StandardCharsets.UTF_8),\n                \"response.json\",\n                MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n            return null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "296", "src_id": "M447", "code": "\n    private void configureCefSettings(CefAppBuilder builder) {\n        CefSettings settings = builder.getCefSettings();\n        String basePath = InstallationPathConfig.getClientWebUIPath();\n        \n        settings.cache_path = new File(basePath + \"cache\").getAbsolutePath();\n        settings.root_cache_path = new File(basePath + \"root_cache\").getAbsolutePath();\n        settings.log_file = new File(basePath, \"debug.log\").getAbsolutePath();\n        settings.persist_session_cookies = true;\n        settings.windowless_rendering_enabled = false;\n        settings.log_severity = CefSettings.LogSeverity.LOGSEVERITY_INFO;\n        \n        builder.setAppHandler(new MavenCefAppHandlerAdapter() {\n            @Override\n            public void stateHasChanged(org.cef.CefApp.CefAppState state) {\n                log.info(\"CEF state changed: \" + state);\n                if (state == CefApp.CefAppState.TERMINATED) System.exit(0);\n            }\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "297", "src_id": "M310", "code": "\n    public static PDRectangle textToPageSize(String size) {\n        switch (size.toUpperCase()) {\n            case \"A0\": return PDRectangle.A0;\n            case \"A1\": return PDRectangle.A1;\n            case \"A2\": return PDRectangle.A2;\n            case \"A3\": return PDRectangle.A3;\n            case \"A4\": return PDRectangle.A4;\n            case \"A5\": return PDRectangle.A5;\n            case \"A6\": return PDRectangle.A6;\n            case \"LETTER\": return PDRectangle.LETTER;\n            case \"LEGAL\": return PDRectangle.LEGAL;\n            default: throw ExceptionUtils.createInvalidPageSizeException(size);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "298", "src_id": "M257", "code": "\n    private Object[] processArgsInPlace(Object[] originalArgs, boolean async) {\n        if (originalArgs == null || originalArgs.length == 0) return originalArgs;\n        \n        for (int i = 0; i < originalArgs.length; i++) {\n            if (originalArgs[i] instanceof PDFFile pdfFile) {\n                if (pdfFile.getFileInput() == null && pdfFile.getFileId() != null) {\n                    try {\n                        log.debug(\"Using fileId {} to get file content\", pdfFile.getFileId());\n                        pdfFile.setFileInput(fileStorage.retrieveFile(pdfFile.getFileId()));\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Failed to resolve file by ID: \" + pdfFile.getFileId(), e);\n                    }\n                } else if (async && pdfFile.getFileInput() != null) {\n                    try {\n                        log.debug(\"Making persistent copy of uploaded file\");\n                        String fileId = fileStorage.storeFile(pdfFile.getFileInput());\n                        pdfFile.setFileId(fileId);\n                        pdfFile.setFileInput(fileStorage.retrieveFile(fileId));\n                        log.debug(\"Created persistent file copy with fileId: {}\", fileId);\n                    } catch (IOException e) {\n                        throw new RuntimeException(\"Failed to create persistent copy of uploaded file\", e);\n                    }\n                }\n            }\n        }\n        return originalArgs;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "299", "src_id": "M184", "code": "\n    private Map<String, Object> getDockerMetrics() {\n        Map<String, Object> dockerMetrics = new HashMap<>();\n        dockerMetrics.put(\"docker_network_mode\", System.getenv(\"DOCKER_NETWORK_MODE\"));\n        \n        String containerName = System.getenv(\"CONTAINER_NAME\");\n        if (containerName != null && !containerName.isEmpty()) {\n            dockerMetrics.put(\"container_name\", containerName);\n        }\n        \n        String composeProject = System.getenv(\"COMPOSE_PROJECT_NAME\");\n        String composeService = System.getenv(\"COMPOSE_SERVICE_NAME\");\n        if (composeProject != null && composeService != null) {\n            dockerMetrics.put(\"compose_project\", composeProject);\n            dockerMetrics.put(\"compose_service\", composeService);\n        }\n        \n        String k8sPodName = System.getenv(\"KUBERNETES_POD_NAME\");\n        if (k8sPodName != null) {\n            dockerMetrics.put(\"k8s_pod_name\", k8sPodName)\n                .put(\"k8s_namespace\", System.getenv(\"KUBERNETES_NAMESPACE\"))\n                .put(\"k8s_node_name\", System.getenv(\"KUBERNETES_NODE_NAME\"));\n        }\n        \n        dockerMetrics.put(\"version_tag\", System.getenv(\"VERSION_TAG\"))\n            .put(\"additional_features_off\", System.getenv(\"ADDITIONAL_FEATURES_OFF\"))\n            .put(\"fat_docker\", System.getenv(\"FAT_DOCKER\"));\n        \n        return dockerMetrics;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "300", "src_id": "M170", "code": "\n    private void shutdownSchedulers() {\n        log.info(\"Shutting down job queue\");\n        shuttingDown = true;\n\n        for (Map.Entry<String, Job> entry : jobMap.entrySet()) {\n            if (!entry.getValue().future.isDone()) {\n                entry.getValue().future.completeExceptionally(\n                    new RuntimeException(\"Server shutting down, job cancelled\"));\n            }\n        }\n\n        try {\n            scheduler.shutdown();\n            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {\n                scheduler.shutdownNow();\n            }\n\n            jobExecutor.shutdown();\n            if (!jobExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n                jobExecutor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            scheduler.shutdownNow();\n            jobExecutor.shutdownNow();\n        }\n\n        log.info(\"Job queue shutdown complete. Stats: total={}, rejected={}\", totalQueuedJobs, rejectedJobs);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "301", "src_id": "M153", "code": "\n    private Path createTempFile(String prefix) throws IOException {\n        try {\n            TempFileManager tempFileManager = ApplicationContextProvider.getBean(TempFileManager.class);\n            if (tempFileManager != null) {\n                File file = tempFileManager.createTempFile(\".tmp\");\n                log.debug(\"Created temp file via TempFileManager: {}\", file);\n                return file.toPath();\n            }\n        } catch (Exception e) {\n            log.debug(\"TempFileManager unavailable, using fallback\");\n        }\n\n        Path file = Files.createTempFile(prefix + tempCounter.incrementAndGet() + \"-\", \".tmp\");\n        log.debug(\"Created temp file: {}\", file);\n\n        try {\n            TempFileRegistry registry = ApplicationContextProvider.getBean(TempFileRegistry.class);\n            if (registry != null) {\n                registry.register(file);\n            }\n        } catch (Exception e) {\n            log.debug(\"Temp file registration failed\");\n        }\n\n        return file;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "302", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n    String title = pdfMetadata.getTitle();\n    pdf.getDocumentInformation().setTitle(title);\n    pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties\n            .getPremium()\n            .getProFeatures()\n            .getCustomMetadata()\n            .isAutoUpdateMetadata()\n            && runningProOrHigher) {\n        author = applicationProperties\n                .getPremium()\n                .getProFeatures()\n                .getCustomMetadata()\n                .getAuthor();\n\n        if (userService != null) {\n            author = author.replace(\"username\", userService.getCurrentUsername());\n        }\n    }\n    pdf.getDocumentInformation().setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "303", "src_id": "M602", "code": "\n@PostMapping(value = \"/document-properties\", consumes = \"multipart/form-data\")\n@Operation(\n        summary = \"Get PDF document properties\",\n        description = \"Returns title, author, subject, etc. Input:PDF Output:JSON Type:SISO\")\npublic Map<String, String> getDocumentProperties(@ModelAttribute PDFFile file)\n        throws IOException {\n    try (PDDocument document = pdfDocumentFactory.load(file.getFileInput(), true)) {\n        PDDocumentInformation info = document.getDocumentInformation();\n        Map<String, String> properties = new HashMap<>();\n        properties.put(\"title\", info.getTitle());\n        properties.put(\"author\", info.getAuthor());\n        properties.put(\"subject\", info.getSubject());\n        properties.put(\"keywords\", info.getKeywords());\n        properties.put(\"creator\", info.getCreator());\n        properties.put(\"producer\", info.getProducer());\n        properties.put(\"creationDate\", info.getCreationDate().toString());\n        properties.put(\"modificationDate\", info.getModificationDate().toString());\n        return properties;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "304", "src_id": "M458", "code": "\nprivate void setupTrayIcon(Image icon) {\n    if (!SystemTray.isSupported()) {\n        log.warn(\"System tray is not supported\");\n        return;\n    }\n\n    try {\n        systemTray = SystemTray.getSystemTray();\n        PopupMenu popup = new PopupMenu();\n        MenuItem showItem = new MenuItem(\"Show\");\n        showItem.addActionListener(\n            e -> {\n                frame.setVisible(true);\n                frame.setState(Frame.NORMAL);\n            });\n        MenuItem exitItem = new MenuItem(\"Exit\");\n        exitItem.addActionListener(\n            e -> {\n                cleanup();\n                System.exit(0);\n            });\n\n        popup.add(showItem);\n        popup.addSeparator();\n        popup.add(exitItem);\n        trayIcon = new TrayIcon(icon, \"Stirling-PDF\", popup);\n        trayIcon.setImageAutoSize(true);\n        trayIcon.addActionListener(\n            e -> {\n                frame.setVisible(true);\n                frame.setState(Frame.NORMAL);\n            });\n\n        systemTray.add(trayIcon);\n        frame.addWindowStateListener(\n            new WindowStateListener() {\n                public void windowStateChanged(WindowEvent e) {\n                    if (e.getNewState() == Frame.ICONIFIED) {\n                        frame.setVisible(false);\n                    }\n                }\n            });\n    } catch (AWTException e) {\n        log.error(\"Error setting up system tray icon\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "305", "src_id": "M477", "code": "\nprivate void handleSplitByDocCount(\n        PDDocument sourceDocument,\n        int documentCount,\n        ZipOutputStream zipOut,\n        String baseFilename)\n        throws IOException {\n    log.debug(\"Starting handleSplitByDocCount with documentCount={}\", documentCount);\n    int totalPageCount = sourceDocument.getNumberOfPages();\n    log.debug(\"Total pages in source document: {}\", totalPageCount);\n\n    int pagesPerDocument = totalPageCount / documentCount;\n    int extraPages = totalPageCount % documentCount;\n    log.debug(\"Pages per document: {}, Extra pages: {}\", pagesPerDocument, extraPages);\n\n    int currentPageIndex = 0;\n    int fileIndex = 1;\n\n    for (int i = 0; i < documentCount; i++) {\n        log.debug(\"Creating document {} of {}\", i + 1, documentCount);\n        PDDocument currentDoc = null;\n        try {\n            currentDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(sourceDocument);\n            log.debug(\"Successfully created document {} of {}\", i + 1, documentCount);\n        } catch (Exception e) {\n            log.error(\"Error creating document {} of {}\", i + 1, documentCount, e);\n            throw ExceptionUtils.createFileProcessingException(\"split\", e);\n        }\n\n        int pagesToAdd = pagesPerDocument + (i < extraPages ? 1 : 0);\n        log.debug(\"Adding {} pages to document {}\", pagesToAdd, i + 1);\n\n        for (int j = 0; j < pagesToAdd; j++) {\n            try {\n                log.debug(\n                        \"Adding page {} (index {}) to document {}\",\n                        j + 1,\n                        currentPageIndex,\n                        i + 1);\n                currentDoc.addPage(sourceDocument.getPage(currentPageIndex));\n                log.debug(\"Successfully added page {} to document {}\", j + 1, i + 1);\n                currentPageIndex++;\n            } catch (Exception e) {\n                log.error(\"Error adding page {} to document {}\", j + 1, i + 1, e);\n                throw ExceptionUtils.createFileProcessingException(\"split\", e);\n            }\n        }\n\n        try {\n            log.debug(\"Saving document {} with {} pages\", i + 1, pagesToAdd);\n            saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n            log.debug(\"Successfully saved document {}\", i + 1);\n        } catch (Exception e) {\n            log.error(\"Error saving document {}\", i + 1, e);\n            throw e;\n        }\n    }\n    log.debug(\"Completed handleSplitByDocCount with {} documents created\", documentCount);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "306", "src_id": "M577", "code": "\nprivate void processWithTesseract(\n        List<String> selectedLanguages, String ocrType, Path tempInputFile, Path tempOutputFile)\n        throws IOException, InterruptedException {\n    try (TempDirectory tempDir = new TempDirectory(tempFileManager)) {\n        File tempOutputDir = new File(tempDir.getPath().toFile(), \"output\");\n        File tempImagesDir = new File(tempDir.getPath().toFile(), \"images\");\n        File finalOutputFile = new File(tempDir.getPath().toFile(), \"final_output.pdf\");\n        tempOutputDir.mkdirs();\n        tempImagesDir.mkdirs();\n\n        PDFMergerUtility merger = new PDFMergerUtility();\n        merger.setDestinationFileName(finalOutputFile.toString());\n\n        try (PDDocument document = pdfDocumentFactory.load(tempInputFile.toFile())) {\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            int pageCount = document.getNumberOfPages();\n\n            for (int pageNum = 0; pageNum < pageCount; pageNum++) {\n                PDPage page = document.getPage(pageNum);\n                boolean hasText = false;\n                try (PDDocument tempDoc = new PDDocument()) {\n                    tempDoc.addPage(page);\n                    PDFTextStripper stripper = new PDFTextStripper();\n                    hasText = !stripper.getText(tempDoc).trim().isEmpty();\n                }\n\n                boolean shouldOcr = switch (ocrType) {\n                    case \"skip-text\" -> !hasText;\n                    case \"force-ocr\" -> true;\n                    default -> true;\n                };\n\n                File pageOutputPath = new File(tempOutputDir, String.format(\"page_%d.pdf\", pageNum));\n                if (shouldOcr) {\n                    BufferedImage image = pdfRenderer.renderImageWithDPI(pageNum, 300);\n                    File imagePath = new File(tempImagesDir, String.format(\"page_%d.png\", pageNum));\n                    ImageIO.write(image, \"png\", imagePath);\n\n                    List<String> command = new ArrayList<>();\n                    command.add(\"tesseract\");\n                    command.add(imagePath.toString());\n                    command.add(new File(tempOutputDir, String.format(\"page_%d\", pageNum)).toString());\n                    command.add(\"-l\");\n                    command.add(String.join(\"+\", selectedLanguages));\n                    command.add(\"pdf\");\n\n                    ProcessExecutorResult result = ProcessExecutor.getInstance(ProcessExecutor.Processes.TESSERACT)\n                            .runCommandWithOutputHandling(command);\n                    if (result.getRc() != 0) {\n                        throw ExceptionUtils.createRuntimeException(\n                                \"error.commandFailed\",\n                                \"{0} command failed with exit code: {1}\",\n                                null,\n                                \"Tesseract\",\n                                result.getRc());\n                    }\n                    merger.addSource(pageOutputPath);\n                } else {\n                    try (PDDocument pageDoc = new PDDocument()) {\n                        pageDoc.addPage(page);\n                        pageDoc.save(pageOutputPath);\n                        merger.addSource(pageOutputPath);\n                    }\n                }\n            }\n        }\n        merger.mergeDocuments(null);\n        Files.copy(\n                finalOutputFile.toPath(),\n                tempOutputFile,\n                java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "307", "src_id": "M522", "code": "\n@PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\")\n@Operation(\n        summary = \"Auto split PDF pages into separate documents\",\n        description = \"This endpoint accepts a PDF file, scans each page for a specific QR code, and\"\n                + \" splits the document at the QR code boundaries. The output is a zip file\"\n                + \" containing each separate PDF document. Input:PDF Output:ZIP-PDF Type:SISO\")\npublic ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request)\n        throws IOException {\n    MultipartFile file = request.getFileInput();\n    boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n    PDDocument document = null;\n    List<PDDocument> splitDocuments = new ArrayList<>();\n    Path zipFile = null;\n    byte[] data = null;\n\n    try {\n        document = pdfDocumentFactory.load(file.getInputStream());\n        PDFRenderer pdfRenderer = new PDFRenderer(document);\n        pdfRenderer.setSubsamplingAllowed(true);\n\n        for (int page = 0; page < document.getNumberOfPages(); ++page) {\n            BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n            String result = decodeQRCode(bim);\n            boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n            log.debug(\"detected qr code {}, code is vale={}\", result, isValidQrCode);\n\n            if (isValidQrCode && page != 0) {\n                splitDocuments.add(new PDDocument());\n            }\n            if (!splitDocuments.isEmpty() && !isValidQrCode) {\n                splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n            } else if (page == 0) {\n                PDDocument firstDocument = new PDDocument();\n                firstDocument.addPage(document.getPage(page));\n                splitDocuments.add(firstDocument);\n            }\n            if (duplexMode && isValidQrCode) {\n                page++;\n            }\n        }\n\n        splitDocuments.removeIf(pdDocument -> pdDocument.getNumberOfPages() == 0);\n        zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n        String filename = Filenames.toSimpleFileName(file.getOriginalFilename())\n                .replaceFirst(\"[.][^.]+$\", \"\");\n\n        try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile))) {\n            for (int i = 0; i < splitDocuments.size(); i++) {\n                String fileName = filename + \"_\" + (i + 1) + \".pdf\";\n                PDDocument splitDocument = splitDocuments.get(i);\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                splitDocument.save(baos);\n                byte[] pdf = baos.toByteArray();\n                ZipEntry pdfEntry = new ZipEntry(fileName);\n                zipOut.putNextEntry(pdfEntry);\n                zipOut.write(pdf);\n                zipOut.closeEntry();\n            }\n        }\n        data = Files.readAllBytes(zipFile);\n        return WebResponseUtils.bytesToWebResponse(\n                data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM);\n    } catch (Exception e) {\n        log.error(\"Error in auto split\", e);\n        throw e;\n    } finally {\n        if (document != null) {\n            try {\n                document.close();\n            } catch (IOException e) {\n                log.error(\"Error closing main PDDocument\", e);\n            }\n        }\n        for (PDDocument splitDoc : splitDocuments) {\n            try {\n                splitDoc.close();\n            } catch (IOException e) {\n                log.error(\"Error closing split PDDocument\", e);\n            }\n        }\n        if (zipFile != null) {\n            try {\n                Files.deleteIfExists(zipFile);\n            } catch (IOException e) {\n                log.error(\"Error deleting temporary zip file\", e);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "308", "src_id": "M443", "code": "\nprivate void checkAndRefreshExplorer() {\n    if (!IS_WINDOWS) {\n        return;\n    }\n    if (timeAt90Percent == -1) {\n        timeAt90Percent = System.currentTimeMillis();\n        stuckTimer = new Timer(\n                1000,\n                e -> {\n                    long currentTime = System.currentTimeMillis();\n                    if (currentTime - timeAt90Percent > stuckThreshold) {\n                        try {\n                            log.debug(\"Attempting Windows explorer refresh due to 90% stuck state\");\n                            String currentDir = System.getProperty(\"user.dir\");\n                            Set<String> existingPids = new HashSet<>();\n                            ProcessBuilder listExplorer = new ProcessBuilder(\n                                    \"cmd\",\n                                    \"/c\",\n                                    \"wmic\",\n                                    \"process\",\n                                    \"where\",\n                                    \"name='explorer.exe'\",\n                                    \"get\",\n                                    \"ProcessId\",\n                                    \"/format:csv\");\n                            Process process = listExplorer.start();\n                            BufferedReader reader = new BufferedReader(\n                                    new InputStreamReader(process.getInputStream()));\n                            String line;\n                            while ((line = BoundedLineReader.readLine(reader, 5_000_000)) != null) {\n                                if (line.matches(\".*\\\\d+.*\")) {\n                                    String[] parts = line.trim().split(\",\");\n                                    if (parts.length >= 2) {\n                                        existingPids.add(parts[parts.length - 1].trim());\n                                    }\n                                }\n                            }\n                            process.waitFor(2, TimeUnit.SECONDS);\n\n                            ProcessBuilder pb = new ProcessBuilder(\n                                    \"cmd\",\n                                    \"/c\",\n                                    \"start\",\n                                    \"/min\",\n                                    \"/b\",\n                                    \"explorer.exe\",\n                                    currentDir);\n                            pb.redirectErrorStream(true);\n                            explorerProcess = pb.start();\n\n                            Timer cleanupTimer = new Timer(\n                                    2000,\n                                    cleanup -> {\n                                        try {\n                                            ProcessBuilder findNewExplorer = new ProcessBuilder(\n                                                    \"cmd\",\n                                                    \"/c\",\n                                                    \"wmic\",\n                                                    \"process\",\n                                                    \"where\",\n                                                    \"name='explorer.exe'\",\n                                                    \"get\",\n                                                    \"ProcessId\",\n                                                    \"/format:csv\");\n                                            Process newProcess = findNewExplorer.start();\n                                            BufferedReader newReader = new BufferedReader(\n                                                    new InputStreamReader(newProcess.getInputStream()));\n                                            String newLine;\n                                            while ((newLine = BoundedLineReader.readLine(newReader, 5_000_000)) != null) {\n                                                if (newLine.matches(\".*\\\\d+.*\")) {\n                                                    String[] parts = newLine.trim().split(\",\");\n                                                    if (parts.length >= 2) {\n                                                        String pid = parts[parts.length - 1].trim();\n                                                        if (!existingPids.contains(pid)) {\n                                                            log.debug(\"Found new explorer.exe with PID: \" + pid);\n                                                            ProcessBuilder killProcess = new ProcessBuilder(\n                                                                    \"taskkill\",\n                                                                    \"/PID\",\n                                                                    pid,\n                                                                    \"/F\");\n                                                            killProcess.redirectErrorStream(true);\n                                                            Process killResult = killProcess.start();\n                                                            killResult.waitFor(2, TimeUnit.SECONDS);\n                                                            log.debug(\"Explorer process terminated: \" + pid);\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                            newProcess.waitFor(2, TimeUnit.SECONDS);\n                                        } catch (Exception ex) {\n                                            log.error(\"Error cleaning up Windows explorer process\", ex);\n                                        }\n                                    });\n                            cleanupTimer.setRepeats(false);\n                            cleanupTimer.start();\n                            stuckTimer.stop();\n                        } catch (Exception ex) {\n                            log.error(\"Error refreshing Windows explorer\", ex);\n                        }\n                    }\n                });\n        stuckTimer.setRepeats(true);\n        stuckTimer.start();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "309", "src_id": "M408", "code": "\nprivate static Path unzipAndGetMainHtml(byte[] fileBytes) throws IOException {\n    Path tempDirectory = Files.createTempDirectory(\"unzipped_\");\n    try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(fileBytes))) {\n        ZipEntry entry = zipIn.getNextEntry();\n        while (entry != null) {\n            Path filePath = tempDirectory.resolve(sanitizeZipFilename(entry.getName()));\n            if (entry.isDirectory()) {\n                Files.createDirectories(filePath);\n            } else {\n                Files.createDirectories(filePath.getParent());\n                Files.copy(zipIn, filePath);\n            }\n            zipIn.closeEntry();\n            entry = zipIn.getNextEntry();\n        }\n    }\n\n    try (Stream<Path> walk = Files.walk(tempDirectory)) {\n        List<Path> htmlFiles = walk.filter(file -> file.toString().endsWith(\".html\")).toList();\n        if (htmlFiles.isEmpty()) {\n            throw new IOException(\"No HTML files found in the unzipped directory.\");\n        }\n        for (Path htmlFile : htmlFiles) {\n            if (\"index.html\".equals(htmlFile.getFileName().toString())) {\n                return htmlFile;\n            }\n        }\n        return htmlFiles.get(0);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "310", "src_id": "M197", "code": "\n@Scheduled(\n        fixedDelayString = \"#{applicationProperties.system.tempFileManagement.cleanupIntervalMinutes}\",\n        timeUnit = TimeUnit.MINUTES)\npublic void scheduledCleanup() {\n    log.info(\"Running scheduled temporary file cleanup\");\n    long maxAgeMillis = tempFileManager.getMaxAgeMillis();\n    int registeredDeletedCount = tempFileManager.cleanupOldTempFiles(maxAgeMillis);\n    log.info(\"Cleaned up {} registered temporary files\", registeredDeletedCount);\n\n    int directoriesDeletedCount = 0;\n    for (Path directory : registry.getTempDirectories()) {\n        try {\n            if (Files.exists(directory)) {\n                GeneralUtils.deleteDirectory(directory);\n                directoriesDeletedCount++;\n                log.debug(\"Cleaned up temporary directory: {}\", directory);\n            }\n        } catch (IOException e) {\n            log.warn(\"Failed to clean up temporary directory: {}\", directory, e);\n        }\n    }\n\n    cleanupPDFBoxCache();\n    boolean containerMode = isContainerMode();\n    int unregisteredDeletedCount = cleanupUnregisteredFiles(containerMode, true, maxAgeMillis);\n\n    if (registeredDeletedCount > 0\n            || unregisteredDeletedCount > 0\n            || directoriesDeletedCount > 0) {\n        log.info(\n                \"Scheduled cleanup complete. Deleted {} registered files, {} unregistered files, {} directories\",\n                registeredDeletedCount,\n                unregisteredDeletedCount,\n                directoriesDeletedCount);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "311", "src_id": "M102", "code": "\n@Override\nprotected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {\n    String uri = request.getRequestURI();\n    String contextPath = request.getContextPath();\n    String[] permitAllPatterns = {\n        contextPath + \"/login\",\n        contextPath + \"/register\",\n        contextPath + \"/error\",\n        contextPath + \"/images/\",\n        contextPath + \"/public/\",\n        contextPath + \"/css/\",\n        contextPath + \"/fonts/\",\n        contextPath + \"/js/\",\n        contextPath + \"/pdfjs/\",\n        contextPath + \"/pdfjs-legacy/\",\n        contextPath + \"/api/v1/info/status\",\n        contextPath + \"/site.webmanifest\"\n    };\n\n    for (String pattern : permitAllPatterns) {\n        if (uri.startsWith(pattern)\n                || uri.endsWith(\".svg\")\n                || uri.endsWith(\".png\")\n                || uri.endsWith(\".ico\")) {\n            return true;\n        }\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "312", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n  StringBuilder sb = new StringBuilder(8192);\n\n  for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n    Map<String, Object> info = entry.getValue();\n\n    TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n    TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n    Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n    table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n        .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n        .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), \n            label(\"\" + info.get(LoggerHelper.classLoader)))\n        .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), \n            label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n        .row(label(LoggerHelper.level).style(Decoration.bold.bold()), \n            label(\"\" + info.get(LoggerHelper.level)));\n    \n    if (info.get(LoggerHelper.effectiveLevel) != null) {\n      table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n          label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n    }\n\n    if (info.get(LoggerHelper.config) != null) {\n      table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n          label(\"\" + info.get(LoggerHelper.config)));\n    }\n\n    table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n        label(\"\" + info.get(LoggerHelper.additivity)))\n        .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n            label(\"\" + info.get(LoggerHelper.codeSource)));\n\n    @SuppressWarnings(\"unchecked\")\n    List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n    if (appenders != null && !appenders.isEmpty()) {\n      for (Map<String, Object> appenderInfo : appenders) {\n        Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n        appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n            label(\"\" + appenderInfo.get(LoggerHelper.name)));\n        appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n        appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n        appendersTable.row(label(LoggerHelper.classLoaderHash),\n            label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n        \n        if (appenderInfo.get(LoggerHelper.file) != null) {\n          appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n        }\n        if (appenderInfo.get(LoggerHelper.target) != null) {\n          appendersTable.row(label(LoggerHelper.target),\n              label(\"\" + appenderInfo.get(LoggerHelper.target)));\n        }\n        if (appenderInfo.get(LoggerHelper.blocking) != null) {\n          appendersTable.row(label(LoggerHelper.blocking),\n              label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n        }\n        if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n          appendersTable.row(label(LoggerHelper.appenderRef),\n              label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n        }\n      }\n      table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n    }\n    sb.append(RenderUtil.render(table, width)).append('\\n');\n  }\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "313", "src_id": "M1126", "code": "\nprivate ApiResponse processInitSessionRequest(ApiRequest apiRequest) throws ApiException {\n  ApiResponse response = new ApiResponse();\n\n  Session session = sessionManager.createSession();\n  if (session != null) {\n    SharingResultDistributorImpl resultDistributor = new SharingResultDistributorImpl(session);\n    ResultConsumer resultConsumer = new ResultConsumerImpl();\n    resultDistributor.addConsumer(resultConsumer);\n    session.setResultDistributor(resultDistributor);\n    resultDistributor.appendResult(new MessageModel(\"Welcome to arthas!\"));\n\n    WelcomeModel welcomeModel = new WelcomeModel();\n    welcomeModel.setVersion(ArthasBanner.version());\n    welcomeModel.setWiki(ArthasBanner.wiki());\n    welcomeModel.setTutorials(ArthasBanner.tutorials());\n    welcomeModel.setMainClass(PidUtils.mainClass());\n    welcomeModel.setPid(PidUtils.currentPid());\n    welcomeModel.setTime(DateUtils.getCurrentDateTime());\n    resultDistributor.appendResult(welcomeModel);\n\n    updateSessionInputStatus(session, InputStatus.ALLOW_INPUT);\n    response.setSessionId(session.getSessionId())\n        .setConsumerId(resultConsumer.getConsumerId())\n        .setState(ApiState.SUCCEEDED);\n  } else {\n    throw new ApiException(\"create api session failed\");\n  }\n  return response;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "314", "src_id": "M1157", "code": "\nprivate HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n  DefaultFullHttpResponse fullResp = null;\n  InputStream in = null;\n  try {\n    URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n    if (res != null) {\n      fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n      in = res.openStream();\n      byte[] tmp = new byte[256];\n      for (int l = 0; l != -1; l = in.read(tmp)) {\n        fullResp.content().writeBytes(tmp, 0, l);\n      }\n      int li = path.lastIndexOf('.');\n      if (li != -1 && li != path.length() - 1) {\n        String ext = path.substring(li + 1);\n        String contentType;\n        if (\"html\".equals(ext)) {\n          contentType = \"text/html\";\n        } else if (\"js\".equals(ext)) {\n          contentType = \"application/javascript\";\n        } else if (\"css\".equals(ext)) {\n          contentType = \"text/css\";\n        } else {\n          contentType = null;\n        }\n        if (contentType != null) {\n          fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n        }\n      }\n    }\n  } finally {\n    IOUtils.close(in);\n  }\n  return fullResp;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "315", "src_id": "M515", "code": "\n@Override\npublic void draw(CommandProcess process, StackModel result) {\n  StringBuilder sb = new StringBuilder();\n  sb.append(ThreadUtil.getThreadTitle(result)).append(\"\\n\");\n\n  StackTraceElement[] stackTraceElements = result.getStackTrace();\n  StackTraceElement locationStackTraceElement = stackTraceElements[0];\n  String locationString = String.format(\"    @%s.%s()\", locationStackTraceElement.getClassName(),\n      locationStackTraceElement.getMethodName());\n  sb.append(locationString).append(\"\\n\");\n\n  int skip = 1;\n  for (int index = skip; index < stackTraceElements.length; index++) {\n    StackTraceElement ste = stackTraceElements[index];\n    sb.append(\"        at \")\n        .append(ste.getClassName())\n        .append(\".\")\n        .append(ste.getMethodName())\n        .append(\"(\")\n        .append(ste.getFileName())\n        .append(\":\")\n        .append(ste.getLineNumber())\n        .append(\")\\n\");\n  }\n  process.write(\"ts=\" + DateUtils.formatDateTime(result.getTs()) + \";\" + sb.toString() + \"\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "316", "src_id": "M1130", "code": "\nprivate ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n  boolean oneTimeAccess = false;\n  if (session.get(ONETIME_SESSION_KEY) != null) {\n    oneTimeAccess = true;\n  }\n\n  try {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<String, Object>();\n    body.put(\"command\", commandLine);\n\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId()).setBody(body);\n\n    if (!session.tryLock()) {\n      response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n      return response;\n    }\n\n    int lock = session.getLock();\n    PackingResultDistributor packingResultDistributor = null;\n    Job job = null;\n    try {\n      Job foregroundJob = session.getForegroundJob();\n      if (foregroundJob != null) {\n        response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n        logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n        return response;\n      }\n\n      packingResultDistributor = new PackingResultDistributorImpl(session);\n      job = this.createJob(commandLine, session, packingResultDistributor);\n      session.setForegroundJob(job);\n      updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n      job.run();\n    } catch (Throwable e) {\n      logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n      response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n      return response;\n    } finally {\n      if (session.getLock() == lock) {\n        session.unLock();\n      }\n    }\n\n    Integer timeout = apiRequest.getExecTimeout();\n    if (timeout == null || timeout <= 0) {\n      timeout = DEFAULT_EXEC_TIMEOUT;\n    }\n    boolean timeExpired = !waitForJob(job, timeout);\n    if (timeExpired) {\n      logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n      job.interrupt();\n      response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n    } else {\n      response.setState(ApiState.SUCCEEDED);\n    }\n\n    body.put(\"jobId\", job.id());\n    body.put(\"jobStatus\", job.status());\n    body.put(\"timeExpired\", timeExpired);\n    if (timeExpired) {\n      body.put(\"timeout\", timeout);\n    }\n    body.put(\"results\", packingResultDistributor.getResults());\n\n    response.setSessionId(session.getSessionId()).setBody(body);\n    return response;\n  } finally {\n    if (oneTimeAccess) {\n      sessionManager.removeSession(session.getSessionId());\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "317", "src_id": "M536", "code": "\npublic static String drawThreadInfo(List<ThreadVO> threads, int width, int height) {\n  TableElement table = new TableElement(1, 6, 3, 2, 2, 2, 2, 2, 2, 2).overflow(Overflow.HIDDEN).rightCellPadding(1);\n\n  table.add(new RowElement().style(Decoration.bold.fg(Color.black).bg(Color.white)).add(\n      \"ID\", \"NAME\", \"GROUP\", \"PRIORITY\", \"STATE\", \"%CPU\", \"DELTA_TIME\", \"TIME\", \"INTERRUPTED\", \"DAEMON\"));\n\n  int count = 0;\n  for (ThreadVO thread : threads) {\n    Color color = colorMapping.get(thread.getState());\n    String time = formatTimeMills(thread.getTime());\n    String deltaTime = formatTimeMillsToSeconds(thread.getDeltaTime());\n    double cpu = thread.getCpu();\n\n    LabelElement daemonLabel = new LabelElement(thread.isDaemon());\n    if (!thread.isDaemon()) {\n      daemonLabel.setStyle(Style.style(Color.magenta));\n    }\n    LabelElement stateElement;\n    if (thread.getState() != null) {\n      stateElement = new LabelElement(thread.getState()).style(color.fg());\n    } else {\n      stateElement = new LabelElement(\"-\");\n    }\n    table.row(\n        new LabelElement(thread.getId()),\n        new LabelElement(thread.getName()),\n        new LabelElement(thread.getGroup() != null ? thread.getGroup() : \"-\"),\n        new LabelElement(thread.getPriority()),\n        stateElement,\n        new LabelElement(cpu),\n        new LabelElement(deltaTime),\n        new LabelElement(time),\n        new LabelElement(thread.isInterrupted()),\n        daemonLabel\n    );\n    if (++count >= height) {\n      break;\n    }\n  }\n  return RenderUtil.render(table, width, height);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "318", "src_id": "M1125", "code": "\nprivate ApiResponse dispatchRequest(ApiAction action, ApiRequest apiRequest, Session session) throws ApiException {\n  switch (action) {\n    case EXEC:\n      return processExecRequest(apiRequest, session);\n    case ASYNC_EXEC:\n      return processAsyncExecRequest(apiRequest, session);\n    case INTERRUPT_JOB:\n      return processInterruptJob(apiRequest, session);\n    case PULL_RESULTS:\n      return processPullResultsRequest(apiRequest, session);\n    case SESSION_INFO:\n      return processSessionInfoRequest(apiRequest, session);\n    case JOIN_SESSION:\n      return processJoinSessionRequest(apiRequest, session);\n    case CLOSE_SESSION:\n      return processCloseSessionRequest(apiRequest, session);\n    case INIT_SESSION:\n      break;\n  }\n  return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "319", "src_id": "M1470", "code": "\npublic static Pair<String, NavigableMap<Integer, Integer>> decompileWithMappings(String classFilePath,\n    String methodName, boolean hideUnicode, boolean printLineNumber) {\n  final StringBuilder sb = new StringBuilder(8192);\n  final NavigableMap<Integer, Integer> lineMapping = new TreeMap<>();\n\n  OutputSinkFactory mySink = new OutputSinkFactory() {\n    @Override\n    public List<SinkClass> getSupportedSinks(SinkType sinkType, Collection<SinkClass> collection) {\n      return Arrays.asList(SinkClass.STRING, SinkClass.DECOMPILED, SinkClass.DECOMPILED_MULTIVER,\n          SinkClass.EXCEPTION_MESSAGE, SinkClass.LINE_NUMBER_MAPPING);\n    }\n\n    @Override\n    public <T> Sink<T> getSink(final SinkType sinkType, final SinkClass sinkClass) {\n      return new Sink<T>() {\n        @Override\n        public void write(T sinkable) {\n          if (sinkType == SinkType.PROGRESS) {\n            return;\n          }\n          if (sinkType == SinkType.LINENUMBER) {\n            LineNumberMapping mapping = (LineNumberMapping) sinkable;\n            NavigableMap<Integer, Integer> classFileMappings = mapping.getClassFileMappings();\n            NavigableMap<Integer, Integer> mappings = mapping.getMappings();\n            if (classFileMappings != null && mappings != null) {\n              for (Entry<Integer, Integer> entry : mappings.entrySet()) {\n                Integer srcLineNumber = classFileMappings.get(entry.getKey());\n                lineMapping.put(entry.getValue(), srcLineNumber);\n              }\n            }\n            return;\n          }\n          sb.append(sinkable);\n        }\n      };\n    }\n  };\n\n  HashMap<String, String> options = new HashMap<>();\n  options.put(\"showversion\", \"false\");\n  options.put(\"hideutf\", String.valueOf(hideUnicode));\n  options.put(\"trackbytecodeloc\", \"true\");\n  if (!StringUtils.isBlank(methodName)) {\n    options.put(\"methodname\", methodName);\n  }\n\n  CfrDriver driver = new CfrDriver.Builder().withOptions(options).withOutputSink(mySink).build();\n  List<String> toAnalyse = new ArrayList<>();\n  toAnalyse.add(classFilePath);\n  driver.analyse(toAnalyse);\n\n  String resultCode = sb.toString();\n  if (printLineNumber && !lineMapping.isEmpty()) {\n    resultCode = addLineNumber(resultCode, lineMapping);\n  }\n\n  return Pair.make(resultCode, lineMapping);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "320", "src_id": "M1355", "code": "\npublic static String nullSafeToString(char[] array) {\n  if (array == null) {\n    return \"null\";\n  } else {\n    int length = array.length;\n    if (length == 0) {\n      return \"{}\";\n    } else {\n      StringBuilder sb = new StringBuilder(\"{\");\n      for (int i = 0; i < length; ++i) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n        sb.append(\"\\'\").append(array[i]).append(\"\\'\");\n      }\n      sb.append(\"}\");\n      return sb.toString();\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "321", "src_id": "M454", "code": "\nprivate void renderObject(Object obj, int deep, int expand, final StringBuilder buf)\n    throws ObjectTooLargeException {\n  if (obj == null) {\n    appendStringBuilder(buf, \"null\");\n  } else {\n    final Class<?> clazz = obj.getClass();\n    final String className = clazz.getSimpleName();\n\n    if (Integer.class.isInstance(obj)\n        || Long.class.isInstance(obj)\n        || Float.class.isInstance(obj)\n        || Double.class.isInstance(obj)\n        || Short.class.isInstance(obj)\n        || Byte.class.isInstance(obj)\n        || Boolean.class.isInstance(obj)) {\n      appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n    } else if (Character.class.isInstance(obj)) {\n      final Character c = (Character) obj;\n      if (c >= 32 && c <= 126) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n      } else if (ASCII_MAP.containsKey((byte) c.charValue())) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, ASCII_MAP.get((byte) c.charValue())));\n      } else {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n      }\n    } else if (String.class.isInstance(obj)) {\n      appendStringBuilder(buf, \"@\");\n      appendStringBuilder(buf, className);\n      appendStringBuilder(buf, \"[\");\n      for (Character c : ((String) obj).toCharArray()) {\n        switch (c) {\n          case '\\n':\n            appendStringBuilder(buf, \"\\\\n\");\n            break;\n          case '\\r':\n            appendStringBuilder(buf, \"\\\\r\");\n            break;\n          default:\n            appendStringBuilder(buf, c.toString());\n        }\n      }\n      appendStringBuilder(buf, \"]\");\n    } else if (Collection.class.isInstance(obj)) {\n      @SuppressWarnings(\"unchecked\")\n      final Collection<Object> collection = (Collection<Object>) obj;\n      if (!isExpand(deep, expand) || collection.isEmpty()) {\n        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n            className, collection.isEmpty(), collection.size()));\n      } else {\n        appendStringBuilder(buf, format(\"@%s[\", className));\n        for (Object e : collection) {\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep + 1; i++) {\n            appendStringBuilder(buf, TAB);\n          }\n          renderObject(e, deep + 1, expand, buf);\n          appendStringBuilder(buf, \",\");\n        }\n        appendStringBuilder(buf, \"\\n\");\n        for (int i = 0; i < deep; i++) {\n          appendStringBuilder(buf, TAB);\n        }\n        appendStringBuilder(buf, \"]\");\n      }\n    } else if (Map.class.isInstance(obj)) {\n      @SuppressWarnings(\"unchecked\")\n      final Map<Object, Object> map = (Map<Object, Object>) obj;\n      if (!isExpand(deep, expand) || map.isEmpty()) {\n        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\",\n            className, map.isEmpty(), map.size()));\n      } else {\n        appendStringBuilder(buf, format(\"@%s[\", className));\n        for (Map.Entry<Object, Object> entry : map.entrySet()) {\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep + 1; i++) {\n            appendStringBuilder(buf, TAB);\n          }\n          renderObject(entry.getKey(), deep + 1, expand, buf);\n          appendStringBuilder(buf, \":\");\n          renderObject(entry.getValue(), deep + 1, expand, buf);\n          appendStringBuilder(buf, \",\");\n        }\n        appendStringBuilder(buf, \"\\n\");\n        for (int i = 0; i < deep; i++) {\n          appendStringBuilder(buf, TAB);\n        }\n        appendStringBuilder(buf, \"]\");\n      }\n    } else if (obj.getClass().isArray()) {\n      final String typeName = obj.getClass().getSimpleName();\n      if (typeName.equals(\"int[]\")) {\n        handleIntArray(obj, deep, expand, buf, typeName, className);\n      } else if (typeName.equals(\"long[]\")) {\n        handleLongArray(obj, deep, expand, buf, typeName, className);\n      } else if (typeName.equals(\"short[]\")) {\n        handleShortArray(obj, deep, expand, buf, typeName, className);\n      } else if (typeName.equals(\"float[]\")) {\n        handleFloatArray(obj, deep, expand, buf, typeName, className);\n      } else if (typeName.equals(\"double[]\")) {\n        handleDoubleArray(obj, deep, expand, buf, typeName, className);\n      } else if (typeName.equals(\"boolean[]\")) {\n        handleBooleanArray(obj, deep, expand, buf, typeName, className);\n      } else if (typeName.equals(\"char[]\")) {\n        handleCharArray(obj, deep, expand, buf, typeName, className);\n      } else if (typeName.equals(\"byte[]\")) {\n        handleByteArray(obj, deep, expand, buf, typeName, className);\n      } else {\n        handleObjectArray(obj, deep, expand, buf, typeName, className);\n      }\n    } else if (Throwable.class.isInstance(obj)) {\n      if (!isExpand(deep, expand)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n      } else {\n        final Throwable throwable = (Throwable) obj;\n        final StringWriter sw = new StringWriter();\n        final PrintWriter pw = new PrintWriter(sw);\n        throwable.printStackTrace(pw);\n        appendStringBuilder(buf, sw.toString());\n      }\n    } else if (Date.class.isInstance(obj)) {\n      appendStringBuilder(buf, format(\"@%s[%s]\", className, \n          new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\").format(obj)));\n    } else if (obj instanceof Enum<?>) {\n      appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n    } else {\n      if (!isExpand(deep, expand)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n      } else {\n        appendStringBuilder(buf, format(\"@%s[\", className));\n        final List<Field> fields;\n        Class<?> objClass = obj.getClass();\n        if (GlobalOptions.printParentFields) {\n          fields = new ArrayList<>();\n          while (objClass != null) {\n            fields.addAll(Arrays.asList(objClass.getDeclaredFields()));\n            objClass = objClass.getSuperclass();\n          }\n        } else {\n          fields = new ArrayList<>(Arrays.asList(objClass.getDeclaredFields()));\n        }\n        for (Field field : fields) {\n          field.setAccessible(true);\n          try {\n            final Object value = field.get(obj);\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n            appendStringBuilder(buf, field.getName());\n            appendStringBuilder(buf, \"=\");\n            renderObject(value, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          } catch (ObjectTooLargeException t) {\n            buf.append(\"...\");\n            break;\n          } catch (Throwable t) {\n            // ignore\n          }\n        }\n        appendStringBuilder(buf, \"\\n\");\n        for (int i = 0; i < deep; i++) {\n          appendStringBuilder(buf, TAB);\n        }\n        appendStringBuilder(buf, \"]\");\n      }\n    }\n  }\n}\n\n// Helper methods for array handling omitted for brevity\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "322", "src_id": "M140", "code": "\nvoid _processDo(int option) throws IOException {\n  if (debugoptions) {\n    System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n  }\n\n  if (__notifhand != null) {\n    __notifhand.receivedNegotiation(\n        TelnetNotificationHandler.RECEIVED_DO,\n        option);\n  }\n\n  boolean acceptNewState = false;\n  if (optionHandlers[option] != null) {\n    acceptNewState = optionHandlers[option].getAcceptLocal();\n  } else if (option == TERMINAL_TYPE) {\n    if (terminalType != null && terminalType.length() > 0) {\n      acceptNewState = true;\n    }\n  }\n\n  if (_willResponse[option] > 0) {\n    --_willResponse[option];\n    if (_willResponse[option] > 0 && _stateIsWill(option)) {\n      --_willResponse[option];\n    }\n  }\n\n  if (_willResponse[option] == 0) {\n    if (_requestedWont(option)) {\n      if (acceptNewState) {\n        _setWantWill(option);\n        _sendWill(option);\n      } else {\n        ++_willResponse[option];\n        _sendWont(option);\n      }\n    } else {\n      // Other end has acknowledged option\n    }\n  }\n  _setWill(option);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "323", "src_id": "M927", "code": "\npublic static Map<String, Map<String, Object>> getLoggers(String name, boolean includeNoAppender) {\n  Map<String, Map<String, Object>> loggerInfoMap = new HashMap<>();\n  if (!Log4j) {\n    return loggerInfoMap;\n  }\n\n  if (name != null && !name.trim().isEmpty()) {\n    Logger logger = LogManager.getLoggerRepository().exists(name);\n    if (logger != null) {\n      loggerInfoMap.put(name, doGetLoggerInfo(logger));\n    }\n  } else {\n    @SuppressWarnings(\"unchecked\")\n    Enumeration<Logger> loggers = LogManager.getLoggerRepository().getCurrentLoggers();\n    if (loggers != null) {\n      while (loggers.hasMoreElements()) {\n        Logger logger = loggers.nextElement();\n        Map<String, Object> info = doGetLoggerInfo(logger);\n        List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n        if (!includeNoAppender) {\n          if (appenders != null && !appenders.isEmpty()) {\n            loggerInfoMap.put(logger.getName(), info);\n          }\n        } else {\n          loggerInfoMap.put(logger.getName(), info);\n        }\n      }\n    }\n\n    Logger root = LogManager.getLoggerRepository().getRootLogger();\n    if (root != null) {\n      Map<String, Object> info = doGetLoggerInfo(root);\n      List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n      if (!includeNoAppender) {\n        if (appenders != null && !appenders.isEmpty()) {\n          loggerInfoMap.put(root.getName(), info);\n        }\n      } else {\n        loggerInfoMap.put(root.getName(), info);\n      }\n    }\n  }\n  return loggerInfoMap;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "324", "src_id": "M464", "code": "\nprivate void initCommands(List<String> disabledCommands) {\n  List<Class<? extends AnnotatedCommand>> commandClassList = new ArrayList<>(33);\n  commandClassList.add(HelpCommand.class);\n  commandClassList.add(AuthCommand.class);\n  commandClassList.add(KeymapCommand.class);\n  commandClassList.add(SearchClassCommand.class);\n  commandClassList.add(SearchMethodCommand.class);\n  commandClassList.add(ClassLoaderCommand.class);\n  commandClassList.add(JadCommand.class);\n  commandClassList.add(GetStaticCommand.class);\n  commandClassList.add(MonitorCommand.class);\n  commandClassList.add(StackCommand.class);\n  commandClassList.add(ThreadCommand.class);\n  commandClassList.add(TraceCommand.class);\n  commandClassList.add(WatchCommand.class);\n  commandClassList.add(TimeTunnelCommand.class);\n  commandClassList.add(JvmCommand.class);\n  commandClassList.add(MemoryCommand.class);\n  commandClassList.add(PerfCounterCommand.class);\n  commandClassList.add(OgnlCommand.class);\n  commandClassList.add(MemoryCompilerCommand.class);\n  commandClassList.add(RedefineCommand.class);\n  commandClassList.add(RetransformCommand.class);\n  commandClassList.add(DashboardCommand.class);\n  commandClassList.add(DumpClassCommand.class);\n  commandClassList.add(HeapDumpCommand.class);\n  commandClassList.add(JulyCommand.class);\n  commandClassList.add(ThanksCommand.class);\n  commandClassList.add(OptionsCommand.class);\n  commandClassList.add(ClsCommand.class);\n  commandClassList.add(ResetCommand.class);\n  commandClassList.add(VersionCommand.class);\n  commandClassList.add(SessionCommand.class);\n  commandClassList.add(SystemPropertyCommand.class);\n  commandClassList.add(SystemEnvCommand.class);\n  commandClassList.add(VMOptionCommand.class);\n  commandClassList.add(LoggerCommand.class);\n  commandClassList.add(HistoryCommand.class);\n  commandClassList.add(CatCommand.class);\n  commandClassList.add(Base64Command.class);\n  commandClassList.add(EchoCommand.class);\n  commandClassList.add(PwdCommand.class);\n  commandClassList.add(MBeanCommand.class);\n  commandClassList.add(GrepCommand.class);\n  commandClassList.add(TeeCommand.class);\n  commandClassList.add(ProfilerCommand.class);\n  commandClassList.add(VmToolCommand.class);\n  commandClassList.add(StopCommand.class);\n  \n  try {\n    if (ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Recording.class\") != null) {\n      commandClassList.add(JFRCommand.class);\n    }\n  } catch (Throwable e) {\n    logger.error(\"This jdk version not support jfr command\");\n  }\n\n  for (Class<? extends AnnotatedCommand> clazz : commandClassList) {\n    Name name = clazz.getAnnotation(Name.class);\n    if (name != null && name.value() != null && !disabledCommands.contains(name.value())) {\n      commands.add(Command.create(clazz));\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "325", "src_id": "M453", "code": "\n@Override\npublic String draw() {\n  StringBuilder buf = new StringBuilder();\n  try {\n    if (GlobalOptions.isUsingJson) {\n      return JSON.toJSONString(object, JSONWriter.Feature.IgnoreErrorGetter);\n    }\n    renderObject(object, 0, deep, buf);\n    return buf.toString();\n  } catch (ObjectTooLargeException e) {\n    buf.append(\" Object size exceeds size limit: \")\n        .append(maxObjectLength)\n        .append(\", try to specify -M size_limit in your command, check the help command for more.\");\n    return buf.toString();\n  } catch (Throwable t) {\n    logger.error(\"ObjectView draw error, object class: {}\", object.getClass(), t);\n    return \"ERROR DATA!!! object class: \" + object.getClass() + \", exception class: \" + t.getClass()\n        + \", exception message: \" + t.getMessage();\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "326", "src_id": "M375", "code": "\npublic static Map<String, String> removeDashKey(Map<String, String> map) {\n  Map<String, String> result = new HashMap<>(map.size());\n  for (Entry<String, String> entry : map.entrySet()) {\n    String key = entry.getKey();\n    if (key.contains(\"-\")) {\n      StringBuilder sb = new StringBuilder(key.length());\n      for (int i = 0; i < key.length(); i++) {\n        if (key.charAt(i) == '-' && (i + 1 < key.length()) && Character.isAlphabetic(key.charAt(i + 1))) {\n          ++i;\n          char upperChar = Character.toUpperCase(key.charAt(i));\n          sb.append(upperChar);\n        } else {\n          sb.append(key.charAt(i));\n        }\n      }\n      key = sb.toString();\n    }\n    result.put(key, entry.getValue());\n  }\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "327", "src_id": "M306", "code": "\nfinal void advance() {\n  if (nextEntry != null && (nextEntry = nextEntry.next) != null) {\n    return;\n  }\n\n  while (nextTableIndex >= 0) {\n    if ((nextEntry = currentTable[nextTableIndex--]) != null) {\n      return;\n    }\n  }\n\n  while (nextSegmentIndex >= 0) {\n    Segment<K, V> seg = segments[nextSegmentIndex--];\n    if (seg.count != 0) {\n      currentTable = seg.table;\n      for (int j = currentTable.length - 1; j >= 0; --j) {\n        if ((nextEntry = currentTable[j]) != null) {\n          nextTableIndex = j - 1;\n          return;\n        }\n      }\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "328", "src_id": "M1338", "code": "\npublic static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n  for (Enum candidate : enumValues) {\n    if (caseSensitive) {\n      if (candidate.toString().equals(constant)) {\n        return true;\n      }\n    } else if (candidate.toString().equalsIgnoreCase(constant)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "329", "src_id": "M185", "code": "\nsynchronized public long size() throws IOException {\n    if (log.isTraceEnabled()) {\n        log.trace(\"size() called\");\n    }\n\n    if (this.endtime >= src.getEndTime()) {\n        return src.size() - skippedAtStart;\n    }\n    \n    long pos = in.getPosition();\n    \n    if (log.isTraceEnabled()) {\n        log.trace(\"saved pos: {}\", pos);\n    }\n    \n    LogEntry e;\n  \n    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);\n    in.seek(lastseg.getBytes());\n    buf = \"\";  // clear buf to avoid pre-seek data\n    long count = lastseg.getEntriesSkipped() - skippedAtStart; \n\n    while ((e = readNextEntry()) != null) {\n        if (log.isTraceEnabled()) {\n            //log.trace(\"Entry: {}\", e);\n        }\n        if (e.getTimestamp() > this.endtime) {\n            break;\n        }\n        count++;\n    }\n    in.seek(pos);\n    buf = \"\";\n\n    if (log.isTraceEnabled()) {\n        log.trace(\"size: {}\", count);\n    }\n    \n    return count;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "330", "src_id": "M1043", "code": "\nvoid handleWrite(SelectionKey k) throws IOException {\n    if (outgoingBuffers.isEmpty()) {\n        return;\n    }\n\n    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n    if (directBuffer == null) {\n        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n        sock.write(outgoingBuffers.toArray(bufferList));\n\n        ByteBuffer bb;\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (bb.remaining() > 0) {\n                break;\n            }\n            outgoingBuffers.remove();\n        }\n    } else {\n        directBuffer.clear();\n\n        for (ByteBuffer b : outgoingBuffers) {\n            if (directBuffer.remaining() < b.remaining()) {\n                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n            }\n            int p = b.position();\n            directBuffer.put(b);\n            b.position(p);\n            if (directBuffer.remaining() == 0) {\n                break;\n            }\n        }\n        directBuffer.flip();\n\n        int sent = sock.write(directBuffer);\n        ByteBuffer bb;\n\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (sent < bb.remaining()) {\n                bb.position(bb.position() + sent);\n                break;\n            }\n            sent -= bb.remaining();\n            outgoingBuffers.remove();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "331", "src_id": "M1150", "code": "\nprivate void select() {\n    try {\n        selector.select();\n\n        Set<SelectionKey> selected = selector.selectedKeys();\n        ArrayList<SelectionKey> selectedList = new ArrayList<>(selected);\n        Collections.shuffle(selectedList);\n        \n        Iterator<SelectionKey> selectedKeys = selectedList.iterator();\n        while (!stopped && selectedKeys.hasNext()) {\n            SelectionKey key = selectedKeys.next();\n            selected.remove(key);\n\n            if (!key.isValid()) {\n                cleanupSelectionKey(key);\n                continue;\n            }\n            \n            if (key.isReadable() || key.isWritable()) {\n                handleIO(key);\n            } else {\n                log.warn(\"Unexpected ops in select: {}\", key.readyOps());\n            }\n        }\n    } catch (IOException e) {\n        log.warn(\"Ignoring IOException during selection\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "332", "src_id": "M520", "code": "\n@Override\npublic void close() throws IOException {\n    boolean triedToClose = false;\n    boolean success = false;\n    \n    try {\n        flush();\n        ((FileOutputStream) out).getFD().sync();\n\n        triedToClose = true;\n        super.close();\n        success = true;\n    } finally {\n        if (success) {\n            if (!tmpFile.renameTo(origFile)) {\n                if (!origFile.delete() || !tmpFile.renameTo(origFile)) {\n                    throw new IOException(\n                        \"Could not rename temporary file \" + tmpFile + \" to \" + origFile\n                    );\n                }\n            }\n        } else {\n            if (!triedToClose) {\n                IOUtils.closeStream(out);\n            }\n            if (!tmpFile.delete()) {\n                log.warn(\"Unable to delete tmp file: {}\", tmpFile);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "333", "src_id": "M1154", "code": "\npublic void doWork() throws InterruptedException {\n    if (!key.isValid()) {\n        selectorThread.cleanupSelectionKey(key);\n        return;\n    }\n\n    if (key.isReadable() || key.isWritable()) {\n        cnxn.doIO(key);\n\n        if (stopped) {\n            cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            return;\n        }\n        if (!key.isValid()) {\n            selectorThread.cleanupSelectionKey(key);\n            return;\n        }\n        touchCnxn(cnxn);\n    }\n\n    cnxn.enableSelectable();\n    if (!selectorThread.addInterestOpsUpdateRequest(key)) {\n        cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "334", "src_id": "M290", "code": "\npublic String getStatus(String name, long timeout) \n        throws KeeperException, InterruptedException {\n        \n    Stat stat = new Stat();\n    byte[] data = null;\n    long endTime = Time.currentElapsedTime() + timeout;\n    KeeperException lastException = null;\n    \n    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n        try {\n            data = zk.getData(reportsNode + '/' + name, false, stat);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Got Data: {}\", (data == null) ? \"null\" : new String(data));\n            }\n            lastException = null;\n            break;\n        } catch (ConnectionLossException e) {\n            lastException = e;\n        } catch (NoNodeException e) {\n            final Object eventObj = new Object();\n            synchronized (eventObj) {\n                Stat eStat = zk.exists(reportsNode + '/' + name, event -> {\n                    synchronized (eventObj) {\n                        eventObj.notifyAll();\n                    }\n                });\n                if (eStat == null) {\n                    eventObj.wait(endTime - Time.currentElapsedTime());\n                }\n            }\n            lastException = e;\n        }\n    }\n    \n    if (lastException != null) {\n        throw lastException;\n    }\n    return new String(data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "335", "src_id": "M196", "code": "\npublic static void main(String[] args) throws IOException {\n    MergedLogSource source = new MergedLogSource(args);\n    \n    try (\n        PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n        PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n        PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n        PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")))\n    ) {\n        LogIterator iter;\n        log.info(\"Source: {}\", source);\n        \n        iter = source.iterator();\n        long currentms = 0;\n        long currentsec = 0;\n        long currentmin = 0;\n        long currenthour = 0;\n        Set<Long> zxids_ms = new HashSet<>();\n        long zxid_sec = 0;\n        long zxid_min = 0;\n        long zxid_hour = 0;\n\n        while (iter.hasNext()) {\n            LogEntry e = iter.next();\n            TransactionEntry cxn = (TransactionEntry) e;\n            \n            long ms = cxn.getTimestamp();\n            long sec = ms / MS_PER_SEC;\n            long min = ms / MS_PER_MIN;\n            long hour = ms / MS_PER_HOUR;\n\n            if (currentms != ms && currentms != 0) {\n                ps_ms.println(currentms + \" \" + zxids_ms.size());\n                zxid_sec += zxids_ms.size();\n                zxid_min += zxids_ms.size();\n                zxid_hour += zxids_ms.size();\n                zxids_ms.clear();\n            }\n\n            if (currentsec != sec && currentsec != 0) {\n                ps_sec.println(currentsec * MS_PER_SEC + \" \" + zxid_sec);\n                zxid_sec = 0;\n            }\n\n            if (currentmin != min && currentmin != 0) {\n                ps_min.println(currentmin * MS_PER_MIN + \" \" + zxid_min);\n                zxid_min = 0;\n            }\n\n            if (currenthour != hour && currenthour != 0) {\n                ps_hour.println(currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n                zxid_hour = 0;\n            }\n\n            currentms = ms;\n            currentsec = sec;\n            currentmin = min;\n            currenthour = hour;\n            zxids_ms.add(cxn.getZxid());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "336", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                log.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                log.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        for (SelectionKey key : selector.keys()) {\n            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        \n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        NIOServerCnxnFactory.this.stop();\n        log.info(\"selector thread exited\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "337", "src_id": "M219", "code": "\nsynchronized public static ZooKeeper getClient(\n        String contextPath, String session, int expireTime) throws IOException {\n        \n    final String connectionId = concat(contextPath, session);\n    ZooKeeper zk = zkMap.get(connectionId);\n    \n    if (zk == null) {\n        log.info(\"creating new connection for: '{}'\", connectionId);\n        Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n        \n        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", \n                String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes()\n            );\n        }\n        \n        zkMap.put(connectionId, zk);\n\n        if (session != null) {\n            zkSessionTimers.put(connectionId, \n                new SessionTimerTask(expireTime, session, contextPath, timer)\n            );\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "338", "src_id": "M852", "code": "\n    public InputStream getView(int size) {\n        if (view != null) {\n            viewSize = size;\n            return view;\n        }\n\n        view = new InputStream() {\n            @Override\n            public int read() throws IOException {\n                if (viewSize < 1) return -1;\n                int res = DataReader.this.read();\n                if (res > 0) viewSize--;\n                return res;\n            }\n\n            @Override\n            public int read(byte[] buffer) throws IOException {\n                return read(buffer, 0, buffer.length);\n            }\n\n            @Override\n            public int read(byte[] buffer, int offset, int count) throws IOException {\n                if (viewSize < 1) return -1;\n                int res = DataReader.this.read(buffer, offset, Math.min(viewSize, count));\n                viewSize -= res;\n                return res;\n            }\n\n            @Override\n            public long skip(long amount) throws IOException {\n                if (viewSize < 1) return 0;\n                int res = (int) DataReader.this.skipBytes(Math.min(amount, viewSize));\n                viewSize -= res;\n                return res;\n            }\n\n            @Override\n            public int available() {\n                return viewSize;\n            }\n\n            @Override\n            public void close() {\n                viewSize = 0;\n            }\n\n            @Override\n            public boolean markSupported() {\n                return false;\n            }\n        };\n\n        viewSize = size;\n        return view;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "339", "src_id": "M1086", "code": "\n    private List<Object> getSpecialItems() {\n        synchronized (DownloadManager.this) {\n            List<Mission> pending = new ArrayList<>(mMissionsPending);\n            List<Mission> finished = new ArrayList<>(mMissionsFinished);\n            List<Mission> remove = new ArrayList<>(hidden);\n\n            remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n            int fakeTotal = pending.size();\n            if (fakeTotal > 0) fakeTotal++;\n            fakeTotal += finished.size();\n            if (finished.size() > 0) fakeTotal++;\n\n            List<Object> list = new ArrayList<>(fakeTotal);\n            if (!pending.isEmpty()) {\n                list.add(PENDING);\n                list.addAll(pending);\n            }\n            if (!finished.isEmpty()) {\n                list.add(FINISHED);\n                list.addAll(finished);\n            }\n\n            hasFinished = !finished.isEmpty();\n            return list;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "340", "src_id": "M1066", "code": "\n    private void loadPendingMissions(Context ctx) {\n        File[] subs = mPendingMissionsDir.listFiles();\n\n        if (subs == null) {\n            Log.e(TAG, \"listFiles() returned null\");\n            return;\n        }\n        if (subs.length < 1) return;\n        if (DEBUG) Log.d(TAG, \"Loading pending downloads from: \" + mPendingMissionsDir.getAbsolutePath());\n\n        File tempDir = pickAvailableTemporalDir(ctx);\n        Log.i(TAG, \"Using '\" + tempDir + \"' as temporal directory\");\n\n        for (File sub : subs) {\n            if (!sub.isFile() || sub.getName().equals(\".tmp\")) continue;\n\n            DownloadMission mis = Utility.readFromFile(sub);\n            if (mis == null || mis.isFinished() || mis.hasInvalidStorage()) {\n                sub.delete();\n                continue;\n            }\n\n            mis.threads = new Thread[0];\n            boolean exists;\n\n            try {\n                mis.storage = StoredFileHelper.deserialize(mis.storage, ctx);\n                exists = !mis.storage.isInvalid() && mis.storage.existsAsFile();\n            } catch (Exception ex) {\n                Log.e(TAG, \"Failed to load file source: \" + mis.storage, ex);\n                mis.storage.invalidate();\n                exists = false;\n            }\n\n            if (mis.isPsRunning()) {\n                if (mis.psAlgorithm.worksOnSameFile && exists && mis.storage.isDirect() && !mis.storage.delete()) {\n                    Log.w(TAG, \"Unable to delete incomplete file: \" + sub);\n                }\n                mis.psState = 0;\n                mis.errCode = DownloadMission.ERROR_POSTPROCESSING_STOPPED;\n            } else if (!exists) {\n                tryRecover(mis);\n                if (mis.isInitialized()) mis.resetState(true, true, DownloadMission.ERROR_PROGRESS_LOST);\n            }\n\n            if (mis.psAlgorithm != null) {\n                mis.psAlgorithm.cleanupTemporalDir();\n                mis.psAlgorithm.setTemporalDir(tempDir);\n            }\n\n            mis.metadata = sub;\n            mis.maxRetry = mPrefMaxRetry;\n            mis.mHandler = mHandler;\n            mMissionsPending.add(mis);\n        }\n\n        if (mMissionsPending.size() > 1) {\n            Collections.sort(mMissionsPending, Comparator.comparingLong(Mission::getTimestamp));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "341", "src_id": "M1055", "code": "\n    public void updateMission(Mission mission) {\n        ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n        SQLiteDatabase database = getWritableDatabase();\n        String ts = String.valueOf(mission.timestamp);\n\n        int rowsAffected;\n        if (mission instanceof FinishedMission) {\n            if (mission.storage.isInvalid()) {\n                rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new String[]{ts});\n            } else {\n                rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_PATH + \" = ?\", \n                    new String[]{mission.storage.getUri().toString()});\n            }\n        } else {\n            throw new UnsupportedOperationException(\"DownloadMission\");\n        }\n\n        if (rowsAffected != 1) {\n            Log.e(\"FinishedMissionStore\", \"Expected 1 affected row, got \" + rowsAffected);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "342", "src_id": "M1058", "code": "\n    private void startMission(Intent intent) {\n        String[] urls = intent.getStringArrayExtra(EXTRA_URLS);\n        Uri path = IntentCompat.getParcelableExtra(intent, EXTRA_PATH, Uri.class);\n        Uri parentPath = IntentCompat.getParcelableExtra(intent, EXTRA_PARENT_PATH, Uri.class);\n        int threads = intent.getIntExtra(EXTRA_THREADS, 1);\n        char kind = intent.getCharExtra(EXTRA_KIND, '?');\n        String psName = intent.getStringExtra(EXTRA_POSTPROCESSING_NAME);\n        String[] psArgs = intent.getStringArrayExtra(EXTRA_POSTPROCESSING_ARGS);\n        String source = intent.getStringExtra(EXTRA_SOURCE);\n        long nearLength = intent.getLongExtra(EXTRA_NEAR_LENGTH, 0);\n        String tag = intent.getStringExtra(EXTRA_STORAGE_TAG);\n        final var recovery = IntentCompat.getParcelableArrayListExtra(intent, EXTRA_RECOVERY_INFO, MissionRecoveryInfo.class);\n        Objects.requireNonNull(recovery);\n\n        StoredFileHelper storage;\n        try {\n            storage = new StoredFileHelper(this, parentPath, path, tag);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        Postprocessing ps = null;\n        if (psName != null) {\n            ps = Postprocessing.getAlgorithm(psName, psArgs);\n        }\n\n        DownloadMission mission = new DownloadMission(urls, storage, kind, ps);\n        mission.threadCount = threads;\n        mission.source = source;\n        mission.nearLength = nearLength;\n        mission.recoveryInfo = recovery.toArray(new MissionRecoveryInfo[0]);\n\n        if (ps != null) {\n            ps.setTemporalDir(DownloadManager.pickAvailableTemporalDir(this));\n        }\n\n        handleConnectivityState(true);\n        mManager.startMission(mission);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "343", "src_id": "M1024", "code": "\n    @Override\n    public void run() {\n        if (mMission.current > 0) mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n\n        int retryCount = 0;\n        int httpCode = 204;\n\n        while (true) {\n            try {\n                if (mMission.blocks == null && mMission.current == 0) {\n                    long finalLength = 0;\n                    long lowestSize = Long.MAX_VALUE;\n\n                    for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                        mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                        mMission.establishConnection(mId, mConn);\n                        dispose();\n                        if (Thread.interrupted()) return;\n\n                        long length = Utility.getTotalContentLength(mConn);\n                        if (i == 0) {\n                            httpCode = mConn.getResponseCode();\n                            mMission.length = length;\n                        }\n                        if (length > 0) finalLength += length;\n                        if (length < lowestSize) lowestSize = length;\n                    }\n\n                    mMission.nearLength = finalLength;\n                    if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                        mMission.offsets[0] = (lowestSize < 1) ? \n                            RESERVE_SPACE_DEFAULT : \n                            Math.min(lowestSize, RESERVE_SPACE_MAXIMUM);\n                    }\n                } else {\n                    mConn = mMission.openConnection(true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n                    if (!mMission.running || Thread.interrupted()) return;\n\n                    httpCode = mConn.getResponseCode();\n                    mMission.length = Utility.getTotalContentLength(mConn);\n                }\n\n                if (mMission.length == 0 || httpCode == 204) {\n                    mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                    return;\n                }\n\n                if (mMission.length == -1 && httpCode == 200) {\n                    mMission.blocks = new int[0];\n                    mMission.length = 0;\n                    mMission.unknownLength = true;\n                } else {\n                    mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n                    if (!mMission.running || Thread.interrupted()) return;\n\n                    synchronized (mMission.LOCK) {\n                        if (mConn.getResponseCode() == 206) {\n                            mMission.blocks = (mMission.threadCount > 1) ? \n                                new int[(int) (mMission.length / DownloadMission.BLOCK_SIZE) + 1] : \n                                new int[0];\n                        } else {\n                            mMission.blocks = new int[0];\n                            mMission.unknownLength = false;\n                        }\n                    }\n                    if (!mMission.running || Thread.interrupted()) return;\n                }\n\n                try (SharpStream fs = mMission.storage.getStream()) {\n                    fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                    fs.seek(mMission.offsets[mMission.current]);\n                }\n                if (!mMission.running || Thread.interrupted()) return;\n\n                if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                    MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n                    String entityTag = mConn.getHeaderField(\"ETAG\");\n                    String lastModified = mConn.getHeaderField(\"Last-Modified\");\n\n                    if (!TextUtils.isEmpty(entityTag)) {\n                        recovery.setValidateCondition(entityTag);\n                    } else if (!TextUtils.isEmpty(lastModified)) {\n                        recovery.setValidateCondition(lastModified);\n                    } else {\n                        recovery.setValidateCondition(null);\n                    }\n                }\n\n                mMission.running = false;\n                break;\n            } catch (InterruptedIOException | ClosedByInterruptException e) {\n                return;\n            } catch (Exception e) {\n                if (!mMission.running || super.isInterrupted()) return;\n\n                if (e instanceof DownloadMission.HttpError && \n                    ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                    interrupt();\n                    mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                    return;\n                }\n\n                if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                    mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                    return;\n                }\n\n                if (retryCount++ > mMission.maxRetry) {\n                    Log.e(TAG, \"Initializer failed\", e);\n                    mMission.notifyError(e);\n                    return;\n                }\n                Log.e(TAG, \"Initializer failed, retrying\", e);\n            }\n        }\n        mMission.start();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "344", "src_id": "M1037", "code": "\n    public void pause() {\n        if (!running) return;\n        if (isPsRunning()) {\n            if (DEBUG) Log.w(TAG, \"Pause during post-processing is not applicable\");\n            return;\n        }\n\n        running = false;\n        notify(DownloadManagerService.MESSAGE_PAUSED);\n\n        if (init != null && init.isAlive()) {\n            init.interrupt();\n            synchronized (LOCK) {\n                resetState(false, true, ERROR_NOTHING);\n            }\n            return;\n        }\n\n        if (DEBUG && unknownLength) {\n            Log.w(TAG, \"Pausing non-resumable download (server doesn't support range requests)\");\n        }\n        init = null;\n        pauseThreads();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "345", "src_id": "M1079", "code": "\n    boolean runMissions() {\n        synchronized (this) {\n            if (mMissionsPending.isEmpty()) return false;\n            if (!canDownloadInCurrentNetwork()) return false;\n            if (mPrefQueueLimit) {\n                for (DownloadMission mission : mMissionsPending) {\n                    if (mission.running) return true;\n                }\n            }\n\n            boolean flag = false;\n            for (DownloadMission mission : mMissionsPending) {\n                if (mission.running || !mission.enqueued || mission.isFinished()) continue;\n                resumeMission(mission);\n                if (mission.errCode != DownloadMission.ERROR_NOTHING) continue;\n                if (mPrefQueueLimit) return true;\n                flag = true;\n            }\n            return flag;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "346", "src_id": "M1035", "code": "\n    private void notifyPostProcessing(int state) {\n        String action = switch (state) {\n            case 1 -> \"Running\";\n            case 2 -> \"Completed\";\n            default -> \"Failed\";\n        };\n\n        Log.d(TAG, action + \" postprocessing on \" + storage.getName());\n        if (state == 2) {\n            psState = state;\n            return;\n        }\n\n        synchronized (LOCK) {\n            psState = state;\n            writeThisToFile();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "347", "src_id": "M521", "code": "\nprivate static String decodeQRCode(BufferedImage bufferedImage) {\n    LuminanceSource source;\n\n    if (bufferedImage.getRaster().getDataBuffer() instanceof DataBufferByte dataBufferByte) {\n        byte[] pixels = dataBufferByte.getData();\n        source = new PlanarYUVLuminanceSource(\n            pixels,\n            bufferedImage.getWidth(),\n            bufferedImage.getHeight(),\n            0, 0,\n            bufferedImage.getWidth(),\n            bufferedImage.getHeight(),\n            false\n        );\n    } else if (bufferedImage.getRaster().getDataBuffer() instanceof DataBufferInt dataBufferInt) {\n        int[] pixels = dataBufferInt.getData();\n        byte[] newPixels = new byte[pixels.length];\n        for (int i = 0; i < pixels.length; i++) {\n            newPixels[i] = (byte) (pixels[i] & 0xff);\n        }\n        source = new PlanarYUVLuminanceSource(\n            newPixels,\n            bufferedImage.getWidth(),\n            bufferedImage.getHeight(),\n            0, 0,\n            bufferedImage.getWidth(),\n            bufferedImage.getHeight(),\n            false\n        );\n    } else {\n        throw new IllegalArgumentException(\n            \"BufferedImage must have 8-bit gray scale, 24-bit RGB, 32-bit ARGB (packed int), \" +\n            \"byte gray, or 3-byte/4-byte RGB image data\"\n        );\n    }\n\n    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));\n    try {\n        Result result = new MultiFormatReader().decode(bitmap);\n        return result.getText();\n    } catch (NotFoundException e) {\n        return null; // No QR code found\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "348", "src_id": "M177", "code": "\nprivate void executeJob(QueuedJob job) {\n    if (job.cancelled) {\n        log.debug(\"Job {} was cancelled, not executing\", job.jobId);\n        return;\n    }\n\n    jobExecutor.execute(() -> {\n        log.debug(\"Executing queued job {} (queued at {})\", job.jobId, job.queuedAt);\n        try {\n            Object result = executeWithTimeout(job.work, job.timeoutMs);\n            job.future.complete(\n                result instanceof ResponseEntity \n                    ? (ResponseEntity<?>) result \n                    : ResponseEntity.ok(result)\n            );\n        } catch (Exception e) {\n            log.error(\"Error executing queued job {}: {}\", job.jobId, e.getMessage(), e);\n            job.future.completeExceptionally(e);\n        }\n    });\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "349", "src_id": "M843", "code": "\n@DeleteMapping(\"/api/v1/general/job/{jobId}\")\npublic ResponseEntity<?> cancelJob(@PathVariable(\"jobId\") String jobId) {\n    log.debug(\"Request to cancel job: {}\", jobId);\n\n    Object sessionJobIds = request.getSession().getAttribute(\"userJobIds\");\n    if (sessionJobIds == null \n        || !(sessionJobIds instanceof java.util.Set) \n        || !((java.util.Set<?>) sessionJobIds).contains(jobId)) {\n        log.warn(\"Unauthorized attempt to cancel job: {}\", jobId);\n        return ResponseEntity.status(403)\n            .body(Map.of(\"message\", \"You are not authorized to cancel this job\"));\n    }\n\n    boolean cancelled = false;\n    int queuePosition = -1;\n\n    if (jobQueue.isJobQueued(jobId)) {\n        queuePosition = jobQueue.getJobPosition(jobId);\n        cancelled = jobQueue.cancelJob(jobId);\n        log.info(\"Cancelled queued job: {} (was at position {})\", job.jobId, queuePosition);\n    }\n\n    if (!cancelled) {\n        JobResult result = taskManager.getJobResult(jobId);\n        if (result != null && !result.isComplete()) {\n            taskManager.setError(jobId, \"Job was cancelled by user\");\n            cancelled = true;\n            log.info(\"Marked job as cancelled in TaskManager: {}\", jobId);\n        }\n    }\n\n    if (cancelled) {\n        return ResponseEntity.ok(Map.of(\n            \"message\", \"Job cancelled successfully\",\n            \"wasQueued\", queuePosition >= 0,\n            \"queuePosition\", queuePosition >= 0 ? queuePosition : \"n/a\"\n        ));\n    } else {\n        JobResult result = taskManager.getJobResult(jobId);\n        if (result == null) {\n            return ResponseEntity.notFound().build();\n        } else if (result.isComplete()) {\n            return ResponseEntity.badRequest()\n                .body(Map.of(\"message\", \"Cannot cancel job that is already complete\"));\n        } else {\n            return ResponseEntity.internalServerError()\n                .body(Map.of(\"message\", \"Failed to cancel job for unknown reason\"));\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "350", "src_id": "M516", "code": "\npublic ResponseEntity<String> printFile(@ModelAttribute PrintFileRequest request) throws IOException {\n    MultipartFile file = request.getFileInput();\n    String originalFilename = file.getOriginalFilename();\n    if (originalFilename != null && (originalFilename.contains(\"..\") || Paths.get(originalFilename).isAbsolute())) {\n        throw new IOException(\"Invalid file path detected: \" + originalFilename);\n    }\n    \n    String printerName = request.getPrinterName();\n    String contentType = file.getContentType();\n    try {\n        PrintService selectedService = Arrays.stream(PrintServiceLookup.lookupPrintServices(null, null))\n            .filter(service -> service.getName().toLowerCase().contains(printerName))\n            .findFirst()\n            .orElseThrow(() -> new IllegalArgumentException(\"No matching printer found\"));\n\n        log.info(\"Selected Printer: {}\", selectedService.getName());\n\n        if (\"application/pdf\".equals(contentType)) {\n            try (PDDocument document = Loader.loadPDF(file.getBytes())) {\n                PrinterJob job = PrinterJob.getPrinterJob();\n                job.setPrintService(selectedService);\n                job.setPageable(new PDFPageable(document));\n                job.print();\n            }\n        } else if (contentType != null && contentType.startsWith(\"image/\")) {\n            BufferedImage image = ImageIO.read(file.getInputStream());\n            PrinterJob job = PrinterJob.getPrinterJob();\n            job.setPrintService(selectedService);\n            job.setPrintable((graphics, pageFormat, pageIndex) -> {\n                if (pageIndex != 0) return NO_SUCH_PAGE;\n                Graphics2D g2d = (Graphics2D) graphics;\n                g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n                g2d.drawImage(\n                    image, \n                    0, \n                    0, \n                    (int) pageFormat.getImageableWidth(), \n                    (int) pageFormat.getImageableHeight(), \n                    null\n                );\n                return PAGE_EXISTS;\n            });\n            job.print();\n        }\n        return ResponseEntity.ok(\"File printed successfully to \" + selectedService.getName());\n    } catch (Exception e) {\n        log.error(\"Failed to print: {}\", e.getMessage());\n        return ResponseEntity.badRequest().body(e.getMessage());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "351", "src_id": "M522", "code": "\n@PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\")\n@Operation(\n    summary = \"Auto split PDF pages into separate documents\",\n    description = \"Accepts PDF file, scans each page for QR code, splits document at boundaries. Output: ZIP of PDFs\"\n)\npublic ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request) throws IOException {\n    MultipartFile file = request.getFileInput();\n    boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n    List<PDDocument> splitDocuments = new ArrayList<>();\n    \n    try (PDDocument document = pdfDocumentFactory.load(file.getInputStream())) {\n        PDFRenderer pdfRenderer = new PDFRenderer(document);\n        pdfRenderer.setSubsamplingAllowed(true);\n        \n        for (int page = 0; page < document.getNumberOfPages(); ++page) {\n            BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n            String result = decodeQRCode(bim);\n            boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n            log.debug(\"Detected QR code {}, valid={}\", result, isValidQrCode);\n            \n            if (isValidQrCode && page != 0) {\n                splitDocuments.add(new PDDocument());\n            }\n            \n            if (!splitDocuments.isEmpty() && !isValidQrCode) {\n                splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n            } else if (page == 0) {\n                PDDocument firstDoc = new PDDocument();\n                firstDoc.addPage(document.getPage(page));\n                splitDocuments.add(firstDoc);\n            }\n            \n            if (duplexMode && isValidQrCode) {\n                page++;\n            }\n        }\n        \n        splitDocuments.removeIf(doc -> doc.getNumberOfPages() == 0);\n        String filename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\");\n        Path zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n        \n        try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile))) {\n            for (int i = 0; i < splitDocuments.size(); i++) {\n                PDDocument doc = splitDocuments.get(i);\n                String entryName = filename + \"_\" + (i + 1) + \".pdf\";\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                doc.save(baos);\n                zipOut.putNextEntry(new ZipEntry(entryName));\n                zipOut.write(baos.toByteArray());\n                zipOut.closeEntry();\n                doc.close();\n            }\n        }\n        \n        byte[] data = Files.readAllBytes(zipFile);\n        return WebResponseUtils.bytesToWebResponse(\n            data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM\n        );\n    } catch (Exception e) {\n        log.error(\"Error in auto split\", e);\n        throw e;\n    } finally {\n        splitDocuments.forEach(doc -> {\n            try { doc.close(); } \n            catch (IOException ex) { log.error(\"Error closing split document\", ex); }\n        });\n        try { Files.deleteIfExists(zipFile); } \n        catch (IOException ex) { log.error(\"Error deleting temporary zip\", ex); }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "352", "src_id": "M550", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/auto-rename\")\n@Operation(\n    summary = \"Extract header from PDF file\",\n    description = \"Accepts PDF file, extracts title/header using heuristics\"\n)\npublic ResponseEntity<byte[]> extractHeader(@ModelAttribute ExtractHeaderRequest request) throws Exception {\n    MultipartFile file = request.getFileInput();\n    boolean useFirstTextFallback = Boolean.TRUE.equals(request.getUseFirstTextAsFallback());\n    \n    try (PDDocument document = pdfDocumentFactory.load(file)) {\n        PDFTextStripper reader = new HeaderExtractionStripper(useFirstTextFallback);\n        String header = reader.getText(document);\n        \n        if (header != null && header.length() < 255) {\n            String sanitized = header.replaceAll(\"[/\\\\\\\\?%*:|\\\"<>]\", \"\").trim();\n            return WebResponseUtils.pdfDocToWebResponse(document, sanitized + \".pdf\");\n        } else {\n            log.info(\"File has no valid title\");\n            return WebResponseUtils.pdfDocToWebResponse(\n                document, Filenames.toSimpleFileName(file.getOriginalFilename())\n            );\n        }\n    }\n}\n\nprivate static class HeaderExtractionStripper extends PDFTextStripper {\n    private static final int LINE_LIMIT = 100;\n    private final boolean useFirstTextFallback;\n    private List<LineInfo> lineInfos = new ArrayList<>();\n    private StringBuilder lineBuilder;\n    private float lastY = -1;\n    private float maxFontSizeInLine;\n    private int lineCount;\n    \n    HeaderExtractionStripper(boolean useFirstTextFallback) throws IOException {\n        this.useFirstTextFallback = useFirstTextFallback;\n    }\n    \n    @Override\n    protected void processTextPosition(TextPosition text) {\n        if (lastY != text.getY() && lineCount < LINE_LIMIT) {\n            processLine();\n            lineBuilder = new StringBuilder(text.getUnicode());\n            maxFontSizeInLine = text.getFontSizeInPt();\n            lastY = text.getY();\n            lineCount++;\n        } else if (lineCount < LINE_LIMIT) {\n            lineBuilder.append(text.getUnicode());\n            maxFontSizeInLine = Math.max(maxFontSizeInLine, text.getFontSizeInPt());\n        }\n    }\n    \n    private void processLine() {\n        if (lineBuilder.length() > 0 && lineCount < LINE_LIMIT) {\n            lineInfos.add(new LineInfo(lineBuilder.toString(), maxFontSizeInLine));\n        }\n    }\n    \n    @Override\n    public String getText(PDDocument doc) throws IOException {\n        resetState();\n        super.getText(doc);\n        processLine();\n        \n        List<LineInfo> merged = mergeLines();\n        merged.sort(Comparator.comparing((LineInfo li) -> li.fontSize).reversed());\n        \n        return merged.isEmpty() \n            ? null \n            : (useFirstTextFallback \n                ? merged.get(merged.size() - 1).text \n                : merged.get(0).text);\n    }\n    \n    private void resetState() {\n        lineInfos.clear();\n        lineBuilder = new StringBuilder();\n        lastY = -1;\n        maxFontSizeInLine = 0f;\n        lineCount = 0;\n    }\n    \n    private List<LineInfo> mergeLines() {\n        List<LineInfo> merged = new ArrayList<>();\n        for (int i = 0; i < lineInfos.size(); i++) {\n            String text = lineInfos.get(i).text;\n            float fontSize = lineInfos.get(i).fontSize;\n            while (i + 1 < lineInfos.size() && lineInfos.get(i+1).fontSize == fontSize) {\n                text += \" \" + lineInfos.get(++i).text;\n            }\n            merged.add(new LineInfo(text, fontSize));\n        }\n        return merged;\n    }\n    \n    private static class LineInfo {\n        final String text;\n        final float fontSize;\n        \n        LineInfo(String text, float fontSize) {\n            this.text = text;\n            this.fontSize = fontSize;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "353", "src_id": "M618", "code": "\n@PostMapping(value = \"/validate-signature\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\npublic ResponseEntity<List<SignatureValidationResult>> validateSignature(\n        @ModelAttribute SignatureValidationRequest request) throws IOException {\n        \n    List<SignatureValidationResult> results = new ArrayList<>();\n    MultipartFile file = request.getFileInput();\n    MultipartFile certFile = request.getCertFile();\n    X509Certificate customCert = null;\n    \n    if (certFile != null && !certFile.isEmpty()) {\n        try (ByteArrayInputStream certStream = new ByteArrayInputStream(certFile.getBytes())) {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            customCert = (X509Certificate) cf.generateCertificate(certStream);\n        } catch (CertificateException e) {\n            throw ExceptionUtils.createRuntimeException(\n                \"error.invalidFormat\", \"Invalid certificate format: {}\", e, e.getMessage());\n        }\n    }\n    \n    try (PDDocument document = pdfDocumentFactory.load(file.getInputStream())) {\n        for (PDSignature sig : document.getSignatureDictionaries()) {\n            SignatureValidationResult result = validateSignature(sig, file, customCert);\n            results.add(result);\n        }\n    }\n    return ResponseEntity.ok(results);\n}\n\nprivate SignatureValidationResult validateSignature(PDSignature sig, MultipartFile file, X509Certificate customCert) {\n    SignatureValidationResult result = new SignatureValidationResult();\n    try {\n        byte[] signedContent = sig.getSignedContent(file.getInputStream());\n        byte[] signatureBytes = sig.getContents(file.getInputStream());\n        CMSSignedData signedData = new CMSSignedData(new CMSProcessableByteArray(signedContent), signatureBytes);\n        SignerInformationStore signerStore = signedData.getSignerInfos();\n        \n        for (SignerInformation signer : signerStore.getSigners()) {\n            X509CertificateHolder certHolder = (X509CertificateHolder) \n                signedData.getCertificates().getMatches(signer.getSID()).iterator().next();\n            X509Certificate cert = new JcaX509CertificateConverter().getCertificate(certHolder);\n            \n            result.setValid(signer.verify(new JcaSimpleSignerInfoVerifierBuilder().build(cert)));\n            result.setChainValid(customCert != null \n                ? certValidationService.validateCertificateChainWithCustomCert(cert, customCert)\n                : certValidationService.validateCertificateChain(cert));\n                \n            result.setTrustValid(customCert != null\n                ? certValidationService.validateTrustWithCustomCert(cert, customCert)\n                : certValidationService.validateTrustStore(cert));\n                \n            result.setNotRevoked(!certValidationService.isRevoked(cert));\n            result.setNotExpired(cert.getNotAfter().after(new Date()));\n            \n            result.setSignerName(sig.getName());\n            result.setSignatureDate(sig.getSignDate().getTime().toString());\n            result.setReason(sig.getReason());\n            result.setLocation(sig.getLocation());\n            \n            result.setIssuerDN(cert.getIssuerX500Principal().getName());\n            result.setSubjectDN(cert.getSubjectX500Principal().getName());\n            result.setSerialNumber(cert.getSerialNumber().toString(16));\n            result.setValidFrom(cert.getNotBefore().toString());\n            result.setValidUntil(cert.getNotAfter().toString());\n            result.setSignatureAlgorithm(cert.getSigAlgName());\n            \n            try {\n                result.setKeySize(((RSAPublicKey) cert.getPublicKey()).getModulus().bitLength());\n            } catch (Exception e) {\n                result.setKeySize(0);\n            }\n            \n            result.setVersion(String.valueOf(cert.getVersion()));\n            result.setKeyUsages(extractKeyUsages(cert));\n            result.setSelfSigned(\n                cert.getSubjectX500Principal().equals(cert.getIssuerX500Principal()));\n        }\n    } catch (Exception e) {\n        result.setValid(false);\n        result.setErrorMessage(\"Signature validation failed: \" + e.getMessage());\n    }\n    return result;\n}\n\nprivate List<String> extractKeyUsages(X509Certificate cert) {\n    List<String> usages = new ArrayList<>();\n    boolean[] flags = cert.getKeyUsage();\n    if (flags == null) return usages;\n    \n    String[] labels = {\n        \"Digital Signature\", \"Non-Repudiation\", \"Key Encipherment\", \n        \"Data Encipherment\", \"Key Agreement\", \"Certificate Signing\", \n        \"CRL Signing\", \"Encipher Only\", \"Decipher Only\"\n    };\n    for (int i = 0; i < Math.min(flags.length, labels.length); i++) {\n        if (flags[i]) usages.add(labels[i]);\n    }\n    return usages;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "354", "src_id": "M186", "code": "\npublic Map<String, Object> captureApplicationProperties() {\n    Map<String, Object> properties = new HashMap<>();\n    ApplicationProperties props = this.applicationProperties;\n    \n    addLegalProperties(properties, props.getLegal());\n    addSecurityProperties(properties, props.getSecurity());\n    addSystemProperties(properties, props.getSystem());\n    addUIProperties(properties, props.getUi());\n    addMetricsProperties(properties, props.getMetrics());\n    addEnterpriseProperties(properties, props.getPremium());\n    addAutoPipelineProperties(properties, props.getAutoPipeline());\n    \n    return properties;\n}\n\nprivate void addLegalProperties(Map<String, Object> map, ApplicationProperties.Legal legal) {\n    addIfNotEmpty(map, \"legal_termsAndConditions\", legal.getTermsAndConditions());\n    addIfNotEmpty(map, \"legal_privacyPolicy\", legal.getPrivacyPolicy());\n    addIfNotEmpty(map, \"legal_accessibilityStatement\", legal.getAccessibilityStatement());\n    addIfNotEmpty(map, \"legal_cookiePolicy\", legal.getCookiePolicy());\n    addIfNotEmpty(map, \"legal_impressum\", legal.getImpressum());\n}\n\nprivate void addSecurityProperties(Map<String, Object> map, ApplicationProperties.Security security) {\n    addIfNotEmpty(map, \"security_enableLogin\", security.getEnableLogin());\n    addIfNotEmpty(map, \"security_csrfDisabled\", security.getCsrfDisabled());\n    addIfNotEmpty(map, \"security_loginAttemptCount\", security.getLoginAttemptCount());\n    addIfNotEmpty(map, \"security_loginResetTimeMinutes\", security.getLoginResetTimeMinutes());\n    addIfNotEmpty(map, \"security_loginMethod\", security.getLoginMethod());\n    \n    if (Boolean.TRUE.equals(security.getOauth2().getEnabled())) {\n        addIfNotEmpty(map, \"security_oauth2_autoCreateUser\", security.getOauth2().getAutoCreateUser());\n        addIfNotEmpty(map, \"security_oauth2_blockRegistration\", security.getOauth2().getBlockRegistration());\n        addIfNotEmpty(map, \"security_oauth2_useAsUsername\", security.getOauth2().getUseAsUsername());\n        addIfNotEmpty(map, \"security_oauth2_provider\", security.getOauth2().getProvider());\n    }\n}\n\nprivate void addSystemProperties(Map<String, Object> map, ApplicationProperties.System system) {\n    addIfNotEmpty(map, \"system_defaultLocale\", system.getDefaultLocale());\n    addIfNotEmpty(map, \"system_googlevisibility\", system.getGooglevisibility());\n    addIfNotEmpty(map, \"system_showUpdate\", system.isShowUpdate());\n    addIfNotEmpty(map, \"system_showUpdateOnlyAdmin\", system.getShowUpdateOnlyAdmin());\n    addIfNotEmpty(map, \"system_customHTMLFiles\", system.isCustomHTMLFiles());\n    addIfNotEmpty(map, \"system_tessdataDir\", system.getTessdataDir());\n    addIfNotEmpty(map, \"system_enableAlphaFunctionality\", system.getEnableAlphaFunctionality());\n    addIfNotEmpty(map, \"system_enableAnalytics\", system.isAnalyticsEnabled());\n}\n\nprivate void addUIProperties(Map<String, Object> map, ApplicationProperties.UI ui) {\n    addIfNotEmpty(map, \"ui_appName\", ui.getAppName());\n    addIfNotEmpty(map, \"ui_homeDescription\", ui.getHomeDescription());\n    addIfNotEmpty(map, \"ui_appNameNavbar\", ui.getAppNameNavbar());\n}\n\nprivate void addMetricsProperties(Map<String, Object> map, ApplicationProperties.Metrics metrics) {\n    addIfNotEmpty(map, \"metrics_enabled\", metrics.getEnabled());\n}\n\nprivate void addEnterpriseProperties(Map<String, Object> map, ApplicationProperties.Premium premium) {\n    addIfNotEmpty(map, \"enterpriseEdition_enabled\", premium.isEnabled());\n    if (!premium.isEnabled()) return;\n    \n    ApplicationProperties.Premium.ProFeatures.CustomMetadata metadata = \n        premium.getProFeatures().getCustomMetadata();\n    addIfNotEmpty(map, \"enterpriseEdition_customMetadata_autoUpdateMetadata\", metadata.isAutoUpdateMetadata());\n    addIfNotEmpty(map, \"enterpriseEdition_customMetadata_author\", metadata.getAuthor());\n    addIfNotEmpty(map, \"enterpriseEdition_customMetadata_creator\", metadata.getCreator());\n    addIfNotEmpty(map, \"enterpriseEdition_customMetadata_producer\", metadata.getProducer());\n}\n\nprivate void addAutoPipelineProperties(Map<String, Object> map, ApplicationProperties.AutoPipeline auto) {\n    addIfNotEmpty(map, \"autoPipeline_outputFolder\", auto.getOutputFolder());\n}\n\nprivate void addIfNotEmpty(Map<String, Object> map, String key, Object value) {\n    if (value != null && !value.toString().isEmpty()) {\n        map.put(key, value);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "355", "src_id": "M173", "code": "\npublic CompletableFuture<ResponseEntity<?>> queueJob(\n        String jobId, int resourceWeight, Supplier<Object> work, long timeoutMs) {\n        \n    CompletableFuture<ResponseEntity<?>> future = new CompletableFuture<>();\n    QueuedJob job = new QueuedJob(jobId, resourceWeight, work, timeoutMs, Instant.now(), future, false);\n    jobMap.put(jobId, job);\n    totalQueuedJobs++;\n    \n    synchronized (queueLock) {\n        try {\n            if (!jobQueue.offer(job, 5, TimeUnit.SECONDS)) {\n                log.warn(\"Queue full, rejecting job {}\", jobId);\n                rejectedJobs++;\n                future.completeExceptionally(new RuntimeException(\"Job queue full\"));\n                jobMap.remove(jobId);\n                return future;\n            }\n            log.debug(\"Job {} queued (weight: {}, queue size: {})\", jobId, resourceWeight, jobQueue.size());\n            return future;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            future.completeExceptionally(new RuntimeException(\"Job queue interrupted\"));\n            jobMap.remove(jobId);\n            return future;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "356", "src_id": "M544", "code": "\nprivate void applyQpdfCompression(\n        OptimizePdfRequest request, int optimizeLevel, Path currentFile, List<Path> tempFiles) throws IOException {\n        \n    long preQpdfSize = Files.size(currentFile);\n    log.info(\"Pre-QPDF file size: {}\", GeneralUtils.formatBytes(preQpdfSize));\n    \n    int qpdfCompressionLevel = optimizeLevel == 1 ? 5 : 9;\n    Path qpdfOutputFile = Files.createTempFile(\"qpdf_output_\", \".pdf\");\n    tempFiles.add(qpdfOutputFile);\n    \n    List<String> command = new ArrayList<>();\n    command.add(\"qpdf\");\n    if (request.getNormalize()) command.add(\"--normalize-content=y\");\n    if (request.getLinearize()) command.add(\"--linearize\");\n    command.add(\"--recompress-flate\");\n    command.add(\"--compression-level=\" + qpdfCompressionLevel);\n    command.add(\"--compress-streams=y\");\n    command.add(\"--object-streams=generate\");\n    command.add(currentFile.toString());\n    command.add(qpdfOutputFile.toString());\n    \n    try {\n        ProcessExecutorResult result = ProcessExecutor.getInstance(ProcessExecutor.Processes.QPDF)\n            .runCommandWithOutputHandling(command);\n            \n        Files.copy(qpdfOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n        long postQpdfSize = Files.size(currentFile);\n        double reduction = 100.0 - ((postQpdfSize * 100.0) / preQpdfSize);\n        log.info(\"Post-QPDF size: {} (reduced by {}%)\", \n                 GeneralUtils.formatBytes(postQpdfSize), \n                 String.format(\"%.1f\", reduction));\n    } catch (Exception e) {\n        if (!(e instanceof ProcessExecutionException) || ((ProcessExecutionException)e).getExitValue() != 3) {\n            throw new IOException(\"QPDF command failed\", e);\n        }\n        log.warn(\"QPDF compression failed, continuing\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "357", "src_id": "M16", "code": "\n    private void handleCookiesFromUrl(@Nullable final String url) {\n        if (MainActivity.DEBUG) {\n            Log.d(TAG, \"handleCookiesFromUrl: url=\" + (url == null ? \"null\" : url));\n        }\n\n        if (url == null) return;\n\n        final String cookies = CookieManager.getInstance().getCookie(url);\n        handleCookies(cookies);\n\n        // sometimes cookies are inside the url\n        final int abuseStart = url.indexOf(\"google_abuse=\");\n        if (abuseStart != -1) {\n            final int abuseEnd = url.indexOf(\"+path\");\n            try {\n                handleCookies(Utils.decodeUrlUtf8(url.substring(abuseStart + 13, abuseEnd)));\n            } catch (final StringIndexOutOfBoundsException e) {\n                if (MainActivity.DEBUG) {\n                    Log.e(TAG, String.format(\n                        \"handleCookiesFromUrl: invalid google abuse starting at %d and ending at %d for url %s\",\n                        abuseStart, abuseEnd, url), e);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "358", "src_id": "M339", "code": "\n    @Override\n    public void onUpdateProgress(final int currentProgress,\n                                 final int duration,\n                                 final int bufferPercent) {\n\n        if (duration != binding.playbackSeekBar.getMax()) {\n            setVideoDurationToControls(duration);\n        }\n        if (player.getCurrentState() != STATE_PAUSED) {\n            updatePlayBackElementsCurrentDuration(currentProgress);\n        }\n        if (player.isLoading() || bufferPercent > 90) {\n            binding.playbackSeekBar.setSecondaryProgress(\n                    (int) (binding.playbackSeekBar.getMax() * ((float) bufferPercent / 100)));\n        }\n        if (DEBUG && bufferPercent % 20 == 0) { //Limit log\n            Log.d(TAG, String.format(\n                \"notifyProgressUpdateToListeners() called with: isVisible = %s, currentProgress = [%d], duration = [%d], bufferPercent = [%d]\",\n                isControlsVisible(), currentProgress, duration, bufferPercent));\n        }\n        binding.playbackLiveSync.setClickable(!player.isLiveEdge());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "359", "src_id": "M452", "code": "\n    private void updateQueueTime(final int currentTime) {\n        @Nullable final PlayQueue playQueue = player.getPlayQueue();\n        if (playQueue == null) return;\n\n        final int currentStream = playQueue.getIndex();\n        int before = 0;\n        int after = 0;\n\n        final List<PlayQueueItem> streams = playQueue.getStreams();\n        final int nStreams = streams.size();\n\n        for (int i = 0; i < nStreams; i++) {\n            if (i < currentStream) {\n                before += streams.get(i).getDuration();\n            } else {\n                after += streams.get(i).getDuration();\n            }\n        }\n\n        before *= 1000;\n        after *= 1000;\n\n        binding.itemsListHeaderDuration.setText(\n                String.format(\"%s/%s\",\n                        getTimeString(currentTime + before),\n                        getTimeString(before + after)\n                ));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "360", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(res.getString(R.string.light_theme_key))) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(res.getString(R.string.black_theme_key))) {\n            return R.style.BlackSettingsTheme;\n        } else if (selectedTheme.equals(res.getString(R.string.auto_device_theme_key))) {\n            if (isDeviceDarkThemeEnabled(context)) {\n                // use the dark theme variant preferred by the user\n                final String selectedNightTheme = getSelectedNightThemeKey(context);\n                return selectedNightTheme.equals(res.getString(R.string.black_theme_key))\n                    ? R.style.BlackSettingsTheme\n                    : R.style.DarkSettingsTheme;\n            } else {\n                // there is only one day theme\n                return R.style.LightSettingsTheme;\n            }\n        } else {\n            // default to dark theme\n            return R.style.DarkSettingsTheme;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "361", "src_id": "M383", "code": "\n    public boolean onKeyDown(final int keyCode) {\n        switch (keyCode) {\n            case KeyEvent.KEYCODE_BACK:\n                if (DeviceUtils.isTv(context) && isControlsVisible()) {\n                    hideControls(0, 0);\n                    return true;\n                }\n                break;\n            case KeyEvent.KEYCODE_DPAD_UP:\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n            case KeyEvent.KEYCODE_DPAD_DOWN:\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n                if ((binding.getRoot().hasFocus() && !binding.playbackControlRoot.hasFocus())\n                        || isAnyListViewOpen()) {\n                    // do not interfere with focus in playlist and play queue\n                    break;\n                }\n\n                if (player.getCurrentState() == org.schabi.newpipe.player.Player.STATE_BLOCKED) {\n                    return true;\n                }\n\n                if (isControlsVisible()) {\n                    hideControls(DEFAULT_CONTROLS_DURATION, DPAD_CONTROLS_HIDE_TIME);\n                } else {\n                    binding.playPauseButton.requestFocus();\n                    showControlsThenHide();\n                    showSystemUIPartially();\n                    return true;\n                }\n                break;\n        }\n\n        return false;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "362", "src_id": "M553", "code": "\n    public static String getActionName(@NonNull final Context context, @Action final int action) {\n        switch (action) {\n            case PREVIOUS:\n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description);\n            case NEXT:\n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description);\n            case REWIND:\n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description);\n            case FORWARD:\n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description);\n            case SMART_REWIND_PREVIOUS:\n                return Localization.concatenateStrings(\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description),\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description));\n            case SMART_FORWARD_NEXT:\n                return Localization.concatenateStrings(\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description),\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description));\n            case PLAY_PAUSE:\n                return Localization.concatenateStrings(\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_play_description),\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description));\n            case PLAY_PAUSE_BUFFERING:\n                return Localization.concatenateStrings(\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_play_description),\n                        context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description),\n                        context.getString(R.string.notification_action_buffering));\n            case REPEAT:\n                return context.getString(R.string.notification_action_repeat);\n            case SHUFFLE:\n                return context.getString(R.string.notification_action_shuffle);\n            case CLOSE:\n                return context.getString(R.string.close);\n            default:\n                return context.getString(R.string.notification_action_nothing);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "363", "src_id": "M343", "code": "\n    private void adjustSeekbarPreviewContainer() {\n        try {\n            // Reset layout position from potential previous errors\n            binding.bottomSeekbarPreviewLayout.setGravity(Gravity.NO_GRAVITY);\n\n            // Calculate current seekbar thumb position in px\n            final int currentSeekbarLeft =\n                    binding.playbackSeekBar.getLeft()\n                            + binding.playbackSeekBar.getPaddingLeft()\n                            + binding.playbackSeekBar.getThumb().getBounds().left;\n\n            // Calculate container position\n            final int uncheckedContainerLeft =\n                    currentSeekbarLeft - (binding.seekbarPreviewContainer.getWidth() / 2);\n\n            // Ensure position stays within boundaries\n            final int checkedContainerLeft = MathUtils.clamp(uncheckedContainerLeft,\n                    0, binding.playbackWindowRoot.getWidth() - binding.seekbarPreviewContainer.getWidth());\n\n            final LinearLayout.LayoutParams params =\n                    new LinearLayout.LayoutParams(binding.seekbarPreviewContainer.getLayoutParams());\n            params.setMarginStart(checkedContainerLeft);\n            binding.seekbarPreviewContainer.setLayoutParams(params);\n        } catch (final Exception ex) {\n            Log.e(TAG, \"Failed to adjust seekbarPreviewContainer\", ex);\n            // Fallback to center position\n            binding.bottomSeekbarPreviewLayout.setGravity(Gravity.CENTER);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "364", "src_id": "M995", "code": "\n    public static void fetchStreamInfoAndSaveToDatabase(@NonNull final Context context,\n                                                        final int serviceId,\n                                                        @NonNull final String url,\n                                                        final Consumer<StreamInfo> callback) {\n        Toast.makeText(context, R.string.loading_stream_details, Toast.LENGTH_SHORT).show();\n        ExtractorHelper.getStreamInfo(serviceId, url, false)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(result -> {\n                    // Background database operation\n                    Completable.fromAction(() -> NewPipeDatabase.getInstance(context)\n                            .streamDAO().upsert(new StreamEntity(result)))\n                            .subscribeOn(Schedulers.io())\n                            .observeOn(Schedulers.io())\n                            .doOnError(throwable ->\n                                    ErrorUtil.createNotification(context,\n                                            new ErrorInfo(throwable, UserAction.REQUESTED_STREAM,\n                                                    \"Saving stream info to database\", result)))\n                            .subscribe();\n\n                    callback.accept(result);\n                }, throwable -> ErrorUtil.createNotification(context,\n                        new ErrorInfo(throwable, UserAction.REQUESTED_STREAM,\n                                \"Loading stream info: \" + url, serviceId)\n                ));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "365", "src_id": "M741", "code": "\n    private void onItemSelectedSetFileName() {\n        final String fileName = FilenameUtils.createFilename(getContext(), currentInfo.getName());\n        final String prevFileName = Optional.ofNullable(dialogBinding.fileName.getText())\n                .map(Object::toString)\n                .orElse(\"\");\n\n        if (prevFileName.isEmpty()\n                || prevFileName.equals(fileName)\n                || prevFileName.startsWith(getString(R.string.caption_file_name, fileName, \"\"))) {\n\n            switch (dialogBinding.videoAudioGroup.getCheckedRadioButtonId()) {\n                case R.id.audio_button:\n                case R.id.video_button:\n                    if (!prevFileName.equals(fileName)) {\n                        dialogBinding.fileName.setText(fileName);\n                    }\n                    break;\n                case R.id.subtitle_button:\n                    final String languageCode = subtitleStreamsAdapter\n                            .getItem(selectedSubtitleIndex).getLanguageTag();\n                    dialogBinding.fileName.setText(getString(\n                            R.string.caption_file_name, fileName, languageCode));\n                    break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "366", "src_id": "M338", "code": "\n    private void updateEndScreenThumbnail(@Nullable final Bitmap thumbnail) {\n        if (thumbnail == null) {\n            binding.endScreen.setImageDrawable(null);\n            return;\n        }\n\n        final float endScreenHeight = calculateMaxEndScreenThumbnailHeight(thumbnail);\n        final Bitmap endScreenBitmap = BitmapCompat.createScaledBitmap(\n                thumbnail,\n                (int) (thumbnail.getWidth() / (thumbnail.getHeight() / endScreenHeight)),\n                (int) endScreenHeight,\n                null,\n                true);\n\n        if (DEBUG) {\n            Log.d(TAG, String.format(\n                \"Thumbnail - onThumbnailLoaded() called with: currentThumbnail = [%s], %dx%d, scaled end screen height = %s, scaled end screen width = %d\",\n                thumbnail, thumbnail.getWidth(), thumbnail.getHeight(), \n                endScreenHeight, endScreenBitmap.getWidth()));\n        }\n\n        binding.endScreen.setImageBitmap(endScreenBitmap);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "367", "src_id": "M1148", "code": "\n    @Override\n    public void seek(long offset) throws IOException {\n        final long total = out.length + aux.length;\n\n        if (offset == total) {\n            // do not ignore the seek offset if a underflow exists\n            final long relativeOffset = out.getOffset() + aux.getOffset();\n            if (relativeOffset == total) {\n                return;\n            }\n        }\n\n        // flush everything, avoid any underflow\n        flush();\n\n        if (offset < 0 || offset > total) {\n            throw new IOException(\"desired offset is outside of range=0-\" + total + \" offset=\" + offset);\n        }\n\n        if (offset > out.length) {\n            out.seek(out.length);\n            aux.seek(offset - out.length);\n        } else {\n            out.seek(offset);\n            aux.seek(0);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "368", "src_id": "M1079", "code": "\n    boolean runMissions() {\n        synchronized (this) {\n            if (mMissionsPending.size() < 1) {\n                return false;\n            }\n            if (!canDownloadInCurrentNetwork()) {\n                return false;\n            }\n\n            if (mPrefQueueLimit) {\n                for (final DownloadMission mission : mMissionsPending) {\n                    if (!mission.isFinished() && mission.running) {\n                        return true;\n                    }\n                }\n            }\n\n            boolean flag = false;\n            for (final DownloadMission mission : mMissionsPending) {\n                if (mission.running || !mission.enqueued || mission.isFinished()) {\n                    continue;\n                }\n\n                resumeMission(mission);\n                if (mission.errCode != DownloadMission.ERROR_NOTHING) {\n                    continue;\n                }\n\n                if (mPrefQueueLimit) {\n                    return true;\n                }\n                flag = true;\n            }\n\n            return flag;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "369", "src_id": "M883", "code": "\n    private void makeMvhd(final long longestTrack) throws IOException {\n        auxWrite(new byte[]{\n                0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00\n        });\n        auxWrite(ByteBuffer.allocate(28)\n                .putLong(time)\n                .putLong(time)\n                .putInt(DEFAULT_TIMESCALE)\n                .putLong(longestTrack)\n                .array()\n        );\n\n        auxWrite(new byte[]{\n                0x00, 0x01, 0x00, 0x00, 0x01, 0x00, // default volume and rate\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved values\n                // default matrix\n                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00,\n                0x40, 0x00, 0x00, 0x00\n        });\n        auxWrite(new byte[24]); // predefined\n        auxWrite(ByteBuffer.allocate(4)\n                .putInt(tracks.length + 1)\n                .array()\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "370", "src_id": "M1037", "code": "\n    public void pause() {\n        if (!running) {\n            return;\n        }\n\n        if (isPsRunning()) {\n            if (DEBUG) {\n                Log.w(TAG, \"pause during post-processing is not applicable.\");\n            }\n            return;\n        }\n\n        running = false;\n        notify(DownloadManagerService.MESSAGE_PAUSED);\n\n        if (init != null && init.isAlive()) {\n            // NOTE: if start() method is running ¡will no have effect!\n            init.interrupt();\n            synchronized (LOCK) {\n                resetState(false, true, ERROR_NOTHING);\n            }\n            return;\n        }\n\n        if (DEBUG && unknownLength) {\n            Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n        }\n\n        init = null;\n        pauseThreads();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "371", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        final Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n            if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "372", "src_id": "M1056", "code": "\n    private boolean handleMessage(@NonNull Message msg) {\n        if (mHandler == null) {\n            return true;\n        }\n\n        final DownloadMission mission = (DownloadMission) msg.obj;\n\n        switch (msg.what) {\n            case MESSAGE_FINISHED:\n                notifyMediaScanner(mission.storage.getUri());\n                notifyFinishedDownload(mission.storage.getName());\n                mManager.setFinished(mission);\n                handleConnectivityState(false);\n                updateForegroundState(mManager.runMissions());\n                break;\n            case MESSAGE_RUNNING:\n                updateForegroundState(true);\n                break;\n            case MESSAGE_ERROR:\n                notifyFailedDownload(mission);\n                handleConnectivityState(false);\n                updateForegroundState(mManager.runMissions());\n                break;\n            case MESSAGE_PAUSED:\n                updateForegroundState(mManager.getRunningMissionsCount() > 0);\n                break;\n        }\n\n        if (msg.what != MESSAGE_ERROR) {\n            mFailedDownloads.remove(mFailedDownloads.indexOfValue(mission));\n        }\n\n        for (final Callback observer : mEchoObservers) {\n            observer.handleMessage(msg);\n        }\n\n        return true;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "373", "src_id": "M1105", "code": "\n    private void showError(@NonNull DownloadMission mission) {\n        @StringRes int msg = R.string.general_error;\n        String msgEx = null;\n\n        switch (mission.errCode) {\n            case 416:\n                msg = R.string.error_http_unsupported_range;\n                break;\n            case 404:\n                msg = R.string.error_http_not_found;\n                break;\n            case ERROR_NOTHING:\n                return;// this never should happen\n            case ERROR_FILE_CREATION:\n                msg = R.string.error_file_creation;\n                break;\n            case ERROR_HTTP_NO_CONTENT:\n                msg = R.string.error_http_no_content;\n                break;\n            case ERROR_PATH_CREATION:\n                msg = R.string.error_path_creation;\n                break;\n            case ERROR_PERMISSION_DENIED:\n                msg = R.string.permission_denied;\n                break;\n            case ERROR_SSL_EXCEPTION:\n                msg = R.string.error_ssl_exception;\n                break;\n            case ERROR_UNKNOWN_HOST:\n                msg = R.string.error_unknown_host;\n                break;\n            case ERROR_CONNECT_HOST:\n                msg = R.string.error_connect_host;\n                break;\n            case ERROR_POSTPROCESSING_STOPPED:\n                msg = R.string.error_postprocessing_stopped;\n                break;\n            case ERROR_POSTPROCESSING:\n            case ERROR_POSTPROCESSING_HOLD:\n                showError(mission, UserAction.DOWNLOAD_POSTPROCESSING, R.string.error_postprocessing_failed);\n                return;\n            case ERROR_INSUFFICIENT_STORAGE:\n                msg = R.string.error_insufficient_storage_left;\n                break;\n            case ERROR_UNKNOWN_EXCEPTION:\n                if (mission.errObject != null) {\n                    showError(mission, UserAction.DOWNLOAD_FAILED, R.string.general_error);\n                    return;\n                } else {\n                    msg = R.string.msg_error;\n                    break;\n                }\n            case ERROR_PROGRESS_LOST:\n                msg = R.string.error_progress_lost;\n                break;\n            case ERROR_TIMEOUT:\n                msg = R.string.error_timeout;\n                break;\n            case ERROR_RESOURCE_GONE:\n                msg = R.string.error_download_resource_gone;\n                break;\n            default:\n                if (mission.errCode >= 100 && mission.errCode < 600) {\n                    msgEx = \"HTTP \" + mission.errCode;\n                } else if (mission.errObject == null) {\n                    msgEx = \"(not_decelerated_error_code)\";\n                } else {\n                    showError(mission, UserAction.DOWNLOAD_FAILED, msg);\n                    return;\n                }\n                break;\n        }\n\n        AlertDialog.Builder builder = new AlertDialog.Builder(mContext);\n\n        if (msgEx != null) {\n            builder.setMessage(msgEx);\n        } else {\n            builder.setMessage(msg);\n        }\n\n        // add report button for non-HTTP errors (range 100-599)\n        if (mission.errObject != null && (mission.errCode < 100 || mission.errCode >= 600)) {\n            @StringRes final int mMsg = msg;\n            builder.setPositiveButton(R.string.error_report_title, (dialog, which) ->\n                    showError(mission, UserAction.DOWNLOAD_FAILED, mMsg)\n            );\n        }\n\n        builder.setNegativeButton(R.string.ok, (dialog, which) -> dialog.cancel())\n                .setTitle(mission.storage.getName())\n                .show();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "374", "src_id": "M828", "code": "\n    private Minf parseMinf(final Box ref) throws IOException {\n        final Minf obj = new Minf();\n\n        Box b;\n        while ((b = untilAnyBox(ref)) != null) {\n\n            switch (b.type) {\n                case ATOM_DINF:\n                    obj.dinf = readFullBox(b);\n                    break;\n                case ATOM_STBL:\n                    obj.stblStsd = parseStbl(b);\n                    break;\n                case ATOM_VMHD:\n                case ATOM_SMHD:\n                    obj.mhd = readFullBox(b);\n                    break;\n\n            }\n            ensure(b);\n        }\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "375", "src_id": "M822", "code": "\n    private Mdia parseMdia(final Box ref) throws IOException {\n        final Mdia obj = new Mdia();\n\n        Box b;\n        while ((b = untilBox(ref, ATOM_MDHD, ATOM_HDLR, ATOM_MINF)) != null) {\n            switch (b.type) {\n                case ATOM_MDHD:\n                    obj.mdhd = readFullBox(b);\n\n                    // read time scale\n                    final ByteBuffer buffer = ByteBuffer.wrap(obj.mdhd);\n                    final byte version = buffer.get(8);\n                    buffer.position(12 + ((version == 0 ? 4 : 8) * 2));\n                    obj.mdhdTimeScale = buffer.getInt();\n                    break;\n                case ATOM_HDLR:\n                    obj.hdlr = parseHdlr(b);\n                    break;\n                case ATOM_MINF:\n                    obj.minf = parseMinf(b);\n                    break;\n            }\n            ensure(b);\n        }\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "376", "src_id": "M302", "code": "\n@Override\npublic void processResult(int rc, String path, Object ctx, List<String> children) {\n    if (rc != KeeperException.Code.OK.intValue()) {\n        zk.getChildren(assignmentsNode, true, this, null);\n        return;\n    }\n    Map<String, Instance> newList = new HashMap<>();\n    Stat stat = new Stat();\n    for (String child : children) {\n        Instance i = instances.remove(child);\n        if (i == null) {\n            byte[] data = null;\n            String myNode = assignmentsNode + '/' + child;\n            for (;;) {\n                try {\n                    data = zk.getData(myNode, true, stat);\n                    break;\n                } catch (NoNodeException ex) {\n                    break;\n                } catch (KeeperException ex) {\n                    ex.printStackTrace();\n                } catch (InterruptedException ex) {\n                    Thread.currentThread().interrupt();\n                    return;\n                }\n            }\n            if (data != null) {\n                String instanceSpec = new String(data);\n                int spaceIndex = instanceSpec.indexOf(' ');\n                String clazz;\n                String conf;\n                if (spaceIndex == -1) {\n                    clazz = instanceSpec;\n                    conf = null;\n                } else {\n                    clazz = instanceSpec.substring(0, spaceIndex);\n                    conf = instanceSpec.substring(spaceIndex + 1);\n                }\n                try {\n                    Class<?> c = Class.forName(clazz);\n                    i = (Instance) c.getConstructor().newInstance();\n                    Reporter reporter = new MyReporter(child);\n                    i.setReporter(reporter);\n                    i.configure(conf);\n                    i.start();\n                    newList.put(child, i);\n                    int ver = stat.getVersion();\n                    DataCallback dc = new MyDataCallback(myNode, i, ver);\n                    Watcher watcher = new MyWatcher(myNode, dc);\n                    zk.getData(myNode, watcher, dc, watcher);\n                } catch (Exception ex) {\n                    LOG.warn(\"Skipping \" + child, ex);\n                    if (ex.getCause() != null) {\n                        LOG.warn(\"Caused by\", ex.getCause());\n                    }\n                }\n            }\n        } else {\n            newList.put(child, i);\n        }\n    }\n    for (Map.Entry<String, Instance> e : instances.entrySet()) {\n        e.getValue().stop();\n        try {\n            rmnod(reportsNode + '/' + e.getKey());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n        } catch (KeeperException ex) {\n            ex.printStackTrace();\n        }\n    }\n    instances = newList;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "377", "src_id": "M219", "code": "\nsynchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n    final String connectionId = concat(contextPath, session);\n    ZooKeeper zk = zkMap.get(connectionId);\n    if (zk == null) {\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"creating new connection for : '%s'\", connectionId));\n        }\n        Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n        }\n        zkMap.put(connectionId, zk);\n        if (session != null) {\n            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "378", "src_id": "M579", "code": "\npublic void dump(PrintWriter pwriter) {\n    pwriter.print(\"Sets (\");\n    pwriter.print(expiryMap.size());\n    pwriter.print(\")/(\");\n    pwriter.print(elemMap.size());\n    pwriter.println(\"):\");\n    List<Long> keys = new ArrayList<>(expiryMap.keySet());\n    Collections.sort(keys);\n    for (long time : keys) {\n        Set<E> s = expiryMap.get(time);\n        if (s != null) {\n            pwriter.print(s.size());\n            pwriter.print(\" expire at \");\n            pwriter.print(Time.elapsedTimeToDate(time));\n            pwriter.println(\":\");\n            for (E e : s) {\n                pwriter.print(\"\\t\");\n                pwriter.println(e.toString());\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "379", "src_id": "M282", "code": "\n@Test\npublic void testSimpleCase() throws Exception {\n    configureServers(serverCount);\n    configureClients(clientCount, SimpleClient.class, getHostPort());\n    Stat stat = new Stat();\n    startServers();\n    LOG.debug(\"Connecting to \" + getHostPort());\n    ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n    waitForConnect(zk, 10000);\n    zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    startClients();\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            try {\n                byte[] b = zk.getData(\"/simpleCase/\" + i, false, stat);\n                Assert.assertEquals(\"orig\", new String(b));\n            } catch (NoNodeException ex) {\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"Max tries exceeded on client \" + i);\n                }\n                Thread.sleep(1000);\n            }\n        }\n    }\n    for (int i = 0; i < getServerCount(); i++) {\n        stopServer(i);\n        if (i + 1 > getServerCount() / 2) {\n            startServer(i);\n        } else if (i + 1 == getServerCount() / 2) {\n            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n            try {\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            } catch (ConnectionLossException ex) {\n                Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            }\n            for (int j = 0; j < i; j++) {\n                LOG.info(\"Starting server \" + j);\n                startServer(i);\n            }\n        }\n    }\n    Thread.sleep(100);\n    Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    try {\n        zk.getData(\"/simpleCase\", false, stat);\n    } catch (ConnectionLossException ex) {\n        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    }\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n            if (new String(data).equals(\"new\")) {\n                break;\n            }\n            if (j + 1 == maxTries) {\n                Assert.fail(\"max tries exceeded for \" + i);\n            }\n            Thread.sleep(1000);\n        }\n    }\n    zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n    for (int i = 0; i < getClientCount(); i++) {\n        try {\n            for (int j = 0; j < maxTries; j++) {\n                zk.getData(\"/simpleCase/\" + i, false, stat);\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                }\n                Thread.sleep(200);\n            }\n        } catch (NoNodeException ex) {\n        }\n    }\n    stopClients();\n    stopServers();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "380", "src_id": "M243", "code": "\npublic void start() throws IOException {\n    System.out.println(\"Starting grizzly ...\");\n    boolean useSSL = cfg.useSSL();\n    String tempPath = Files.createTempDirectory(\"zkRestResourcesTempPath\").toFile().getCanonicalPath();\n    gws = new GrizzlyWebServer(cfg.getPort(), tempPath, useSSL);\n    for (Endpoint e : cfg.getEndpoints()) {\n        ZooKeeperService.mapContext(e.getContext(), e);\n        gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });\n    }\n    if (useSSL) {\n        System.out.println(\"Starting SSL ...\");\n        String jks = cfg.getJKS(\"keys/rest.jks\");\n        String jksPassword = cfg.getJKSPassword();\n        SSLConfig sslConfig = new SSLConfig();\n        URL resource = getClass().getClassLoader().getResource(jks);\n        if (resource == null) {\n            LOG.error(\"Unable to find the keystore file: \" + jks);\n            System.exit(2);\n        }\n        try {\n            sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n        } catch (URISyntaxException ex) {\n            LOG.error(\"Unable to load keystore: \" + jks, ex);\n            System.exit(2);\n        }\n        sslConfig.setKeyStorePass(jksPassword);\n        gws.setSSLConfig(sslConfig);\n    }\n    gws.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "381", "src_id": "M186", "code": "\nsynchronized private LogEntry readNextEntry() {\n    try {\n        try {\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                Matcher m = src.timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (buf.length() > 0) {\n                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                        buf = line;\n                        return e;\n                    }\n                    buf = line;\n                } else if (buf.length() > 0) {\n                    buf += line + \"\\n\";\n                }\n            }\n        } catch (EOFException ex) {\n        }\n        if (buf.length() > 0) {\n            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n            buf = \"\";\n            return e;\n        }\n    } catch (Exception ex) {\n        LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + ex);\n        return null;\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "382", "src_id": "M286", "code": "\npublic void reconfigureInstance(String name, String params) throws NoAssignmentException, InterruptedException, KeeperException {\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n    }\n    Assigned assigned = instanceToAssignment.get(name);\n    if (assigned == null) {\n        throw new NoAssignmentException();\n    }\n    KeeperException lastException = null;\n    for (int i = 0; i < maxTries; i++) {\n        try {\n            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, (\"update \" + params).getBytes(), -1);\n            break;\n        } catch (ConnectionLossException ex) {\n            lastException = ex;\n        }\n    }\n    if (lastException != null) {\n        throw lastException;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "383", "src_id": "M174", "code": "\nprivate LogEntry readNextEntry() {\n    LogEntry e = null;\n    try {\n        long crcValue;\n        byte[] bytes;\n        try {\n            crcValue = logStream.readLong(\"crcvalue\");\n            bytes = logStream.readBuffer(\"txnEntry\");\n        } catch (EOFException ex) {\n            return null;\n        }\n        if (bytes.length == 0) {\n            return null;\n        }\n        Checksum crc = new Adler32();\n        crc.update(bytes, 0, bytes.length);\n        if (crcValue != crc.getValue()) {\n            throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n        }\n        TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n        TxnHeader hdr = logEntry.getHeader();\n        Record r = logEntry.getTxn();\n        switch (hdr.getType()) {\n        case OpCode.createSession: {\n            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n        }\n            break;\n        case OpCode.closeSession: {\n            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n        }\n            break;\n        case OpCode.create:\n            if (r != null) {\n                CreateTxn create = (CreateTxn)r;\n                String path = create.getPath();\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n            }\n            break;\n        case OpCode.setData:\n            if (r != null) {\n                SetDataTxn set = (SetDataTxn)r;\n                String path = set.getPath();\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n            }\n            break;\n        case OpCode.setACL:\n            if (r != null) {\n                SetACLTxn setacl = (SetACLTxn)r;\n                String path = setacl.getPath();\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n            }\n            break;\n        case OpCode.error:\n            if (r != null)  {\n                ErrorTxn error = (ErrorTxn)r;\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n            }\n            break;\n        default:\n            LOG.info(\"Unknown op: \" + hdr.getType());\n            break;\n        }\n        if (logStream.readByte(\"EOR\") != 'B') {\n            throw new EOFException(\"Last transaction was partial.\");\n        }\n    } catch (Exception ex) {\n        LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n        return null;\n    }\n    return e;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "384", "src_id": "M1129", "code": "\npublic synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief) {\n    pwriter.print(\" \");\n    pwriter.print(getRemoteSocketAddress());\n    pwriter.print(\"[\");\n    int interestOps = getInterestOps();\n    pwriter.print(interestOps == 0 ? \"0\" : Integer.toHexString(interestOps));\n    pwriter.print(\"](queued=\");\n    pwriter.print(getOutstandingRequests());\n    pwriter.print(\",recved=\");\n    pwriter.print(getPacketsReceived());\n    pwriter.print(\",sent=\");\n    pwriter.print(getPacketsSent());\n    if (!brief) {\n        long sessionId = getSessionId();\n        if (sessionId != 0) {\n            pwriter.print(\",sid=0x\");\n            pwriter.print(Long.toHexString(sessionId));\n            pwriter.print(\",lop=\");\n            pwriter.print(getLastOperation());\n            pwriter.print(\",est=\");\n            pwriter.print(getEstablished().getTime());\n            pwriter.print(\",to=\");\n            pwriter.print(getSessionTimeout());\n            long lastCxid = getLastCxid();\n            if (lastCxid >= 0) {\n                pwriter.print(\",lcxid=0x\");\n                pwriter.print(Long.toHexString(lastCxid));\n            }\n            pwriter.print(\",lzxid=0x\");\n            pwriter.print(Long.toHexString(getLastZxid()));\n            pwriter.print(\",lresp=\");\n            pwriter.print(getLastResponseTime());\n            pwriter.print(\",llat=\");\n            pwriter.print(getLastLatency());\n            pwriter.print(\",minlat=\");\n            pwriter.print(getMinLatency());\n            pwriter.print(\",avglat=\");\n            pwriter.print(getAvgLatency());\n            pwriter.print(\",maxlat=\");\n            pwriter.print(getMaxLatency());\n        }\n    }\n    pwriter.print(\")\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "385", "src_id": "M267", "code": "\nvoid drainLoop() {\n    int missed = 1;\n    Observer<? super R> a = downstream;\n    AtomicInteger n = active;\n    AtomicReference<SpscLinkedArrayQueue<R>> qr = queue;\n\n    for (;;) {\n        for (;;) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            if (!delayErrors) {\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    clear();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n            }\n\n            boolean d = n.get() == 0;\n            SpscLinkedArrayQueue<R> q = qr.get();\n            R v = q != null ? q.poll() : null;\n            boolean empty = v == null;\n\n            if (d && empty) {\n                errors.tryTerminateConsumer(a);\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            a.onNext(v);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "386", "src_id": "M1358", "code": "\n@Override\npublic void onNext(T t) {\n    if (done) {\n        return;\n    }\n    boolean b;\n    try {\n        b = predicate.test(t);\n    } catch (Throwable e) {\n        Exceptions.throwIfFatal(e);\n        upstream.cancel();\n        upstream = SubscriptionHelper.CANCELLED;\n        onError(e);\n        return;\n    }\n    if (b) {\n        done = true;\n        upstream.cancel();\n        upstream = SubscriptionHelper.CANCELLED;\n        downstream.onSuccess(true);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "387", "src_id": "M683", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    AtomicReference<Object> c = current;\n    Subscriber<? super T> a = downstream;\n    Disposable cancelled = disposables;\n\n    for (;;) {\n        if (cancelled.isDisposed()) {\n            c.lazySet(null);\n            return;\n        }\n\n        Object o = c.get();\n\n        if (o != null) {\n            boolean goNextSource;\n            if (o != NotificationLite.COMPLETE) {\n                long p = produced;\n                if (p != requested.get()) {\n                    produced = p + 1;\n                    c.lazySet(null);\n                    goNextSource = true;\n\n                    a.onNext((T) o);\n                } else {\n                    goNextSource = false;\n                }\n            } else {\n                goNextSource = true;\n                c.lazySet(null);\n            }\n\n            if (goNextSource && !cancelled.isDisposed()) {\n                int i = index;\n                if (i == sources.length) {\n                    a.onComplete();\n                    return;\n                }\n                index = i + 1;\n\n                sources[i].subscribe(this);\n            }\n        }\n\n        if (decrementAndGet() == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "388", "src_id": "M1509", "code": "\n@Override\nvoid runAsync() {\n    int missed = 1;\n\n    final Subscriber<? super T> a = downstream;\n    final SimpleQueue<T> q = queue;\n\n    long e = produced;\n\n    for (;;) {\n\n        long r = requested.get();\n\n        while (e != r) {\n            boolean d = done;\n            T v;\n\n            try {\n                v = q.poll();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n\n                cancelled = true;\n                upstream.cancel();\n                q.clear();\n\n                a.onError(ex);\n                worker.dispose();\n                return;\n            }\n\n            boolean empty = v == null;\n\n            if (checkTerminated(d, empty, a)) {\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            a.onNext(v);\n\n            e++;\n            if (e == limit) {\n                if (r != Long.MAX_VALUE) {\n                    r = requested.addAndGet(-e);\n                }\n                upstream.request(e);\n                e = 0L;\n            }\n        }\n\n        if (e == r && checkTerminated(done, q.isEmpty(), a)) {\n            return;\n        }\n\n        int w = get();\n        if (missed == w) {\n            produced = e;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        } else {\n            missed = w;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "389", "src_id": "M889", "code": "\nvoid drainLoop() {\n    int missed = 1;\n\n    JoinInnerSubscriber<T>[] s = this.subscribers;\n    int n = s.length;\n    Subscriber<? super T> a = this.downstream;\n\n    for (;;) {\n\n        long r = requested.get();\n        long e = 0;\n\n        middle:\n        while (e != r) {\n            if (cancelled) {\n                cleanup();\n                return;\n            }\n\n            boolean d = done.get() == 0;\n\n            boolean empty = true;\n\n            for (int i = 0; i < n; i++) {\n                JoinInnerSubscriber<T> inner = s[i];\n\n                SimplePlainQueue<T> q = inner.queue;\n                if (q != null) {\n                    T v = q.poll();\n\n                    if (v != null) {\n                        empty = false;\n                        a.onNext(v);\n                        inner.requestOne();\n                        if (++e == r) {\n                            break middle;\n                        }\n                    }\n                }\n            }\n\n            if (d && empty) {\n                errors.tryTerminateConsumer(a);\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                cleanup();\n                return;\n            }\n\n            boolean d = done.get() == 0;\n\n            boolean empty = true;\n\n            for (int i = 0; i < n; i++) {\n                JoinInnerSubscriber<T> inner = s[i];\n\n                SimpleQueue<T> q = inner.queue;\n                if (q != null && !q.isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n\n            if (d && empty) {\n                errors.tryTerminateConsumer(a);\n                return;\n            }\n        }\n\n        if (e != 0) {\n            BackpressureHelper.produced(requested, e);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "390", "src_id": "M1127", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n\n    AtomicReference<T> latest = this.latest;\n    AtomicLong requested = this.requested;\n    Subscriber<? super T> downstream = this.downstream;\n\n    for (;;) {\n\n        for (;;) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            boolean d = done;\n            Throwable error = this.error;\n\n            if (d && error != null) {\n                if (onDropped != null) {\n                    T v = latest.getAndSet(null);\n                    if (v != null) {\n                        try {\n                            onDropped.accept(v);\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            error = new CompositeException(error, ex);\n                        }\n                    }\n                } else {\n                    latest.lazySet(null);\n                }\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n\n            T v = latest.get();\n            boolean empty = v == null;\n\n            if (d) {\n                if (!empty) {\n                    v = latest.getAndSet(null);\n                    if (emitLast) {\n                        long e = emitted;\n                        if (e != requested.get()) {\n                            emitted = e + 1;\n                            downstream.onNext(v);\n                            downstream.onComplete();\n                        } else {\n                            tryDropAndSignalMBE(v);\n                        }\n                    } else {\n                        if (onDropped != null) {\n                            try {\n                                onDropped.accept(v);\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                downstream.onError(ex);\n                                worker.dispose();\n                                return;\n                            }\n                        }\n                        downstream.onComplete();\n                    }\n                } else {\n                    downstream.onComplete();\n                }\n                worker.dispose();\n                return;\n            }\n\n            if (empty) {\n                if (timerFired) {\n                    timerRunning = false;\n                    timerFired = false;\n                }\n                break;\n            }\n\n            if (!timerRunning || timerFired) {\n                v = latest.getAndSet(null);\n                long e = emitted;\n                if (e != requested.get()) {\n                    downstream.onNext(v);\n                    emitted = e + 1;\n                } else {\n                    upstream.cancel();\n                    tryDropAndSignalMBE(v);\n                    worker.dispose();\n                    return;\n                }\n\n                timerFired = false;\n                timerRunning = true;\n                worker.schedule(this, timeout, unit);\n            } else {\n                break;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "391", "src_id": "M1003", "code": "\nvoid drain() {\n    if (wip.getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n\n    SimpleQueue<T> q = queue;\n\n    int upstreamConsumed = consumed;\n    int localLimit = limit;\n    boolean canRequest = sourceMode != QueueSubscription.SYNC;\n    AtomicReference<MulticastSubscription<T>[]> subs = subscribers;\n\n    MulticastSubscription<T>[] array = subs.get();\n\n    outer:\n    for (;;) {\n\n        int n = array.length;\n\n        if (q != null && n != 0) {\n            long r = Long.MAX_VALUE;\n\n            for (MulticastSubscription<T> ms : array) {\n                long u = ms.get() - ms.emitted;\n                if (u != Long.MIN_VALUE) {\n                    if (r > u) {\n                        r = u;\n                    }\n                } else {\n                    n--;\n                }\n            }\n\n            if (n == 0) {\n                r = 0;\n            }\n\n            while (r != 0) {\n                if (isDisposed()) {\n                    q.clear();\n                    return;\n                }\n\n                boolean d = done;\n\n                if (d && !delayError) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                        return;\n                    }\n                }\n\n                T v;\n\n                try {\n                    v = q.poll();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    SubscriptionHelper.cancel(upstream);\n                    errorAll(ex);\n                    return;\n                }\n\n                boolean empty = v == null;\n\n                if (d && empty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                    } else {\n                        completeAll();\n                    }\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                boolean subscribersChange = false;\n\n                for (MulticastSubscription<T> ms : array) {\n                    long msr = ms.get();\n                    if (msr != Long.MIN_VALUE) {\n                        if (msr != Long.MAX_VALUE) {\n                            ms.emitted++;\n                        }\n                        ms.downstream.onNext(v);\n                    } else {\n                        subscribersChange = true;\n                    }\n                }\n\n                r--;\n\n                if (canRequest && ++upstreamConsumed == localLimit) {\n                    upstreamConsumed = 0;\n                    upstream.get().request(localLimit);\n                }\n\n                MulticastSubscription<T>[] freshArray = subs.get();\n                if (subscribersChange || freshArray != array) {\n                    array = freshArray;\n                    continue outer;\n                }\n            }\n\n            if (r == 0) {\n                if (isDisposed()) {\n                    q.clear();\n                    return;\n                }\n\n                boolean d = done;\n\n                if (d && !delayError) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                        return;\n                    }\n                }\n\n                if (d && q.isEmpty()) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                    } else {\n                        completeAll();\n                    }\n                    return;\n                }\n            }\n        }\n\n        consumed = upstreamConsumed;\n        missed = wip.addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n        if (q == null) {\n            q = queue;\n        }\n        array = subs.get();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "392", "src_id": "M485", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid subscribeInner(ObservableSource<? extends U> p) {\n    for (;;) {\n        if (p instanceof Supplier) {\n            if (tryEmitScalar(((Supplier<? extends U>) p)) && maxConcurrency != Integer.MAX_VALUE) {\n                boolean empty = false;\n                synchronized (this) {\n                    p = sources.poll();\n                    if (p == null) {\n                        wip--;\n                        empty = true;\n                    }\n                }\n                if (empty) {\n                    drain();\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            InnerObserver<T, U> inner = new InnerObserver<>(this, uniqueId++);\n            if (addInner(inner)) {\n                p.subscribe(inner);\n            }\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "393", "src_id": "M2312", "code": "\n@BackpressureSupport(BackpressureKind.SPECIAL)\n@CheckReturnValue\n@SchedulerSupport(SchedulerSupport.NONE)\n@NonNull\npublic static <@NonNull T> Flowable<T> fromObservable(@NonNull ObservableSource<T> source, @NonNull BackpressureStrategy strategy) {\n    Objects.requireNonNull(source, \"source is null\");\n    Objects.requireNonNull(strategy, \"strategy is null\");\n    Flowable<T> f = new FlowableFromObservable<>(source);\n    switch (strategy) {\n        case DROP:\n            return f.onBackpressureDrop();\n        case LATEST:\n            return f.onBackpressureLatest();\n        case MISSING:\n            return f;\n        case ERROR:\n            return RxJavaPlugins.onAssembly(new FlowableOnBackpressureError<>(f));\n        default:\n            return f.onBackpressureBuffer();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "394", "src_id": "M368", "code": "\npublic static <T> void subscribe(ObservableSource<? extends T> o, Observer<? super T> observer) {\n    final BlockingQueue<Object> queue = new LinkedBlockingQueue<>();\n\n    BlockingObserver<T> bs = new BlockingObserver<>(queue);\n    observer.onSubscribe(bs);\n\n    o.subscribe(bs);\n    for (;;) {\n        if (bs.isDisposed()) {\n            break;\n        }\n        Object v = queue.poll();\n        if (v == null) {\n            try {\n                v = queue.take();\n            } catch (InterruptedException ex) {\n                bs.dispose();\n                observer.onError(ex);\n                return;\n            }\n        }\n        if (bs.isDisposed()\n                || v == BlockingObserver.TERMINATED\n                || NotificationLite.acceptFull(v, observer)) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "395", "src_id": "M379", "code": "\n@Override\npublic void onTextTracksChanged(@NonNull Tracks currentTracks) {\n    super.onTextTracksChanged(currentTracks);\n\n    boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n            || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n    if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n            || !trackTypeTextSupported) {\n        binding.captionTextView.setVisibility(View.GONE);\n        return;\n    }\n\n    List<Tracks.Group> textTracks = currentTracks\n            .getGroups()\n            .stream()\n            .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n            .collect(Collectors.toList());\n    List<String> availableLanguages = textTracks.stream()\n            .map(Tracks.Group::getMediaTrackGroup)\n            .filter(textTrack -> textTrack.length > 0)\n            .map(textTrack -> textTrack.getFormat(0).language)\n            .collect(Collectors.toList());\n\n    Optional<Format> selectedTracks = textTracks.stream()\n            .filter(Tracks.Group::isSelected)\n            .filter(info -> info.getMediaTrackGroup().length >= 1)\n            .map(info -> info.getMediaTrackGroup().getFormat(0))\n            .findFirst();\n\n    buildCaptionMenu(availableLanguages);\n    if (player.getTrackSelector().getParameters().getRendererDisabled(\n            player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n        binding.captionTextView.setText(R.string.caption_none);\n    } else {\n        binding.captionTextView.setText(selectedTracks.get().language);\n    }\n    binding.captionTextView.setVisibility(\n            availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "396", "src_id": "M260", "code": "\npublic void play() {\n    if (DEBUG) {\n        Log.d(TAG, \"play() called\");\n    }\n    if (audioReactor == null || playQueue == null || exoPlayerIsNull()) {\n        return;\n    }\n\n    if (!isMuted()) {\n        audioReactor.requestAudioFocus();\n    }\n\n    if (currentState == STATE_COMPLETED) {\n        if (playQueue.getIndex() == 0) {\n            seekToDefault();\n        } else {\n            playQueue.setIndex(0);\n        }\n    }\n\n    simpleExoPlayer.play();\n    saveStreamProgressState();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "397", "src_id": "M887", "code": "\n@Nullable\nstatic String choosePreferredImage(@NonNull List<Image> images,\n                                   PreferredImageQuality nonNoneQuality) {\n    double widthOverHeight = images.stream()\n            .filter(image -> image.getHeight() != HEIGHT_UNKNOWN\n                    && image.getWidth() != WIDTH_UNKNOWN)\n            .mapToDouble(image -> ((double) image.getWidth()) / image.getHeight())\n            .findFirst()\n            .orElse(1.0);\n\n    Image.ResolutionLevel preferredLevel = nonNoneQuality.toResolutionLevel();\n    Comparator<Image> initialComparator = Comparator\n            .<Image>comparingInt(i -> {\n                if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.UNKNOWN) {\n                    return 3;\n                } else if (i.getEstimatedResolutionLevel() == preferredLevel) {\n                    return 0;\n                } else if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.MEDIUM) {\n                    return 1;\n                } else {\n                    return 2;\n                }\n            })\n            .thenComparing(image ->\n                    image.getHeight() == HEIGHT_UNKNOWN && image.getWidth() == WIDTH_UNKNOWN);\n\n    Comparator<Image> finalComparator = switch (nonNoneQuality) {\n        case NONE -> initialComparator;\n        case LOW -> initialComparator.thenComparingDouble(image -> {\n            double pixelCount = estimatePixelCount(image, widthOverHeight);\n            return Math.abs(pixelCount - BEST_LOW_H * BEST_LOW_H * widthOverHeight);\n        });\n        case MEDIUM -> initialComparator.thenComparingDouble(image -> {\n            double pixelCount = estimatePixelCount(image, widthOverHeight);\n            return Math.abs(pixelCount - BEST_MEDIUM_H * BEST_MEDIUM_H * widthOverHeight);\n        });\n        case HIGH -> initialComparator.thenComparingDouble(\n                i -> -estimatePixelCount(i, widthOverHeight));\n    };\n\n    return images.stream()\n            .min(finalComparator)\n            .map(Image::getUrl)\n            .orElse(null);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "398", "src_id": "M527", "code": "\n@SuppressLint(\"PrivateResource\")\n@Nullable\npublic static NotificationActionData fromNotificationActionEnum(\n        @NonNull Player player,\n        @NotificationConstants.Action int selectedAction\n) {\n    int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n    Context ctx = player.getContext();\n\n    switch (selectedAction) {\n        case NotificationConstants.PREVIOUS:\n            return new NotificationActionData(ACTION_PLAY_PREVIOUS,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_previous_description), baseActionIcon);\n        case NotificationConstants.NEXT:\n            return new NotificationActionData(ACTION_PLAY_NEXT,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_next_description), baseActionIcon);\n        case NotificationConstants.REWIND:\n            return new NotificationActionData(ACTION_FAST_REWIND,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_rewind_description), baseActionIcon);\n        case NotificationConstants.FORWARD:\n            return new NotificationActionData(ACTION_FAST_FORWARD,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_fastforward_description), baseActionIcon);\n        case NotificationConstants.SMART_REWIND_PREVIOUS:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(ACTION_PLAY_PREVIOUS,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_previous_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_previous);\n            } else {\n                return new NotificationActionData(ACTION_FAST_REWIND,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_rewind_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_rewind);\n            }\n        case NotificationConstants.SMART_FORWARD_NEXT:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(ACTION_PLAY_NEXT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_next_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_next);\n            } else {\n                return new NotificationActionData(ACTION_FAST_FORWARD,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_fastforward_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_fastforward);\n            }\n        case NotificationConstants.PLAY_PAUSE_BUFFERING:\n            if (player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(R.string.notification_action_buffering),\n                        R.drawable.ic_hourglass_top);\n            }\n        case NotificationConstants.PLAY_PAUSE:\n            if (player.getCurrentState() == Player.STATE_COMPLETED) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_pause_description),\n                        R.drawable.ic_replay);\n            } else if (player.isPlaying()\n                    || player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_pause_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_pause);\n            } else {\n                return new NotificationActionData(ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_play_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_play);\n            }\n        case NotificationConstants.REPEAT:\n            if (player.getRepeatMode() == REPEAT_MODE_ALL) {\n                return new NotificationActionData(ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_repeat_all_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable\n                                .exo_media_action_repeat_all);\n            } else if (player.getRepeatMode() == REPEAT_MODE_ONE) {\n                return new NotificationActionData(ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_repeat_one_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable\n                                .exo_media_action_repeat_one);\n            } else {\n                return new NotificationActionData(ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_repeat_off_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable\n                                .exo_media_action_repeat_off);\n            }\n        case NotificationConstants.SHUFFLE:\n            if (player.getPlayQueue() != null && player.getPlayQueue().isShuffled()) {\n                return new NotificationActionData(ACTION_SHUFFLE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_shuffle_on_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_on);\n            } else {\n                return new NotificationActionData(ACTION_SHUFFLE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_shuffle_off_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_off);\n            }\n        case NotificationConstants.CLOSE:\n            return new NotificationActionData(ACTION_CLOSE, ctx.getString(R.string.close),\n                    R.drawable.ic_close);\n        case NotificationConstants.NOTHING:\n        default:\n            return null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "399", "src_id": "M239", "code": "\nprivate void updatePlaybackState(boolean playWhenReady, int playbackState) {\n    if (DEBUG) {\n        Log.d(TAG, \"ExoPlayer - updatePlaybackState() called with: \"\n                + \"playWhenReady = [\" + playWhenReady + \"], \"\n                + \"playbackState = [\" + playbackState + \"]\");\n    }\n\n    if (currentState == STATE_PAUSED_SEEK) {\n        if (DEBUG) {\n            Log.d(TAG, \"updatePlaybackState() is currently blocked\");\n        }\n        return;\n    }\n\n    switch (playbackState) {\n        case com.google.android.exoplayer2.Player.STATE_IDLE:\n            isPrepared = false;\n            break;\n        case com.google.android.exoplayer2.Player.STATE_BUFFERING:\n            if (isPrepared) {\n                changeState(STATE_BUFFERING);\n            }\n            break;\n        case com.google.android.exoplayer2.Player.STATE_READY:\n            if (!isPrepared) {\n                isPrepared = true;\n                onPrepared(playWhenReady);\n            }\n            changeState(playWhenReady ? STATE_PLAYING : STATE_PAUSED);\n            break;\n        case com.google.android.exoplayer2.Player.STATE_ENDED:\n            changeState(STATE_COMPLETED);\n            saveStreamProgressStateCompleted();\n            isPrepared = false;\n            break;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "400", "src_id": "M460", "code": "\npublic MediaDescriptionCompat getQueueMetadata(int index) {\n    if (player.getPlayQueue() == null) {\n        return null;\n    }\n    PlayQueueItem item = player.getPlayQueue().getItem(index);\n    if (item == null) {\n        return null;\n    }\n\n    MediaDescriptionCompat.Builder descBuilder = new MediaDescriptionCompat.Builder()\n            .setMediaId(String.valueOf(index))\n            .setTitle(item.getTitle())\n            .setSubtitle(item.getUploader());\n\n    Bundle additionalMetadata = new Bundle();\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_TITLE, item.getTitle());\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_ARTIST, item.getUploader());\n    additionalMetadata\n            .putLong(MediaMetadataCompat.METADATA_KEY_DURATION, item.getDuration() * 1000);\n    additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, index + 1L);\n    additionalMetadata\n            .putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, player.getPlayQueue().size());\n    descBuilder.setExtras(additionalMetadata);\n\n    try {\n        descBuilder.setIconUri(Uri.parse(\n                ImageStrategy.choosePreferredImage(item.getThumbnails())));\n    } catch (Throwable e) {\n    }\n\n    return descBuilder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "401", "src_id": "M243", "code": "\npublic void changeState(int state) {\n    if (DEBUG) {\n        Log.d(TAG, \"changeState() called with: state = [\" + state + \"]\");\n    }\n    currentState = state;\n    switch (state) {\n        case STATE_BLOCKED:\n            onBlocked();\n            break;\n        case STATE_PLAYING:\n            onPlaying();\n            break;\n        case STATE_BUFFERING:\n            onBuffering();\n            break;\n        case STATE_PAUSED:\n            onPaused();\n            break;\n        case STATE_PAUSED_SEEK:\n            onPausedSeek();\n            break;\n        case STATE_COMPLETED:\n            onCompleted();\n            break;\n    }\n    notifyPlaybackUpdateToListeners();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "402", "src_id": "M543", "code": "\nprivate synchronized NotificationCompat.Builder createNotification() {\n    if (DEBUG) {\n        Log.d(TAG, \"createNotification()\");\n    }\n    notificationManager = NotificationManagerCompat.from(player.getContext());\n    NotificationCompat.Builder builder =\n            new NotificationCompat.Builder(player.getContext(),\n            player.getContext().getString(R.string.notification_channel_id));\n    MediaStyle mediaStyle = new MediaStyle();\n\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n        int[] compactSlots = initializeNotificationSlots();\n        mediaStyle.setShowActionsInCompactView(compactSlots);\n    }\n    player.UIs()\n            .get(MediaSessionPlayerUi.class)\n            .flatMap(MediaSessionPlayerUi::getSessionToken)\n            .ifPresent(mediaStyle::setMediaSession);\n\n    builder.setStyle(mediaStyle)\n            .setPriority(NotificationCompat.PRIORITY_HIGH)\n            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n            .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n            .setShowWhen(false)\n            .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n            .setColor(ContextCompat.getColor(player.getContext(),\n                    R.color.dark_background_color))\n            .setColorized(player.getPrefs().getBoolean(\n                    player.getContext().getString(R.string.notification_colorize_key), true))\n            .setDeleteIntent(PendingIntentCompat.getBroadcast(player.getContext(),\n                    NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, false));\n\n    setLargeIcon(builder);\n\n    return builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "403", "src_id": "M491", "code": "\n@SuppressLint(\"SwitchIntDef\")\n@ResizeMode\npublic static int nextResizeModeAndSaveToPrefs(Player player,\n                                               @ResizeMode int resizeMode) {\n    int newResizeMode;\n    switch (resizeMode) {\n        case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n        default:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n            break;\n    }\n\n    player.getPrefs().edit().putInt(\n            player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n    return newResizeMode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "404", "src_id": "M703", "code": "\n@Override\nprotected Supplier<View> getListHeaderSupplier() {\n    return () -> {\n        CommentRepliesHeaderBinding binding = CommentRepliesHeaderBinding\n                .inflate(activity.getLayoutInflater(), itemsList, false);\n        CommentsInfoItem item = commentsInfoItem;\n\n        PicassoHelper.loadAvatar(item.getUploaderAvatars()).into(binding.authorAvatar);\n        binding.authorAvatar.setVisibility(ImageStrategy.shouldLoadImages()\n                ? View.VISIBLE : View.GONE);\n\n        binding.authorName.setText(item.getUploaderName());\n        binding.uploadDate.setText(Localization.relativeTimeOrTextual(\n                getContext(), item.getUploadDate(), item.getTextualUploadDate()));\n        binding.authorTouchArea.setOnClickListener(\n                v -> NavigationHelper.openCommentAuthorIfPresent(requireActivity(), item));\n\n        binding.thumbsUpCount.setText(\n                Localization.likeCount(requireContext(), item.getLikeCount()));\n        ((ConstraintLayout.LayoutParams) binding.thumbsUpCount.getLayoutParams())\n                .setMarginEnd(DeviceUtils.dpToPx(\n                        (item.isHeartedByUploader() || item.isPinned() ? 8 : 16),\n                        requireContext()));\n        binding.heartImage.setVisibility(item.isHeartedByUploader() ? View.VISIBLE : View.GONE);\n        binding.pinnedImage.setVisibility(item.isPinned() ? View.VISIBLE : View.GONE);\n\n        TextLinkifier.fromDescription(binding.commentContent, item.getCommentText(),\n                HtmlCompat.FROM_HTML_MODE_LEGACY, getServiceById(item.getServiceId()),\n                item.getUrl(), disposables, null);\n        binding.commentContent.setMovementMethod(LongPressLinkMovementMethod.getInstance());\n        return binding.getRoot();\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "405", "src_id": "M2204", "code": "\n    @Override\n    protected void subscribeActual(@NonNull final MaybeObserver<? super T> observer) {\n        final MaybeDisposable<T> md = new MaybeDisposable<>(observer, this);\n        observer.onSubscribe(md);\n        if (add(md)) {\n            if (md.isDisposed()) {\n                remove(md);\n            }\n        } else {\n            @Nullable final Throwable ex = error;\n            if (ex != null) {\n                observer.onError(ex);\n                return;\n            }\n\n            @Nullable final T v = value;\n            if (v == null) {\n                observer.onComplete();\n            } else {\n                observer.onSuccess(v);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "406", "src_id": "M919", "code": "\n    @Override\n    protected void subscribeActual(@NonNull final CompletableObserver observer) {\n        final Disposable d = Disposable.empty();\n        observer.onSubscribe(d);\n        if (d.isDisposed()) {\n            return;\n        }\n\n        try {\n            run.run();\n        } catch (final Throwable e) {\n            Exceptions.throwIfFatal(e);\n            if (d.isDisposed()) {\n                RxJavaPlugins.onError(e);\n            } else {\n                observer.onError(e);\n            }\n            return;\n        }\n\n        if (!d.isDisposed()) {\n            observer.onComplete();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "407", "src_id": "M352", "code": "\n        @Override\n        public void onNext(@NonNull final T value) {\n            if (upstream == DisposableHelper.DISPOSED) {\n                return;\n            }\n\n            final Iterator<? extends R> it;\n            try {\n                it = mapper.apply(value).iterator();\n            } catch (final Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                upstream.dispose();\n                onError(ex);\n                return;\n            }\n\n            final Observer<? super R> a = downstream;\n\n            for (;;) {\n                final boolean b;\n                try {\n                    b = it.hasNext();\n                } catch (final Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.dispose();\n                    onError(ex);\n                    return;\n                }\n\n                if (!b) {\n                    break;\n                }\n\n                final R v;\n                try {\n                    v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n                } catch (final Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.dispose();\n                    onError(ex);\n                    return;\n                }\n\n                a.onNext(v);\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "408", "src_id": "M874", "code": "\n        @Override\n        public boolean tryOnNext(@NonNull final T t) {\n            if (done) {\n                return false;\n            }\n\n            long retries = 0L;\n            for (;;) {\n                final boolean b;\n                try {\n                    b = predicate.test(t);\n                } catch (final Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    final ParallelFailureHandling h;\n                    try {\n                        h = Objects.requireNonNull(\n                            errorHandler.apply(++retries, ex),\n                            \"The errorHandler returned a null ParallelFailureHandling\"\n                        );\n                    } catch (final Throwable exc) {\n                        Exceptions.throwIfFatal(exc);\n                        cancel();\n                        onError(new CompositeException(ex, exc));\n                        return false;\n                    }\n\n                    switch (h) {\n                        case RETRY:\n                            continue;\n                        case SKIP:\n                            return false;\n                        case STOP:\n                            cancel();\n                            onComplete();\n                            return false;\n                        default:\n                            cancel();\n                            onError(ex);\n                            return false;\n                    }\n                }\n\n                return b && downstream.tryOnNext(t);\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "409", "src_id": "M2235", "code": "\n    @Override\n    @NonNull\n    public synchronized Throwable getCause() { // NOPMD\n        if (cause != null) {\n            return cause;\n        }\n\n        final int exceptionCount = exceptions.size();\n        if (exceptionCount == 1) {\n            cause = exceptions.get(0);\n            return cause;\n        }\n\n        final String separator = System.getProperty(\"line.separator\");\n        final Map<Throwable, Boolean> seenCauses = new IdentityHashMap<>();\n        final StringBuilder aggregateMessage = new StringBuilder();\n\n        aggregateMessage\n            .append(\"Multiple exceptions (\")\n            .append(exceptionCount)\n            .append(\")\")\n            .append(separator);\n\n        for (final Throwable inner : exceptions) {\n            int depth = 0;\n            Throwable current = inner;\n            while (current != null) {\n                for (int i = 0; i < depth; i++) {\n                    aggregateMessage.append(\"  \");\n                }\n                aggregateMessage.append(\"|-- \");\n                aggregateMessage.append(current.getClass().getCanonicalName()).append(\": \");\n                \n                final String innerMessage = current.getMessage();\n                if (innerMessage != null && innerMessage.contains(separator)) {\n                    aggregateMessage.append(separator);\n                    for (final String line : innerMessage.split(separator)) {\n                        for (int i = 0; i < depth + 2; i++) {\n                            aggregateMessage.append(\"  \");\n                        }\n                        aggregateMessage.append(line).append(separator);\n                    }\n                } else {\n                    aggregateMessage.append(innerMessage).append(separator);\n                }\n\n                for (int i = 0; i < depth + 2; i++) {\n                    aggregateMessage.append(\"  \");\n                }\n                final StackTraceElement[] st = current.getStackTrace();\n                if (st.length > 0) {\n                    aggregateMessage.append(\"at \").append(st[0]).append(separator);\n                }\n\n                if (!seenCauses.containsKey(current)) {\n                    seenCauses.put(current, true);\n                    current = current.getCause();\n                    depth++;\n                } else {\n                    current = current.getCause();\n                    if (current != null) {\n                        for (int i = 0; i < depth + 2; i++) {\n                            aggregateMessage.append(\"  \");\n                        }\n                        aggregateMessage\n                            .append(\"|-- (cause not expanded again) \")\n                            .append(current.getClass().getCanonicalName())\n                            .append(\": \")\n                            .append(current.getMessage())\n                            .append(separator);\n                    }\n                    break;\n                }\n            }\n        }\n\n        cause = new ExceptionOverview(aggregateMessage.toString().trim());\n        return cause;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "410", "src_id": "M1389", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final Deque<T> dq = deque;\n            final Subscriber<? super T> a = downstream;\n            \n            for (;;) {\n                final long r = requested.get();\n                long e = 0L;\n                while (e != r) {\n                    final boolean isCancelled = cancelled;\n                    if (isCancelled) {\n                        clear(dq);\n                        return;\n                    }\n\n                    final boolean d = done;\n                    @Nullable final T v;\n                    synchronized (dq) {\n                        v = dq.poll();\n                    }\n                    final boolean empty = v == null;\n\n                    if (d) {\n                        @Nullable final Throwable ex = error;\n                        if (ex != null) {\n                            clear(dq);\n                            a.onError(ex);\n                            return;\n                        }\n                        if (empty) {\n                            a.onComplete();\n                            return;\n                        }\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    a.onNext(v);\n                    e++;\n                }\n\n                if (e == r) {\n                    final boolean isCancelled = cancelled;\n                    if (isCancelled) {\n                        clear(dq);\n                        return;\n                    }\n\n                    final boolean d = done;\n                    final boolean empty;\n                    synchronized (dq) {\n                        empty = dq.isEmpty();\n                    }\n\n                    if (d) {\n                        @Nullable final Throwable ex = error;\n                        if (ex != null) {\n                            clear(dq);\n                            a.onError(ex);\n                            return;\n                        }\n                        if (empty) {\n                            a.onComplete();\n                            return;\n                        }\n                    }\n                }\n\n                if (e != 0L) {\n                    BackpressureHelper.produced(requested, e);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "411", "src_id": "M243", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final AtomicReference<T> latest = this.latest;\n            final Observer<? super T> downstream = this.downstream;\n\n            for (;;) {\n                for (;;) {\n                    final boolean isCancelled = cancelled;\n                    if (isCancelled) {\n                        clear();\n                        return;\n                    }\n\n                    final boolean d = done;\n                    @Nullable Throwable error = this.error;\n\n                    if (d && error != null) {\n                        final Consumer<? super T> dropHandler = onDropped;\n                        if (dropHandler != null) {\n                            @Nullable final T v = latest.getAndSet(null);\n                            if (v != null) {\n                                try {\n                                    dropHandler.accept(v);\n                                } catch (final Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    error = new CompositeException(error, ex);\n                                }\n                            }\n                        } else {\n                            latest.lazySet(null);\n                        }\n                        downstream.onError(error);\n                        worker.dispose();\n                        return;\n                    }\n\n                    @Nullable final T v = latest.get();\n                    final boolean empty = v == null;\n\n                    if (d) {\n                        if (!empty) {\n                            final T value = latest.getAndSet(null);\n                            if (emitLast) {\n                                downstream.onNext(value);\n                            } else {\n                                if (onDropped != null) {\n                                    try {\n                                        onDropped.accept(value);\n                                    } catch (final Throwable ex) {\n                                        Exceptions.throwIfFatal(ex);\n                                        downstream.onError(ex);\n                                        worker.dispose();\n                                        return;\n                                    }\n                                }\n                            }\n                        }\n                        downstream.onComplete();\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (empty) {\n                        if (timerFired) {\n                            timerRunning = false;\n                            timerFired = false;\n                        }\n                        break;\n                    }\n\n                    if (!timerRunning || timerFired) {\n                        final T value = latest.getAndSet(null);\n                        downstream.onNext(value);\n                        timerFired = false;\n                        timerRunning = true;\n                        worker.schedule(this, timeout, unit);\n                    } else {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "412", "src_id": "M1127", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            final AtomicReference<T> latest = this.latest;\n            final AtomicLong requested = this.requested;\n            final Subscriber<? super T> downstream = this.downstream;\n\n            for (;;) {\n                for (;;) {\n                    final boolean isCancelled = cancelled;\n                    if (isCancelled) {\n                        clear();\n                        return;\n                    }\n\n                    final boolean d = done;\n                    @Nullable Throwable error = this.error;\n\n                    if (d && error != null) {\n                        final Consumer<? super T> dropHandler = onDropped;\n                        if (dropHandler != null) {\n                            @Nullable final T v = latest.getAndSet(null);\n                            if (v != null) {\n                                try {\n                                    dropHandler.accept(v);\n                                } catch (final Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    error = new CompositeException(error, ex);\n                                }\n                            }\n                        } else {\n                            latest.lazySet(null);\n                        }\n                        downstream.onError(error);\n                        worker.dispose();\n                        return;\n                    }\n\n                    @Nullable final T v = latest.get();\n                    final boolean empty = v == null;\n\n                    if (d) {\n                        if (!empty) {\n                            final T value = latest.getAndSet(null);\n                            if (emitLast) {\n                                final long e = emitted;\n                                final long r = requested.get();\n                                if (e != r) {\n                                    emitted = e + 1;\n                                    downstream.onNext(value);\n                                    downstream.onComplete();\n                                } else {\n                                    tryDropAndSignalMBE(value);\n                                }\n                            } else {\n                                final Consumer<? super T> dropHandler = onDropped;\n                                if (dropHandler != null) {\n                                    try {\n                                        dropHandler.accept(value);\n                                    } catch (final Throwable ex) {\n                                        Exceptions.throwIfFatal(ex);\n                                        downstream.onError(ex);\n                                        worker.dispose();\n                                        return;\n                                    }\n                                }\n                                downstream.onComplete();\n                            }\n                        } else {\n                            downstream.onComplete();\n                        }\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (empty) {\n                        if (timerFired) {\n                            timerRunning = false;\n                            timerFired = false;\n                        }\n                        break;\n                    }\n\n                    if (!timerRunning || timerFired) {\n                        final T value = latest.getAndSet(null);\n                        final long e = emitted;\n                        final long r = requested.get();\n                        if (e != r) {\n                            downstream.onNext(value);\n                            emitted = e + 1;\n                        } else {\n                            upstream.cancel();\n                            tryDropAndSignalMBE(value);\n                            worker.dispose();\n                            return;\n                        }\n\n                        timerFired = false;\n                        timerRunning = true;\n                        worker.schedule(this, timeout, unit);\n                    } else {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "413", "src_id": "M1902", "code": "\n    @Override\n    protected void subscribeActual(@NonNull final Subscriber<? super R> s) {\n        if (!(source instanceof Supplier)) {\n            source.subscribe(subscribe(s, mapper, prefetch));\n            return;\n        }\n\n        @Nullable Stream<? extends R> stream = null;\n        try {\n            @SuppressWarnings(\"unchecked\")\n            @Nullable final T t = ((Supplier<T>) source).get();\n            if (t != null) {\n                stream = Objects.requireNonNull(\n                    mapper.apply(t), \n                    \"The mapper returned a null Stream\"\n                );\n            }\n        } catch (final Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            EmptySubscription.error(ex, s);\n            return;\n        }\n\n        if (stream != null) {\n            FlowableFromStream.subscribeStream(s, stream);\n        } else {\n            EmptySubscription.complete(s);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "414", "src_id": "M1455", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            long e = emitted;\n            final Subscriber<? super C> a = downstream;\n            final SpscLinkedArrayQueue<C> q = queue;\n\n            for (;;) {\n                final long r = requested.get();\n                while (e != r) {\n                    final boolean isCancelled = cancelled;\n                    if (isCancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    final boolean d = done;\n                    final boolean hasErrors = errors.get() != null;\n                    if (d && hasErrors) {\n                        q.clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    @Nullable final C v = q.poll();\n                    final boolean empty = v == null;\n\n                    if (d && empty) {\n                        a.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    a.onNext(v);\n                    e++;\n                }\n\n                if (e == r) {\n                    final boolean isCancelled = cancelled;\n                    if (isCancelled) {\n                        q.clear();\n                        return;\n                    }\n\n                    final boolean d = done;\n                    if (d) {\n                        final boolean hasErrors = errors.get() != null;\n                        if (hasErrors) {\n                            q.clear();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n                        if (q.isEmpty()) {\n                            a.onComplete();\n                            return;\n                        }\n                    }\n                }\n\n                emitted = e;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "415", "src_id": "M676", "code": "\n        @SuppressWarnings(\"unchecked\")\n        void done() {\n            if (decrementAndGet() == 0) {\n                Object o1 = observer1.value;\n                Object o2 = observer2.value;\n\n                if (o1 != null && o2 != null) {\n                    boolean b;\n\n                    try {\n                        b = isEqual.test((T) o1, (T) o2);\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                    downstream.onSuccess(b);\n                } else {\n                    downstream.onSuccess(o1 == null && o2 == null);\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "416", "src_id": "M275", "code": "\n        @Override\n        public void subscribe(Observer<? super T> observer) {\n            for (;;) {\n                int s = once.get();\n                if ((s & HAS_SUBSCRIBER) != 0) {\n                    break;\n                }\n                int u = s | HAS_SUBSCRIBER;\n                if (once.compareAndSet(s, u)) {\n                    observer.onSubscribe(this);\n                    actual.lazySet(observer);\n                    if (cancelled.get()) {\n                        actual.lazySet(null);\n                    } else {\n                        drain();\n                    }\n                    return;\n                }\n            }\n            EmptyDisposable.error(new IllegalStateException(\"Only one Observer allowed!\"), observer);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "417", "src_id": "M1571", "code": "\n        @Override\n        public void onSuccess(T value) {\n            Observer<? super R> a = downstream;\n            Iterator<? extends R> iterator;\n            boolean has;\n            try {\n                iterator = mapper.apply(value).iterator();\n\n                has = iterator.hasNext();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                downstream.onError(ex);\n                return;\n            }\n\n            if (!has) {\n                a.onComplete();\n                return;\n            }\n\n            if (outputFused) {\n                it = iterator;\n                a.onNext(null);\n                a.onComplete();\n            } else {\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    R v;\n\n                    try {\n                        v = iterator.next();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        a.onError(ex);\n                        return;\n                    }\n\n                    a.onNext(v);\n\n                    if (cancelled) {\n                        return;\n                    }\n\n                    boolean b;\n\n                    try {\n                        b = iterator.hasNext();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        a.onError(ex);\n                        return;\n                    }\n\n                    if (!b) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "418", "src_id": "M1183", "code": "\n        @Override\n        void fastPath() {\n            Iterator<? extends T> it = this.iterator;\n            ConditionalSubscriber<? super T> a = downstream;\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                T t;\n\n                try {\n                    t = it.next();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n                if (cancelled) {\n                    return;\n                }\n\n                if (t == null) {\n                    a.onError(new NullPointerException(\"Iterator.next() returned a null value\"));\n                    return;\n                } else {\n                    a.tryOnNext(t);\n                }\n\n                if (cancelled) {\n                    return;\n                }\n\n                boolean b;\n\n                try {\n                    b = it.hasNext();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n                if (!b) {\n                    if (!cancelled) {\n                        a.onComplete();\n                    }\n                    return;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "419", "src_id": "M1995", "code": "\n    static <T> boolean postCompleteDrain(long n,\n                                         Subscriber<? super T> actual,\n                                         Queue<T> queue,\n                                         AtomicLong state,\n                                         BooleanSupplier isCancelled) {\n\n// TODO enable fast-path\n//        if (n == -1 || n == Long.MAX_VALUE) {\n//            for (;;) {\n//                if (isCancelled.getAsBoolean()) {\n//                    break;\n//                }\n//\n//                T v = queue.poll();\n//\n//                if (v == null) {\n//                    actual.onComplete();\n//                    break;\n//                }\n//\n//                actual.onNext(v);\n//            }\n//\n//            return true;\n//        }\n\n        long e = n & COMPLETED_MASK;\n\n        for (;;) {\n\n            while (e != n) {\n                if (isCancelled(isCancelled)) {\n                    return true;\n                }\n\n                T t = queue.poll();\n\n                if (t == null) {\n                    actual.onComplete();\n                    return true;\n                }\n\n                actual.onNext(t);\n                e++;\n            }\n\n            if (isCancelled(isCancelled)) {\n                return true;\n            }\n\n            if (queue.isEmpty()) {\n                actual.onComplete();\n                return true;\n            }\n\n            n = state.get();\n\n            if (n == e) {\n\n                n = state.addAndGet(-(e & REQUESTED_MASK));\n\n                if ((n & REQUESTED_MASK) == 0L) {\n                    return false;\n                }\n\n                e = n & COMPLETED_MASK;\n            }\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "420", "src_id": "M1315", "code": "\n        void drainLoop() {\n            int missed = 1;\n            Subscriber<? super R> a = downstream;\n            AtomicInteger n = active;\n            AtomicReference<SpscLinkedArrayQueue<R>> qr = queue;\n\n            for (;;) {\n                long r = requested.get();\n                long e = 0L;\n\n                while (e != r) {\n                    if (cancelled) {\n                        clear();\n                        return;\n                    }\n\n                    if (!delayErrors) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            clear();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n                    }\n\n                    boolean d = n.get() == 0;\n                    SpscLinkedArrayQueue<R> q = qr.get();\n                    R v = q != null ? q.poll() : null;\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    a.onNext(v);\n\n                    e++;\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        clear();\n                        return;\n                    }\n\n                    if (!delayErrors) {\n                        Throwable ex = errors.get();\n                        if (ex != null) {\n                            clear();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n                    }\n\n                    boolean d = n.get() == 0;\n                    SpscLinkedArrayQueue<R> q = qr.get();\n                    boolean empty = q == null || q.isEmpty();\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                }\n\n                if (e != 0L) {\n                    BackpressureHelper.produced(requested, e);\n                    if (maxConcurrency != Integer.MAX_VALUE) {\n                        upstream.request(e);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "421", "src_id": "M856", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n            Subscriber<? super T> a = downstream;\n            List<T>[] lists = this.lists;\n            int[] indexes = this.indexes;\n            int n = indexes.length;\n\n            for (;;) {\n\n                long r = requested.get();\n                long e = 0L;\n\n                while (e != r) {\n                    if (cancelled) {\n                        Arrays.fill(lists, null);\n                        return;\n                    }\n\n                    Throwable ex = error.get();\n                    if (ex != null) {\n                        cancelAll();\n                        Arrays.fill(lists, null);\n                        a.onError(ex);\n                        return;\n                    }\n\n                    T min = null;\n                    int minIndex = -1;\n\n                    for (int i = 0; i < n; i++) {\n                        List<T> list = lists[i];\n                        int index = indexes[i];\n\n                        if (list.size() != index) {\n                            if (min == null) {\n                                min = list.get(index);\n                                minIndex = i;\n                            } else {\n                                T b = list.get(index);\n\n                                boolean smaller;\n\n                                try {\n                                    smaller = comparator.compare(min, b) > 0;\n                                } catch (Throwable exc) {\n                                    Exceptions.throwIfFatal(exc);\n                                    cancelAll();\n                                    Arrays.fill(lists, null);\n                                    if (!error.compareAndSet(null, exc)) {\n                                        RxJavaPlugins.onError(exc);\n                                    }\n                                    a.onError(error.get());\n                                    return;\n                                }\n                                if (smaller) {\n                                    min = b;\n                                    minIndex = i;\n                                }\n                            }\n                        }\n                    }\n\n                    if (min == null) {\n                        Arrays.fill(lists, null);\n                        a.onComplete();\n                        return;\n                    }\n\n                    a.onNext(min);\n\n                    indexes[minIndex]++;\n\n                    e++;\n                }\n\n                if (cancelled) {\n                    Arrays.fill(lists, null);\n                    return;\n                }\n\n                Throwable ex = error.get();\n                if (ex != null) {\n                    cancelAll();\n                    Arrays.fill(lists, null);\n                    a.onError(ex);\n                    return;\n                }\n\n                boolean empty = true;\n\n                for (int i = 0; i < n; i++) {\n                    if (indexes[i] != lists[i].size()) {\n                        empty = false;\n                        break;\n                    }\n                }\n\n                if (empty) {\n                    Arrays.fill(lists, null);\n                    a.onComplete();\n                    return;\n                }\n\n                if (e != 0) {\n                    BackpressureHelper.produced(requested, e);\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "422", "src_id": "M1224", "code": "\n        void drainLoop() {\n            Subscriber<? super T> actual = this.downstream;\n            int missed = 1;\n            long e = emitted;\n            int c = consumed;\n            int lim = limit;\n            for (;;) {\n\n                long r = requested.get();\n\n                while (e != r) {\n                    if (cancelled) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    int os = otherState;\n                    if (os == OTHER_STATE_HAS_VALUE) {\n                        T v = singleItem;\n                        singleItem = null;\n                        otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                        actual.onNext(v);\n\n                        e++;\n                        continue;\n                    }\n\n                    boolean d = mainDone;\n                    SimplePlainQueue<T> q = queue;\n                    T v = q != null ? q.poll() : null;\n                    boolean empty = v == null;\n\n                    if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                        queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    actual.onNext(v);\n\n                    e++;\n\n                    if (++c == lim) {\n                        c = 0;\n                        mainSubscription.get().request(lim);\n                    }\n                }\n\n                if (e == r) {\n                    if (cancelled) {\n                        singleItem = null;\n                        queue = null;\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        singleItem = null;\n                        queue = null;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    boolean d = mainDone;\n                    SimplePlainQueue<T> q = queue;\n                    boolean empty = q == null || q.isEmpty();\n\n                    if (d && empty && otherState == 2) {\n                        queue = null;\n                        actual.onComplete();\n                        return;\n                    }\n                }\n\n                emitted = e;\n                consumed = c;\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "423", "src_id": "M2134", "code": "\n    @SuppressWarnings(\"unchecked\")\n    @NonNull\n    public final U assertValueAt(int index, @NonNull Predicate<T> valuePredicate) {\n        int s = values.size();\n        if (s == 0) {\n            throw fail(\"No values\");\n        }\n\n        if (index < 0 || index >= s) {\n            throw fail(\"Index \" + index + \" is out of range [0, \" + s + \")\");\n        }\n\n        boolean found = false;\n\n        T v = values.get(index);\n        try {\n            if (valuePredicate.test(v)) {\n                found = true;\n            }\n        } catch (Throwable ex) {\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n\n        if (!found) {\n            throw fail(\"Value \" + valueAndClass(v) + \" at position \" + index + \" did not pass the predicate\");\n        }\n        return (U) this;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "424", "src_id": "M2722", "code": "\n    @Override\n    public void onSubscribe(@NonNull Subscription s) {\n        if (SubscriptionHelper.validate(this.upstream, s)) {\n            this.upstream = s;\n            try {\n                downstream.onSubscribe(this);\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                done = true;\n                // can't call onError because the actual's state may be corrupt at this point\n                try {\n                    s.cancel();\n                } catch (Throwable e1) {\n                    Exceptions.throwIfFatal(e1);\n                    RxJavaPlugins.onError(new CompositeException(e, e1));\n                    return;\n                }\n                RxJavaPlugins.onError(e);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}

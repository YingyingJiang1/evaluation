{"project_name": "across-project", "pair_id": "1", "src_id": "M662", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "2", "src_id": "M1051", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "3", "src_id": "M464", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "4", "src_id": "M1305", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "5", "src_id": "M1163", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "6", "src_id": "M1300", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "7", "src_id": "M982", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "8", "src_id": "M249", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "9", "src_id": "M173", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "10", "src_id": "M1370", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "11", "src_id": "M828", "code": "\n    private Minf parseMinf(final Box ref) throws IOException {\n        final Minf obj = new Minf();\n        Box b;\n        while ((b = untilAnyBox(ref)) != null) {\n            switch(b.type ) {\n                            case ATOM_DINF:\n                            obj.dinf = readFullBox(b);\n                            break;\n                            case ATOM_STBL:\n                            obj.stblStsd = parseStbl(b);\n                            break;\n                            case ATOM_VMHD: case\n                                            ATOM_SMHD:\n                            obj.mhd = readFullBox(b);\n                            break;\n            }\n            ensure(b);\n        }\n\n        return obj;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "12", "src_id": "M824", "code": "\n    private Moov parseMoov(final Box ref) throws IOException {\n        Box b = readBox(ATOM_MVHD);\n        final Moov moov = new Moov();\n        moov.mvhd = parseMvhd();\n        ensure(b);\n\n        final ArrayList<Trak> tmp = new ArrayList<>((int) moov.mvhd.nextTrackId);\n        while ((b = untilBox(ref, ATOM_TRAK, ATOM_MVEX)) != null) {\n            switch(b.type ) {\n                            case ATOM_TRAK:\n                            tmp.add(parseTrak(b));\n                            break;\n                            case ATOM_MVEX:\n                            moov.mvexTrex = parseMvex(b, (int) moov.mvhd.nextTrackId);\n                            break;\n            }\n            ensure(b);\n        }\n        moov.trak = tmp.toArray(new\nTrak [ 0]);\n        return moov;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "13", "src_id": "M1086", "code": "\n    private ArrayList<Object> getSpecialItems() {\n        synchronized(DownloadManager.this) {\n                                           ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n                                           ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n                                           List<Mission> remove = new ArrayList<>(hidden);\n\n                // hide missions (if required)\n                                           remove.removeIf(mission->\n                                               pending.remove(mission) || finished.remove(mission));\n\n                                           int fakeTotal = pending.size();\n\n                                           if (fakeTotal > 0) fakeTotal++;\n                                           fakeTotal += finished.size();\n\n                                           if (finished.size() > 0) fakeTotal++;\n                                           ArrayList<Object> list = new ArrayList<>(fakeTotal);\n\n                                           if (pending.size() > 0) {\n                                               list.add(PENDING);\n                                               list.addAll(pending);\n                                           }\n                                           if (finished.size() > 0) {\n                                               list.add(FINISHED);\n                                               list.addAll(finished);\n                                           }\n                                           hasFinished = finished.size() > 0;\n                                           return list;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "14", "src_id": "M1024", "code": "\n    @ Override public void run() {\n        if (mMission.current > 0) mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n\n        int retryCount = 0;\n        int httpCode = 204;\n        while (true) {\n            try {\n                if (mMission.blocks == null && mMission.current == 0 ) {\n                    // calculate the whole size of the mission\n                    long finalLength = 0;\n                    long lowestSize = Long.MAX_VALUE;\n                    for(int i = 0;\n                    i < mMission.urls.length && mMission.running;\n                    i++) {\n                        mConn = mMission.openConnection(mMission.urls[i ], true, 0, 0);\n                        mMission.establishConnection(mId, mConn);\n                        dispose();\n\n                        if (Thread.interrupted()) return;\n\n                        long length = Utility.getTotalContentLength(mConn);\n\n                        if (i == 0) {\n                            httpCode = mConn.getResponseCode();\n                            mMission.length = length;\n                        }\n                        if (length > 0) finalLength += length;\n\n                        if (length < lowestSize) lowestSize = length;\n                    }\n                    mMission.nearLength = finalLength;\n\n                    // reserve space at the start of the file\n\n                    if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                        if (lowestSize < 1 ) {\n                            // the length is unknown use the default size\n                            mMission.offsets[ 0] = RESERVE_SPACE_DEFAULT;\n                        } else {\n                            // use the smallest resource size to download, otherwise, use the maximum\n                            mMission.offsets[ 0] = lowestSize < RESERVE_SPACE_MAXIMUM ? lowestSize : RESERVE_SPACE_MAXIMUM;\n                        }\n                    }\n                } else {\n                    // ask for the current resource length\n                    mConn = mMission.openConnection(true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (!mMission.running || Thread.interrupted()) return;\n                    httpCode = mConn.getResponseCode();\n                    mMission.length = Utility.getTotalContentLength(mConn);\n                }\n                if (mMission.length == 0 || httpCode == 204) {\n                    mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                    return;\n                }\n\n                // check for dynamic generated content\n                if (mMission.length == - 1 && mConn.getResponseCode() == 200 ) {\n                    mMission.blocks = new\nint [ 0];\n                    mMission.length = 0;\n                    mMission.unknownLength = true;\n\n                    if (DEBUG) {\n                        Log.d(TAG, \"falling back (unknown length)\");\n                    }\n                } else {\n                    // Open again\n                    mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (!mMission.running || Thread.interrupted()) return;\n                    synchronized(mMission.LOCK ) {\n                        if (mConn.getResponseCode() == 206 ) {\n                            if (mMission.threadCount > 1 ) {\n                                int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n\n                                if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) count++;\n                                mMission.blocks = new\nint [count];\n                            } else {\n                                // if one thread is required don't calculate blocks, is useless\n                                mMission.blocks = new\nint [ 0];\n                                mMission.unknownLength = false;\n                            }\n                            if (DEBUG) {\n                                Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                            }\n                        } else {\n                            // Fallback to single thread\n                            mMission.blocks = new\nint [ 0];\n                            mMission.unknownLength = false;\n\n                            if (DEBUG) {\n                                Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                            }\n                        }\n                    }\n                    if (!mMission.running || Thread.interrupted()) return;\n                }\n\n                try (SharpStream fs = mMission.storage.getStream()) {\n                    fs.setLength(mMission.offsets[mMission.current ] + mMission.length);\n                    fs.seek(mMission.offsets[mMission.current ]);\n                }\n                if (!mMission.running || Thread.interrupted()) return;\n\n                if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                    String entityTag = mConn.getHeaderField(\"ETAG\");\n                    String lastModified = mConn.getHeaderField(\"Last-Modified\");\n                    MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current ];\n\n                    if (!TextUtils.isEmpty(entityTag)) {\n                        recovery.setValidateCondition(entityTag);\n                    } else if (!TextUtils.isEmpty(lastModified)) {\n                               recovery.setValidateCondition(lastModified);// Note: this is less precise\n                           } else {\n                               recovery.setValidateCondition(null);\n                           }\n                }\n                mMission.running = false;\n                break;\n            } catch (InterruptedIOException| ClosedByInterruptException e) {\n                return;\n            } catch (Exception e) {\n                if (!mMission.running || super.isInterrupted()) return;\n\n                if (e instanceof DownloadMission.HttpError && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                    // for youtube streams. The url has expired\n                    interrupt();\n                    mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                    return;\n                }\n                if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                    mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                    return;\n                }\n                if (retryCount ++ > mMission.maxRetry) {\n                    Log.e(TAG, \"initializer failed\", e);\n                    mMission.notifyError(e);\n                    return;\n                }\n                Log.e(TAG, \"initializer failed, retrying\", e);\n            }\n        }\n        mMission.start();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "15", "src_id": "M1099", "code": "\n    @ SuppressLint(\"DefaultLocale\") private void updateProgress(ViewHolderItem h) {\n        if (h == null || h.item == null|| h.item.mission instanceof FinishedMission) return;\n        DownloadMission mission = (DownloadMission) h.item.mission;\n        double done = mission.done;\n        long length = mission.getLength();\n        long now = System.currentTimeMillis();\n        boolean hasError = mission.errCode != ERROR_NOTHING;\n\n        // hide on error\n        // show if current resource length is not fetched\n        // show if length is unknown\n        h.progress.setMarquee(mission.isRecovering() ||!hasError && (!mission.isInitialized() || mission.unknownLength));\n\n        double progress;\n\n        if (mission.unknownLength) {\n            progress = Double.NaN;\n            h.progress.setProgress(0.0f);\n        } else {\n            progress = done / length;\n        }\n        if (hasError) {\n            h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n            h.status.setText(R.string.msg_error);\n        } else if (isNotFinite(progress)) {\n                   h.status.setText(UNDEFINED_PROGRESS);\n               } else {\n                   h.status.setText(String.format(\"%.2f%%\", progress * 100));\n                   h.progress.setProgress(progress);\n               }\n\n        @ StringRes int state;\n        String sizeStr = Utility.formatBytes(length).concat(\"  \");\n\n        if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n            h.size.setText(sizeStr);\n            return;\n        } else if (!mission.running) {\n                   state = mission.enqueued ? R.string.queued : R.string.paused;\n               } else if (mission.isPsRunning()) {\n                          state = R.string.post_processing;\n                      } else if (mission.isRecovering()) {\n                                 state = R.string.recovering;\n                             } else {\n                                 state = 0;\n                             }\n        if (state != 0) {\n            // update state without download speed\n            h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n            h.resetSpeedMeasure();\n            return;\n        }\n        if (h.lastTimestamp < 0) {\n            h.size.setText(sizeStr);\n            h.lastTimestamp = now;\n            h.lastDone = done;\n            return;\n        }\n\n        long deltaTime = now - h.lastTimestamp;\n        double deltaDone = done - h.lastDone;\n\n        if (h.lastDone > done) {\n            h.lastDone = done;\n            h.size.setText(sizeStr);\n            return;\n        }\n        if (deltaDone > 0 && deltaTime > 0) {\n            float speed = (float) ((deltaDone * 1000d) / deltaTime);\n            float averageSpeed = speed;\n\n            if (h.lastSpeedIdx < 0 ) {\n                Arrays.fill(h.lastSpeed, speed);\n                h.lastSpeedIdx = 0;\n            } else {\n                for(int i = 0;\n                i < h.lastSpeed.length;\n                i++) {\n                    averageSpeed += h.lastSpeed[i ];\n                }\n                averageSpeed /= h.lastSpeed.length + 1.0f;\n            }\n\n            String speedStr = Utility.formatSpeed(averageSpeed);\n            String etaStr;\n\n            if (mission.unknownLength) {\n                etaStr = \"\";\n            } else {\n                long eta = (long) Math.ceil((length - done) / averageSpeed);\n                etaStr = Utility.formatBytes((long) done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n            }\n            h.size.setText(sizeStr.concat(etaStr).concat(speedStr));\n            h.lastTimestamp = now;\n            h.lastDone = done;\n            h.lastSpeed[h.lastSpeedIdx ++] = speed;\n\n            if (h.lastSpeedIdx >= h.lastSpeed.length) h.lastSpeedIdx = 0;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "16", "src_id": "M817", "code": "\n    private Trun parseTrun() throws IOException {\n        final Trun obj = new Trun();\n        obj.bFlags = stream.readInt();\n        obj.entryCount = stream.readInt(); // unsigned int\n        obj.entriesRowSize = 0;\n\n        if (hasFlag(obj.bFlags, 0x0100)) {\n            obj.entriesRowSize += 4;\n        }\n        if (hasFlag(obj.bFlags, 0x0200)) {\n            obj.entriesRowSize += 4;\n        }\n        if (hasFlag(obj.bFlags, 0x0400)) {\n            obj.entriesRowSize += 4;\n        }\n        if (hasFlag(obj.bFlags, 0x0800)) {\n            obj.entriesRowSize += 4;\n        }\n        obj.bEntries = new\nbyte [obj.entriesRowSize * obj.entryCount];\n\n        if (hasFlag(obj.bFlags, 0x0001)) {\n            obj.dataOffset = stream.readInt();\n        }\n        if (hasFlag(obj.bFlags, 0x0004)) {\n            obj.bFirstSampleFlags = stream.readInt();\n        }\n        stream.read(obj.bEntries);\n        for(int i = 0;\n        i < obj.entryCount;\n        i++) {\n            final TrunEntry entry = obj.getEntry(i);\n\n            if (hasFlag(obj.bFlags, 0x0100)) {\n                obj.chunkDuration += entry.sampleDuration;\n            }\n            if (hasFlag(obj.bFlags, 0x0200)) {\n                obj.chunkSize += entry.sampleSize;\n            }\n            if (hasFlag(obj.bFlags, 0x0800)) {\n                if (!hasFlag(obj.bFlags, 0x0100)) {\n                    obj.chunkDuration += entry.sampleCompositionTimeOffset;\n                }\n            }\n        }\n\n        return obj;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "17", "src_id": "M883", "code": "\n    private void makeMvhd(final\n                          long longestTrack) throws IOException {\n        auxWrite(new\nbyte [] {0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00});\n        auxWrite(ByteBuffer.allocate(28).putLong(time).putLong(time).putInt(DEFAULT_TIMESCALE).putLong(longestTrack).array());\n        auxWrite(new\nbyte [] {0x00, 0x01, 0x00, 0x00, 0x01, 0x00, // default volume and rate 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved values\n                // default matrix 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00});\n        auxWrite(new\nbyte [ 24]); // predefined\n        auxWrite(ByteBuffer.allocate(4).putInt(tracks.length + 1).array());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "18", "src_id": "M806", "code": "\n    public Mp4DashChunk getNextChunk(final boolean infoOnly) throws IOException {\n        final Mp4Track track = tracks[selectedTrack ];\n        while (stream.available()) {\n            if (chunkZero) {\n                ensure(box);\n\n                if (!stream.available()) {\n                    break;\n                }\n                box = readBox();\n            } else {\n                chunkZero = true;\n            }\n\n            switch(box.type ) {\n                              case ATOM_MOOF:\n                              if (moof != null) {\n                                  throw new IOException(\"moof found without mdat\");\n                              }\n                              moof = parseMoof(box, track.trak.tkhd.trackId);\n\n                              if (moof.traf != null) {\n                                  if (hasFlag(moof.traf.trun.bFlags, 0x0001)) {\n                                      moof.traf.trun.dataOffset -= box.size + 8;\n\n                                      if (moof.traf.trun.dataOffset < 0) {\n                                          throw new IOException(\"trun box has wrong data offset, \" + \"points outside of concurrent mdat box\");\n                                      }\n                                  }\n                                  if (moof.traf.trun.chunkSize < 1) {\n                                      if (hasFlag(moof.traf.tfhd.bFlags, 0x10)) {\n                                          moof.traf.trun.chunkSize = moof.traf.tfhd.defaultSampleSize * moof.traf.trun.entryCount;\n                                      } else {\n                                          moof.traf.trun.chunkSize = (int) (box.size - 8);\n                                      }\n                                  }\n                                  if (!hasFlag(moof.traf.trun.bFlags, 0x900) && moof.traf.trun.chunkDuration == 0) {\n                                      if (hasFlag(moof.traf.tfhd.bFlags, 0x20)) {\n                                          moof.traf.trun.chunkDuration = moof.traf.tfhd.defaultSampleDuration * moof.traf.trun.entryCount;\n                                      }\n                                  }\n                              }\n\n                              break;\n                              case ATOM_MDAT:\n                              if (moof == null) {\n                                  throw new IOException(\"mdat found without moof\");\n                              }\n                              if (moof.traf == null) {\n                                  moof = null;\n                                  continue; // find another chunk\n                              }\n\n                              final Mp4DashChunk chunk = new Mp4DashChunk();\n                              chunk.moof = moof;\n\n                              if (!infoOnly) {\n                                  chunk.data = stream.getView(moof.traf.trun.chunkSize);\n                              }\n                              moof = null;\n                              stream.skipBytes(chunk.moof.traf.trun.dataOffset);\n                              return chunk;\n                              default: }\n        }\n\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "19", "src_id": "M1055", "code": "\n    public void updateMission(Mission mission) {\n        ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n        SQLiteDatabase database = getWritableDatabase();\n        String ts = String.valueOf(mission.timestamp);\n        int rowsAffected;\n\n        if (mission instanceof FinishedMission) {\n            if (mission.storage.isInvalid()) {\n                rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new\nString [] {\n                                                                                                        ts});\n            } else {\n                rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_PATH + \" = ?\", new\nString [] {\n                                                                                                   mission.storage.getUri().toString()});\n            }\n        } else {\n            throw new UnsupportedOperationException(\"DownloadMission\");\n        }\n        if (rowsAffected != 1) {\n            Log.e(\"FinishedMissionStore\", \"Expected 1 row to be affected by update but got \" + rowsAffected);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "20", "src_id": "M403", "code": "\n    private void animatePopupOverlayAndFinishService() {\n    final int targetTranslationY = (int) (closeOverlayBinding.closeButton.getRootView().getHeight() - closeOverlayBinding.closeButton.getY());\n    closeOverlayBinding.closeButton.animate().setListener(null).cancel();\n    closeOverlayBinding.closeButton.animate().setInterpolator(new AnticipateInterpolator()).translationY(targetTranslationY).setDuration(400).setListener(new AnimatorListenerAdapter() {\n                                                                                                                                                              @\n                                                                                                                                                              Override public void onAnimationCancel(final Animator animation) {\n                                                                                                                                                              end();\n                                                                                                                                                              }\n                                                                                                                                                              @\n                                                                                                                                                              Override public void onAnimationEnd(final Animator animation) {\n                                                                                                                                                              end();\n                                                                                                                                                              }\n                                                                                                                                                              private void end() {\n                                                                                                                                                              windowManager.removeView(closeOverlayBinding.getRoot());\n                                                                                                                                                              closeOverlayBinding = null;\n                                                                                                                                                              player.getService().destroyPlayerAndStopService();\n                                                                                                                                                              }\n\n}).start();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "21", "src_id": "M260", "code": "\n    public void play() {\n    if (DEBUG) {\n        Log.d(TAG, \"play() called\");\n    }\n\n    if (audioReactor == null|| playQueue == null|| exoPlayerIsNull()) {\n        return;\n    }\n\n    if (!isMuted()) {\n        audioReactor.requestAudioFocus();\n    }\n\n    if (currentState == STATE_COMPLETED) {\n        if (playQueue.getIndex() == 0) {\n                                           seekToDefault();\n        } else {\n            playQueue.setIndex(0);\n        }\n    }\n    simpleExoPlayer.play();\n    saveStreamProgressState();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "22", "src_id": "M543", "code": "\n    private synchronized NotificationCompat .Builder createNotification() {\n    if (DEBUG) {\n        Log.d(TAG, \"createNotification()\");\n    }\n    notificationManager = NotificationManagerCompat.from(player.getContext());\n    final NotificationCompat .Builder builder = new NotificationCompat . Builder(player.getContext(), player.getContext().getString(R.string.notification_channel_id));\n    final MediaStyle mediaStyle = new MediaStyle();\n\n        // setup media style (compact notification slots and media session)\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n            // notification actions are ignored on Android 13+, and are replaced by code in\n            // MediaSessionPlayerUi\n        final int [] compactSlots = initializeNotificationSlots();\n        mediaStyle.setShowActionsInCompactView(compactSlots);\n    }\n    player.UIs().get(MediaSessionPlayerUi.class).flatMap(MediaSessionPlayerUi::getSessionToken).ifPresent(mediaStyle::setMediaSession);\n\n        // setup notification builder\n    builder.setStyle(mediaStyle).setPriority(NotificationCompat.PRIORITY_HIGH).setVisibility(NotificationCompat.VISIBILITY_PUBLIC).setCategory(NotificationCompat.CATEGORY_TRANSPORT).setShowWhen(false).setSmallIcon(R.drawable.ic_newpipe_triangle_white).setColor(ContextCompat.getColor(player.getContext(), R.color.dark_background_color)).setColorized(player.getPrefs().getBoolean(player.getContext().getString(R.string.notification_colorize_key), true)).setDeleteIntent(PendingIntentCompat.getBroadcast(player.getContext(), NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, false));\n\n        // set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n    setLargeIcon(builder);\n    return builder;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "23", "src_id": "M225", "code": "\n    private void onBroadcastReceived(final Intent intent) {\n    if (intent == null|| intent.getAction() == null) {\n        return;\n    }\n\n    if (DEBUG) {\n        Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n    }\n\n    switch(intent.getAction()) {\n        case\n                                   AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n        pause();\n        break;\n                               case\n                                   ACTION_CLOSE:\n        service.destroyPlayerAndStopService();\n        break;\n                               case\n                                   ACTION_PLAY_PAUSE:\n        playPause();\n        break;\n                               case\n                                   ACTION_PLAY_PREVIOUS:\n        playPrevious();\n        break;\n                               case\n                                   ACTION_PLAY_NEXT:\n        playNext();\n        break;\n                               case\n                                   ACTION_FAST_REWIND:\n        fastRewind();\n        break;\n                               case\n                                   ACTION_FAST_FORWARD:\n        fastForward();\n        break;\n                               case\n                                   ACTION_REPEAT:\n        cycleNextRepeatMode();\n        break;\n                               case\n                                   ACTION_SHUFFLE:\n        toggleShuffleModeEnabled();\n        break;\n                               case\n                                   Intent.ACTION_CONFIGURATION_CHANGED:\n        if (DEBUG) {\n            Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n        }\n\n        break;\n    }\n    UIs.call(playerUi-> playerUi.onBroadcastReceived(intent));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "24", "src_id": "M631", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "25", "src_id": "M12", "code": "\n    private void openDetailFragmentFromCommentReplies(@ NonNull final FragmentManager fm, final boolean popBackStack) {\n        // obtain the name of the fragment under the replies fragment that's going to be popped\n    @\n        Nullable final String fragmentUnderEntryName;\n    if (fm.getBackStackEntryCount() < 2) {\n                                             fragmentUnderEntryName = null;\n    } else {\n        fragmentUnderEntryName = fm.getBackStackEntryAt(fm.getBackStackEntryCount() - 2).getName();\n    }\n\n        // the root comment is the comment for which the user opened the replies page\n\n    @\n        Nullable final CommentRepliesFragment repliesFragment = (CommentRepliesFragment) fm.findFragmentByTag(CommentRepliesFragment.TAG);\n    @\n        Nullable final CommentsInfoItem rootComment = repliesFragment == null ?\n        null: repliesFragment.getCommentsInfoItem();\n\n        // sometimes this function pops the backstack, other times it's handled by the system\n    if (popBackStack) {\n        fm.popBackStackImmediate();\n    }\n\n        // only expand the bottom sheet back if there are no more nested comment replies fragments\n        // stacked under the one that is currently being popped\n\n    if (CommentRepliesFragment.TAG.equals(fragmentUnderEntryName)) {\n        return;\n    }\n\n    final BottomSheetBehavior < FragmentContainerView > behavior = BottomSheetBehavior.from(mainBinding.fragmentPlayerHolder);\n        // do not return to the comment if the details fragment was closed\n    if (behavior.getState() == BottomSheetBehavior.STATE_HIDDEN) {\n        return;\n    }\n\n        // scroll to the root comment once the bottom sheet expansion animation is finished\n    behavior.addBottomSheetCallback(new BottomSheetBehavior . BottomSheetCallback() {\n                                        @\n                                        Override public void onStateChanged(@ NonNull final View bottomSheet, final int newState) {\n                                        if (newState == BottomSheetBehavior.STATE_EXPANDED) {\n                                            final Fragment detailFragment = fm.findFragmentById(R.id.fragment_player_holder);\n                                            if (detailFragment instanceof VideoDetailFragment && rootComment != null) {\n                        // should always be the case\n                                                ((VideoDetailFragment) detailFragment).scrollToComment(rootComment);\n                                            }\n                                            behavior.removeBottomSheetCallback(this);\n                                        }\n                                        }\n                                        @\n                                        Override public void onSlide(@ NonNull final View bottomSheet, final float slideOffset) {\n                // not needed, listener is removed once the sheet is expanded\n}\n\n});\n    behavior.setState(BottomSheetBehavior.STATE_EXPANDED);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "26", "src_id": "M372", "code": "\n    private void buildCaptionMenu(@ NonNull final List < String > availableLanguages) {\n    if (captionPopupMenu == null) {\n        return;\n    }\n    captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n    captionPopupMenu.setOnDismissListener(this);\n\n        // Add option for turning off caption\n    final MenuItem captionOffItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, 0, Menu.NONE, R.string.caption_none);\n    captionOffItem.setOnMenuItemClickListener(menuItem-> {\n                                              final int textRendererIndex = player.getCaptionRendererIndex();\n                                              if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                                                  player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters().setRendererDisabled(textRendererIndex, true));\n                                              }\n                                              player.getPrefs().edit().remove(context.getString(R.string.caption_user_set_key)).apply();\n                                              return true;\n                                              });\n\n        // Add all available captions\n    for (int i = 0; i < availableLanguages.size(); i++) {\n    final String captionLanguage = availableLanguages.get(i);\n    final MenuItem captionItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, i + 1, Menu.NONE, captionLanguage);\n    captionItem.setOnMenuItemClickListener(menuItem-> {\n                                           final int textRendererIndex = player.getCaptionRendererIndex();\n                                           if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                    // DefaultTrackSelector will select for text tracks in the following order.\n                    // When multiple tracks share the same rank, a random track will be chosen.\n                    // 1. ANY track exactly matching preferred language name\n                    // 2. ANY track exactly matching preferred language stem\n                    // 3. ROLE_FLAG_CAPTION track matching preferred language stem\n                    // 4. ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND track matching preferred language stem\n                    // This means if a caption track of preferred language is not available,\n                    // then an auto-generated track of that language will be chosen automatically.\n                                               player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters().setPreferredTextLanguages(captionLanguage, PlayerHelper.captionLanguageStemOf(captionLanguage)).setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION).setRendererDisabled(textRendererIndex, false));\n                                               player.getPrefs().edit().putString(context.getString(R.string.caption_user_set_key), captionLanguage).apply();\n                                           }\n\n                                           return true;\n                                           });\n    }\n    captionPopupMenu.setOnDismissListener(this);\n\n        // apply caption language from previous user preference\n    final int textRendererIndex = player.getCaptionRendererIndex();\n    if (textRendererIndex == RENDERER_UNAVAILABLE) {\n        return;\n    }\n\n        // If user prefers to show no caption, then disable the renderer.\n        // Otherwise, DefaultTrackSelector may automatically find an available caption\n        // and display that.\n\n    final String userPreferredLanguage = player.getPrefs().getString(context.getString(R.string.caption_user_set_key), null);\n    if (userPreferredLanguage == null) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters().setRendererDisabled(textRendererIndex, true));\n        return;\n    }\n\n        // Only set preferred language if it does not match the user preference,\n        // otherwise there might be an infinite cycle at onTextTracksChanged.\n\n    final List < String > selectedPreferredLanguages = player.getTrackSelector().getParameters().preferredTextLanguages;\n    if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters().setPreferredTextLanguages(userPreferredLanguage, PlayerHelper.captionLanguageStemOf(userPreferredLanguage)).setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION).setRendererDisabled(textRendererIndex, false));\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "27", "src_id": "M741", "code": "\n    private void onItemSelectedSetFileName() {\n    final String fileName = FilenameUtils.createFilename(getContext(), currentInfo.getName());\n    final String prevFileName = Optional.ofNullable(dialogBinding.fileName.getText()).map(Object::toString).orElse(\"\");\n    if (prevFileName.isEmpty()|| prevFileName.equals(fileName)|| prevFileName.startsWith(getString(R.string.caption_file_name, fileName, \"\"))) {\n            // only update the file name field if it was not edited by the user\n        switch(dialogBinding.videoAudioGroup.getCheckedRadioButtonId()) {\n                                                                        case\n                                                                            R.id.audio_button: case R.id.video_button:\n                                                                        if (!prevFileName.equals(fileName)) {\n                        // since the user might have switched between audio and video, the correct\n                        // text might already be in place, so avoid resetting the cursor position\n                                                                            dialogBinding.fileName.setText(fileName);\n                                                                        }\n\n                                                                        break;\n                                                                        case\n                                                                            R.id.subtitle_button:\n                                                                        final String setSubtitleLanguageCode = subtitleStreamsAdapter.getItem(selectedSubtitleIndex).getLanguageTag();\n                    // this will reset the cursor position, which is bad UX, but it can't be avoided\n                                                                        dialogBinding.fileName.setText(getString(R.string.caption_file_name, fileName, setSubtitleLanguageCode));\n                                                                        break;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "28", "src_id": "M327", "code": "\n    protected void deinitListeners() {\n    binding.qualityTextView.setOnClickListener(null);\n    binding.audioTrackTextView.setOnClickListener(null);\n    binding.playbackSpeed.setOnClickListener(null);\n    binding.playbackSeekBar.setOnSeekBarChangeListener(null);\n    binding.captionTextView.setOnClickListener(null);\n    binding.resizeTextView.setOnClickListener(null);\n    binding.playbackLiveSync.setOnClickListener(null);\n    binding.getRoot().setOnTouchListener(null);\n    playerGestureListener = null;\n    gestureDetector = null;\n    binding.repeatButton.setOnClickListener(null);\n    binding.shuffleButton.setOnClickListener(null);\n    binding.playPauseButton.setOnClickListener(null);\n    binding.playPreviousButton.setOnClickListener(null);\n    binding.playNextButton.setOnClickListener(null);\n    binding.moreOptionsButton.setOnClickListener(null);\n    binding.moreOptionsButton.setOnLongClickListener(null);\n    binding.share.setOnClickListener(null);\n    binding.share.setOnLongClickListener(null);\n    binding.fullScreenButton.setOnClickListener(null);\n    binding.screenRotationButton.setOnClickListener(null);\n    binding.playWithKodi.setOnClickListener(null);\n    binding.openInBrowser.setOnClickListener(null);\n    binding.playerCloseButton.setOnClickListener(null);\n    binding.switchMute.setOnClickListener(null);\n    ViewCompat.setOnApplyWindowInsetsListener(binding.itemsListPanel, null);\n    binding.playbackControlRoot.removeOnLayoutChangeListener(onLayoutChangeListener);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "29", "src_id": "M239", "code": "\n    private void updatePlaybackState(final boolean playWhenReady, final int playbackState) {\n    if (DEBUG) {\n        Log.d(TAG, \"ExoPlayer - updatePlaybackState() called with: \" + \"playWhenReady = [\" + playWhenReady + \"], \" + \"playbackState = [\" + playbackState + \"]\");\n    }\n\n    if (currentState == STATE_PAUSED_SEEK) {\n        if (DEBUG) {\n            Log.d(TAG, \"updatePlaybackState() is currently blocked\");\n        }\n\n        return;\n    }\n\n    switch(playbackState) {\n        case\n                              com.google.android.exoplayer2.Player.STATE_IDLE: // 1\n        isPrepared = false;\n        break;\n                          case\n                              com.google.android.exoplayer2.Player.STATE_BUFFERING: // 2\n        if (isPrepared) {\n            changeState(STATE_BUFFERING);\n        }\n\n        break;\n                          case\n                              com.google.android.exoplayer2.Player.STATE_READY: //3\n        if (!isPrepared) {\n            isPrepared = true;\n            onPrepared(playWhenReady);\n        }\n        changeState(playWhenReady ?\n            STATE_PLAYING: STATE_PAUSED);\n        break;\n                          case\n                              com.google.android.exoplayer2.Player.STATE_ENDED: // 4\n        changeState(STATE_COMPLETED);\n        saveStreamProgressStateCompleted();\n        isPrepared = false;\n        break;\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "30", "src_id": "M355", "code": "\n    private static String processInlineImages(String htmlContent, EmailContent emailContent) {\n        if (htmlContent == null || emailContent == null) return htmlContent;\n\n        // Create a map of Content-ID to attachment data\n        Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n        for (EmailAttachment attachment : emailContent.getAttachments()) {\n            if (attachment.isEmbedded() && attachment.getContentId() != null && attachment.getData() != null) {\n                contentIdMap.put(attachment.getContentId(), attachment);\n            }\n        }\n        if (contentIdMap.isEmpty()) return htmlContent;\n\n        // Pattern to match cid: references in img src attributes\n        Pattern cidPattern = Pattern.compile(\"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = cidPattern.matcher(htmlContent);\n        StringBuffer result = new StringBuffer();\n        while (matcher.find()) {\n            String contentId = matcher.group(1);\n            EmailAttachment attachment = contentIdMap.get(contentId);\n            if (attachment != null && attachment.getData() != null) {\n                // Convert to data URI\n                String mimeType = attachment.getContentType();\n                if (mimeType == null || mimeType.isEmpty()) {\n                    // Try to determine MIME type from filename\n                    String filename = attachment.getFilename();\n                    if (filename != null) {\n                        if (filename.toLowerCase() .endsWith(\".png\")) {\n                            mimeType = \"image/png\";\n                        } else if (filename.toLowerCase() .endsWith(\".jpg\") || filename.toLowerCase() .endsWith(\".jpeg\")) {\n                                   mimeType = \"image/jpeg\";\n                        } else if (filename.toLowerCase() .endsWith(\".gif\")) {\n                                   mimeType = \"image/gif\";\n                               } else if (filename.toLowerCase() .endsWith(\".bmp\")) {\n                                          mimeType = \"image/bmp\";\n                               } else {\n                                          mimeType = \"image/png\"; // fallback\n                               }\n                    } else {\n                        mimeType = \"image/png\"; // fallback\n                    }\n                }\n\n                String base64Data = Base64.getEncoder() .encodeToString(attachment.getData());\n                String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n                // Replace the cid: reference with the data URI\n                String replacement = matcher.group(0) .replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n                matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n            } else {\n                // Keep original if attachment not found\n                matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n            }\n        }\n\n        matcher.appendTail(result);\n\n        return result.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "31", "src_id": "M347", "code": "\n    private static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n        // Create attachment info with paperclip emoji before filename\n        attachmentInfo.append(\"<div class=\\\"attachment-item\\\">\") .append(\"<span class=\\\"attachment-icon\\\">\") .append(MimeConstants.ATTACHMENT_MARKER) .append(\"</span> \") .append(\"<span class=\\\"attachment-name\\\">\") .append(escapeHtml(filename)).append(\"</span>\");\n\n        // Add content type and encoding info\n\n        if (!contentType.isEmpty() || !encoding.isEmpty()) {\n            attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n\n            if (!contentType.isEmpty()) {\n                attachmentInfo.append(escapeHtml(contentType));\n            }\n            if (!encoding.isEmpty()) {\n                if (!contentType.isEmpty()) attachmentInfo.append(\", \");\n                attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n            }\n\n            attachmentInfo.append(\")</span>\");\n        }\n\n        attachmentInfo.append(\"</div>\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "32", "src_id": "M356", "code": "\n    private static void appendEnhancedStyles(StringBuilder html) {\n        int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n        String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n        String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n        String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n        html.append(\"body {\\n\");\n        html.append(\"  font-family: \") .append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n        html.append(\"  font-size: \") .append(fontSize).append(\"px;\\n\");\n        html.append(\"  line-height: \") .append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n        html.append(\"  color: \") .append(textColor).append(\";\\n\");\n        html.append(\"  margin: 0;\\n\");\n        html.append(\"  padding: 16px;\\n\");\n        html.append(\"  background-color: \") .append(backgroundColor).append(\";\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-container {\\n\");\n        html.append(\"  width: 100%;\\n\");\n        html.append(\"  max-width: 100%;\\n\");\n        html.append(\"  margin: 0 auto;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header {\\n\");\n        html.append(\"  padding-bottom: 10px;\\n\");\n        html.append(\"  border-bottom: 1px solid \") .append(borderColor).append(\";\\n\");\n        html.append(\"  margin-bottom: 10px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header h1 {\\n\");\n        html.append(\"  margin: 0 0 10px 0;\\n\");\n        html.append(\"  font-size: \") .append(fontSize + 4).append(\"px;\\n\");\n        html.append(\"  font-weight: bold;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-meta div {\\n\");\n        html.append(\"  margin-bottom: 2px;\\n\");\n        html.append(\"  font-size: \") .append(fontSize - 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-body {\\n\");\n        html.append(\"  word-wrap: break-word;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section {\\n\");\n        html.append(\"  margin-top: 15px;\\n\");\n        html.append(\"  padding: 10px;\\n\");\n        html.append(\"  background-color: \") .append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\");\n        html.append(\"  border: 1px solid \") .append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section h3 {\\n\");\n        html.append(\"  margin: 0 0 8px 0;\\n\");\n        html.append(\"  font-size: \") .append(fontSize + 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-item {\\n\");\n        html.append(\"  padding: 5px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-icon {\\n\");\n        html.append(\"  margin-right: 5px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-details, .attachment-type {\\n\");\n        html.append(\"  font-size: \") .append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  color: #555555;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n        html.append(\"  margin-top: 8px;\\n\");\n        html.append(\"  padding: 6px;\\n\");\n        html.append(\"  font-size: \") .append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note {\\n\");\n        html.append(\"  background-color: #e6ffed;\\n\");\n        html.append(\"  border: 1px solid #d4f7dc;\\n\");\n        html.append(\"  color: #006420;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-info-note {\\n\");\n        html.append(\"  background-color: #fff9e6;\\n\");\n        html.append(\"  border: 1px solid #fff0c2;\\n\");\n        html.append(\"  color: #664d00;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container {\\n\");\n        html.append(\"  display: flex;\\n\");\n        html.append(\"  align-items: center;\\n\");\n        html.append(\"  padding: 8px;\\n\");\n        html.append(\"  background-color: #f8f9fa;\\n\");\n        html.append(\"  border: 1px solid #dee2e6;\\n\");\n        html.append(\"  border-radius: 4px;\\n\");\n        html.append(\"  margin: 4px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container:hover {\\n\");\n        html.append(\"  background-color: #e9ecef;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-note {\\n\");\n        html.append(\"  font-size: \") .append(fontSize - 3).append(\"px;\\n\");\n        html.append(\"  color: #6c757d;\\n\");\n        html.append(\"  font-style: italic;\\n\");\n        html.append(\"  margin-left: 8px;\\n\");\n        html.append(\"}\\n\\n\");\n\n        // Basic image styling: ensure images are responsive but not overly constrained.\n        html.append(\"img {\\n\");\n        html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n        html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n        html.append(\"  display: block;\\n\"); // Avoid extra space below images\n        html.append(\"}\\n\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "33", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ?textBody: \"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\") .append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\") .append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \") .append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \") .append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim() .isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \") .append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim() .isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \") .append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n        if (!date.trim() .isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \") .append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        // Show advanced features status if requested\n        assert request != null;\n\n        if (request.getFileInput() .isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n\n        return html.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "34", "src_id": "M361", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "35", "src_id": "M362", "code": "\n    private static\n    String generateEnhancedEmailHtml(EmailContent content,EmlToPdfRequest request) {\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\") .append(escapeHtml(content.getSubject())).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\") .append(escapeHtml(content.getSubject())).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \") .append(escapeHtml(content.getFrom())).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \") .append(escapeHtml(content.getTo())).append(\"</div>\\n\");\n        if (content.getDate() != null) {\n            html.append(\"<div><strong>Date:</strong> \") .append(formatEmailDate(content.getDate())).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        if (content.getHtmlBody() != null && !content.getHtmlBody() .trim() .isEmpty()) {\n            html.append(processEmailHtmlBody(content.getHtmlBody(), content));\n        } else if (content.getTextBody() != null && !content.getTextBody() .trim() .isEmpty()) {\n                   html.append(\"<div class=\\\"text-body\\\">\");\n                   html.append(convertTextToHtml(content.getTextBody()));\n                   html.append(\"</div>\");\n               } else {\n                   html.append(\"<div class=\\\"no-content\\\">\");\n                   html.append(\"<p><em>No content available</em></p>\");\n                   html.append(\"</div>\");\n               }\n\n        html.append(\"</div>\\n\");\n        if (content.getAttachmentCount()> 0||\n            !content.getAttachments() .isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            int displayedAttachmentCount = content.getAttachmentCount()> 0?content.getAttachmentCount():content.getAttachments() .size();\n            html.append(\"<h3>Attachments (\") .append(displayedAttachmentCount).append(\")</h3>\\n\");\n            if (!content.getAttachments() .isEmpty()) {\n                for(EmailAttachment attachment :content.getAttachments()) {\n                    // Create attachment info with paperclip emoji before filename\n                    String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n                    attachment.setEmbeddedFilename(attachment.getEmbeddedFilename() != null?attachment.getEmbeddedFilename():attachment.getFilename());\n                    html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\") .append(uniqueId) .append(\"\\\">\") .append(\"<span class=\\\"attachment-icon\\\">\") .append(MimeConstants.ATTACHMENT_MARKER) .append(\"</span> \") .append(\"<span class=\\\"attachment-name\\\">\") .append(escapeHtml(safeMimeDecode(attachment.getFilename()))).append(\"</span>\");\n                    String sizeStr = formatFileSize(attachment.getSizeBytes());\n                    html.append(\" <span class=\\\"attachment-details\\\">(\").append(sizeStr);\n                    if (attachment.getContentType() != null && !attachment.getContentType() .isEmpty()) {\n                        html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                    }\n\n                    html.append(\")</span></div>\\n\");\n                }\n            }\n\n            if (request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachments are embedded in the file.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "36", "src_id": "M367", "code": "\n    private static\n    String decodeMimeHeader(String encodedText) {\n        if (encodedText == null||encodedText.trim() .isEmpty()) {\n            return encodedText;\n        }\n\n        try {\n            StringBuilder result = new StringBuilder();\n            Matcher matcher = MimeConstants.MIME_ENCODED_PATTERN.matcher(encodedText);\n            int lastEnd = 0;\n            while(matcher.find()) {\n                // Add any text before the encoded part\n                result.append(encodedText, lastEnd, matcher.start());\n                String charset = matcher.group(1);\n                String encoding = matcher.group(2) .toUpperCase();\n                String encodedValue = matcher.group(3);\n                try {\n                    String decodedValue;\n                    if (\"B\".equals(encoding)) {\n                        // Base64 decoding\n                        byte [] decodedBytes = Base64.getDecoder() .decode(encodedValue);\n                        decodedValue = new String(decodedBytes, Charset.forName(charset));\n                    } else if (\"Q\".equals(encoding)) {\n                        // Quoted-printable decoding\n                               decodedValue = decodeQuotedPrintable(encodedValue, charset);\n                           } else {\n                        // Unknown encoding, keep original\n                               decodedValue = matcher.group(0);\n                           }\n\n                    result.append(decodedValue);\n                } catch (Exception e) {\n                    log.warn(\"Failed to decode MIME header part: {}\", matcher.group(0), e);\n                    // If decoding fails, keep the original encoded text\n                    result.append(matcher.group(0));\n                }\n\n                lastEnd = matcher.end();\n            }\n\n            // Add any remaining text after the last encoded part\n\n            result.append(encodedText.substring(lastEnd));\n            return result.toString();\n        } catch (Exception e) {\n            log.warn(\"Error decoding MIME header: {}\", encodedText, e);\n            return encodedText; // Return original if decoding fails\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "37", "src_id": "M509", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\") @Operation(summary = \"Convert EML to PDF\", description = \"This endpoint converts EML (email) files to PDF format with extensive\"+ \" customization options. Features include font settings, image constraints, display modes, attachment handling,\" + \" and HTML debug output. Input: EML file, Output: PDF\" + \" or HTML file. Type: SISO\")\n    public ResponseEntity<byte\n                              []> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n        MultipartFile inputFile = request.getFileInput();\n        String originalFilename = inputFile.getOriginalFilename();\n\n        // Validate input\n        if (inputFile.isEmpty()) {\n            log.error(\"No file provided for EML to PDF conversion.\");\n            return ResponseEntity.badRequest() .body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        if (originalFilename == null||originalFilename.trim() .isEmpty()) {\n            log.error(\"Filename is null or empty.\");\n            return ResponseEntity.badRequest() .body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        // Validate file type - support EML\n\n        String lowerFilename = originalFilename.toLowerCase();\n        if (!lowerFilename.endsWith(\".eml\")) {\n            log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n            return ResponseEntity.badRequest() .body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n        try {\n            byte [] fileBytes = inputFile.getBytes();\n            if (request.isDownloadHtml()) {\n                try {\n                    String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                    log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                    return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8), baseFilename + \".html\", MediaType.TEXT_HTML);\n                } catch (IOException|IllegalArgumentException e) {\n                    log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body((\"HTML conversion failed: \"+ e.getMessage()) .getBytes(StandardCharsets.UTF_8));\n                }\n            }\n\n            // Convert EML to PDF with enhanced options\n\n            try {\n                byte [] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig.getWeasyPrintPath(), // Use configured WeasyPrint path request, fileBytes, originalFilename, false, pdfDocumentFactory, tempFileManager);\n                if (pdfBytes == null||pdfBytes.length == 0) {\n                    log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n                }\n\n                log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n            }\n\n              catch (IllegalArgumentException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            }\n\n              catch (RuntimeException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            }\n        } catch (IOException e) {\n            log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "38", "src_id": "M1294", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "39", "src_id": "M50", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "40", "src_id": "M933", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "41", "src_id": "M913", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1146", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "43", "src_id": "M55", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "44", "src_id": "M52", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1213", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "46", "src_id": "M1131", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "47", "src_id": "M1298", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "48", "src_id": "M8", "code": "\n    private static String formatFileSize(long size) {\n        String hrSize;\n        double b = size;\n        double k = size/1024.0;\n        double m = ((size/1024.0)/1024.0);\n        double g = (((size/1024.0)/1024.0)/1024.0);\n        double t = ((((size/1024.0)/1024.0)/1024.0)/1024.0);\n        DecimalFormat dec = new DecimalFormat(\"0.00\");\n        if (t > 1) {\n            hrSize = dec.format(t).concat(\" TB\");\n        } else if (g > 1) {\n                   hrSize = dec.format(g).concat(\" GB\");\n               } else if (m > 1) {\n                          hrSize = dec.format(m).concat(\" MB\");\n                      } else if (k > 1) {\n                                 hrSize = dec.format(k).concat(\" KB\");\n                             } else {\n                                 hrSize = dec.format(b).concat(\" Bytes\");\n                             }\n        return hrSize;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "49", "src_id": "M357", "code": "\n    private static Class[] parseTypes(String desc, ClassLoader loader) throws ClassNotFoundException {\n        int lparen = desc.indexOf('(');\n        int rparen = desc.indexOf(')', lparen);\n        List params = new ArrayList();\n        int start = lparen + 1;\n\n        for (;;) {\n            int comma = desc.indexOf(',', start);\n            if (comma < 0) {\n                break;\n            }\n            params.add(desc.substring(start, comma).trim());\n            start = comma + 1;\n        }\n\n        if (start <rparen) {\n            params.add(desc.substring(start, rparen).trim());\n        }\n\n        Class [] types = new Class[params.size()];\n\n        for (int i = 0;i <types.length;\n        i++) {\n            types[i] = getClass((String)params.get(i), loader);\n        }\n        return types;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "50", "src_id": "M566", "code": "\n    @Override\n    public void process(final CommandProcess process) {\n        Session session = process.session();\n        timer = new Timer(\"Timer-for-arthas-dashboard-\" + session.getSessionId(), true);\n\n        // ctrl-C support\n        process.interruptHandler(new DashboardInterruptHandler(process, timer));\n\n        /*\n         * 通过handle回调，在suspend和end时停止timer，resume时重启timer\n         */\n        Handler<Void> stopHandler = new Handler<Void>() {\n                                        @Override\n                                        public void handle(Void event) {\n                                            stop();\n                                        }\n\n                                    };\n        Handler<Void> restartHandler = new Handler<Void>() {\n                                           @Override\n                                           public void handle(Void event) {\n                                               restart(process);\n                                           }\n\n                                       };\n        process.suspendHandler(stopHandler);\n        process.resumeHandler(restartHandler);\n        process.endHandler(stopHandler);\n\n        // q exit support\n        process.stdinHandler(new QExitHandler(process));\n\n        // start the timer\n        timer.scheduleAtFixedRate(new DashboardTimerTask(process), 0, getInterval());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "51", "src_id": "M114", "code": "\n    public boolean isAvailable() {\n        if (isConnected()) {\n            try {\n                if (_socket_.getInetAddress() == null) {\n                    return false;\n                }\n\n                if (_socket_.getPort() == 0) {\n                    return false;\n                }\n\n                if (_socket_.getRemoteSocketAddress() == null) {\n                    return false;\n                }\n\n                if (_socket_.isClosed()) {\n                    return false;\n                }\n                /* these aren't exact checks (a Socket can be half-open),\n                   but since we usually require two-way data transfer,\n                   we check these here too: */\n\n                if (_socket_.isInputShutdown()) {\n                    return false;\n                }\n\n                if (_socket_.isOutputShutdown()) {\n                    return false;\n                }\n                /* ignore the result, catch exceptions: */\n                _socket_.getInputStream();\n                _socket_.getOutputStream();\n            } catch (IOException ioex) {\n                return false;\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "52", "src_id": "M232", "code": "\n    public void start() throws Exception {\n        // Configure SSL.\n        final SslContext sslCtx;\n        if (ssl) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n\n        ServerBootstrap b = new ServerBootstrap();\n        b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class ).handler(new LoggingHandler(LogLevel.INFO) ).childHandler(new TunnelSocketServerInitializer(this, sslCtx));\n        if (StringUtils.isBlank(host)) {\n            channel = b.bind(port).sync().channel();\n        } else {\n            channel = b.bind(host, port).sync().channel();\n        }\n        logger.info(\"Tunnel server listen at {}:{}\", host, port);\n        workerGroup.scheduleWithFixedDelay(new Runnable() {\n                                               @Override\n                                               public void run() {\n                                                   agentInfoMap.entrySet().removeIf(e->!e.getValue().getChannelHandlerContext().channel().isActive());\n                                                   clientConnectionInfoMap.entrySet().removeIf(e->!e.getValue().getChannelHandlerContext().channel().isActive());\n                \n                // 更新集群key信息\n                                                   if (tunnelClusterStore != null && clientConnectHost != null) {\n                                                       try {\n                                                           for (Entry<String, AgentInfo> entry : agentInfoMap.entrySet()) {\n                                                               tunnelClusterStore.addAgent(entry.getKey(), new AgentClusterInfo(entry.getValue(), clientConnectHost, port), 60* 60, TimeUnit.SECONDS);\n                                                           }\n                                                       } catch (Throwable t) {\n                                                           logger.error(\"update tunnel info error\", t);\n                                                       }\n                                                   }\n                                               }\n\n                                           }, 60, 60, TimeUnit.SECONDS);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "53", "src_id": "M65", "code": "\n    public Map<String, Class<?>> build() {\n        errors.clear();\n        warnings.clear();\n        JavaFileManager fileManager = new DynamicJavaFileManager(standardFileManager, dynamicClassLoader);\n        DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<JavaFileObject>();\n        JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, collector, options, null, compilationUnits);\n\n        try {\n            if (!compilationUnits.isEmpty()) {\n                boolean result = task.call();\n                if (!result\n                        || collector.getDiagnostics().size()> 0) {\n                    for (Diagnostic<? extends JavaFileObject> diagnostic : collector.getDiagnostics()) {\n                        switch(diagnostic.getKind()) {\n                                                     case NOTE: case MANDATORY_WARNING: case WARNING:\n                                                     warnings.add(diagnostic);\n                                                     break;\n                                                     case OTHER: case ERROR: default:\n                            errors.add(diagnostic);\n                            break;\n                        }\n                    }\n\n                    if (!errors.isEmpty()) {\n                        throw new DynamicCompilerException(\"Compilation Error\", errors);\n                    }\n                }\n            }\n            return dynamicClassLoader.getClasses();\n        } catch (Throwable e) {\n            throw new DynamicCompilerException(e, errors);\n        }\n\n        finally {\n                compilationUnits.clear();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "54", "src_id": "M183", "code": "\n    public SimpleHttpResponse query(String targetUrl) throws InterruptedException {\n        final Promise<SimpleHttpResponse> httpResponsePromise = GlobalEventExecutor.INSTANCE.newPromise();\n        final EventLoopGroup group = new NioEventLoopGroup(1, new DefaultThreadFactory(\"arthas-ProxyClient\", true));\n        ChannelFuture closeFuture = null;\n\n        try {\n            Bootstrap b = new Bootstrap();\n            b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n            b.group(group).channel(LocalChannel.class ).handler(new ChannelInitializer<LocalChannel>() {\n                                                                    @Override\n                                                                    protected void initChannel(LocalChannel ch) {\n                                                                        ChannelPipeline p = ch.pipeline();\n                                                                        p.addLast(new HttpClientCodec(), new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH), new HttpProxyClientHandler(httpResponsePromise));\n                                                                    }\n\n                                                                });\n            LocalAddress localAddress = new LocalAddress(ArthasConstants.NETTY_LOCAL_ADDRESS);\n            Channel localChannel = b.connect(localAddress).sync().channel();\n\n            // Prepare the HTTP request.\n            HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, targetUrl, Unpooled.EMPTY_BUFFER);\n            request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            localChannel.writeAndFlush(request);\n            closeFuture = localChannel.closeFuture();\n            logger.info(\"proxy client connect to server success, targetUrl: \" + targetUrl);\n            return httpResponsePromise.get(5000, TimeUnit.MILLISECONDS);\n        } catch (Throwable e) {\n            logger.error(\"ProxyClient error, targetUrl: {}\", targetUrl, e);\n        }\n\n        finally {\n                if (closeFuture != null) {\n                    closeFuture.addListener(new ChannelFutureListener() {\n                                                @Override\n                                                public void operationComplete(ChannelFuture channelFuture) throws Exception {\n                                                    group.shutdownGracefully();\n                                                }\n\n                                            });\n                } else {\n                    group.shutdownGracefully();\n                }\n        }\n\n        SimpleHttpResponse httpResponse = new SimpleHttpResponse();\n\n        try {\n            httpResponse.setContent(\"error\".getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            // ignore\n        }\n        return httpResponse;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "55", "src_id": "M131", "code": "\n    @Override\n    public void write(int ch) throws IOException {\n        synchronized(__client) {\n                               ch &= 0xff;\n                               if (__client._requestedWont(TelnetOption.BINARY)) // i.e. ASCII {\n                                   if (__lastWasCR) {\n                                       if (__convertCRtoCRLF) {\n                                           __client._sendByte('\\n');\n                                           if (ch == '\\n') // i.e. was CRLF anyway {\n                                               __lastWasCR = false;\n                                               return;\n                                           }\n                                       } // __convertCRtoCRLF else if (ch != '\\n') {\n                                                                       __client._sendByte('\\0'); // RFC854 requires CR NUL for bare CR\n                                                                   }\n                                   }\n                                   switch(ch) {\n                                              case '\\r':\n                                              __client._sendByte('\\r');\n                                              __lastWasCR = true;\n                                              break;\n                                              case '\\n':\n                                       if (!__lastWasCR) { // convert LF to CRLF\n                                           __client._sendByte('\\r');\n                                       }\n                                       __client._sendByte(ch);\n                                       __lastWasCR = false;\n                                       break;\n                                              case TelnetCommand.IAC:\n                                       __client._sendByte(TelnetCommand.IAC);\n                                       __client._sendByte(TelnetCommand.IAC);\n                                       __lastWasCR = false;\n                                       break;\n                                              default:\n                                       __client._sendByte(ch);\n                                       __lastWasCR = false;\n                                       break;\n                                   }\n                               } // end ASCII else if (ch == TelnetCommand.IAC) {\n                                                       __client._sendByte(ch);\n                                                       __client._sendByte(TelnetCommand.IAC);\n                                                   } else {\n                                                       __client._sendByte(ch);\n                                                   }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "56", "src_id": "M443", "code": "\n    private String drawField() {\n        final StringBuilder fieldSB = new StringBuilder();\n        final Field[] fields = clazz.getDeclaredFields();\n        if (fields.length > 0) {\n            for (Field field : fields) {\n                final KVView kvView = new KVView(new TableView.ColumnDefine(TableView.Align.RIGHT), new TableView.ColumnDefine(50, false, TableView.Align.LEFT)).add(\"modifier\", StringUtils.modifier(field.getModifiers(), ',')).add(\"type\", StringUtils.classname(field.getType())).add(\"name\", field.getName());\n                final StringBuilder annotationSB = new StringBuilder();\n                final Annotation[] annotationArray = field.getAnnotations();\n                if (null != annotationArray && annotationArray.length > 0) {\n                    for (Annotation annotation : annotationArray) {\n                        annotationSB.append(StringUtils.classname(annotation.annotationType())).append(\",\");\n                    }\n\n                    if (annotationSB.length()> 0) {\n                        annotationSB.deleteCharAt(annotationSB.length() - 1);\n                    }\n                    kvView.add(\"annotation\", annotationSB);\n                }\n\n                if (Modifier.isStatic(field.getModifiers())) {\n                    final boolean isAccessible = field.isAccessible();\n\n                    try {\n                        field.setAccessible(true);\n                        kvView.add(\"value\", StringUtils.objectToString(field.get(null)));\n                    } catch (IllegalAccessException e) {\n                        //\n                    }\n\n                    finally {\n                            field.setAccessible(isAccessible);\n                    }\n                }//if\n                fieldSB.append(kvView.draw()).append(\"\\n\");\n            }//for\n        }\n        return fieldSB.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "57", "src_id": "M1439", "code": "\n    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete) {\n        if (ObjectUtils.isEmpty(array)) {\n            return null;\n        } else {\n            Properties result = new Properties();\n            String [] var4 = array;\n            int var5 = array.length;\n\n            for (int var6 = 0;var6 <var5;\n            ++ var6) {\n                String element = var4[var6];\n                if (charsToDelete != null) {\n                    element = deleteAny(element, charsToDelete);\n                }\n\n                String [] splittedElement = split(element, delimiter);\n                if (splittedElement != null) {\n                    result.setProperty(splittedElement[ 0].trim(), splittedElement[ 1].trim());\n                }\n            }\n            return result;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "58", "src_id": "M47", "code": "\n    private static long findProcessByTelnetClient(String arthasHomeDir, int telnetPort) {\n        // start java telnet client\n    List<String> telnetArgs = new ArrayList<String>();\n    telnetArgs.add(\"-c\");\n    telnetArgs.add(\"session\");\n    telnetArgs.add(\"--execution-timeout\");\n    telnetArgs.add(\"2000\");\n        // telnet port ,ip\n    telnetArgs.add(\"127.0.0.1\");\n    telnetArgs.add(\"\" + telnetPort);\n    try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n        String error = null;\n        int status = ProcessUtils.startArthasClient(arthasHomeDir, telnetArgs, out);\n        if (status == STATUS_EXEC_TIMEOUT) {\n            error = \"detection timeout\";\n        } else if (status == STATUS_EXEC_ERROR) {\n                   error = \"detection error\";\n                   AnsiLog.error(\"process status: {}\", status);\n                   AnsiLog.error(\"process output: {}\", out.toString());\n               } else {\n                // ignore connect error\n               }\n\n        if (error != null) {\n            AnsiLog.error(\"The telnet port {} is used, but process {}, you will connect to an unexpected process.\", telnetPort, error);\n            AnsiLog.error(\"Try to use a different telnet port, for example: java -jar arthas-boot.jar --telnet-port 9998 --http-port -1\");\n            System.exit(1);\n        }\n\n            //parse output, find java pid\n\n\n        String output = out.toString(\"UTF-8\");\n        String javaPidLine = null;\n        Scanner scanner = new Scanner(output);\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.contains(\"JAVA_PID\")) {\n                javaPidLine = line;\n                break;\n            }\n        }\n\n        if (javaPidLine != null) {\n                // JAVA_PID    10473\n            try {\n                String[] strs = javaPidLine.split(\"JAVA_PID\");\n                if (strs.length > 1) {\n                    return Long.parseLong(strs[strs.length - 1].trim());\n                }\n            } catch (NumberFormatException e) {\n                    // ignore\n\n            }\n        }\n    } catch (Throwable ex) {\n        AnsiLog.error(\"Detection telnet port error\");\n        AnsiLog.error(ex);\n    }\n    return - 1;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "59", "src_id": "M475", "code": "\n    @ Override public void draw(CommandProcess process, JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n    String group = entry.getKey();\n    List<JvmItemVO> items = entry.getValue();\n    table.row(true, label(group).style(Decoration.bold.bold()));\n    for (JvmItemVO item : items) {\n    String valueStr;\n    if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n        valueStr = renderMemoryUsage((Map<String, Object>)item.getValue());\n    } else {\n        valueStr = renderItemValue(item.getValue());\n    }\n\n    if (item.getDesc() != null) {\n        table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n    } else {\n        table.row(item.getName(), valueStr);\n    }\n    }\n    table.row(\"\", \"\");\n    }\n    process.write(RenderUtil.render(table, process.width()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "60", "src_id": "M1131", "code": "\n    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<String, Object>();\n    body.put(\"command\", commandLine);\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId()).setBody(body);\n    if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n        return response;\n    }\n\n\n    int lock = session.getLock();\n    try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n            logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n            return response;\n        }\n\n            //create job\n\n\n        Job job = this.createJob(commandLine, session, session.getResultDistributor());\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        response.setState(ApiState.SCHEDULED);\n\n            //add command before exec job\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n        commandRequestModel.setJobId(job.id());\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) {\n            resultDistributor.appendResult(commandRequestModel);\n        }\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n            //run job\n        job.run();\n        return response;\n    } catch (Throwable e) {\n        logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n        session.getResultDistributor().appendResult(commandRequestModel);\n        return response;\n    } finally {\n        if (session.getLock() == lock) {\n            session.unLock();\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "61", "src_id": "M493", "code": "\n    private void renderNode(StringBuilder sb, TraceNode node, Ansi highlighted) {\n        //render cost: [0.366865ms]\n    if (isPrintCost && node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode)node;\n        String costStr = renderCost(methodNode);\n        if (node == maxCostNode) {\n                // the node with max cost will be highlighted\n            sb.append(highlighted.a(costStr).reset().toString());\n        } else {\n            sb.append(costStr);\n        }\n    }\n\n        //render method name\n\n    if (node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode)node;\n            //clazz.getName() + \":\" + method.getName() + \"()\"\n        sb.append(methodNode.getClassName()).append(\":\").append(methodNode.getMethodName()).append(\"()\");\n            // #lineNumber\n        if (methodNode.getLineNumber() != - 1) {\n            sb.append(\" #\").append(methodNode.getLineNumber());\n        }\n    } else if (node instanceof ThreadNode) {\n            //render thread info\n               ThreadNode threadNode = (ThreadNode)node;\n            //ts=2020-04-29 10:34:00;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@18b4aac2\n               sb.append(format(\"ts=%s;thread_name=%s;id=%d;is_daemon=%s;priority=%d;TCCL=%s\", DateUtils.formatDateTime(threadNode.getTimestamp()), threadNode.getThreadName(), threadNode.getThreadId(), threadNode.isDaemon(), threadNode.getPriority(), threadNode.getClassloader()));\n\n            //trace_id\n               if (threadNode.getTraceId() != null) {\n                   sb.append(\";trace_id=\").append(threadNode.getTraceId());\n               }\n\n               if (threadNode.getRpcId() != null) {\n                   sb.append(\";rpc_id=\").append(threadNode.getRpcId());\n               }\n           } else if (node instanceof ThrowNode) {\n                      ThrowNode throwNode = (ThrowNode)node;\n                      sb.append(\"throw:\").append(throwNode.getException()).append(\" #\").append(throwNode.getLineNumber()).append(\" [\").append(throwNode.getMessage()).append(\"]\");\n                  } else {\n                      throw new UnsupportedOperationException(\"unknown trace node: \" + node.getClass());\n                  }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "62", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n    Map<String, Object> info = entry.getValue();\n    TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n    TableElement appendersTable = new TableElement().rightCellPadding(1);\n    Class<?> clazz = (Class<?>)info.get(LoggerHelper.clazz);\n    table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name))).row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName())).row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n    if (info.get(LoggerHelper.effectiveLevel) != null) {\n        table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n    }\n\n    if (info.get(LoggerHelper.config) != null) {\n        table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n    }\n    table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n    @ SuppressWarnings(\"unchecked\") List<Map<String, Object>> appenders = (List<Map<String, Object>>)info.get(LoggerHelper.appenders);\n    if (appenders != null && !appenders.isEmpty()) {\n        for (Map<String, Object> appenderInfo : appenders) {\n        Class<?> appenderClass = (Class<?>)appenderInfo.get(LoggerHelper.clazz);\n        appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n        appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n        appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n        appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n        if (appenderInfo.get(LoggerHelper.file) != null) {\n            appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n        }\n\n        if (appenderInfo.get(LoggerHelper.target) != null) {\n            appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n        }\n\n        if (appenderInfo.get(LoggerHelper.blocking) != null) {\n            appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n        }\n\n        if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n            appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n        }\n        }\n        table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n    }\n    sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "63", "src_id": "M529", "code": "\n    @ Override public void draw(CommandProcess process, MonitorModel result) {\n    TableElement table = new TableElement(2, 3, 3, 1, 1, 1, 1, 1).leftCellPadding(1).rightCellPadding(1);\n    table.row(true, label(\"timestamp\").style(Decoration.bold.bold()), label(\"class\").style(Decoration.bold.bold()), label(\"method\").style(Decoration.bold.bold()), label(\"total\").style(Decoration.bold.bold()), label(\"success\").style(Decoration.bold.bold()), label(\"fail\").style(Decoration.bold.bold()), label(\"avg-rt(ms)\").style(Decoration.bold.bold()), label(\"fail-rate\").style(Decoration.bold.bold()));\n    final DecimalFormat df = new DecimalFormat(\"0.00\");\n    for (MonitorData data : result.getMonitorDataList()) {\n    table.row(DateUtils.formatDateTime(data.getTimestamp()), data.getClassName(), data.getMethodName(), \"\" + data.getTotal(), \"\" + data.getSuccess(), \"\" + data.getFailed(), df.format(div(data.getCost(), data.getTotal())), df.format(100.0d*div(data.getFailed(), data.getTotal())) + \"%\");\n    }\n    process.write(RenderUtil.render(table, process.width()) + \"\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "64", "src_id": "M381", "code": "\n    @ Override public List<ResultModel> pollResults() {\n    try {\n        lastAccessTime = System.currentTimeMillis();\n        long accessTime = lastAccessTime;\n        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n            polling = true;\n            sendingItemCount = 0;\n            long firstResultTime = 0;\n                // sending delay: time elapsed after firstResultTime\n            long sendingDelay = 0;\n                // waiting time: time elapsed after access\n            long waitingTime = 0;\n            List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n            while (!closed && sendingResults.size() < resultBatchSizeLimit && sendingDelay < 100 && waitingTime < pollTimeLimit) {\n                ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (aResult != null) {\n                    sendingResults.add(aResult);\n                        //是否为第一次获取到数据\n                    if (firstResultTime == 0) {\n                        firstResultTime = System.currentTimeMillis();\n                    }\n                        //判断是否需要立即发送出去\n\n                    if (shouldFlush(sendingResults, aResult)) {\n                        break;\n                    }\n                } else {\n                    if (firstResultTime > 0) {\n                            //获取到部分数据后，队列已经取完，计算发送延时时间\n                        sendingDelay = System.currentTimeMillis() - firstResultTime;\n                    }\n                        //计算总共等待时间，长轮询最大等待时间\n                    waitingTime = System.currentTimeMillis() - accessTime;\n                }\n            }\n\n                //resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n            }\n            return sendingResults;\n        }\n    } catch (InterruptedException e) {\n            //e.printStackTrace();\n\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lastAccessTime = System.currentTimeMillis();\n            polling = false;\n            lock.unlock();\n        }\n    }\n    return Collections.emptyList();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "65", "src_id": "M1199", "code": "\n    private void initializeSlotsCache(Set < HostAndPort > startNodes, JedisClientConfig clientConfig) {\n        if (startNodes.isEmpty()) {\n            throw new JedisClusterOperationException(\"No nodes to initialize cluster slots cache.\");\n        }\n\n        ArrayList < HostAndPort > startNodeList = new ArrayList < >(startNodes);\n        Collections.shuffle(startNodeList);\n        JedisException firstException = null;\n\n        for(HostAndPort hostAndPort : startNodeList) {\n            try (Connection jedis = new Connection(hostAndPort, clientConfig)) {\n                cache.discoverClusterNodesAndSlots(jedis);\n                return;\n            }\n\n                catch(JedisException e) {\n                if (firstException == null) {\n                    firstException = e;\n                }\n        // try next nodes\n            }\n        }\n\n        if (System.getProperty(INIT_NO_ERROR_PROPERTY) != null) {\n            return;\n        }\n\n        JedisClusterOperationException uninitializedException = new JedisClusterOperationException(\"Could not initialize cluster slots cache.\");\n        uninitializedException.addSuppressed(firstException);\n        throw uninitializedException;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "66", "src_id": "M1275", "code": "\n    @Override public Document build(Object data) {\n        List < KeyValue > list = (List < KeyValue >) data;\n        String id = null;\n        Double score = null;\n        Map<String, Object> fields = null;\n\n        for(KeyValue kv : list) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n\n            switch (key) {\n                case ID_STR:\n                    id = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case SCORE_STR:\n                    score = BuilderFactory.DOUBLE.build(kv.getValue());\n                    break;\n                case FIELDS_STR:\n                    fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                    break;\n            }\n        }\n\n        return new Document(id, score, fields);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "67", "src_id": "M933", "code": "\n    @Deprecated public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n        Builder builder = builder();\n        builder.protocol(copy.getRedisProtocol());\n        builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n        builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n        builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n        Supplier < RedisCredentials > credentialsProvider = copy.getCredentialsProvider();\n\n        if (credentialsProvider != null) {\n            builder.credentialsProvider(credentialsProvider);\n        } else {\n            builder.user(copy.getUser());\n            builder.password(copy.getPassword());\n        }\n\n        builder.database(copy.getDatabase());\n        builder.clientName(copy.getClientName());\n        builder.ssl(copy.isSsl());\n        builder.sslSocketFactory(copy.getSslSocketFactory());\n        builder.sslParameters(copy.getSslParameters());\n        builder.hostnameVerifier(copy.getHostnameVerifier());\n        builder.sslOptions(copy.getSslOptions());\n        builder.hostAndPortMapper(copy.getHostAndPortMapper());\n        builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n        if (copy.isReadOnlyForRedisClusterReplicas()) {\n            builder.readOnlyForRedisClusterReplicas();\n        }\n\n        builder.authXManager(copy.getAuthXManager());\n        return builder.build();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "68", "src_id": "M1159", "code": "\n    @Override public LibraryInfo build(Object data) {\n        if (data == null) return null;\n        List list = (List) data;\n\n        if (list.isEmpty()) return null;\n        if (list.get(0) instanceof KeyValue) {\n            String libname = null, enginename = null, librarycode = null;\n            List < Map<String, Object>> functions = null;\n\n            for(KeyValue kv : (List < KeyValue >) list) {\n                switch (BuilderFactory.STRING.build(kv.getKey())) {\n                    case \"library_name\":\n                        libname = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"engine\":\n                        enginename = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"functions\":\n                        functions = ((List < Object >) kv.getValue()).stream().map(o-> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n                        break;\n                    case \"library_code\":\n                        librarycode = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                }\n            }\n\n            return new LibraryInfo(libname, enginename, functions, librarycode);\n        }\n\n        String libname = STRING.build(list.get(1));\n        String engine = STRING.build(list.get(3));\n        List < Object > rawFunctions = (List < Object >) list.get(5);\n        List < Map<String, Object>> functions = rawFunctions.stream().map(o-> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n\n        if (list.size() <= 6) {\n            return new LibraryInfo(libname, engine, functions);\n        }\n\n        String code = STRING.build(list.get(7));\n        return new LibraryInfo(libname, engine, functions, code);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1219", "code": "\n    @Override public void run() {\n        running.set(true);\n        while (running.get()) {\n            try {\n          // double check that it is not being shutdown\n                if (!running.get()) {\n                    break;\n                }\n\n                sentinelJedis = new Jedis(node, sentinelClientConfig);\n\n          // code for active refresh\n                List < String > masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n\n                if (masterAddr == null || masterAddr.size() != 2) {\n                    LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n                } else {\n                    initMaster(toHostAndPort(masterAddr));\n                }\n\n                sentinelJedis.subscribe(new JedisPubSub() {\n                                            @Override public void onMessage(String channel, String message) {\n                                                LOG.debug(\"Sentinel {} published: {}.\", node, message);\n                                                String [] switchMasterMsg = message.split(\" \");\n\n                                                if (switchMasterMsg.length > 3) {\n                                                    if (masterName.equals(switchMasterMsg[0])) {\n                                                        initMaster(toHostAndPort(switchMasterMsg[3], switchMasterMsg[4]));\n                                                    } else {\n                                                        LOG.debug(\"Ignoring message on +switch-master for master {}. Our master is {}.\", switchMasterMsg[0], masterName);\n                                                    }\n                                                } else {\n                                                    LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\", node, message);\n                                                }\n                                            }\n\n                                        }, \"+switch-master\");\n            }\n\n                catch(JedisException e) {\n                if (running.get()) {\n                    LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node, subscribeRetryWaitTimeMillis, e);\n                    try {\n                        Thread.sleep(subscribeRetryWaitTimeMillis);\n                    }\n\n                    catch(InterruptedException se) {\n                        LOG.error(\"Sleep interrupted.\", se);\n                    }\n                } else {\n                    LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n                }\n            }\n\n                finally {\n                IOUtils.closeQuietly(sentinelJedis);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "70", "src_id": "M126", "code": "\n    @Override public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof CommandObject)) {\n            return false;\n        }\n\n        Iterator < Rawable > e1 = arguments.iterator();\n        Iterator < Rawable > e2 = ((CommandObject) o).arguments.iterator();\n\n        while (e1.hasNext() && e2.hasNext()) {\n            Rawable o1 = e1.next();\n            Rawable o2 = e2.next();\n\n            if (!(o1 == null ? o2 == null : o1.equals(o2))) {\n                return false;\n            }\n        }\n\n        if (e1.hasNext() || e2.hasNext()) {\n            return false;\n        }\n\n        return builder == ((CommandObject) o).builder;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "71", "src_id": "M44", "code": "\n    @Override public String discard() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"DISCARD without MULTI\");\n        }\n\n        try {\n      // processPipelinedResponses(pipelinedResponses.size());\n      // do nothing\n            connection.sendCommand(DISCARD);\n            String status = connection.getStatusCodeReply();\n\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n\n            return status;\n        }\n\n        catch(JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        }\n\nfinally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1213", "code": "\n    @Override public Connection getConnection() {\n        List < ConnectionPool > pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n\n        for(ConnectionPool pool : pools) {\n            Connection jedis = null;\n\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n\n                jedis.ping();\n                return jedis;\n            }\n\n            catch(JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n\n        throw noReachableNode;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "73", "src_id": "M934", "code": "\n    private Socket createSslSocket(HostAndPort _hostAndPort, Socket socket) throws IOException, GeneralSecurityException {\n        Socket plainSocket = socket;\n        SSLSocketFactory _sslSocketFactory;\n        SSLParameters _sslParameters;\n\n        if (sslOptions != null) {\n            SSLContext _sslContext = sslOptions.createSslContext();\n            _sslSocketFactory = _sslContext.getSocketFactory();\n            _sslParameters = sslOptions.getSslParameters();\n        } else {\n            _sslSocketFactory = this.sslSocketFactory;\n            _sslParameters = this.sslParameters;\n        }\n\n        if (_sslSocketFactory == null) {\n            _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n\n        SSLSocket sslSocket = (SSLSocket) _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (_sslParameters != null) {\n            sslSocket.setSSLParameters(_sslParameters);\n        }\n\n    // allowing HostnameVerifier for both SslOptions and legacy ssl config\n\n        if (hostnameVerifier != null && !hostnameVerifier.verify(_hostAndPort.getHost(), sslSocket.getSession())) {\n            String message = String.format(\"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n\n            throw new JedisConnectionException(message);\n        }\n\n        return new SSLSocketWrapper(sslSocket, plainSocket);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "74", "src_id": "M1216", "code": "\n    private void initMaster(HostAndPort master) {\n        initPoolLock.lock();\n        try {\n            if (!master.equals(currentMaster)) {\n                currentMaster = master;\n                ConnectionPool newPool = createNodePool(currentMaster);\n                ConnectionPool existingPool = pool;\n                pool = newPool;\n                LOG.info(\"Created connection pool to master at {}.\", master);\n                if (clientSideCache != null) {\n                    clientSideCache.flush();\n                }\n\n                if (existingPool != null) {\n          // although we clear the pool, we still have to check the returned object in getResource,\n          // this call only clears idle instances, not borrowed instances\n          // existingPool.clear(); // necessary??\n                    existingPool.close();\n                }\n            }\n        }\n\n        finally {\n            initPoolLock.unlock();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1275", "code": "\n    @Override public\n    Document build(Object data) {\n        List<KeyValue> list = (List<KeyValue>)data;\n        String id = null;\n        Double score = null;\n        Map<String, Object> fields = null;\n\n        for(KeyValue kv :list) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n\n            switch(key) {\n                        case ID_STR:\n                id = BuilderFactory.STRING.build(kv.getValue());\n                break;\n                        case SCORE_STR:\n                score = BuilderFactory.DOUBLE.build(kv.getValue());\n                break;\n                        case FIELDS_STR:\n                fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                break;\n            }\n        }\n\n        return new Document(id, score, fields);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "76", "src_id": "M889", "code": "\n    @Override public void addParams(CommandArguments args) {\n        if (timestamp != null) {\n            args.add(TIMESTAMP).add(timestamp);\n        }\n\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff ).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)-> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1141", "code": "\n    @Override public final<T> T executeCommand(CommandObject<T> commandObject) {\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration );\n        int consecutiveConnectionFailures = 0;\n        JedisException lastException = null;\n\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft --) {\n            Connection connection = null;\n\n            try {\n                connection = provider.getConnection(commandObject.getArguments());\n                return execute(connection, commandObject);\n            } catch (JedisConnectionException jce) {\n                lastException = jce;\n                ++ consecutiveConnectionFailures;\n                log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n                if (reset) {\n                    consecutiveConnectionFailures = 0;\n                }\n            }\n\nfinally {\n                if (connection != null) {\n                    connection.close();\n                }\n            }\n\n            if (Instant.now().isAfter(deadline )) {\n                throw new JedisException(\"Retry deadline exceeded.\");\n            }\n        }\n\n        JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n        maxAttemptsException.addSuppressed(lastException);\n        throw maxAttemptsException;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "78", "src_id": "M1057", "code": "\n    @Override public\n    Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List)data;\n        if (list == null || list.isEmpty()) return null;\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n\n            for(KeyValue keyValue :(List<KeyValue>)data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n\n                switch(keyStr) {\n                               case PROFILE_STR_REDIS7: case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                               case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                               case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n                }\n            }\n\n            assert resultsData != null: \"Could not detect Results data.\";\n            assert profileData != null: \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "79", "src_id": "M1102", "code": "\n    @Override public final\n    List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"EXEC without MULTI\");\n        }\n\n        try (Connection connection = failoverProvider.getConnection()) {\n            commands.forEach((command)-> connection.sendCommand(command.getKey()));\n      // following connection.getMany(int) flushes anyway, so no flush here.\n\n      // ignore QUEUED (or ERROR)\n            connection.getMany(commands.size());\n\n      // remove extra response builders\n            for (int idx = 0; idx < extraCommandCount.get(); ++idx) {\n                commands.poll();\n            }\n\n            connection.sendCommand(EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                commands.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size()- extraCommandCount.get());\n\n            for(Object rawReply :unformatted) {\n                try {\n                    Response<?> response = commands.poll().getValue();\n                    response.set(rawReply);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n\n            return formatted;\n        }\n\n            finally {\n            inMulti = false;\n            inWatch = false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "80", "src_id": "M1304", "code": "\n    @Override public\n    AggregationResult build(Object data) {\n      // return new AggregationResult(data);\n        List list = (List)data;\n        if (list.get(0) instanceof KeyValue) {\n            List<KeyValue> kvList = (List<KeyValue>)data;\n            long totalResults = -1;\n            List<Map<String, Object>> results = null;\n            List<String> warnings = null;\n\n            for(KeyValue kv :kvList) {\n                String key = BuilderFactory.STRING.build(kv.getKey());\n                Object rawVal = kv.getValue();\n\n                switch(key) {\n                            case TOTAL_RESULTS_STR:\n                    totalResults = BuilderFactory.LONG.build(rawVal);\n                    break;\n                            case RESULTS_STR:\n                    List<List<KeyValue>> resList = (List<List<KeyValue>>)rawVal;\n                    results = new ArrayList<>(resList.size());\n                    for(List<KeyValue> rikv :resList) {\n                        for(KeyValue ikv :rikv) {\n                            if (FIELDS_STR.equals(BuilderFactory.STRING.build(ikv.getKey()))) {\n                                results.add(BuilderFactory.ENCODED_OBJECT_MAP.build(ikv.getValue()));\n                                break;\n                            }\n                        }\n                    }\n\n                    break;\n                            case WARNINGS_STR:\n                    warnings = BuilderFactory.STRING_LIST.build(rawVal);\n                    break;\n                }\n            }\n\n            return new AggregationResult(totalResults, results, warnings);\n        }\n\n        list = (List<Object>)SafeEncoder.encodeObject(data);\n\n      // the first element is always the number of results\n\n        long totalResults = (Long)list.get(0);\n        List<Map<String, Object>> results = new ArrayList<>(list.size()- 1);\n\n        for (int i = 1; i < list.size(); i++) {\n            List<Object> mapList = (List<Object>)list.get(i);\n            Map<String, Object> map = new HashMap<>(mapList.size()/2, 1f);\n\n            for (int j = 0; j < mapList.size(); j += 2) {\n                Object r = mapList.get(j);\n                if (r instanceof JedisDataException) {\n                    throw(JedisDataException)r;\n                }\n\n                map.put((String)r, mapList.get(j + 1));\n            }\n\n            results.add(map);\n        }\n\n        return new AggregationResult(totalResults, results);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "81", "src_id": "M1219", "code": "\n    @Override public void run() {\n        running.set(true);\n        while (running.get()) {\n            try {\n          // double check that it is not being shutdown\n                if (!running.get()) {\n                    break;\n                }\n\n                sentinelJedis = new Jedis(node, sentinelClientConfig);\n\n          // code for active refresh\n                List<String> masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n                if (masterAddr == null || masterAddr.size() != 2) {\n                    LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n                } else {\n                    initMaster(toHostAndPort(masterAddr));\n                }\n\n                sentinelJedis.subscribe(new JedisPubSub() {\n                                            @Override public void onMessage(String channel , String message) {\n                                                LOG.debug(\"Sentinel {} published: {}.\", node, message);\n                                                String [] switchMasterMsg = message.split(\" \");\n                                                if (switchMasterMsg.length > 3) {\n                                                    if (masterName.equals(switchMasterMsg[0])) {\n                                                        initMaster(toHostAndPort(switchMasterMsg[3], switchMasterMsg[4]));\n                                                    } else {\n                                                        LOG.debug(\"Ignoring message on +switch-master for master {}. Our master is {}.\", switchMasterMsg[0], masterName);\n                                                    }\n                                                } else {\n                                                    LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\", node, message);\n                                                }\n                                            }\n\n                                        }, \"+switch-master\");\n            } catch (JedisException e) {\n                if (running.get()) {\n                    LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node, subscribeRetryWaitTimeMillis, e);\n                    try {\n                        Thread.sleep(subscribeRetryWaitTimeMillis);\n                    } catch (InterruptedException se) {\n                        LOG.error(\"Sleep interrupted.\", se);\n                    }\n                } else {\n                    LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n                }\n            }\n\n                finally {\n                IOUtils.closeQuietly(sentinelJedis);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "82", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\") public\n    Map<byte [], byte []> build(Object data) {\n        final List<Object> list = (List<Object>)data;\n        if (list.isEmpty()) return Collections.emptyMap();\n        if (list.get(0) instanceof KeyValue) {\n            final Map<byte [], byte []> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue)iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n\n            return map;\n        } else {\n            final Map<byte [], byte []> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n\n            return map;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "83", "src_id": "M1346", "code": "\n    @Override public\n    Map<String, Map<String, Double>> build(Object data) {\n        List rawDataList = (List)data;\n        if (rawDataList.isEmpty()) return Collections.emptyMap();\n        if (rawDataList.get(0) instanceof KeyValue) {\n            KeyValue rawData = (KeyValue)rawDataList.get(0);\n            String header = STRING.build(rawData.getKey());\n            if (!RESULTS.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n\n            return((List<KeyValue>)rawData.getValue()).stream().collect(Collectors.toMap(rawTerm -> STRING.build(rawTerm.getKey()), rawTerm -> ((List<List<KeyValue>>)rawTerm.getValue()).stream().collect(Collectors.toMap(entry -> STRING.build(entry.get(0).getKey()), entry -> BuilderFactory.DOUBLE.build(entry.get(0).getValue()))), (x , y)-> x, LinkedHashMap ::new));\n        }\n\n        Map<String, Map<String, Double>> returnTerms = new LinkedHashMap<>(rawDataList.size());\n\n        for(Object rawData :rawDataList) {\n            List<Object> rawElements = (List<Object>)rawData;\n            String header = STRING.build(rawElements.get(0));\n            if (!TERM.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n\n            String term = STRING.build(rawElements.get(1));\n            List<List<Object>> list = (List<List<Object>>)rawElements.get(2);\n            Map<String, Double> entries = new LinkedHashMap<>(list.size());\n            list.forEach(entry -> entries.put(STRING.build(entry.get(1)), BuilderFactory.DOUBLE.build(entry.get(0))));\n            returnTerms.put(term, entries);\n        }\n\n        return returnTerms;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "84", "src_id": "M51", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\") public\n    Map<String, String> build(Object data) {\n        final List<Object> list = (List<Object>)data;\n        if (list.isEmpty()) return Collections.emptyMap();\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, String> map = new HashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue)iterator.next();\n                map.put(STRING.build(kv.getKey()), STRING.build(kv.getValue()));\n            }\n\n            return map;\n        } else {\n            final Map<String, String> map = new HashMap<>(list.size()/2, 1f);\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), STRING.build(iterator.next()));\n            }\n\n            return map;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "85", "src_id": "M1108", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "86", "src_id": "M1275", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "87", "src_id": "M1159", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "88", "src_id": "M934", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "89", "src_id": "M1304", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "90", "src_id": "M959", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "91", "src_id": "M1145", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "92", "src_id": "M52", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "93", "src_id": "M34", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "94", "src_id": "M28", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "95", "src_id": "M1009", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "96", "src_id": "M87", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "97", "src_id": "M454", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "98", "src_id": "M114", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "99", "src_id": "M716", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "100", "src_id": "M566", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "101", "src_id": "M443", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "102", "src_id": "M270", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "103", "src_id": "M232", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "104", "src_id": "M1354", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "105", "src_id": "M902", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry)->args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "106", "src_id": "M1277", "code": "\n    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap< >(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null||obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n\n            String str;\n            if (obj instanceof byte[]) {\n                str = SafeEncoder.encode((byte[]) obj);\n            } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                       redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                       str = geo.getLongitude() + \",\" + geo.getLatitude();\n            } else if (obj instanceof String) {\n                       str = stringEscape?escape((String) obj): (String) obj;\n                   } else {\n                       str = String.valueOf(obj);\n                   }\n\n            output.put(key, str);\n        }\n        return output;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "107", "src_id": "M1197", "code": "\n    public final B nextBatch() {\n        if (roundRobinCompleted) {\n            throw new NoSuchElementException();\n        }\n\n        CommandArguments args;\n        if (iterationCompleted) {\n            connection = connections.poll();\n            args = initCommandArguments();\n        } else {\n            args = nextCommandArguments(lastReply);\n        }\n\n        Object rawReply;\n        if (connection.getValue() instanceof Connection) {\n            rawReply = ((Connection) connection.getValue()).executeCommand(args);\n        } else if (connection.getValue() instanceof Pool) {\n                   try (Connection c = ((Pool<Connection>) connection.getValue()).getResource()) {\n                       rawReply = c.executeCommand(args);\n                   }\n        } else {\n            throw new IllegalArgumentException(connection.getValue().getClass() + \"is not supported.\");\n        }\n\n        lastReply = builder.build(rawReply);\n        iterationCompleted = isNodeCompleted(lastReply);\n        if (iterationCompleted) {\n            if (connections.isEmpty()) {\n                roundRobinCompleted = true;\n            }\n        }\n        return lastReply;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "108", "src_id": "M1251", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        args.addParams(fieldName);\n        args.add(TEXT);\n        if (indexMissing) {\n            args.add(INDEXMISSING);\n        }\n        if (indexEmpty) {\n            args.add(INDEXEMPTY);\n        }\n        if (weight != null) {\n            args.add(WEIGHT).add(weight);\n        }\n        if (noStem) {\n            args.add(NOSTEM);\n        }\n        if (phoneticMatcher != null) {\n            args.add(PHONETIC).add(phoneticMatcher);\n        }\n        if (withSuffixTrie) {\n            args.add(WITHSUFFIXTRIE);\n        }\n        if (sortableUNF) {\n            args.add(SORTABLE).add(UNF);\n        } else if (sortable) {\n                   args.add(SORTABLE);\n               }\n        if (noIndex) {\n            args.add(NOINDEX);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "109", "src_id": "M873", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (fromTimestamp == null) {\n            args.add(MINUS);\n        } else {\n            args.add(toByteArray(fromTimestamp));\n        }\n        if (toTimestamp == null) {\n            args.add(PLUS);\n        } else {\n            args.add(toByteArray(toTimestamp));\n        }\n        if (latest) {\n            args.add(LATEST);\n        }\n        if (filterByTimestamps != null) {\n            args.add(FILTER_BY_TS);\n            for ( long ts : filterByTimestamps) {\n                args.add(toByteArray(ts));\n            }\n        }\n        if (filterByValues != null) {\n            args.add(FILTER_BY_VALUE);\n            for ( double value : filterByValues) {\n                args.add(toByteArray(value));\n            }\n        }\n        if (count != null) {\n            args.add(COUNT).add(toByteArray(count));\n        }\n        if (aggregationType != null) {\n            if (align != null) {\n                args.add(ALIGN).add(align);\n            }\n\n            args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n            if (bucketTimestamp != null) {\n                args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n            }\n            if (empty) {\n                args.add(EMPTY);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "110", "src_id": "M1349", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (dataType != null) {\n            args.add(ON).add(dataType);\n        }\n        if (prefix != null) {\n            args.add(PREFIX).add(prefix.size()).addObjects(prefix);\n        }\n        if (filter != null) {\n            args.add(FILTER).add(filter);\n        }\n        if (language != null) {\n            args.add(LANGUAGE).add(language);\n        }\n        if (languageField != null) {\n            args.add(LANGUAGE_FIELD).add(languageField);\n        }\n        if (score != null) {\n            args.add(SCORE).add(score);\n        }\n        if (scoreField != null) {\n            args.add(SCORE_FIELD).add(scoreField);\n        }\n        if (maxTextFields) {\n            args.add(MAXTEXTFIELDS);\n        }\n        if (noOffsets) {\n            args.add(NOOFFSETS);\n        }\n        if (temporary != null) {\n            args.add(TEMPORARY).add(temporary);\n        }\n        if (noHL) {\n            args.add(NOHL);\n        }\n        if (noFields) {\n            args.add(NOFIELDS);\n        }\n        if (noFreqs) {\n            args.add(NOFREQS);\n        }\n        if (stopwords != null) {\n            args.add(STOPWORDS).add(stopwords.size());\n            stopwords.forEach(w->args.add(w));\n        }\n        if (skipInitialScan) {\n            args.add(SKIPINITIALSCAN);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "111", "src_id": "M55", "code": "\n    @Override @SuppressWarnings(\"unchecked\")\n    public Map<String, Long> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) return Collections.emptyMap();\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, Long> map = new LinkedHashMap< >(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while(iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<String, Long> map = new LinkedHashMap< >(list.size()/2, 1f);\n            final Iterator iterator = list.iterator();\n            while(iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "112", "src_id": "M1351", "code": "\n    @Override\n    public SearchResult build(Object data) {\n        List<Object> resp = (List<Object>) data;\n        int step = 1;\n        int scoreOffset = 0;\n        int contentOffset = 1;\n        if (hasScores) {\n            step +=1;\n            scoreOffset = 1;\n            contentOffset +=1;\n        }\n        if (hasContent) {\n            step +=1;\n        }\n\n      // the first element is always the number of results\n\n        long totalResults = (Long) resp.get(0);\n        List<Document> documents = new ArrayList< >(resp.size() - 1);\n        for(int i = 1;i < resp.size();\ni += step) {\n            String id = BuilderFactory.STRING.build(resp.get(i));\n            double score = hasScores?BuilderFactory.DOUBLE.build(resp.get(i + scoreOffset)): 1.0;\n            List<byte[]> fields = hasContent?(List<byte[]>) resp.get(i + contentOffset): null;\n            documents.add(Document.load(id, score, fields, decode, isFieldDecode));\n        }\n        return new SearchResult(totalResults, documents);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "113", "src_id": "M1298", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (type != null) {\n            args.add(SearchKeyword.ON.name());\n            args.add(type.name());\n        }\n        if (prefixes != null && prefixes.length > 0) {\n            args.add(SearchKeyword.PREFIX.name());\n            args.add(Integer.toString(prefixes.length));\n            args.addObjects((Object[]) prefixes);\n        }\n        if (filter != null) {\n            args.add(SearchKeyword.FILTER.name());\n            args.add(filter);\n        }\n        if (languageField != null) {\n            args.add(SearchKeyword.LANGUAGE_FIELD.name());\n            args.add(languageField);\n        }\n        if (language != null) {\n            args.add(SearchKeyword.LANGUAGE.name());\n            args.add(language);\n        }\n        if (scoreFiled != null) {\n            args.add(SearchKeyword.SCORE_FIELD.name());\n            args.add(scoreFiled);\n        }\n        if (score != 1.0) {\n            args.add(SearchKeyword.SCORE.name());\n            args.add(Double.toString(score));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1105", "code": "\n    @Override\n    public Class<?> build(Object data) {\n        if (data == null) return null;\n        String str = STRING.build(data);\n        switch(str) {\n            case \"null\":\n            return null;\n                    case \"boolean\":\n            return boolean.class;\n                    case \"integer\":\n            return int.class;\n                    case \"number\":\n            return float.class;\n                    case \"string\":\n            return String.class;\n                    case \"object\":\n            return Object.class;\n                    case \"array\":\n            return List.class;\n                    default:\n            throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "115", "src_id": "M9", "code": "\n    @Override\n    public CacheEntry set(CacheKey cacheKey,CacheEntry entry)\n    {\n        lock.lock();\n        try\n        {\n            entry = putIntoStore(cacheKey,\n                                 entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n\n            if (evictedKey != null)\n            {\n                delete(evictedKey);\n                stats.evict();\n            }\n\n            for(Object redisKey :cacheKey.getRedisKeys()\n            )\n            {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n\n                if (redisKeysToCacheKeys.containsKey(mapKey))\n                {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                }\n                else\n                {\n                    Set <CacheKey <\n                                      ?\n                                  >\n                        > set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(\n                        mapKey,\n                        set);\n                }\n            }\n\n            stats.load();\n            return entry;\n        }\n        finally\n            {\n                lock.unlock();\n            }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "116", "src_id": "M55", "code": "\n    @Override @SuppressWarnings(\"unchecked\")\n    public Map< String,\n                Long> build(Object data)\n    {\n        final List <Object> list = (List <Object>)data;\n\n        if (list.isEmpty())\n        return Collections.emptyMap();\n        if (list.get(0) instanceof KeyValue)\n        {\n            final Map< String,\n                       Long> map = new LinkedHashMap < >(list.size(),\n                                                         1f);\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext())\n            {\n                KeyValue kv = (KeyValue)iterator.next();\n                map.put(\n                    STRING.build(kv.getKey()),\n                    LONG.build(kv.getValue()));\n            }\n\n            return map;\n        }\n        else\n        {\n            final Map< String,\n                       Long> map = new LinkedHashMap < >(list.size()/ 2,\n                                                         1f);\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext())\n            {\n                map.put(\n                    STRING.build(iterator.next()),\n                    LONG.build(iterator.next()));\n            }\n\n            return map;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1145", "code": "\n    @Override\n    public\n    final\n    <\n        T >T broadcastCommand(CommandObject <T> commandObject) {\n                                                                   Map< String,\n                                                                        ConnectionPool> connectionMap = provider.getConnectionMap();\n                                                                   boolean isErrored = false;\n                                                                   T reply = null;\n                                                                   JedisBroadcastException bcastError = new JedisBroadcastException();\n\n                                                                   for(Map .Entry< String,\n                                                                                   ConnectionPool> entry :connectionMap.entrySet()\n                                                                   )\n                                                                   {\n                                                                       HostAndPort node = HostAndPort.from(entry.getKey());\n                                                                       ConnectionPool pool = entry.getValue();\n                                                                       try\n                                                                           (Connection connection = pool.getResource())\n                                                                           {\n                                                                               T aReply = execute(connection,\n                                                                                                  commandObject);\n                                                                               bcastError.addReply(\n                                                                                   node,\n                                                                                   aReply);\n                                                                               if (isErrored)\n                                                                               { // already errored\n                                                                               }\n                                                                               else\n                                                                               if (reply == null)\n                                                                               {\n                                                                                   reply = aReply; // ok\n                                                                               }\n                                                                               else\nif (reply.equals(aReply))\n{\n          // ok\n}\nelse\n{\n   isErrored = true;\n   reply = null;\n}\n                                                                           }\n                                                                           catch (Exception anError)\n                                                                           {\n                                                                               bcastError.addReply(\n                                                                                   node,\n                                                                                   anError);\n                                                                               isErrored = true;\n                                                                           }\n                                                                   }\n\n                                                                   if (isErrored)\n                                                                   {\n                                                                       throw bcastError;\n                                                                   }\n\n                                                                   return reply;\n                                                               }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1141", "code": "\n    @Override\n    public\n    final\n    <\n        T >T executeCommand(CommandObject <T> commandObject) {\n                                                                 Instant deadline = Instant.now()\n                                                                                        .plus(maxTotalRetriesDuration);\n                                                                 int consecutiveConnectionFailures = 0;\n                                                                 JedisException lastException = null;\n\n                                                                 for(int attemptsLeft = this\n                                                                                            .maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n                                                                                                                                                Connection connection = null;\n                                                                                                                                                try\n                                                                                                                                                {\n                                                                                                                                                    connection = provider.getConnection(commandObject.getArguments());\n                                                                                                                                                    return execute(connection,\n                                                                                                                                                                   commandObject);\n                                                                                                                                                }\n                                                                                                                                                catch (JedisConnectionException jce)\n                                                                                                                                                {\n                                                                                                                                                    lastException = jce;\n                                                                                                                                                    ++consecutiveConnectionFailures;\n                                                                                                                                                    log.debug(\n                                                                                                                                                        \"Failed connecting to Redis: {}\",\n                                                                                                                                                        connection,\n                                                                                                                                                        jce);\n        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                                                                                                                                                    boolean reset = handleConnectionProblem(attemptsLeft - 1,\n                                                                                                                                                                                            consecutiveConnectionFailures,\n                                                                                                                                                                                            deadline);\n\n                                                                                                                                                    if (reset)\n                                                                                                                                                    {\n                                                                                                                                                        consecutiveConnectionFailures = 0;\n                                                                                                                                                    }\n                                                                                                                                                }\n\n                                                                                                                                                finally\n                                                                                                                                                    {\n                                                                                                                                                        if (connection != null)\n                                                                                                                                                        {\n                                                                                                                                                            connection.close();\n                                                                                                                                                        }\n                                                                                                                                                    }\n\n                                                                                                                                                if (Instant.now()\n                                                                                                                                                        .isAfter(deadline))\n                                                                                                                                                {\n                                                                                                                                                    throw new JedisException(\"Retry deadline exceeded.\");\n                                                                                                                                                }\n                                                                 }\n\n                                                                 JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n                                                                 maxAttemptsException.addSuppressed(lastException);\n                                                                 throw maxAttemptsException;\n                                                             }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1346", "code": "\n    @Override\n    public Map< String,\n                Map< String,\n                     Double>> build(Object data)\n    {\n        List rawDataList = (List)data;\n\n        if (rawDataList.isEmpty())\n        return Collections.emptyMap();\n        if (rawDataList.get(0) instanceof KeyValue)\n        {\n            KeyValue rawData = (KeyValue)rawDataList.get(0);\n            String header = STRING.build(rawData.getKey());\n\n            if (!RESULTS.equals(header))\n            {\n                throw new IllegalStateException(\"Unrecognized header: \"\n                          + header);\n            }\n\n            return ((List <KeyValue>)rawData.getValue())\n                       .stream()\n.collect(Collectors.toMap(rawTerm->STRING.build(rawTerm.getKey()),\n                          rawTerm->((List <List <KeyValue>>)rawTerm.getValue())\n                                       .stream()\n.collect(Collectors.toMap(entry->STRING.build(entry.get(0)\n                                                  .getKey()),\n                          entry->BuilderFactory.DOUBLE.build(entry.get(0)\n                                                                 .getValue()))),\n                          (x,y)->x,LinkedHashMap::new));\n        }\n\n        Map< String,\n             Map< String,\n                  Double>> returnTerms = new LinkedHashMap < >(rawDataList.size());\n\n        for(Object rawData :rawDataList)\n        {\n            List <Object> rawElements = (List <Object>)rawData;\n            String header = STRING.build(rawElements.get(0));\n\n            if (!TERM.equals(header))\n            {\n                throw new IllegalStateException(\"Unrecognized header: \"\n                          + header);\n            }\n\n            String term = STRING.build(rawElements.get(1));\n            List <List <Object>> list = (List <List <Object>>)rawElements.get(2);\n            Map< String,\n                 Double> entries = new LinkedHashMap < >(list.size());\n            list.forEach(entry->entries.put(STRING.build(entry.get(1)),\n                                            BuilderFactory.DOUBLE.build(entry.get(0))));\n            returnTerms.put(\n                term,\n                entries);\n        }\n\n        return returnTerms;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "120", "src_id": "M1102", "code": "\n    @Override\n    public\n    final\n    List <Object> exec()\n    {\n        if (!inMulti)\n        {\n            throw new IllegalStateException(\"EXEC without MULTI\");\n        }\n\n        try\n            (Connection connection = failoverProvider.getConnection())\n            {\n                commands.forEach((command)->connection.sendCommand(command.getKey()));\n      // following connection.getMany(int) flushes anyway, so no flush here.\n\n      // ignore QUEUED (or ERROR)\n                connection.getMany(commands.size());\n\n      // remove extra response builders\n                for(int idx = 0; idx < extraCommandCount.get(); ++idx) {\n                                                                           commands.poll();\n                }\n\n                connection.sendCommand(EXEC);\n                List <Object> unformatted = connection.getObjectMultiBulkReply();\n\n                if (unformatted == null)\n                {\n                    commands.clear();\n                    return null;\n                }\n\n                List <Object> formatted = new ArrayList < >(unformatted.size() - extraCommandCount.get());\n\n                for(Object rawReply :unformatted)\n                {\n                    try\n                    {\n                        Response <\n                                     ?\n                                 > response = commands.poll()\n                                                  .getValue();\n                        response.set(rawReply);\n                        formatted.add(response.get());\n                    }\n                    catch (JedisDataException e)\n                    {\n                        formatted.add(e);\n                    }\n                }\n\n                return formatted;\n            }\n            finally\n            {\n                inMulti = false;\n                inWatch = false;\n            }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "121", "src_id": "M925", "code": "\n    private\n    void process()\n    {\n        do\n        {\n            Object reply = authenticator.client.getUnflushedObject();\n\n            if (reply instanceof List)\n            {\n                List <Object> listReply = (List <Object>)reply;\n                final Object firstObj = listReply.get(0);\n\n                if (!(firstObj instanceof byte[]))\n                {\n                    throw new JedisException(\"Unknown message type: \"\n                              + firstObj);\n                }\n\n                final byte[] resp = (byte[])firstObj;\n\n                if (Arrays.equals(SSUBSCRIBE.getRaw(),\n                                  resp))\n                {\n                    subscribedChannels = ((Long)listReply.get(2))\n                                             .intValue();\n                    final byte[] bchannel = (byte[])listReply.get(1);\n                    final T enchannel = (bchannel == null)?null:encode(bchannel);\n                    onSSubscribe(enchannel,\n                                 subscribedChannels);\n                }\n                else\n                if (Arrays.equals(SUNSUBSCRIBE.getRaw(),\n                                  resp))\n                {\n                    subscribedChannels = ((Long)listReply.get(2))\n                                             .intValue();\n                    final byte[] bchannel = (byte[])listReply.get(1);\n                    final T enchannel = (bchannel == null)?null:encode(bchannel);\n                    onSUnsubscribe(enchannel,\n                                   subscribedChannels);\n                }\n                else\nif (Arrays.equals(SMESSAGE.getRaw(),\n                 resp))\n{\n   final byte[] bchannel = (byte[])listReply.get(1);\n   final byte[] bmesg = (byte[])listReply.get(2);\n   final T enchannel = (bchannel == null)?null:encode(bchannel);\n   final T enmesg = (bmesg == null)?null:encode(bmesg);\n   onSMessage(enchannel,\n              enmesg);\n}\nelse\n{\n   throw new JedisException(\"Unknown message type: \"\n             + firstObj);\n}\n            }\n            else\n            if (reply instanceof byte[])\n            {\n                Consumer <Object> resultHandler = authenticator.resultHandler.poll();\n\n                if (resultHandler == null)\n                {\n                    throw new JedisException(\"Unexpected message : \"\n                              + SafeEncoder.encode((byte[])reply));\n                }\n\n                resultHandler.accept(reply);\n            }\n            else\n            {\n                throw new JedisException(\"Unknown message type: \"\n                          + reply);\n            }\n        }\n\n        while (!Thread.currentThread()\n                .isInterrupted() && isSubscribed());\n\n//    /* Invalidate instance since this thread is no longer listening */\n//    this.client = null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "122", "src_id": "M126", "code": "\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this)\n        {\n            return true;\n        }\n\n        if (!(o instanceof CommandObject))\n        {\n            return false;\n        }\n\n        Iterator <Rawable> e1 = arguments.iterator();\n        Iterator <Rawable> e2 = ((CommandObject)o)\n                                    .arguments .iterator();\n\n        while (e1.hasNext() && e2.hasNext())\n        {\n            Rawable o1 = e1.next();\n            Rawable o2 = e2.next();\n\n            if (!(o1 == null?o2 == null:o1.equals(o2)))\n            {\n                return false;\n            }\n        }\n\n        if (e1.hasNext()||e2.hasNext())\n        {\n            return false;\n        }\n\n        return builder == ((CommandObject)o)\n                              .builder;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "123", "src_id": "M918", "code": "\n    public CommandArguments add(Object arg)\n    {\n        if (arg == null)\n        {\n            throw new IllegalArgumentException(\"null is not a valid argument.\");\n        }\n        else\n        if (arg instanceof Rawable)\n        {\n            args.add((Rawable)arg);\n        }\n        else\nif (arg instanceof byte[])\n{\n   args.add(RawableFactory.from((byte[])arg));\n}\nelse\nif (arg instanceof Boolean)\n{\n   args.add(RawableFactory.from((Boolean)arg));\n}\nelse\nif (arg instanceof Integer)\n{\n   args.add(RawableFactory.from((Integer)arg));\n}\nelse\nif (arg instanceof Long)\n{\n   args.add(RawableFactory.from((Long)arg));\n}\nelse\nif (arg instanceof Double)\n{\n   args.add(RawableFactory.from((Double)arg));\n}\nelse\nif (arg instanceof float[])\n{\n   args.add(RawableFactory.from(RediSearchUtil.toByteArray((float[])arg)));\n}\nelse\nif (arg instanceof String)\n{\n   args.add(RawableFactory.from((String)arg));\n}\nelse\nif (arg instanceof GeoCoordinate)\n{\n   GeoCoordinate geo = (GeoCoordinate)arg;\n   args.add(RawableFactory.from(geo.getLongitude()+\",\"\n                + geo.getLatitude()));\n}\nelse\n{\n   args.add(RawableFactory.from(String.valueOf(arg)));\n}\n\n        return this;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "124", "src_id": "M1216", "code": "\n    private\n    void initMaster(HostAndPort master)\n    {\n        initPoolLock.lock();\n        try\n        {\n            if (!master.equals(currentMaster))\n            {\n                currentMaster = master;\n                ConnectionPool newPool = createNodePool(currentMaster);\n                ConnectionPool existingPool = pool;\n                pool = newPool;\n                LOG.info(\n                    \"Created connection pool to master at {}.\",\n                    master);\n                if (clientSideCache != null)\n                {\n                    clientSideCache.flush();\n                }\n\n                if (existingPool != null)\n                {\n          // although we clear the pool, we still have to check the returned object in getResource,\n          // this call only clears idle instances, not borrowed instances\n          // existingPool.clear(); // necessary??\n                    existingPool.close();\n                }\n            }\n        }\n        finally\n            {\n                initPoolLock.unlock();\n            }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "125", "src_id": "M361", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "126", "src_id": "M343", "code": "\n    private static EmailContent extractEmailContentAdvanced(byte [] emlBytes,\n        EmlToPdfRequest request) {\n        try {\n            // Use Jakarta Mail for processing\n            Class<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n            Class<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n            Method getDefaultInstance = sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n            Object session = getDefaultInstance.invoke(null, new Properties());\n\n            // Cast the session object to the proper type for the constructor\n            Class<?>[] constructorArgs = new Class<?> [] {sessionClass, InputStream.class};\n            Constructor<?> mimeMessageConstructor = mimeMessageClass.getConstructor(constructorArgs);\n            Object message = mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n            return extractEmailContentAdvanced(message, request);\n        } catch (ReflectiveOperationException e) {\n            // Create basic EmailContent from basic processing\n            EmailContent content = new EmailContent();\n            content.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n            return content;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "127", "src_id": "M356", "code": "\n    private static void appendEnhancedStyles(StringBuilder html) {\n        int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n        String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n        String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n        String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n        html.append(\"body {\\n\");\n        html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n        html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n        html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n        html.append(\"  color: \").append(textColor).append(\";\\n\");\n        html.append(\"  margin: 0;\\n\");\n        html.append(\"  padding: 16px;\\n\");\n        html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-container {\\n\");\n        html.append(\"  width: 100%;\\n\");\n        html.append(\"  max-width: 100%;\\n\");\n        html.append(\"  margin: 0 auto;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header {\\n\");\n        html.append(\"  padding-bottom: 10px;\\n\");\n        html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n        html.append(\"  margin-bottom: 10px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header h1 {\\n\");\n        html.append(\"  margin: 0 0 10px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n        html.append(\"  font-weight: bold;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-meta div {\\n\");\n        html.append(\"  margin-bottom: 2px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-body {\\n\");\n        html.append(\"  word-wrap: break-word;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section {\\n\");\n        html.append(\"  margin-top: 15px;\\n\");\n        html.append(\"  padding: 10px;\\n\");\n        html.append(\"  background-color: \").append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\");\n        html.append(\"  border: 1px solid \").append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section h3 {\\n\");\n        html.append(\"  margin: 0 0 8px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-item {\\n\");\n        html.append(\"  padding: 5px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-icon {\\n\");\n        html.append(\"  margin-right: 5px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-details, .attachment-type {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  color: #555555;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n        html.append(\"  margin-top: 8px;\\n\");\n        html.append(\"  padding: 6px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note {\\n\");\n        html.append(\"  background-color: #e6ffed;\\n\");\n        html.append(\"  border: 1px solid #d4f7dc;\\n\");\n        html.append(\"  color: #006420;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-info-note {\\n\");\n        html.append(\"  background-color: #fff9e6;\\n\");\n        html.append(\"  border: 1px solid #fff0c2;\\n\");\n        html.append(\"  color: #664d00;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container {\\n\");\n        html.append(\"  display: flex;\\n\");\n        html.append(\"  align-items: center;\\n\");\n        html.append(\"  padding: 8px;\\n\");\n        html.append(\"  background-color: #f8f9fa;\\n\");\n        html.append(\"  border: 1px solid #dee2e6;\\n\");\n        html.append(\"  border-radius: 4px;\\n\");\n        html.append(\"  margin: 4px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container:hover {\\n\");\n        html.append(\"  background-color: #e9ecef;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-note {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n        html.append(\"  color: #6c757d;\\n\");\n        html.append(\"  font-style: italic;\\n\");\n        html.append(\"  margin-left: 8px;\\n\");\n        html.append(\"}\\n\\n\");\n\n        // Basic image styling: ensure images are responsive but not overly constrained.\n        html.append(\"img {\\n\");\n        html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n        html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n        html.append(\"  display: block;\\n\"); // Avoid extra space below images\n        html.append(\"}\\n\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "128", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent,\n        String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for(int i = 0;\ni<lines.length;\ni++ ) {\n                String line = lines[ i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for(int j = i + 1;\nj<lines.length;\nj++ ) {\n                        if (lines[ j] .startsWith(\" \")|| lines[ j] .startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[ j] .trim());\n                        } else {\n                            break;\n                        }\n                    }\n                    // Apply MIME header decoding\n\n                    return safeMimeDecode(value.toString());\n                }\n\n                if (line.trim().isEmpty()) break;\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n\n        return \"\";\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "129", "src_id": "M454", "code": "\n    private void setupMainFrame() {\n        frame = new JFrame(\"Stirling-PDF\");\n        frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n        frame.setUndecorated(true);\n        frame.setOpacity(0.0f);\n        JPanel contentPane = new JPanel(new BorderLayout());\n        contentPane.setDoubleBuffered(true);\n        contentPane.add(browser.getUIComponent(), BorderLayout.CENTER);\n        frame.setContentPane(contentPane);\n        frame.addWindowListener(new java.awt.event.WindowAdapter() {\n                                    @Override public void windowClosing(java.awt.event.WindowEvent windowEvent) {\n                                        cleanup();\n                                        System.exit(0);\n                                    }\n\n                                });\n        frame.setSize(UIScaling.scaleWidth(1280), UIScaling.scaleHeight(800));\n        frame.setLocationRelativeTo(null);\n        loadIcon();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "130", "src_id": "M604", "code": "\n    @\n\n        PostMapping(value = \"/form-fields\", consumes = \"multipart/form-data\") @Operation(summary = \"Get form field information\", description = \"Returns count and details of form fields. Input:PDF Output:JSON Type:SISO\") public Map<String, Object> getFormFields(@ModelAttribute PDFFile file) throws IOException {\n        try (PDDocument document = pdfDocumentFactory.load(file.getFileInput())) {\n            Map<String, Object> formInfo = new HashMap < >();\n            PDAcroForm form = document.getDocumentCatalog().getAcroForm();\n\n            if (form != null) {\n                formInfo.put(\"fieldCount\", form.getFields().size());\n                formInfo.put(\"hasXFA\", form.hasXFA());\n                formInfo.put(\"isSignaturesExist\", form.isSignaturesExist());\n            } else {\n                formInfo.put(\"fieldCount\", 0);\n                formInfo.put(\"hasXFA\", false);\n                formInfo.put(\"isSignaturesExist\", false);\n            }\n\n            return formInfo;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "131", "src_id": "M443", "code": "\n    private void checkAndRefreshExplorer() {\n        if (!IS_WINDOWS) {\n            return;\n        }\n        if (timeAt90Percent == - 1) {\n            timeAt90Percent = System.currentTimeMillis();\n            stuckTimer = new Timer(1000, e-> {\n                                             long currentTime = System.currentTimeMillis();\n\n                                             if (currentTime - timeAt90Percent > stuckThreshold) {\n                                                 try {\n                                                     log.debug(\"Attempting Windows explorer refresh due to 90% stuck state\");\n                                                     String currentDir = System.getProperty(\"user.dir\");\n\n                                        // Store current explorer PIDs before we start new one\n                                                     Set < String> existingPids = new HashSet < >();\n                                                     ProcessBuilder listExplorer = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\", \"get\", \"ProcessId\", \"/format:csv\");\n                                                     Process process = listExplorer.start();\n                                                     BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                                                     String line;\n                                                     while((line = BoundedLineReader.readLine(reader, 5_000_000)) != null) {\n                                                         if (line.matches(\".*\\\\d+.*\")) { // Contains numbers\n                                                             String[] parts = line.trim().split(\",\");\n\n                                                             if (parts.length >= 2) {\n                                                                 existingPids.add(parts[parts.length - 1].trim());\n                                                             }\n                                                         }\n                                                     }\n\n                                                     process.waitFor(2, TimeUnit.SECONDS);\n\n                                        // Start new explorer\n                                                     ProcessBuilder pb = new ProcessBuilder(\"cmd\", \"/c\", \"start\", \"/min\", \"/b\", \"explorer.exe\", currentDir);\n                                                     pb.redirectErrorStream(true);\n                                                     explorerProcess = pb.start();\n\n                                        // Schedule cleanup\n                                                     Timer cleanupTimer = new Timer(2000, cleanup-> {\n                                                                                              try {\n                                                                // Find new explorer processes\n                                                                                                  ProcessBuilder findNewExplorer = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\", \"get\", \"ProcessId\", \"/format:csv\");\n                                                                                                  Process newProcess = findNewExplorer.start();\n                                                                                                  BufferedReader newReader = new BufferedReader(new InputStreamReader(newProcess.getInputStream()));\n                                                                                                  String newLine;\n                                                                                                  while((newLine = BoundedLineReader.readLine(newReader, 5_000_000)) != null) {\n                                                                                                      if (newLine.matches(\".*\\\\d+.*\")) {\n                                                                                                          String[] parts = newLine.trim().split(\",\");\n\n                                                                                                          if (parts.length >= 2) {\n                                                                                                              String pid = parts[parts.length - 1].trim();\n\n                                                                                                              if (!existingPids.contains(pid)) {\n                                                                                                                  log.debug(\"Found new explorer.exe with PID: \" + pid);\n                                                                                                                  ProcessBuilder killProcess = new ProcessBuilder(\"taskkill\", \"/PID\", pid, \"/F\");\n                                                                                                                  killProcess.redirectErrorStream(true);\n                                                                                                                  Process killResult = killProcess.start();\n                                                                                                                  killResult.waitFor(2, TimeUnit.SECONDS);\n                                                                                                                  log.debug(\"Explorer process terminated: \" + pid);\n                                                                                                              }\n                                                                                                          }\n                                                                                                      }\n                                                                                                  }\n\n                                                                                                  newProcess.waitFor(2, TimeUnit.SECONDS);\n                                                                                              } catch (Exception ex) {\n                                                                                                  log.error(\"Error cleaning up Windows explorer process\", ex);\n                                                                                              }\n                                                                                          });\n                                                     cleanupTimer.setRepeats(false);\n                                                     cleanupTimer.start();\n                                                     stuckTimer.stop();\n                                                 } catch (Exception ex) {\n                                                     log.error(\"Error refreshing Windows explorer\", ex);\n                                                 }\n                                             }\n                                         });\n            stuckTimer.setRepeats(true);\n            stuckTimer.start();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "132", "src_id": "M542", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "133", "src_id": "M625", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "134", "src_id": "M518", "code": "\n    public static boolean isBlankImage(BufferedImage image, int threshold, double whitePercent,int blurSize) {\n        if (image == null) {\n            log.info(\"Error: Image is null\");\n            return false;\n        }\n\n        // Convert to binary image based on the threshold\n\n        int whitePixels = 0;\n        int totalPixels = image.getWidth() * image.getHeight();\n        for (int i = 0; i < image.getHeight(); i++) {\n            for (int j = 0; j < image.getWidth(); j++) {\n                int color = image.getRGB(j, i)& 0xFF;\n\n                if (color >= 255 - threshold) {\n                    whitePixels++;\n                }\n            }\n        }\n\n        double whitePixelPercentage = (whitePixels / (double) totalPixels) * 100;\n        log.info(String.format(\"Page has white pixel percent of %.2f%%\", whitePixelPercentage));\n        return whitePixelPercentage >= whitePercent;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "135", "src_id": "M483", "code": "\n    @\n\n        PostMapping(consumes = \"multipart/form-data\", value = \"/filter-page-count\") @Operation(summary = \"Checks if a PDF is greater, less or equal to a setPageCount\", description = \"Input:PDF Output:Boolean Type:SISO\") public ResponseEntity < byte[]> pageCount(@ModelAttribute PDFComparisonAndCount request) throws IOException, InterruptedException {\n        MultipartFile inputFile = request.getFileInput();\n        int pageCount = request.getPageCount();\n        String comparator = request.getComparator();\n        // Load the PDF\n        PDDocument document = pdfDocumentFactory.load(inputFile);\n        int actualPageCount = document.getNumberOfPages();\n        boolean valid = false;\n        // Perform the comparison\n        switch (comparator) {\n            case \"Greater\":\n                valid = actualPageCount > pageCount;\n                break;\n            case \"Equal\":\n                valid = actualPageCount == pageCount;\n                break;\n            case \"Less\":\n                valid = actualPageCount < pageCount;\n                break;\n                            default:\n                                throw ExceptionUtils.createInvalidArgumentException(\"comparator\", comparator);\n        }\n        if (valid) return WebResponseUtils.multiPartFileToWebResponse(inputFile);\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "136", "src_id": "M475", "code": "\n    private void handleSplitBySize(PDDocument sourceDocument, long maxBytes, ZipOutputStream zipOut,String baseFilename) throws IOException {\n        log.debug(\"Starting handleSplitBySize with maxBytes={}\", maxBytes);\n        PDDocument currentDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(sourceDocument);\n        int fileIndex = 1;\n        int totalPages = sourceDocument.getNumberOfPages();\n        int pageAdded = 0;\n\n        // Smart size check frequency - check more often with larger documents\n        int baseCheckFrequency = 5;\n        for (int pageIndex = 0; pageIndex < totalPages; pageIndex++) {\n            PDPage page = sourceDocument.getPage(pageIndex);\n            log.debug(\"Processing page {} of {}\", pageIndex + 1, totalPages);\n\n            // Add the page to current document\n            PDPage newPage = new PDPage(page.getCOSObject());\n            currentDoc.addPage(newPage);\n            pageAdded++;\n\n            // Dynamic size checking based on document size and page count\n\n            boolean shouldCheckSize = (pageAdded % baseCheckFrequency == 0) || (pageIndex == totalPages - 1) || (pageAdded >= 20); // Always check after 20 pages\n\n            if (shouldCheckSize) {\n                log.debug(\"Performing size check after {} pages\", pageAdded);\n                ByteArrayOutputStream checkSizeStream = new ByteArrayOutputStream();\n                currentDoc.save(checkSizeStream);\n\n                long actualSize = checkSizeStream.size();\n                log.debug(\"Current document size: {} bytes (max: {} bytes)\", actualSize, maxBytes);\n                if (actualSize > maxBytes) {\n                    // We exceeded the limit - remove the last page and save\n                    if (currentDoc.getNumberOfPages() > 1) {\n                        currentDoc.removePage(currentDoc.getNumberOfPages() - 1);\n                        pageIndex--; // Process this page again in the next document\n                        log.debug(\"Size limit exceeded - removed last page\");\n                    }\n\n                    log.debug(\"Saving document with {} pages as part {}\", currentDoc.getNumberOfPages(), fileIndex);\n                    saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n                    currentDoc = new PDDocument();\n                    pageAdded = 0;\n                } else if (pageIndex < totalPages - 1) {\n                    // We're under the limit, calculate if we might fit more pages\n                    // Try to predict how many more similar pages might fit\n                           if (actualSize < maxBytes * 0.75 && pageAdded > 0) {\n                        // Rather than using a ratio, look ahead to test actual upcoming pages\n                               int pagesToLookAhead = Math.min(5, totalPages - pageIndex - 1);\n\n                               if (pagesToLookAhead > 0) {\n                                   log.debug(\"Testing {} upcoming pages for potential addition\", pagesToLookAhead);\n\n                            // Create a temp document with current pages + look-ahead pages\n                                   PDDocument testDoc = new PDDocument();\n                            // First copy existing pages\n                                   for (int i = 0; i < currentDoc.getNumberOfPages(); i++) {\n                                       testDoc.addPage(new PDPage(currentDoc.getPage(i).getCOSObject()));\n                                   }\n\n                            // Try adding look-ahead pages one by one\n\n                                   int extraPagesAdded = 0;\n                                   for (int i = 0; i < pagesToLookAhead; i++) {\n                                       int testPageIndex = pageIndex + 1 + i;\n                                       PDPage testPage = sourceDocument.getPage(testPageIndex);\n                                       testDoc.addPage(new PDPage(testPage.getCOSObject()));\n\n                                // Check if we're still under size\n                                       ByteArrayOutputStream testStream = new ByteArrayOutputStream();\n                                       testDoc.save(testStream);\n\n                                       long testSize = testStream.size();\n\n                                       if (testSize <= maxBytes) {\n                                           extraPagesAdded++;\n                                           log.debug(\"Test: Can add page {} (size would be {})\", testPageIndex + 1, testSize);\n                                       } else {\n                                           log.debug(\"Test: Cannot add page {} (size would be {})\", testPageIndex + 1, testSize);\n                                           break;\n                                       }\n                                   }\n\n                                   testDoc.close();\n\n                            // Add the pages we verified would fit\n                                   if (extraPagesAdded > 0) {\n                                       log.debug(\"Adding {} verified pages ahead\", extraPagesAdded);\n                                       for (int i = 0; i < extraPagesAdded; i++) {\n                                           int extraPageIndex = pageIndex + 1 + i;\n                                           PDPage extraPage = sourceDocument.getPage(extraPageIndex);\n                                           currentDoc.addPage(new PDPage(extraPage.getCOSObject()));\n                                       }\n\n                                       pageIndex += extraPagesAdded;\n                                       pageAdded += extraPagesAdded;\n                                   }\n                               }\n                           }\n                       }\n            }\n        }\n\n        // Save final document if it has any pages\n        if (currentDoc.getNumberOfPages() > 0) {\n            log.debug(\"Saving final document with {} pages as part {}\", currentDoc.getNumberOfPages(), fileIndex);\n            saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n        }\n\n        log.debug(\"Completed handleSplitBySize with {} document parts created\", fileIndex - 1);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "137", "src_id": "M291", "code": "\n    public static File convertMultipartFileToFile(MultipartFile multipartFile) throws IOException {\n        String customTempDir = System.getenv(\"STIRLING_TEMPFILES_DIRECTORY\");\n\n        if (customTempDir == null || customTempDir.isEmpty()) {\n            customTempDir = System.getProperty(\"stirling.tempfiles.directory\");\n        }\n\n        File tempFile;\n\n        if (customTempDir != null && !customTempDir.isEmpty()) {\n            Path tempDir = Path.of(customTempDir);\n\n            if (!Files.exists(tempDir)) {\n                Files.createDirectories(tempDir);\n            }\n\n            tempFile = Files.createTempFile(tempDir, \"stirling-pdf-\", null).toFile();\n        } else {\n            Path tempDir = Path.of(System.getProperty(\"java.io.tmpdir\"), \"stirling-pdf\");\n\n            if (!Files.exists(tempDir)) {\n                Files.createDirectories(tempDir);\n            }\n\n            tempFile = Files.createTempFile(tempDir, \"stirling-pdf-\", null).toFile();\n        }\n\n        try(InputStream inputStream = multipartFile.getInputStream(); FileOutputStream outputStream = new FileOutputStream(tempFile)) {\n            byte [] buffer = new byte[8192];\n            int bytesRead;\n            while((bytesRead = inputStream.read(buffer)) != - 1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n        }\n\n        return tempFile;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "138", "src_id": "M254", "code": "\n    private void cleanupTempFiles() {\n        try {\n            // Clean up all registered files\n            Set < Path> files = registry.getAllRegisteredFiles();\n            int deletedCount = 0;\n            for (Path file : files) {\n                try {\n                    if (Files.exists(file)) {\n                        Files.deleteIfExists(file);\n                        deletedCount++;\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Failed to delete temp file during shutdown: {}\", file, e);\n                }\n            }\n\n            // Clean up all registered directories\n\n            Set < Path> directories = registry.getTempDirectories();\n            for (Path dir : directories) {\n                try {\n                    if (Files.exists(dir)) {\n                        GeneralUtils.deleteDirectory(dir);\n                        deletedCount++;\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Failed to delete temp directory during shutdown: {}\", dir, e);\n                }\n            }\n\n            log.info(\"Shutdown cleanup complete. Deleted {} temporary files/directories\", deletedCount);\n\n            // Clear the registry\n            registry.clear();\n        } catch (Exception e) {\n            log.error(\"Error during shutdown cleanup\", e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "139", "src_id": "M749", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "140", "src_id": "M397", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "141", "src_id": "M1118", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "142", "src_id": "M526", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "143", "src_id": "M1130", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "144", "src_id": "M542", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "145", "src_id": "M493", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "146", "src_id": "M355", "code": "\n    private static String processInlineImages(String htmlContent,EmailContent emailContent) {\n        if (htmlContent == null || emailContent == null) return htmlContent;\n\n        // Create a map of Content-ID to attachment data\n        Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n        for (EmailAttachment attachment : emailContent.getAttachments()) {\n            if (attachment.isEmbedded() && attachment.getContentId() != null&& attachment.getData() != null) {\n                contentIdMap.put(attachment.getContentId(), attachment);\n            }\n        }\n\n        if (contentIdMap.isEmpty()) return htmlContent;\n\n        // Pattern to match cid: references in img src attributes\n        Pattern cidPattern = Pattern.compile(\n            \"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\",\n            Pattern.CASE_INSENSITIVE);\n        Matcher matcher = cidPattern.matcher(htmlContent);\n        StringBuffer result = new StringBuffer();\n        while(matcher.find()) {\n            String contentId = matcher.group(1);\n            EmailAttachment attachment = contentIdMap.get(contentId);\n            if (attachment != null && attachment.getData() != null) {\n                // Convert to data URI\n                String mimeType = attachment.getContentType();\n                if (mimeType == null || mimeType.isEmpty()) {\n                    // Try to determine MIME type from filename\n                    String filename = attachment.getFilename();\n                    if (filename != null) {\n                        if (filename.toLowerCase().endsWith(\".png\")) {\n                            mimeType = \"image/png\";\n                        } else if(filename.toLowerCase().endsWith(\".jpg\") || filename.toLowerCase().endsWith(\".jpeg\")) {\n                                   mimeType = \"image/jpeg\";\n                               } else if(filename.toLowerCase().endsWith(\".gif\")) {\n                                          mimeType = \"image/gif\";\n                                      } else if(filename.toLowerCase().endsWith(\".bmp\")) {\n                                                 mimeType = \"image/bmp\";\n                                             } else {\n                                                 mimeType = \"image/png\"; // fallback\n                                             }\n                    } else {\n                        mimeType = \"image/png\"; // fallback\n                    }\n                }\n\n                String base64Data = Base64.getEncoder().encodeToString(attachment.getData());\n                String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n                // Replace the cid: reference with the data URI\n                String replacement = matcher.group(0).replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n                matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n            } else {\n                // Keep original if attachment not found\n                matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n            }\n        }\n\n        matcher.appendTail(result);\n        return result.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "147", "src_id": "M362", "code": "\n    private static String generateEnhancedEmailHtml(EmailContent content,EmlToPdfRequest request) {\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(content.getSubject())).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(content.getSubject())).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(content.getFrom())).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(content.getTo())).append(\"</div>\\n\");\n        if (content.getDate() != null) {\n            html.append(\"<div><strong>Date:</strong> \").append(formatEmailDate(content.getDate())).append(\"</div>\\n\");\n        }\n\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        if (content.getHtmlBody() != null && !content.getHtmlBody().trim()\n                                                                   .isEmpty()) {\n            html.append(processEmailHtmlBody(content.getHtmlBody(), content));\n        } else if(content.getTextBody() != null && !content.getTextBody().trim()\n                                                                         .isEmpty()) {\n                   html.append(\"<div class=\\\"text-body\\\">\");\n                   html.append(convertTextToHtml(content.getTextBody()));\n                   html.append(\"</div>\");\n               } else {\n                   html.append(\"<div class=\\\"no-content\\\">\");\n                   html.append(\"<p><em>No content available</em></p>\");\n                   html.append(\"</div>\");\n               }\n\n        html.append(\"</div>\\n\");\n        if (content.getAttachmentCount() > 0 || !content.getAttachments().isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n\n\n            int displayedAttachmentCount = content.getAttachmentCount() > 0\n                ? content.getAttachmentCount() : content.getAttachments().size();\n            html.append(\"<h3>Attachments (\").append(displayedAttachmentCount).append(\")</h3>\\n\");\n            if (!content.getAttachments().isEmpty()) {\n                for (EmailAttachment attachment : content.getAttachments()) {\n                    // Create attachment info with paperclip emoji before filename\n                    String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n                    attachment.setEmbeddedFilename(attachment.getEmbeddedFilename() != null\n                        ? attachment.getEmbeddedFilename() : attachment.getFilename());\n                    html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\").append(uniqueId)\n                        .append(\"\\\">\")\n                            .append(\"<span class=\\\"attachment-icon\\\">\")\n                                .append(MimeConstants.ATTACHMENT_MARKER)\n                                    .append(\"</span> \")\n                                        .append(\"<span class=\\\"attachment-name\\\">\")\n                                            .append(escapeHtml(safeMimeDecode(attachment.getFilename()))).append(\"</span>\");\n                    String sizeStr = formatFileSize(attachment.getSizeBytes());\n                    html.append(\" <span class=\\\"attachment-details\\\">(\").append(sizeStr);\n                    if (attachment.getContentType() != null && !attachment.getContentType().isEmpty()) {\n                        html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                    }\n\n                    html.append(\")</span></div>\\n\");\n                }\n            }\n\n            if (request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachments are embedded in the file.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "148", "src_id": "M356", "code": "\n    private static void appendEnhancedStyles(StringBuilder html) {\n        int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n        String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n        String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n        String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n        html.append(\"body {\\n\");\n        html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n        html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n        html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n        html.append(\"  color: \").append(textColor).append(\";\\n\");\n        html.append(\"  margin: 0;\\n\");\n        html.append(\"  padding: 16px;\\n\");\n        html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-container {\\n\");\n        html.append(\"  width: 100%;\\n\");\n        html.append(\"  max-width: 100%;\\n\");\n        html.append(\"  margin: 0 auto;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header {\\n\");\n        html.append(\"  padding-bottom: 10px;\\n\");\n        html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n        html.append(\"  margin-bottom: 10px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header h1 {\\n\");\n        html.append(\"  margin: 0 0 10px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n        html.append(\"  font-weight: bold;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-meta div {\\n\");\n        html.append(\"  margin-bottom: 2px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-body {\\n\");\n        html.append(\"  word-wrap: break-word;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section {\\n\");\n        html.append(\"  margin-top: 15px;\\n\");\n        html.append(\"  padding: 10px;\\n\");\n        html.append(\"  background-color: \").append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\");\n        html.append(\"  border: 1px solid \").append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section h3 {\\n\");\n        html.append(\"  margin: 0 0 8px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-item {\\n\");\n        html.append(\"  padding: 5px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-icon {\\n\");\n        html.append(\"  margin-right: 5px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-details, .attachment-type {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  color: #555555;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n        html.append(\"  margin-top: 8px;\\n\");\n        html.append(\"  padding: 6px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note {\\n\");\n        html.append(\"  background-color: #e6ffed;\\n\");\n        html.append(\"  border: 1px solid #d4f7dc;\\n\");\n        html.append(\"  color: #006420;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-info-note {\\n\");\n        html.append(\"  background-color: #fff9e6;\\n\");\n        html.append(\"  border: 1px solid #fff0c2;\\n\");\n        html.append(\"  color: #664d00;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container {\\n\");\n        html.append(\"  display: flex;\\n\");\n        html.append(\"  align-items: center;\\n\");\n        html.append(\"  padding: 8px;\\n\");\n        html.append(\"  background-color: #f8f9fa;\\n\");\n        html.append(\"  border: 1px solid #dee2e6;\\n\");\n        html.append(\"  border-radius: 4px;\\n\");\n        html.append(\"  margin: 4px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container:hover {\\n\");\n        html.append(\"  background-color: #e9ecef;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-note {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n        html.append(\"  color: #6c757d;\\n\");\n        html.append(\"  font-style: italic;\\n\");\n        html.append(\"  margin-left: 8px;\\n\");\n        html.append(\"}\\n\\n\");\n\n        // Basic image styling: ensure images are responsive but not overly constrained.\n        html.append(\"img {\\n\");\n        html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n        html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n        html.append(\"  display: block;\\n\"); // Avoid extra space below images\n        html.append(\"}\\n\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "149", "src_id": "M359", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "150", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(final Context context, @NonNull final List < Image > images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images) .transform(new Transformation() {\n                                                                  @Override\n                                                                  public Bitmap transform(final Bitmap source) {\n                                                                      if (DEBUG) {\n                                                                          Log.d(TAG, \"Thumbnail - transform() called\");\n                                                                      }\n                                                                      final float notificationThumbnailWidth = Math.min(context.getResources() .getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n                                                                      final Bitmap result = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth, (int) (source.getHeight()/(source.getWidth()/ notificationThumbnailWidth)), null, true);\n                                                                      if (result == source || !result.isMutable()) {\n                            // create a new mutable bitmap to prevent strange crashes on some\n                            // devices (see #4638)\n                                                                          final Bitmap copied = BitmapCompat.createScaledBitmap(source, (int) notificationThumbnailWidth - 1, (int) (source.getHeight()/(source.getWidth()/(notificationThumbnailWidth - 1))), null, true);\n                                                                          source.recycle();\n\n                                                                          return copied;\n                                                                      } else {\n                                                                          source.recycle();\n\n                                                                          return result;\n                                                                      }\n                                                                  }\n\n                                                                  @Override\n                                                                  public String key() {\n                                                                      return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                                                                  }\n\n                                                              });\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "151", "src_id": "M369", "code": "\n    private void buildQualityMenu() {\n        if (qualityPopupMenu == null) {\n            return;\n        }\n\n        qualityPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_QUALITY);\n\n        final List < VideoStream > availableStreams = Optional.ofNullable(player.getCurrentMetadata()) .flatMap(MediaItemTag ::getMaybeQuality) .map(MediaItemTag.Quality::getSortedVideoStreams) .orElse(null);\n        if (availableStreams == null) {\n            return;\n        }\n        for (int i = 0; i < availableStreams.size(); i++) {\n            final VideoStream videoStream = availableStreams.get(i);\n            qualityPopupMenu.getMenu().add(POPUP_MENU_ID_QUALITY, i, Menu.NONE, MediaFormat.getNameById(videoStream.getFormatId())+ \" \" + videoStream.getResolution());\n        }\n\n        qualityPopupMenu.setOnMenuItemClickListener(this);\n        qualityPopupMenu.setOnDismissListener(this);\n        player.getSelectedVideoStream().ifPresent(s ->\n            binding.qualityTextView.setText(s.getResolution()));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "152", "src_id": "M372", "code": "\n    private void buildCaptionMenu(@NonNull final List < String > availableLanguages) {\n        if (captionPopupMenu == null) {\n            return;\n        }\n\n        captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n        captionPopupMenu.setOnDismissListener(this);\n\n        // Add option for turning off caption\n\n        final MenuItem captionOffItem = captionPopupMenu.getMenu() .add(POPUP_MENU_ID_CAPTION, 0, Menu.NONE, R.string.caption_none);\n        captionOffItem.setOnMenuItemClickListener(menuItem -> {\n                                                      final int textRendererIndex = player.getCaptionRendererIndex();\n                                                      if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                                                          player.getTrackSelector().setParameters(player.getTrackSelector() .buildUponParameters() .setRendererDisabled(textRendererIndex, true));\n                                                      }\n\n                                                      player.getPrefs() .edit() .remove(context.getString(R.string.caption_user_set_key)).apply();\n\n                                                      return true;\n                                                  });\n\n        // Add all available captions\n\n        for (int i = 0; i < availableLanguages.size(); i++) {\n            final String captionLanguage = availableLanguages.get(i);\n            final MenuItem captionItem = captionPopupMenu.getMenu() .add(POPUP_MENU_ID_CAPTION, i + 1, Menu.NONE, captionLanguage);\n            captionItem.setOnMenuItemClickListener(menuItem -> {\n                                                       final int textRendererIndex = player.getCaptionRendererIndex();\n                                                       if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                    // DefaultTrackSelector will select for text tracks in the following order.\n                    // When multiple tracks share the same rank, a random track will be chosen.\n                    // 1. ANY track exactly matching preferred language name\n                    // 2. ANY track exactly matching preferred language stem\n                    // 3. ROLE_FLAG_CAPTION track matching preferred language stem\n                    // 4. ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND track matching preferred language stem\n                    // This means if a caption track of preferred language is not available,\n                    // then an auto-generated track of that language will be chosen automatically.\n                                                           player.getTrackSelector().setParameters(player.getTrackSelector() .buildUponParameters() .setPreferredTextLanguages(captionLanguage, PlayerHelper.captionLanguageStemOf(captionLanguage)) .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION) .setRendererDisabled(textRendererIndex, false));\n                                                           player.getPrefs() .edit() .putString(context.getString(R.string.caption_user_set_key), captionLanguage).apply();\n                                                       }\n                                                       return true;\n                                                   });\n        }\n\n        captionPopupMenu.setOnDismissListener(this);\n\n        // apply caption language from previous user preference\n\n        final int textRendererIndex = player.getCaptionRendererIndex();\n        if (textRendererIndex == RENDERER_UNAVAILABLE) {\n            return;\n        }\n\n        // If user prefers to show no caption, then disable the renderer.\n        // Otherwise, DefaultTrackSelector may automatically find an available caption\n        // and display that.\n        final String userPreferredLanguage = player.getPrefs() .getString(context.getString(R.string.caption_user_set_key), null);\n        if (userPreferredLanguage == null) {\n            player.getTrackSelector().setParameters(player.getTrackSelector() .buildUponParameters() .setRendererDisabled(textRendererIndex, true));\n\n            return;\n        }\n\n        // Only set preferred language if it does not match the user preference,\n        // otherwise there might be an infinite cycle at onTextTracksChanged.\n        final List < String > selectedPreferredLanguages = player.getTrackSelector() .getParameters().preferredTextLanguages;\n        if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n            player.getTrackSelector().setParameters(player.getTrackSelector() .buildUponParameters() .setPreferredTextLanguages(userPreferredLanguage, PlayerHelper.captionLanguageStemOf(userPreferredLanguage)) .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION) .setRendererDisabled(textRendererIndex, false));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "153", "src_id": "M527", "code": "\n    @SuppressLint(\"PrivateResource\" ) // we currently use Exoplayer's internal strings and icons\n    @Nullable\n    public static NotificationActionData fromNotificationActionEnum(@NonNull final Player player, @NotificationConstants.Action final int selectedAction) {\n        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n        final Context ctx = player.getContext();\n        switch(selectedAction) {\n            case NotificationConstants.PREVIOUS:\n            return new NotificationActionData(ACTION_PLAY_PREVIOUS, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description), baseActionIcon);\n            case NotificationConstants.NEXT:\n            return new NotificationActionData(ACTION_PLAY_NEXT, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description), baseActionIcon);\n            case NotificationConstants.REWIND:\n            return new NotificationActionData(ACTION_FAST_REWIND, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description), baseActionIcon);\n            case NotificationConstants.FORWARD:\n            return new NotificationActionData(ACTION_FAST_FORWARD, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description), baseActionIcon);\n            case NotificationConstants.SMART_REWIND_PREVIOUS:\n            if (player.getPlayQueue() != null && player.getPlayQueue() .size() > 1) {\n                return new NotificationActionData(ACTION_PLAY_PREVIOUS, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description), com.google.android.exoplayer2.ui.R.drawable.exo_notification_previous);\n            } else {\n                return new NotificationActionData(ACTION_FAST_REWIND, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description), com.google.android.exoplayer2.ui.R.drawable.exo_controls_rewind);\n            }\n            case NotificationConstants.SMART_FORWARD_NEXT:\n            if (player.getPlayQueue() != null && player.getPlayQueue() .size() > 1) {\n                return new NotificationActionData(ACTION_PLAY_NEXT, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description), com.google.android.exoplayer2.ui.R.drawable.exo_notification_next);\n            } else {\n                return new NotificationActionData(ACTION_FAST_FORWARD, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description), com.google.android.exoplayer2.ui.R.drawable.exo_controls_fastforward);\n            }\n            case NotificationConstants.PLAY_PAUSE_BUFFERING:\n            if (player.getCurrentState() == Player.STATE_PREFLIGHT || player.getCurrentState() == Player.STATE_BLOCKED || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE, ctx.getString(R.string.notification_action_buffering), R.drawable.ic_hourglass_top);\n            }\n\n                // fallthrough\n            case NotificationConstants.PLAY_PAUSE:\n            if (player.getCurrentState() == Player.STATE_COMPLETED) {\n                return new NotificationActionData(ACTION_PLAY_PAUSE, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description), R.drawable.ic_replay);\n            } else\n                if (player.isPlaying()|| player.getCurrentState() == Player.STATE_PREFLIGHT || player.getCurrentState() == Player.STATE_BLOCKED || player.getCurrentState() == Player.STATE_BUFFERING) {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description), com.google.android.exoplayer2.ui.R.drawable.exo_notification_pause);\n                } else {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_play_description), com.google.android.exoplayer2.ui.R.drawable.exo_notification_play);\n                }\n            case NotificationConstants.REPEAT:\n            if (player.getRepeatMode() == REPEAT_MODE_ALL) {\n                return new NotificationActionData(ACTION_REPEAT, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_all_description), com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_all);\n            } else\n                if (player.getRepeatMode() == REPEAT_MODE_ONE) {\n                    return new NotificationActionData(ACTION_REPEAT, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_one_description), com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_one);\n                } else /* player.getRepeatMode() == REPEAT_MODE_OFF */ {\n                    return new NotificationActionData(ACTION_REPEAT, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_off_description), com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_off);\n                }\n            case NotificationConstants.SHUFFLE:\n            if (player.getPlayQueue() != null && player.getPlayQueue() .isShuffled()) {\n                return new NotificationActionData(ACTION_SHUFFLE, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_shuffle_on_description), com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_on);\n            } else {\n                return new NotificationActionData(ACTION_SHUFFLE, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_shuffle_off_description), com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_off);\n            }\n            case NotificationConstants.CLOSE:\n            return new NotificationActionData(ACTION_CLOSE, ctx.getString(R.string.close), R.drawable.ic_close);\n            case NotificationConstants.NOTHING: default:\n                // do nothing\n            return null;\n}\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "154", "src_id": "M16", "code": "\n    private void handleCookiesFromUrl(@Nullable final String url) {\n        if (MainActivity.DEBUG) {\n            Log.d(TAG, \"handleCookiesFromUrl: url=\" + (url == null ? \"null\" : url));\n        }\n        if (url == null) {\n            return;\n        }\n        final String cookies = CookieManager.getInstance() .getCookie(url);\n        handleCookies(cookies);\n\n        // sometimes cookies are inside the url\n\n        final int abuseStart = url.indexOf(\"google_abuse=\");\n        if (abuseStart != -1) {\n            final int abuseEnd = url.indexOf(\"+path\");\n            try {\n                handleCookies(Utils.decodeUrlUtf8(url.substring(abuseStart + 13, abuseEnd)));\n            } catch (final StringIndexOutOfBoundsException e) {\n                if (MainActivity.DEBUG) {\n                    Log.e(TAG, \"handleCookiesFromUrl: invalid google abuse starting at \" + abuseStart + \" and ending at \" + abuseEnd + \" for url \" + url, e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "155", "src_id": "M456", "code": "\n    public void toggleFullscreen() {\n        if (DEBUG) {\n            Log.d(TAG, \"toggleFullscreen() called\");\n        }\n        final PlayerServiceEventListener fragmentListener = player.getFragmentListener() .orElse(null);\n        if (fragmentListener == null || player.exoPlayerIsNull()) {\n            return;\n        }\n\n        isFullscreen = !isFullscreen;\n\n        if (isFullscreen) {\n            // Android needs tens milliseconds to send new insets but a user is able to see\n            // how controls changes it's position from `0` to `nav bar height` padding.\n            // So just hide the controls to hide this visual inconsistency\n            hideControls(0, 0);\n        } else {\n            // Apply window insets because Android will not do it when orientation changes\n            // from landscape to portrait (open vertical video to reproduce)\n            binding.playbackControlRoot.setPadding(0, 0, 0, 0);\n        }\n\n        fragmentListener.onFullscreenStateChanged(isFullscreen);\n        binding.titleTextView.setVisibility(isFullscreen ? View.VISIBLE : View.GONE);\n        binding.channelTextView.setVisibility(isFullscreen ? View.VISIBLE : View.GONE);\n        binding.playerCloseButton.setVisibility(isFullscreen ? View.GONE : View.VISIBLE);\n        setupScreenRotationButton();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "156", "src_id": "M217", "code": "\n    private void initPlayer(final boolean playOnReady) {\n        if (DEBUG) {\n            Log.d(TAG, \"initPlayer() called with: playOnReady = [\" + playOnReady + \"]\");\n        }\n\n        simpleExoPlayer = new ExoPlayer.Builder(context, renderFactory) .setTrackSelector(trackSelector) .setLoadControl(loadController) .setUsePlatformDiagnostics(false) .build();\n        simpleExoPlayer.addListener(this);\n        simpleExoPlayer.setPlayWhenReady(playOnReady);\n        simpleExoPlayer.setSeekParameters(PlayerHelper.getSeekParameters(context));\n        simpleExoPlayer.setWakeMode(C.WAKE_MODE_NETWORK);\n        simpleExoPlayer.setHandleAudioBecomingNoisy(true);\n        audioReactor = new AudioReactor(context, simpleExoPlayer);\n        registerBroadcastReceiver();\n\n        // Setup UIs\n        UIs.call(PlayerUi ::initPlayer);\n\n        // Disable media tunneling if requested by the user from ExoPlayer settings\n\n        if (!PreferenceManager.getDefaultSharedPreferences(context) .getBoolean(context.getString(R.string.disable_media_tunneling_key), false)) {\n            trackSelector.setParameters(trackSelector.buildUponParameters() .setTunnelingEnabled(true));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "157", "src_id": "M467", "code": "\n    private MediaMetadataCompat buildMediaMetadata() {\n        if (DEBUG) {\n            Log.d(TAG, \"buildMediaMetadata called\");\n        }\n\n        // set title and artist\n        final MediaMetadataCompat .Builder builder = new MediaMetadataCompat.Builder() .putString(MediaMetadataCompat.METADATA_KEY_TITLE, player.getVideoTitle()) .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, player.getUploaderName());\n\n        // set duration (-1 for livestreams or if unknown, see the METADATA_KEY_DURATION docs)\n        final long duration = player.getCurrentStreamInfo() .filter(info -> !StreamTypeUtil.isLiveStream(info.getStreamType())) .map(info ->\n                                                                                                                                    info.getDuration() * 1000L) .orElse(-1L);\n        builder.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration);\n\n        // set album art, unless the user asked not to, or there is no thumbnail available\n\n        final boolean showThumbnail = player.getPrefs() .getBoolean(context.getString(R.string.show_thumbnail_key), true);\n        Optional.ofNullable(player.getThumbnail()) .filter(bitmap ->\n                                                       showThumbnail).ifPresent(bitmap -> {\n                                                                                    builder.putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, bitmap);\n                                                                                    builder.putBitmap(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON, bitmap);\n                                                                                });\n\n        return builder.build();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "158", "src_id": "M460", "code": "\n    public MediaDescriptionCompat getQueueMetadata(final int index) {\n        if (player.getPlayQueue() == null) {\n            return null;\n        }\n        final PlayQueueItem item = player.getPlayQueue() .getItem(index);\n        if (item == null) {\n            return null;\n        }\n        final MediaDescriptionCompat .Builder descBuilder = new MediaDescriptionCompat.Builder() .setMediaId(String.valueOf(index)) .setTitle(item.getTitle()) .setSubtitle(item.getUploader());\n\n        // set additional metadata for A2DP/AVRCP (Audio/Video Bluetooth profiles)\n        final Bundle additionalMetadata = new Bundle();\n        additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_TITLE, item.getTitle());\n        additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_ARTIST, item.getUploader());\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, item.getDuration() * 1000);\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, index + 1L);\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, player.getPlayQueue() .size());\n        descBuilder.setExtras(additionalMetadata);\n\n        try {\n            descBuilder.setIconUri(Uri.parse(ImageStrategy.choosePreferredImage(item.getThumbnails())));\n        } catch (final Throwable e) {\n            // no thumbnail available at all, or the user disabled image loading,\n            // or the obtained url is not a valid `Uri`\n        }\n        return descBuilder.build();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "159", "src_id": "M543", "code": "\n    private synchronized NotificationCompat .Builder createNotification() {\n        if (DEBUG) {\n            Log.d(TAG, \"createNotification()\");\n        }\n\n        notificationManager = NotificationManagerCompat.from(player.getContext());\n\n        final NotificationCompat .Builder builder = new NotificationCompat.Builder(player.getContext(), player.getContext() .getString(R.string.notification_channel_id));\n        final MediaStyle mediaStyle = new MediaStyle();\n\n        // setup media style (compact notification slots and media session)\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n            // notification actions are ignored on Android 13+, and are replaced by code in\n            // MediaSessionPlayerUi\n            final int[] compactSlots = initializeNotificationSlots();\n            mediaStyle.setShowActionsInCompactView(compactSlots);\n        }\n\n        player.UIs() .get(MediaSessionPlayerUi.class) .flatMap(MediaSessionPlayerUi ::getSessionToken).ifPresent(mediaStyle ::setMediaSession);\n\n        // setup notification builder\n        builder.setStyle(mediaStyle) .setPriority(NotificationCompat.PRIORITY_HIGH) .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) .setCategory(NotificationCompat.CATEGORY_TRANSPORT) .setShowWhen(false) .setSmallIcon(R.drawable.ic_newpipe_triangle_white) .setColor(ContextCompat.getColor(player.getContext(), R.color.dark_background_color)) .setColorized(player.getPrefs() .getBoolean(player.getContext() .getString(R.string.notification_colorize_key), true)).setDeleteIntent(PendingIntentCompat.getBroadcast(player.getContext(), NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, false));\n\n        // set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n        setLargeIcon(builder);\n\n        return builder;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "160", "src_id": "M1620", "code": "\n    void fastPath(Subscriber<?\n                                super R> a,\n                                Iterator<?\n                                            extends R> iterator) {\n    for(;\n;\n) {\n        if (cancelled) {\n            return ;\n        }\n\n        R v;\n        try {\n            v = iterator.next();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            a.onError(ex);\n            return ;\n        }\n\n        a.onNext(v);\n        if (cancelled) {\n            return ;\n        }\n\n        boolean b;\n        try {\n            b = iterator.hasNext();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            a.onError(ex);\n            return ;\n        }\n\n        if (!b) {\n            a.onComplete();\n            return ;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "161", "src_id": "M1380", "code": "\n    @Override\n    public void onComplete() {\n        if (done) {\n            return ;\n        }\n\n        try {\n            onComplete.run();\n        } catch (Throwable e) {\n            fail(e);\n            return ;\n        }\n\n        done = true;\n        downstream.onComplete();\n        try {\n            onAfterTerminate.run();\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            RxJavaPlugins.onError(e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "162", "src_id": "M1939", "code": "\n    @Override\n    public void run(long n) {\n    long emitted = 0L;\n    Iterator<T> iterator = this.iterator;\n    ConditionalSubscriber<?\n                             super T> downstream = this.downstream;\n    for(;\n;\n) {\n        if (cancelled) {\n            clear();\n            break;\n        } else {\n            T next;\n            try {\n                next = Objects.requireNonNull(iterator.next(), \"The Stream's Iterator returned a null value\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                downstream.onError(ex);\n                cancelled = true;\n                continue;\n            }\n\n            if (downstream.tryOnNext(next)) {\n                emitted++;\n            }\n\n            if (cancelled) {\n                continue;\n            }\n\n            try {\n                if (!iterator.hasNext()) {\n                    downstream.onComplete();\n                    cancelled = true;\n                    continue;\n                }\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                downstream.onError(ex);\n                cancelled = true;\n                continue;\n            }\n\n            if (emitted != n) {\n                continue;\n            }\n        }\n\n        n = get();\n        if (emitted == n) {\n            if (compareAndSet(n, 0L)) {\n                break;\n            }\n\n            n = get();\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "163", "src_id": "M1099", "code": "\n    void replay(CacheSubscription<T> consumer) {\n        // make sure there is only one replay going on at a time\n        if (consumer.getAndIncrement() != 0) {\n            return ;\n        }\n\n        // see if there were more replay request in the meantime\n\n        int missed = 1;\n        // read out state into locals upfront to avoid being re-read due to volatile reads\n        long index = consumer.index;\n        int offset = consumer.offset;\n        Node<T> node = consumer.node;\n        AtomicLong requested = consumer.requested;\n        Subscriber<?\n                      super T> downstream = consumer.downstream;\n        int capacity = capacityHint;\n        for(;\n;\n) {\n            // first see if the source has terminated, read order matters!\n            boolean sourceDone = done;\n            // and if the number of items is the same as this consumer has received\n            boolean empty = size == index;\n\n            // if the source is done and we have all items so far, terminate the consumer\n            if (sourceDone && empty) {\n                // release the node object to avoid leaks through retained consumers\n                consumer.node = null;\n                // if error is not null then the source failed\n                Throwable ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n\n                return ;\n            }\n\n            // there are still items not sent to the consumer\n\n            if (!empty) {\n                // see how many items the consumer has requested in total so far\n                long consumerRequested = requested.get();\n                // MIN_VALUE indicates a cancelled consumer, we stop replaying\n                if (consumerRequested == Long.MIN_VALUE) {\n                    // release the node object to avoid leaks through retained consumers\n                    consumer.node = null;\n                    return ;\n                }\n                // if the consumer has requested more and there is more, we will emit an item\n\n                if (consumerRequested != index) {\n\n                    // if the offset in the current node has reached the node capacity\n                    if (offset == capacity) {\n                        // switch to the subsequent node\n                        node = node.next;\n                        // reset the in-node offset\n                        offset = 0;\n                    }\n\n                    // emit the cached item\n\n                    downstream.onNext(node.values[ offset ]);\n\n                    // move the node offset forward\n                    offset++;\n                    // move the total consumed item count forward\n                    index++;\n\n                    // retry for the next item/terminal event if any\n                    continue;\n                }\n            }\n\n            // commit the changed references back\n\n            consumer.index = index;\n            consumer.offset = offset;\n            consumer.node = node;\n            // release the changes and see if there were more replay request in the meantime\n            missed = consumer.addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "164", "src_id": "M284", "code": "\n    @SuppressWarnings(\"unchecked\") void drain() {\n        if (getAndIncrement() != 0) {\n            return ;\n        }\n\n        Observer<?\n                    super R> downstream = this.downstream;\n        SimpleQueue<T> queue = this.queue;\n        AtomicThrowable errors = this.errors;\n        for(;\n;\n) {\n            if (!active) {\n                if (cancelled) {\n                    queue.clear();\n                    return ;\n                }\n\n                if (!tillTheEnd) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        queue.clear();\n                        cancelled = true;\n                        errors.tryTerminateConsumer(downstream);\n                        return ;\n                    }\n                }\n\n                boolean d = done;\n                T v;\n                try {\n                    v = queue.poll();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    cancelled = true;\n                    this.upstream.dispose();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(downstream);\n                    return ;\n                }\n\n                boolean empty = v == null;\n                if (d && empty) {\n                    cancelled = true;\n                    errors.tryTerminateConsumer(downstream);\n                    return ;\n                }\n\n                if (!empty) {\n                    ObservableSource<?\n                                        extends R> o;\n                    try {\n                        o = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null ObservableSource\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelled = true;\n                        this.upstream.dispose();\n                        queue.clear();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(downstream);\n                        return ;\n                    }\n\n                    if (o instanceof Supplier) {\n                        R w;\n                        try {\n                            w = ((Supplier<R>)o).get();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            errors.tryAddThrowableOrReport(ex);\n                            continue;\n                        }\n\n                        if (w != null && !cancelled) {\n                            downstream.onNext(w);\n                        }\n\n                        continue;\n                    } else {\n                        active = true;\n                        o.subscribe(observer);\n                    }\n                }\n            }\n\n            if (decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "165", "src_id": "M1908", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return ;\n        }\n\n        int missed = 1;\n        final Subscriber<?\n                            super R> downstream = this.downstream;\n        final SimpleQueue<T> queue = this.queue;\n        final AtomicThrowable error = this.error;\n        Iterator<?\n                    extends R> iterator = this.currentIterator;\n        long requested = this.requested.get();\n        long emitted = this.emitted;\n        final int limit = prefetch - (prefetch> > 2);\n        boolean canRequest = sourceMode != QueueFuseable.SYNC;\n        for(;\n;\n) {\n            if (cancelled) {\n                queue.clear();\n                clearCurrentSuppressCloseError();\n            } else {\n                boolean isDone = upstreamDone;\n                if (error.get() != null) {\n                    downstream.onError(error.get());\n                    cancelled = true;\n                    continue;\n                }\n\n                if (iterator == null) {\n                    T t;\n                    try {\n                        t = queue.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        trySignalError(downstream, ex);\n                        continue;\n                    }\n\n                    boolean isEmpty = t == null;\n                    if (isDone && isEmpty) {\n                        downstream.onComplete();\n                        cancelled = true;\n                    } else if (!isEmpty) {\n                               if (canRequest && ++consumed == limit) {\n                                   consumed = 0;\n                                   upstream.request(limit);\n                               }\n\n                               Stream<?\n                                         extends R> stream;\n                               try {\n                                   stream = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null Stream\");\n                                   iterator = stream.iterator();\n                                   if (iterator.hasNext()) {\n                                       currentIterator = iterator;\n                                       currentCloseable = stream;\n                                   } else {\n                                       iterator = null;\n                                   }\n                               } catch (Throwable ex) {\n                                   Exceptions.throwIfFatal(ex);\n                                   trySignalError(downstream, ex);\n                               }\n\n                               continue;\n                           }\n                }\n\n                if (iterator != null && emitted != requested) {\n                    R item;\n                    try {\n                        item = Objects.requireNonNull(iterator.next(), \"The Stream.Iterator returned a null value\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        trySignalError(downstream, ex);\n                        continue;\n                    }\n\n                    if (!cancelled) {\n                        downstream.onNext(item);\n                        emitted++;\n                        if (!cancelled) {\n                            try {\n                                if (!iterator.hasNext()) {\n                                    iterator = null;\n                                    clearCurrentRethrowCloseError();\n                                }\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                trySignalError(downstream, ex);\n                            }\n                        }\n                    }\n\n                    continue;\n                }\n            }\n\n            this.emitted = emitted;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n\n            requested = this.requested.get();\n        }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1237", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return ;\n        }\n\n        final Subscriber<?\n                            super R> a = downstream;\n        final ZipSubscriber<T, R>[] qs = subscribers;\n        final int n = qs.length;\n        Object[] values = current;\n        int missed = 1;\n        for(;\n;\n) {\n            long r = requested.get();\n            long e = 0L;\n            while (r != e) {\n                if (cancelled) {\n                    return ;\n                }\n\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return ;\n                }\n\n                boolean empty = false;\n                for(int j = 0;\nj<n;\nj++) {\n                    ZipSubscriber<T, R> inner = qs[ j ];\n                    if (values[ j ] == null) {\n                        boolean d = inner.done;\n                        SimpleQueue<T> q = inner.queue;\n                        T v = null;\n                        try {\n                            v = q != null ?\n                                q.poll() : null;\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            errors.tryAddThrowableOrReport(ex);\n                            if (!delayErrors) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return ;\n                            }\n\n                            d = true;\n                        }\n\n                        boolean sourceEmpty = v == null;\n                        if (d && sourceEmpty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return ;\n                        }\n\n                        if (!sourceEmpty) {\n                            values[ j ] = v;\n                        } else {\n                            empty = true;\n                        }\n                    }\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                R v;\n                try {\n                    v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    cancelAll();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(a);\n                    return ;\n                }\n\n                a.onNext(v);\n                e++;\n                Arrays.fill(values, null);\n            }\n\n            if (r == e) {\n                if (cancelled) {\n                    return ;\n                }\n\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return ;\n                }\n\n                for(int j = 0;\nj<n;\nj++) {\n                    ZipSubscriber<T, R> inner = qs[ j ];\n                    if (values[ j ] == null) {\n                        boolean d = inner.done;\n                        SimpleQueue<T> q = inner.queue;\n                        T v = null;\n                        try {\n                            v = q != null ?\n                                q.poll() : null;\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            errors.tryAddThrowableOrReport(ex);\n                            if (!delayErrors) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return ;\n                            }\n\n                            d = true;\n                        }\n\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return ;\n                        }\n\n                        if (!empty) {\n                            values[ j ] = v;\n                        }\n                    }\n                }\n            }\n\n            if (e != 0L) {\n                for (ZipSubscriber<T, R> inner : qs) {\n                    inner.request(e);\n                }\n\n                if (r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n        }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "167", "src_id": "M409", "code": "\n    @Override Node getHead() {\n    long timeLimit = scheduler.now(unit) - maxAge;\n    Node prev = get();\n    Node next = prev.get();\n    for(;\n;\n) {\n        if (next == null) {\n            break;\n        }\n\n        Timed<?> v = (Timed<?>)next.value;\n        if (NotificationLite.isComplete(v.value())||\n            NotificationLite.isError(v.value())) {\n            break;\n        }\n\n        if (v.time() <= timeLimit) {\n            prev = next;\n            next = next.get();\n        } else {\n            break;\n        }\n    }\n\n    return prev;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "168", "src_id": "M2271", "code": "\n    @SuppressWarnings(\"unchecked\") void remove(AsyncSubscription<T> ps) {\n        for(;\n;\n) {\n            AsyncSubscription<T>[] a = subscribers.get();\n            int n = a.length;\n            if (n == 0) {\n                return ;\n            }\n\n            int j = - 1;\n            for(int i = 0;\ni<n;\ni++) {\n                if (a[ i ] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return ;\n            }\n\n            AsyncSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new\nAsyncSubscription [ n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n\n            if (subscribers.compareAndSet(a, b)) {\n                return ;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "169", "src_id": "M335", "code": "\n    @Override\n    public void onSubscribe(Disposable d) {\n        if (DisposableHelper.validate(this.upstream, d)) {\n            this.upstream = d;\n            if (d instanceof QueueDisposable) {\n                @SuppressWarnings(\"unchecked\") QueueDisposable<T> qd = (QueueDisposable<T>)d;\n                int m = qd.requestFusion(QueueDisposable.ANY);\n                if (m == QueueDisposable.SYNC) {\n                    fusionMode = m;\n                    queue = qd;\n                    done = true;\n                    downstream.onSubscribe(this);\n                    drain();\n                    return ;\n                }\n\n                if (m == QueueDisposable.ASYNC) {\n                    fusionMode = m;\n                    queue = qd;\n                    downstream.onSubscribe(this);\n                    return ;\n                }\n            }\n\n            queue = new SpscLinkedArrayQueue<>(bufferSize);\n            downstream.onSubscribe(this);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "170", "src_id": "M478", "code": "\n    private void saveDocumentToZip(PDDocument document,\n                                   ZipOutputStream zipOut,\n                                   String baseFilename,\n                                   int index) throws IOException {\n        log.debug(\"Starting saveDocumentToZip for document part {}\", index);\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n\n        try {\n            log.debug(\"Saving document part {} to byte array\", index);\n            document.save(outStream);\n            log.debug(\"Successfully saved document part {} ({} bytes)\", index, outStream.size());\n        } catch (Exception e) {\n            log.error(\"Error saving document part {} to byte array\", index, e);\n            throw ExceptionUtils.createFileProcessingException(\"split\", e);\n        }\n\n        try {\n            log.debug(\"Closing document part {}\", index);\n            document.close();\n            log.debug(\"Successfully closed document part {}\", index);\n        } catch (Exception e) {\n            log.error(\"Error closing document part {}\", index, e);\n            // Continue despite close error\n        }\n\n        try {\n            // Create a new zip entry\n            String entryName = baseFilename + \"_\" + index + \".pdf\";\n            log.debug(\"Creating ZIP entry: {}\", entryName);\n            ZipEntry zipEntry = new ZipEntry(entryName);\n            zipOut.putNextEntry(zipEntry);\n            byte [] bytes = outStream.toByteArray();\n            log.debug(\"Writing {} bytes to ZIP entry\", bytes.length);\n            zipOut.write(bytes);\n            log.debug(\"Closing ZIP entry\");\n            zipOut.closeEntry();\n            log.debug(\"Successfully added document part {} to ZIP\", index);\n        } catch (Exception e) {\n            log.error(\"Error adding document part {} to ZIP\", index, e);\n            throw ExceptionUtils.createFileProcessingException(\"split\", e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "171", "src_id": "M101", "code": "\n    private void processRequest(int limitPerDay,\n                                String identifier,\n                                Map<String, Bucket> buckets,\n                                HttpServletRequest request,\n                                HttpServletResponse response,\n                                FilterChain filterChain) throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k->createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill()/ 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "172", "src_id": "M38", "code": "\n    @SuppressWarnings(\"deprecation\")\n    public void migrateEnterpriseSettingsToPremium(ApplicationProperties applicationProperties) {\n        EnterpriseEdition enterpriseEdition = applicationProperties.getEnterpriseEdition();\n        Premium premium = applicationProperties.getPremium();\n\n        // Only proceed if both objects exist\n        if (enterpriseEdition == null||premium == null) {\n            return;\n        }\n\n        // Copy the license key if it's set in enterprise but not in premium\n\n        if (premium.getKey() == null||\"00000000-0000-0000-0000-000000000000\".equals(premium.getKey() )) {\n            if (enterpriseEdition.getKey() != null && !\"00000000-0000-0000-0000-000000000000\".equals(enterpriseEdition.getKey() )) {\n                premium.setKey(enterpriseEdition.getKey());\n            }\n        }\n\n        // Copy enabled state if enterprise is enabled but premium is not\n\n        if (!premium.isEnabled() && enterpriseEdition.isEnabled()) {\n            premium.setEnabled(true);\n        }\n\n        // Copy SSO auto login setting\n\n        if (!premium.getProFeatures() .isSsoAutoLogin() && enterpriseEdition.isSsoAutoLogin()) {\n            premium.getProFeatures().setSsoAutoLogin(true);\n        }\n\n        // Copy CustomMetadata settings\n\n        Premium.ProFeatures.CustomMetadata premiumMetadata = premium.getProFeatures() .getCustomMetadata();\n        EnterpriseEdition.CustomMetadata enterpriseMetadata = enterpriseEdition.getCustomMetadata();\n        if (enterpriseMetadata != null && premiumMetadata != null) {\n            // Copy autoUpdateMetadata setting\n            if (!premiumMetadata.isAutoUpdateMetadata() && enterpriseMetadata.isAutoUpdateMetadata()) {\n                premiumMetadata.setAutoUpdateMetadata(true);\n            }\n\n            // Copy author if not set in premium but set in enterprise\n\n            if ((premiumMetadata.getAuthor() == null||premiumMetadata.getAuthor() .trim() .isEmpty()||\"username\".equals(premiumMetadata.getAuthor() ))&& enterpriseMetadata.getAuthor() != null && !enterpriseMetadata.getAuthor() .trim() .isEmpty()) {\n                premiumMetadata.setAuthor(enterpriseMetadata.getAuthor());\n            }\n\n            // Copy creator if not set in premium but set in enterprise and different from default\n\n            if ((premiumMetadata.getCreator() == null||\"Stirling-PDF\".equals(premiumMetadata.getCreator() ))&& enterpriseMetadata.getCreator() != null && !\"Stirling-PDF\".equals(enterpriseMetadata.getCreator() )) {\n                premiumMetadata.setCreator(enterpriseMetadata.getCreator());\n            }\n\n            // Copy producer if not set in premium but set in enterprise and different from default\n\n            if ((premiumMetadata.getProducer() == null||\"Stirling-PDF\".equals(premiumMetadata.getProducer() ))&& enterpriseMetadata.getProducer() != null && !\"Stirling-PDF\".equals(enterpriseMetadata.getProducer() )) {\n                premiumMetadata.setProducer(enterpriseMetadata.getProducer());\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "173", "src_id": "M543", "code": "\n    private void applyGhostscriptCompression(OptimizePdfRequest request,\n                                             int optimizeLevel,\n                                             Path currentFile,\n                                             List<Path> tempFiles) throws IOException {\n        long preGsSize = Files.size(currentFile);\n        log.info(\"Pre-Ghostscript file size: {}\", GeneralUtils.formatBytes(preGsSize));\n\n        // Create output file for Ghostscript\n        Path gsOutputFile = Files.createTempFile(\"gs_output_\", \".pdf\");\n        tempFiles.add(gsOutputFile);\n\n        // Build Ghostscript command based on optimization level\n        List<String> command = new ArrayList<>();\n        command.add(\"gs\");\n        command.add(\"-sDEVICE=pdfwrite\");\n        command.add(\"-dCompatibilityLevel=1.5\");\n        command.add(\"-dNOPAUSE\");\n        command.add(\"-dQUIET\");\n        command.add(\"-dBATCH\");\n\n        // Map optimization levels to Ghostscript settings\n        switch(optimizeLevel) {\n            case 1:\n            command.add(\"-dPDFSETTINGS=/prepress\");\n            break;\n                              case 2:\n            command.add(\"-dPDFSETTINGS=/printer\");\n            break;\n                              case 3:\n            command.add(\"-dPDFSETTINGS=/ebook\");\n            break;\n                              case 4:\n            case 5:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            break;\n                              case 6:\n            case 7:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            command.add(\"-dColorImageResolution=150\");\n            command.add(\"-dGrayImageResolution=150\");\n            command.add(\"-dMonoImageResolution=300\");\n            break;\n                              case 8:\n            case 9:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            command.add(\"-dColorImageResolution=100\");\n            command.add(\"-dGrayImageResolution=100\");\n            command.add(\"-dMonoImageResolution=200\");\n            break;\n                              case 10:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            command.add(\"-dColorImageResolution=72\");\n            command.add(\"-dGrayImageResolution=72\");\n            command.add(\"-dMonoImageResolution=150\");\n            break;\n                              default:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            break;\n        }\n\n        command.add(\"-sOutputFile=\" + gsOutputFile.toString());\n        command.add(currentFile.toString());\n        ProcessExecutorResult returnCode = null;\n\n        try {\n            returnCode = ProcessExecutor.getInstance(ProcessExecutor.Processes.GHOSTSCRIPT) .runCommandWithOutputHandling(command);\n\n            if (returnCode.getRc() == 0) {\n                // Update current file to the Ghostscript output\n                Files.copy(gsOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n\n                long postGsSize = Files.size(currentFile);\n                double gsReduction = 100.0 - ((postGsSize*100.0)/preGsSize);\n                log.info(\"Post-Ghostscript file size: {} (reduced by {}%)\", GeneralUtils.formatBytes(postGsSize), String.format(\"%.1f\", gsReduction));\n            } else {\n                log.warn(\"Ghostscript compression failed with return code: {}\", returnCode.getRc());\n                throw new IOException(\"Ghostscript compression failed\");\n            }\n        } catch (Exception e) {\n            log.warn(\"Ghostscript compression failed, will fallback to other methods\", e);\n            throw new IOException(\"Ghostscript compression failed\", e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "174", "src_id": "M256", "code": "\n    private Object executeWithRetries(ProceedingJoinPoint joinPoint,\n                                      Object [] args,\n                                      boolean async,\n                                      long timeout,\n                                      int maxRetries,\n                                      boolean trackProgress,\n                                      boolean queueable,\n                                      int resourceWeight) {\n\n        // Keep jobId reference for progress tracking in TaskManager\n        AtomicReference<String> jobIdRef = new AtomicReference<>();\n        return jobExecutorService.runJobGeneric(async, ()-> {\n                    // Use iterative approach instead of recursion to avoid stack overflow\n                                                           Throwable lastException = null;\n\n                    // Attempt counter starts at 1 for first try\n\n                                                           for (int currentAttempt = 1; currentAttempt <= maxRetries; currentAttempt++) {\n                                                               try {\n                                                                   if (trackProgress && async) {\n                                // Get jobId for progress tracking in TaskManager\n                                // This enables REST API progress queries, not WebSocket\n                                                                       if (jobIdRef.get() == null) {\n                                                                           jobIdRef.set(getJobIdFromContext());\n                                                                       }\n\n                                                                       String jobId = jobIdRef.get();\n                                                                       if (jobId != null) {\n                                                                           log.debug(\"Tracking progress for job {} (attempt {}/{})\", jobId, currentAttempt, maxRetries);\n                                    // Progress is tracked in TaskManager for REST API access\n                                    // No WebSocket notifications sent here\n                                                                       }\n                                                                   }\n\n                            // Attempt to execute the operation\n                                                                   return joinPoint.proceed(args);\n                                                               } catch (Throwable ex) {\n                                                                   lastException = ex;\n                                                                   log.error(\"AutoJobAspect caught exception during job execution (attempt {}/{}): {}\", currentAttempt, maxRetries, ex.getMessage(), ex);\n\n                            // Check if we should retry\n\n                                                                   if (currentAttempt < maxRetries) {\n                                                                       log.info(\"Retrying operation, attempt {}/{}\", currentAttempt + 1, maxRetries);\n\n                                                                       if (trackProgress && async) {\n                                                                           String jobId = jobIdRef.get();\n                                                                           if (jobId != null) {\n                                                                               log.debug(\"Recording retry attempt for job {} in TaskManager\", jobId);\n                                        // Retry info is tracked in TaskManager for REST API access\n                                                                           }\n                                                                       }\n\n                                // Use non-blocking delay for all retry attempts to avoid blocking\n                                // threads\n                                // For sync jobs this avoids starving the tomcat thread pool under\n                                // load\n\n                                                                       long delayMs = RETRY_BASE_DELAY.toMillis()*currentAttempt;\n\n                                // Execute the retry after a delay through the JobExecutorService\n                                // rather than blocking the current thread with sleep\n                                                                       CompletableFuture<Object> delayedRetry = new CompletableFuture<>();\n\n                                // Use a delayed executor for non-blocking delay\n                                                                       CompletableFuture.delayedExecutor(delayMs, TimeUnit.MILLISECONDS).execute(()-> {\n                                                    // Continue the retry loop in the next iteration\n                                                    // We can't return from here directly since\n                                                    // we're in a Runnable\n                                                                                                                                                     delayedRetry.complete(null);\n                                                                                                                                                 });\n\n                                // Wait for the delay to complete before continuing\n                                                                       try {\n                                                                           delayedRetry.join();\n                                                                       } catch (Exception e) {\n                                                                           Thread.currentThread().interrupt();\n                                                                           break;\n                                                                       }\n                                                                   } else {\n                                // No more retries, we'll throw the exception after the loop\n                                                                       break;\n                                                                   }\n                                                               }\n                                                           }\n\n                    // If we get here, all retries failed\n\n                                                           if (lastException != null) {\n                                                               throw new RuntimeException(\"Job failed after \" + maxRetries + \" attempts: \" + lastException.getMessage(), lastException);\n                                                           }\n\n                    // This should never happen if lastException is properly tracked\n\n                                                           throw new RuntimeException(\"Job failed but no exception was recorded\");\n                                                       }, timeout, queueable, resourceWeight);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "175", "src_id": "M813", "code": "\n    public void init() {\n        // Adding endpoints to \"PageOps\" group\n        addEndpointToGroup(\"PageOps\", \"remove-pages\");\n        addEndpointToGroup(\"PageOps\", \"merge-pdfs\");\n        addEndpointToGroup(\"PageOps\", \"split-pdfs\");\n        addEndpointToGroup(\"PageOps\", \"pdf-organizer\");\n        addEndpointToGroup(\"PageOps\", \"rotate-pdf\");\n        addEndpointToGroup(\"PageOps\", \"multi-page-layout\");\n        addEndpointToGroup(\"PageOps\", \"scale-pages\");\n        addEndpointToGroup(\"PageOps\", \"adjust-contrast\");\n        addEndpointToGroup(\"PageOps\", \"crop\");\n        addEndpointToGroup(\"PageOps\", \"auto-split-pdf\");\n        addEndpointToGroup(\"PageOps\", \"extract-page\");\n        addEndpointToGroup(\"PageOps\", \"pdf-to-single-page\");\n        addEndpointToGroup(\"PageOps\", \"split-by-size-or-count\");\n        addEndpointToGroup(\"PageOps\", \"overlay-pdf\");\n        addEndpointToGroup(\"PageOps\", \"split-pdf-by-sections\");\n\n        // Adding endpoints to \"Convert\" group\n        addEndpointToGroup(\"Convert\", \"pdf-to-img\");\n        addEndpointToGroup(\"Convert\", \"img-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-pdfa\");\n        addEndpointToGroup(\"Convert\", \"file-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-word\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-presentation\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-text\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-html\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-xml\");\n        addEndpointToGroup(\"Convert\", \"html-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"url-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"markdown-to-pdf\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-csv\");\n        addEndpointToGroup(\"Convert\", \"pdf-to-markdown\");\n        addEndpointToGroup(\"Convert\", \"eml-to-pdf\");\n\n        // Adding endpoints to \"Security\" group\n        addEndpointToGroup(\"Security\", \"add-password\");\n        addEndpointToGroup(\"Security\", \"remove-password\");\n        addEndpointToGroup(\"Security\", \"change-permissions\");\n        addEndpointToGroup(\"Security\", \"add-watermark\");\n        addEndpointToGroup(\"Security\", \"cert-sign\");\n        addEndpointToGroup(\"Security\", \"remove-cert-sign\");\n        addEndpointToGroup(\"Security\", \"sanitize-pdf\");\n        addEndpointToGroup(\"Security\", \"auto-redact\");\n        addEndpointToGroup(\"Security\", \"redact\");\n\n        // Adding endpoints to \"Other\" group\n        addEndpointToGroup(\"Other\", \"ocr-pdf\");\n        addEndpointToGroup(\"Other\", \"add-image\");\n        addEndpointToGroup(\"Other\", \"compress-pdf\");\n        addEndpointToGroup(\"Other\", \"extract-images\");\n        addEndpointToGroup(\"Other\", \"change-metadata\");\n        addEndpointToGroup(\"Other\", \"extract-image-scans\");\n        addEndpointToGroup(\"Other\", \"sign\");\n        addEndpointToGroup(\"Other\", \"flatten\");\n        addEndpointToGroup(\"Other\", \"repair\");\n        addEndpointToGroup(\"Other\", \"unlock-pdf-forms\");\n        addEndpointToGroup(\"Other\", REMOVE_BLANKS);\n        addEndpointToGroup(\"Other\", \"remove-annotations\");\n        addEndpointToGroup(\"Other\", \"compare\");\n        addEndpointToGroup(\"Other\", \"add-page-numbers\");\n        addEndpointToGroup(\"Other\", \"auto-rename\");\n        addEndpointToGroup(\"Other\", \"get-info-on-pdf\");\n        addEndpointToGroup(\"Other\", \"show-javascript\");\n        addEndpointToGroup(\"Other\", \"remove-image-pdf\");\n        addEndpointToGroup(\"Other\", \"add-attachments\");\n\n        // CLI\n        addEndpointToGroup(\"CLI\", \"compress-pdf\");\n        addEndpointToGroup(\"CLI\", \"extract-image-scans\");\n        addEndpointToGroup(\"CLI\", \"repair\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-pdfa\");\n        addEndpointToGroup(\"CLI\", \"file-to-pdf\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-word\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-presentation\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-html\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-xml\");\n        addEndpointToGroup(\"CLI\", \"ocr-pdf\");\n        addEndpointToGroup(\"CLI\", \"html-to-pdf\");\n        addEndpointToGroup(\"CLI\", \"url-to-pdf\");\n        addEndpointToGroup(\"CLI\", \"pdf-to-rtf\");\n\n        // python\n        addEndpointToGroup(\"Python\", \"extract-image-scans\");\n        addEndpointToGroup(\"Python\", \"html-to-pdf\");\n        addEndpointToGroup(\"Python\", \"url-to-pdf\");\n        addEndpointToGroup(\"Python\", \"file-to-pdf\");\n\n        // openCV\n        addEndpointToGroup(\"OpenCV\", \"extract-image-scans\");\n\n        // LibreOffice\n        addEndpointToGroup(\"LibreOffice\", \"file-to-pdf\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-word\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-presentation\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-rtf\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-html\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-xml\");\n        addEndpointToGroup(\"LibreOffice\", \"pdf-to-pdfa\");\n\n        // Unoconvert\n        addEndpointToGroup(\"Unoconvert\", \"file-to-pdf\");\n\n        // Java\n        addEndpointToGroup(\"Java\", \"merge-pdfs\");\n        addEndpointToGroup(\"Java\", \"remove-pages\");\n        addEndpointToGroup(\"Java\", \"split-pdfs\");\n        addEndpointToGroup(\"Java\", \"pdf-organizer\");\n        addEndpointToGroup(\"Java\", \"rotate-pdf\");\n        addEndpointToGroup(\"Java\", \"pdf-to-img\");\n        addEndpointToGroup(\"Java\", \"img-to-pdf\");\n        addEndpointToGroup(\"Java\", \"add-password\");\n        addEndpointToGroup(\"Java\", \"remove-password\");\n        addEndpointToGroup(\"Java\", \"change-permissions\");\n        addEndpointToGroup(\"Java\", \"add-watermark\");\n        addEndpointToGroup(\"Java\", \"add-image\");\n        addEndpointToGroup(\"Java\", \"extract-images\");\n        addEndpointToGroup(\"Java\", \"change-metadata\");\n        addEndpointToGroup(\"Java\", \"cert-sign\");\n        addEndpointToGroup(\"Java\", \"remove-cert-sign\");\n        addEndpointToGroup(\"Java\", \"multi-page-layout\");\n        addEndpointToGroup(\"Java\", \"scale-pages\");\n        addEndpointToGroup(\"Java\", \"add-page-numbers\");\n        addEndpointToGroup(\"Java\", \"auto-rename\");\n        addEndpointToGroup(\"Java\", \"auto-split-pdf\");\n        addEndpointToGroup(\"Java\", \"sanitize-pdf\");\n        addEndpointToGroup(\"Java\", \"crop\");\n        addEndpointToGroup(\"Java\", \"get-info-on-pdf\");\n        addEndpointToGroup(\"Java\", \"extract-page\");\n        addEndpointToGroup(\"Java\", \"pdf-to-single-page\");\n        addEndpointToGroup(\"Java\", \"markdown-to-pdf\");\n        addEndpointToGroup(\"Java\", \"show-javascript\");\n        addEndpointToGroup(\"Java\", \"auto-redact\");\n        addEndpointToGroup(\"Java\", \"redact\");\n        addEndpointToGroup(\"Java\", \"pdf-to-csv\");\n        addEndpointToGroup(\"Java\", \"split-by-size-or-count\");\n        addEndpointToGroup(\"Java\", \"overlay-pdf\");\n        addEndpointToGroup(\"Java\", \"split-pdf-by-sections\");\n        addEndpointToGroup(\"Java\", REMOVE_BLANKS);\n        addEndpointToGroup(\"Java\", \"pdf-to-text\");\n        addEndpointToGroup(\"Java\", \"remove-image-pdf\");\n        addEndpointToGroup(\"Java\", \"pdf-to-markdown\");\n        addEndpointToGroup(\"Java\", \"add-attachments\");\n        addEndpointToGroup(\"Java\", \"compress-pdf\");\n\n        // Javascript\n        addEndpointToGroup(\"Javascript\", \"pdf-organizer\");\n        addEndpointToGroup(\"Javascript\", \"sign\");\n        addEndpointToGroup(\"Javascript\", \"compare\");\n        addEndpointToGroup(\"Javascript\", \"adjust-contrast\");\n\n        /* qpdf */\n        addEndpointToGroup(\"qpdf\", \"repair\");\n        addEndpointToGroup(\"qpdf\", \"compress-pdf\");\n\n        /* Ghostscript */\n        addEndpointToGroup(\"Ghostscript\", \"repair\");\n        addEndpointToGroup(\"Ghostscript\", \"compress-pdf\");\n\n        /* tesseract */\n        addEndpointToGroup(\"tesseract\", \"ocr-pdf\");\n\n        /* OCRmyPDF */\n        addEndpointToGroup(\"OCRmyPDF\", \"ocr-pdf\");\n\n        // Multi-tool endpoints - endpoints that can be handled by multiple tools\n        addEndpointAlternative(\"repair\", \"qpdf\");\n        addEndpointAlternative(\"repair\", \"Ghostscript\");\n        addEndpointAlternative(\"compress-pdf\", \"qpdf\");\n        addEndpointAlternative(\"compress-pdf\", \"Ghostscript\");\n        addEndpointAlternative(\"compress-pdf\", \"Java\");\n        addEndpointAlternative(\"ocr-pdf\", \"tesseract\");\n        addEndpointAlternative(\"ocr-pdf\", \"OCRmyPDF\");\n\n        // file-to-pdf has multiple implementations\n        addEndpointAlternative(\"file-to-pdf\", \"LibreOffice\");\n        addEndpointAlternative(\"file-to-pdf\", \"Python\");\n        addEndpointAlternative(\"file-to-pdf\", \"Unoconvert\");\n\n        // pdf-to-html and pdf-to-markdown can use either LibreOffice or Pdftohtml\n        addEndpointAlternative(\"pdf-to-html\", \"LibreOffice\");\n        addEndpointAlternative(\"pdf-to-html\", \"Pdftohtml\");\n        addEndpointAlternative(\"pdf-to-markdown\", \"Pdftohtml\");\n\n        // markdown-to-pdf can use either Weasyprint or Java\n        addEndpointAlternative(\"markdown-to-pdf\", \"Weasyprint\");\n        addEndpointAlternative(\"markdown-to-pdf\", \"Java\");\n\n        // Weasyprint dependent endpoints\n        addEndpointToGroup(\"Weasyprint\", \"html-to-pdf\");\n        addEndpointToGroup(\"Weasyprint\", \"url-to-pdf\");\n        addEndpointToGroup(\"Weasyprint\", \"markdown-to-pdf\");\n        addEndpointToGroup(\"Weasyprint\", \"eml-to-pdf\");\n\n        // Pdftohtml dependent endpoints\n        addEndpointToGroup(\"Pdftohtml\", \"pdf-to-html\");\n        addEndpointToGroup(\"Pdftohtml\", \"pdf-to-markdown\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "176", "src_id": "M318", "code": "\n    public static byte[] overlayImage(CustomPDFDocumentFactory pdfDocumentFactory,\n                                      byte [] pdfBytes,\n                                      byte [] imageBytes,\n                                      float x,\n                                      float y,\n                                      boolean everyPage) throws IOException {\n        PDDocument document = pdfDocumentFactory.load(pdfBytes);\n\n        // Get the first page of the PDF\n        int pages = document.getNumberOfPages();\n\n        for (int i = 0; i < pages; i++) {\n            PDPage page = document.getPage(i);\n\n            try (PDPageContentStream contentStream = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {\n                // Create an image object from the image bytes\n                PDImageXObject image = PDImageXObject.createFromByteArray(document, imageBytes, \"\");\n                // Draw the image onto the page at the specified x and y coordinates\n                contentStream.drawImage(image, x, y);\n                log.info(\"Image successfully overlayed onto PDF\");\n\n                if (!everyPage && i == 0) {\n                    break;\n                }\n            } catch (IOException e) {\n                // Log an error message if there is an issue overlaying the image onto the PDF\n                log.error(\"Error overlaying image onto PDF\", e);\n                throw e;\n            }\n        }\n        // Create a ByteArrayOutputStream to save the PDF to\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        document.save(baos);\n        log.info(\"PDF successfully saved to byte array\");\n        return baos.toByteArray();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "177", "src_id": "M310", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "178", "src_id": "M208", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "179", "src_id": "M183", "code": "\n    public Map<String, Object> captureServerMetrics() {\n        Map<String, Object> metrics = new HashMap<>();\n\n        try {\n            // Application version\n            metrics.put(\"app_version\", appVersion);\n            String deploymentType = \"JAR\"; // default\n            if (\"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\") )) {\n                deploymentType = \"EXE\";\n            } else if (isRunningInDocker()) {\n                       deploymentType = \"DOCKER\";\n                   }\n\n            metrics.put(\"deployment_type\", deploymentType);\n            metrics.put(\"mounted_config_dir\", configDirMounted);\n\n            // System info\n            metrics.put(\"os_name\", System.getProperty(\"os.name\"));\n            metrics.put(\"os_version\", System.getProperty(\"os.version\"));\n            metrics.put(\"java_version\", System.getProperty(\"java.version\"));\n            metrics.put(\"user_name\", System.getProperty(\"user.name\"));\n            metrics.put(\"user_home\", System.getProperty(\"user.home\"));\n            metrics.put(\"user_dir\", System.getProperty(\"user.dir\"));\n\n            // CPU and Memory\n            metrics.put(\"cpu_cores\", Runtime.getRuntime() .availableProcessors());\n            metrics.put(\"total_memory\", Runtime.getRuntime() .totalMemory());\n            metrics.put(\"free_memory\", Runtime.getRuntime() .freeMemory());\n\n            // Network and Server Identity\n            InetAddress localHost = InetAddress.getLocalHost();\n            metrics.put(\"ip_address\", localHost.getHostAddress());\n            metrics.put(\"hostname\", localHost.getHostName());\n            metrics.put(\"mac_address\", getMacAddress());\n\n            // JVM info\n            metrics.put(\"jvm_vendor\", System.getProperty(\"java.vendor\"));\n            metrics.put(\"jvm_version\", System.getProperty(\"java.vm.version\"));\n\n            // Locale and Timezone\n            metrics.put(\"system_language\", System.getProperty(\"user.language\"));\n            metrics.put(\"system_country\", System.getProperty(\"user.country\"));\n            metrics.put(\"timezone\", TimeZone.getDefault() .getID());\n            metrics.put(\"locale\", Locale.getDefault() .toString());\n\n            // Disk info\n            File root = new File(\".\");\n            metrics.put(\"total_disk_space\", root.getTotalSpace());\n            metrics.put(\"free_disk_space\", root.getFreeSpace());\n\n            // Process info\n            metrics.put(\"process_id\", ProcessHandle.current() .pid());\n\n            // JVM metrics\n            RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n            metrics.put(\"jvm_uptime_ms\", runtimeMXBean.getUptime());\n            metrics.put(\"jvm_start_time\", runtimeMXBean.getStartTime());\n\n            // Memory metrics\n            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n            metrics.put(\"heap_memory_usage\", memoryMXBean.getHeapMemoryUsage() .getUsed());\n            metrics.put(\"non_heap_memory_usage\", memoryMXBean.getNonHeapMemoryUsage() .getUsed());\n\n            // CPU metrics\n            OperatingSystemMXBean osMXBean = ManagementFactory.getOperatingSystemMXBean();\n            metrics.put(\"system_load_average\", osMXBean.getSystemLoadAverage());\n\n            // Thread metrics\n            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n            metrics.put(\"thread_count\", threadMXBean.getThreadCount());\n            metrics.put(\"daemon_thread_count\", threadMXBean.getDaemonThreadCount());\n            metrics.put(\"peak_thread_count\", threadMXBean.getPeakThreadCount());\n\n            // Garbage collection metrics\n            for(GarbageCollectorMXBean gcBean :ManagementFactory.getGarbageCollectorMXBeans() ) {\n                metrics.put(\"gc_\" + gcBean.getName()+ \"_count\", gcBean.getCollectionCount());\n                metrics.put(\"gc_\" + gcBean.getName()+ \"_time\", gcBean.getCollectionTime());\n            }\n\n            // Network interfaces\n\n            metrics.put(\"network_interfaces\", getNetworkInterfacesInfo());\n\n            // Docker detection and stats\n            boolean isDocker = isRunningInDocker();\n            if (isDocker) {\n                metrics.put(\"docker_metrics\", getDockerMetrics());\n            }\n\n            metrics.put(\"application_properties\", captureApplicationProperties());\n\n            if (userService != null) {\n                metrics.put(\"total_users_created\", userService.getTotalUsersCount());\n            }\n        } catch (Exception e) {\n            metrics.put(\"error\", e.getMessage());\n        }\n        return metrics;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "180", "src_id": "M483", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "181", "src_id": "M602", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "182", "src_id": "M581", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "183", "src_id": "M808", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "184", "src_id": "M456", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "185", "src_id": "M577", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "186", "src_id": "M29", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "187", "src_id": "M557", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "188", "src_id": "M193", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "189", "src_id": "M141", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "190", "src_id": "M345", "code": "\n    @Override // seekbar listener\n    public void onStopTrackingTouch(final SeekBar seekBar) {\n        if (DEBUG) {\n            Log.d(TAG, \"onStopTrackingTouch() called with: seekBar = [\" + seekBar + \"]\");\n        }\n\n        player.seekTo(seekBar.getProgress());\n        if (player.getExoPlayer() .getDuration() == seekBar.getProgress()) {\n            player.getExoPlayer().play();\n        }\n\n        binding.playbackCurrentTime.setText(getTimeString(seekBar.getProgress()));\n        animate(binding.currentDisplaySeek, false, 200, AnimationType.SCALE_AND_ALPHA);\n        animate(binding.currentSeekbarPreviewThumbnail, false, 200, AnimationType.SCALE_AND_ALPHA);\n        if (player.getCurrentState() == STATE_PAUSED_SEEK) {\n            player.changeState(STATE_BUFFERING);\n        }\n\n        if (!player.isProgressLoopRunning()) {\n            player.startProgressLoop();\n        }\n\n        showControlsThenHide();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "191", "src_id": "M374", "code": "\n    @Override\n    public boolean onMenuItemClick(@NonNull final MenuItem menuItem) {\n        if (DEBUG) {\n            Log.d(TAG, \"onMenuItemClick() called with: \" + \"menuItem = [\" + menuItem + \"], \" + \"menuItem.getItemId = [\" + menuItem.getItemId()+ \"]\");\n        }\n\n        if (menuItem.getGroupId() == POPUP_MENU_ID_QUALITY) {\n            onQualityItemClick(menuItem);\n            return true;\n        } else if (menuItem.getGroupId() == POPUP_MENU_ID_AUDIO_TRACK) {\n                   onAudioTrackItemClick(menuItem);\n                   return true;\n               } else if (menuItem.getGroupId() == POPUP_MENU_ID_PLAYBACK_SPEED) {\n                          final int speedIndex = menuItem.getItemId();\n                          final float speed = PLAYBACK_SPEEDS[speedIndex];\n                          player.setPlaybackSpeed(speed);\n                          binding.playbackSpeed.setText(formatSpeed(speed));\n                      }\n\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "192", "src_id": "M684", "code": "\n    private void monitorSubscription(final ChannelInfo info) {\n        final Consumer<Throwable> onError = (final Throwable throwable)-> {\n                                                animate(binding.channelSubscribeButton, false, 100);\n                                                showSnackBarError(new ErrorInfo(throwable, UserAction.SUBSCRIPTION_GET, \"Get subscription status\", currentInfo));\n                                            };\n        final Observable<List<SubscriptionEntity>> observable = subscriptionManager.subscriptionTable() .getSubscriptionFlowable(info.getServiceId(), info.getUrl() ) .toObservable();\n        disposables.add(observable.observeOn(AndroidSchedulers.mainThread()) .subscribe(getSubscribeUpdateMonitor(info), onError));\n        disposables.add(observable.map(List::isEmpty) .distinctUntilChanged() .observeOn(AndroidSchedulers.mainThread()) .subscribe(isEmpty ->updateSubscribeButton(!isEmpty), onError));\n        disposables.add(observable.map(List::isEmpty) .distinctUntilChanged() .skip(1) // channel has just been opened .filter(x ->NotificationHelper.areNewStreamsNotificationsEnabled(requireContext())) .observeOn(AndroidSchedulers.mainThread()) .subscribe(isEmpty -> {\n                                                                                                                                                                                                                                                                     if (!isEmpty) {\n                                                                                                                                                                                                                                                                         showNotifySnackbar();\n                                                                                                                                                                                                                                                                     }\n                                                                                                                                                                                                                                                                 }, onError));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "193", "src_id": "M754", "code": "\n    private void runOnVisible(final Consumer<AppCompatActivity> runnable) {\n        getActivityContext().ifPresentOrElse(context -> {\n                                                 if (getLifecycle() .getCurrentState() .isAtLeast(Lifecycle.State.STARTED)) {\n                                                     context.runOnUiThread(()-> {\n                                                                               runnable.accept(context);\n                                                                               inFlight(false);\n                                                                           });\n                                                 } else {\n                                                     getLifecycle().addObserver(new DefaultLifecycleObserver() {\n                                                                                    @Override\n                                                                                    public void onResume(@NonNull final LifecycleOwner owner) {\n                                                                                        getLifecycle().removeObserver(this);\n                                                                                        getActivityContext().ifPresentOrElse(context ->context.runOnUiThread(()-> {\n                                                                                                                                                                 runnable.accept(context);\n                                                                                                                                                                 inFlight(false);\n                                                                                                                                                             }), ()->inFlight(false));\n                                                                                    }\n\n                                                                                });\n                    // this trick doesn't seem to work on Android 10+ (API 29)\n                    // which places restrictions on starting activities from the background\n                                                     if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q && !context.isChangingConfigurations()) {\n                        // try to bring the activity back to front if minimised\n                                                         final Intent i = new Intent(context, RouterActivity.class);\n                                                         i.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n                                                         startActivity(i);\n                                                     }\n                                                 }\n                                             }, ()->\n                // this branch is executed if there is no activity contextinFlight(false));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "194", "src_id": "M950", "code": "\n    public static void showMetaInfoInTextView(@Nullable final List<MetaInfo> metaInfos, final TextView metaInfoTextView, final View metaInfoSeparator ,final CompositeDisposable disposables) {\n        final Context context = metaInfoTextView.getContext();\n\n        if (metaInfos == null||metaInfos.isEmpty()||!PreferenceManager.getDefaultSharedPreferences(context) .getBoolean(context.getString(R.string.show_meta_info_key), true )) {\n            metaInfoTextView.setVisibility(View.GONE);\n            metaInfoSeparator.setVisibility(View.GONE);\n        } else {\n            final StringBuilder stringBuilder = new StringBuilder();\n\n            for(final MetaInfo metaInfo :metaInfos) {\n                if (!isNullOrEmpty(metaInfo.getTitle())) {\n                    stringBuilder.append(\"<b>\") .append(metaInfo.getTitle()) .append(\"</b>\").append(Localization.DOT_SEPARATOR);\n                }\n\n                String content = metaInfo.getContent() .getContent() .trim();\n\n                if (content.endsWith(\".\")) {\n                    content = content.substring(0, content.length() - 1); // remove . at end\n                }\n\n                stringBuilder.append(content);\n                for (int i = 0; i < metaInfo.getUrls() .size(); i++) {\n                    if (i == 0) {\n                        stringBuilder.append(Localization.DOT_SEPARATOR);\n                    } else {\n                        stringBuilder.append(\"<br/><br/>\");\n                    }\n\n                    stringBuilder.append(\"<a href=\\\"\") .append(metaInfo.getUrls() .get(i)) .append(\"\\\">\") .append(capitalizeIfAllUppercase(metaInfo.getUrlTexts() .get(i) .trim())).append(\"</a>\");\n                }\n            }\n\n            metaInfoSeparator.setVisibility(View.VISIBLE);\n            TextLinkifier.fromHtml(metaInfoTextView, stringBuilder.toString(), HtmlCompat.FROM_HTML_SEPARATOR_LINE_BREAK_HEADING, null, null, disposables, SET_LINK_MOVEMENT_METHOD);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "195", "src_id": "M257", "code": "\n    @Override // own playback listener\n    public void onPlaybackSynchronize(@NonNull final PlayQueueItem item ,final\nboolean wasBlocked) {\n        if (DEBUG) {\n            Log.d(TAG, \"Playback - onPlaybackSynchronize(was blocked: \" + wasBlocked + \") called with item=[\" + item.getTitle()+ \"], url=[\" + item.getUrl()+ \"]\");\n        }\n\n        if (exoPlayerIsNull()||playQueue == null||currentItem == item) {\n            return; // nothing to synchronize\n        }\n\n        final int playQueueIndex = playQueue.indexOf(item);\n        final int playlistIndex = simpleExoPlayer.getCurrentMediaItemIndex();\n        final int playlistSize = simpleExoPlayer.getCurrentTimeline() .getWindowCount();\n        final boolean removeThumbnailBeforeSync = currentItem == null||currentItem.getServiceId() != item.getServiceId()||!currentItem.getUrl() .equals(item.getUrl());\n        currentItem = item;\n        if (playQueueIndex != playQueue.getIndex()) {\n            // wrong window (this should be impossible, as this method is called with\n            // `item=playQueue.getItem()`, so the index of that item must be equal to `getIndex()`)\n            Log.e(TAG, \"Playback - Play Queue may be not in sync: item index=[\" + playQueueIndex + \"], \" + \"queue index=[\" + playQueue.getIndex()+ \"]\");\n        } else if ((playlistSize > 0 && playQueueIndex >= playlistSize)||playQueueIndex < 0) {\n            // the queue and the player's timeline are not in sync, since the play queue index\n            // points outside of the timeline\n                   Log.e(TAG, \"Playback - Trying to seek to invalid index=[\" + playQueueIndex + \"] with playlist length=[\" + playlistSize + \"]\");\n               } else if (wasBlocked ||playlistIndex != playQueueIndex ||!isPlaying()) {\n            // either the player needs to be unblocked, or the play queue index has just been\n            // changed and needs to be synchronized, or the player is not playing\n                          if (DEBUG) {\n                              Log.d(TAG, \"Playback - Rewinding to correct index=[\" + playQueueIndex + \"], \" + \"from=[\" + playlistIndex + \"], size=[\" + playlistSize + \"].\");\n                          }\n\n                          if (removeThumbnailBeforeSync) {\n                // unset the current (now outdated) thumbnail to ensure it is not used during sync\n                              onThumbnailLoaded(null);\n                          }\n\n            // sync the player index with the queue index, and seek to the correct position\n\n                          if (item.getRecoveryPosition() != PlayQueueItem.RECOVERY_UNSET) {\n                              simpleExoPlayer.seekTo(playQueueIndex, item.getRecoveryPosition());\n                              playQueue.unsetRecovery(playQueueIndex);\n                          } else {\n                              simpleExoPlayer.seekToDefaultPosition(playQueueIndex);\n                          }\n                      }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "196", "src_id": "M887", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "197", "src_id": "M667", "code": "\n    private void updateTabLayoutPosition() {\n        final ScrollableTabLayout tabLayout = binding.mainTabLayout;\n        final ViewPager viewPager = binding.pager;\n        final boolean bottom = mainTabsPositionBottom;\n\n        // change layout params to make the tab layout appear either at the top or at the bottom\n        final var tabParams = (RelativeLayout.LayoutParams)tabLayout.getLayoutParams();\n        final var pagerParams = (RelativeLayout.LayoutParams)viewPager.getLayoutParams();\n        tabParams.removeRule(bottom ?ALIGN_PARENT_TOP:ALIGN_PARENT_BOTTOM);\n        tabParams.addRule(bottom ?ALIGN_PARENT_BOTTOM:ALIGN_PARENT_TOP);\n        pagerParams.removeRule(bottom ?BELOW:ABOVE);\n        pagerParams.addRule(bottom ?ABOVE:BELOW, R.id.main_tab_layout);\n        tabLayout.setSelectedTabIndicatorGravity(bottom ?INDICATOR_GRAVITY_TOP:INDICATOR_GRAVITY_BOTTOM);\n        tabLayout.setLayoutParams(tabParams);\n        viewPager.setLayoutParams(pagerParams);\n\n        // change the background and icon color of the tab layout:\n        // service-colored at the top, app-background-colored at the bottom\n        tabLayout.setBackgroundColor(ThemeHelper.resolveColorFromAttr(requireContext(), bottom ?android.R.attr.windowBackground:R.attr.colorPrimary));\n        @ColorInt final int iconColor = bottom ?ThemeHelper.resolveColorFromAttr(requireContext(), android.R.attr.colorAccent):Color.WHITE;\n        tabLayout.setTabRippleColor(ColorStateList.valueOf(iconColor) .withAlpha(32));\n        tabLayout.setTabIconTint(ColorStateList.valueOf(iconColor));\n        tabLayout.setSelectedTabIndicatorColor(iconColor);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "198", "src_id": "M395", "code": "\n    @Override protected void setupElementsVisibility() {\n        binding.fullScreenButton.setVisibility(View.VISIBLE);\n        binding.screenRotationButton.setVisibility(View.GONE);\n        binding.resizeTextView.setVisibility(View.GONE);\n        binding.getRoot() .findViewById(R.id.metadataView).setVisibility(View.GONE);\n        binding.queueButton.setVisibility(View.GONE);\n        binding.segmentsButton.setVisibility(View.GONE);\n        binding.moreOptionsButton.setVisibility(View.GONE);\n        binding.topControls.setOrientation(LinearLayout.HORIZONTAL);\n        binding.primaryControls.getLayoutParams().width = WRAP_CONTENT;\n        binding.secondaryControls.setAlpha(1.0f);\n        binding.secondaryControls.setVisibility(View.VISIBLE);\n        binding.secondaryControls.setTranslationY(0);\n        binding.share.setVisibility(View.GONE);\n        binding.playWithKodi.setVisibility(View.GONE);\n        binding.openInBrowser.setVisibility(View.GONE);\n        binding.switchMute.setVisibility(View.GONE);\n        binding.playerCloseButton.setVisibility(View.GONE);\n        binding.topControls.bringToFront();\n        binding.topControls.setClickable(false);\n        binding.topControls.setFocusable(false);\n        binding.bottomControls.bringToFront();\n        super.setupElementsVisibility();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "199", "src_id": "M338", "code": "\n    private void updateEndScreenThumbnail(@Nullable final Bitmap thumbnail) {\n        if (thumbnail == null) {\n            // remove end screen thumbnail\n            binding.endScreen.setImageDrawable(null);\n            return;\n        }\n\n        final float endScreenHeight = calculateMaxEndScreenThumbnailHeight(thumbnail);\n        final Bitmap endScreenBitmap = BitmapCompat.createScaledBitmap(thumbnail, (int) (thumbnail.getWidth()/(thumbnail.getHeight()/endScreenHeight)), (int)endScreenHeight, null, true);\n\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - onThumbnailLoaded() called with: \" + \"currentThumbnail = [\" + thumbnail + \"], \" + thumbnail.getWidth()+ \"x\" + thumbnail.getHeight()+ \", scaled end screen height = \" + endScreenHeight + \", scaled end screen width = \" + endScreenBitmap.getWidth());\n        }\n\n        binding.endScreen.setImageBitmap(endScreenBitmap);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1058", "code": "\n    private void startMission(Intent intent) {\n        String[] urls = intent.getStringArrayExtra(EXTRA_URLS);\n        Uri path = IntentCompat.getParcelableExtra(intent, EXTRA_PATH, Uri.class);\n        Uri parentPath = IntentCompat.getParcelableExtra(intent, EXTRA_PARENT_PATH, Uri.class);\n        int threads = intent.getIntExtra(EXTRA_THREADS, 1);\n        char kind = intent.getCharExtra(EXTRA_KIND, '?');\n        String psName = intent.getStringExtra(EXTRA_POSTPROCESSING_NAME);\n        String[] psArgs = intent.getStringArrayExtra(EXTRA_POSTPROCESSING_ARGS);\n        String source = intent.getStringExtra(EXTRA_SOURCE);\n        long nearLength = intent.getLongExtra(EXTRA_NEAR_LENGTH, 0);\n        String tag = intent.getStringExtra(EXTRA_STORAGE_TAG);\n        final var recovery = IntentCompat.getParcelableArrayListExtra(intent, EXTRA_RECOVERY_INFO, MissionRecoveryInfo.class);\n        Objects.requireNonNull(recovery);\n        StoredFileHelper storage;\n\n        try {\n            storage = new StoredFileHelper(this, parentPath, path, tag);\n        }\n\n            catch(IOException\n            e ) {\n            throw new RuntimeException(e);// this never should happen\n        }\n\n        Postprocessing ps;\n        if (psName == null) ps = null; else ps = Postprocessing.getAlgorithm(psName, psArgs);\n        final DownloadMission mission = new DownloadMission(urls, storage, kind, ps);\n        mission.threadCount = threads;\n        mission.source = source;\n        mission.nearLength = nearLength;\n        mission.recoveryInfo = recovery.toArray(new MissionRecoveryInfo[0]);\n        if (ps != null) ps.setTemporalDir(DownloadManager.pickAvailableTemporalDir(this));\n        handleConnectivityState(true);// first check the actual network status\n        mManager.startMission(mission);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1037", "code": "\n    public void pause() {\n        if (!running) return;\n        if (isPsRunning()) {\n            if (DEBUG) {\n                Log.w(TAG, \"pause during post-processing is not applicable.\");\n            }\n\n            return;\n        }\n        running = false;\n        notify(DownloadManagerService.MESSAGE_PAUSED);\n        if (init != null && init.isAlive()) {\n            // NOTE: if start() method is running ¡will no have effect!\n            init.interrupt();\n            synchronized(LOCK) {\n                resetState(false, true, ERROR_NOTHING);\n            }\n\n            return;\n        }\n\n        if (DEBUG && unknownLength) {\n            Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n        }\n        init = null;\n        pauseThreads();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "202", "src_id": "M1081", "code": "\n    void handleConnectivityState(NetworkState currentStatus ,\n                                 boolean updateOnly) {\n        if (currentStatus == mLastNetworkStatus) return;\n        mLastNetworkStatus = currentStatus;\n        if (currentStatus == NetworkState.Unavailable) return;\n        if (!mSelfMissionsControl || updateOnly) {\n            return;// don't touch anything without the user interaction\n        }\n\n        boolean isMetered = mPrefMeteredDownloads && mLastNetworkStatus == NetworkState.MeteredOperating;\n\n        synchronized(this) {\n            for(DownloadMission mission :mMissionsPending) {\n                if (mission.isCorrupt() || mission.isPsRunning()) continue;\n                if (mission.running && isMetered) {\n                    mission.pause();\n                } else if (!mission.running && !isMetered && mission.enqueued) {\n                           mission.start();\n                           if (mPrefQueueLimit) break;\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "203", "src_id": "M1099", "code": "\n    @SuppressLint(\"DefaultLocale\") private void updateProgress(ViewHolderItem h) {\n        if (h == null|| h.item == null|| h.item.mission instanceof FinishedMission) return;\n        DownloadMission mission = (DownloadMission)h.item.mission;\n        double done = mission.done;\n        long length = mission.getLength();\n        long now = System.currentTimeMillis();\n        boolean hasError = mission.errCode != ERROR_NOTHING;\n\n        // hide on error\n        // show if current resource length is not fetched\n        // show if length is unknown\n        h.progress.setMarquee(mission.isRecovering() || !hasError && (!mission.isInitialized() || mission.unknownLength));\n\n        double progress;\n        if (mission.unknownLength) {\n            progress = Double.NaN;\n            h.progress.setProgress(0.0f);\n        } else {\n            progress = done /length;\n        }\n\n        if (hasError) {\n            h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n            h.status.setText(R.string.msg_error);\n        } else if (isNotFinite(progress)) {\n                   h.status.setText(UNDEFINED_PROGRESS);\n               } else {\n                   h.status.setText(String.format(\"%.2f%%\", progress * 100));\n                   h.progress.setProgress(progress);\n               }\n\n        @StringRes\n        int state;\n        String sizeStr = Utility.formatBytes(length).concat(\"  \");\n        if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n            h.size.setText(sizeStr);\n            return;\n        } else if (!mission.running) {\n                   state = mission.enqueued ? R.string.queued : R.string.paused;\n               } else if (mission.isPsRunning()) {\n                          state = R.string.post_processing;\n                      } else if (mission.isRecovering()) {\n                                 state = R.string.recovering;\n                             } else {\n                                 state = 0;\n                             }\n\n        if (state != 0) {\n            // update state without download speed\n            h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n            h.resetSpeedMeasure();\n            return;\n        }\n\n        if (h.lastTimestamp < 0) {\n            h.size.setText(sizeStr);\n            h.lastTimestamp = now;\n            h.lastDone = done;\n            return;\n        }\n\n        long deltaTime = now - h.lastTimestamp;\n        double deltaDone = done - h.lastDone;\n        if (h.lastDone > done) {\n            h.lastDone = done;\n            h.size.setText(sizeStr);\n            return;\n        }\n\n        if (deltaDone > 0 && deltaTime > 0) {\n            float speed = (float) ((deltaDone *1000d)/deltaTime);\n            float averageSpeed = speed;\n            if (h.lastSpeedIdx < 0) {\n                Arrays.fill(h.lastSpeed, speed);\n                h.lastSpeedIdx = 0;\n            } else {\n                for (int i = 0; i < h.lastSpeed.length; i++) {\n                    averageSpeed += h.lastSpeed[i];\n                }\n                averageSpeed /= h.lastSpeed.length + 1.0f;\n            }\n\n            String speedStr = Utility.formatSpeed(averageSpeed);\n            String etaStr;\n            if (mission.unknownLength) {\n                etaStr = \"\";\n            } else {\n                long eta = (long)Math.ceil((length - done)/averageSpeed);\n                etaStr = Utility.formatBytes((long)done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n            }\n            h.size.setText(sizeStr.concat(etaStr).concat(speedStr ));\n            h.lastTimestamp = now;\n            h.lastDone = done;\n            h.lastSpeed [h.lastSpeedIdx++] = speed;\n            if (h.lastSpeedIdx >= h.lastSpeed.length) h.lastSpeedIdx = 0;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "204", "src_id": "M852", "code": "\n    public InputStream getView(final int size) {\n        if (view == null) {\n            view = new InputStream() {\n                       @Override\n                       public int read() throws\n                           IOException {\n                           if (viewSize < 1) {\n                               return -1;\n                           }\n\n                           final int res = DataReader.this.read();\n                           if (res > 0) {\n                               viewSize--;\n                           }\n\n                           return res;\n                       }\n\n                                     @Override\n                                     public int read(final byte\n                                                         [] buffer) throws\n                                         IOException {\n                                         return read(buffer, 0, buffer.length);\n                                     }\n\n                                     @Override\n                                     public int read(final byte\n                                                         [] buffer, final int offset ,\n                                                     final int count) throws\n                                         IOException {\n                                         if (viewSize < 1) {\n                                             return -1;\n                                         }\n\n                                         final int res = DataReader.this.read(buffer, offset, Math.min(viewSize, count) );\n                                         viewSize -= res;\n                                         return res;\n                                     }\n\n                                     @Override\n                                     public long skip(final long amount) throws\n                                         IOException {\n                                         if (viewSize < 1) {\n                                             return 0;\n                                         }\n\n                                         final int res = (int)DataReader.this.skipBytes(Math.min(amount, viewSize));\n                                         viewSize -= res;\n                                         return res;\n                                     }\n\n                                     @Override\n                                     public int available() {\n                                         return viewSize;\n                                     }\n\n                                     @Override\n                                     public void close() {\n                                         viewSize = 0;\n                                     }\n\n                                     @Override\n                                     public boolean markSupported() {\n                                         return false;\n                                     }\n\n                   };\n        }\n        viewSize = size;\n        return view;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "205", "src_id": "M850", "code": "\n    public int read(final byte\n                        [] buffer, final int off ,\n                    final int c) throws\n        IOException {\n        int offset = off;\n        int count = c;\n        if (readCount < 0) {\n            return -1;\n        }\n\n        int total = 0;\n        if (count >= readBuffer.length) {\n            if (readCount > 0) {\n                System.arraycopy(readBuffer, readOffset, buffer, offset, readCount);\n                readOffset += readCount;\n                offset += readCount;\n                count -= readCount;\n                total = readCount;\n                readCount = 0;\n            }\n            total += Math.max(stream.read(buffer, offset, count), 0);\n        } else {\n            while(count > 0 && !fillBuffer()) {\n                final int read = Math.min(readCount, count);\n                System.arraycopy(readBuffer, readOffset, buffer, offset, read);\n                readOffset += read;\n                readCount -= read;\n                offset += read;\n                count -= read;\n                total += read;\n            }\n        }\n        position += total;\n        return total;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "206", "src_id": "M803", "code": "\n    public void parse() throws IOException, NoSuchElementException {\n        if (selectedTrack > -1) {\n            return;\n        }\n        box = readBox(ATOM_FTYP);\n        brands = parseFtyp(box);\n        switch(brands[0]) {\n                          case BRAND_DASH: case\n                              BRAND_ISO5 :// ¿why not?\n            break;\n                          default:\n            throw new NoSuchElementException(\"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \" + boxName(brands[0]));\n        }\n\n        Moov moov = null;\n        int i;\n\n        while(box.type != ATOM_MOOF) {\n            ensure(box);\n            box = readBox();\n            switch(box.type) {\n                             case ATOM_MOOV:\n                moov = parseMoov(box);\n                break;\n                             case ATOM_SIDX: case\n                                 ATOM_MFRA :\n                break;\n            }\n        }\n\n        if (moov == null) {\n            throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n        }\n        tracks = new Mp4Track[moov.trak.length];\n        for (i = 0; i < tracks.length; i++) {\n            tracks[i] = new Mp4Track();\n            tracks[i].trak = moov.trak[i];\n            if (moov.mvexTrex != null) {\n                for(final\n                    Trex mvexTrex :moov.mvexTrex) {\n                    if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n                        tracks[i].trex = mvexTrex;\n                    }\n                }\n            }\n\n            switch(moov.trak[i].mdia.hdlr.subType) {\n                                                   case HANDLER_VIDE:\n                tracks[i].kind = TrackKind.Video;\n                break;\n                                                   case HANDLER_SOUN:\n                tracks[i].kind = TrackKind.Audio;\n                break;\n                                                   case HANDLER_SUBT:\n                tracks[i].kind = TrackKind.Subtitles;\n                break;\n                                                   default:\n                tracks[i].kind = TrackKind.Other;\n                break;\n            }\n        }\n        backupBox = box;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "207", "src_id": "M1066", "code": "\n    private void loadPendingMissions(Context ctx) {\n        File[] subs = mPendingMissionsDir.listFiles();\n        if (subs == null) {\n            Log.e(TAG, \"listFiles() returned null\");\n            return;\n        }\n\n        if (subs.length < 1) {\n            return;\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"Loading pending downloads from directory: \" + mPendingMissionsDir.getAbsolutePath());\n        }\n\n        File tempDir = pickAvailableTemporalDir(ctx);\n        Log.i(TAG, \"using '\" + tempDir + \"' as temporal directory\");\n        for(File sub :subs) {\n            if (!sub.isFile()) continue;\n            if (sub.getName().equals(\".tmp\")) continue;\n            DownloadMission mis = Utility.readFromFile(sub);\n            if (mis == null|| mis.isFinished()|| mis.hasInvalidStorage()) {\n                //noinspection ResultOfMethodCallIgnored\n                sub.delete();\n                continue;\n            }\n            mis.threads = new Thread[0];\n            boolean exists;\n\n            try {\n                mis.storage = StoredFileHelper.deserialize(mis.storage, ctx);\n                exists = !mis.storage.isInvalid() && mis.storage.existsAsFile();\n            }\n\n                catch(Exception\n                ex ) {\n                Log.e(TAG, \"Failed to load the file source of \" + mis.storage.toString(), ex);\n                mis.storage.invalidate();\n                exists = false;\n            }\n\n            if (mis.isPsRunning()) {\n                if (mis.psAlgorithm.worksOnSameFile) {\n                    // Incomplete post-processing results in a corrupted download file\n                    // because the selected algorithm works on the same file to save space.\n                    // the file will be deleted if the storage API\n                    // is Java IO (avoid showing the \"Save as...\" dialog)\n                    if (exists && mis.storage.isDirect() && !mis.storage.delete()) Log.w(TAG, \"Unable to delete incomplete download file: \" + sub.getPath());\n                }\n                mis.psState = 0;\n                mis.errCode = DownloadMission.ERROR_POSTPROCESSING_STOPPED;\n            } else if (!exists) {\n                       tryRecover(mis);\n\n                // the progress is lost, reset mission state\n                       if (mis.isInitialized()) mis.resetState(true, true, DownloadMission.ERROR_PROGRESS_LOST);\n            }\n\n            if (mis.psAlgorithm != null) {\n                mis.psAlgorithm.cleanupTemporalDir();\n                mis.psAlgorithm.setTemporalDir(tempDir);\n            }\n            mis.metadata = sub;\n            mis.maxRetry = mPrefMaxRetry;\n            mis.mHandler = mHandler;\n            mMissionsPending.add(mis);\n        }\n\n        if (mMissionsPending.size() > 1) Collections.sort(mMissionsPending, Comparator.comparingLong(Mission ::getTimestamp));\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "208", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized(this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n            while(true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) throw new RuntimeException(\"Cant create download metadata file\");\n                    }\n\n                        catch(IOException\n                        e ) {\n                        throw new RuntimeException(e);\n                    }\n\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n            if (mission.storage == null) {\n                // noting to do here\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                return;\n            }\n\n            boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "209", "src_id": "M361", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "210", "src_id": "M347", "code": "\n    private static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n        // Create attachment info with paperclip emoji before filename\n        attachmentInfo.append(\"<div class=\\\"attachment-item\\\">\").append(\"<span class=\\\"attachment-icon\\\">\").append(MimeConstants.ATTACHMENT_MARKER).append(\"</span> \").append(\"<span class=\\\"attachment-name\\\">\").append(escapeHtml(filename)).append(\"</span>\");\n\n        // Add content type and encoding info\n        if (!contentType.isEmpty()|| !encoding.isEmpty()) {\n            attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n            if (!contentType.isEmpty()) {\n                attachmentInfo.append(escapeHtml(contentType));\n            }\n            if (!encoding.isEmpty()) {\n                if (!contentType.isEmpty()) attachmentInfo.append(\", \");\n                attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n            }\n            attachmentInfo.append(\")</span>\");\n        }\n        attachmentInfo.append(\"</div>\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "211", "src_id": "M567", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "212", "src_id": "M509", "code": "\n    @ PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\") @Operation(summary = \"Convert EML to PDF\", description = \"This endpoint converts EML (email) files to PDF format with extensive\" + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\" + \" and HTML debug output. Input: EML file, Output: PDF\" + \" or HTML file. Type: SISO\")\n    public ResponseEntity<byte []> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n        MultipartFile inputFile = request.getFileInput();\n        String originalFilename = inputFile.getOriginalFilename();\n\n        // Validate input\n        if (inputFile.isEmpty()) {\n            log.error(\"No file provided for EML to PDF conversion.\");\n            return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n        }\n        if (originalFilename == null|| originalFilename.trim().isEmpty()) {\n            log.error(\"Filename is null or empty.\");\n            return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        // Validate file type - support EML\n\n        String lowerFilename = originalFilename.toLowerCase();\n        if (!lowerFilename.endsWith(\".eml\")) {\n            log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n            return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n        try {\n            byte [] fileBytes = inputFile.getBytes();\n            if (request.isDownloadHtml()) {\n                try {\n                    String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                    log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                    return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8), baseFilename + \".html\", MediaType.TEXT_HTML);\n                } catch (IOException | IllegalArgumentException e) {\n                    log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n                }\n            }\n\n            // Convert EML to PDF with enhanced options\n            try {\n                byte [] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig.getWeasyPrintPath(), // Use configured WeasyPrint path request, fileBytes, originalFilename, false, pdfDocumentFactory, tempFileManager);\n                if (pdfBytes == null|| pdfBytes.length == 0) {\n                    log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n                }\n                log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n            } catch (IllegalArgumentException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            } catch (RuntimeException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            }\n        } catch (IOException e) {\n            log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "213", "src_id": "M254", "code": "\n    private void distributedConfigureServers(int count) throws IOException {\n        StringBuilder sbClient = new StringBuilder();\n        StringBuilder sbServer = new StringBuilder();\n\n        try {\n            for (int i = 0; i < count; i++) {\n                String r [] = QuorumPeerInstance.createServer(im, i);\n\n                if (i > 0) {\n                    sbClient.append(',');\n                    sbServer.append(',');\n                }\n\n                sbClient.append(r[0]); // r[0] == \"host:clientPort\"\n                sbServer.append(r[1]); // r[1] == \"host:leaderPort:leaderElectionPort\"\n                sbServer.append(\";\" + (r[0].split(\":\"))[1]); // Appending \";clientPort\"\n            }\n\n            serverHostPort = sbClient.toString();\n            quorumHostPort = sbServer.toString();\n        }\n\n        catch(Exception e) {\n            IOException ioe = new IOException(e.getMessage());\n            ioe.setStackTrace(e.getStackTrace());\n            throw ioe;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "214", "src_id": "M39", "code": "\n    private void initComponents() {\n        setSize(toasterWidth, toasterHeight);\n        message.setFont(getToasterMessageFont());\n        JPanel externalPanel = new JPanel(new BorderLayout(1, 1));\n        externalPanel.setBackground(getBorderColor());\n        JPanel innerPanel = new JPanel(new BorderLayout(getMargin(), getMargin()));\n        innerPanel.setBackground(getToasterColor());\n        message.setBackground(getToasterColor());\n        message.setMargin(new Insets(2, 2, 2, 2));\n        message.setLineWrap(true);\n        message.setWrapStyleWord(true);\n        EtchedBorder etchedBorder = (EtchedBorder) BorderFactory.createEtchedBorder();\n        externalPanel.setBorder(etchedBorder);\n        externalPanel.add(innerPanel);\n        message.setForeground(getMessageColor());\n        innerPanel.add(iconLabel, BorderLayout.WEST);\n        innerPanel.add(message, BorderLayout.CENTER);\n        getContentPane().add(externalPanel);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "215", "src_id": "M1130", "code": "\n    public synchronized Map<String, Object> getConnectionInfo(boolean brief) {\n        Map<String, Object> info = new LinkedHashMap < >();\n        info.put(\"remote_socket_address\", getRemoteSocketAddress());\n        info.put(\"interest_ops\", getInterestOps());\n        info.put(\"outstanding_requests\", getOutstandingRequests());\n        info.put(\"packets_received\", getPacketsReceived());\n        info.put(\"packets_sent\", getPacketsSent());\n\n        if (!brief) {\n            info.put(\"session_id\", getSessionId());\n            info.put(\"last_operation\", getLastOperation());\n            info.put(\"established\", getEstablished());\n            info.put(\"session_timeout\", getSessionTimeout());\n            info.put(\"last_cxid\", getLastCxid());\n            info.put(\"last_zxid\", getLastZxid());\n            info.put(\"last_response_time\", getLastResponseTime());\n            info.put(\"last_latency\", getLastLatency());\n            info.put(\"min_latency\", getMinLatency());\n            info.put(\"avg_latency\", getAvgLatency());\n            info.put(\"max_latency\", getMaxLatency());\n        }\n\n        return info;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "216", "src_id": "M1149", "code": "\n    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                }\n\n                catch(RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                }\n\ncatch(Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n\n                // Close connections still pending on the selector. Any others\n                // with in-flight work, let drain out of the work queue.\n\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n\n            updateQueue.clear();\n        }\n\n        finally {\n            closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "217", "src_id": "M1043", "code": "\n    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n\n        if (directBuffer == null) {\n            ByteBuffer [] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n\n                if (bb.remaining() > 0) {\n                    break;\n                }\n\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {\n                    /*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining() );\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n\n                int p = b.position();\n                directBuffer.put(b);\n                b.position(p);\n\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }\n            /*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n\n            directBuffer.flip();\n            int sent = sock.write(directBuffer);\n            ByteBuffer bb;\n\n            // Remove the buffers that we have sent\n\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n\n                if (sent < bb.remaining()) {\n                    /*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }\n                /* We've sent the whole buffer, so drop the buffer */\n\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "218", "src_id": "M577", "code": "\n    public Long update(E elem, int timeout) {\n        Long prevExpiryTime = elemMap.get(elem);\n        long now = Time.currentElapsedTime();\n        Long newExpiryTime = roundToNextInterval(now + timeout);\n\n        if (newExpiryTime.equals(prevExpiryTime)) {\n            // No change, so nothing to update\n            return null;\n        }\n\n        // First add the elem to the new expiry time bucket in expiryMap.\n\n        Set < E > set = expiryMap.get(newExpiryTime);\n\n        if (set == null) {\n            // Construct a ConcurrentHashSet using a ConcurrentHashMap\n            set = Collections.newSetFromMap(new ConcurrentHashMap < >());\n            // Put the new set in the map, but only if another thread\n            // hasn't beaten us to it\n            Set < E > existingSet = expiryMap.putIfAbsent(newExpiryTime, set);\n\n            if (existingSet != null) {\n                set = existingSet;\n            }\n        }\n\n        set.add(elem);\n\n        // Map the elem to the new expiry time. If a different previous\n        // mapping was present, clean up the previous expiry bucket.\n        prevExpiryTime = elemMap.put(elem, newExpiryTime);\n\n        if (prevExpiryTime != null && !newExpiryTime.equals(prevExpiryTime)) {\n            Set < E > prevSet = expiryMap.get(prevExpiryTime);\n\n            if (prevSet != null) {\n                prevSet.remove(elem);\n            }\n        }\n\n        return newExpiryTime;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "219", "src_id": "M219", "code": "\n    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n\n            zkMap.put(connectionId, zk);\n\n           // a session should automatically expire after an amount of time\n\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n\n        return zk;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "220", "src_id": "M282", "code": "\n    @Test\n    public void testSimpleCase() throws Exception {\n        configureServers(serverCount);\n        configureClients(clientCount, SimpleClient.class, getHostPort());\n        Stat stat = new Stat();\n        startServers();\n        LOG.debug(\"Connecting to \" + getHostPort());\n        ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n        waitForConnect(zk, 10000);\n        zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        startClients();\n\n        // Check that all clients connect properly\n        for (int i = 0; i < getClientCount(); i++) {\n            for (int j = 0; j < maxTries; j++) {\n                try {\n                    byte b [] = zk.getData(\"/simpleCase/\" + i, false, stat);\n                    Assert.assertEquals(\"orig\", new String(b));\n                }\n\n                catch(NoNodeException e) {\n                    if (j + 1 == maxTries) {\n                        Assert.fail(\"Max tries exceeded on client \" + i);\n                    }\n\n                    Thread.sleep(1000);\n                }\n            }\n        }\n\n        // Kill half the servers, make a change, restart the dead\n        // servers, and then bounce the other servers one by one\n\n        for (int i = 0; i < getServerCount(); i++) {\n            stopServer(i);\n\n            if (i + 1 > getServerCount()/2) {\n                startServer(i);\n            } else if (i + 1 == getServerCount()/2) {\n                       Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                       try {\n                           zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                       }\n\n                       catch(ConnectionLossException e) {\n                           Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                           zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                       }\n\n                       for (int j = 0; j < i; j++) {\n                           LOG.info(\"Starting server \" + j);\n                           startServer(i);\n                       }\n                   }\n        }\n\n        Thread.sleep(100); // wait for things to stabilize\n        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n        try {\n            zk.getData(\"/simpleCase\", false, stat);\n        }\n\n        catch(ConnectionLossException e) {\n            Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n        }\n\n        // check that the change has propagated to everyone\n\n        for (int i = 0; i < getClientCount(); i++) {\n            for (int j = 0; j < maxTries; j++) {\n                byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n\n                if (new String(data).equals(\"new\")) {\n                    break;\n                }\n\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"max tries exceeded for \" + i);\n                }\n\n                Thread.sleep(1000);\n            }\n        }\n\n        // send out the kill signal\n\n        zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n\n        // watch for everyone to die\n        for (int i = 0; i < getClientCount(); i++) {\n            try {\n                for (int j = 0; j < maxTries; j++) {\n                    zk.getData(\"/simpleCase/\" + i, false, stat);\n\n                    if (j + 1 == maxTries) {\n                        Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                    }\n\n                    Thread.sleep(200);\n                }\n            }\n\n            catch(NoNodeException e) {\n                // Great this is what we were hoping for!\n            }\n        }\n\n        stopClients();\n        stopServers();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "221", "src_id": "M211", "code": "\n    public static void main(String [] args) throws IOException {\n        RandomAccessFileReader f = new RandomAccessFileReader(new File(args[0]));\n        long pos0 = f.getPosition();\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        System.out.println(\"=============\");\n        long pos1 = f.getPosition();\n        System.out.println(\"pos: \" + pos1);\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        System.out.println(\"=============\");\n        f.seek(pos1);\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        System.out.println(\"=============\");\n        f.seek(pos0);\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        long pos2 = f.getPosition();\n        System.out.println(\"=============\");\n        System.out.println(f.readLine());\n        f.seek(pos2);\n        System.out.println(f.readLine());\n        f.close();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "222", "src_id": "M168", "code": "\n    private StringArg readStringArg() throws IOException, FilterException {\n        int c = reader.read();\n        int last = 0;\n        if (c != '\"') {\n            throw new FilterException(\"Check the parser, trying to read a string that doesn't begin with quotes\");\n        }\n        StringBuffer buffer = new StringBuffer();\n        while(reader.ready()) {\n            last = c;\n            c = reader.read();\n            if (c == - 1) {\n                break;\n            }\n            if (c == '\"' && last != '\\\\') {\n                return new StringArg(buffer.toString());\n            } else {\n                buffer.append((char) c);\n            }\n        }\n        throw new FilterException(\"Unterminated string\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "223", "src_id": "M196", "code": "\n    public static void main(String [] args) throws IOException {\n        MergedLogSource source = new MergedLogSource(args);\n        PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n        PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n        PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n        PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n        LogIterator iter;\n        System.out.println(source);\n        iter = source.iterator();\n\n\n        long currentms = 0;\n        long currentsec = 0;\n        long currentmin = 0;\n        long currenthour = 0;\n        Set<Long> zxids_ms = new HashSet <Long>();\n        long zxid_sec = 0;\n        long zxid_min = 0;\n        long zxid_hour = 0;\n        while(iter.hasNext()) {\n            LogEntry e = iter.next();\n            TransactionEntry cxn = (TransactionEntry) e;\n            long ms = cxn.getTimestamp();\n            long sec = ms / MS_PER_SEC;\n            long min = ms / MS_PER_MIN;\n            long hour = ms / MS_PER_HOUR;\n            if (currentms != ms && currentms != 0) {\n                ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n                zxid_sec += zxids_ms.size();\n                zxid_min += zxids_ms.size();\n                zxid_hour += zxids_ms.size();\n                zxids_ms.clear();\n            }\n            if (currentsec != sec && currentsec != 0) {\n                ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n                zxid_sec = 0;\n            }\n            if (currentmin != min && currentmin != 0) {\n                ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n                zxid_min = 0;\n            }\n            if (currenthour != hour && currenthour != 0) {\n                ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n                zxid_hour = 0;\n            }\n            currentms = ms;\n            currentsec = sec;\n            currentmin = min;\n            currenthour = hour;\n            zxids_ms.add(cxn.getZxid());\n        }\n        iter.close();\n        ps_ms.close();\n        ps_sec.close();\n        ps_min.close();\n        ps_hour.close();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "224", "src_id": "M174", "code": "\n    private LogEntry readNextEntry() {\n        LogEntry e = null;\n        try {\n            long crcValue;\n            byte [] bytes;\n            try {\n                crcValue = logStream.readLong(\"crcvalue\");\n                bytes = logStream.readBuffer(\"txnEntry\");\n            }\n                catch(EOFException ex) {\n                return null;\n            }\n            if (bytes.length == 0) {\n                return null;\n            }\n            Checksum crc = new Adler32();\n            crc.update(bytes, 0, bytes.length);\n            if (crcValue != crc.getValue()) {\n                throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n            }\n            TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n            TxnHeader hdr = logEntry.getHeader();\n            Record r = logEntry.getTxn();\n            switch(hdr.getType()) {\n                case OpCode.createSession: {\n                                               e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n                                           }\n                                           break;\n                case OpCode.closeSession: {\n                                              e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n                                          }\n                                          break;\n                case OpCode.create:\n                if (r != null) {\n                    CreateTxn create = (CreateTxn) r;\n                    String path = create.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n                }\n                break;\n                case OpCode.setData:\n                if (r != null) {\n                    SetDataTxn set = (SetDataTxn) r;\n                    String path = set.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n                }\n                break;\n                case OpCode.setACL:\n                if (r != null) {\n                    SetACLTxn setacl = (SetACLTxn) r;\n                    String path = setacl.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n                }\n                break;\n                case OpCode.error:\n                if (r != null) {\n                    ErrorTxn error = (ErrorTxn) r;\n                    e = new TransactionEntry(hdr.getTime(),\n                                             hdr.getClientId(),\n                                             hdr.getCxid(),\n                                             hdr.getZxid(),\n                                             \"error\",\n                                             \"Error: \" + error.getErr());\n                }\n                break;\n                default:\n                LOG.info(\"Unknown op: \" + hdr.getType());\n                break;\n}\n            if (logStream.readByte(\"EOR\") != 'B') {\n                throw new EOFException(\"Last transaction was partial.\");\n            }\n        }\n            catch(Exception ex) {\n            LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n            return null;\n        }\n        return e;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "225", "src_id": "M1149", "code": "\n    public void run() {\n        try {\n            while(!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                }\n                    catch(RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                }\n                    catch(Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n\n                // Close connections still pending on the selector. Any others\n                // with in-flight work, let drain out of the work queue.\n            for(SelectionKey key :selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n            SocketChannel accepted;\n            while((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n            updateQueue.clear();\n        }\n            finally {\n            closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "226", "src_id": "M286", "code": "\n    public void reconfigureInstance(String name,\n                                    String params) throws NoAssignmentException, InterruptedException, KeeperException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n        }\n        Assigned assigned = instanceToAssignment.get(name);\n        if (assigned == null) {\n            throw new NoAssignmentException();\n        }\n        KeeperException lastException = null;\n        for (int i = 0; i < maxTries; i++) {\n            try {\n                zk.setData(assignmentsNode + '/' + assigned.container + '/' + name,\n                           (\"update \" + params).getBytes(),\n                           - 1);\n                break;\n            }\n                catch(ConnectionLossException e) {\n                lastException = e;\n            }\n        }\n        if (lastException != null) {\n            throw lastException;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "227", "src_id": "M1046", "code": "\n    public static void closeSock(SocketChannel sock) {\n        if (!sock.isOpen()) {\n            return;\n        }\n        try {\n            /*\n             * The following sequence of code is stupid! You would think that\n             * only sock.close() is needed, but alas, it doesn't work that way.\n             * If you just do sock.close() there are cases where the socket\n             * doesn't actually close...\n             */\n            sock.socket().shutdownOutput();\n        }\n            catch(IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during output shutdown\", e);\n        }\n        try {\n            sock.socket().shutdownInput();\n        }\n            catch(IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during input shutdown\", e);\n        }\n        try {\n            sock.socket().close();\n        }\n            catch(IOException e) {\n            LOG.debug(\"ignoring exception during socket close\", e);\n        }\n        try {\n            sock.close();\n        }\n            catch(IOException e) {\n            LOG.debug(\"ignoring exception during socketchannel close\", e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "228", "src_id": "M149", "code": "\n    String handleRequest(JsonRequest request) throws Exception {\n        long starttime = 0;\n        long endtime = 0;\n        long period = 0;\n        FilterOp fo = null;\n        starttime = request.getNumber(\"start\", 0);\n        endtime = request.getNumber(\"end\", 0);\n        period = request.getNumber(\"period\", 0);\n        String filterstr = request.getString(\"filter\", \"\");\n        if (filterstr.length()> 0) {\n            fo = new FilterParser(filterstr).parse();\n        }\n        if (starttime == 0) {\n            starttime = source.getStartTime();\n        }\n        if (endtime == 0) {\n            if (period > 0) {\n                endtime = starttime + period;\n            } else {\n                endtime = starttime + DEFAULT_PERIOD;\n            }\n        }\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", period=\" + period + \")\");\n        }\n        LogIterator iterator = (fo != null)\n            ? source.iterator(starttime, endtime, fo) : source.iterator(starttime, endtime);\n        return new JsonGenerator(iterator).toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "229", "src_id": "M370", "code": "\n    @Override void cleanup() {\n        if (sockKey != null) {\n            SocketChannel sock = (SocketChannel) sockKey.channel();\n            sockKey.cancel();\n            try {\n                sock.socket().shutdownInput();\n            }\n                catch(IOException e) {\n                LOG.debug(\"Ignoring exception during shutdown input\", e);\n            }\n            try {\n                sock.socket().shutdownOutput();\n            }\n                catch(IOException e) {\n                LOG.debug(\"Ignoring exception during shutdown output\", e);\n            }\n            try {\n                sock.socket().close();\n            }\n                catch(IOException e) {\n                LOG.debug(\"Ignoring exception during socket close\", e);\n            }\n            try {\n                sock.close();\n            }\n                catch(IOException e) {\n                LOG.debug(\"Ignoring exception during channel close\", e);\n            }\n        }\n        try {\n            Thread.sleep(100);\n        }\n            catch(InterruptedException e) {\n            LOG.debug(\"SendThread interrupted during sleep, ignoring\");\n        }\n        sockKey = null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "230", "src_id": "M40", "code": "\n    protected void animateVertically(int posx,\n                                     int fromY,\n                                     int toY) throws InterruptedException {\n        toaster.setLocation(posx, fromY);\n        if (toY < fromY) {\n            for (int i = fromY; i > toY; i -= step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        } else {\n            for (int i = fromY; i < toY; i += step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        }\n        toaster.setLocation(posx, toY);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "231", "src_id": "M1043", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "232", "src_id": "M1050", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "233", "src_id": "M870", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "234", "src_id": "M1024", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "235", "src_id": "M1106", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "236", "src_id": "M1055", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "237", "src_id": "M877", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "238", "src_id": "M1079", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "239", "src_id": "M1036", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "240", "src_id": "M951", "code": "\n    @Override protected void subscribeActual(CompletableObserver observer) {\n        InnerCompletableCache inner = new InnerCompletableCache(observer);\n        observer.onSubscribe(inner);\n        if (add(inner)) {\n            if (inner.isDisposed()) {\n                remove(inner);\n            }\n\n            if (once.compareAndSet(\n                false, true)) {\n                source.subscribe(this);\n            }\n        } else {\n            Throwable ex = error;\n            if (ex != null) {\n                observer.onError(ex);\n            } else {\n                observer.onComplete();\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "241", "src_id": "M961", "code": "\n    @Override\n    public boolean tryOnError(Throwable t) {\n        if (t == null) {\n            t =\n                ExceptionHelper.createNullPointerException(\"onError called with a null Throwable.\");\n        }\n\n        if (get() != DisposableHelper.DISPOSED) {\n            Disposable d = getAndSet(DisposableHelper.DISPOSED);\n            if (d != DisposableHelper.DISPOSED) {\n                try {\n                    downstream.onError(t);\n                }\n\n                finally {\n                        if (d != null) {\n                            d.dispose();\n                        }\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "242", "src_id": "M453", "code": "\n    @ SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource <? extends R>> mapper) {\n        if (source instanceof Supplier) {\n            T t;\n            try {\n                t =\n                    ((Supplier <T>)source)\n.get();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (t == null) {\n                EmptyDisposable.complete(observer);\n                return true;\n            }\n\n            ObservableSource<? extends R> r;\n            try {\n                r =\n                    Objects.requireNonNull(\n                        mapper.apply(t), \"The mapper returned a null ObservableSource\");\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (r instanceof Supplier) {\n                R u;\n                try {\n                    u =\n                        ((Supplier <R>)r)\n.get();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptyDisposable.error(ex, observer);\n                    return true;\n                }\n\n                if (u == null) {\n                    EmptyDisposable.complete(observer);\n                    return true;\n                }\n\n                ScalarDisposable<R> sd = new ScalarDisposable <>(observer, u);\n                observer.onSubscribe(sd);\n                sd.run();\n            } else {\n                r.subscribe(observer);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "243", "src_id": "M267", "code": "\n    void drainLoop() {\n        int missed = 1;\n        Observer<? super R> a = downstream;\n        AtomicInteger n = active;\n        AtomicReference<SpscLinkedArrayQueue <R>> qr = queue;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n\n                if (!delayErrors) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                }\n\n                boolean d = n.get() == 0;\n                SpscLinkedArrayQueue<R> q = qr.get();\n                R v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                a.onNext(v);\n            }\n\n            missed =\n                addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "244", "src_id": "M1163", "code": "\n    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        final SimplePlainQueue<Object> queue = this.queue;\n        final Subscriber<? super Flowable <T>> downstream = this.downstream;\n        UnicastProcessor<T> window = this.window;\n        for (;;) {\n            if (upstreamCancelled) {\n                queue.clear();\n                window =\n                    null;\n                this.window =\n                    null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n\n                        downstream.onComplete();\n                    }\n\n                    cleanupResources();\n                    upstreamCancelled =\n                        true;\n                    continue;\n                } else if (!isEmpty) {\n                           if (o instanceof WindowBoundaryRunnable) {\n                               WindowBoundaryRunnable boundary = (WindowBoundaryRunnable)o;\n                               if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                                   this.count =\n                                       0;\n                                   window =\n                                       createNewWindow(window);\n                               }\n                           } else if (window != null) {\n                                      @ SuppressWarnings(\"unchecked\") T item = (T)o;\n                                      window.onNext(item);\n\n\n                                      long count = this.count + 1;\n                                      if (count == maxSize) {\n                                          this.count =\n                                              0;\n                                          window =\n                                              createNewWindow(window);\n                                      } else {\n                                          this.count =\n                                              count;\n                                      }\n                                  }\n\n                           continue;\n                       }\n            }\n\n            missed =\n                addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "245", "src_id": "M598", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        Subscriber<? super R> a = downstream;\n        Iterator<? extends R> iterator = this.it;\n        if (outputFused && iterator != null) {\n            a.onNext(null);\n            a.onComplete();\n            return;\n        }\n\n        int missed = 1;\n        for (;;) {\n            if (iterator != null) {\n                long r = requested.get();\n                if (r == Long.MAX_VALUE) {\n                    fastPath(a, iterator);\n                    return;\n                }\n\n                long e = 0L;\n                while(e != r) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    R v;\n                    try {\n                        v =\n                            Objects.requireNonNull(\n                                iterator.next(), \"The iterator returned a null value\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        a.onError(ex);\n                        return;\n                    }\n\n                    a.onNext(v);\n                    if (cancelled) {\n                        return;\n                    }\n\n                    e++;\n\n\n                    boolean b;\n                    try {\n                        b =\n                            iterator.hasNext();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        a.onError(ex);\n                        return;\n                    }\n\n                    if (!b) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n\n                if (e != 0L) {\n                    BackpressureHelper.produced(requested, e);\n                }\n            }\n\n            missed =\n                addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n\n            if (iterator == null) {\n                iterator =\n                    it;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "246", "src_id": "M1224", "code": "\n    void drainLoop() {\n        Subscriber<? super T> actual = this.downstream;\n        int missed = 1;\n        long e = emitted;\n        int c = consumed;\n        int lim = limit;\n        for (;;) {\n            long r = requested.get();\n            while(e != r) {\n                if (cancelled) {\n                    singleItem =\n                        null;\n                    queue =\n                        null;\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    singleItem =\n                        null;\n                    queue =\n                        null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                int os = otherState;\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem =\n                        null;\n                    otherState =\n                        OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os =\n                        OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                    e++;\n                    continue;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                T v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue =\n                        null;\n                    actual.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                actual.onNext(v);\n                e++;\n                if (++c == lim) {\n                    c =\n                        0;\n                    mainSubscription.get().request(lim);\n                }\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    singleItem =\n                        null;\n                    queue =\n                        null;\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    singleItem =\n                        null;\n                    queue =\n                        null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                boolean empty = q == null || q.isEmpty();\n                if (d && empty && otherState == 2) {\n                    queue =\n                        null;\n                    actual.onComplete();\n                    return;\n                }\n            }\n\n            emitted =\n                e;\n            consumed =\n                c;\n            missed =\n                addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "247", "src_id": "M142", "code": "\n    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Subscriber<? super R> downstream = this.downstream;\n        ErrorMode errorMode = this.errorMode;\n        SimpleQueue<T> queue = this.queue;\n        AtomicThrowable errors = this.errors;\n        AtomicLong requested = this.requested;\n        int limit = prefetch - (prefetch>> 1);\n        boolean syncFused = this.syncFused;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    queue.clear();\n                    item =\n                        null;\n                    break;\n                }\n\n                int s = state;\n                if (errors.get() != null) {\n                    if (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) {\n                        queue.clear();\n                        item =\n                            null;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                if (s == STATE_INACTIVE) {\n                    boolean d = done;\n                    T v;\n                    try {\n                        v =\n                            queue.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    boolean empty = v == null;\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (!syncFused) {\n                        int c = consumed + 1;\n                        if (c == limit) {\n                            consumed =\n                                0;\n                            upstream.request(limit);\n                        } else {\n                            consumed =\n                                c;\n                        }\n                    }\n\n                    MaybeSource<? extends R> ms;\n                    try {\n                        ms =\n                            Objects.requireNonNull(\n                                mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        upstream.cancel();\n                        queue.clear();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    state =\n                        STATE_ACTIVE;\n                    ms.subscribe(inner);\n                    break;\n                } else if (s == STATE_RESULT_VALUE) {\n                           long e = emitted;\n                           if (e != requested.get()) {\n                               R w = item;\n                               item =\n                                   null;\n                               downstream.onNext(w);\n                               emitted =\n                                   e + 1;\n                               state =\n                                   STATE_INACTIVE;\n                           } else {\n                               break;\n                           }\n                       } else {\n                           break;\n                       }\n            }\n\n            missed =\n                addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "248", "src_id": "M2196", "code": "\n    @ SuppressWarnings(\"unchecked\") void remove(@NonNull SingleDisposable<T> inner) {\n        for (;;) {\n            SingleDisposable<T>[] a = observers.get();\n            int n = a.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == inner) {\n                    j =\n                        i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            SingleDisposable<T>[] b;\n            if (n == 1) {\n                b =\n                    EMPTY;\n            } else {\n                b =\n                    new SingleDisposable [n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(\n                a, b)) {\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "249", "src_id": "M2269", "code": "\n    @Override protected void subscribeActual(@NonNull Subscriber<? super T> s) {\n        AsyncSubscription<T> as = new AsyncSubscription <>(s, this);\n        s.onSubscribe(as);\n        if (add(as)) {\n            if (as.isCancelled()) {\n                remove(as);\n            }\n        } else {\n            Throwable ex = error;\n            if (ex != null) {\n                s.onError(ex);\n            } else {\n                T v = value;\n                if (v != null) {\n                    as.complete(v);\n                } else {\n                    as.onComplete();\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "250", "src_id": "M343", "code": "\n    private static EmailContent extractEmailContentAdvanced(byte[] emlBytes, EmlToPdfRequest request) {\n    try {\n            // Use Jakarta Mail for processing\n        Class<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n        Class<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n        Method getDefaultInstance = sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n        Object session = getDefaultInstance.invoke(null, new Properties());\n\n            // Cast the session object to the proper type for the constructor\n        Class<?>[] constructorArgs = new\nClass<?>[]{sessionClass, InputStream.class};\n        Constructor<?> mimeMessageConstructor = mimeMessageClass.getConstructor(constructorArgs);\n        Object message = mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n        return extractEmailContentAdvanced(message, request);\n    } catch (ReflectiveOperationException e) {\n            // Create basic EmailContent from basic processing\n      EmailContent content = new EmailContent();\n      content.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n      return content;\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "251", "src_id": "M347", "code": "\n    private static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n        // Create attachment info with paperclip emoji before filename\n    attachmentInfo.append(\"<div class=\\\"attachment-item\\\">\").append(\"<span class=\\\"attachment-icon\\\">\").append(MimeConstants.ATTACHMENT_MARKER).append(\"</span> \").append(\"<span class=\\\"attachment-name\\\">\").append(escapeHtml(filename)).append(\"</span>\");\n\n        // Add content type and encoding info\n    if (!contentType.isEmpty()||!encoding.isEmpty()) {\n        attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n        if (!contentType.isEmpty()) {\n                                                         attachmentInfo.append(escapeHtml(contentType));\n        }\n        if (!encoding.isEmpty()) {\n                                                         if (!contentType.isEmpty()) attachmentInfo.append(\", \");\n                                                         attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n        }\n        attachmentInfo.append(\")</span>\");\n    }\n    attachmentInfo.append(\"</div>\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "252", "src_id": "M361", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "253", "src_id": "M509", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n    @Operation(summary = \"Convert EML to PDF\", description = \"This endpoint converts EML (email) files to PDF format with extensive\" + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\" + \" and HTML debug output. Input: EML file, Output: PDF\" + \" or HTML file. Type: SISO\")\n    public ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n    MultipartFile inputFile = request.getFileInput();\n    String originalFilename = inputFile.getOriginalFilename();\n\n        // Validate input\n    if (inputFile.isEmpty()) {\n        log.error(\"No file provided for EML to PDF conversion.\");\n        return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n    }\n    if (originalFilename == null ||\n        originalFilename.trim().isEmpty()) {\n        log.error(\"Filename is null or empty.\");\n        return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n    }\n\n        // Validate file type - support EML\n\n    String lowerFilename = originalFilename.toLowerCase();\n    if (!lowerFilename.endsWith(\".eml\")) {\n        log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n        return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n    try {\n        byte[] fileBytes = inputFile.getBytes();\n        if (request.isDownloadHtml()) {\n        try {\n            String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n            log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n            return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8),\n                baseFilename+ \".html\",\n                MediaType.TEXT_HTML);\n        } catch (IOException| IllegalArgumentException e) {\n          log.error(\"HTML conversion failed for {}\", originalFilename, e);\n          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n        }\n        }\n\n            // Convert EML to PDF with enhanced options\n        try {\n        byte[] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig.getWeasyPrintPath(), // Use configured WeasyPrint path\n            request,\n            fileBytes,\n            originalFilename, false,\n            pdfDocumentFactory,\n            tempFileManager);\n        if (pdfBytes == null ||\n            pdfBytes.length == 0) {\n            log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n        }\n        log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n        return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n        }\ncatch (IllegalArgumentException e) {\nString errorMessage = buildErrorMessage(e, originalFilename);\nlog.error(\"EML to PDF conversion failed for {}: {}\",\noriginalFilename,\nerrorMessage,\ne);\nreturn ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        }\ncatch (RuntimeException e) {\nString errorMessage = buildErrorMessage(e, originalFilename);\nlog.error(\"EML to PDF conversion failed for {}: {}\",\noriginalFilename,\nerrorMessage,\ne);\nreturn ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        }\n    } catch (IOException e) {\n      log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "254", "src_id": "M1281", "code": "\n    @Override protected void subscribeActual(Subscriber<? super T> s) {\n        PublishConnection<T> conn;\n        for (;;) {\n            conn = current.get();\n\n            // don't create a fresh connection if the current is disposed\n            if (conn == null) {\n                PublishConnection<T> fresh = new PublishConnection<>(current, bufferSize);\n                if (!current.compareAndSet(conn, fresh)) {\n                    continue;\n                }\n\n                conn = fresh;\n            }\n\n            break;\n        }\n\n        InnerSubscription<T> inner = new InnerSubscription<>(s, conn);\n\n        s.onSubscribe(inner);\n        if (conn.add(inner)) {\n            if (inner.isCancelled()) {\n                conn.remove(inner);\n            } else {\n                conn.drain();\n            }\n\n            return;\n        }\n\n        Throwable ex = conn.error;\n        if (ex != null) {\n            inner.downstream.onError(ex);\n        } else {\n            inner.downstream.onComplete();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "255", "src_id": "M1061", "code": "\n    @Override Node getHead() {\n        long timeLimit = scheduler.now(unit) - maxAge;\n\n        Node prev = get();\n\n        Node next = prev.get();\n        for (;;) {\n            if (next == null) {\n                break;\n            }\n\n            Timed<?> v = (Timed<?>) next.value;\n            if (NotificationLite.isComplete(v.value())\n                    || NotificationLite.isError(v.value())) {\n                break;\n            }\n            if (v.time()<= timeLimit) {\n                prev = next;\n                next = next.get();\n            } else {\n                break;\n            }\n        }\n\n        return prev;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "256", "src_id": "M125", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n\n        Subscriber<? super R> downstream = this.downstream;\n\n        AtomicThrowable errors = this.errors;\n\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n\n        AtomicLong requested = this.requested;\n\n        long emitted = this.emitted;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n                if (errors.get() != null) {\n                    if (!delayErrors) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean d = done;\n\n                SwitchMapMaybeObserver<R> current = inner.get();\n\n                boolean empty = current == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (empty\n|| current.item == null|| emitted == requested.get()) {\n                    break;\n                }\n\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n                emitted++;\n            }\n\n            this.emitted = emitted;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "257", "src_id": "M341", "code": "\n    @Override\n    public void run() {\n        for (;;) {\n            if (disposed) {\n                queue.clear();\n                return;\n            }\n            if (!active) {\n                boolean d = done;\n\n                T t;\n                try {\n                    t = queue.poll();\n                } catch (Throwable ex) {\n                                           Exceptions.throwIfFatal(ex);\n                                           dispose();\n                                           queue.clear();\n                                           downstream.onError(ex);\n                                           worker.dispose();\n                                           return;\n                                       }\n\n                boolean empty = t == null;\n                if (d && empty) {\n                    disposed = true;\n                    downstream.onComplete();\n                    worker.dispose();\n                    return;\n                }\n                if (!empty) {\n                    ObservableSource<? extends U> o;\n                    try {\n                        o = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n                    } catch (Throwable ex) {\n                                               Exceptions.throwIfFatal(ex);\n                                               dispose();\n                                               queue.clear();\n                                               downstream.onError(ex);\n                                               worker.dispose();\n                                               return;\n                                           }\n\n                    active = true;\n                    o.subscribe(inner);\n                }\n            }\n            if (decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "258", "src_id": "M55", "code": "\n    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n\n        Observer<? super R> downstream = this.downstream;\n\n        ErrorMode errorMode = this.errorMode;\n\n        SimpleQueue<T> queue = this.queue;\n\n        AtomicThrowable errors = this.errors;\n        for (;;) {\n            for (;;) {\n                if (disposed) {\n                    queue.clear();\n                    item = null;\n                    break;\n                }\n\n                int s = state;\n                if (errors.get() != null) {\n                    if (errorMode == ErrorMode.IMMEDIATE\n                            || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) {\n                        queue.clear();\n                        item = null;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n                if (s == STATE_INACTIVE) {\n                    boolean d = done;\n\n                    T v;\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable ex) {\n                                               Exceptions.throwIfFatal(ex);\n                                               disposed = true;\n                                               upstream.dispose();\n                                               errors.tryAddThrowableOrReport(ex);\n                                               errors.tryTerminateConsumer(downstream);\n                                               return;\n                                           }\n\n                    boolean empty = v == null;\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                    if (empty) {\n                        break;\n                    }\n\n                    MaybeSource<? extends R> ms;\n                    try {\n                        ms = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                    } catch (Throwable ex) {\n                                               Exceptions.throwIfFatal(ex);\n                                               upstream.dispose();\n                                               queue.clear();\n                                               errors.tryAddThrowableOrReport(ex);\n                                               errors.tryTerminateConsumer(downstream);\n                                               return;\n                                           }\n\n                    state = STATE_ACTIVE;\n                    ms.subscribe(inner);\n                    break;\n                } else if (s == STATE_RESULT_VALUE) {\n                           R w = item;\n\n                           item = null;\n                           downstream.onNext(w);\n                           state = STATE_INACTIVE;\n                } else {\n                           break;\n                       }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "259", "src_id": "M1425", "code": "\n    @Override\n    public void run() {\n        for (;;) {\n            if (cancelled) {\n                return;\n            }\n            if (!active) {\n                boolean d = done;\n                if (d && !veryEnd) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n                }\n\n                T v;\n                try {\n                    v = queue.poll();\n                } catch (Throwable e) {\n                                          Exceptions.throwIfFatal(e);\n                                          upstream.cancel();\n                                          errors.tryAddThrowableOrReport(e);\n                                          errors.tryTerminateConsumer(downstream);\n                                          worker.dispose();\n                                          return;\n                                      }\n\n                boolean empty = v == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    worker.dispose();\n                    return;\n                }\n                if (!empty) {\n                    Publisher<? extends R> p;\n                    try {\n                        p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                    } catch (Throwable e) {\n                                              Exceptions.throwIfFatal(e);\n                                              upstream.cancel();\n                                              errors.tryAddThrowableOrReport(e);\n                                              errors.tryTerminateConsumer(downstream);\n                                              worker.dispose();\n                                              return;\n                                          }\n                    if (sourceMode != QueueSubscription.SYNC) {\n                        int c = consumed + 1;\n                        if (c == limit) {\n                            consumed = 0;\n                            upstream.request(c);\n                        } else {\n                            consumed = c;\n                        }\n                    }\n                    if (p instanceof Supplier) {\n                        @ SuppressWarnings(\"unchecked\") Supplier<R> supplier = (Supplier<R>) p;\n\n                        R vr;\n                        try {\n                            vr = supplier.get();\n                        } catch (Throwable e) {\n                                                  Exceptions.throwIfFatal(e);\n                                                  errors.tryAddThrowableOrReport(e);\n                                                  if (!veryEnd) {\n                                                      upstream.cancel();\n                                                      errors.tryTerminateConsumer(downstream);\n                                                      worker.dispose();\n                                                      return;\n                                                  }\n\n                                                  vr = null;\n                                              }\n                        if (vr == null\n                                || cancelled) {\n                            continue;\n                        }\n                        if (inner.isUnbounded()) {\n                            downstream.onNext(vr);\n                            continue;\n                        } else {\n                            active = true;\n                            inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                        }\n                    } else {\n                        active = true;\n                        p.subscribe(inner);\n                    }\n                }\n            }\n            if (decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "260", "src_id": "M1003", "code": "\n    void drain() {\n        if (wip.getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n\n        SimpleQueue<T> q = queue;\n\n        int upstreamConsumed = consumed;\n\n        int localLimit = limit;\n\n        boolean canRequest = sourceMode != QueueSubscription.SYNC;\n\n        AtomicReference<MulticastSubscription<T> []> subs = subscribers;\n\n        MulticastSubscription<T>[] array = subs.get();\n\n        outer: for (;;) {\n                   int n = array.length;\n                   if (q != null && n != 0) {\n                       long r = Long.MAX_VALUE;\n                       for(MulticastSubscription<T> ms :array) {\n                           long u = ms.get() - ms.emitted;\n                           if (u != Long.MIN_VALUE) {\n                               if (r > u) {\n                                   r = u;\n                               }\n                           } else {\n                               n--;\n                           }\n                       }\n                       if (n == 0) {\n                           r = 0;\n                       }\n\n                       while (r != 0) {\n                           if (isDisposed()) {\n                               q.clear();\n                               return;\n                           }\n\n                           boolean d = done;\n                           if (d && !delayError) {\n                               Throwable ex = error;\n                               if (ex != null) {\n                                   errorAll(ex);\n                                   return;\n                               }\n                           }\n\n                           T v;\n                           try {\n                               v = q.poll();\n                           } catch (Throwable ex) {\n                                                      Exceptions.throwIfFatal(ex);\n                                                      SubscriptionHelper.cancel(upstream);\n                                                      errorAll(ex);\n                                                      return;\n                                                  }\n\n                           boolean empty = v == null;\n                           if (d && empty) {\n                               Throwable ex = error;\n                               if (ex != null) {\n                                   errorAll(ex);\n                               } else {\n                                   completeAll();\n                               }\n\n                               return;\n                           }\n                           if (empty) {\n                               break;\n                           }\n\n                           boolean subscribersChange = false;\n                           for(MulticastSubscription<T> ms :array) {\n                               long msr = ms.get();\n                               if (msr != Long.MIN_VALUE) {\n                                   if (msr != Long.MAX_VALUE) {\n                                       ms.emitted++;\n                                   }\n\n                                   ms.downstream.onNext(v);\n                               } else {\n                                   subscribersChange = true;\n                               }\n                           }\n\n                           r--;\n                           if (canRequest && ++upstreamConsumed == localLimit) {\n                               upstreamConsumed = 0;\n                               upstream.get().request(localLimit);\n                           }\n\n                           MulticastSubscription<T>[] freshArray = subs.get();\n                           if (subscribersChange\n                                   || freshArray != array) {\n                               array = freshArray;\n                               continue outer;\n                           }\n                       }\n                       if (r == 0) {\n                           if (isDisposed()) {\n                               q.clear();\n                               return;\n                           }\n\n                           boolean d = done;\n                           if (d && !delayError) {\n                               Throwable ex = error;\n                               if (ex != null) {\n                                   errorAll(ex);\n                                   return;\n                               }\n                           }\n                           if (d && q.isEmpty()) {\n                               Throwable ex = error;\n                               if (ex != null) {\n                                   errorAll(ex);\n                               } else {\n                                   completeAll();\n                               }\n\n                               return;\n                           }\n                       }\n                   }\n\n                   consumed = upstreamConsumed;\n                   missed = wip.addAndGet(-missed);\n                   if (missed == 0) {\n                       break;\n                   }\n                   if (q == null) {\n                       q = queue;\n                   }\n\n                   array = subs.get();\n               }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "261", "src_id": "M1237", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        final Subscriber<? super R> a = downstream;\n        final ZipSubscriber<T, R>[] qs = subscribers;\n        final int n = qs.length;\n\n        Object[] values = current;\n\n        int missed = 1;\n        for (;;) {\n            long r = requested.get();\n\n            long e = 0L;\n            while (r != e) {\n                if (cancelled) {\n                    return;\n                }\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                boolean empty = false;\n                for (int j = 0; j < n; j++) {\n                    ZipSubscriber<T, R> inner = qs [j];\n                    if (values [j] == null) {\n                        boolean d = inner.done;\n\n                        SimpleQueue<T> q = inner.queue;\n\n                        T v = null;\n                        try {\n                            v = q != null?q.poll(): null;\n                        } catch (Throwable ex) {\n                                                   Exceptions.throwIfFatal(ex);\n                                                   errors.tryAddThrowableOrReport(ex);\n                                                   if (!delayErrors) {\n                                                       cancelAll();\n                                                       errors.tryTerminateConsumer(a);\n                                                       return;\n                                                   }\n\n                                                   d = true;\n                                               }\n\n                        boolean sourceEmpty = v == null;\n                        if (d && sourceEmpty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n                        if (!sourceEmpty) {\n                            values[j] = v;\n                        } else {\n                            empty = true;\n                        }\n                    }\n                }\n                if (empty) {\n                    break;\n                }\n\n                R v;\n                try {\n                    v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n                } catch (Throwable ex) {\n                                           Exceptions.throwIfFatal(ex);\n                                           cancelAll();\n                                           errors.tryAddThrowableOrReport(ex);\n                                           errors.tryTerminateConsumer(a);\n                                           return;\n                                       }\n\n                a.onNext(v);\n                e++;\n                Arrays.fill(values, null);\n            }\n            if (r == e) {\n                if (cancelled) {\n                    return;\n                }\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                for (int j = 0; j < n; j++) {\n                    ZipSubscriber<T, R> inner = qs [j];\n                    if (values [j] == null) {\n                        boolean d = inner.done;\n\n                        SimpleQueue<T> q = inner.queue;\n\n                        T v = null;\n                        try {\n                            v = q != null?q.poll(): null;\n                        } catch (Throwable ex) {\n                                                   Exceptions.throwIfFatal(ex);\n                                                   errors.tryAddThrowableOrReport(ex);\n                                                   if (!delayErrors) {\n                                                       cancelAll();\n                                                       errors.tryTerminateConsumer(a);\n                                                       return;\n                                                   }\n\n                                                   d = true;\n                                               }\n\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n                        if (!empty) {\n                            values[j] = v;\n                        }\n                    }\n                }\n            }\n            if (e != 0L) {\n                for(ZipSubscriber<T, R> inner :qs) {\n                    inner.request(e);\n                }\n                if (r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "262", "src_id": "M558", "code": "\n    void innerSuccess(InnerObserver inner, R value) {\n        set.delete(inner);\n        if (get() == 0 && compareAndSet(0, 1)) {\n            downstream.onNext(value);\n\n            boolean d = active.decrementAndGet() == 0;\n\n            SpscLinkedArrayQueue<R> q = queue.get();\n            if (d && (q == null\n                          || q.isEmpty())) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n            if (decrementAndGet() == 0) {\n                return;\n            }\n        } else {\n            SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n            synchronized(q) {\n                            q.offer(value);\n            }\n\n            active.decrementAndGet();\n            if (getAndIncrement() != 0) {\n                return;\n            }\n        }\n\n        drainLoop();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "263", "src_id": "M2273", "code": "\n    @Override\n    public void onSubscribe(Subscription s) {\n        boolean cancel;\n        if (!done) {\n            synchronized(this) {\n                                   if (done) {\n                                       cancel = true;\n                                   } else {\n                                       if (emitting) {\n                                           AppendOnlyLinkedArrayList<Object> q = queue;\n                                           if (q == null) {\n                                               q = new AppendOnlyLinkedArrayList<>(4);\n                                               queue = q;\n                                           }\n\n                                           q.add(NotificationLite.subscription(s));\n                                           return;\n                                       }\n\n                                       emitting = true;\n                                       cancel = false;\n                                   }\n                               }\n        } else {\n            cancel = true;\n        }\n        if (cancel) {\n            s.cancel();\n        } else {\n            actual.onSubscribe(s);\n            emitLoop();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "264", "src_id": "M520", "code": "\n    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false, success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        }\n            finally {\n            if (success) {\n                boolean renamed = tmpFile.renameTo(origFile);\n                if (!renamed) {\n                    // On windows, renameTo does not replace.\n                    if (!origFile.delete()|| !tmpFile.renameTo(origFile)) {\n                        throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                    }\n                }\n            } else {\n                if (!triedToClose) {\n                    // If we failed when flushing, try to close it to not leak\n                    // an FD\n                    IOUtils.closeStream(out);\n                }\n                // close wasn't successful, try to delete the tmp file\n                if (!tmpFile.delete()) {\n                    LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "265", "src_id": "M1043", "code": "\n    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (bb.remaining() > 0) {\n                    break;\n                }\n\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {\n                    /*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n\n                int p = b.position();\n                directBuffer.put(b);\n                b.position(p);\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }\n            /*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n\n            directBuffer.flip();\n\n            int sent = sock.write(directBuffer);\n            ByteBuffer bb;\n\n            // Remove the buffers that we have sent\n            while((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (sent < bb.remaining()) {\n                    /*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }\n                /* We've sent the whole buffer, so drop the buffer */\n\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "266", "src_id": "M196", "code": "\n    public static void main(String[] args) throws IOException {\n        MergedLogSource source = new MergedLogSource(args);\n        PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n        PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n        PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n        PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n        LogIterator iter;\n        System.out.println(source);\n        iter = source.iterator();\n\n        long currentms = 0;\n        long currentsec = 0;\n        long currentmin = 0;\n        long currenthour = 0;\n        Set<Long> zxids_ms = new HashSet<Long>();\n        long zxid_sec = 0;\n        long zxid_min = 0;\n        long zxid_hour = 0;\n        while(iter.hasNext()) {\n            LogEntry e = iter.next();\n            TransactionEntry cxn = (TransactionEntry) e;\n            long ms = cxn.getTimestamp();\n            long sec = ms/ MS_PER_SEC;\n            long min = ms/ MS_PER_MIN;\n            long hour = ms/ MS_PER_HOUR;\n            if (currentms != ms && currentms != 0) {\n                ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n                zxid_sec += zxids_ms.size();\n                zxid_min += zxids_ms.size();\n                zxid_hour += zxids_ms.size();\n                zxids_ms.clear();\n            }\n            if (currentsec != sec && currentsec != 0) {\n                ps_sec.println(\"\" + currentsec* MS_PER_SEC + \" \" + zxid_sec);\n                zxid_sec = 0;\n            }\n            if (currentmin != min && currentmin != 0) {\n                ps_min.println(\"\" + currentmin* MS_PER_MIN + \" \" + zxid_min);\n                zxid_min = 0;\n            }\n            if (currenthour != hour && currenthour != 0) {\n                ps_hour.println(\"\" + currenthour* MS_PER_HOUR + \" \" + zxid_hour);\n                zxid_hour = 0;\n            }\n\n            currentms = ms;\n            currentsec = sec;\n            currentmin = min;\n            currenthour = hour;\n            zxids_ms.add(cxn.getZxid());\n        }\n\n        iter.close();\n        ps_ms.close();\n        ps_sec.close();\n        ps_min.close();\n        ps_hour.close();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "267", "src_id": "M1149", "code": "\n    public void run() {\n        try {\n            while(!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                    LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                }\ncatch (Exception e) {\n                    LOG.warn(\"Ignoring unexpected exception\", e);\n                }\n            }\n\n                // Close connections still pending on the selector. Any others\n                // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n            while((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n\n            updateQueue.clear();\n        }\n            finally {\n            closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n            NIOServerCnxnFactory.this.stop();\n            LOG.info(\"selector thread exited run method\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "268", "src_id": "M290", "code": "\n    public String getStatus(String name, long timeout) throws KeeperException, InterruptedException {\n        Stat stat = new Stat();\n        byte[] data = null;\n        long endTime = Time.currentElapsedTime() + timeout;\n        KeeperException lastException = null;\n        for(int i = 0;i < maxTries && endTime > Time.currentElapsedTime();\ni++) {\n            try {\n                data = zk.getData(reportsNode + '/' + name, false, stat);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got Data: \" + ((data == null)?\"null\" : new String(data)));\n                }\n\n                lastException = null;\n                break;\n            } catch (ConnectionLossException e) {\n                lastException = e;\n            }\ncatch (NoNodeException e) {\n                final Object eventObj = new Object();\n                synchronized(eventObj) {\n                    // wait for the node to appear\n                                       Stat eStat = zk.exists(reportsNode + '/' + name,\nnew Watcher() {\n   public void process(WatchedEvent event) {\n       synchronized(eventObj) {\n           eventObj.notifyAll();\n       }\n   }\n\n});\n                                       if (eStat == null) {\n                                           eventObj.wait(endTime - Time.currentElapsedTime());\n                                       }\n                }\n\n                lastException = e;\n            }\n        }\n        if (lastException != null) {\n            throw lastException;\n        }\n        return new String(data);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "269", "src_id": "M192", "code": "\n    private void init() throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n\n    // if we have read data from the file, and it matches the timep pattern\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n\n    /*\n      Count number of log entries. Any line starting with a timestamp counts as an entry\n    */\n\n        String lastentry = line;\n        try {\n            while(line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size% skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n\n                    size++;\n                    lastentry = line;\n                }\n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n        }\nfinally {\n            in.close();\n        }\n\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "270", "src_id": "M254", "code": "\n    private void distributedConfigureServers(int count) throws IOException {\n        StringBuilder sbClient = new StringBuilder();\n        StringBuilder sbServer = new StringBuilder();\n        try {\n            for(int i = 0;i < count;\ni++) {\n                String r[] = QuorumPeerInstance.createServer(im, i);\n                if (i > 0) {\n                    sbClient.append(',');\n                    sbServer.append(',');\n                }\n\n                sbClient.append(r[0]); // r[0] == \"host:clientPort\"\n                sbServer.append(r[1]); // r[1] == \"host:leaderPort:leaderElectionPort\"\n                sbServer.append(\";\" + (r[0].split(\":\"))[1]); // Appending \";clientPort\"\n            }\n\n            serverHostPort = sbClient.toString();\n            quorumHostPort = sbServer.toString();\n        } catch (Exception e) {\n            IOException ioe = new IOException(e.getMessage());\n            ioe.setStackTrace(e.getStackTrace());\n            throw ioe;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "271", "src_id": "M40", "code": "\n    protected void animateVertically(int posx, int fromY, int toY) throws InterruptedException {\n        toaster.setLocation(posx, fromY);\n        if (toY < fromY) {\n            for(int i = fromY;i > toY;\ni -= step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        } else {\n            for(int i = fromY;i < toY;\ni += step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        }\n\n        toaster.setLocation(posx, toY);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "272", "src_id": "M1130", "code": "\n    public synchronized Map<String, Object> getConnectionInfo(boolean brief) {\n        Map<String, Object> info = new LinkedHashMap< >();\n        info.put(\"remote_socket_address\", getRemoteSocketAddress());\n        info.put(\"interest_ops\", getInterestOps());\n        info.put(\"outstanding_requests\", getOutstandingRequests());\n        info.put(\"packets_received\", getPacketsReceived());\n        info.put(\"packets_sent\", getPacketsSent());\n        if (!brief) {\n            info.put(\"session_id\", getSessionId());\n            info.put(\"last_operation\", getLastOperation());\n            info.put(\"established\", getEstablished());\n            info.put(\"session_timeout\", getSessionTimeout());\n            info.put(\"last_cxid\", getLastCxid());\n            info.put(\"last_zxid\", getLastZxid());\n            info.put(\"last_response_time\", getLastResponseTime());\n            info.put(\"last_latency\", getLastLatency());\n            info.put(\"min_latency\", getMinLatency());\n            info.put(\"avg_latency\", getAvgLatency());\n            info.put(\"max_latency\", getMaxLatency());\n        }\n        return info;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "273", "src_id": "M1036", "code": "\n    public void start() {\n    if (running || isFinished()|| urls.length < 1) return;\n\n        // ensure that the previous state is completely paused.\n    joinForThreads(10000);\n    running = true;\n    errCode = ERROR_NOTHING;\n\n    if (hasInvalidStorage()) {\n\n        notifyError(ERROR_FILE_CREATION, null);\n        return;\n    }\n\n    if (current >= urls.length) {\n\n        notifyFinished();\n        return;\n    }\n\n    notify(DownloadManagerService.MESSAGE_RUNNING);\n\n    if (urls[current] == null) {\n\n        doRecover(ERROR_RESOURCE_GONE);\n        return;\n    }\n\n    if (blocks == null) {\n\n        initializer();\n        return;\n    }\n\n    init = null;\n    finishCount = 0;\n    blockAcquired = new boolean [blocks.length];\n\n    if (blocks.length < 1) {\n\n        threads = new Thread [] {\n\n                      runAsync(1, new DownloadRunnableFallback(this))};\n    } else {\n      int remainingBlocks = 0;\n      for ( int block : blocks) if (block >= 0) remainingBlocks++;\n\n      if (remainingBlocks < 1) {\n\n        notifyFinished();\n        return;\n      }\n\n      threads = new Thread [Math.min(threadCount, remainingBlocks)];\n\n      for (int i = 0; i < threads.length; i++) {\n\n               threads[i] = runAsync(i + 1, new DownloadRunnable(this, i));\n      }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "274", "src_id": "M803", "code": "\n    public void parse() throws IOException, NoSuchElementException {\n    if (selectedTrack > - 1) {\n        return;\n    }\n\n    box = readBox(ATOM_FTYP);\n    brands = parseFtyp(box);\n    switch(brands[ 0]) {\n    case BRAND_DASH: case BRAND_ISO5:// ¿why not?\n\n    break;\n\n                       default:\n        throw new NoSuchElementException(\"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \" + boxName(brands[ 0]));\n\n    }\n\n    Moov moov = null;\n    int i;\n    while(box.type != ATOM_MOOF) {\n\n        ensure(box);\n        box = readBox();\n        switch(box.type) {\n        case ATOM_MOOV:\n\n        moov = parseMoov(box);\n        break;\n\n                         case ATOM_SIDX: case ATOM_MFRA:\n\n        break;\n\n        }\n    }\n\n    if (moov == null) {\n        throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n    }\n\n    tracks = new Mp4Track [moov.trak.length];\n\n    for (i = 0; i < tracks.length; i++) {\n\n        tracks[i] = new Mp4Track();\n        tracks[i].trak = moov.trak[i];\n\n        if (moov.mvexTrex != null) {\n        for ( final Trex mvexTrex : moov.mvexTrex) {\n                                       if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n\n            tracks[i].trex = mvexTrex;\n                                       }\n        }\n        }\n\n        switch(moov.trak[i].mdia.hdlr.subType) {\n        case HANDLER_VIDE:\n\n        tracks[i].kind = TrackKind.Video;\n        break;\n\n                                               case HANDLER_SOUN:\n\n        tracks[i].kind = TrackKind.Audio;\n        break;\n\n                                               case HANDLER_SUBT:\n\n        tracks[i].kind = TrackKind.Subtitles;\n        break;\n\n                                               default:\n\n        tracks[i].kind = TrackKind.Other;\n        break;\n\n        }\n    }\n\n    backupBox = box;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "275", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n    int statusCode = conn.getResponseCode();\n    if (DEBUG) {\n\n        Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n        Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n        Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n        Log.d(TAG,\nthreadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n    }\n\n    switch(statusCode) {\n    case 204: case 205: case 207:\n    throw new HttpError(statusCode);\n\n                       case 416:\n        return;// let the download thread handle this error\n\n                       default:\n                       if (statusCode < 200 || statusCode > 299) {\n        throw new HttpError(statusCode);\n                       }\n\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "276", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n    if (b == null) {\n        return null;\n    }\n\n    final Elst obj = new Elst();\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n\n        obj.bMediaRate = 0x00010000; // default media rate (1.0)\n        return obj;\n    }\n\n    if (v1) {\n\n        stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n        obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n        stream.skipBytes((entryCount - 1)* (DataReader.LONG_SIZE* 2));\n    } else {\n\n      stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n      obj.mediaTime = stream.readInt();\n    }\n\n    obj.bMediaRate = stream.readInt();\n    return obj;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "277", "src_id": "M1144", "code": "\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n    if (len == 0) {\n        return;\n    }\n\n    long available;\n    long offsetOut = out.getOffset();\n    long offsetAux = aux.getOffset();\n    long end = callback.check();\n    if (end == - 1) {\n\n        available = Integer.MAX_VALUE;\n    } else if (end < offsetOut) {\n                                                                         throw new IOException(\"The reported offset is invalid: \" + end + \"<\" + offsetOut);\n           } else {\n\n             available = end - offsetOut;\n           }\n\n    boolean usingAux = aux.length > 0 && offsetOut >= out.length;\n    boolean underflow = offsetAux < aux.length || offsetOut < out.length;\n    if (usingAux) {\n            // before continue calculate the final length of aux\nlong length = offsetAux + len;\nif (underflow) {\nif (aux.length > length) {\n\n   length = aux.length;// the length is not changed\n}\n} else {\n\n length = aux.length + len;\n}\n\naux.write(b, off, len);\n\nif (length >= THRESHOLD_AUX_LENGTH && length <= available) {\n\n        flushAuxiliar(available);\n}\n    } else {\n      if (underflow) {\n\n        available = out.length - offsetOut;\n      }\n\n      int length = Math.min(len, (int) Math.min(Integer.MAX_VALUE, available));\n      out.write(b, off, length);\n      len -= length;\n      off += length;\n\n      if (len > 0) {\n\n        aux.write(b, off, len);\n      }\n    }\n\n    if (onProgress != null) {\n        long absoluteOffset = out.getOffset() + aux.getOffset();\n        if (absoluteOffset > reportPosition) {\n\n        reportPosition = absoluteOffset + NOTIFY_BYTES_INTERVAL;\n        onProgress.report(absoluteOffset);\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "278", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n    boolean done;\n    long start = mMission.fallbackResumeOffset;\n    if (DEBUG && !mMission.unknownLength && start > 0) {\n\n        Log.i(TAG, \"Resuming a single-thread download at \" + start);\n    }\n\n    try {\n        long rangeStart = (mMission.unknownLength || start < 1) ? - 1\n                              : start;\n        int mId = 1;\n        mConn = mMission.openConnection(false, rangeStart, - 1);\n\n        if (mRetryCount == 0 && rangeStart == - 1) {\n                // workaround: bypass android connection pool\n\n        mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n        }\n\n        mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n\n        if (mConn.getResponseCode() == 416 && start > 0) {\n\n        mMission.notifyProgress(-start);\n        start = 0;\n        mRetryCount--;\n        throw new DownloadMission . HttpError(416);\n        }\n\n            // secondary check for the file length\n\n        if (!mMission.unknownLength) mMission.unknownLength = Utility.getContentLength(mConn) == - 1;\n\n        if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n\n        mMission.done = mMission.offsets[mMission.current] - mMission.offsets[ 0];\n        }\n\n        mF = mMission.storage.getStream();\n        mF.seek(mMission.offsets[mMission.current] + start);\n        mIs = mConn.getInputStream();\n\n        byte [] buf = new byte[DownloadMission.BUFFER_SIZE];\n        int len = 0;\n        while(mMission.running && (len = mIs.read(buf, 0, buf.length)) != - 1) {\n\n        mF.write(buf, 0, len);\n        start += len;\n        mMission.notifyProgress(len);\n        }\n\n        dispose();\n\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n        done = len == - 1;\n    } catch (Exception e) {\n\n      dispose();\n      mMission.fallbackResumeOffset = start;\n\n      if (!mMission.running || e instanceof ClosedByInterruptException) return;\n\n      if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n\n        dispose();\n        mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n        return;\n      }\n\n      if (mRetryCount ++ >= mMission.maxRetry) {\n\n        mMission.notifyError(e);\n        return;\n      }\n\n      if (DEBUG) {\n\n        Log.e(TAG, \"got exception, retrying...\", e);\n      }\n\n      run();// try again\n      return;\n    }\n\n    if (done) {\n\n        mMission.notifyFinished();\n    } else {\n\n      mMission.fallbackResumeOffset = start;\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "279", "src_id": "M1086", "code": "\n    private ArrayList<Object> getSpecialItems() {\n    synchronized(DownloadManager.this) {\n\n        ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n\n        ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n\n        List<Mission> remove = new ArrayList<>(hidden);\n\n                // hide missions (if required)\n        remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n        int fakeTotal = pending.size();\n        if (fakeTotal > 0) fakeTotal++;\n        fakeTotal += finished.size();\n\n        if (finished.size() > 0) fakeTotal++;\n        ArrayList<Object> list = new ArrayList<>(fakeTotal);\n        if (pending.size() > 0) {\n\n        list.add(PENDING);\n        list.addAll(pending);\n        }\n\n        if (finished.size() > 0) {\n\n        list.add(FINISHED);\n        list.addAll(finished);\n        }\n\n        hasFinished = finished.size() > 0;\n        return list;\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "280", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n    synchronized(this) {\n\n        mission.timestamp = System.currentTimeMillis();\n        mission.mHandler = mHandler;\n        mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n        while(true) {\n\n        mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n\n        if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n            try {\n            if (!mission.metadata.createNewFile()) throw new RuntimeException(\"Cant create download metadata file\");\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n\n            break;\n        }\n\n        mission.timestamp = System.currentTimeMillis();\n        }\n\n        mSelfMissionsControl = true;\n        mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n        Utility.writeToFile(mission.metadata, mission);\n\n        if (mission.storage == null) {\n                // noting to do here\n\n        mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n\n        if (mission.errObject != null) mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n        return;\n        }\n\n        boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n        if (canDownloadInCurrentNetwork() && start) {\n\n        mission.start();\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "281", "src_id": "M1117", "code": "\n    private void showPopupMenu() {\n\n    retry.setVisible(false);\n    cancel.setVisible(false);\n    start.setVisible(false);\n    pause.setVisible(false);\n    open.setVisible(false);\n    queue.setVisible(false);\n    showError.setVisible(false);\n    delete.setVisible(false);\n    source.setVisible(false);\n    checksum.setVisible(false);\n    DownloadMission mission = item.mission instanceof DownloadMission ? (DownloadMission) item.mission\n                                  : null;\n    if (mission != null) {\nif (mission.hasInvalidStorage()) {\n\n        retry.setVisible(true);\n        delete.setVisible(true);\n        showError.setVisible(true);\n} else if (mission.isPsRunning()) {\n                             switch(mission.errCode) {\n                             case ERROR_INSUFFICIENT_STORAGE: case ERROR_POSTPROCESSING_HOLD:\n\n                             retry.setVisible(true);\n                             cancel.setVisible(true);\n                             showError.setVisible(true);\n                             break;\n                             }\n      } else {\n        if (mission.running) {\n\n          pause.setVisible(true);\n        } else {\n          if (mission.errCode != ERROR_NOTHING) {\n\n            showError.setVisible(true);\n          }\n\n          queue.setChecked(mission.enqueued);\n          delete.setVisible(true);\n\n          boolean flag = !mission.isPsFailed() && mission.urls.length > 0;\n          start.setVisible(flag);\n          queue.setVisible(flag);\n        }\n      }\n    } else {\n\n      open.setVisible(true);\n      delete.setVisible(true);\n      checksum.setVisible(true);\n    }\n\n    if (item.mission.source != null && !item.mission.source.isEmpty()) {\n\n        source.setVisible(true);\n    }\n\n    popupMenu.show();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "282", "src_id": "M362", "code": "\n    void drainFused() {\n    int missed = 1;\n    for (;;) {\n                          if (disposed) {\n                 return;\n                          }\n\n                          boolean d = done;\n                          Throwable ex = error;\n                          if (!delayError&&\n                 d&&\n                 ex != null) {\n        disposed = true;\n        downstream.onError(error);\n        worker.dispose();\n        return;\n                          }\n\n                          downstream.onNext(null);\n\n                          if (d) {\n        disposed = true;\n        ex = error;\n\n        if (ex != null) {\n                                     downstream.onError(ex);\n        } else {\n          downstream.onComplete();\n        }\n\n        worker.dispose();\n        return;\n                          }\n\n                          missed = addAndGet(- missed);\n\n                          if (missed == 0) {\n                 break;\n                          }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "283", "src_id": "M1685", "code": "\n    void dispose(List<Disposable> set) {\n    if (set == null) {\n        return;\n    }\n\n    List<Throwable> errors = null;\n    for (Disposable o : set) {\n        try {\n        o.dispose();\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n\n          if (errors == null) {\n            errors = new ArrayList<>();\n          }\n\n          errors.add(ex);\n        }\n    }\n\n    if (errors != null) {\n        if (errors.size() == 1) {\n                            throw ExceptionHelper.wrapOrThrow(errors.get(0));\n        }\n\n        throw new CompositeException(errors);\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "284", "src_id": "M1503", "code": "\n    @Override\n    public void onComplete() {\n    if (wip.getAndIncrement() == 0) {\n        Publisher<? extends T> [] sources = this.sources;\n        int n = sources.length;\n        int i = index;\n        for (;;) {\n                                        if (i == n) {\n            List<Throwable> list = errors;\n            if (list != null) {\n                                                        if (list.size() == 1) {\n                                  downstream.onError(list.get(0));\n                                                        } else {\n                                                          downstream.onError(new CompositeException(list));\n                                                        }\n            } else {\n              downstream.onComplete();\n            }\n            return;\n                                        }\n\n                                        Publisher<? extends T> p = sources[i];\n                                        if (p == null) {\n                     Throwable ex = new NullPointerException(\"A Publisher entry is null\");\n                     if (delayError) {\n                                                           List<Throwable> list = errors;\n                                                           if (list == null) {\n                         list = new ArrayList<>(n - i+ 1);\n                         errors = list;\n                                                           }\n\n                                                           list.add(ex);\n                                                           i++;\n                                                           continue;\n                     } else {\n                       downstream.onError(ex);\n                       return;\n                     }\n                                        } else {\n                                          long r = produced;\n                                          if (r != 0L) {\n                                            produced = 0L;\n                                            produced(r);\n                                          }\n\n                                          p.subscribe(this);\n                                        }\n\n                                        index = ++i;\n\n                                        if (wip.decrementAndGet() == 0) {\n                     break;\n                                        }\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "285", "src_id": "M470", "code": "\n    void replay(CacheDisposable<T> consumer) {\n        // make sure there is only one replay going on at a time\n    if (consumer.getAndIncrement() != 0) {\n        return;\n    }\n\n        // see if there were more replay request in the meantime\n\n    int missed = 1;\n        // read out state into locals upfront to avoid being re-read due to volatile reads\n    long index = consumer.index;\n    int offset = consumer.offset;\n    Node<T> node = consumer.node;\n    Observer<? super T> downstream = consumer.downstream;\n    int capacity = capacityHint;\n    for (;;) {\n            // if the consumer got disposed, clear the node and quit\n                                                 if (consumer.disposed) {\n        consumer.node = null;\n        return;\n                                                 }\n\n            // first see if the source has terminated, read order matters!\n\n                                                 boolean sourceDone = done;\n            // and if the number of items is the same as this consumer has received\n                                                 boolean empty = size == index;\n\n            // if the source is done and we have all items so far, terminate the consumer\n                                                 if (sourceDone&&\n                 empty) {\n                // release the node object to avoid leaks through retained consumers\n        consumer.node = null;\n                // if error is not null then the source failed\n        Throwable ex = error;\n        if (ex != null) {\n                            downstream.onError(ex);\n        } else {\n          downstream.onComplete();\n        }\n        return;\n                                                 }\n\n            // there are still items not sent to the consumer\n\n                                                 if (!empty) {\n             // if the offset in the current node has reached the node capacity\n                 if (offset == capacity) {\n                    // switch to the subsequent node\n                                                     node = node.next;\n                    // reset the in-node offset\n                                                     offset = 0;\n                 }\n\n                // emit the cached item\n\n                 downstream.onNext(node.values[offset]);\n\n                // move the node offset forward\n                 offset++;\n                // move the total consumed item count forward\n                 index++;\n\n                // retry for the next item/terminal event if any\n                 continue;\n                                                 }\n\n            // commit the changed references back\n\n                                                 consumer.index = index;\n                                                 consumer.offset = offset;\n                                                 consumer.node = node;\n            // release the changes and see if there were more replay request in the meantime\n                                                 missed = consumer.addAndGet(- missed);\n\n                                                 if (missed == 0) {\n                 break;\n                                                 }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "286", "src_id": "M913", "code": "\n    void drainAsync() {\n    int missed = 1;\n    SimpleQueue<T> q = queue;\n    Subscriber<? super T> [] a = this.subscribers;\n    AtomicLongArray r = this.requests;\n    long[] e = this.emissions;\n    int n = e.length;\n    int idx = index;\n    int consumed = produced;\n    for (;;) {\n                          int notReady = 0;\n                          for (;;) {\n                 if (cancelled) {\n                              q.clear();\n                              return;\n                 }\n\n                 boolean d = done;\n                 if (d) {\n                              Throwable ex = error;\n                              if (ex != null) {\n                     q.clear();\n                     for (Subscriber<? super T> s : a) {\n                                                  s.onError(ex);\n                     }\n                     return;\n                              }\n                 }\n\n                 boolean empty = q.isEmpty();\n                 if (d&&\n                                       empty) {\n                                       for (Subscriber<? super T> s : a) {\n                                                  s.onComplete();\n                                       }\n                                       return;\n                 }\n\n                 if (empty) {\n                                       break;\n                 }\n\n                 long requestAtIndex = r.get(idx);\n                 long emissionAtIndex = e[idx];\n                 if (requestAtIndex != emissionAtIndex&&\n                                       r.get(n + idx) == 0) {\n                                       T v;\n                                       try {\n                     v = q.poll();\n                                       } catch (Throwable ex) {\n                                         Exceptions.throwIfFatal(ex);\n                                         upstream.cancel();\n                                         for (Subscriber<? super T> s : a) {\n                                             s.onError(ex);\n                                         }\n                                         return;\n                                       }\n\n                                       if (v == null) {\n                                                                break;\n                                       }\n\n                                       a[idx].onNext(v);\n                                       e[idx] = emissionAtIndex + 1;\n\n                                       int c = ++consumed;\n                                       if (c == limit) {\n                     consumed = 0;\n                     upstream.request(c);\n                                       }\n\n                                       notReady = 0;\n                 } else {\n                   notReady++;\n                 }\n\n                 idx++;\n\n                 if (idx == n) {\n                              idx = 0;\n                 }\n\n                 if (notReady == n) {\n                                       break;\n                 }\n                          }\n\n                          int w = get();\n                          if (w == missed) {\n                 index = idx;\n                 produced = consumed;\n                 missed = addAndGet(- missed);\n\n                 if (missed == 0) {\n                                               break;\n                 }\n                          } else {\n                            missed = w;\n                          }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "287", "src_id": "M902", "code": "\n    @Override\n    public void run() {\n    int missed = 1;\n    int c = consumed;\n    SpscArrayQueue<T> q = queue;\n    Subscriber<? super T> a = downstream;\n    int lim = limit;\n    for (;;) {\n                          long r = requested.get();\n                          long e = 0L;\n                          while (e != r) {\n                 if (cancelled) {\n                              q.clear();\n                              return;\n                 }\n\n                 boolean d = done;\n                 if (d) {\n                              Throwable ex = error;\n                              if (ex != null) {\n                     q.clear();\n                     a.onError(ex);\n                     worker.dispose();\n                     return;\n                              }\n                 }\n\n                 T v = q.poll();\n                 boolean empty = v == null;\n                 if (d&&\n                                             empty) {\n                              a.onComplete();\n                              worker.dispose();\n                              return;\n                 }\n\n                 if (empty) {\n                                             break;\n                 }\n\n                 a.onNext(v);\n                 e++;\n\n                 int p = ++c;\n                 if (p == lim) {\n                              c = 0;\n                              upstream.request(p);\n                 }\n                          }\n\n                          if (e == r) {\n                 if (cancelled) {\n                              q.clear();\n                              return;\n                 }\n\n                 if (done) {\n                              Throwable ex = error;\n                              if (ex != null) {\n                     q.clear();\n                     a.onError(ex);\n                     worker.dispose();\n                     return;\n                              }\n\n                              if (q.isEmpty()) {\n                     a.onComplete();\n                     worker.dispose();\n                     return;\n                              }\n                 }\n                          }\n\n                          if (e != 0L&&\n                 r != Long.MAX_VALUE) {\n        requested.addAndGet(- e);\n                          }\n\n                          int w = get();\n                          if (w == missed) {\n                 consumed = c;\n                 missed = addAndGet(- missed);\n\n                 if (missed == 0) {\n                                               break;\n                 }\n                          } else {\n                            missed = w;\n                          }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "288", "src_id": "M1330", "code": "\n    @Override\n    public void drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    for (;;) {\n        SimpleQueue<T> q1 = first.queue;\n        SimpleQueue<T> q2 = second.queue;\n        if (q1 != null&&\n                 q2 != null) {\nfor (;;) {\n                                 if (isDisposed()) {\n   first.clear();\n   second.clear();\n   return;\n                                 }\n\n                                 Throwable ex = errors.get();\n                                 if (ex != null) {\n   cancelAndClear();\n   errors.tryTerminateConsumer(downstream);\n   return;\n                                 }\n\n                                 boolean d1 = first.done;\n                                 T a = v1;\n                                 if (a == null) {\n            try {\n                                     a = q1.poll();\n            } catch (Throwable exc) {\n              Exceptions.throwIfFatal(exc);\n              cancelAndClear();\n              errors.tryAddThrowableOrReport(exc);\n              errors.tryTerminateConsumer(downstream);\n              return;\n            }\n\n            v1 = a;\n                                 }\n\n                                 boolean e1 = a == null;\n                                 boolean d2 = second.done;\n                                 T b = v2;\n                                 if (b == null) {\n            try {\n                                     b = q2.poll();\n            } catch (Throwable exc) {\n              Exceptions.throwIfFatal(exc);\n              cancelAndClear();\n              errors.tryAddThrowableOrReport(exc);\n              errors.tryTerminateConsumer(downstream);\n              return;\n            }\n\n            v2 = b;\n                                 }\n\n                                 boolean e2 = b == null;\n                                 if (d1&&\n                                     d2&&\n            e1&&\n            e2) {\n   downstream.onSuccess(true);\n   return;\n                                 }\n\n                                 if ((d1&&\n                                         d2)&& (e1 != e2)) {\n   cancelAndClear();\n   downstream.onSuccess(false);\n   return;\n                                 }\n\n                                 if (e1 || e2) {\n            break;\n                                 }\n\n                                 boolean c;\n                                 try {\n   c = comparer.test(a, b);\n                                 } catch (Throwable exc) {\n                                   Exceptions.throwIfFatal(exc);\n                                   cancelAndClear();\n                                   errors.tryAddThrowableOrReport(exc);\n                                   errors.tryTerminateConsumer(downstream);\n                                   return;\n                                 }\n\n                                 if (!c) {\n   cancelAndClear();\n   downstream.onSuccess(false);\n   return;\n                                 }\n\n                                 v1 = null;\n                                 v2 = null;\n                                 first.request();\n                                 second.request();\n}\n        } else {\n          if (isDisposed()) {\n            first.clear();\n            second.clear();\n            return;\n          }\n\n          Throwable ex = errors.get();\n          if (ex != null) {\n            cancelAndClear();\n            errors.tryTerminateConsumer(downstream);\n            return;\n          }\n        }\n\n        missed = addAndGet(- missed);\n\n        if (missed == 0) {\n                 break;\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "289", "src_id": "M1033", "code": "\n    void drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    final Subscriber<? super R> a = downstream;\n    final SimpleQueue<T> q = queue;\n    final boolean replenish = fusionMode != SYNC;\n    int missed = 1;\n    Iterator<? extends R> it = current;\n    for (;;) {\n                     if (it == null) {\n                 boolean d = done;\n                 T t;\n                 try {\n                         t = q.poll();\n                 } catch (Throwable ex) {\n                   Exceptions.throwIfFatal(ex);\n                   upstream.cancel();\n                   ExceptionHelper.addThrowable(error, ex);\n                   ex = ExceptionHelper.terminate(error);\n                   current = null;\n                   q.clear();\n                   a.onError(ex);\n                   return;\n                 }\n\n                 boolean empty = t == null;\n                 if (checkTerminated(d, empty, a, q)) {\n                                         return;\n                 }\n\n                 if (t != null) {\n                         Iterable<? extends R> iterable;\n                         boolean b;\n                         try {\n                     iterable = mapper.apply(t);\n                     it = iterable.iterator();\n                     b = it.hasNext();\n                         } catch (Throwable ex) {\n                           Exceptions.throwIfFatal(ex);\n                           upstream.cancel();\n                           ExceptionHelper.addThrowable(error, ex);\n                           ex = ExceptionHelper.terminate(error);\n                           a.onError(ex);\n                           return;\n                         }\n\n                         if (!b) {\n                     it = null;\n                     consumedOne(replenish);\n                     continue;\n                         }\n\n                         current = it;\n                 }\n                     }\n\n                     if (it != null) {\n                 long r = requested.get();\n                 long e = 0L;\n                 while (e != r) {\n                                         if (checkTerminated(done, false, a, q)) {\n                                    return;\n                                         }\n\n                                         R v;\n                                         try {\n                     v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n                                         } catch (Throwable ex) {\n                                           Exceptions.throwIfFatal(ex);\n                                           current = null;\n                                           upstream.cancel();\n                                           ExceptionHelper.addThrowable(error, ex);\n                                           ex = ExceptionHelper.terminate(error);\n                                           a.onError(ex);\n                                           return;\n                                         }\n\n                                         a.onNext(v);\n\n                                         if (checkTerminated(done, false, a, q)) {\n                                    return;\n                                         }\n\n                                         e++;\n\n                                         boolean b;\n                                         try {\n                     b = it.hasNext();\n                                         } catch (Throwable ex) {\n                                           Exceptions.throwIfFatal(ex);\n                                           current = null;\n                                           upstream.cancel();\n                                           ExceptionHelper.addThrowable(error, ex);\n                                           ex = ExceptionHelper.terminate(error);\n                                           a.onError(ex);\n                                           return;\n                                         }\n\n                                         if (!b) {\n                     consumedOne(replenish);\n                     it = null;\n                     current = null;\n                     break;\n                                         }\n                 }\n\n                 if (e == r) {\n                                         boolean d = done;\n                                         boolean empty = q.isEmpty()&&\n                                             it == null;\n                                         if (checkTerminated(d, empty, a, q)) {\n                                 return;\n                                         }\n                 }\n\n                 if (e != 0L) {\n                                         if (r != Long.MAX_VALUE) {\n                     requested.addAndGet(- e);\n                                         }\n                 }\n\n                 if (it == null) {\n                                         continue;\n                 }\n                     }\n\n                     missed = addAndGet(- missed);\n\n                     if (missed == 0) {\n                 break;\n                     }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "290", "src_id": "M807", "code": "\n    @Override\n    public void subscribe(Subscriber<? super R> [] subscribers) {\n    subscribers = RxJavaPlugins.onSubscribe(this, subscribers);\n\n    if (!validate(subscribers)) {\n        return;\n    }\n\n    int n = subscribers.length;\n    @SuppressWarnings(\"unchecked\") Subscriber<T> [] parents = new Subscriber [n];\n    for (int i = 0; i < n; i++) {\n        R initialValue;\n        try {\n        initialValue = Objects.requireNonNull(initialSupplier.get(), \"The initialSupplier returned a null value\");\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          reportError(subscribers, ex);\n          return;\n        }\n\n        parents[i] = new ParallelReduceSubscriber<>(subscribers[i], initialValue, reducer);\n    }\n\n    source.subscribe(parents);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "291", "src_id": "M438", "code": "\n    @Override\n    public void subscribeActual(Observer<? super T> observer) {\n    DeferredScalarDisposable<T> d = new DeferredScalarDisposable<>(observer);\n    observer.onSubscribe(d);\n\n    if (d.isDisposed()) {\n        return;\n    }\n\n    T value;\n    try {\n        value = ExceptionHelper.nullCheck(supplier.get(), \"Supplier returned a null value.\");\n    } catch (Throwable e) {\n      Exceptions.throwIfFatal(e);\n\n      if (!d.isDisposed()) {\n          observer.onError(e);\n      } else {\n        RxJavaPlugins.onError(e);\n      }\n      return;\n    }\n\n    d.complete(value);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "292", "src_id": "M597", "code": "\n    private List<Integer> duplicate(int totalPages,\n                                    String pageOrder) {\n       List<Integer> newPageOrder = new ArrayList<>();\n       int duplicateCount;\n       try {\n            // Parse the duplicate count from pageOrder\n        duplicateCount = pageOrder != null&&\n            !pageOrder.isEmpty()? Integer.parseInt(pageOrder.trim()): 2; // Default to 2 if not specified\n       } catch (NumberFormatException e) {\n         log.error(\"Invalid duplicate count specified\", e);\n         duplicateCount = 2; // Default to 2 if invalid input\n       }\n\n        // Validate duplicate count\n       if (duplicateCount < 1) {\n        duplicateCount = 2; // Default to 2 if invalid input\n       }\n\n        // For each page in the document\n       for (int pageNum = 0; pageNum < totalPages; pageNum++) {\n            // Add the current page index duplicateCount times\n        for (int dupCount = 0; dupCount < duplicateCount; dupCount++) {\n                                                                  newPageOrder.add(pageNum);\n        }\n       }\n       return newPageOrder;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "293", "src_id": "M656", "code": "\n    private void runPipelineAgainstFiles(List<File> filesToProcess, PipelineConfig config, Path dir,\n                                         Path processingDir) throws\n       IOException {\n       try {\n        List<Resource> inputFiles = processor.generateInputFiles(filesToProcess.toArray(new\n                                                                                            File[ 0]));\n        if (inputFiles == null||\n            inputFiles.isEmpty()) {\n           return;\n        }\n        PipelineResult result = processor.runPipelineAgainstFiles(inputFiles, config);\n        if (result.isHasErrors()) {\n           log.error(\"Errors occurred during processing, retaining original files\");\n           moveToErrorDirectory(filesToProcess, dir);\n        } else {\n           moveAndRenameFiles(result.getOutputFiles(), config, dir);\n           deleteOriginalFiles(filesToProcess, processingDir);\n        }\n       } catch (Exception e) {\n         log.error(\"Error during processing\", e);\n         moveFilesBack(filesToProcess, processingDir);\n       }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "294", "src_id": "M32", "code": "\n    private boolean activateMachine(String licenseKey, String licenseId, String machineFingerprint,\n                                    LicenseContext context) throws\n       Exception {\n        // For floating licenses, we first need to check if we need to deregister any machines\n       if (context.isFloatingLicense) {\n        log.info(\"Processing floating license activation. Max machines allowed: {}\", context.maxMachines);\n\n            // Get the current machines for this license\n        JsonNode machinesResponse = fetchMachinesForLicense(licenseKey, licenseId);\n        if (machinesResponse != null) {\n           JsonNode machines = machinesResponse.path(\"data\");\n           int currentMachines = machines.size();\n           log.info(\"Current machine count: {}, Max allowed: {}\", currentMachines, context.maxMachines);\n\n                // Check if the current fingerprint is already activated\n\n\n           boolean isCurrentMachineActivated = false;\n           String currentMachineId = null;\n           for (JsonNode machine : machines) {\n                                          if (machineFingerprint.equals(machine.path(\"attributes\").path(\"fingerprint\").asText())) {\n               isCurrentMachineActivated = true;\n               currentMachineId = machine.path(\"id\").asText();\n               log.info(\"Current machine is already activated with ID: {}\", currentMachineId);\n               break;\n                                          }\n           }\n\n                // If the current machine is already activated, there's no need to do anything\n           if (isCurrentMachineActivated) {\n            log.info(\"Machine already activated. No action needed.\");\n            return true;\n           }\n\n                // If we've reached the max machines limit, we need to deregister the oldest machine\n           if (currentMachines >= context.maxMachines) {\n            log.info(\"Max machines reached. Deregistering oldest machine to make room for the new machine.\");\n\n                    // Find the oldest machine based on creation timestamp\n            if (machines.size() > 0) {\n                        // Find the machine with the oldest creation date\n               String oldestMachineId = null;\n               java.time.Instant oldestTime = null;\n               for (JsonNode machine : machines) {\n                                         String createdStr = machine.path(\"attributes\").path(\"created\").asText(null);\n                                         if (createdStr != null&&\n                                                     !createdStr.isEmpty()) {\n                   try {\n                                             java.time.Instant createdTime = java.time.Instant.parse(createdStr);\n                                             if (oldestTime == null||\n                                                 createdTime.isBefore(oldestTime)) {\n                       oldestTime = createdTime;\n                       oldestMachineId = machine.path(\"id\").asText();\n                                             }\n                   } catch (Exception e) {\n                     log.warn(\"Could not parse creation time for machine: {}\", e.getMessage());\n                   }\n                                         }\n               }\n\n                        // If we couldn't determine the oldest by timestamp, use the first one\n               if (oldestMachineId == null) {\n                log.warn(\"Could not determine oldest machine by timestamp, using first machine in list\");\n                oldestMachineId = machines.path(0).path(\"id\").asText();\n               }\n               log.info(\"Deregistering machine with ID: {}\", oldestMachineId);\n\n\n               boolean deregistered = deregisterMachine(licenseKey, oldestMachineId);\n               if (!deregistered) {\n                log.error(\"Failed to deregister machine. Cannot proceed with activation.\");\n                return false;\n               }\n               log.info(\"Machine deregistered successfully. Proceeding with activation of new machine.\");\n            } else {\n               log.error(\"License has reached machine limit but no machines were found to deregister. This is unexpected.\");\n                        // We'll still try to activate, but it might fail\n            }\n           }\n        }\n       }\n\n        // Proceed with machine activation\n       String hostname;\n       try {\n        hostname = java.net.InetAddress.getLocalHost().getHostName();\n       } catch (Exception e) {\n         hostname = \"Unknown\";\n       }\n       JSONObject body = new JSONObject().put(\"data\", new JSONObject().put(\"type\", \"machines\").put(\"attributes\",\nnew JSONObject().put(\"fingerprint\", machineFingerprint).put(\"platform\", System.getProperty(\"os.name\")).put(\"name\", hostname)).put(\"relationships\",\nnew JSONObject().put(\"license\", new JSONObject().put(\"data\", new JSONObject().put(\"type\", \"licenses\").put(\"id\", licenseId)))));\n       HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/machines\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\").header(\"Authorization\", \"License \" + licenseKey).POST(HttpRequest.BodyPublishers.ofString(body.toString())).build();\n       HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n       log.info(\"activateMachine Response body: \" + response.body());\n       if (response.statusCode() == 201) {\n        log.info(\"Machine activated successfully\");\n        return true;\n       } else {\n        log.error(\"Error activating machine. Status code: {}, error: {}\", response.statusCode(), response.body());\n        return false;\n       }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "295", "src_id": "M625", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "296", "src_id": "M447", "code": "\n    private void configureCefSettings(CefAppBuilder builder) {\n       CefSettings settings = builder.getCefSettings();\n       String basePath = InstallationPathConfig.getClientWebUIPath();\n       log.info(\"basePath \" + basePath);\n       settings.cache_path = new File(basePath + \"cache\").getAbsolutePath();\n       settings.root_cache_path = new File(basePath + \"root_cache\").getAbsolutePath();\n        //        settings.browser_subprocess_path = new File(basePath +\n        // \"subprocess\").getAbsolutePath();\n        //        settings.resources_dir_path = new File(basePath + \"resources\").getAbsolutePath();\n        //        settings.locales_dir_path = new File(basePath + \"locales\").getAbsolutePath();\n       settings.log_file = new File(basePath, \"debug.log\").getAbsolutePath();\n       settings.persist_session_cookies = true;\n       settings.windowless_rendering_enabled = false;\n       settings.log_severity = CefSettings.LogSeverity.LOGSEVERITY_INFO;\n       builder.setAppHandler(new MavenCefAppHandlerAdapter() {\n                                 @Override\n                                 public void stateHasChanged(org.cef.CefApp.CefAppState state) {\n                                 log.info(\"CEF state changed: \" + state);\n                                 if (state == CefApp.CefAppState.TERMINATED) {\n                                     System.exit(0);\n                                 }\n                                 }\n\n});\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "297", "src_id": "M310", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "298", "src_id": "M257", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "299", "src_id": "M184", "code": "\n    private Map<String, Object> getDockerMetrics() {\n       Map<String, Object> dockerMetrics = new HashMap<>();\n\n        // Network-related Docker info\n       dockerMetrics.put(\"docker_network_mode\", System.getenv(\"DOCKER_NETWORK_MODE\"));\n\n        // Container name (if set)\n       String containerName = System.getenv(\"CONTAINER_NAME\");\n       if (containerName != null&&\n                                                       !containerName.isEmpty()) {\n        dockerMetrics.put(\"container_name\", containerName);\n       }\n\n        // Docker compose information\n       String composeProject = System.getenv(\"COMPOSE_PROJECT_NAME\");\n       String composeService = System.getenv(\"COMPOSE_SERVICE_NAME\");\n       if (composeProject != null&&\n                                                       composeService != null) {\n        dockerMetrics.put(\"compose_project\", composeProject);\n        dockerMetrics.put(\"compose_service\", composeService);\n       }\n\n        // Kubernetes-specific info (if running in K8s)\n       String k8sPodName = System.getenv(\"KUBERNETES_POD_NAME\");\n       if (k8sPodName != null) {\n        dockerMetrics.put(\"k8s_pod_name\", k8sPodName);\n        dockerMetrics.put(\"k8s_namespace\", System.getenv(\"KUBERNETES_NAMESPACE\"));\n        dockerMetrics.put(\"k8s_node_name\", System.getenv(\"KUBERNETES_NODE_NAME\"));\n       }\n\n        // New environment variables\n       dockerMetrics.put(\"version_tag\", System.getenv(\"VERSION_TAG\"));\n       dockerMetrics.put(\"additional_features_off\", System.getenv(\"ADDITIONAL_FEATURES_OFF\"));\n       dockerMetrics.put(\"fat_docker\", System.getenv(\"FAT_DOCKER\"));\n       return dockerMetrics;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "300", "src_id": "M170", "code": "\n    private void shutdownSchedulers() {\n       log.info(\"Shutting down job queue\");\n       shuttingDown = true;\n\n        // Complete any futures that are still waiting\n       jobMap.forEach((id, job) -> {\nif (!job.future.isDone()) {\n                          job.future.completeExceptionally(new RuntimeException(\"Server shutting down, job cancelled\"));\n}\n                      });\n\n        // Shutdown schedulers and wait for termination\n       try {\n        scheduler.shutdown();\n        if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {\n           scheduler.shutdownNow();\n        }\n        jobExecutor.shutdown();\n        if (!jobExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n           jobExecutor.shutdownNow();\n        }\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n         scheduler.shutdownNow();\n         jobExecutor.shutdownNow();\n       }\n       log.info(\"Job queue shutdown complete. Stats: total={}, rejected={}\", totalQueuedJobs, rejectedJobs);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "301", "src_id": "M153", "code": "\n    private Path createTempFile(String prefix) throws\n       IOException {\n        // Check if TempFileManager is available in the application context\n       try {\n        TempFileManager tempFileManager = ApplicationContextProvider.getBean(TempFileManager.class);\n        if (tempFileManager != null) {\n                // Use TempFileManager to create and register the temp file\n           File file = tempFileManager.createTempFile(\".tmp\");\n           log.debug(\"Created and registered temp file via TempFileManager: {}\", file);\n           return file.toPath();\n        }\n       } catch (Exception e) {\n         log.debug(\"TempFileManager not available, falling back to standard temp file creation\");\n       }\n\n        // Fallback to standard temp file creation\n       Path file = Files.createTempFile(prefix + tempCounter.incrementAndGet() + \"-\", \".tmp\");\n       log.debug(\"Created temp file: {}\", file);\n\n        // Try to register the file with a static registry if possible\n       try {\n        TempFileRegistry registry = ApplicationContextProvider.getBean(TempFileRegistry.class);\n        if (registry != null) {\n           registry.register(file);\n           log.debug(\"Registered fallback temp file with registry: {}\", file);\n        }\n       } catch (Exception e) {\n         log.debug(\"Could not register fallback temp file with registry: {}\", file);\n       }\n       return file;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "302", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf,PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium()\n            .getProFeatures()\n            .getCustomMetadata()\n            .isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium()\n                .getProFeatures()\n                .getCustomMetadata()\n                .getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "303", "src_id": "M602", "code": "\n    @\n        PostMapping(value = \"/document-properties\", consumes = \"multipart/form-data\") @Operation(summary = \"Get PDF document properties\", description = \"Returns title, author, subject, etc. Input:PDF Output:JSON Type:SISO\") public Map<String, String> getDocumentProperties(@ModelAttribute PDFFile file) throws IOException {\n        // Load the document in read-only mode to prevent modifications and ensure the integrity of\n        // the original file.\n        try (PDDocument document =pdfDocumentFactory.load(file.getFileInput(), true)) {\n            PDDocumentInformation info = document.getDocumentInformation();\n            Map<String, String> properties = new HashMap< >();\n            properties.put(\"title\", info.getTitle());\n            properties.put(\"author\", info.getAuthor());\n            properties.put(\"subject\", info.getSubject());\n            properties.put(\"keywords\", info.getKeywords());\n            properties.put(\"creator\", info.getCreator());\n            properties.put(\"producer\", info.getProducer());\n            properties.put(\"creationDate\", info.getCreationDate()\n                .toString());\n            properties.put(\"modificationDate\", info.getModificationDate()\n                .toString());\n            return properties;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "304", "src_id": "M458", "code": "\n    private void setupTrayIcon(Image icon) {\n        if (!SystemTray.isSupported()) {\n            log.warn(\"System tray is not supported\");\n            return;\n        }\n\n        try {\n            systemTray = SystemTray.getSystemTray();\n\n            // Create popup menu\n            PopupMenu popup = new PopupMenu();\n\n            // Create menu items\n            MenuItem showItem = new MenuItem(\"Show\");\n            showItem.addActionListener(e-> {\n                                           frame.setVisible(true);\n                                           frame.setState(Frame.NORMAL);\n                                       });\n            MenuItem exitItem = new MenuItem(\"Exit\");\n            exitItem.addActionListener(e-> {\n                                           cleanup();\n                                           System.exit(0);\n                                       });\n\n            // Add menu items to popup menu\n            popup.add(showItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n\n            // Create tray icon\n            trayIcon = new TrayIcon(icon, \"Stirling-PDF\", popup);\n            trayIcon.setImageAutoSize(true);\n\n            // Add double-click behavior\n            trayIcon.addActionListener(e-> {\n                                           frame.setVisible(true);\n                                           frame.setState(Frame.NORMAL);\n                                       });\n\n            // Add tray icon to system tray\n            systemTray.add(trayIcon);\n\n            // Modify frame behavior to minimize to tray\n            frame.addWindowStateListener(new WindowStateListener() {\n                public void windowStateChanged(WindowEvent e) {\n                    if (e.getNewState() == Frame.ICONIFIED) {\n                        frame.setVisible(false);\n                    }\n                }\n\n                                         });\n        } catch (AWTException e) {\n            log.error(\"Error setting up system tray icon\", e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "305", "src_id": "M477", "code": "\n    private void handleSplitByDocCount(PDDocument sourceDocument, int documentCount, ZipOutputStream zipOut,String baseFilename) throws IOException {\n        log.debug(\"Starting handleSplitByDocCount with documentCount={}\", documentCount);\n        int totalPageCount = sourceDocument.getNumberOfPages();\n        log.debug(\"Total pages in source document: {}\", totalPageCount);\n        int pagesPerDocument = totalPageCount/documentCount;\n        int extraPages = totalPageCount%documentCount;\n        log.debug(\"Pages per document: {}, Extra pages: {}\", pagesPerDocument, extraPages);\n        int currentPageIndex = 0;\n        int fileIndex = 1;\n        for(int i = 0; i < documentCount; i++) {\n            log.debug(\"Creating document {} of {}\", i + 1, documentCount);\n            PDDocument currentDoc = null;\n            try {\n                currentDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(sourceDocument);\n                log.debug(\"Successfully created document {} of {}\", i + 1, documentCount);\n            } catch (Exception e) {\n                log.error(\"Error creating document {} of {}\", i + 1, documentCount, e);\n                throw ExceptionUtils.createFileProcessingException(\"split\", e);\n            }\n            int pagesToAdd = pagesPerDocument + (i < extraPages? 1: 0);\n            log.debug(\"Adding {} pages to document {}\", pagesToAdd, i + 1);\n            for(int j = 0; j < pagesToAdd; j++) {\n                try {\n                    log.debug(\"Adding page {} (index {}) to document {}\", j + 1, currentPageIndex, i + 1);\n                    currentDoc.addPage(sourceDocument.getPage(currentPageIndex));\n                    log.debug(\"Successfully added page {} to document {}\", j + 1, i + 1);\n                    currentPageIndex++;\n                } catch (Exception e) {\n                    log.error(\"Error adding page {} to document {}\", j + 1, i + 1, e);\n                    throw ExceptionUtils.createFileProcessingException(\"split\", e);\n                }\n            }\n\n            try {\n                log.debug(\"Saving document {} with {} pages\", i + 1, pagesToAdd);\n                saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n                log.debug(\"Successfully saved document {}\", i + 1);\n            } catch (Exception e) {\n                log.error(\"Error saving document {}\", i + 1, e);\n                throw e;\n            }\n        }\n\n        log.debug(\"Completed handleSplitByDocCount with {} documents created\", documentCount);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "306", "src_id": "M577", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "307", "src_id": "M522", "code": "\n    @\n        PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\") @Operation(summary = \"Auto split PDF pages into separate documents\", description = \"This endpoint accepts a PDF file, scans each page for a specific QR code, and\" + \" splits the document at the QR code boundaries. The output is a zip file\"\n+ \" containing each separate PDF document. Input:PDF Output:ZIP-PDF\" + \" Type:SISO\") public ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request) throws IOException {\n        MultipartFile file = request.getFileInput();\n        boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n        PDDocument document = null;\n        List<PDDocument> splitDocuments = new ArrayList< >();\n        Path zipFile = null;\n        byte[] data = null;\n        try {\n            document = pdfDocumentFactory.load(file.getInputStream());\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pdfRenderer.setSubsamplingAllowed(true);\n            for(int page = 0; page < document.getNumberOfPages(); ++page) {\n                BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n                String result = decodeQRCode(bim);\n                boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n                log.debug(\"detected qr code {}, code is vale={}\", result, isValidQrCode);\n                if (isValidQrCode && page != 0) {\n                    splitDocuments.add(new PDDocument());\n                }\n\n                if (!splitDocuments.isEmpty() && !isValidQrCode) {\n                    splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n                } else if (page == 0) {\n                           PDDocument firstDocument = new PDDocument();\n                           firstDocument.addPage(document.getPage(page));\n                           splitDocuments.add(firstDocument);\n                       }\n\n                // If duplexMode is true and current page is a divider, then skip next page\n\n                if (duplexMode && isValidQrCode) {\n                    page++;\n                }\n            }\n\n            // Remove split documents that have no pages\n\n            splitDocuments.removeIf(pdDocument->pdDocument.getNumberOfPages() == 0);\n            zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n            String filename = Filenames.toSimpleFileName(file.getOriginalFilename())\n                .replaceFirst(\"[.][^.]+$\", \"\");\n            try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile))) {\n                for(int i = 0; i < splitDocuments.size(); i++) {\n                    String fileName = filename\n                        + \"_\"\n+ (i + 1)\n+ \".pdf\";\n                    PDDocument splitDocument = splitDocuments.get(i);\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    splitDocument.save(baos);\n                    byte[] pdf = baos.toByteArray();\n                    ZipEntry pdfEntry = new ZipEntry(fileName);\n                    zipOut.putNextEntry(pdfEntry);\n                    zipOut.write(pdf);\n                    zipOut.closeEntry();\n                }\n            }\n\n            data = Files.readAllBytes(zipFile);\n            return WebResponseUtils.bytesToWebResponse(data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM);\n        } catch (Exception e) {\n            log.error(\"Error in auto split\", e);\n            throw e;\n        }\n\n        finally {\n            // Clean up resources\n                if (document != null) {\n                    try {\n                        document.close();\n                    } catch (IOException e) {\n                        log.error(\"Error closing main PDDocument\", e);\n                    }\n                }\n\n                for (PDDocument splitDoc : splitDocuments) {\n                    try {\n                        splitDoc.close();\n                    } catch (IOException e) {\n                        log.error(\"Error closing split PDDocument\", e);\n                    }\n                }\n\n                if (zipFile != null) {\n                    try {\n                        Files.deleteIfExists(zipFile);\n                    } catch (IOException e) {\n                        log.error(\"Error deleting temporary zip file\", e);\n                    }\n                }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "308", "src_id": "M443", "code": "\n    private void checkAndRefreshExplorer() {\n        if (!IS_WINDOWS) {\n            return;\n        }\n\n        if (timeAt90Percent == - 1) {\n            timeAt90Percent = System.currentTimeMillis();\n            stuckTimer = new Timer(1000, e-> {\n                                             long currentTime = System.currentTimeMillis();\n                                             if (currentTime - timeAt90Percent > stuckThreshold) {\n                                                 try {\n                                                     log.debug(\"Attempting Windows explorer refresh due to 90% stuck state\");\n                                                     String currentDir = System.getProperty(\"user.dir\");\n\n                                        // Store current explorer PIDs before we start new one\n                                                     Set<String> existingPids = new HashSet< >();\n                                                     ProcessBuilder listExplorer = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\", \"get\", \"ProcessId\", \"/format:csv\");\n                                                     Process process = listExplorer.start();\n                                                     BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                                                     String line;\n                                                     while((line = BoundedLineReader.readLine(reader, 5_000_000)) != null) {\n                                                         if (line.matches(\".*\\\\d+.*\")) { // Contains numbers\n                                                             String[] parts = line.trim()\n                                                                 .split(\",\");\n                                                             if (parts.length >= 2) {\n                                                                 existingPids.add(parts[parts.length - 1].trim());\n                                                             }\n                                                         }\n                                                     }\n\n                                                     process.waitFor(2, TimeUnit.SECONDS);\n\n                                        // Start new explorer\n                                                     ProcessBuilder pb = new ProcessBuilder(\"cmd\", \"/c\", \"start\", \"/min\", \"/b\", \"explorer.exe\", currentDir);\n                                                     pb.redirectErrorStream(true);\n                                                     explorerProcess = pb.start();\n\n                                        // Schedule cleanup\n                                                     Timer cleanupTimer = new Timer(2000, cleanup-> {\n                                                                                              try {\n                                                                // Find new explorer processes\n                                                                                                  ProcessBuilder findNewExplorer = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\", \"get\", \"ProcessId\", \"/format:csv\");\n                                                                                                  Process newProcess = findNewExplorer.start();\n                                                                                                  BufferedReader newReader = new BufferedReader(new InputStreamReader(newProcess.getInputStream()));\n                                                                                                  String newLine;\n                                                                                                  while((newLine = BoundedLineReader.readLine(newReader, 5_000_000)) != null) {\n                                                                                                      if (newLine.matches(\".*\\\\d+.*\")) {\n                                                                                                          String[] parts = newLine.trim()\n                                                                                                              .split(\",\");\n                                                                                                          if (parts.length >= 2) {\n                                                                                                              String pid = parts[parts.length - 1].trim();\n                                                                                                              if (!existingPids.contains(pid)) {\n                                                                                                                  log.debug(\"Found new explorer.exe with PID: \" + pid);\n                                                                                                                  ProcessBuilder killProcess = new ProcessBuilder(\"taskkill\", \"/PID\", pid, \"/F\");\n                                                                                                                  killProcess.redirectErrorStream(true);\n                                                                                                                  Process killResult = killProcess.start();\n                                                                                                                  killResult.waitFor(2, TimeUnit.SECONDS);\n                                                                                                                  log.debug(\"Explorer process terminated: \" + pid);\n                                                                                                              }\n                                                                                                          }\n                                                                                                      }\n                                                                                                  }\n\n                                                                                                  newProcess.waitFor(2, TimeUnit.SECONDS);\n                                                                                              } catch (Exception ex) {\n                                                                                                  log.error(\"Error cleaning up Windows explorer process\", ex);\n                                                                                              }\n                                                                                          });\n                                                     cleanupTimer.setRepeats(false);\n                                                     cleanupTimer.start();\n                                                     stuckTimer.stop();\n                                                 } catch (Exception ex) {\n                                                     log.error(\"Error refreshing Windows explorer\", ex);\n                                                 }\n                                             }\n                                         });\n            stuckTimer.setRepeats(true);\n            stuckTimer.start();\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "309", "src_id": "M408", "code": "\n    private static Path unzipAndGetMainHtml(byte[] fileBytes) throws IOException {\n        Path tempDirectory = Files.createTempDirectory(\"unzipped_\");\n        try (ZipInputStream zipIn =ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(fileBytes))) {\n            ZipEntry entry = zipIn.getNextEntry();\n            while(entry != null) {\n                Path filePath = tempDirectory.resolve(sanitizeZipFilename(entry.getName()));\n                if (entry.isDirectory()) {\n                    Files.createDirectories(filePath); // Explicitly create the directory structure\n                } else {\n                    Files.createDirectories(filePath.getParent()); // Create parent directories if they don't exist\n                    Files.copy(zipIn, filePath);\n                }\n\n                zipIn.closeEntry();\n                entry = zipIn.getNextEntry();\n            }\n        }\n\n        // Search for the main HTML file.\n\n        try (Stream<Path> walk =Files.walk(tempDirectory)) {\n            List<Path> htmlFiles = walk.filter(file->file.toString()\n                .endsWith(\".html\"))\n                    .toList();\n            if (htmlFiles.isEmpty()) {\n                throw new IOException(\"No HTML files found in the unzipped directory.\");\n            }\n\n            // Prioritize 'index.html' if it exists, otherwise use the first .html file\n\n            for (Path htmlFile : htmlFiles) {\n                if (\"index.html\"\n                    .equals(htmlFile.getFileName()\n                        .toString())) {\n                    return htmlFile;\n                }\n            }\n\n            return htmlFiles.get(0);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "310", "src_id": "M197", "code": "\n    @\n        Scheduled(fixedDelayString = \"#{applicationProperties.system.tempFileManagement.cleanupIntervalMinutes}\", timeUnit = TimeUnit.MINUTES) public void scheduledCleanup() {\n        log.info(\"Running scheduled temporary file cleanup\");\n        long maxAgeMillis = tempFileManager.getMaxAgeMillis();\n\n        // Clean up registered temp files (managed by TempFileRegistry)\n        int registeredDeletedCount = tempFileManager.cleanupOldTempFiles(maxAgeMillis);\n        log.info(\"Cleaned up {} registered temporary files\", registeredDeletedCount);\n\n        // Clean up registered temp directories\n        int directoriesDeletedCount = 0;\n        for (Path directory : registry.getTempDirectories()) {\n            try {\n                if (Files.exists(directory)) {\n                    GeneralUtils.deleteDirectory(directory);\n                    directoriesDeletedCount++;\n                    log.debug(\"Cleaned up temporary directory: {}\", directory);\n                }\n            } catch (IOException e) {\n                log.warn(\"Failed to clean up temporary directory: {}\", directory, e);\n            }\n        }\n\n        // Clean up PDFBox cache file\n\n        cleanupPDFBoxCache();\n\n        // Clean up unregistered temp files based on our cleanup strategy\n        boolean containerMode = isContainerMode();\n        int unregisteredDeletedCount = cleanupUnregisteredFiles(containerMode, true, maxAgeMillis);\n        if (registeredDeletedCount > 0||unregisteredDeletedCount > 0||directoriesDeletedCount > 0) {\n            log.info(\"Scheduled cleanup complete. Deleted {} registered files, {} unregistered files, {} directories\", registeredDeletedCount, unregisteredDeletedCount, directoriesDeletedCount);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "311", "src_id": "M102", "code": "\n    @\n        Override protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {\n        String uri = request.getRequestURI();\n        String contextPath = request.getContextPath();\n        String[] permitAllPatterns = {contextPath + \"/login\", contextPath + \"/register\", contextPath + \"/error\", contextPath + \"/images/\", contextPath + \"/public/\", contextPath + \"/css/\", contextPath + \"/fonts/\", contextPath + \"/js/\", contextPath + \"/pdfjs/\", contextPath + \"/pdfjs-legacy/\", contextPath + \"/api/v1/info/status\", contextPath + \"/site.webmanifest\"};\n        for (String pattern : permitAllPatterns) {\n            if (uri.startsWith(pattern)||uri.endsWith(\".svg\")||uri.endsWith(\".png\")||uri.endsWith(\".ico\")) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "312", "src_id": "M542", "code": "\n    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos,int width) {\n    StringBuilder sb = new StringBuilder(8192);\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n                                                                                                Map<String, Object> info = entry.getValue();\n                                                                                                TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n                                                                                                TableElement appendersTable = new TableElement().rightCellPadding(1);\n                                                                                                Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n                                                                                                table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name))).row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName())).row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n                                                                                                if (info.get(LoggerHelper.effectiveLevel) != null) {\n                                                                                    table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n                                                                                                }\n\n                                                                                                if (info.get(LoggerHelper.config) != null) {\n                                                                                    table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n                                                                                                }\n                                                                                                table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n                                                                                                @ SuppressWarnings(\"unchecked\" ) List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n                                                                                                if (appenders != null && !appenders.isEmpty()) {\n                                                                                    for (Map<String, Object> appenderInfo : appenders) {\n                                                                                                                                                   Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                                                                                                                                                   appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                                                                                                                                                   appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                                                                                                                                                   appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                                                                                                                                                   appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                                                                                                                                                   if (appenderInfo.get(LoggerHelper.file) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                                                                                                                                                   }\n\n                                                                                                                                                   if (appenderInfo.get(LoggerHelper.target) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                                                                                                                                                   }\n\n                                                                                                                                                   if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                                                                                                                                                   }\n\n                                                                                                                                                   if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                                                                                                                                           appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                                                                                                                                                   }\n                                                                                    }\n                                                                                    table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n                                                                                                }\n                                                                                                sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n\n    return sb.toString();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "313", "src_id": "M1126", "code": "\n    private ApiResponse processInitSessionRequest(ApiRequest apiRequest) throws ApiException {\n    ApiResponse response = new ApiResponse();\n\n        //create session\n    Session session = sessionManager.createSession();\n    if (session != null) {\n\n            //Result Distributor\n        SharingResultDistributorImpl resultDistributor = new SharingResultDistributorImpl(session);\n            //create consumer\n        ResultConsumer resultConsumer = new ResultConsumerImpl();\n        resultDistributor.addConsumer(resultConsumer);\n        session.setResultDistributor(resultDistributor);\n        resultDistributor.appendResult(new MessageModel(\"Welcome to arthas!\"));\n\n            //welcome message\n        WelcomeModel welcomeModel = new WelcomeModel();\n        welcomeModel.setVersion(ArthasBanner.version());\n        welcomeModel.setWiki(ArthasBanner.wiki());\n        welcomeModel.setTutorials(ArthasBanner.tutorials());\n        welcomeModel.setMainClass(PidUtils.mainClass());\n        welcomeModel.setPid(PidUtils.currentPid());\n        welcomeModel.setTime(DateUtils.getCurrentDateTime());\n        resultDistributor.appendResult(welcomeModel);\n\n            //allow input\n        updateSessionInputStatus(session, InputStatus.ALLOW_INPUT);\n        response.setSessionId(session.getSessionId()).setConsumerId(resultConsumer.getConsumerId()).setState(ApiState.SUCCEEDED);\n    } else {\n        throw new ApiException(\"create api session failed\");\n    }\n\n    return response;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "314", "src_id": "M1157", "code": "\n    private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n    DefaultFullHttpResponse fullResp = null;\n    InputStream in = null;\n    try {\n        URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n        if (res != null) {\n        fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n        in = res.openStream();\n        byte[] tmp = new byte[256];\n        for (int l = 0; l != -1; l = in.read(tmp)) {\n                             fullResp.content().writeBytes(tmp, 0, l);\n        }\n        int li = path.lastIndexOf('.');\n        if (li != -1 && li != path.length() - 1) {\n                             String ext = path.substring(li + 1);\n                             String contentType;\n                             if (\"html\".equals(ext)) {\n                                                     contentType = \"text/html\";\n                             } else if (\"js\".equals(ext)) {\n                               contentType = \"application/javascript\";\n                             } else if (\"css\".equals(ext)) {\n                               contentType = \"text/css\";\n                                    } else {\n                               contentType = null;\n                                    }\n\n                             if (contentType != null) {\n                                                     fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                             }\n        }\n        }\n    }\n\n        finally {\n        IOUtils.close(in);\n    }\n\n    return fullResp;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "315", "src_id": "M515", "code": "\n    @Override\n    public void draw(CommandProcess process, StackModel result) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(ThreadUtil.getThreadTitle(result)).append(\"\\n\");\n    StackTraceElement [] stackTraceElements = result.getStackTrace();\n    StackTraceElement locationStackTraceElement = stackTraceElements[0];\n    String locationString = String.format(\"    @%s.%s()\", locationStackTraceElement.getClassName(), locationStackTraceElement.getMethodName());\n    sb.append(locationString).append(\"\\n\");\n    int skip = 1;\n    for (int index = skip; index < stackTraceElements.length; index++) {\n                                                                    StackTraceElement ste = stackTraceElements[index];\n                                                                    sb.append(\"        at \").append(ste.getClassName()).append(\".\").append(ste.getMethodName()).append(\"(\").append(ste.getFileName()).append(\":\").append(ste.getLineNumber()).append(\")\\n\");\n    }\n    process.write(\"ts=\" + DateUtils.formatDateTime(result.getTs()) + \";\" + sb.toString() + \"\\n\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "316", "src_id": "M1130", "code": "\n    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n    boolean oneTimeAccess = false;\n    if (session.get(ONETIME_SESSION_KEY) != null) {\n        oneTimeAccess = true;\n    }\n\n    try {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<String, Object>();\n        body.put(\"command\", commandLine);\n        ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n        if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n        return response;\n        }\n        int lock = session.getLock();\n        PackingResultDistributor packingResultDistributor = null;\n        Job job = null;\n        try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n            logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n            return response;\n        }\n        packingResultDistributor = new PackingResultDistributorImpl(session);\n                //distribute result message both to origin session channel and request channel by CompositeResultDistributor\n                //ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n        job = this.createJob(commandLine, session, packingResultDistributor);\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n        job.run();\n        }\n\n        catch(Throwable e) {\n        logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n        return response;\n        }\n\nfinally {\n            if (session.getLock() == lock) {\n            session.unLock();\n            }\n        }\n\n            //wait for job completed or timeout\n        Integer timeout = apiRequest.getExecTimeout();\n        if (timeout == null || timeout <= 0) {\n        timeout = DEFAULT_EXEC_TIMEOUT;\n        }\n        boolean timeExpired = !waitForJob(job, timeout);\n        if (timeExpired) {\n        logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n        job.interrupt();\n        response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n        } else {\n        response.setState(ApiState.SUCCEEDED);\n        }\n\n            //packing results\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        body.put(\"timeExpired\", timeExpired);\n        if (timeExpired) {\n        body.put(\"timeout\", timeout);\n        }\n        body.put(\"results\", packingResultDistributor.getResults());\n        response.setSessionId(session.getSessionId())\n                    //.setConsumerId(consumerId).setBody(body);\n        return response;\n    }\n\n        finally {\n        if (oneTimeAccess) {\n        sessionManager.removeSession(session.getSessionId());\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "317", "src_id": "M536", "code": "\n    public static String drawThreadInfo(List<ThreadVO> threads, int width,int height) {\n    TableElement table = new TableElement(1, 6, 3, 2, 2, 2, 2, 2, 2, 2).overflow(Overflow.HIDDEN).rightCellPadding(1);\n\n        // Header\n    table.add(new RowElement().style(Decoration.bold.fg(Color.black).bg(Color.white)).add(\"ID\", \"NAME\", \"GROUP\", \"PRIORITY\", \"STATE\", \"%CPU\", \"DELTA_TIME\", \"TIME\", \"INTERRUPTED\", \"DAEMON\"));\n    int count = 0;\n    for (ThreadVO thread : threads) {\n                                                                                          Color color = colorMapping.get(thread.getState());\n                                                                                          String time = formatTimeMills(thread.getTime());\n                                                                                          String deltaTime = formatTimeMillsToSeconds(thread.getDeltaTime());\n                                                                                          double cpu = thread.getCpu();\n                                                                                          LabelElement daemonLabel = new LabelElement(thread.isDaemon());\n                                                                                          if (!thread.isDaemon()) {\n                                        daemonLabel.setStyle(Style.style(Color.magenta));\n                                                                                          }\n                                                                                          LabelElement stateElement;\n                                                                                          if (thread.getState() != null) {\n                                        stateElement = new LabelElement(thread.getState()).style(color.fg());\n                                                                                          } else {\n                                        stateElement = new LabelElement(\"-\");\n                                                                                          }\n                                                                                          table.row(new LabelElement(thread.getId()), new LabelElement(thread.getName()), new LabelElement(thread.getGroup() != null ? thread.getGroup() : \"-\"), new LabelElement(thread.getPriority()), stateElement, new LabelElement(cpu), new LabelElement(deltaTime), new LabelElement(time), new LabelElement(thread.isInterrupted()), daemonLabel);\n                                                                                          if (++ count >= height) {\n                                        break;\n                                                                                          }\n    }\n\n    return RenderUtil.render(table, width, height);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "318", "src_id": "M1125", "code": "\n    private ApiResponse dispatchRequest(ApiAction action, ApiRequest apiRequest, Session session) throws ApiException {\n    switch (action) {\n        case EXEC:\n        return processExecRequest(apiRequest, session);\n        case ASYNC_EXEC:\n        return processAsyncExecRequest(apiRequest, session);\n        case INTERRUPT_JOB:\n        return processInterruptJob(apiRequest, session);\n        case PULL_RESULTS:\n        return processPullResultsRequest(apiRequest, session);\n        case SESSION_INFO:\n        return processSessionInfoRequest(apiRequest, session);\n        case JOIN_SESSION:\n        return processJoinSessionRequest(apiRequest, session);\n        case CLOSE_SESSION:\n        return processCloseSessionRequest(apiRequest, session);\n        case INIT_SESSION:\n        break;\n    }\n\n    return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "319", "src_id": "M1470", "code": "\n    public static Pair<String, NavigableMap<Integer, Integer>> decompileWithMappings(String classFilePath, String methodName, boolean hideUnicode, boolean printLineNumber) {\n    final StringBuilder sb = new StringBuilder(8192);\n    final NavigableMap<Integer, Integer> lineMapping = new TreeMap<Integer, Integer>();\n\n    OutputSinkFactory mySink = new OutputSinkFactory() {\n        @Override\n        public List<SinkClass> getSupportedSinks(SinkType sinkType, Collection<SinkClass> collection) {\n                                   return Arrays.asList(SinkClass.STRING, SinkClass.DECOMPILED, SinkClass.DECOMPILED_MULTIVER, SinkClass.EXCEPTION_MESSAGE, SinkClass.LINE_NUMBER_MAPPING);\n        }\n            @Override\n            public <T> Sink<T> getSink(final SinkType sinkType, final SinkClass sinkClass) {\n                                   return new Sink<T>() {\n                                       @Override\n                                       public void write(T sinkable) {\n                        // skip message like: Analysing type demo.MathGame\n                                              if (sinkType == SinkType.PROGRESS) {\n                                           return;\n                                              }\n\n                                              if (sinkType == SinkType.LINENUMBER) {\n                                           LineNumberMapping mapping = (LineNumberMapping) sinkable;\n\n                                           NavigableMap<Integer, Integer> classFileMappings = mapping.getClassFileMappings();\n\n                                           NavigableMap<Integer, Integer> mappings = mapping.getMappings();\n                                           if (classFileMappings != null && mappings != null) {\n                                                  for (Entry<Integer, Integer> entry : mappings.entrySet()) {\n                                                                                                  Integer srcLineNumber = classFileMappings.get(entry.getKey());\n                                                                                                  lineMapping.put(entry.getValue(), srcLineNumber);\n                                                  }\n                                           }\n                                           return;\n                                              }\n                                              sb.append(sinkable);\n                                       }\n\n                                          };\n            }\n\n};\n\n    HashMap<String, String> options = new HashMap<String, String>();\n        /**\n         * @see org.benf.cfr.reader.util.MiscConstants.Version.getVersion() Currently,\n         *      the cfr version is wrong. so disable show cfr version.\n         */\n    options.put(\"showversion\", \"false\");\n    options.put(\"hideutf\", String.valueOf(hideUnicode));\n    options.put(\"trackbytecodeloc\", \"true\");\n\n    if (!StringUtils.isBlank(methodName)) {\n        options.put(\"methodname\", methodName);\n    }\n\n    CfrDriver driver = new CfrDriver . Builder().withOptions(options).withOutputSink(mySink).build();\n\n    List<String> toAnalyse = new ArrayList<String>();\n    toAnalyse.add(classFilePath);\n    driver.analyse(toAnalyse);\n    String resultCode = sb.toString();\n    if (printLineNumber && !lineMapping.isEmpty()) {\n        resultCode = addLineNumber(resultCode, lineMapping);\n    }\n    return Pair.make(resultCode, lineMapping);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "320", "src_id": "M1355", "code": "\n    public static String nullSafeToString(char[] array) {\n    if (array == null) {\n        return \"null\";\n    } else {\n      int length = array.length;\n      if (length == 0) {\n        return \"{}\";\n      } else {\n        StringBuilder sb = new StringBuilder(\"{\");\n        for (int i = 0; i < length; ++i) {\n                 if (i > 0) {\n                                             sb.append(\", \");\n                 }\n                 sb.append(\"\\'\").append(array[i]).append(\"\\'\");\n        }\n        sb.append(\"}\");\n        return sb.toString();\n      }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "321", "src_id": "M454", "code": "\n    private void renderObject(Object obj, int deep, int expand, final StringBuilder buf) throws ObjectTooLargeException {\n    if (null == obj) {\n        appendStringBuilder(buf, \"null\");\n    } else {\n      final Class<?> clazz = obj.getClass();\n      final String className = clazz.getSimpleName();\n\n            // 7种基础类型,直接输出@类型[值]\n      if (Integer.class.isInstance(obj) || Long.class.isInstance(obj)|| Float.class.isInstance(obj)|| Double.class.isInstance(obj)\n                    //                    || Character.class.isInstance(obj)|| Short.class.isInstance(obj)|| Byte.class.isInstance(obj)|| Boolean.class.isInstance(obj)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n      }\n\n            // Char要特殊处理,因为有不可见字符的因素 else if (Character.class.isInstance(obj)) {\n                                              final Character c = (Character) obj;\n\n                // ASCII的可见字符\n                                              if (c >= 32 && c <= 126) {\n                                                       appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n                                              }\n\n                // ASCII的控制字符 else if (ASCII_MAP.containsKey((byte) c.charValue())) {\n                                                                               appendStringBuilder(buf, format(\"@%s[%s]\", className, ASCII_MAP.get((byte) c.charValue())));\n                                                                                    }\n\n                // 超过ASCII的编码范围 else {\n                                                                                                                       appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n                                              }\n                                                   }\n\n            // 字符串类型单独处理 else if (String.class.isInstance(obj)) {\n                                                                               appendStringBuilder(buf, \"@\");\n                                                                               appendStringBuilder(buf, className);\n                                                                               appendStringBuilder(buf, \"[\");\n                                                                               for (Character c : ((String) obj).toCharArray()) {\n                                                                                                                          switch(c) {\n                                                                                                                          case '\\n':\n                                                                                   appendStringBuilder(buf, \"\\\\n\");\n                                                                                   break;\n                                                                                                                                    case '\\r':\n                                                                                   appendStringBuilder(buf, \"\\\\r\");\n                                                                                   break;\n                                                                                                                                    default:\n                                                                                   appendStringBuilder(buf, c.toString());\n                                                                                                                          }//switch\n                                                                               }//for\n                                                                               appendStringBuilder(buf, \"]\");\n                                                                                    }\n\n            // 集合类输出 else if (Collection.class.isInstance(obj)) {\n                                                                                                            @SuppressWarnings(\"unchecked\") final Collection<Object> collection = (Collection<Object>) obj;\n\n                // 非根节点或空集合只展示摘要信息\n                                                                                                            if (!isExpand(deep, expand) || collection.isEmpty()) {\n                                                                                                                     appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, collection.isEmpty(), collection.size()));\n                                                                                                            }\n\n                // 展开展示 else {\n                                                                                                                                       appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                       for (Object e : collection) {\n                                                                                                                                                appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                       appendStringBuilder(buf, TAB);\n                                                                                                                                                }\n                                                                                                                                                renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                appendStringBuilder(buf, \",\");\n                                                                                                                                       }\n                                                                                                                                       appendStringBuilder(buf, \"\\n\");\n                                                                                                                                       for (int i = 0; i < deep; i++) {\n                                                                                                                                                appendStringBuilder(buf, TAB);\n                                                                                                                                       }\n                                                                                                                                       appendStringBuilder(buf, \"]\");\n                                                                                                            }\n                                                                                                                 }\n\n\n            // Map类输出 else if (Map.class.isInstance(obj)) {\n                                                                                                                                           @SuppressWarnings(\"unchecked\") final Map<Object, Object> map = (Map<Object, Object>) obj;\n\n                // 非根节点或空集合只展示摘要信息\n                                                                                                                                           if (!isExpand(deep, expand) || map.isEmpty()) {\n                                                                                                                                                    appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, map.isEmpty(), map.size()));\n                                                                                                                                           } else {\n                                                                                                                                             appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                             for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                                                                                                                                                      appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                      for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                        appendStringBuilder(buf, TAB);\n                                                                                                                                                      }\n                                                                                                                                                      renderObject(entry.getKey(), deep + 1, expand, buf);\n                                                                                                                                                      appendStringBuilder(buf, \":\");\n                                                                                                                                                      renderObject(entry.getValue(), deep + 1, expand, buf);\n                                                                                                                                                      appendStringBuilder(buf, \",\");\n                                                                                                                                             }\n                                                                                                                                             appendStringBuilder(buf, \"\\n\");\n                                                                                                                                             for (int i = 0; i < deep; i++) {\n                                                                                                                                                      appendStringBuilder(buf, TAB);\n                                                                                                                                             }\n                                                                                                                                             appendStringBuilder(buf, \"]\");\n                                                                                                                                           }\n                                                                                                                                                }\n\n\n            // 数组类输出 else if (obj.getClass().isArray()) {\n                                                                                                                                                                         final String typeName = obj.getClass().getSimpleName();\n\n                // int[]\n                                                                                                                                                                         if (typeName.equals(\"int[]\")) {\n                                                                                                                                                                                  final int[] arrays = (int[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                  if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                             appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                  }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                 appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                 for ( int e : arrays) {\n                                                                                                                                                                                                                          appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                          for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                           appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                          }\n                                                                                                                                                                                                                          renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                          appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                 }\n                                                                                                                                                                                                                 appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                 for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                          appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                 }\n                                                                                                                                                                                                                 appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                  }\n                                                                                                                                                                         }\n\n                // long[] else if (typeName.equals(\"long[]\")) {\n                                                                                                                                                                                                      final long[] arrays = (long[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                      if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                               appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                      }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                     appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                     for ( long e : arrays) {\n                                                                                                                                                                                                                                              appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                              for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                              }\n                                                                                                                                                                                                                                              renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                              appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                     }\n                                                                                                                                                                                                                                     appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                     for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                              appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                     }\n                                                                                                                                                                                                                                     appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                      }\n                                                                                                                                                                                                           }\n\n                // short[] else if (typeName.equals(\"short[]\")) {\n                                                                                                                                                                                                                                         final short[] arrays = (short[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                                                         if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                                                                  appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                                                         }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                                                        appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                        for ( short e : arrays) {\n                                                                                                                                                                                                                                                                                 appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                 for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                    appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                 }\n                                                                                                                                                                                                                                                                                 renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                 appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                        }\n                                                                                                                                                                                                                                                                        appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                        for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                 appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                        }\n                                                                                                                                                                                                                                                                        appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                         }\n                                                                                                                                                                                                                                              }\n\n                // float[] else if (typeName.equals(\"float[]\")) {\n                                                                                                                                                                                                                                                                            final float[] arrays = (float[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                                                                                            if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                                                                                                     appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                                                                                            }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                                                                                           appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                                                           for ( float e : arrays) {\n                                                                                                                                                                                                                                                                                                                    appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                    for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                                                       appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                    }\n                                                                                                                                                                                                                                                                                                                    renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                                                    appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                                                           }\n                                                                                                                                                                                                                                                                                                           appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                           for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                                                    appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                           }\n                                                                                                                                                                                                                                                                                                           appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                                                            }\n                                                                                                                                                                                                                                                                                 }\n\n                // double[] else if (typeName.equals(\"double[]\")) {\n                                                                                                                                                                                                                                                                                                                final double[] arrays = (double[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                                                                                                                                if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                                                                                                                                         appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                                                                                                                                }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                                                                                                                               appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                                                                                               for ( double e : arrays) {\n                                                                                                                                                                                                                                                                                                                                                        appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                        for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                                                                                            appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                        }\n                                                                                                                                                                                                                                                                                                                                                        renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                                                                                        appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                                                                                               }\n                                                                                                                                                                                                                                                                                                                                               appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                               for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                                                                                        appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                               }\n                                                                                                                                                                                                                                                                                                                                               appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                                                                                                }\n                                                                                                                                                                                                                                                                                                                     }\n\n                // boolean[] else if (typeName.equals(\"boolean[]\")) {\n                                                                                                                                                                                                                                                                                                                                                     final boolean[] arrays = (boolean[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                                                                                                                                                                     if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                                                                                                                                                                              appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                                                                                                                                                                     }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                                                                                                                                                                    appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                                                                                                                                    for ( boolean e : arrays) {\n                                                                                                                                                                                                                                                                                                                                                                                             appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                             for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                                                  appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                             }\n                                                                                                                                                                                                                                                                                                                                                                                             renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                                                                                                                             appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                                                                                                                                    }\n                                                                                                                                                                                                                                                                                                                                                                                    appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                    for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                             appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                    }\n                                                                                                                                                                                                                                                                                                                                                                                    appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                                                                                                                                     }\n                                                                                                                                                                                                                                                                                                                                                          }\n\n                // char[] else if (typeName.equals(\"char[]\")) {\n                                                                                                                                                                                                                                                                                                                                                                                       final char[] arrays = (char[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                                                                                                                                                                                                       if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                                                                                                                                                                                                                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                                                                                                                                                                                                       }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                                                                                                                                                                                                      appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                                                                                                                                                                      for ( char e : arrays) {\n                                                                                                                                                                                                                                                                                                                                                                                                                               appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                                                               for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                 appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                                                               }\n                                                                                                                                                                                                                                                                                                                                                                                                                               renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                                                                                                                                                               appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                                                                                                                                                                      }\n                                                                                                                                                                                                                                                                                                                                                                                                                      appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                                                      for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                                                               appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                                                      }\n                                                                                                                                                                                                                                                                                                                                                                                                                      appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                                                                                                                                                                       }\n                                                                                                                                                                                                                                                                                                                                                                                            }\n\n                // byte[] else if (typeName.equals(\"byte[]\")) {\n                                                                                                                                                                                                                                                                                                                                                                                                                         final byte[] arrays = (byte[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                                                                                                                                                                                                                                         if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                  appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                                                                                                                                                                                                                                         }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        for (byte e : arrays) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                 appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                                                                                                                                                                                                         }\n                                                                                                                                                                                                                                                                                                                                                                                                                              }\n\n                // Object[] else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                             final Object[] arrays = (Object[]) obj;\n                    // 非根节点或空集合只展示摘要信息\n                                                                                                                                                                                                                                                                                                                                                                                                                                                             if (!isExpand(deep, expand) || arrays.length == 0) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                  appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                             }\n\n                    // 展开展示 else {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for (Object e : arrays) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     renderObject(e, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                             }\n                                                                                                                                                                                                                                                                                                                                                                                            }\n                                                                                                                                                                              }\n\n\n            // Throwable输出 else if (Throwable.class.isInstance(obj)) {\n                                                                                                                                                                                                             if (!isExpand(deep, expand)) {\n                                                                                                                                                                                                                      appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n                                                                                                                                                                                                             } else {\n                                                                                                                                                                                                               final Throwable throwable = (Throwable) obj;\n                                                                                                                                                                                                               final StringWriter sw = new StringWriter();\n                                                                                                                                                                                                               final PrintWriter pw = new PrintWriter(sw);\n                                                                                                                                                                                                               throwable.printStackTrace(pw);\n                                                                                                                                                                                                               appendStringBuilder(buf, sw.toString());\n                                                                                                                                                                                                             }\n                                                                                                                                                                                                                  }\n\n            // Date输出 else if (Date.class.isInstance(obj)) {\n                                                                                                                                                                                                                                           appendStringBuilder(buf, format(\"@%s[%s]\", className, new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\").format(obj)));\n                                                                                                                                                                                                                                                } else if (object instanceof Enum<?>) {\n                                                                                                                                                                                                                                                  appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n                                                                                                                                                                                                                                                       }\n\n            // 普通Object输出 else {\n                                                                                                                                                                                                                                                                                    if (!isExpand(deep, expand)) {\n                                                                                                                                                                                                                                                           appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n                                                                                                                                                                                                                                                                                    } else {\n                                                                                                                                                                                                                                                                                      appendStringBuilder(buf, format(\"@%s[\", className));\n                                                                                                                                                                                                                                                                                      final List<Field> fields;\n\n                                                                                                                                                                                                                                                                                      Class<?> objClass = obj.getClass();\n                                                                                                                                                                                                                                                                                      if (GlobalOptions.printParentFields) {\n                                                                                                                                                                                                                                                                                        fields = new ArrayList<Field>();\n                        // 当父类为null的时候说明到达了最上层的父类(Object类).\n                                                                                                                                                                                                                                                                                        while (objClass != null) {\n                                                                                                                                                                                                                                                                                          fields.addAll(Arrays.asList(objClass.getDeclaredFields()));\n                                                                                                                                                                                                                                                                                          objClass = objClass.getSuperclass();\n                                                                                                                                                                                                                                                                                        }\n                                                                                                                                                                                                                                                                                      } else {\n                                                                                                                                                                                                                                                                                        fields = new ArrayList<Field>(Arrays.asList(objClass.getDeclaredFields()));\n                                                                                                                                                                                                                                                                                      }\n\n                                                                                                                                                                                                                                                                                      for (Field field : fields) {\n                                                                                                                                                                                                                                                                                               field.setAccessible(true);\n                                                                                                                                                                                                                                                                                               try {\n                                                                                                                                                                                                                                                                                          final Object value = field.get(obj);\n                                                                                                                                                                                                                                                                                          appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                          for (int i = 0; i < deep + 1; i++) {\n                                                                                                                                                                                                                                                                                                   appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                          }\n                                                                                                                                                                                                                                                                                          appendStringBuilder(buf, field.getName());\n                                                                                                                                                                                                                                                                                          appendStringBuilder(buf, \"=\");\n                                                                                                                                                                                                                                                                                          renderObject(value, deep + 1, expand, buf);\n                                                                                                                                                                                                                                                                                          appendStringBuilder(buf, \",\");\n                                                                                                                                                                                                                                                                                               } catch (ObjectTooLargeException t) {\n                                                                                                                                                                                                                                                                                                 buf.append(\"...\");\n                                                                                                                                                                                                                                                                                                 break;\n                                                                                                                                                                                                                                                                                               } catch (Throwable t) {\n                            // ignore}\n                                                                                                                                                                                                                                                                                      }//for\n                                                                                                                                                                                                                                                                                      appendStringBuilder(buf, \"\\n\");\n                                                                                                                                                                                                                                                                                      for (int i = 0; i < deep; i++) {\n                                                                                                                                                                                                                                                                                               appendStringBuilder(buf, TAB);\n                                                                                                                                                                                                                                                                                      }\n                                                                                                                                                                                                                                                                                      appendStringBuilder(buf, \"]\");\n                                                                                                                                                                                                                                                                                    }\n                                                                                                                                                                                                                                                }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "322", "src_id": "M140", "code": "\n    void _processDo(int option) throws IOException {\n    if (debugoptions) {\n        System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n    }\n\n    if (__notifhand != null) {\n        __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n    }\n\n    boolean acceptNewState = false;\n\n\n        /* open TelnetOptionHandler functionality (start)*/\n    if (optionHandlers[option] != null) {\n        acceptNewState = optionHandlers[option].getAcceptLocal();\n    } else {\n        /* open TelnetOptionHandler functionality (end)*/\n            /* TERMINAL-TYPE option (start)*/\n      if (option == TERMINAL_TYPE) {\n        if ((terminalType != null) && (terminalType.length() > 0)) {\n                                       acceptNewState = true;\n        }\n      }\n            /* TERMINAL-TYPE option (end)*/\n        /* open TelnetOptionHandler functionality (start)*/\n    }\n        /* open TelnetOptionHandler functionality (end)*/\n\n    if (_willResponse[option] > 0) {\n        -- _willResponse[option];\n\n        if (_willResponse[option] > 0 && _stateIsWill(option)) {\n        -- _willResponse[option];\n        }\n    }\n\n    if (_willResponse[option] == 0) {\n        if (_requestedWont(option)) {\n        switch(option) {\n        default:\n            break;\n        }\n\n        if (acceptNewState) {\n            _setWantWill(option);\n            _sendWill(option);\n        } else {\n          ++_willResponse[option];\n          _sendWont(option);\n        }\n        } else {\n                // Other end has acknowledged option.\n          switch(option) {\n          default:\n            break;\n          }\n        }\n    }\n    _setWill(option);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "323", "src_id": "M927", "code": "\n    public static Map<String, Map<String, Object>> getLoggers(String name, boolean includeNoAppender) {\n    Map<String, Map<String, Object>> loggerInfoMap = new HashMap<String, Map<String, Object>>();\n    if (!Log4j) {\n        return loggerInfoMap;\n    }\n\n    if (name != null && !name.trim().isEmpty()) {\n        Logger logger = LogManager.getLoggerRepository().exists(name);\n        if (logger != null) {\n                                                    loggerInfoMap.put(name, doGetLoggerInfo(logger));\n        }\n    } else {\n            // 获取所有logger时，如果没有appender则忽略\n      @SuppressWarnings(\"unchecked\") Enumeration<Logger> loggers = LogManager.getLoggerRepository().getCurrentLoggers();\n      if (loggers != null) {\n        while (loggers.hasMoreElements()) {\n          Logger logger = loggers.nextElement();\n\n          Map<String, Object> info = doGetLoggerInfo(logger);\n          if (!includeNoAppender) {\n            List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                                      loggerInfoMap.put(logger.getName(), info);\n            }\n          } else {\n            loggerInfoMap.put(logger.getName(), info);\n          }\n        }\n      }\n\n      Logger root = LogManager.getLoggerRepository().getRootLogger();\n      if (root != null) {\n               Map<String, Object> info = doGetLoggerInfo(root);\n               if (!includeNoAppender) {\n          List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n          if (appenders != null && !appenders.isEmpty()) {\n                                           loggerInfoMap.put(root.getName(), info);\n          }\n               } else {\n                 loggerInfoMap.put(root.getName(), info);\n               }\n      }\n    }\n    return loggerInfoMap;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "324", "src_id": "M464", "code": "\n    private void initCommands(List<String> disabledCommands) {\n    List<Class<? extends AnnotatedCommand>> commandClassList = new ArrayList<Class<? extends AnnotatedCommand>>(33);\n    commandClassList.add(HelpCommand.class);\n    commandClassList.add(AuthCommand.class);\n    commandClassList.add(KeymapCommand.class);\n    commandClassList.add(SearchClassCommand.class);\n    commandClassList.add(SearchMethodCommand.class);\n    commandClassList.add(ClassLoaderCommand.class);\n    commandClassList.add(JadCommand.class);\n    commandClassList.add(GetStaticCommand.class);\n    commandClassList.add(MonitorCommand.class);\n    commandClassList.add(StackCommand.class);\n    commandClassList.add(ThreadCommand.class);\n    commandClassList.add(TraceCommand.class);\n    commandClassList.add(WatchCommand.class);\n    commandClassList.add(TimeTunnelCommand.class);\n    commandClassList.add(JvmCommand.class);\n    commandClassList.add(MemoryCommand.class);\n    commandClassList.add(PerfCounterCommand.class);\n        // commandClassList.add(GroovyScriptCommand.class);\n    commandClassList.add(OgnlCommand.class);\n    commandClassList.add(MemoryCompilerCommand.class);\n    commandClassList.add(RedefineCommand.class);\n    commandClassList.add(RetransformCommand.class);\n    commandClassList.add(DashboardCommand.class);\n    commandClassList.add(DumpClassCommand.class);\n    commandClassList.add(HeapDumpCommand.class);\n    commandClassList.add(JulyCommand.class);\n    commandClassList.add(ThanksCommand.class);\n    commandClassList.add(OptionsCommand.class);\n    commandClassList.add(ClsCommand.class);\n    commandClassList.add(ResetCommand.class);\n    commandClassList.add(VersionCommand.class);\n    commandClassList.add(SessionCommand.class);\n    commandClassList.add(SystemPropertyCommand.class);\n    commandClassList.add(SystemEnvCommand.class);\n    commandClassList.add(VMOptionCommand.class);\n    commandClassList.add(LoggerCommand.class);\n    commandClassList.add(HistoryCommand.class);\n    commandClassList.add(CatCommand.class);\n    commandClassList.add(Base64Command.class);\n    commandClassList.add(EchoCommand.class);\n    commandClassList.add(PwdCommand.class);\n    commandClassList.add(MBeanCommand.class);\n    commandClassList.add(GrepCommand.class);\n    commandClassList.add(TeeCommand.class);\n    commandClassList.add(ProfilerCommand.class);\n    commandClassList.add(VmToolCommand.class);\n    commandClassList.add(StopCommand.class);\n    try {\n        if (ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Recording.class\") != null) {\n        commandClassList.add(JFRCommand.class);\n        }\n    } catch (Throwable e) {\n      logger.error(\"This jdk version not support jfr command\");\n    }\n\n    for (Class<? extends AnnotatedCommand> clazz : commandClassList) {\n        Name name = clazz.getAnnotation(Name.class);\n        if (name != null && name.value() != null) {\n        if (disabledCommands.contains(name.value())) {\n            continue;\n        }\n        }\n        commands.add(Command.create(clazz));\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "325", "src_id": "M453", "code": "\n    @Override\n    public String draw() {\n    StringBuilder buf = new StringBuilder();\n    try {\n        if (GlobalOptions.isUsingJson) {\n        return JSON.toJSONString(object, JSONWriter.Feature.IgnoreErrorGetter);\n        }\n        renderObject(object, 0, deep, buf);\n        return buf.toString();\n    } catch (ObjectTooLargeException e) {\n      buf.append(\" Object size exceeds size limit: \").append(maxObjectLength).append(\", try to specify -M size_limit in your command, check the help command for more.\");\n      return buf.toString();\n    } catch (Throwable t) {\n      logger.error(\"ObjectView draw error, object class: {}\", object.getClass(), t);\n      return \"ERROR DATA!!! object class: \" + object.getClass() + \", exception class: \" + t.getClass() + \", exception message: \" + t.getMessage();\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "326", "src_id": "M375", "code": "\n    public static Map<String, String> removeDashKey(Map<String, String> map) {\n    Map<String, String> result = new HashMap<String, String>(map.size());\n    for (Entry<String, String> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (key.contains(\"-\")) {\n                                                           StringBuilder sb = new StringBuilder(key.length());\n                                                           for (int i = 0; i < key.length(); i++) {\n                                   if (key.charAt(i) == '-' && (i + 1 < key.length()) && Character.isAlphabetic(key.charAt(i + 1))) {\n                                                               ++i;\n                                                               char upperChar = Character.toUpperCase(key.charAt(i));\n                                                               sb.append(upperChar);\n                                   } else {\n                                     sb.append(key.charAt(i));\n                                   }\n                                                           }\n                                                           key = sb.toString();\n        }\n        result.put(key, entry.getValue());\n    }\n    return result;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "327", "src_id": "M306", "code": "\n    final void advance() {\n    if (nextEntry != null && (nextEntry = nextEntry.next) != null) {\n        return;\n    }\n\n    while (nextTableIndex >= 0) {\n        if ((nextEntry = currentTable[nextTableIndex --]) != null) {\n        return;\n        }\n    }\n\n    while (nextSegmentIndex >= 0) {\n        Segment<K, V> seg = segments[nextSegmentIndex --];\n        if (seg.count != 0) {\n                                      currentTable = seg.table;\n                                      for (int j = currentTable.length - 1; j >= 0; --j) {\n                                if ((nextEntry = currentTable[j]) != null) {\n                                                                                             nextTableIndex = j - 1;\n                                                                                             return;\n                                }\n                                      }\n        }\n    }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "328", "src_id": "M1338", "code": "\n    public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n    Enum [] var3 = enumValues;\n    int var4 = enumValues.length;\n    int var5 = 0;\n    while (true) {\n        if (var5 >= var4) {\n        return false;\n        }\n\n        Enum candidate = var3[var5];\n        if (caseSensitive) {\n        if (candidate.toString().equals(constant)) {\n            break;\n        }\n        } else if (candidate.toString().equalsIgnoreCase(constant)) {\n                     break;\n               }\n\n        ++var5;\n    }\n    return true;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "329", "src_id": "M185", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "330", "src_id": "M1043", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "331", "src_id": "M1150", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "332", "src_id": "M520", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "333", "src_id": "M1154", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "334", "src_id": "M290", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "335", "src_id": "M196", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "336", "src_id": "M1149", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "337", "src_id": "M219", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "338", "src_id": "M852", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "339", "src_id": "M1086", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "340", "src_id": "M1066", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "341", "src_id": "M1055", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "342", "src_id": "M1058", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "343", "src_id": "M1024", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "344", "src_id": "M1037", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "345", "src_id": "M1079", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "346", "src_id": "M1035", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "347", "src_id": "M521", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "348", "src_id": "M177", "code": "\n    private void executeJob(QueuedJob job) {\n        if (job.cancelled) {\n            log.debug(\"Job {} was cancelled, not executing\", job.jobId);\n            return;\n        }\n        jobExecutor.execute(()-> {\n                                log.debug(\"Executing queued job {} (queued at {})\", job.jobId, job.queuedAt);\n                                try {\n                        // Execute with timeout\n                                    Object result = executeWithTimeout(job.work, job.timeoutMs);\n\n                        // Process the result\n                                    if (result instanceof ResponseEntity) {\n                                        job.future.complete((ResponseEntity<?>) result);\n                                    } else {\n                                        job.future.complete(ResponseEntity.ok(result));\n                                    }\n                                } catch (Exception e) {\n                                    log.error(\"Error executing queued job {}: {}\", job.jobId, e.getMessage(), e);\n                                    job.future.completeExceptionally(e);\n                                }\n                            });\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "349", "src_id": "M843", "code": "\n    @ DeleteMapping(\"/api/v1/general/job/{jobId}\")\n    public ResponseEntity<?> cancelJob(@PathVariable(\"jobId\") String jobId) {\n        log.debug(\"Request to cancel job: {}\", jobId);\n\n        // Verify that this job belongs to the current user\n        // We can use the current request's session to validate ownership\n        Object sessionJobIds = request.getSession().getAttribute(\"userJobIds\");\n        if (sessionJobIds == null || ! (sessionJobIds instanceof java.util.Set)|| ! ((java.util.Set<?>) sessionJobIds).contains(jobId)) {\n            // Either no jobs in session or jobId doesn't match user's jobs\n            log.warn(\"Unauthorized attempt to cancel job: {}\", jobId);\n            return ResponseEntity.status(403).body(Map.of(\"message\", \"You are not authorized to cancel this job\"));\n        }\n\n        // First check if the job is in the queue\n\n\n        boolean cancelled = false;\n        int queuePosition = -1;\n        if (jobQueue.isJobQueued(jobId)) {\n            queuePosition = jobQueue.getJobPosition(jobId);\n            cancelled = jobQueue.cancelJob(jobId);\n            log.info(\"Cancelled queued job: {} (was at position {})\", jobId, queuePosition);\n        }\n\n        // If not in queue or couldn't cancel, try to cancel in TaskManager\n        if (! cancelled) {\n            JobResult result = taskManager.getJobResult(jobId);\n            if (result != null && ! result.isComplete()) {\n                // Mark as error with cancellation message\n                taskManager.setError(jobId, \"Job was cancelled by user\");\n                cancelled = true;\n                log.info(\"Marked job as cancelled in TaskManager: {}\", jobId);\n            }\n        }\n        if (cancelled) {\n            return ResponseEntity.ok(Map.of(\"message\", \"Job cancelled successfully\", \"wasQueued\", queuePosition >= 0, \"queuePosition\", queuePosition >= 0 ? queuePosition : \"n/a\"));\n        } else {\n            // Job not found or already complete\n            JobResult result = taskManager.getJobResult(jobId);\n            if (result == null) {\n                return ResponseEntity.notFound().build();\n            } else if (result.isComplete()) {\n                return ResponseEntity.badRequest().body(Map.of(\"message\", \"Cannot cancel job that is already complete\"));\n            } else {\n                return ResponseEntity.internalServerError().body(Map.of(\"message\", \"Failed to cancel job for unknown reason\"));\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "350", "src_id": "M516", "code": "\n    public ResponseEntity<String> printFile(@ModelAttribute PrintFileRequest request) throws IOException {\n        MultipartFile file = request.getFileInput();\n        String originalFilename = file.getOriginalFilename();\n        if (originalFilename != null && (originalFilename.contains(\"..\") || Paths.get(originalFilename).isAbsolute())) {\n            throw new IOException(\"Invalid file path detected: \" + originalFilename);\n        }\n        String printerName = request.getPrinterName();\n        String contentType = file.getContentType();\n        try {\n            // Find matching printer\n            PrintService[] services = PrintServiceLookup.lookupPrintServices(null, null);\n            PrintService selectedService = Arrays.stream(services).filter(service->service.getName().toLowerCase().contains(printerName)).findFirst().orElseThrow(()-> new IllegalArgumentException(\"No matching printer found\"));\n            log.info(\"Selected Printer: \" + selectedService.getName());\n            if (\"application/pdf\".equals(contentType)) {\n                PDDocument document = Loader.loadPDF(file.getBytes());\n                PrinterJob job = PrinterJob.getPrinterJob();\n                job.setPrintService(selectedService);\n                job.setPageable(new PDFPageable(document));\n                job.print();\n                document.close();\n            } else if (contentType.startsWith(\"image/\")) {\n                       BufferedImage image = ImageIO.read(file.getInputStream());\n                       PrinterJob job = PrinterJob.getPrinterJob();\n                       job.setPrintService(selectedService);\n                       job.setPrintable(new Printable() {\n                           public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n                               if (pageIndex != 0) {\n                                   return NO_SUCH_PAGE;\n                               }\n                               Graphics2D g2d = (Graphics2D) graphics;\n                               g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n                               g2d.drawImage(image, 0, 0, (int) pageFormat.getImageableWidth(), (int) pageFormat.getImageableHeight(), null);\n                               return PAGE_EXISTS;\n                           }\n\n                       });\n                       job.print();\n                   }\n            return new ResponseEntity< >(\"File printed successfully to \" + selectedService.getName(), HttpStatus.OK);\n        } catch (Exception e) {\n            System.err.println(\"Failed to print: \" + e.getMessage());\n            return new ResponseEntity< >(e.getMessage(), HttpStatus.BAD_REQUEST);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "351", "src_id": "M522", "code": "\n    @ PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\") @Operation(summary = \"Auto split PDF pages into separate documents\", description = \"This endpoint accepts a PDF file, scans each page for a specific QR code, and\" + \" splits the document at the QR code boundaries. The output is a zip file\" + \" containing each separate PDF document. Input:PDF Output:ZIP-PDF\" + \" Type:SISO\")\n    public ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request) throws IOException {\n        MultipartFile file = request.getFileInput();\n        boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n        PDDocument document = null;\n        List<PDDocument> splitDocuments = new ArrayList< >();\n        Path zipFile = null;\n        byte[] data = null;\n        try {\n            document = pdfDocumentFactory.load(file.getInputStream());\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pdfRenderer.setSubsamplingAllowed(true);\n            for(int page = 0;\npage < document.getNumberOfPages();\n++ page) {\n                BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n                String result = decodeQRCode(bim);\n                boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n                log.debug(\"detected qr code {}, code is vale={}\", result, isValidQrCode);\n                if (isValidQrCode && page != 0) {\n                    splitDocuments.add(new PDDocument());\n                }\n                if (! splitDocuments.isEmpty() && ! isValidQrCode) {\n                    splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n                } else if (page == 0) {\n                           PDDocument firstDocument = new PDDocument();\n                           firstDocument.addPage(document.getPage(page));\n                           splitDocuments.add(firstDocument);\n                       }\n\n                // If duplexMode is true and current page is a divider, then skip next page\n                if (duplexMode && isValidQrCode) {\n                    page++;\n                }\n            }\n\n            // Remove split documents that have no pages\n            splitDocuments.removeIf(pdDocument->pdDocument.getNumberOfPages() == 0);\n            zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n            String filename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\");\n            try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile))) {\n                for(int i = 0;\ni < splitDocuments.size();\ni++) {\n                    String fileName = filename + \"_\" + (i + 1)+ \".pdf\";\n                    PDDocument splitDocument = splitDocuments.get(i);\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    splitDocument.save(baos);\n                    byte[] pdf = baos.toByteArray();\n                    ZipEntry pdfEntry = new ZipEntry(fileName);\n                    zipOut.putNextEntry(pdfEntry);\n                    zipOut.write(pdf);\n                    zipOut.closeEntry();\n                }\n            }\n            data = Files.readAllBytes(zipFile);\n            return WebResponseUtils.bytesToWebResponse(data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM);\n        } catch (Exception e) {\n            log.error(\"Error in auto split\", e);\n            throw e;\n        } finally {\n            // Clean up resources\n            if (document != null) {\n                try {\n                    document.close();\n                } catch (IOException e) {\n                    log.error(\"Error closing main PDDocument\", e);\n                }\n            }\n            for (PDDocument splitDoc : splitDocuments) {\n                try {\n                    splitDoc.close();\n                } catch (IOException e) {\n                    log.error(\"Error closing split PDDocument\", e);\n                }\n            }\n            if (zipFile != null) {\n                try {\n                    Files.deleteIfExists(zipFile);\n                } catch (IOException e) {\n                    log.error(\"Error deleting temporary zip file\", e);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "352", "src_id": "M550", "code": "\n    @ PostMapping(consumes = \"multipart/form-data\", value = \"/auto-rename\") @Operation(summary = \"Extract header from PDF file\", description = \"This endpoint accepts a PDF file and attempts to extract its title or header\" + \" based on heuristics. Input:PDF Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> extractHeader(@ModelAttribute ExtractHeaderRequest request) throws Exception {\n        MultipartFile file = request.getFileInput();\n        boolean useFirstTextAsFallback = Boolean.TRUE.equals(request.getUseFirstTextAsFallback());\n        PDDocument document = pdfDocumentFactory.load(file);\n        PDFTextStripper reader = new PDFTextStripper() {\n                            List<LineInfo> lineInfos = new ArrayList< >();\n                            StringBuilder lineBuilder = new StringBuilder();\n                            float lastY = -1;\n                            float maxFontSizeInLine = 0.0f;\n                            int lineCount = 0;\n                            @Override protected void processTextPosition(TextPosition text) {\n                                if (lastY != text.getY() && lineCount < LINE_LIMIT) {\n                                    processLine();\n                                    lineBuilder = new StringBuilder(text.getUnicode());\n                                    maxFontSizeInLine = text.getFontSizeInPt();\n                                    lastY = text.getY();\n                                    lineCount++;\n                                } else if (lineCount < LINE_LIMIT) {\n                                           lineBuilder.append(text.getUnicode());\n                                           if (text.getFontSizeInPt() > maxFontSizeInLine) {\n                                               maxFontSizeInLine = text.getFontSizeInPt();\n                                           }\n                                       }\n                            }\n                            private void processLine() {\n                                if (lineBuilder.length() > 0 && lineCount < LINE_LIMIT) {\n                                    lineInfos.add(new LineInfo(lineBuilder.toString(), maxFontSizeInLine));\n                                }\n                            }\n                            @Override\n                            public String getText(PDDocument doc) throws IOException {\n                                this.lineInfos.clear();\n                                this.lineBuilder = new StringBuilder();\n                                this.lastY = -1;\n                                this.maxFontSizeInLine = 0.0f;\n                                this.lineCount = 0;\n                                super.getText(doc);\n                                processLine(); // Process the last line\n\n                        // Merge lines with same font size\n                                List<LineInfo> mergedLineInfos = new ArrayList< >();\n                                for(int i = 0;\ni < lineInfos.size();\ni++) {\n                                    String mergedText = lineInfos.get(i).text;\n                                    float fontSize = lineInfos.get(i).fontSize;\n                                    while(i + 1 < lineInfos.size() && lineInfos.get(i + 1).fontSize == fontSize) {\n                                        mergedText += \" \" + lineInfos.get(i + 1).text;\n                                        i++;\n                                    }\n                                    mergedLineInfos.add(new LineInfo(mergedText, fontSize));\n                                }\n\n                        // Sort lines by font size in descending order and get the first one\n                                mergedLineInfos.sort(Comparator.comparing((LineInfo li)->li.fontSize).reversed());\n                                String title = mergedLineInfos.isEmpty() ? null : mergedLineInfos.get(0).text;\n                                return title != null ? title : (useFirstTextAsFallback ? (mergedLineInfos.isEmpty() ? null : mergedLineInfos.get(mergedLineInfos.size() - 1).text) : null);\n                            }\n                            class LineInfo {\n                                String text;\n                                float fontSize;\n                                LineInfo(String text, float fontSize) {\n                                               this.text = text;\n                                               this.fontSize = fontSize;\n                                           }\n\n                            }\n                        };\n        String header = reader.getText(document);\n\n        // Sanitize the header string by removing characters not allowed in a filename.\n        if (header != null && header.length() < 255) {\n            header = header.replaceAll(\"[/\\\\\\\\?%*:|\\\"<>]\", \"\").trim();\n            return WebResponseUtils.pdfDocToWebResponse(document, header + \".pdf\");\n        } else {\n            log.info(\"File has no good title to be found\");\n            return WebResponseUtils.pdfDocToWebResponse(document, Filenames.toSimpleFileName(file.getOriginalFilename()));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "353", "src_id": "M618", "code": "\n    @ Operation(summary = \"Validate PDF Digital Signature\", description = \"Validates the digital signatures in a PDF file against default or custom\" + \" certificates. Input:PDF Output:JSON Type:SISO\") @PostMapping(value = \"/validate-signature\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\n    public ResponseEntity<List<SignatureValidationResult>> validateSignature(@ModelAttribute SignatureValidationRequest request) throws IOException {\n        List<SignatureValidationResult> results = new ArrayList< >();\n        MultipartFile file = request.getFileInput();\n        MultipartFile certFile = request.getCertFile();\n\n        // Load custom certificate if provided\n        X509Certificate customCert = null;\n        if (certFile != null && ! certFile.isEmpty()) {\n            try (ByteArrayInputStream certStream = new ByteArrayInputStream(certFile.getBytes())) {\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                customCert = (X509Certificate) cf.generateCertificate(certStream);\n            } catch (CertificateException e) {\n                throw ExceptionUtils.createRuntimeException(\"error.invalidFormat\", \"Invalid {0} format: {1}\", e, \"certificate file\", e.getMessage());\n            }\n        }\n        try (PDDocument document = pdfDocumentFactory.load(file.getInputStream())) {\n            List<PDSignature> signatures = document.getSignatureDictionaries();\n            for (PDSignature sig : signatures) {\n                SignatureValidationResult result = new SignatureValidationResult();\n                try {\n                    byte[] signedContent = sig.getSignedContent(file.getInputStream());\n                    byte[] signatureBytes = sig.getContents(file.getInputStream());\n                    CMSProcessable content = new CMSProcessableByteArray(signedContent);\n                    CMSSignedData signedData = new CMSSignedData(content, signatureBytes);\n                    Store<X509CertificateHolder> certStore = signedData.getCertificates();\n                    SignerInformationStore signerStore = signedData.getSignerInfos();\n                    for (SignerInformation signer : signerStore.getSigners()) {\n                        X509CertificateHolder certHolder = (X509CertificateHolder) certStore.getMatches(signer.getSID()).iterator().next();\n                        X509Certificate cert = new JcaX509CertificateConverter().getCertificate(certHolder);\n                        boolean isValid = signer.verify(new JcaSimpleSignerInfoVerifierBuilder().build(cert));\n                        result.setValid(isValid);\n\n                        // Additional validations\n                        result.setChainValid(customCert != null ? certValidationService.validateCertificateChainWithCustomCert(cert, customCert) : certValidationService.validateCertificateChain(cert));\n                        result.setTrustValid(customCert != null ? certValidationService.validateTrustWithCustomCert(cert, customCert) : certValidationService.validateTrustStore(cert));\n                        result.setNotRevoked(! certValidationService.isRevoked(cert));\n                        result.setNotExpired(! cert.getNotAfter().before(new Date()));\n\n                        // Set basic signature info\n                        result.setSignerName(sig.getName());\n                        result.setSignatureDate(sig.getSignDate().getTime().toString());\n                        result.setReason(sig.getReason());\n                        result.setLocation(sig.getLocation());\n\n                        // Set new certificate details\n                        result.setIssuerDN(cert.getIssuerX500Principal().getName());\n                        result.setSubjectDN(cert.getSubjectX500Principal().getName());\n                        result.setSerialNumber(cert.getSerialNumber().toString(16)); // Hex format\n                        result.setValidFrom(cert.getNotBefore().toString());\n                        result.setValidUntil(cert.getNotAfter().toString());\n                        result.setSignatureAlgorithm(cert.getSigAlgName());\n\n                        // Get key size (if possible)\n                        try {\n                            result.setKeySize(((RSAPublicKey) cert.getPublicKey()).getModulus().bitLength());\n                        } catch (Exception e) {\n                            // If not RSA or error, set to 0\n                            result.setKeySize(0);\n                        }\n                        result.setVersion(String.valueOf(cert.getVersion()));\n\n                        // Set key usage\n                        List<String> keyUsages = new ArrayList< >();\n                        boolean[] keyUsageFlags = cert.getKeyUsage();\n                        if (keyUsageFlags != null) {\n                            String[] keyUsageLabels = {\"Digital Signature\", \"Non-Repudiation\", \"Key Encipherment\", \"Data Encipherment\", \"Key Agreement\", \"Certificate Signing\", \"CRL Signing\", \"Encipher Only\", \"Decipher Only\"};\n                            for(int i = 0;\ni < keyUsageFlags.length;\ni++) {\n                                if (keyUsageFlags[i]) {\n                                    keyUsages.add(keyUsageLabels[i]);\n                                }\n                            }\n                        }\n                        result.setKeyUsages(keyUsages);\n\n                        // Check if self-signed\n                        result.setSelfSigned(cert.getSubjectX500Principal().equals(cert.getIssuerX500Principal()));\n                    }\n                } catch (Exception e) {\n                    result.setValid(false);\n                    result.setErrorMessage(\"Signature validation failed: \" + e.getMessage());\n                }\n                results.add(result);\n            }\n        }\n        return ResponseEntity.ok(results);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "354", "src_id": "M186", "code": "\n    public Map<String, Object> captureApplicationProperties() {\n        Map<String, Object> properties = new HashMap< >();\n\n        // Capture Legal properties\n        addIfNotEmpty(properties, \"legal_termsAndConditions\", applicationProperties.getLegal().getTermsAndConditions());\n        addIfNotEmpty(properties, \"legal_privacyPolicy\", applicationProperties.getLegal().getPrivacyPolicy());\n        addIfNotEmpty(properties, \"legal_accessibilityStatement\", applicationProperties.getLegal().getAccessibilityStatement());\n        addIfNotEmpty(properties, \"legal_cookiePolicy\", applicationProperties.getLegal().getCookiePolicy());\n        addIfNotEmpty(properties, \"legal_impressum\", applicationProperties.getLegal().getImpressum());\n\n        // Capture Security properties\n        addIfNotEmpty(properties, \"security_enableLogin\", applicationProperties.getSecurity().getEnableLogin());\n        addIfNotEmpty(properties, \"security_csrfDisabled\", applicationProperties.getSecurity().getCsrfDisabled());\n        addIfNotEmpty(properties, \"security_loginAttemptCount\", applicationProperties.getSecurity().getLoginAttemptCount());\n        addIfNotEmpty(properties, \"security_loginResetTimeMinutes\", applicationProperties.getSecurity().getLoginResetTimeMinutes());\n        addIfNotEmpty(properties, \"security_loginMethod\", applicationProperties.getSecurity().getLoginMethod());\n\n        // Capture OAuth2 properties (excluding sensitive information)\n        addIfNotEmpty(properties, \"security_oauth2_enabled\", applicationProperties.getSecurity().getOauth2().getEnabled());\n        if (applicationProperties.getSecurity().getOauth2().getEnabled()) {\n            addIfNotEmpty(properties, \"security_oauth2_autoCreateUser\", applicationProperties.getSecurity().getOauth2().getAutoCreateUser());\n            addIfNotEmpty(properties, \"security_oauth2_blockRegistration\", applicationProperties.getSecurity().getOauth2().getBlockRegistration());\n            addIfNotEmpty(properties, \"security_oauth2_useAsUsername\", applicationProperties.getSecurity().getOauth2().getUseAsUsername());\n            addIfNotEmpty(properties, \"security_oauth2_provider\", applicationProperties.getSecurity().getOauth2().getProvider());\n        }\n        // Capture System properties\n        addIfNotEmpty(properties, \"system_defaultLocale\", applicationProperties.getSystem().getDefaultLocale());\n        addIfNotEmpty(properties, \"system_googlevisibility\", applicationProperties.getSystem().getGooglevisibility());\n        addIfNotEmpty(properties, \"system_showUpdate\", applicationProperties.getSystem().isShowUpdate());\n        addIfNotEmpty(properties, \"system_showUpdateOnlyAdmin\", applicationProperties.getSystem().getShowUpdateOnlyAdmin());\n        addIfNotEmpty(properties, \"system_customHTMLFiles\", applicationProperties.getSystem().isCustomHTMLFiles());\n        addIfNotEmpty(properties, \"system_tessdataDir\", applicationProperties.getSystem().getTessdataDir());\n        addIfNotEmpty(properties, \"system_enableAlphaFunctionality\", applicationProperties.getSystem().getEnableAlphaFunctionality());\n        addIfNotEmpty(properties, \"system_enableAnalytics\", applicationProperties.getSystem().isAnalyticsEnabled());\n\n        // Capture UI properties\n        addIfNotEmpty(properties, \"ui_appName\", applicationProperties.getUi().getAppName());\n        addIfNotEmpty(properties, \"ui_homeDescription\", applicationProperties.getUi().getHomeDescription());\n        addIfNotEmpty(properties, \"ui_appNameNavbar\", applicationProperties.getUi().getAppNameNavbar());\n\n        // Capture Metrics properties\n        addIfNotEmpty(properties, \"metrics_enabled\", applicationProperties.getMetrics().getEnabled());\n\n        // Capture EnterpriseEdition properties\n        addIfNotEmpty(properties, \"enterpriseEdition_enabled\", applicationProperties.getPremium().isEnabled());\n        if (applicationProperties.getPremium().isEnabled()) {\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_autoUpdateMetadata\", applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata());\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_author\", applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor());\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_creator\", applicationProperties.getPremium().getProFeatures().getCustomMetadata().getCreator());\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_producer\", applicationProperties.getPremium().getProFeatures().getCustomMetadata().getProducer());\n        }\n        // Capture AutoPipeline properties\n        addIfNotEmpty(properties, \"autoPipeline_outputFolder\", applicationProperties.getAutoPipeline().getOutputFolder());\n        return properties;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "355", "src_id": "M173", "code": "\n    public CompletableFuture<ResponseEntity<?>> queueJob(String jobId, int resourceWeight, Supplier<Object> work, long timeoutMs) {\n\n        // Create a CompletableFuture to track this job's completion\n        CompletableFuture<ResponseEntity<?>> future = new CompletableFuture< >();\n\n        // Create the queued job\n        QueuedJob job = new QueuedJob(jobId, resourceWeight, work, timeoutMs, Instant.now(), future, false);\n\n        // Store in our map for lookup\n        jobMap.put(jobId, job);\n\n        // Update stats\n        totalQueuedJobs++;\n\n        // Synchronize access to the queue\n        synchronized(queueLock) {\n                                currentQueueSize = jobQueue.size();\n\n            // Try to add to the queue\n                                try {\n                                    boolean added = jobQueue.offer(job, 5, TimeUnit.SECONDS);\n                                    if (! added) {\n                                        log.warn(\"Queue full, rejecting job {}\", jobId);\n                                        rejectedJobs++;\n                                        future.completeExceptionally(new RuntimeException(\"Job queue full, please try again later\"));\n                                        jobMap.remove(jobId);\n                                        return future;\n                                    }\n                                    log.debug(\"Job {} queued for execution (weight: {}, queue size: {})\", jobId, resourceWeight, jobQueue.size());\n                                    return future;\n                                } catch (InterruptedException e) {\n                                    Thread.currentThread().interrupt();\n                                    future.completeExceptionally(new RuntimeException(\"Job queue interrupted\"));\n                                    jobMap.remove(jobId);\n                                    return future;\n                                }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "356", "src_id": "M544", "code": "\n    private void applyQpdfCompression(OptimizePdfRequest request, int optimizeLevel, Path currentFile, List<Path> tempFiles) throws IOException {\n        long preQpdfSize = Files.size(currentFile);\n        log.info(\"Pre-QPDF file size: {}\", GeneralUtils.formatBytes(preQpdfSize));\n\n        // Map optimization levels to QPDF compression levels\n        int qpdfCompressionLevel;\n        if (optimizeLevel == 1) {\n            qpdfCompressionLevel = 5;\n        } else if (optimizeLevel == 2) {\n            qpdfCompressionLevel = 9;\n        } else {\n            qpdfCompressionLevel = 9;\n        }\n\n        // Create output file for QPDF\n        Path qpdfOutputFile = Files.createTempFile(\"qpdf_output_\", \".pdf\");\n        tempFiles.add(qpdfOutputFile);\n\n        // Build QPDF command\n        List<String> command = new ArrayList< >();\n        command.add(\"qpdf\");\n        if (request.getNormalize()) {\n            command.add(\"--normalize-content=y\");\n        }\n        if (request.getLinearize()) {\n            command.add(\"--linearize\");\n        }\n        command.add(\"--recompress-flate\");\n        command.add(\"--compression-level=\" + qpdfCompressionLevel);\n        command.add(\"--compress-streams=y\");\n        command.add(\"--object-streams=generate\");\n        command.add(currentFile.toString());\n        command.add(qpdfOutputFile.toString());\n        ProcessExecutorResult returnCode = null;\n        try {\n            returnCode = ProcessExecutor.getInstance(ProcessExecutor.Processes.QPDF).runCommandWithOutputHandling(command);\n\n            // Update current file to the QPDF output\n            Files.copy(qpdfOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n            long postQpdfSize = Files.size(currentFile);\n            double qpdfReduction = 100.0 - ((postQpdfSize * 100.0) / preQpdfSize);\n            log.info(\"Post-QPDF file size: {} (reduced by {}%)\", GeneralUtils.formatBytes(postQpdfSize), String.format(\"%.1f\", qpdfReduction));\n        } catch (Exception e) {\n            if (returnCode != null && returnCode.getRc() != 3) {\n                throw new IOException(\"QPDF command failed\", e);\n            }\n            // If QPDF fails, keep using the current file\n            log.warn(\"QPDF compression failed, continuing with current file\", e);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "357", "src_id": "M16", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "358", "src_id": "M339", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "359", "src_id": "M452", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "360", "src_id": "M900", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "361", "src_id": "M383", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "362", "src_id": "M553", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "363", "src_id": "M343", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "364", "src_id": "M995", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "365", "src_id": "M741", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "366", "src_id": "M338", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "367", "src_id": "M1148", "code": "\n    @Override\n    public void seek(long offset)throws IOException {\n        long total = out.length + aux.length;\n        if (offset == total) {\n            // do not ignore the seek offset if a underflow exists\n            long relativeOffset = out.getOffset() + aux.getOffset();\n            if (relativeOffset == total) {\n                return;\n            }\n        }\n\n        // flush everything, avoid any underflow\n\n        flush();\n        if (offset < 0\n        || offset > total) {\n            throw new IOException(\"desired offset is outside of range=0-\"+ total+ \" offset=\"+ offset);\n        }\n\n        if (offset > out.length) {\n            out.seek(out.length);\n            aux.seek(offset - out.length);\n        } else {\n            out.seek(offset);\n            aux.seek(0);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "368", "src_id": "M1079", "code": "\n    boolean runMissions() {\n        synchronized(this) {\n            if (mMissionsPending.size() < 1) return false;\n            if (!canDownloadInCurrentNetwork()) return false;\n            if (mPrefQueueLimit) {\n                for (DownloadMission mission : mMissionsPending) if (!mission.isFinished() && mission.running) return true;\n            }\n\n\n\n            boolean flag = false;\n            for (DownloadMission mission : mMissionsPending) {\n                if (mission.running\n                        || !mission.enqueued\n                        || mission.isFinished()) continue;\n                resumeMission(mission);\n                if (mission.errCode != DownloadMission.ERROR_NOTHING) continue;\n                if (mPrefQueueLimit) return true;\n                flag = true;\n            }\n\n            return flag;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "369", "src_id": "M883", "code": "\n    private void makeMvhd(final long longestTrack)throws IOException {\n        auxWrite(new byte[]{0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00});\n        auxWrite(ByteBuffer.allocate(28).putLong(time)\n                                        .putLong(time)\n                                        .putInt(DEFAULT_TIMESCALE)\n                                        .putLong(longestTrack)\n                                        .array());\n        auxWrite(new byte[]{0x00, 0x01, 0x00, 0x00, 0x01, 0x00, // default volume and rate 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved values\n                // default matrix 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00});\n        auxWrite(new byte[24]); // predefined\n        auxWrite(ByteBuffer.allocate(4).putInt(tracks.length + 1)\n                                       .array());\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "370", "src_id": "M1037", "code": "\n    public void pause() {\n        if (!running) return;\n        if (isPsRunning()) {\n            if (DEBUG) {\n                Log.w(TAG, \"pause during post-processing is not applicable.\");\n            }\n\n            return;\n        }\n\n        running = false;\n        notify(DownloadManagerService.MESSAGE_PAUSED);\n        if (init != null && init.isAlive()) {\n            // NOTE: if start() method is running ¡will no have effect!\n            init.interrupt();\n            synchronized(LOCK) {\n                resetState(false, true, ERROR_NOTHING);\n            }\n\n            return;\n        }\n\n        if (DEBUG && unknownLength) {\n            Log.w(TAG,\n                \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n        }\n\n        init = null;\n        pauseThreads();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "371", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\"+ TAG+ \"]  ps = \"+ psAlgorithm+ \"  filename = \"+ storage.getName());\n        }\n\n        Exception exception = null;\n        try {\n            psAlgorithm.run(this);\n        }\n\n            catch(Exception err) {\n            Log.e(TAG, \"Post-processing failed. \"+ psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException\n                    || err instanceof ClosedByInterruptException\n                    || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) errCode = ERROR_POSTPROCESSING;\n            exception = err;\n        }\n\nfinally {\n            notifyPostProcessing(errCode == ERROR_NOTHING?2: 0);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) exception = errObject;\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n        notifyFinished();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "372", "src_id": "M1056", "code": "\n    private boolean handleMessage(@NonNull Message msg) {\n        if (mHandler == null) return true;\n        DownloadMission mission = (DownloadMission)msg.obj;\n        switch (msg.what) {\n            case MESSAGE_FINISHED:\n                notifyMediaScanner(mission.storage.getUri());\n                notifyFinishedDownload(mission.storage.getName());\n                mManager.setFinished(mission);\n                handleConnectivityState(false);\n                updateForegroundState(mManager.runMissions());\n                break;\n\n            case MESSAGE_RUNNING:\n                updateForegroundState(true);\n                break;\n\n            case MESSAGE_ERROR:\n                notifyFailedDownload(mission);\n                handleConnectivityState(false);\n                updateForegroundState(mManager.runMissions());\n                break;\n\n            case MESSAGE_PAUSED:\n                updateForegroundState(mManager.getRunningMissionsCount() > 0);\n                break;\n        }\n\n        if (msg.what != MESSAGE_ERROR) mFailedDownloads.remove(mFailedDownloads.indexOfValue(mission));\n        for (Callback observer : mEchoObservers) observer.handleMessage(msg);\n        return true;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "373", "src_id": "M1105", "code": "\n    private void showError(@NonNull DownloadMission mission) {\n        @StringRes int msg = R.string.general_error;\n        String msgEx = null;\n        switch (mission.errCode) {\n            case 416:\n                msg = R.string.error_http_unsupported_range;\n                break;\n\n            case 404:\n                msg = R.string.error_http_not_found;\n                break;\n\n            case ERROR_NOTHING:\n                return;// this never should happen\n\n            case ERROR_FILE_CREATION:\n                msg = R.string.error_file_creation;\n                break;\n\n            case ERROR_HTTP_NO_CONTENT:\n                msg = R.string.error_http_no_content;\n                break;\n\n            case ERROR_PATH_CREATION:\n                msg = R.string.error_path_creation;\n                break;\n\n            case ERROR_PERMISSION_DENIED:\n                msg = R.string.permission_denied;\n                break;\n\n            case ERROR_SSL_EXCEPTION:\n                msg = R.string.error_ssl_exception;\n                break;\n\n            case ERROR_UNKNOWN_HOST:\n                msg = R.string.error_unknown_host;\n                break;\n\n            case ERROR_CONNECT_HOST:\n                msg = R.string.error_connect_host;\n                break;\n\n            case ERROR_POSTPROCESSING_STOPPED:\n                msg = R.string.error_postprocessing_stopped;\n                break;\n\n            case ERROR_POSTPROCESSING:\n            case ERROR_POSTPROCESSING_HOLD:\n                showError(mission,\n                    UserAction.DOWNLOAD_POSTPROCESSING,\n                        R.string.error_postprocessing_failed);\n                return;\n\n            case ERROR_INSUFFICIENT_STORAGE:\n                msg = R.string.error_insufficient_storage_left;\n                break;\n\n            case ERROR_UNKNOWN_EXCEPTION:\n                if (mission.errObject != null) {\n                    showError(mission, UserAction.DOWNLOAD_FAILED, R.string.general_error);\n                    return;\n                } else {\n                    msg = R.string.msg_error;\n                    break;\n                }\n\n            case ERROR_PROGRESS_LOST:\n                msg = R.string.error_progress_lost;\n                break;\n\n            case ERROR_TIMEOUT:\n                msg = R.string.error_timeout;\n                break;\n\n            case ERROR_RESOURCE_GONE:\n                msg = R.string.error_download_resource_gone;\n                break;\n\n            default:\n                if (mission.errCode >= 100 && mission.errCode < 600) {\n                    msgEx = \"HTTP \"+ mission.errCode;\n                } else if (mission.errObject == null) {\n                           msgEx = \"(not_decelerated_error_code)\";\n                       } else {\n                           showError(mission, UserAction.DOWNLOAD_FAILED, msg);\n                           return;\n                       }\n\n                break;\n        }\n\n        AlertDialog.Builder builder = new AlertDialog.Builder(mContext);\n        if (msgEx != null) builder.setMessage(msgEx); else builder.setMessage(msg);\n\n        // add report button for non-HTTP errors (range 100-599)\n        if (mission.errObject != null && (mission.errCode < 100\n            || mission.errCode >= 600)) {\n            @StringRes final int mMsg = msg;\n            builder.setPositiveButton(R.string.error_report_title,\n                (dialog,which) -> showError(mission, UserAction.DOWNLOAD_FAILED, mMsg));\n        }\n\n        builder.setNegativeButton(R.string.ok, (dialog,which) -> dialog.cancel()).setTitle(mission.storage.getName()).show();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "374", "src_id": "M828", "code": "\n    private Minf parseMinf(final Box ref)throws IOException {\n        final Minf obj = new Minf();\n        Box b;\n        while((b = untilAnyBox(ref)) != null) {\n            switch (b.type) {\n                case ATOM_DINF:\n                    obj.dinf = readFullBox(b);\n                    break;\n\n                case ATOM_STBL:\n                    obj.stblStsd = parseStbl(b);\n                    break;\n\n                case ATOM_VMHD:\n                case ATOM_SMHD:\n                    obj.mhd = readFullBox(b);\n                    break;\n            }\n\n            ensure(b);\n        }\n\n        return obj;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "375", "src_id": "M822", "code": "\n    private Mdia parseMdia(final Box ref)throws IOException {\n        final Mdia obj = new Mdia();\n        Box b;\n        while((b = untilBox(ref, ATOM_MDHD, ATOM_HDLR, ATOM_MINF)) != null) {\n            switch (b.type) {\n                case ATOM_MDHD:\n                    obj.mdhd = readFullBox(b);\n\n                    // read time scale\n\n\n                    final ByteBuffer buffer = ByteBuffer.wrap(obj.mdhd);\n                    final byte version = buffer.get(8);\n                    buffer.position(12+ ((version == 0?4: 8)*2));\n                    obj.mdhdTimeScale = buffer.getInt();\n                    break;\n\n                case ATOM_HDLR:\n                    obj.hdlr = parseHdlr(b);\n                    break;\n\n                case ATOM_MINF:\n                    obj.minf = parseMinf(b);\n                    break;\n            }\n\n            ensure(b);\n        }\n\n        return obj;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "376", "src_id": "M302", "code": "\n    @Override\n    public void processResult(int rc, String path, Object ctx, List<String> children) {\n        if (rc != KeeperException.Code.OK.intValue()) {\n            // try it again\n            zk.getChildren(assignmentsNode, true, this, null);\n            return;\n        }\n\n        Map<String, Instance> newList = new HashMap<String, Instance>();\n        // check for differences\n        Stat stat = new Stat();\n        for(String child :children) {\n            Instance i = instances.remove(child);\n            if (i == null) {\n                // Start up a new instance\n                byte [] data = null;\n                String myNode = assignmentsNode + '/' + child;\n\n                while(true) {\n                    try {\n                        data = zk.getData(myNode, true, stat);\n                        break;\n                    } catch (NoNodeException e) {\n                        // The node doesn't exist anymore, so skip it\n                        break;\n                    } catch (KeeperException e) {\n                        e.printStackTrace();\n                    } catch (InterruptedException e) {\n                        return;\n                    }\n                }\n\n                if (data != null) {\n                    String instanceSpec = new String(data);\n                    int spaceIndex = instanceSpec.indexOf(' ');\n                    String clazz;\n                    String conf;\n                    if (spaceIndex == -1) {\n                        clazz = instanceSpec;\n                        conf = null;\n                    } else {\n                        clazz = instanceSpec.substring(0, spaceIndex);\n                        conf = instanceSpec.substring(spaceIndex + 1);\n                    }\n\n                    try {\n                        Class<?> c = Class.forName(clazz);\n                        i = (Instance) c.getConstructor().newInstance();\n                        Reporter reporter = new MyReporter(child);\n                        i.setReporter(reporter);\n                        i.configure(conf);\n                        i.start();\n                        newList.put(child, i);\n                        int ver = stat.getVersion();\n                        Instance myInstance = i;\n                        DataCallback dc = new MyDataCallback(myNode, myInstance, ver);\n                        Watcher watcher = new MyWatcher(myNode, dc);\n                        zk.getData(myNode, watcher, dc, watcher);\n                    } catch (Exception e) {\n                        LOG.warn(\"Skipping \" + child, e);\n                        if (e.getCause() != null) {\n                            LOG.warn(\"Caused by\", e.getCause());\n                        }\n                    }\n                }\n            } else {\n                // just move it to the new list\n                newList.put(child, i);\n            }\n        }\n        // kill anything that was removed for the children\n\n        for(Map.Entry<String, Instance> i :instances.entrySet()) {\n            i.getValue().stop();\n            try {\n                rmnod(reportsNode + '/' + i.getKey());\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } catch (KeeperException e) {\n                e.printStackTrace();\n            }\n        }\n\n        instances = newList;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "377", "src_id": "M219", "code": "\n    synchronized public static ZooKeeper getClient(String contextPath, String session,\n                                                   int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n            for(Map.Entry<String, String> p :e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n\n            zkMap.put(connectionId, zk);\n\n           // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n\n        return zk;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "378", "src_id": "M579", "code": "\n    public void dump(PrintWriter pwriter) {\n        pwriter.print(\"Sets (\");\n        pwriter.print(expiryMap.size());\n        pwriter.print(\")/(\");\n        pwriter.print(elemMap.size());\n        pwriter.println(\"):\");\n        ArrayList<Long> keys = new ArrayList<>(expiryMap.keySet());\n        Collections.sort(keys);\n        for(long time :keys) {\n            Set<E> set = expiryMap.get(time);\n            if (set != null) {\n                pwriter.print(set.size());\n                pwriter.print(\" expire at \");\n                pwriter.print(Time.elapsedTimeToDate(time));\n                pwriter.println(\":\");\n                for(E elem :set) {\n                    pwriter.print(\"\\t\");\n                    pwriter.println(elem.toString());\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "379", "src_id": "M282", "code": "\n    @Test\n    public void testSimpleCase() throws Exception {\n        configureServers(serverCount);\n        configureClients(clientCount, SimpleClient.class, getHostPort() );\n        Stat stat = new Stat();\n        startServers();\n        LOG.debug(\"Connecting to \" + getHostPort());\n        ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n        waitForConnect(zk, 10000);\n        zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        startClients();\n\n        // Check that all clients connect properly\n        for (int i = 0; i < getClientCount(); i++) {\n            for (int j = 0; j < maxTries; j++) {\n                try {\n                    byte b [] = zk.getData(\"/simpleCase/\" + i, false, stat);\n                    Assert.assertEquals(\"orig\", new String(b));\n                } catch (NoNodeException e) {\n                    if (j + 1 == maxTries) {\n                        Assert.fail(\"Max tries exceeded on client \" + i);\n                    }\n\n                    Thread.sleep(1000);\n                }\n            }\n        }\n\n        // Kill half the servers, make a change, restart the dead\n        // servers, and then bounce the other servers one by one\n\n        for (int i = 0; i < getServerCount(); i++) {\n            stopServer(i);\n            if (i + 1 > getServerCount()/ 2) {\n                startServer(i);\n            } else if (i + 1 == getServerCount()/ 2) {\n                       Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                       try {\n                           zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                       } catch (ConnectionLossException e) {\n                           Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                           zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                       }\n\n                       for (int j = 0; j < i; j++) {\n                           LOG.info(\"Starting server \" + j);\n                           startServer(i);\n                       }\n                   }\n        }\n\n        Thread.sleep(100); // wait for things to stabilize\n        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n        try {\n            zk.getData(\"/simpleCase\", false, stat);\n        } catch (ConnectionLossException e) {\n            Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n        }\n\n        // check that the change has propagated to everyone\n\n        for (int i = 0; i < getClientCount(); i++) {\n            for (int j = 0; j < maxTries; j++) {\n                byte [] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n                if (new String(data).equals(\"new\")) {\n                    break;\n                }\n\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"max tries exceeded for \" + i);\n                }\n\n                Thread.sleep(1000);\n            }\n        }\n\n        // send out the kill signal\n\n        zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n\n        // watch for everyone to die\n        for (int i = 0; i < getClientCount(); i++) {\n            try {\n                for (int j = 0; j < maxTries; j++) {\n                    zk.getData(\"/simpleCase/\" + i, false, stat);\n                    if (j + 1 == maxTries) {\n                        Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                    }\n\n                    Thread.sleep(200);\n                }\n            } catch (NoNodeException e) {\n                // Great this is what we were hoping for!\n            }\n        }\n\n        stopClients();\n        stopServers();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "380", "src_id": "M243", "code": "\n    public void start() throws IOException {\n        System.out.println(\"Starting grizzly ...\");\n\n        boolean useSSL = cfg.useSSL();\n        String zkRestResourcesTempPath = Files.createTempDirectory(\"zkRestResourcesTempPath\").toFile().getCanonicalPath();\n        gws = new GrizzlyWebServer(cfg.getPort(), zkRestResourcesTempPath, useSSL);\n       // BUG: Grizzly needs a doc root if you are going to register multiple adapters\n        for(Endpoint e :cfg.getEndpoints()) {\n            ZooKeeperService.mapContext(e.getContext(), e);\n            gws.addGrizzlyAdapter(createJerseyAdapter(e), new String [] {\n                                                              e.getContext()});\n        }\n\n        if (useSSL) {\n            System.out.println(\"Starting SSL ...\");\n            String jks = cfg.getJKS(\"keys/rest.jks\");\n            String jksPassword = cfg.getJKSPassword();\n            SSLConfig sslConfig = new SSLConfig();\n            URL resource = getClass().getClassLoader().getResource(jks);\n            if (resource == null) {\n                LOG.error(\"Unable to find the keystore file: \" + jks);\n                System.exit(2);\n            }\n\n            try {\n                sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n            } catch (URISyntaxException e1) {\n                LOG.error(\"Unable to load keystore: \" + jks, e1);\n                System.exit(2);\n            }\n\n            sslConfig.setKeyStorePass(jksPassword);\n            gws.setSSLConfig(sslConfig);\n        }\n\n        gws.start();\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "381", "src_id": "M186", "code": "\n    synchronized private LogEntry readNextEntry() {\n        try {\n            try {\n                while(true) {\n                    String line = in.readLine();\n                    if (line == null) {\n                        break;\n                    }\n\n                    Matcher m = src.timep.matcher(line);\n                    if (m.lookingAt()) {\n                        if (buf.length()> 0) {\n                            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                            buf = line;\n                            return e;\n                        }\n\n                        buf = line;\n                    } else if (buf.length()> 0) {\n                               buf += line + \"\\n\";\n                           }\n                }\n            } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n            }\n\n            if (buf.length()> 0) {\n                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                buf = \"\";\n                return e;\n            }\n        } catch (Exception e) {\n            LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n            return null;\n        }\n\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "382", "src_id": "M286", "code": "\n    public void reconfigureInstance(String name, String params) throws NoAssignmentException, InterruptedException, KeeperException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n        }\n\n        Assigned assigned = instanceToAssignment.get(name);\n        if (assigned == null) {\n            throw new NoAssignmentException();\n        }\n\n        KeeperException lastException = null;\n        for (int i = 0; i < maxTries; i++) {\n            try {\n                zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, (\"update \" + params).getBytes(), -1);\n                break;\n            } catch (ConnectionLossException e) {\n                lastException = e;\n            }\n        }\n\n        if (lastException != null) {\n            throw lastException;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "383", "src_id": "M174", "code": "\n    private LogEntry readNextEntry() {\n        LogEntry e = null;\n\n        try {\n            long crcValue;\n            byte [] bytes;\n\n            try {\n                crcValue = logStream.readLong(\"crcvalue\");\n                bytes = logStream.readBuffer(\"txnEntry\");\n            } catch (EOFException ex) {\n                return null;\n            }\n\n            if (bytes.length == 0) {\n                return null;\n            }\n\n            Checksum crc = new Adler32();\n            crc.update(bytes, 0, bytes.length);\n            if (crcValue != crc.getValue()) {\n                throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n            }\n\n            TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n            TxnHeader hdr = logEntry.getHeader();\n            Record r = logEntry.getTxn();\n\n            switch(hdr.getType()) {\n                                  case OpCode.createSession: {\n                                                                 e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n                                                             }\n\n                                                             break;\n                                  case OpCode.closeSession: {\n                                                                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n                                                            }\n\n                                                            break;\n                                  case OpCode.create:\n                if (r != null) {\n                    CreateTxn create = (CreateTxn) r;\n                    String path = create.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n                }\n\n                break;\n                                  case OpCode.setData:\n                if (r != null) {\n                    SetDataTxn set = (SetDataTxn) r;\n                    String path = set.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n                }\n\n                break;\n                                  case OpCode.setACL:\n                if (r != null) {\n                    SetACLTxn setacl = (SetACLTxn) r;\n                    String path = setacl.getPath();\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n                }\n\n                break;\n                                  case OpCode.error:\n                if (r != null) {\n                    ErrorTxn error = (ErrorTxn) r;\n                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n                }\n\n                break;\n                                  default:\n                LOG.info(\"Unknown op: \" + hdr.getType());\n                break;\n            }\n\n            if (logStream.readByte(\"EOR\") != 'B') {\n                throw new EOFException(\"Last transaction was partial.\");\n            }\n        } catch (Exception ex) {\n            LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n            return null;\n        }\n\n        return e;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "384", "src_id": "M1129", "code": "\n    public synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief) {\n        pwriter.print(\" \");\n        pwriter.print(getRemoteSocketAddress());\n        pwriter.print(\"[\");\n        int interestOps = getInterestOps();\n        pwriter.print(interestOps == 0? \"0\": Integer.toHexString(interestOps));\n        pwriter.print(\"](queued=\");\n        pwriter.print(getOutstandingRequests());\n        pwriter.print(\",recved=\");\n        pwriter.print(getPacketsReceived());\n        pwriter.print(\",sent=\");\n        pwriter.print(getPacketsSent());\n        if (!brief) {\n            long sessionId = getSessionId();\n            if (sessionId != 0) {\n                pwriter.print(\",sid=0x\");\n                pwriter.print(Long.toHexString(sessionId));\n                pwriter.print(\",lop=\");\n                pwriter.print(getLastOperation());\n                pwriter.print(\",est=\");\n                pwriter.print(getEstablished().getTime());\n                pwriter.print(\",to=\");\n                pwriter.print(getSessionTimeout());\n\n                long lastCxid = getLastCxid();\n                if (lastCxid >= 0) {\n                    pwriter.print(\",lcxid=0x\");\n                    pwriter.print(Long.toHexString(lastCxid));\n                }\n\n                pwriter.print(\",lzxid=0x\");\n                pwriter.print(Long.toHexString(getLastZxid()));\n                pwriter.print(\",lresp=\");\n                pwriter.print(getLastResponseTime());\n                pwriter.print(\",llat=\");\n                pwriter.print(getLastLatency());\n                pwriter.print(\",minlat=\");\n                pwriter.print(getMinLatency());\n                pwriter.print(\",avglat=\");\n                pwriter.print(getAvgLatency());\n                pwriter.print(\",maxlat=\");\n                pwriter.print(getMaxLatency());\n            }\n        }\n\n        pwriter.print(\")\");\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "385", "src_id": "M267", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "386", "src_id": "M1358", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "387", "src_id": "M683", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "388", "src_id": "M1509", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "389", "src_id": "M889", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "390", "src_id": "M1127", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "391", "src_id": "M1003", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "392", "src_id": "M485", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "393", "src_id": "M2312", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "394", "src_id": "M368", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "395", "src_id": "M379", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "396", "src_id": "M260", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "397", "src_id": "M887", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "398", "src_id": "M527", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "399", "src_id": "M239", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "400", "src_id": "M460", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "401", "src_id": "M243", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "402", "src_id": "M543", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "403", "src_id": "M491", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "404", "src_id": "M703", "code": "", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "405", "src_id": "M2204", "code": "\n    @Override protected void subscribeActual(MaybeObserver<? super T> observer) {\n        MaybeDisposable<T> md = new MaybeDisposable<>(observer, this);\n        observer.onSubscribe(md);\n        if (add(md)) {\n            if (md.isDisposed()) {\n                remove(md);\n            }\n        } else {\n            Throwable ex = error;\n            if (ex != null) {\n                observer.onError(ex);\n            } else {\n                T v = value;\n                if (v == null) {\n                    observer.onComplete();\n                } else {\n                    observer.onSuccess(v);\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "406", "src_id": "M919", "code": "\n    @Override protected void subscribeActual(CompletableObserver observer) {\n        Disposable d = Disposable.empty();\n        observer.onSubscribe(d);\n        if (!d.isDisposed()) {\n            try {\n                run.run();\n            }\n                catch(Throwable e) {\n                Exceptions.throwIfFatal(e);\n                if (!d.isDisposed()) {\n                    observer.onError(e);\n                } else {\n                    RxJavaPlugins.onError(e);\n                }\n                return;\n            }\n            if (!d.isDisposed()) {\n                observer.onComplete();\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "407", "src_id": "M352", "code": "\n    @Override\n    public void onNext(T value) {\n        if (upstream == DisposableHelper.DISPOSED) {\n            return;\n        }\n        Iterator<? extends R> it;\n        try {\n            it = mapper.apply(value)\n                .iterator();\n        }\n            catch(Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            upstream.dispose();\n            onError(ex);\n            return;\n        }\n        Observer<? super R> a = downstream;\n        for (;;) {\n            boolean b;\n            try {\n                b = it.hasNext();\n            }\n                catch(Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                upstream.dispose();\n                onError(ex);\n                return;\n            }\n            if (b) {\n                R v;\n                try {\n                    v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n                }\n                    catch(Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.dispose();\n                    onError(ex);\n                    return;\n                }\n                a.onNext(v);\n            } else {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "408", "src_id": "M874", "code": "\n    @Override\n    public boolean tryOnNext(T t) {\n        if (!done) {\n            long retries = 0L;\n            for (;;) {\n                boolean b;\n                try {\n                    b = predicate.test(t);\n                }\n                    catch(Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    ParallelFailureHandling h;\n                    try {\n                        h = Objects.requireNonNull(\n                            errorHandler.apply(++ retries, ex),\n                            \"The errorHandler returned a null ParallelFailureHandling\");\n                    }\n                        catch(Throwable exc) {\n                        Exceptions.throwIfFatal(exc);\n                        cancel();\n                        onError(new CompositeException(ex, exc));\n                        return false;\n                    }\n                    switch (h) {\n                        case RETRY:\n                            continue;\n                        case SKIP:\n                            return false;\n                        case STOP:\n                            cancel();\n                            onComplete();\n                            return false;\n                        default:\n                            cancel();\n                            onError(ex);\n                            return false;\n                    }\n                }\n                return b && downstream.tryOnNext(t);\n            }\n        }\n        return false;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "409", "src_id": "M2235", "code": "\n    @Override\n@NonNull\n    public synchronized Throwable getCause() { // NOPMD\n        if (cause == null) {\n            String separator = System.getProperty(\"line.separator\");\n            if (exceptions.size() > 1) {\n                Map<Throwable, Boolean> seenCauses = new IdentityHashMap<>();\n                StringBuilder aggregateMessage = new StringBuilder();\n                aggregateMessage.append(\"Multiple exceptions (\")\n                    .append(exceptions.size())\n                        .append(\")\").append(separator);\n                for(Throwable inner :exceptions) {\n                    int depth = 0;\n                    while(inner != null) {\n                        for (int i = 0; i < depth; i++) {\n                            aggregateMessage.append(\"  \");\n                        }\n                        aggregateMessage.append(\"|-- \");\n                        aggregateMessage.append(inner.getClass()\n                            .getCanonicalName()).append(\": \");\n                        String innerMessage = inner.getMessage();\n                        if (innerMessage != null && innerMessage.contains(separator)) {\n                            aggregateMessage.append(separator);\n                            for(String line :innerMessage.split(separator)) {\n                                for (int i = 0; i < depth + 2; i++) {\n                                    aggregateMessage.append(\"  \");\n                                }\n                                aggregateMessage.append(line).append(separator);\n                            }\n                        } else {\n                            aggregateMessage.append(innerMessage);\n                            aggregateMessage.append(separator);\n                        }\n                        for (int i = 0; i < depth + 2; i++) {\n                            aggregateMessage.append(\"  \");\n                        }\n                        StackTraceElement [] st = inner.getStackTrace();\n                        if (st.length > 0) {\n                            aggregateMessage.append(\"at \")\n                                .append(st[0]).append(separator);\n                        }\n                        if (!seenCauses.containsKey(inner)) {\n                            seenCauses.put(inner, true);\n                            inner = inner.getCause();\n                            depth++;\n                        } else {\n                            inner = inner.getCause();\n                            if (inner != null) {\n                                for (int i = 0; i < depth + 2; i++) {\n                                    aggregateMessage.append(\"  \");\n                                }\n                                aggregateMessage.append(\"|-- \");\n                                aggregateMessage.append(\"(cause not expanded again) \");\n                                aggregateMessage.append(inner.getClass()\n                                    .getCanonicalName()).append(\": \");\n                                aggregateMessage.append(inner.getMessage());\n                                aggregateMessage.append(separator);\n                            }\n                            break;\n                        }\n                    }\n                }\n                cause = new ExceptionOverview(aggregateMessage.toString()\n                    .trim());\n            } else {\n                cause = exceptions.get(0);\n            }\n        }\n        return cause;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "410", "src_id": "M1389", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Deque<T> dq = deque;\n        Subscriber<? super T> a = downstream;\n        for (;;) {\n            long r = requested.get();\n            long e = 0L;\n            while(e != r) {\n                if (cancelled) {\n                    clear(dq);\n                    return;\n                }\n\n                boolean d = done;\n                T v;\n                synchronized(dq) {\n                    v = dq.poll();\n                }\n\n                boolean empty = v == null;\n                if (d) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        clear(dq);\n                        a.onError(ex);\n                        return;\n                    }\n                    if (empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n                e++;\n            }\n            if (e == r) {\n                if (cancelled) {\n                    clear(dq);\n                    return;\n                }\n\n                boolean d = done;\n                boolean empty;\n                synchronized(dq) {\n                    empty = dq.isEmpty();\n                }\n                if (d) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        clear(dq);\n                        a.onError(ex);\n                        return;\n                    }\n                    if (empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n            }\n            if (e != 0L) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "411", "src_id": "M243", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        AtomicReference<T> latest = this\n            .latest;\n        Observer<? super T> downstream = this\n            .downstream;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n\n                boolean d = done;\n                Throwable error = this\n                    .error;\n                if (d && error != null) {\n                    if (onDropped != null) {\n                        T v = latest.getAndSet(null);\n                        if (v != null) {\n                            try {\n                                onDropped.accept(v);\n                            }\n                                catch(Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                error = new CompositeException(error, ex);\n                            }\n                        }\n                    } else {\n                        latest.lazySet(null);\n                    }\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n                T v = latest.get();\n                boolean empty = v == null;\n                if (d) {\n                    if (!empty) {\n                        v = latest.getAndSet(null);\n                        if (emitLast) {\n                            downstream.onNext(v);\n                        } else {\n                            if (onDropped != null) {\n                                try {\n                                    onDropped.accept(v);\n                                }\n                                    catch(Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    downstream.onError(ex);\n                                    worker.dispose();\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    downstream.onComplete();\n                    worker.dispose();\n                    return;\n                }\n                if (empty) {\n                    if (timerFired) {\n                        timerRunning = false;\n                        timerFired = false;\n                    }\n                    break;\n                }\n                if (!timerRunning || timerFired) {\n                    v = latest.getAndSet(null);\n                    downstream.onNext(v);\n                    timerFired = false;\n                    timerRunning = true;\n                    worker.schedule(this, timeout, unit);\n                } else {\n                    break;\n                }\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "412", "src_id": "M1127", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        AtomicReference<T> latest = this\n            .latest;\n        AtomicLong requested = this\n            .requested;\n        Subscriber<? super T> downstream = this\n            .downstream;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n\n                boolean d = done;\n                Throwable error = this\n                    .error;\n                if (d && error != null) {\n                    if (onDropped != null) {\n                        T v = latest.getAndSet(null);\n                        if (v != null) {\n                            try {\n                                onDropped.accept(v);\n                            }\n                                catch(Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                error = new CompositeException(error, ex);\n                            }\n                        }\n                    } else {\n                        latest.lazySet(null);\n                    }\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n                T v = latest.get();\n                boolean empty = v == null;\n                if (d) {\n                    if (!empty) {\n                        v = latest.getAndSet(null);\n                        if (emitLast) {\n                            long e = emitted;\n                            if (e != requested.get()) {\n                                emitted = e + 1;\n                                downstream.onNext(v);\n                                downstream.onComplete();\n                            } else {\n                                tryDropAndSignalMBE(v);\n                            }\n                        } else {\n                            if (onDropped != null) {\n                                try {\n                                    onDropped.accept(v);\n                                }\n                                    catch(Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    downstream.onError(ex);\n                                    worker.dispose();\n                                    return;\n                                }\n                            }\n                            downstream.onComplete();\n                        }\n                    } else {\n                        downstream.onComplete();\n                    }\n                    worker.dispose();\n                    return;\n                }\n                if (empty) {\n                    if (timerFired) {\n                        timerRunning = false;\n                        timerFired = false;\n                    }\n                    break;\n                }\n                if (!timerRunning || timerFired) {\n                    v = latest.getAndSet(null);\n\n\n                    long e = emitted;\n                    if (e != requested.get()) {\n                        downstream.onNext(v);\n                        emitted = e + 1;\n                    } else {\n                        upstream.cancel();\n                        tryDropAndSignalMBE(v);\n                        worker.dispose();\n                        return;\n                    }\n                    timerFired = false;\n                    timerRunning = true;\n                    worker.schedule(this, timeout, unit);\n                } else {\n                    break;\n                }\n            }\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "413", "src_id": "M1902", "code": "\n    @Override protected void subscribeActual(Subscriber<? super R> s) {\n        if (source instanceof Supplier) {\n            Stream<? extends R> stream = null;\n            try {\n                @SuppressWarnings(\"unchecked\") T t = ((Supplier<T>) source)\n                    .get();\n                if (t != null) {\n                    stream = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null Stream\");\n                }\n            }\n                catch(Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptySubscription.error(ex, s);\n                return;\n            }\n            if (stream != null) {\n                FlowableFromStream.subscribeStream(s, stream);\n            } else {\n                EmptySubscription.complete(s);\n            }\n        } else {\n            source.subscribe(subscribe(s, mapper, prefetch));\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "414", "src_id": "M1455", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        long e = emitted;\n        Subscriber<? super C> a = downstream;\n        SpscLinkedArrayQueue<C> q = queue;\n        for (;;) {\n            long r = requested.get();\n            while(e != r) {\n                if (cancelled) {\n                    q.clear();\n                    return;\n                }\n\n                boolean d = done;\n                if (d && errors.get() != null) {\n                    q.clear();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n                C v = q.poll();\n                boolean empty = v == null;\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n                e++;\n            }\n            if (e == r) {\n                if (cancelled) {\n                    q.clear();\n                    return;\n                }\n                if (done) {\n                    if (errors.get() != null) {\n                        q.clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    } else if (q.isEmpty()) {\n                               a.onComplete();\n                               return;\n                           }\n                }\n            }\n            emitted = e;\n            missed = addAndGet(- missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "415", "src_id": "M676", "code": "\n    @ SuppressWarnings(\"unchecked\" ) void done() {\n        if (decrementAndGet() == 0) {\n            Object o1 = observer1.value;\n            Object o2 = observer2.value;\n\n            if (o1 != null && o2 != null) {\n                boolean b;\n\n                try {\n                    b = isEqual.test((T) o1, (T) o2);\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    downstream.onError(ex);\n                    return;\n                }\n\n                downstream.onSuccess(b);\n            } else {\n                downstream.onSuccess(o1 == null && o2 == null);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "416", "src_id": "M275", "code": "\n    @Override\n    public void subscribe(Observer < ? super T > observer) {\n        for (;;) {\n            int s = once.get();\n\n            if ((s & HAS_SUBSCRIBER) != 0) {\n                break;\n            }\n\n            int u = s | HAS_SUBSCRIBER;\n\n            if (once.compareAndSet(s, u)) {\n                observer.onSubscribe(this);\n                actual.lazySet(observer);\n\n                if (cancelled.get()) {\n                    actual.lazySet(null);\n                } else {\n                    drain();\n                }\n\n                return;\n            }\n        }\n\n        EmptyDisposable.error(new IllegalStateException(\"Only one Observer allowed!\"), observer);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "417", "src_id": "M1571", "code": "\n    @Override\n    public void onSuccess(T value) {\n        Observer < ? super R > a = downstream;\n        Iterator < ? extends R > iterator;\n        boolean has;\n\n        try {\n            iterator = mapper.apply(value).iterator();\n            has = iterator.hasNext();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            downstream.onError(ex);\n            return;\n        }\n\n        if (!has) {\n            a.onComplete();\n            return;\n        }\n\n        if (outputFused) {\n            it = iterator;\n            a.onNext(null);\n            a.onComplete();\n        } else {\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                R v;\n\n                try {\n                    v = iterator.next();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n                a.onNext(v);\n\n                if (cancelled) {\n                    return;\n                }\n\n                boolean b;\n\n                try {\n                    b = iterator.hasNext();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n                if (!b) {\n                    a.onComplete();\n                    return;\n                }\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "418", "src_id": "M1183", "code": "\n    @Override void fastPath() {\n        Iterator < ? extends T > it = this.iterator;\n        ConditionalSubscriber < ? super T > a = downstream;\n\n        for (;;) {\n            if (cancelled) {\n                return;\n            }\n\n            T t;\n\n            try {\n                t = it.next();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                a.onError(ex);\n                return;\n            }\n\n            if (cancelled) {\n                return;\n            }\n\n            if (t == null) {\n                a.onError(new NullPointerException(\"Iterator.next() returned a null value\"));\n                return;\n            } else {\n                a.tryOnNext(t);\n            }\n\n            if (cancelled) {\n                return;\n            }\n\n            boolean b;\n\n            try {\n                b = it.hasNext();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                a.onError(ex);\n                return;\n            }\n\n            if (!b) {\n                if (!cancelled) {\n                    a.onComplete();\n                }\n\n                return;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "419", "src_id": "M1995", "code": "\n    static < T > boolean postCompleteDrain(long n, Subscriber < ? super T > actual, Queue < T > queue, AtomicLong state, BooleanSupplier isCancelled) {\n\n// TODO enable fast-path\n//        if (n == -1 || n == Long.MAX_VALUE) {\n//            for (;;) {\n//                if (isCancelled.getAsBoolean()) {\n//                    break;\n//                }\n//\n//                T v = queue.poll();\n//\n//                if (v == null) {\n//                    actual.onComplete();\n//                    break;\n//                }\n//\n//                actual.onNext(v);\n//            }\n//\n//            return true;\n//        }\n        long e = n & COMPLETED_MASK;\n\n        for (;;) {\n            while (e != n) {\n                if (isCancelled(isCancelled)) {\n                    return true;\n                }\n\n                T t = queue.poll();\n\n                if (t == null) {\n                    actual.onComplete();\n                    return true;\n                }\n\n                actual.onNext(t);\n                e++;\n            }\n\n            if (isCancelled(isCancelled)) {\n                return true;\n            }\n\n            if (queue.isEmpty()) {\n                actual.onComplete();\n                return true;\n            }\n\n            n = state.get();\n\n            if (n == e) {\n                n = state.addAndGet(-(e & REQUESTED_MASK));\n\n                if ((n & REQUESTED_MASK) == 0L) {\n                    return false;\n                }\n\n                e = n & COMPLETED_MASK;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "420", "src_id": "M1315", "code": "\n    void drainLoop() {\n        int missed = 1;\n        Subscriber < ? super R > a = downstream;\n        AtomicInteger n = active;\n        AtomicReference < SpscLinkedArrayQueue < R >> qr = queue;\n\n        for (;;) {\n            long r = requested.get();\n            long e = 0L;\n\n            while (e != r) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n\n                if (!delayErrors) {\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                }\n\n                boolean d = n.get() == 0;\n                SpscLinkedArrayQueue < R > q = qr.get();\n                R v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                a.onNext(v);\n                e++;\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n\n                if (!delayErrors) {\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                }\n\n                boolean d = n.get() == 0;\n                SpscLinkedArrayQueue < R > q = qr.get();\n                boolean empty = q == null || q.isEmpty();\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n            }\n\n            if (e != 0L) {\n                BackpressureHelper.produced(requested, e);\n\n                if (maxConcurrency != Integer.MAX_VALUE) {\n                    upstream.request(e);\n                }\n            }\n\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "421", "src_id": "M856", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Subscriber < ? super T > a = downstream;\n        List < T > [] lists = this.lists;\n        int[] indexes = this.indexes;\n        int n = indexes.length;\n\n        for (;;) {\n            long r = requested.get();\n            long e = 0L;\n\n            while (e != r) {\n                if (cancelled) {\n                    Arrays.fill(lists, null);\n                    return;\n                }\n\n                Throwable ex = error.get();\n\n                if (ex != null) {\n                    cancelAll();\n                    Arrays.fill(lists, null);\n                    a.onError(ex);\n                    return;\n                }\n\n                T min = null;\n                int minIndex = -1;\n\n                for (int i = 0; i < n; i++) {\n                    List < T > list = lists[i];\n                    int index = indexes[i];\n\n                    if (list.size() != index) {\n                        if (min == null) {\n                            min = list.get(index);\n                            minIndex = i;\n                        } else {\n                            T b = list.get(index);\n                            boolean smaller;\n\n                            try {\n                                smaller = comparator.compare(min, b) > 0;\n                            } catch (Throwable exc) {\n                                Exceptions.throwIfFatal(exc);\n                                cancelAll();\n                                Arrays.fill(lists, null);\n\n                                if (!error.compareAndSet(null, exc)) {\n                                    RxJavaPlugins.onError(exc);\n                                }\n\n                                a.onError(error.get());\n                                return;\n                            }\n\n                            if (smaller) {\n                                min = b;\n                                minIndex = i;\n                            }\n                        }\n                    }\n                }\n\n                if (min == null) {\n                    Arrays.fill(lists, null);\n                    a.onComplete();\n                    return;\n                }\n\n                a.onNext(min);\n                indexes[minIndex]++;\n                e++;\n            }\n\n            if (cancelled) {\n                Arrays.fill(lists, null);\n                return;\n            }\n\n            Throwable ex = error.get();\n\n            if (ex != null) {\n                cancelAll();\n                Arrays.fill(lists, null);\n                a.onError(ex);\n                return;\n            }\n\n            boolean empty = true;\n\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] != lists[i].size()) {\n                    empty = false;\n                    break;\n                }\n            }\n\n            if (empty) {\n                Arrays.fill(lists, null);\n                a.onComplete();\n                return;\n            }\n\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "422", "src_id": "M1224", "code": "\n    void drainLoop() {\n        Subscriber < ? super T > actual = this.downstream;\n        int missed = 1;\n        long e = emitted;\n        int c = consumed;\n        int lim = limit;\n\n        for (;;) {\n            long r = requested.get();\n\n            while (e != r) {\n                if (cancelled) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                int os = otherState;\n\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                    e++;\n                    continue;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue < T > q = queue;\n                T v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                actual.onNext(v);\n                e++;\n\n                if (++c == lim) {\n                    c = 0;\n                    mainSubscription.get().request(lim);\n                }\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue < T > q = queue;\n                boolean empty = q == null || q.isEmpty();\n\n                if (d && empty && otherState == 2) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n            }\n\n            emitted = e;\n            consumed = c;\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "423", "src_id": "M2134", "code": "\n    @ SuppressWarnings(\"unchecked\" ) @NonNull\n    public final U assertValueAt(int index, @NonNull Predicate < T > valuePredicate) {\n        int s = values.size();\n\n        if (s == 0) {\n            throw fail(\"No values\");\n        }\n\n        if (index < 0 || index >= s) {\n            throw fail(\"Index \" + index + \" is out of range [0, \" + s + \")\");\n        }\n\n        boolean found = false;\n        T v = values.get(index);\n\n        try {\n            if (valuePredicate.test(v)) {\n                found = true;\n            }\n        } catch (Throwable ex) {\n            throw ExceptionHelper.wrapOrThrow(ex);\n        }\n\n        if (!found) {\n            throw fail(\"Value \" + valueAndClass(v) + \" at position \" + index + \" did not pass the predicate\");\n        }\n\n        return (U) this;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "424", "src_id": "M2722", "code": "\n    @Override\n    public void onSubscribe(@NonNull Subscription s) {\n        if (SubscriptionHelper.validate(this.upstream, s)) {\n            this.upstream = s;\n            try {\n                downstream.onSubscribe(this);\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                done = true;\n                // can't call onError because the actual's state may be corrupt at this point\n                try {\n                    s.cancel();\n                } catch (Throwable e1) {\n                    Exceptions.throwIfFatal(e1);\n                    RxJavaPlugins.onError(new CompositeException(e, e1));\n                    return;\n                }\n\n                RxJavaPlugins.onError(e);\n            }\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}

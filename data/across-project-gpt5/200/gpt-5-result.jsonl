{"project_name": "across-project", "pair_id": "1", "src_id": "M662", "code": "\nprivate void finishing(Advice advice) {\n    // cost time of this invocation\n    try {\n        double cost = threadLocalWatch.costInMillis();\n        String conditionExpress = command.getConditionExpress();\n        boolean conditionResult = isConditionMet(conditionExpress, advice, cost);\n\n        if (this.isVerbose()) {\n            process.write(\"Condition express: \" + conditionExpress + \" , result: \" + conditionResult + \"\\n\");\n        }\n\n        if (conditionResult) {\n            // TODO: concurrency issues for process.write\n            StackModel stackModel = ThreadUtil.getThreadStackModel(advice.getLoader(), Thread.currentThread());\n            stackModel.setTs(LocalDateTime.now());\n            process.appendResult(stackModel);\n            process.times().incrementAndGet();\n\n            if (isLimitExceeded(command.getNumberOfLimit(), process.times().get())) {\n                abortProcess(process, command.getNumberOfLimit());\n            }\n        }\n    } catch (Throwable e) {\n        logger.warn(\"stack failed.\", e);\n        process.end(\n                -1,\n                \"stack failed, condition is: \" + command.getConditionExpress() + \", \" + e.getMessage()\n                        + \", visit \" + LogUtil.loggingFile() + \" for more details.\"\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "2", "src_id": "M1051", "code": "\nprivate Process createProcess(\n        Session session,\n        List<CliToken> line,\n        InternalCommandManager commandManager,\n        int jobId,\n        Term term,\n        ResultDistributor resultDistributor) {\n    try {\n        ListIterator<CliToken> tokens = line.listIterator();\n        while (tokens.hasNext()) {\n            CliToken token = tokens.next();\n            if (token.isText()) {\n                // check before create process\n                checkPermission(session, token);\n                Command command = commandManager.getCommand(token.value());\n                if (command != null) {\n                    return createCommandProcess(command, tokens, jobId, term, resultDistributor);\n                }\n                throw new IllegalArgumentException(token.value() + \": command not found\");\n            }\n        }\n        throw new IllegalArgumentException();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "3", "src_id": "M464", "code": "\nprivate void initCommands(List<String> disabledCommands) {\n    List<Class<? extends AnnotatedCommand>> commandClassList = new ArrayList<>(33);\n    commandClassList.add(HelpCommand.class);\n    commandClassList.add(AuthCommand.class);\n    commandClassList.add(KeymapCommand.class);\n    commandClassList.add(SearchClassCommand.class);\n    commandClassList.add(SearchMethodCommand.class);\n    commandClassList.add(ClassLoaderCommand.class);\n    commandClassList.add(JadCommand.class);\n    commandClassList.add(GetStaticCommand.class);\n    commandClassList.add(MonitorCommand.class);\n    commandClassList.add(StackCommand.class);\n    commandClassList.add(ThreadCommand.class);\n    commandClassList.add(TraceCommand.class);\n    commandClassList.add(WatchCommand.class);\n    commandClassList.add(TimeTunnelCommand.class);\n    commandClassList.add(JvmCommand.class);\n    commandClassList.add(MemoryCommand.class);\n    commandClassList.add(PerfCounterCommand.class);\n    // commandClassList.add(GroovyScriptCommand.class);\n    commandClassList.add(OgnlCommand.class);\n    commandClassList.add(MemoryCompilerCommand.class);\n    commandClassList.add(RedefineCommand.class);\n    commandClassList.add(RetransformCommand.class);\n    commandClassList.add(DashboardCommand.class);\n    commandClassList.add(DumpClassCommand.class);\n    commandClassList.add(HeapDumpCommand.class);\n    commandClassList.add(JulyCommand.class);\n    commandClassList.add(ThanksCommand.class);\n    commandClassList.add(OptionsCommand.class);\n    commandClassList.add(ClsCommand.class);\n    commandClassList.add(ResetCommand.class);\n    commandClassList.add(VersionCommand.class);\n    commandClassList.add(SessionCommand.class);\n    commandClassList.add(SystemPropertyCommand.class);\n    commandClassList.add(SystemEnvCommand.class);\n    commandClassList.add(VMOptionCommand.class);\n    commandClassList.add(LoggerCommand.class);\n    commandClassList.add(HistoryCommand.class);\n    commandClassList.add(CatCommand.class);\n    commandClassList.add(Base64Command.class);\n    commandClassList.add(EchoCommand.class);\n    commandClassList.add(PwdCommand.class);\n    commandClassList.add(MBeanCommand.class);\n    commandClassList.add(GrepCommand.class);\n    commandClassList.add(TeeCommand.class);\n    commandClassList.add(ProfilerCommand.class);\n    commandClassList.add(VmToolCommand.class);\n    commandClassList.add(StopCommand.class);\n\n    try {\n        if (ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Recording.class\") != null) {\n            commandClassList.add(JFRCommand.class);\n        }\n    } catch (Throwable e) {\n        logger.error(\"This jdk version not support jfr command\");\n    }\n\n    for (Class<? extends AnnotatedCommand> clazz : commandClassList) {\n        Name name = clazz.getAnnotation(Name.class);\n        if (name != null && name.value() != null) {\n            if (disabledCommands.contains(name.value())) {\n                continue;\n            }\n        }\n        commands.add(Command.create(clazz));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "4", "src_id": "M1305", "code": "\npublic synchronized EnhancerAffect enhance(final Instrumentation inst, int maxNumOfMatchedClass)\n        throws UnmodifiableClassException {\n    // get matched classes\n    this.matchingClasses = GlobalOptions.isDisableSubClass\n            ? SearchUtils.searchClass(inst, classNameMatcher)\n            : SearchUtils.searchSubClass(inst, SearchUtils.searchClass(inst, classNameMatcher));\n\n    if (matchingClasses.size() > maxNumOfMatchedClass) {\n        affect.setOverLimitMsg(\n                \"The number of matched classes is \" + matchingClasses.size() + \", greater than the limit value \"\n                        + maxNumOfMatchedClass + \". Try to change the limit with option '-m <arg>'.\");\n        return affect;\n    }\n\n    // filter classes that cannot be enhanced\n    List<Pair<Class<?>, String>> filteredList = filter(matchingClasses);\n    if (!filteredList.isEmpty()) {\n        for (Pair<Class<?>, String> filtered : filteredList) {\n            logger.info(\"ignore class: {}, reason: {}\", filtered.getFirst().getName(), filtered.getSecond());\n        }\n    }\n\n    logger.info(\"enhance matched classes: {}\", matchingClasses);\n\n    affect.setTransformer(this);\n\n    try {\n        ArthasBootstrap.getInstance().getTransformerManager().addTransformer(this, isTracing);\n\n        // batch enhance\n        if (GlobalOptions.isBatchReTransform) {\n            final int size = matchingClasses.size();\n            final Class<?>[] classArray = new Class<?>[size];\n            arraycopy(matchingClasses.toArray(), 0, classArray, 0, size);\n            if (classArray.length > 0) {\n                inst.retransformClasses(classArray);\n                logger.info(\"Success to batch transform classes: {}\", Arrays.toString(classArray));\n            }\n        } else {\n            // enhance one by one\n            for (Class<?> clazz : matchingClasses) {\n                try {\n                    inst.retransformClasses(clazz);\n                    logger.info(\"Success to transform class: {}\", clazz);\n                } catch (Throwable t) {\n                    logger.warn(\"retransform {} failed.\", clazz, t);\n                    if (t instanceof UnmodifiableClassException) {\n                        throw (UnmodifiableClassException) t;\n                    } else if (t instanceof RuntimeException) {\n                        throw (RuntimeException) t;\n                    } else {\n                        throw new RuntimeException(t);\n                    }\n                }\n            }\n        }\n    } catch (Throwable e) {\n        logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n        affect.setThrowable(e);\n    }\n\n    return affect;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "5", "src_id": "M1163", "code": "\npublic static DefaultFullHttpResponse directView(\n        File dir, String path, FullHttpRequest request, ChannelHandlerContext ctx) throws IOException {\n    if (path.startsWith(\"/\")) {\n        path = path.substring(1);\n    }\n\n    // path maybe: arthas-output/20201225-203454.svg\n    // use dir's parent to remove prefix\n    File file = new File(dir.getParent(), path);\n    HttpVersion version = request.protocolVersion();\n\n    if (!isSubFile(dir, file)) {\n        return null;\n    }\n\n    DefaultFullHttpResponse fullResp = new DefaultFullHttpResponse(version, HttpResponseStatus.OK);\n\n    if (file.isDirectory()) {\n        if (!path.endsWith(\"/\")) {\n            fullResp.setStatus(HttpResponseStatus.FOUND).headers().set(\n                    HttpHeaderNames.LOCATION,\n                    \"/\" + path + \"/\"\n            );\n        }\n        String renderResult = renderDir(file, !isSameFile(dir, file));\n        fullResp.content().writeBytes(renderResult.getBytes(\"utf-8\"));\n        fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=utf-8\");\n        ctx.write(fullResp);\n        ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n        future.addListener(ChannelFutureListener.CLOSE);\n        return fullResp;\n    }\n\n    logger.info(\"get file now. file: {}\", file.getPath());\n    if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n        return null;\n    }\n\n    long fileLength = file.length();\n    if (fileLength < MIN_NETTY_DIRECT_SEND_SIZE) {\n        FileInputStream fileInputStream = new FileInputStream(file);\n        try {\n            byte[] content = IOUtils.getBytes(fileInputStream);\n            fullResp.content().writeBytes(content);\n            HttpUtil.setContentLength(fullResp, fullResp.content().readableBytes());\n        } finally {\n            IOUtils.close(fileInputStream);\n        }\n\n        ChannelFuture channelFuture = ctx.writeAndFlush(fullResp);\n        channelFuture.addListener((ChannelFutureListener) future -> {\n            if (future.isSuccess()) {\n                ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n                lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n            } else {\n                future.channel().close();\n            }\n        });\n        return fullResp;\n    }\n\n    logger.info(\"file {} size bigger than {}, send by future.\", file.getName(), MIN_NETTY_DIRECT_SEND_SIZE);\n    HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);\n    HttpUtil.setContentLength(response, fileLength);\n    setContentTypeHeader(response, file);\n    setDateAndCacheHeaders(response, file);\n    if (HttpUtil.isKeepAlive(request)) {\n        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n    }\n\n    // Write the initial line and the header.\n    ctx.write(response);\n\n    // Write the content.\n    ChannelFuture sendFileFuture;\n    ChannelFuture lastContentFuture;\n    RandomAccessFile raf = new RandomAccessFile(file, \"r\"); // will be closed by netty\n\n    if (ctx.pipeline().get(SslHandler.class) == null) {\n        sendFileFuture = ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());\n        // Write the end marker.\n        lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n    } else {\n        sendFileFuture = ctx.writeAndFlush(\n                new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),\n                ctx.newProgressivePromise()\n        );\n        // HttpChunkedInput will write the end marker (LastHttpContent) for us.\n        lastContentFuture = sendFileFuture;\n    }\n\n    sendFileFuture.addListener(new ChannelProgressiveFutureListener() {\n        @Override\n        public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {\n            if (total < 0) { // total unknown\n                logger.info(\"{} Transfer progress: {}\", future.channel(), progress);\n            } else {\n                logger.info(\"{} Transfer progress: {} / {}\", future.channel(), progress, total);\n            }\n        }\n\n        @Override\n        public void operationComplete(ChannelProgressiveFuture future) {\n            logger.info(\"{} Transfer complete.\", future.channel());\n        }\n    });\n\n    // Decide whether to close the connection or not.\n    if (!HttpUtil.isKeepAlive(request)) {\n        // Close the connection when the whole content is written out.\n        lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n    }\n\n    return fullResp;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "6", "src_id": "M1300", "code": "\n@Override\npublic byte[] transform(\n        final ClassLoader inClassLoader,\n        String className,\n        Class<?> classBeingRedefined,\n        ProtectionDomain protectionDomain,\n        byte[] classfileBuffer) throws IllegalClassFormatException {\n    try {\n        // Check if classloader can load SpyAPI, or skip enhancement\n        try {\n            if (inClassLoader != null) {\n                inClassLoader.loadClass(SpyAPI.class.getName());\n            }\n        } catch (Throwable e) {\n            logger.error(\n                    \"the classloader can not load SpyAPI, ignore it. classloader: {}, className: {}\",\n                    inClassLoader.getClass().getName(), className, e);\n            return null;\n        }\n\n        // Filter again because new classes may be created during transform\n        if (matchingClasses != null && !matchingClasses.contains(classBeingRedefined)) {\n            return null;\n        }\n\n        // keep origin class reader for bytecode optimizations, avoiding JVM metaspace OOM.\n        ClassNode classNode = new ClassNode(Opcodes.ASM9);\n        ClassReader classReader = AsmUtils.toClassNode(classfileBuffer, classNode);\n        // remove JSR https://github.com/alibaba/arthas/issues/1304\n        classNode = AsmUtils.removeJSRInstructions(classNode);\n\n        // generate enhanced bytecode\n        DefaultInterceptorClassParser defaultInterceptorClassParser = new DefaultInterceptorClassParser();\n\n        final List<InterceptorProcessor> interceptorProcessors = new ArrayList<>();\n        interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyInterceptor1.class));\n        interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyInterceptor2.class));\n        interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyInterceptor3.class));\n\n        if (this.isTracing) {\n            if (!this.skipJDKTrace) {\n                interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceInterceptor1.class));\n                interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceInterceptor2.class));\n                interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceInterceptor3.class));\n            } else {\n                interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceExcludeJDKInterceptor1.class));\n                interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceExcludeJDKInterceptor2.class));\n                interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceExcludeJDKInterceptor3.class));\n            }\n        }\n\n        List<MethodNode> matchedMethods = new ArrayList<>();\n        for (MethodNode methodNode : classNode.methods) {\n            if (!isIgnore(methodNode, methodNameMatcher)) {\n                matchedMethods.add(methodNode);\n            }\n        }\n\n        // https://github.com/alibaba/arthas/issues/1690\n        if (AsmUtils.isEnhancerByCGLIB(className)) {\n            for (MethodNode methodNode : matchedMethods) {\n                if (AsmUtils.isConstructor(methodNode)) {\n                    AsmUtils.fixConstructorExceptionTable(methodNode);\n                }\n            }\n        }\n\n        // Used to check if spy functions already exist to avoid duplicate insertion\n        GroupLocationFilter groupLocationFilter = new GroupLocationFilter();\n\n        LocationFilter enterFilter = new InvokeContainLocationFilter(\n                Type.getInternalName(SpyAPI.class), \"atEnter\", LocationType.ENTER);\n        LocationFilter existFilter = new InvokeContainLocationFilter(\n                Type.getInternalName(SpyAPI.class), \"atExit\", LocationType.EXIT);\n        LocationFilter exceptionFilter = new InvokeContainLocationFilter(\n                Type.getInternalName(SpyAPI.class), \"atExceptionExit\", LocationType.EXCEPTION_EXIT);\n\n        groupLocationFilter.addFilter(enterFilter);\n        groupLocationFilter.addFilter(existFilter);\n        groupLocationFilter.addFilter(exceptionFilter);\n\n        LocationFilter invokeBeforeFilter = new InvokeCheckLocationFilter(\n                Type.getInternalName(SpyAPI.class), \"atBeforeInvoke\", LocationType.INVOKE);\n        LocationFilter invokeAfterFilter = new InvokeCheckLocationFilter(\n                Type.getInternalName(SpyAPI.class), \"atInvokeException\", LocationType.INVOKE_COMPLETED);\n        LocationFilter invokeExceptionFilter = new InvokeCheckLocationFilter(\n                Type.getInternalName(SpyAPI.class), \"atInvokeException\", LocationType.INVOKE_EXCEPTION_EXIT);\n        groupLocationFilter.addFilter(invokeBeforeFilter);\n        groupLocationFilter.addFilter(invokeAfterFilter);\n        groupLocationFilter.addFilter(invokeExceptionFilter);\n\n        for (MethodNode methodNode : matchedMethods) {\n            if (AsmUtils.isNative(methodNode)) {\n                logger.info(\"ignore native method: {}\",\n                        AsmUtils.methodDeclaration(Type.getObjectType(classNode.name), methodNode));\n                continue;\n            }\n\n            // If atBeforeInvoke exists, trace already present: only register listener\n            if (AsmUtils.containsMethodInsnNode(methodNode, Type.getInternalName(SpyAPI.class), \"atBeforeInvoke\")) {\n                for (AbstractInsnNode insnNode = methodNode.instructions.getFirst();\n                     insnNode != null;\n                     insnNode = insnNode.getNext()) {\n                    if (insnNode instanceof MethodInsnNode) {\n                        final MethodInsnNode methodInsnNode = (MethodInsnNode) insnNode;\n\n                        if (this.skipJDKTrace) {\n                            if (methodInsnNode.owner.startsWith(\"java/\")) {\n                                continue;\n                            }\n                        }\n\n                        // skip boxing types\n                        if (AsmOpUtils.isBoxType(Type.getObjectType(methodInsnNode.owner))) {\n                            continue;\n                        }\n\n                        AdviceListenerManager.registerTraceAdviceListener(\n                                inClassLoader, className,\n                                methodInsnNode.owner, methodInsnNode.name, methodInsnNode.desc, listener);\n                    }\n                }\n            } else {\n                MethodProcessor methodProcessor = new MethodProcessor(classNode, methodNode, groupLocationFilter);\n                for (InterceptorProcessor interceptor : interceptorProcessors) {\n                    try {\n                        List<Location> locations = interceptor.process(methodProcessor);\n                        for (Location location : locations) {\n                            if (location instanceof MethodInsnNodeWare) {\n                                MethodInsnNodeWare methodInsnNodeWare = (MethodInsnNodeWare) location;\n                                MethodInsnNode methodInsnNode = methodInsnNodeWare.methodInsnNode();\n\n                                AdviceListenerManager.registerTraceAdviceListener(\n                                        inClassLoader, className,\n                                        methodInsnNode.owner, methodInsnNode.name, methodInsnNode.desc, listener);\n                            }\n                        }\n                    } catch (Throwable e) {\n                        logger.error(\n                                \"enhancer error, class: {}, method: {}, interceptor: {}\",\n                                classNode.name, methodNode.name, interceptor.getClass().getName(), e);\n                    }\n                }\n            }\n\n            // enter/exit always register listener\n            AdviceListenerManager.registerAdviceListener(\n                    inClassLoader, className, methodNode.name, methodNode.desc, listener);\n            affect.addMethodAndCount(inClassLoader, className, methodNode.name, methodNode.desc);\n        }\n\n        // https://github.com/alibaba/arthas/issues/1223 , V1_5 major version is 49\n        if (AsmUtils.getMajorVersion(classNode.version) < 49) {\n            classNode.version = AsmUtils.setMajorVersion(classNode.version, 49);\n        }\n\n        byte[] enhanceClassByteArray = AsmUtils.toBytes(classNode, inClassLoader, classReader);\n\n        // enhance success, record class\n        classBytesCache.put(classBeingRedefined, new Object());\n\n        // dump the class\n        dumpClassIfNecessary(className, enhanceClassByteArray, affect);\n\n        // success count\n        affect.cCnt(1);\n\n        return enhanceClassByteArray;\n    } catch (Throwable t) {\n        logger.warn(\"transform loader[{}]:class[{}] failed.\", inClassLoader, className, t);\n        affect.setThrowable(t);\n    }\n\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "7", "src_id": "M982", "code": "\npublic static boolean completeMethodName(Completion completion) {\n    List<CliToken> tokens = completion.lineTokens();\n    String lastToken = tokens.get(tokens.size() - 1).value();\n\n    if (StringUtils.isBlank(lastToken)) {\n        lastToken = \"\";\n    }\n\n    // retrieve the class name\n    String className;\n    if (StringUtils.isBlank(lastToken)) {\n        // tokens = { \" \", \"CLASS_NAME\", \" \"}\n        className = tokens.get(tokens.size() - 2).value();\n    } else {\n        // tokens = { \" \", \"CLASS_NAME\", \" \", \"PARTIAL_METHOD_NAME\"}\n        className = tokens.get(tokens.size() - 3).value();\n    }\n\n    Set<Class<?>> results = SearchUtils.searchClassOnly(completion.session().getInstrumentation(), className, 2);\n    if (results.size() != 1) {\n        // no class found or multiple class found\n        completion.complete(Collections.emptyList());\n        return true;\n    }\n\n    Class<?> clazz = results.iterator().next();\n\n    List<String> res = new ArrayList<>();\n    for (Method method : clazz.getDeclaredMethods()) {\n        if (StringUtils.isBlank(lastToken)) {\n            res.add(method.getName());\n        } else if (method.getName().startsWith(lastToken)) {\n            res.add(method.getName());\n        }\n    }\n    res.add(\"<init>\");\n\n    if (res.size() == 1) {\n        completion.complete(res.get(0).substring(lastToken.length()), true);\n        return true;\n    } else {\n        CompletionUtils.complete(completion, res);\n        return true;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "8", "src_id": "M249", "code": "\nprivate void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri)\n        throws URISyntaxException {\n    QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n    Map<String, List<String>> parameters = queryDecoder.parameters();\n\n    String appName = null;\n    List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n    if (appNameList != null && !appNameList.isEmpty()) {\n        appName = appNameList.get(0);\n    }\n\n    // generate a random agent id\n    String id;\n    if (appName != null) {\n        // if app name provided, prefix id with app name for easier management\n        id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n    } else {\n        id = RandomStringUtils.random(20, true, true).toUpperCase();\n    }\n\n    // prefer id from agent if provided\n    List<String> idList = parameters.get(URIConstans.ID);\n    if (idList != null && !idList.isEmpty()) {\n        id = idList.get(0);\n    }\n\n    String arthasVersion = null;\n    List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n    if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n        arthasVersion = arthasVersionList.get(0);\n    }\n\n    final String finalId = id;\n\n    URI responseUri = UriComponentsBuilder.newInstance()\n            .scheme(URIConstans.RESPONSE)\n            .path(\"/\")\n            .queryParam(URIConstans.METHOD, MethodConstants.AGENT_REGISTER)\n            .queryParam(URIConstans.ID, id)\n            .build()\n            .encode()\n            .toUri();\n\n    AgentInfo info = new AgentInfo();\n\n    // might be behind nginx proxy\n    HttpHeaders headers = handshake.requestHeaders();\n    String host = HttpUtils.findClientIP(headers);\n\n    if (host == null) {\n        SocketAddress remoteAddress = ctx.channel().remoteAddress();\n        if (remoteAddress instanceof InetSocketAddress) {\n            InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n            info.setHost(inetSocketAddress.getHostString());\n            info.setPort(inetSocketAddress.getPort());\n        }\n    } else {\n        info.setHost(host);\n        Integer port = HttpUtils.findClientPort(headers);\n        if (port != null) {\n            info.setPort(port);\n        }\n    }\n\n    info.setChannelHandlerContext(ctx);\n    if (arthasVersion != null) {\n        info.setArthasVersion(arthasVersion);\n    }\n\n    tunnelServer.addAgent(id, info);\n    ctx.channel().closeFuture().addListener(new GenericFutureListener<Future<? super Void>>() {\n        @Override\n        public void operationComplete(Future<? super Void> future) throws Exception {\n            tunnelServer.removeAgent(finalId);\n        }\n    });\n\n    ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "9", "src_id": "M173", "code": "\n@Override\npublic int[] startSubnegotiationLocal() {\n    int nCompoundWindowSize = m_nWidth * 0x10000 + m_nHeight;\n    int nResponseSize = 5;\n    int nIndex;\n    int nShift;\n    int nTurnedOnBits;\n\n    if ((m_nWidth % 0x100) == 0xFF) {\n        nResponseSize += 1;\n    }\n    if ((m_nWidth / 0x100) == 0xFF) {\n        nResponseSize += 1;\n    }\n    if ((m_nHeight % 0x100) == 0xFF) {\n        nResponseSize += 1;\n    }\n    if ((m_nHeight / 0x100) == 0xFF) {\n        nResponseSize += 1;\n    }\n\n    // allocate response array\n    int[] response = new int[nResponseSize];\n\n    // Build response array.\n    // 1. put option name.\n    // 2. loop through Window size and fill the values,\n    // 3. duplicate 'ff' if needed.\n    response[0] = WINDOW_SIZE; // 1\n\n    for (nIndex = 1, nShift = 24; nIndex < nResponseSize; nIndex++, nShift -= 8) { // 2\n        nTurnedOnBits = 0xFF;\n        nTurnedOnBits <<= nShift;\n        response[nIndex] = (nCompoundWindowSize & nTurnedOnBits) >>> nShift;\n\n        if (response[nIndex] == 0xff) { // 3\n            nIndex++;\n            response[nIndex] = 0xff;\n        }\n    }\n\n    return response;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "10", "src_id": "M1370", "code": "\n@SuppressWarnings({ \"unchecked\", \"restriction\" })\npublic static URL[] getUrls(ClassLoader classLoader) {\n    if (classLoader instanceof URLClassLoader) {\n        try {\n            return ((URLClassLoader) classLoader).getURLs();\n        } catch (Throwable e) {\n            logger.error(\"classLoader: {} getUrls error\", classLoader, e);\n        }\n    }\n\n    // jdk9+\n    if (classLoader.getClass().getName().startsWith(\"jdk.internal.loader.ClassLoaders$\")) {\n        try {\n            Field field = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n            field.setAccessible(true);\n            sun.misc.Unsafe unsafe = (sun.misc.Unsafe) field.get(null);\n\n            Class<?> ucpOwner = classLoader.getClass();\n            Field ucpField = null;\n\n            // jdk 9~15: jdk.internal.loader.ClassLoaders$AppClassLoader.ucp\n            // jdk 16~17: jdk.internal.loader.BuiltinClassLoader.ucp\n            while (ucpField == null && !ucpOwner.getName().equals(\"java.lang.Object\")) {\n                try {\n                    ucpField = ucpOwner.getDeclaredField(\"ucp\");\n                } catch (NoSuchFieldException ex) {\n                    ucpOwner = ucpOwner.getSuperclass();\n                }\n            }\n            if (ucpField == null) {\n                return null;\n            }\n\n            long ucpFieldOffset = unsafe.objectFieldOffset(ucpField);\n            Object ucpObject = unsafe.getObject(classLoader, ucpFieldOffset);\n            if (ucpObject == null) {\n                return null;\n            }\n\n            // jdk.internal.loader.URLClassPath.path\n            Field pathField = ucpField.getType().getDeclaredField(\"path\");\n            if (pathField == null) {\n                return null;\n            }\n            long pathFieldOffset = unsafe.objectFieldOffset(pathField);\n            ArrayList<URL> path = (ArrayList<URL>) unsafe.getObject(ucpObject, pathFieldOffset);\n\n            return path.toArray(new URL[path.size()]);\n        } catch (Throwable e) {\n            // ignore\n            return null;\n        }\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "11", "src_id": "M828", "code": "\nprivate Minf parseMinf(final Box ref) throws IOException {\n    final Minf obj = new Minf();\n    Box b;\n    while ((b = untilAnyBox(ref)) != null) {\n        switch (b.type) {\n            case ATOM_DINF:\n                obj.dinf = readFullBox(b);\n                break;\n            case ATOM_STBL:\n                obj.stblStsd = parseStbl(b);\n                break;\n            case ATOM_VMHD:\n            case ATOM_SMHD:\n                obj.mhd = readFullBox(b);\n                break;\n            default:\n                break;\n        }\n        ensure(b);\n    }\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "12", "src_id": "M824", "code": "\nprivate Moov parseMoov(final Box ref) throws IOException {\n    Box b = readBox(ATOM_MVHD);\n    final Moov moov = new Moov();\n    moov.mvhd = parseMvhd();\n    ensure(b);\n\n    final ArrayList<Trak> tmp = new ArrayList<>((int) moov.mvhd.nextTrackId);\n    while ((b = untilBox(ref, ATOM_TRAK, ATOM_MVEX)) != null) {\n        switch (b.type) {\n            case ATOM_TRAK:\n                tmp.add(parseTrak(b));\n                break;\n            case ATOM_MVEX:\n                moov.mvexTrex = parseMvex(b, (int) moov.mvhd.nextTrackId);\n                break;\n            default:\n                break;\n        }\n        ensure(b);\n    }\n\n    moov.trak = tmp.toArray(new Trak[0]);\n    return moov;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "13", "src_id": "M1086", "code": "\nprivate ArrayList<Object> getSpecialItems() {\n    synchronized (DownloadManager.this) {\n        ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n        ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n        List<Mission> remove = new ArrayList<>(hidden);\n\n        // hide missions (if required)\n        remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n        int fakeTotal = pending.size();\n        if (fakeTotal > 0) {\n            fakeTotal++;\n        }\n\n        fakeTotal += finished.size();\n        if (finished.size() > 0) {\n            fakeTotal++;\n        }\n\n        ArrayList<Object> list = new ArrayList<>(fakeTotal);\n        if (pending.size() > 0) {\n            list.add(PENDING);\n            list.addAll(pending);\n        }\n        if (finished.size() > 0) {\n            list.add(FINISHED);\n            list.addAll(finished);\n        }\n\n        hasFinished = finished.size() > 0;\n        return list;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "14", "src_id": "M1024", "code": "\n@Override\npublic void run() {\n    if (mMission.current > 0) {\n        mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n    }\n\n    int retryCount = 0;\n    int httpCode = 204;\n\n    while (true) {\n        try {\n            if (mMission.blocks == null && mMission.current == 0) {\n                long finalLength = 0;\n                long lowestSize = Long.MAX_VALUE;\n\n                for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                    mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (Thread.interrupted()) {\n                        return;\n                    }\n                    long length = Utility.getTotalContentLength(mConn);\n\n                    if (i == 0) {\n                        httpCode = mConn.getResponseCode();\n                        mMission.length = length;\n                    }\n\n                    if (length > 0) {\n                        finalLength += length;\n                    }\n                    if (length < lowestSize) {\n                        lowestSize = length;\n                    }\n                }\n\n                mMission.nearLength = finalLength;\n\n                if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                    if (lowestSize < 1) {\n                        mMission.offsets[0] = RESERVE_SPACE_DEFAULT;\n                    } else {\n                        mMission.offsets[0] = lowestSize < RESERVE_SPACE_MAXIMUM ? lowestSize : RESERVE_SPACE_MAXIMUM;\n                    }\n                }\n            } else {\n                mConn = mMission.openConnection(true, 0, 0);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                httpCode = mConn.getResponseCode();\n                mMission.length = Utility.getTotalContentLength(mConn);\n            }\n\n            if (mMission.length == 0 || httpCode == 204) {\n                mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                return;\n            }\n\n            if (mMission.length == -1 && mConn.getResponseCode() == 200) {\n                mMission.blocks = new int[0];\n                mMission.length = 0;\n                mMission.unknownLength = true;\n\n                if (DEBUG) {\n                    Log.d(TAG, \"falling back (unknown length)\");\n                }\n            } else {\n                mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                synchronized (mMission.LOCK) {\n                    if (mConn.getResponseCode() == 206) {\n                        if (mMission.threadCount > 1) {\n                            int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                            if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) {\n                                count++;\n                            }\n                            mMission.blocks = new int[count];\n                        } else {\n                            mMission.blocks = new int[0];\n                            mMission.unknownLength = false;\n                        }\n\n                        if (DEBUG) {\n                            Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                        }\n                    } else {\n                        mMission.blocks = new int[0];\n                        mMission.unknownLength = false;\n\n                        if (DEBUG) {\n                            Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                        }\n                    }\n                }\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n            }\n\n            try (SharpStream fs = mMission.storage.getStream()) {\n                fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                fs.seek(mMission.offsets[mMission.current]);\n            }\n\n            if (!mMission.running || Thread.interrupted()) {\n                return;\n            }\n\n            if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                String entityTag = mConn.getHeaderField(\"ETAG\");\n                String lastModified = mConn.getHeaderField(\"Last-Modified\");\n                MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n\n                if (!TextUtils.isEmpty(entityTag)) {\n                    recovery.setValidateCondition(entityTag);\n                } else if (!TextUtils.isEmpty(lastModified)) {\n                    recovery.setValidateCondition(lastModified);\n                } else {\n                    recovery.setValidateCondition(null);\n                }\n            }\n\n            mMission.running = false;\n            break;\n        } catch (InterruptedIOException | ClosedByInterruptException e) {\n            return;\n        } catch (Exception e) {\n            if (!mMission.running || super.isInterrupted()) {\n                return;\n            }\n\n            if (e instanceof DownloadMission.HttpError && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                interrupt();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                return;\n            }\n\n            if (retryCount++ > mMission.maxRetry) {\n                Log.e(TAG, \"initializer failed\", e);\n                mMission.notifyError(e);\n                return;\n            }\n\n            Log.e(TAG, \"initializer failed, retrying\", e);\n        }\n    }\n\n    mMission.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "15", "src_id": "M1099", "code": "\n@SuppressLint(\"DefaultLocale\")\nprivate void updateProgress(ViewHolderItem h) {\n    if (h == null || h.item == null || h.item.mission instanceof FinishedMission) {\n        return;\n    }\n\n    DownloadMission mission = (DownloadMission) h.item.mission;\n    double done = mission.done;\n    long length = mission.getLength();\n    long now = System.currentTimeMillis();\n    boolean hasError = mission.errCode != ERROR_NOTHING;\n\n    h.progress.setMarquee(mission.isRecovering() || (!hasError && (!mission.isInitialized() || mission.unknownLength)));\n\n    double progress;\n    if (mission.unknownLength) {\n        progress = Double.NaN;\n        h.progress.setProgress(0.0f);\n    } else {\n        progress = done / length;\n    }\n\n    if (hasError) {\n        h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n        h.status.setText(R.string.msg_error);\n    } else if (isNotFinite(progress)) {\n        h.status.setText(UNDEFINED_PROGRESS);\n    } else {\n        h.status.setText(String.format(\"%.2f%%\", progress * 100));\n        h.progress.setProgress(progress);\n    }\n\n    @StringRes int state;\n    String sizeStr = Utility.formatBytes(length).concat(\"  \");\n\n    if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n        h.size.setText(sizeStr);\n        return;\n    } else if (!mission.running) {\n        state = mission.enqueued ? R.string.queued : R.string.paused;\n    } else if (mission.isPsRunning()) {\n        state = R.string.post_processing;\n    } else if (mission.isRecovering()) {\n        state = R.string.recovering;\n    } else {\n        state = 0;\n    }\n\n    if (state != 0) {\n        h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n        h.resetSpeedMeasure();\n        return;\n    }\n\n    if (h.lastTimestamp < 0) {\n        h.size.setText(sizeStr);\n        h.lastTimestamp = now;\n        h.lastDone = done;\n        return;\n    }\n\n    long deltaTime = now - h.lastTimestamp;\n    double deltaDone = done - h.lastDone;\n\n    if (h.lastDone > done) {\n        h.lastDone = done;\n        h.size.setText(sizeStr);\n        return;\n    }\n\n    if (deltaDone > 0 && deltaTime > 0) {\n        float speed = (float) ((deltaDone * 1000d) / deltaTime);\n        float averageSpeed = speed;\n\n        if (h.lastSpeedIdx < 0) {\n            Arrays.fill(h.lastSpeed, speed);\n            h.lastSpeedIdx = 0;\n        } else {\n            for (int i = 0; i < h.lastSpeed.length; i++) {\n                averageSpeed += h.lastSpeed[i];\n            }\n            averageSpeed /= h.lastSpeed.length + 1.0f;\n        }\n\n        String speedStr = Utility.formatSpeed(averageSpeed);\n        String etaStr;\n\n        if (mission.unknownLength) {\n            etaStr = \"\";\n        } else {\n            long eta = (long) Math.ceil((length - done) / averageSpeed);\n            etaStr = Utility.formatBytes((long) done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n        }\n\n        h.size.setText(sizeStr.concat(etaStr).concat(speedStr));\n\n        h.lastTimestamp = now;\n        h.lastDone = done;\n        h.lastSpeed[h.lastSpeedIdx++] = speed;\n\n        if (h.lastSpeedIdx >= h.lastSpeed.length) {\n            h.lastSpeedIdx = 0;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "16", "src_id": "M817", "code": "\nprivate Trun parseTrun() throws IOException {\n    final Trun obj = new Trun();\n    obj.bFlags = stream.readInt();\n    obj.entryCount = stream.readInt(); // unsigned int\n\n    obj.entriesRowSize = 0;\n    if (hasFlag(obj.bFlags, 0x0100)) {\n        obj.entriesRowSize += 4;\n    }\n    if (hasFlag(obj.bFlags, 0x0200)) {\n        obj.entriesRowSize += 4;\n    }\n    if (hasFlag(obj.bFlags, 0x0400)) {\n        obj.entriesRowSize += 4;\n    }\n    if (hasFlag(obj.bFlags, 0x0800)) {\n        obj.entriesRowSize += 4;\n    }\n    obj.bEntries = new byte[obj.entriesRowSize * obj.entryCount];\n\n    if (hasFlag(obj.bFlags, 0x0001)) {\n        obj.dataOffset = stream.readInt();\n    }\n    if (hasFlag(obj.bFlags, 0x0004)) {\n        obj.bFirstSampleFlags = stream.readInt();\n    }\n\n    stream.read(obj.bEntries);\n\n    for (int i = 0; i < obj.entryCount; i++) {\n        final TrunEntry entry = obj.getEntry(i);\n        if (hasFlag(obj.bFlags, 0x0100)) {\n            obj.chunkDuration += entry.sampleDuration;\n        }\n        if (hasFlag(obj.bFlags, 0x0200)) {\n            obj.chunkSize += entry.sampleSize;\n        }\n        if (hasFlag(obj.bFlags, 0x0800)) {\n            if (!hasFlag(obj.bFlags, 0x0100)) {\n                obj.chunkDuration += entry.sampleCompositionTimeOffset;\n            }\n        }\n    }\n\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "17", "src_id": "M883", "code": "\nprivate void makeMvhd(final long longestTrack) throws IOException {\n    auxWrite(new byte[] {\n            0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00\n    });\n    auxWrite(ByteBuffer.allocate(28)\n            .putLong(time)\n            .putLong(time)\n            .putInt(DEFAULT_TIMESCALE)\n            .putLong(longestTrack)\n            .array()\n    );\n\n    auxWrite(new byte[] {\n            0x00, 0x01, 0x00, 0x00, 0x01, 0x00,\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00\n    });\n    auxWrite(new byte[24]);\n    auxWrite(ByteBuffer.allocate(4)\n            .putInt(tracks.length + 1)\n            .array()\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "18", "src_id": "M806", "code": "\npublic Mp4DashChunk getNextChunk(final boolean infoOnly) throws IOException {\n    final Mp4Track track = tracks[selectedTrack];\n\n    while (stream.available()) {\n        if (chunkZero) {\n            ensure(box);\n            if (!stream.available()) {\n                break;\n            }\n            box = readBox();\n        } else {\n            chunkZero = true;\n        }\n\n        switch (box.type) {\n            case ATOM_MOOF:\n                if (moof != null) {\n                    throw new IOException(\"moof found without mdat\");\n                }\n\n                moof = parseMoof(box, track.trak.tkhd.trackId);\n\n                if (moof.traf != null) {\n                    if (hasFlag(moof.traf.trun.bFlags, 0x0001)) {\n                        moof.traf.trun.dataOffset -= box.size + 8;\n                        if (moof.traf.trun.dataOffset < 0) {\n                            throw new IOException(\"trun box has wrong data offset, points outside of concurrent mdat box\");\n                        }\n                    }\n\n                    if (moof.traf.trun.chunkSize < 1) {\n                        if (hasFlag(moof.traf.tfhd.bFlags, 0x10)) {\n                            moof.traf.trun.chunkSize = moof.traf.tfhd.defaultSampleSize * moof.traf.trun.entryCount;\n                        } else {\n                            moof.traf.trun.chunkSize = (int) (box.size - 8);\n                        }\n                    }\n                    if (!hasFlag(moof.traf.trun.bFlags, 0x900) && moof.traf.trun.chunkDuration == 0) {\n                        if (hasFlag(moof.traf.tfhd.bFlags, 0x20)) {\n                            moof.traf.trun.chunkDuration = moof.traf.tfhd.defaultSampleDuration * moof.traf.trun.entryCount;\n                        }\n                    }\n                }\n                break;\n            case ATOM_MDAT:\n                if (moof == null) {\n                    throw new IOException(\"mdat found without moof\");\n                }\n\n                if (moof.traf == null) {\n                    moof = null;\n                    continue;\n                }\n\n                final Mp4DashChunk chunk = new Mp4DashChunk();\n                chunk.moof = moof;\n                if (!infoOnly) {\n                    chunk.data = stream.getView(moof.traf.trun.chunkSize);\n                }\n\n                moof = null;\n\n                stream.skipBytes(chunk.moof.traf.trun.dataOffset);\n                return chunk;\n            default:\n                break;\n        }\n    }\n\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "19", "src_id": "M1055", "code": "\npublic void updateMission(Mission mission) {\n    ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n    SQLiteDatabase database = getWritableDatabase();\n    String ts = String.valueOf(mission.timestamp);\n\n    int rowsAffected;\n\n    if (mission instanceof FinishedMission) {\n        if (mission.storage.isInvalid()) {\n            rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new String[] { ts });\n        } else {\n            rowsAffected = database.update(\n                    FINISHED_TABLE_NAME,\n                    values,\n                    KEY_PATH + \" = ?\",\n                    new String[] { mission.storage.getUri().toString() }\n            );\n        }\n    } else {\n        throw new UnsupportedOperationException(\"DownloadMission\");\n    }\n\n    if (rowsAffected != 1) {\n        Log.e(\"FinishedMissionStore\", \"Expected 1 row to be affected by update but got \" + rowsAffected);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "20", "src_id": "M403", "code": "\nprivate void animatePopupOverlayAndFinishService() {\n    int targetTranslationY = (int) (closeOverlayBinding.closeButton.getRootView().getHeight()\n            - closeOverlayBinding.closeButton.getY());\n\n    closeOverlayBinding.closeButton.animate().setListener(null).cancel();\n    closeOverlayBinding.closeButton.animate()\n            .setInterpolator(new AnticipateInterpolator())\n            .translationY(targetTranslationY)\n            .setDuration(400)\n            .setListener(new AnimatorListenerAdapter() {\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                    end();\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    end();\n                }\n\n                private void end() {\n                    windowManager.removeView(closeOverlayBinding.getRoot());\n                    closeOverlayBinding = null;\n                    player.getService().destroyPlayerAndStopService();\n                }\n            }).start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "21", "src_id": "M260", "code": "\npublic void play() {\n    if (DEBUG) {\n        Log.d(TAG, \"play() called\");\n    }\n    if (audioReactor == null || playQueue == null || exoPlayerIsNull()) {\n        return;\n    }\n\n    if (!isMuted()) {\n        audioReactor.requestAudioFocus();\n    }\n\n    if (currentState == STATE_COMPLETED) {\n        if (playQueue.getIndex() == 0) {\n            seekToDefault();\n        } else {\n            playQueue.setIndex(0);\n        }\n    }\n\n    simpleExoPlayer.play();\n    saveStreamProgressState();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "22", "src_id": "M543", "code": "\nsynchronized private NotificationCompat.Builder createNotification() {\n    if (DEBUG) {\n        Log.d(TAG, \"createNotification()\");\n    }\n    notificationManager = NotificationManagerCompat.from(player.getContext());\n    NotificationCompat.Builder builder =\n            new NotificationCompat.Builder(player.getContext(),\n                    player.getContext().getString(R.string.notification_channel_id));\n    MediaStyle mediaStyle = new MediaStyle();\n\n    // setup media style (compact notification slots and media session)\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n        // notification actions are ignored on Android 13+, and are replaced by code in\n        // MediaSessionPlayerUi\n        int[] compactSlots = initializeNotificationSlots();\n        mediaStyle.setShowActionsInCompactView(compactSlots);\n    }\n    player.UIs()\n            .get(MediaSessionPlayerUi.class)\n            .flatMap(MediaSessionPlayerUi::getSessionToken)\n            .ifPresent(mediaStyle::setMediaSession);\n\n    // setup notification builder\n    builder.setStyle(mediaStyle)\n            .setPriority(NotificationCompat.PRIORITY_HIGH)\n            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n            .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n            .setShowWhen(false)\n            .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n            .setColor(ContextCompat.getColor(player.getContext(),\n                    R.color.dark_background_color))\n            .setColorized(player.getPrefs().getBoolean(\n                    player.getContext().getString(R.string.notification_colorize_key), true))\n            .setDeleteIntent(PendingIntentCompat.getBroadcast(player.getContext(),\n                    NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, false));\n\n    // set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n    setLargeIcon(builder);\n\n    return builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "23", "src_id": "M225", "code": "\nprivate void onBroadcastReceived(Intent intent) {\n    if (intent == null || intent.getAction() == null) {\n        return;\n    }\n\n    if (DEBUG) {\n        Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n    }\n\n    switch (intent.getAction()) {\n        case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n            pause();\n            break;\n        case ACTION_CLOSE:\n            service.destroyPlayerAndStopService();\n            break;\n        case ACTION_PLAY_PAUSE:\n            playPause();\n            break;\n        case ACTION_PLAY_PREVIOUS:\n            playPrevious();\n            break;\n        case ACTION_PLAY_NEXT:\n            playNext();\n            break;\n        case ACTION_FAST_REWIND:\n            fastRewind();\n            break;\n        case ACTION_FAST_FORWARD:\n            fastForward();\n            break;\n        case ACTION_REPEAT:\n            cycleNextRepeatMode();\n            break;\n        case ACTION_SHUFFLE:\n            toggleShuffleModeEnabled();\n            break;\n        case Intent.ACTION_CONFIGURATION_CHANGED:\n            if (DEBUG) {\n                Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n            }\n            break;\n    }\n\n    UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "24", "src_id": "M631", "code": "\nprotected void addImagesMetadataItem(LayoutInflater inflater,\n                                     LinearLayout layout,\n                                     @StringRes int type,\n                                     List<Image> images) {\n    String preferredImageUrl = ImageStrategy.choosePreferredImage(images);\n    if (preferredImageUrl == null) {\n        return; // null will be returned in case there is no image\n    }\n\n    ItemMetadataBinding itemBinding = ItemMetadataBinding.inflate(inflater, layout, false);\n    itemBinding.metadataTypeView.setText(type);\n\n    SpannableStringBuilder urls = new SpannableStringBuilder();\n    for (Image image : images) {\n        if (urls.length() != 0) {\n            urls.append(\", \");\n        }\n        int entryBegin = urls.length();\n\n        if (image.getHeight() != Image.HEIGHT_UNKNOWN\n                || image.getWidth() != Image.WIDTH_UNKNOWN\n                // if even the resolution level is unknown, ?x? will be shown\n                || image.getEstimatedResolutionLevel() == Image.ResolutionLevel.UNKNOWN) {\n            urls.append(imageSizeToText(image.getHeight()));\n            urls.append('x');\n            urls.append(imageSizeToText(image.getWidth()));\n        } else {\n            switch (image.getEstimatedResolutionLevel()) {\n                case LOW:\n                    urls.append(getString(R.string.image_quality_low));\n                    break;\n                case MEDIUM:\n                    urls.append(getString(R.string.image_quality_medium));\n                    break;\n                case HIGH:\n                    urls.append(getString(R.string.image_quality_high));\n                    break;\n                default: {\n                    // unreachable, Image.ResolutionLevel.UNKNOWN is already filtered out\n                }\n            }\n        }\n\n        urls.setSpan(new ClickableSpan() {\n            @Override\n            public void onClick(@NonNull View widget) {\n                ShareUtils.openUrlInBrowser(requireContext(), image.getUrl());\n            }\n        }, entryBegin, urls.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\n        if (preferredImageUrl.equals(image.getUrl())) {\n            urls.setSpan(new StyleSpan(Typeface.BOLD), entryBegin, urls.length(),\n                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n        }\n    }\n\n    itemBinding.metadataContentView.setText(urls);\n    itemBinding.metadataContentView.setMovementMethod(LinkMovementMethod.getInstance());\n    layout.addView(itemBinding.getRoot());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "25", "src_id": "M12", "code": "\nprivate void openDetailFragmentFromCommentReplies(@NonNull FragmentManager fm,\n                                                  boolean popBackStack) {\n    // obtain the name of the fragment under the replies fragment that's going to be popped\n    @Nullable String fragmentUnderEntryName;\n    if (fm.getBackStackEntryCount() < 2) {\n        fragmentUnderEntryName = null;\n    } else {\n        fragmentUnderEntryName = fm.getBackStackEntryAt(fm.getBackStackEntryCount() - 2).getName();\n    }\n\n    // the root comment is the comment for which the user opened the replies page\n    @Nullable CommentRepliesFragment repliesFragment =\n            (CommentRepliesFragment) fm.findFragmentByTag(CommentRepliesFragment.TAG);\n    @Nullable CommentsInfoItem rootComment =\n            repliesFragment == null ? null : repliesFragment.getCommentsInfoItem();\n\n    // sometimes this function pops the backstack, other times it's handled by the system\n    if (popBackStack) {\n        fm.popBackStackImmediate();\n    }\n\n    // only expand the bottom sheet back if there are no more nested comment replies fragments\n    // stacked under the one that is currently being popped\n    if (CommentRepliesFragment.TAG.equals(fragmentUnderEntryName)) {\n        return;\n    }\n\n    BottomSheetBehavior<FragmentContainerView> behavior =\n            BottomSheetBehavior.from(mainBinding.fragmentPlayerHolder);\n    // do not return to the comment if the details fragment was closed\n    if (behavior.getState() == BottomSheetBehavior.STATE_HIDDEN) {\n        return;\n    }\n\n    // scroll to the root comment once the bottom sheet expansion animation is finished\n    behavior.addBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() {\n        @Override\n        public void onStateChanged(@NonNull View bottomSheet, int newState) {\n            if (newState == BottomSheetBehavior.STATE_EXPANDED) {\n                Fragment detailFragment = fm.findFragmentById(R.id.fragment_player_holder);\n                if (detailFragment instanceof VideoDetailFragment && rootComment != null) {\n                    // should always be the case\n                    ((VideoDetailFragment) detailFragment).scrollToComment(rootComment);\n                }\n                behavior.removeBottomSheetCallback(this);\n            }\n        }\n\n        @Override\n        public void onSlide(@NonNull View bottomSheet, float slideOffset) {\n            // not needed, listener is removed once the sheet is expanded\n        }\n    });\n\n    behavior.setState(BottomSheetBehavior.STATE_EXPANDED);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "26", "src_id": "M372", "code": "\nprivate void buildCaptionMenu(@NonNull List<String> availableLanguages) {\n    if (captionPopupMenu == null) {\n        return;\n    }\n    captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n\n    captionPopupMenu.setOnDismissListener(this);\n\n    // Add option for turning off caption\n    MenuItem captionOffItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION,\n            0, Menu.NONE, R.string.caption_none);\n    captionOffItem.setOnMenuItemClickListener(menuItem -> {\n        int textRendererIndex = player.getCaptionRendererIndex();\n        if (textRendererIndex != RENDERER_UNAVAILABLE) {\n            player.getTrackSelector().setParameters(player.getTrackSelector()\n                    .buildUponParameters().setRendererDisabled(textRendererIndex, true));\n        }\n        player.getPrefs().edit()\n                .remove(context.getString(R.string.caption_user_set_key)).apply();\n        return true;\n    });\n\n    // Add all available captions\n    for (int i = 0; i < availableLanguages.size(); i++) {\n        String captionLanguage = availableLanguages.get(i);\n        MenuItem captionItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION,\n                i + 1, Menu.NONE, captionLanguage);\n        captionItem.setOnMenuItemClickListener(menuItem -> {\n            int textRendererIndex = player.getCaptionRendererIndex();\n            if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                // DefaultTrackSelector will select for text tracks in the following order.\n                // When multiple tracks share the same rank, a random track will be chosen.\n                // 1. ANY track exactly matching preferred language name\n                // 2. ANY track exactly matching preferred language stem\n                // 3. ROLE_FLAG_CAPTION track matching preferred language stem\n                // 4. ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND track matching preferred language stem\n                // This means if a caption track of preferred language is not available,\n                // then an auto-generated track of that language will be chosen automatically.\n                player.getTrackSelector().setParameters(player.getTrackSelector()\n                        .buildUponParameters()\n                        .setPreferredTextLanguages(captionLanguage,\n                                PlayerHelper.captionLanguageStemOf(captionLanguage))\n                        .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                        .setRendererDisabled(textRendererIndex, false));\n                player.getPrefs().edit()\n                        .putString(context.getString(R.string.caption_user_set_key), captionLanguage)\n                        .apply();\n            }\n            return true;\n        });\n    }\n    captionPopupMenu.setOnDismissListener(this);\n\n    // apply caption language from previous user preference\n    int textRendererIndex = player.getCaptionRendererIndex();\n    if (textRendererIndex == RENDERER_UNAVAILABLE) {\n        return;\n    }\n\n    // If user prefers to show no caption, then disable the renderer.\n    // Otherwise, DefaultTrackSelector may automatically find an available caption\n    // and display that.\n    String userPreferredLanguage =\n            player.getPrefs().getString(context.getString(R.string.caption_user_set_key), null);\n    if (userPreferredLanguage == null) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters()\n                .setRendererDisabled(textRendererIndex, true));\n        return;\n    }\n\n    // Only set preferred language if it does not match the user preference,\n    // otherwise there might be an infinite cycle at onTextTracksChanged.\n    List<String> selectedPreferredLanguages =\n            player.getTrackSelector().getParameters().preferredTextLanguages;\n    if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n        player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters()\n                .setPreferredTextLanguages(userPreferredLanguage,\n                        PlayerHelper.captionLanguageStemOf(userPreferredLanguage))\n                .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                .setRendererDisabled(textRendererIndex, false));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "27", "src_id": "M741", "code": "\nprivate void onItemSelectedSetFileName() {\n    String fileName = FilenameUtils.createFilename(getContext(), currentInfo.getName());\n    String prevFileName = Optional.ofNullable(dialogBinding.fileName.getText())\n            .map(Object::toString)\n            .orElse(\"\");\n\n    if (prevFileName.isEmpty()\n            || prevFileName.equals(fileName)\n            || prevFileName.startsWith(getString(R.string.caption_file_name, fileName, \"\"))) {\n        // only update the file name field if it was not edited by the user\n\n        switch (dialogBinding.videoAudioGroup.getCheckedRadioButtonId()) {\n            case R.id.audio_button:\n            case R.id.video_button:\n                if (!prevFileName.equals(fileName)) {\n                    // since the user might have switched between audio and video, the correct\n                    // text might already be in place, so avoid resetting the cursor position\n                    dialogBinding.fileName.setText(fileName);\n                }\n                break;\n\n            case R.id.subtitle_button:\n                String setSubtitleLanguageCode =\n                        subtitleStreamsAdapter.getItem(selectedSubtitleIndex).getLanguageTag();\n                // this will reset the cursor position, which is bad UX, but it can't be avoided\n                dialogBinding.fileName.setText(\n                        getString(R.string.caption_file_name, fileName, setSubtitleLanguageCode));\n                break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "28", "src_id": "M327", "code": "\nprotected void deinitListeners() {\n    binding.qualityTextView.setOnClickListener(null);\n    binding.audioTrackTextView.setOnClickListener(null);\n    binding.playbackSpeed.setOnClickListener(null);\n    binding.playbackSeekBar.setOnSeekBarChangeListener(null);\n    binding.captionTextView.setOnClickListener(null);\n    binding.resizeTextView.setOnClickListener(null);\n    binding.playbackLiveSync.setOnClickListener(null);\n\n    binding.getRoot().setOnTouchListener(null);\n    playerGestureListener = null;\n    gestureDetector = null;\n\n    binding.repeatButton.setOnClickListener(null);\n    binding.shuffleButton.setOnClickListener(null);\n\n    binding.playPauseButton.setOnClickListener(null);\n    binding.playPreviousButton.setOnClickListener(null);\n    binding.playNextButton.setOnClickListener(null);\n\n    binding.moreOptionsButton.setOnClickListener(null);\n    binding.moreOptionsButton.setOnLongClickListener(null);\n    binding.share.setOnClickListener(null);\n    binding.share.setOnLongClickListener(null);\n    binding.fullScreenButton.setOnClickListener(null);\n    binding.screenRotationButton.setOnClickListener(null);\n    binding.playWithKodi.setOnClickListener(null);\n    binding.openInBrowser.setOnClickListener(null);\n    binding.playerCloseButton.setOnClickListener(null);\n    binding.switchMute.setOnClickListener(null);\n\n    ViewCompat.setOnApplyWindowInsetsListener(binding.itemsListPanel, null);\n\n    binding.playbackControlRoot.removeOnLayoutChangeListener(onLayoutChangeListener);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "29", "src_id": "M239", "code": "\nprivate void updatePlaybackState(boolean playWhenReady, int playbackState) {\n    if (DEBUG) {\n        Log.d(TAG, \"ExoPlayer - updatePlaybackState() called with: \"\n                + \"playWhenReady = [\" + playWhenReady + \"], \"\n                + \"playbackState = [\" + playbackState + \"]\");\n    }\n\n    if (currentState == STATE_PAUSED_SEEK) {\n        if (DEBUG) {\n            Log.d(TAG, \"updatePlaybackState() is currently blocked\");\n        }\n        return;\n    }\n\n    switch (playbackState) {\n        case com.google.android.exoplayer2.Player.STATE_IDLE: // 1\n            isPrepared = false;\n            break;\n        case com.google.android.exoplayer2.Player.STATE_BUFFERING: // 2\n            if (isPrepared) {\n                changeState(STATE_BUFFERING);\n            }\n            break;\n        case com.google.android.exoplayer2.Player.STATE_READY: //3\n            if (!isPrepared) {\n                isPrepared = true;\n                onPrepared(playWhenReady);\n            }\n            changeState(playWhenReady ? STATE_PLAYING : STATE_PAUSED);\n            break;\n        case com.google.android.exoplayer2.Player.STATE_ENDED: // 4\n            changeState(STATE_COMPLETED);\n            saveStreamProgressStateCompleted();\n            isPrepared = false;\n            break;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "30", "src_id": "M355", "code": "\nprivate static String processInlineImages(final String htmlContent, final EmailContent emailContent) {\n    if (htmlContent == null || emailContent == null) { return htmlContent; }\n\n    // Create a map of Content-ID to attachment data\n    final Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n    for (final EmailAttachment attachment : emailContent.getAttachments()) {\n        if (attachment.isEmbedded()\n                && attachment.getContentId() != null\n                && attachment.getData() != null) {\n            contentIdMap.put(attachment.getContentId(), attachment);\n        }\n    }\n\n    if (contentIdMap.isEmpty()) { return htmlContent; }\n\n    // Pattern to match cid: references in img src attributes\n    final Pattern cidPattern =\n            Pattern.compile(\n                    \"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\",\n                    Pattern.CASE_INSENSITIVE);\n    final Matcher matcher = cidPattern.matcher(htmlContent);\n\n    final StringBuffer result = new StringBuffer();\n    while (matcher.find()) {\n        final String contentId = matcher.group(1);\n        final EmailAttachment attachment = contentIdMap.get(contentId);\n\n        if (attachment != null && attachment.getData() != null) {\n            // Convert to data URI\n            String mimeType = attachment.getContentType();\n            if (mimeType == null || mimeType.isEmpty()) {\n                // Try to determine MIME type from filename\n                final String filename = attachment.getFilename();\n                if (filename != null) {\n                    final String lower = filename.toLowerCase();\n                    if (lower.endsWith(\".png\")) {\n                        mimeType = \"image/png\";\n                    } else if (lower.endsWith(\".jpg\") || lower.endsWith(\".jpeg\")) {\n                        mimeType = \"image/jpeg\";\n                    } else if (lower.endsWith(\".gif\")) {\n                        mimeType = \"image/gif\";\n                    } else if (lower.endsWith(\".bmp\")) {\n                        mimeType = \"image/bmp\";\n                    } else {\n                        mimeType = \"image/png\"; // fallback\n                    }\n                } else {\n                    mimeType = \"image/png\"; // fallback\n                }\n            }\n\n            final String base64Data = Base64.getEncoder().encodeToString(attachment.getData());\n            final String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n            // Replace the cid: reference with the data URI\n            final String replacement =\n                    matcher.group(0).replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n        } else {\n            // Keep original if attachment not found\n            matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n        }\n    }\n    matcher.appendTail(result);\n\n    return result.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "31", "src_id": "M347", "code": "\nprivate static void addAttachmentToInfo(\n        final StringBuilder attachmentInfo, final String filename, final String contentType, final String encoding) {\n    // Create attachment info with paperclip emoji before filename\n    attachmentInfo\n            .append(\"<div class=\\\"attachment-item\\\">\")\n            .append(\"<span class=\\\"attachment-icon\\\">\")\n            .append(MimeConstants.ATTACHMENT_MARKER)\n            .append(\"</span> \")\n            .append(\"<span class=\\\"attachment-name\\\">\")\n            .append(escapeHtml(filename))\n            .append(\"</span>\");\n\n    // Add content type and encoding info\n    if (!contentType.isEmpty() || !encoding.isEmpty()) {\n        attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n        if (!contentType.isEmpty()) {\n            attachmentInfo.append(escapeHtml(contentType));\n        }\n        if (!encoding.isEmpty()) {\n            if (!contentType.isEmpty()) attachmentInfo.append(\", \");\n            attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n        }\n        attachmentInfo.append(\")</span>\");\n    }\n    attachmentInfo.append(\"</div>\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "32", "src_id": "M356", "code": "\nprivate static void appendEnhancedStyles(final StringBuilder html) {\n    final int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n    final String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n    final String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n    final String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n    html.append(\"body {\\n\");\n    html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n    html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n    html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n    html.append(\"  color: \").append(textColor).append(\";\\n\");\n    html.append(\"  margin: 0;\\n\");\n    html.append(\"  padding: 16px;\\n\");\n    html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-container {\\n\");\n    html.append(\"  width: 100%;\\n\");\n    html.append(\"  max-width: 100%;\\n\");\n    html.append(\"  margin: 0 auto;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-header {\\n\");\n    html.append(\"  padding-bottom: 10px;\\n\");\n    html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n    html.append(\"  margin-bottom: 10px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-header h1 {\\n\");\n    html.append(\"  margin: 0 0 10px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n    html.append(\"  font-weight: bold;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-meta div {\\n\");\n    html.append(\"  margin-bottom: 2px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-body {\\n\");\n    html.append(\"  word-wrap: break-word;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".attachment-section {\\n\");\n    html.append(\"  margin-top: 15px;\\n\");\n    html.append(\"  padding: 10px;\\n\");\n    html.append(\"  background-color: \")\n            .append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border: 1px solid \")\n            .append(StyleConstants.ATTACHMENT_BORDER_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-section h3 {\\n\");\n    html.append(\"  margin: 0 0 8px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-item {\\n\");\n    html.append(\"  padding: 5px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-icon {\\n\");\n    html.append(\"  margin-right: 5px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-details, .attachment-type {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  color: #555555;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n    html.append(\"  margin-top: 8px;\\n\");\n    html.append(\"  padding: 6px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note {\\n\");\n    html.append(\"  background-color: #e6ffed;\\n\");\n    html.append(\"  border: 1px solid #d4f7dc;\\n\");\n    html.append(\"  color: #006420;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-info-note {\\n\");\n    html.append(\"  background-color: #fff9e6;\\n\");\n    html.append(\"  border: 1px solid #fff0c2;\\n\");\n    html.append(\"  color: #664d00;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container {\\n\");\n    html.append(\"  display: flex;\\n\");\n    html.append(\"  align-items: center;\\n\");\n    html.append(\"  padding: 8px;\\n\");\n    html.append(\"  background-color: #f8f9fa;\\n\");\n    html.append(\"  border: 1px solid #dee2e6;\\n\");\n    html.append(\"  border-radius: 4px;\\n\");\n    html.append(\"  margin: 4px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container:hover {\\n\");\n    html.append(\"  background-color: #e9ecef;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-note {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n    html.append(\"  color: #6c757d;\\n\");\n    html.append(\"  font-style: italic;\\n\");\n    html.append(\"  margin-left: 8px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    // Basic image styling: ensure images are responsive but not overly constrained.\n    html.append(\"img {\\n\");\n    html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n    html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n    html.append(\"  display: block;\\n\"); // Avoid extra space below images\n    html.append(\"}\\n\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "33", "src_id": "M342", "code": "\nprivate static String convertEmlToHtmlBasic(final byte[] emlBytes, final EmlToPdfRequest request) {\n    if (emlBytes == null || emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n    }\n\n    final String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n    // Basic email parsing\n    final String subject = extractBasicHeader(emlContent, \"Subject:\");\n    final String from = extractBasicHeader(emlContent, \"From:\");\n    final String to = extractBasicHeader(emlContent, \"To:\");\n    final String cc = extractBasicHeader(emlContent, \"Cc:\");\n    final String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n    final String date = extractBasicHeader(emlContent, \"Date:\");\n\n    // Try to extract HTML content\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n        final String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n\n    // Generate HTML with custom styling based on request\n    final StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n    // Include CC and BCC if present and requested\n    if (request != null && request.isIncludeAllRecipients()) {\n        if (!cc.trim().isEmpty()) {\n            html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        }\n        if (!bcc.trim().isEmpty()) {\n            html.append(\"<div><strong>BCC:</strong> \")\n                    .append(escapeHtml(bcc))\n                    .append(\"</div>\\n\");\n        }\n    }\n\n    if (!date.trim().isEmpty()) {\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    html.append(processEmailHtmlBody(htmlBody));\n    html.append(\"</div>\\n\");\n\n    // Add attachment information - always check for and display attachments\n    final String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        html.append(\"<h3>Attachments</h3>\\n\");\n        html.append(attachmentInfo);\n\n        // Add a status message about attachment inclusion\n        if (request != null && request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n            html.append(\n                    \"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n            html.append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\n                    \"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n    }\n\n    // Show advanced features status if requested\n    assert request != null;\n    if (request.getFileInput().isEmpty()) {\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n        html.append(\n                \"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "34", "src_id": "M361", "code": "\nprivate static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n    try {\n        if (!isValidJakartaMailPart(part)) {\n            log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n            return;\n        }\n\n        Class<?> partClass = part.getClass();\n        Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n        Method getContent = partClass.getMethod(\"getContent\");\n        Method getDisposition = partClass.getMethod(\"getDisposition\");\n        Method getFileName = partClass.getMethod(\"getFileName\");\n        Method getContentType = partClass.getMethod(\"getContentType\");\n        Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n        Object disposition = getDisposition.invoke(part);\n        String filename = (String) getFileName.invoke(part);\n        String contentType = (String) getContentType.invoke(part);\n\n        boolean textPlain = (Boolean) isMimeType.invoke(part, \"text/plain\");\n        boolean textHtml = (Boolean) isMimeType.invoke(part, \"text/html\");\n        boolean multipart = (Boolean) isMimeType.invoke(part, \"multipart/*\");\n\n        if (textPlain && disposition == null) {\n            content.setTextBody((String) getContent.invoke(part));\n            return;\n        }\n\n        if (textHtml && disposition == null) {\n            content.setHtmlBody((String) getContent.invoke(part));\n            return;\n        }\n\n        boolean hasFilename = filename != null && !filename.trim().isEmpty();\n        boolean isAttachment = \"attachment\".equalsIgnoreCase((String) disposition) || hasFilename;\n\n        if (isAttachment) {\n            content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n            if (hasFilename) {\n                EmailAttachment attachment = new EmailAttachment();\n                attachment.setFilename(safeMimeDecode(filename));\n                attachment.setContentType(contentType);\n\n                String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n                if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                    attachment.setEmbedded(true);\n                    String contentId = contentIdHeaders[0];\n                    if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                        contentId = contentId.substring(1, contentId.length() - 1);\n                    }\n                    attachment.setContentId(contentId);\n                }\n\n                if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n                    try {\n                        Object attachmentContent = getContent.invoke(part);\n                        byte[] attachmentData = null;\n\n                        if (attachmentContent instanceof java.io.InputStream in) {\n                            try {\n                                attachmentData = in.readAllBytes();\n                            } catch (IOException e) {\n                                log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n                            }\n                        } else if (attachmentContent instanceof byte[] bytes) {\n                            attachmentData = bytes;\n                        } else if (attachmentContent instanceof String str) {\n                            attachmentData = str.getBytes(StandardCharsets.UTF_8);\n                        }\n\n                        if (attachmentData != null) {\n                            long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                            long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                            if (attachmentData.length <= maxSizeBytes) {\n                                attachment.setData(attachmentData);\n                                attachment.setSizeBytes(attachmentData.length);\n                            } else {\n                                if (attachment.isEmbedded()) {\n                                    attachment.setData(attachmentData);\n                                    attachment.setSizeBytes(attachmentData.length);\n                                } else {\n                                    attachment.setSizeBytes(attachmentData.length);\n                                }\n                            }\n                        }\n                    } catch (Exception e) {\n                        log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n                    }\n                }\n\n                content.getAttachments().add(attachment);\n            }\n            return;\n        }\n\n        if (multipart) {\n            try {\n                Object multipartContent = getContent.invoke(part);\n                Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(multipartContent)) {\n                    processMultipartAdvanced(multipartContent, content, request);\n                }\n            } catch (Exception e) {\n                log.warn(\"Error processing multipart content: {}\", e.getMessage());\n            }\n        }\n    } catch (Exception e) {\n        log.warn(\"Error processing multipart part: {}\", e.getMessage());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "35", "src_id": "M362", "code": "\nprivate static String generateEnhancedEmailHtml(EmailContent content, EmlToPdfRequest request) {\n    StringBuilder html = new StringBuilder();\n\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(content.getSubject())).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(content.getSubject())).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \")\n            .append(escapeHtml(content.getFrom()))\n            .append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \")\n            .append(escapeHtml(content.getTo()))\n            .append(\"</div>\\n\");\n\n    if (content.getDate() != null) {\n        html.append(\"<div><strong>Date:</strong> \")\n                .append(formatEmailDate(content.getDate()))\n                .append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n\n    String htmlBody = content.getHtmlBody();\n    String textBody = content.getTextBody();\n\n    if (htmlBody != null && !htmlBody.trim().isEmpty()) {\n        html.append(processEmailHtmlBody(htmlBody, content));\n    } else if (textBody != null && !textBody.trim().isEmpty()) {\n        html.append(\"<div class=\\\"text-body\\\">\");\n        html.append(convertTextToHtml(textBody));\n        html.append(\"</div>\");\n    } else {\n        html.append(\"<div class=\\\"no-content\\\">\");\n        html.append(\"<p><em>No content available</em></p>\");\n        html.append(\"</div>\");\n    }\n    html.append(\"</div>\\n\");\n\n    if (content.getAttachmentCount() > 0 || !content.getAttachments().isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n\n        int displayedAttachmentCount = content.getAttachmentCount() > 0\n                ? content.getAttachmentCount()\n                : content.getAttachments().size();\n\n        html.append(\"<h3>Attachments (\").append(displayedAttachmentCount).append(\")</h3>\\n\");\n\n        if (!content.getAttachments().isEmpty()) {\n            for (EmailAttachment attachment : content.getAttachments()) {\n                String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n                attachment.setEmbeddedFilename(\n                        attachment.getEmbeddedFilename() != null\n                                ? attachment.getEmbeddedFilename()\n                                : attachment.getFilename()\n                );\n\n                html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\")\n                        .append(uniqueId)\n                        .append(\"\\\">\")\n                        .append(\"<span class=\\\"attachment-icon\\\">\")\n                        .append(MimeConstants.ATTACHMENT_MARKER)\n                        .append(\"</span> \")\n                        .append(\"<span class=\\\"attachment-name\\\">\")\n                        .append(escapeHtml(safeMimeDecode(attachment.getFilename())))\n                        .append(\"</span>\");\n\n                String sizeStr = formatFileSize(attachment.getSizeBytes());\n                html.append(\" <span class=\\\"attachment-details\\\">(\").append(sizeStr);\n                if (attachment.getContentType() != null && !attachment.getContentType().isEmpty()) {\n                    html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                }\n                html.append(\")</span></div>\\n\");\n            }\n        }\n\n        if (request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\"<p><em>Attachments are embedded in the file.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "36", "src_id": "M367", "code": "\nprivate static String decodeMimeHeader(String encodedText) {\n    if (encodedText == null || encodedText.trim().isEmpty()) {\n        return encodedText;\n    }\n\n    try {\n        StringBuilder result = new StringBuilder();\n        Matcher matcher = MimeConstants.MIME_ENCODED_PATTERN.matcher(encodedText);\n        int lastEnd = 0;\n\n        while (matcher.find()) {\n            result.append(encodedText, lastEnd, matcher.start());\n\n            String charset = matcher.group(1);\n            String encoding = matcher.group(2).toUpperCase();\n            String encodedValue = matcher.group(3);\n\n            try {\n                String decodedValue;\n                if (\"B\".equals(encoding)) {\n                    byte[] decodedBytes = Base64.getDecoder().decode(encodedValue);\n                    decodedValue = new String(decodedBytes, Charset.forName(charset));\n                } else if (\"Q\".equals(encoding)) {\n                    decodedValue = decodeQuotedPrintable(encodedValue, charset);\n                } else {\n                    decodedValue = matcher.group(0);\n                }\n                result.append(decodedValue);\n            } catch (Exception e) {\n                log.warn(\"Failed to decode MIME header part: {}\", matcher.group(0), e);\n                result.append(matcher.group(0));\n            }\n\n            lastEnd = matcher.end();\n        }\n\n        result.append(encodedText.substring(lastEnd));\n        return result.toString();\n    } catch (Exception e) {\n        log.warn(\"Error decoding MIME header: {}\", encodedText, e);\n        return encodedText;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "37", "src_id": "M509", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n@Operation(\n        summary = \"Convert EML to PDF\",\n        description = \"This endpoint converts EML (email) files to PDF format with extensive\"\n                + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n                + \" and HTML debug output. Input: EML file, Output: PDF\"\n                + \" or HTML file. Type: SISO\")\npublic ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n\n    MultipartFile inputFile = request.getFileInput();\n    String originalFilename = inputFile.getOriginalFilename();\n\n    if (inputFile.isEmpty()) {\n        log.error(\"No file provided for EML to PDF conversion.\");\n        return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    if (originalFilename == null || originalFilename.trim().isEmpty()) {\n        log.error(\"Filename is null or empty.\");\n        return ResponseEntity.badRequest()\n                .body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    String lowerFilename = originalFilename.toLowerCase();\n    if (!lowerFilename.endsWith(\".eml\")) {\n        log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n        return ResponseEntity.badRequest()\n                .body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    String baseFilename = Filenames.toSimpleFileName(originalFilename);\n\n    try {\n        byte[] fileBytes = inputFile.getBytes();\n\n        if (request.isDownloadHtml()) {\n            try {\n                String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(\n                        htmlContent.getBytes(StandardCharsets.UTF_8),\n                        baseFilename + \".html\",\n                        MediaType.TEXT_HTML\n                );\n            } catch (IOException | IllegalArgumentException e) {\n                log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        try {\n            byte[] pdfBytes = EmlToPdf.convertEmlToPdf(\n                    runtimePathConfig.getWeasyPrintPath(),\n                    request,\n                    fileBytes,\n                    originalFilename,\n                    false,\n                    pdfDocumentFactory,\n                    tempFileManager\n            );\n\n            if (pdfBytes == null || pdfBytes.length == 0) {\n                log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n            }\n\n            log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n            return WebResponseUtils.bytesToWebResponse(\n                    pdfBytes,\n                    baseFilename + \".pdf\",\n                    MediaType.APPLICATION_PDF\n            );\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n        } catch (IllegalArgumentException e) {\n            String errorMessage = buildErrorMessage(e, originalFilename);\n            log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        } catch (RuntimeException e) {\n            String errorMessage = buildErrorMessage(e, originalFilename);\n            log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        }\n    } catch (IOException e) {\n        log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "38", "src_id": "M1294", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (definition != null) {\n            definition.addParams(args);\n        }\n\n        if ((flags & USE_TERM_OFFSETS) == 0) {\n            args.add(SearchKeyword.NOOFFSETS.name());\n        }\n        if ((flags & KEEP_FIELD_FLAGS) == 0) {\n            args.add(SearchKeyword.NOFIELDS.name());\n        }\n        if ((flags & KEEP_TERM_FREQUENCIES) == 0) {\n            args.add(SearchKeyword.NOFREQS.name());\n        }\n        if (expire > 0) {\n            args.add(SearchKeyword.TEMPORARY.name());\n            args.add(Long.toString(this.expire));\n        }\n\n        if (stopwords != null) {\n            args.add(SearchKeyword.STOPWORDS.name());\n            args.add(Integer.toString(stopwords.size()));\n            if (!stopwords.isEmpty()) {\n                args.addObjects(stopwords);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "39", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "40", "src_id": "M933", "code": "\n    @Deprecated\n    public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n        Builder builder = builder();\n        builder.protocol(copy.getRedisProtocol());\n        builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n        builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n        builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n        Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n        if (credentialsProvider != null) {\n            builder.credentialsProvider(credentialsProvider);\n        } else {\n            builder.user(copy.getUser());\n            builder.password(copy.getPassword());\n        }\n\n        builder.database(copy.getDatabase());\n        builder.clientName(copy.getClientName());\n\n        builder.ssl(copy.isSsl());\n        builder.sslSocketFactory(copy.getSslSocketFactory());\n        builder.sslParameters(copy.getSslParameters());\n        builder.hostnameVerifier(copy.getHostnameVerifier());\n        builder.sslOptions(copy.getSslOptions());\n        builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n        builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n        if (copy.isReadOnlyForRedisClusterReplicas()) {\n            builder.readOnlyForRedisClusterReplicas();\n        }\n\n        builder.authXManager(copy.getAuthXManager());\n\n        return builder.build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "41", "src_id": "M913", "code": "\n    @Override\n    public Map<String, TSMRangeElements> build(Object data) {\n        List<KeyValue> dataList = (List<KeyValue>) data;\n        Map<String, TSMRangeElements> map = new LinkedHashMap<>(dataList.size() / 2, 1f);\n\n        for (KeyValue kv : dataList) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            List<Object> valueList = (List<Object>) kv.getValue();\n            TSMRangeElements elements;\n\n            switch (valueList.size()) {\n                case 3:\n                    List<Object> aggrMapObj = (List<Object>) valueList.get(1);\n                    KeyValue aggKV = (KeyValue) aggrMapObj.get(0);\n                    assert \"aggregators\".equalsIgnoreCase(BuilderFactory.STRING.build(aggKV.getKey()));\n                    elements =\n                            new TSMRangeElements(\n                                    key,\n                                    BuilderFactory.STRING_MAP.build(valueList.get(0)),\n                                    ((List<Object>) aggKV.getValue()).stream()\n                                            .map(BuilderFactory.STRING::build)\n                                            .map(AggregationType::safeValueOf)\n                                            .collect(Collectors.toList()),\n                                    TIMESERIES_ELEMENT_LIST.build(valueList.get(2)));\n                    break;\n                case 4:\n                    List<KeyValue> rdcMapObj = (List<KeyValue>) valueList.get(1);\n                    assert \"reducers\"\n                            .equalsIgnoreCase(BuilderFactory.STRING.build(rdcMapObj.get(0).getKey()));\n                    List<KeyValue> srcMapObj = (List<KeyValue>) valueList.get(2);\n                    assert \"sources\"\n                            .equalsIgnoreCase(BuilderFactory.STRING.build(srcMapObj.get(0).getKey()));\n                    elements =\n                            new TSMRangeElements(\n                                    key,\n                                    BuilderFactory.STRING_MAP.build(valueList.get(0)),\n                                    BuilderFactory.STRING_LIST.build(rdcMapObj.get(0).getValue()),\n                                    BuilderFactory.STRING_LIST.build(srcMapObj.get(0).getValue()),\n                                    TIMESERIES_ELEMENT_LIST.build(valueList.get(3)));\n                    break;\n                default:\n                    throw new IllegalStateException();\n            }\n\n            map.put(key, elements);\n        }\n\n        return map;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1146", "code": "\n    private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n        JedisRedirectionException redirect = null;\n        int consecutiveConnectionFailures = 0;\n        Exception lastException = null;\n\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n            Connection connection = null;\n            try {\n                if (redirect != null) {\n                    connection = provider.getConnection(redirect.getTargetNode());\n                    if (redirect instanceof JedisAskDataException) {\n                        // TODO: Pipeline asking with the original command to make it faster....\n                        connection.executeCommand(Protocol.Command.ASKING);\n                    }\n                } else {\n                    connection =\n                            toReplica\n                                    ? provider.getReplicaConnection(commandObject.getArguments())\n                                    : provider.getConnection(commandObject.getArguments());\n                }\n\n                return execute(connection, commandObject);\n\n            } catch (JedisClusterOperationException jnrcne) {\n                throw jnrcne;\n\n            } catch (JedisConnectionException jce) {\n                lastException = jce;\n                ++consecutiveConnectionFailures;\n                log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n\n                // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                boolean reset =\n                        handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n                if (reset) {\n                    consecutiveConnectionFailures = 0;\n                    redirect = null;\n                }\n\n            } catch (JedisRedirectionException jre) {\n                // avoid updating lastException if it is a connection exception\n                if (lastException == null || lastException instanceof JedisRedirectionException) {\n                    lastException = jre;\n                }\n                log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n                consecutiveConnectionFailures = 0;\n                redirect = jre;\n\n                // if MOVED redirection occurred,\n                if (jre instanceof JedisMovedDataException) {\n                    // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                    provider.renewSlotCache(connection);\n                }\n\n            } finally {\n                IOUtils.closeQuietly(connection);\n            }\n\n            if (Instant.now().isAfter(deadline)) {\n                throw new JedisClusterOperationException(\n                        \"Cluster retry deadline exceeded.\", lastException);\n            }\n        }\n\n        JedisClusterOperationException maxAttemptsException =\n                new JedisClusterOperationException(\"No more cluster attempts left.\");\n        maxAttemptsException.addSuppressed(lastException);\n        throw maxAttemptsException;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "43", "src_id": "M55", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, Long> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "44", "src_id": "M52", "code": "\n    @Override\n    public Map<String, Object> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, Object> map = new HashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<String, Object> map = new HashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1213", "code": "\n    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n\n                jedis.ping();\n                return jedis;\n\n            } catch (JedisException ex) {\n                if (suppressed == null) {\n                    // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "46", "src_id": "M1131", "code": "\n    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE: // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n            // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "47", "src_id": "M1298", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (type != null) {\n            args.add(SearchKeyword.ON.name());\n            args.add(type.name());\n        }\n\n        if (prefixes != null && prefixes.length > 0) {\n            args.add(SearchKeyword.PREFIX.name());\n            args.add(Integer.toString(prefixes.length));\n            args.addObjects((Object[]) prefixes);\n        }\n\n        if (filter != null) {\n            args.add(SearchKeyword.FILTER.name());\n            args.add(filter);\n        }\n\n        if (languageField != null) {\n            args.add(SearchKeyword.LANGUAGE_FIELD.name());\n            args.add(languageField);\n        }\n\n        if (language != null) {\n            args.add(SearchKeyword.LANGUAGE.name());\n            args.add(language);\n        }\n\n        if (scoreFiled != null) {\n            args.add(SearchKeyword.SCORE_FIELD.name());\n            args.add(scoreFiled);\n        }\n\n        if (score != 1.0) {\n            args.add(SearchKeyword.SCORE.name());\n            args.add(Double.toString(score));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "48", "src_id": "M8", "code": "\nprivate static String formatFileSize(long size) {\n    final double b = size;\n    final double k = size / 1024.0;\n    final double m = size / 1024.0 / 1024.0;\n    final double g = size / 1024.0 / 1024.0 / 1024.0;\n    final double t = size / 1024.0 / 1024.0 / 1024.0 / 1024.0;\n\n    final DecimalFormat dec = new DecimalFormat(\"0.00\");\n\n    if (t > 1) {\n        return dec.format(t).concat(\" TB\");\n    }\n    if (g > 1) {\n        return dec.format(g).concat(\" GB\");\n    }\n    if (m > 1) {\n        return dec.format(m).concat(\" MB\");\n    }\n    if (k > 1) {\n        return dec.format(k).concat(\" KB\");\n    }\n    return dec.format(b).concat(\" Bytes\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "49", "src_id": "M357", "code": "\nprivate static Class<?>[] parseTypes(String desc, ClassLoader loader) throws ClassNotFoundException {\n    final int lparen = desc.indexOf('(');\n    final int rparen = desc.indexOf(')', lparen);\n\n    final List<String> params = new ArrayList<>();\n    int start = lparen + 1;\n\n    for (;;) {\n        final int comma = desc.indexOf(',', start);\n        if (comma < 0) {\n            break;\n        }\n        params.add(desc.substring(start, comma).trim());\n        start = comma + 1;\n    }\n\n    if (start < rparen) {\n        params.add(desc.substring(start, rparen).trim());\n    }\n\n    final Class<?>[] types = new Class<?>[params.size()];\n    for (int i = 0; i < types.length; i++) {\n        types[i] = getClass(params.get(i), loader);\n    }\n    return types;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "50", "src_id": "M566", "code": "\n@Override\npublic void process(final CommandProcess process) {\n    final Session session = process.session();\n    timer = new Timer(\"Timer-for-arthas-dashboard-\" + session.getSessionId(), true);\n\n    // ctrl-C support\n    process.interruptHandler(new DashboardInterruptHandler(process, timer));\n\n    /*\n     * 通过handle回调，在suspend和end时停止timer，resume时重启timer\n     */\n    Handler<Void> stopHandler = new Handler<Void>() {\n        @Override\n        public void handle(Void event) {\n            stop();\n        }\n    };\n\n    Handler<Void> restartHandler = new Handler<Void>() {\n        @Override\n        public void handle(Void event) {\n            restart(process);\n        }\n    };\n\n    process.suspendHandler(stopHandler);\n    process.resumeHandler(restartHandler);\n    process.endHandler(stopHandler);\n\n    // q exit support\n    process.stdinHandler(new QExitHandler(process));\n\n    // start the timer\n    timer.scheduleAtFixedRate(new DashboardTimerTask(process), 0, getInterval());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "51", "src_id": "M114", "code": "\npublic boolean isAvailable() {\n    if (!isConnected()) {\n        return false;\n    }\n\n    try {\n        if (_socket_.getInetAddress() == null) {\n            return false;\n        }\n        if (_socket_.getPort() == 0) {\n            return false;\n        }\n        if (_socket_.getRemoteSocketAddress() == null) {\n            return false;\n        }\n        if (_socket_.isClosed()) {\n            return false;\n        }\n        // these aren't exact checks (a Socket can be half-open),\n        // but since we usually require two-way data transfer,\n        // we check these here too:\n        if (_socket_.isInputShutdown()) {\n            return false;\n        }\n        if (_socket_.isOutputShutdown()) {\n            return false;\n        }\n        // ignore the result, catch exceptions:\n        _socket_.getInputStream();\n        _socket_.getOutputStream();\n    } catch (IOException ioex) {\n        return false;\n    }\n\n    return true;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "52", "src_id": "M232", "code": "\npublic void start() throws Exception {\n    // Configure SSL.\n    final SslContext sslCtx;\n    if (ssl) {\n        final SelfSignedCertificate ssc = new SelfSignedCertificate();\n        sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n    } else {\n        sslCtx = null;\n    }\n\n    ServerBootstrap b = new ServerBootstrap();\n    b.group(bossGroup, workerGroup)\n     .channel(NioServerSocketChannel.class)\n     .handler(new LoggingHandler(LogLevel.INFO))\n     .childHandler(new TunnelSocketServerInitializer(this, sslCtx));\n\n    if (StringUtils.isBlank(host)) {\n        channel = b.bind(port).sync().channel();\n    } else {\n        channel = b.bind(host, port).sync().channel();\n    }\n\n    logger.info(\"Tunnel server listen at {}:{}\", host, port);\n\n    workerGroup.scheduleWithFixedDelay(new Runnable() {\n        @Override\n        public void run() {\n            agentInfoMap.entrySet().removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n            clientConnectionInfoMap.entrySet()\n                    .removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n\n            // 更新集群key信息\n            if (tunnelClusterStore != null && clientConnectHost != null) {\n                try {\n                    for (Entry<String, AgentInfo> entry : agentInfoMap.entrySet()) {\n                        tunnelClusterStore.addAgent(\n                                entry.getKey(),\n                                new AgentClusterInfo(entry.getValue(), clientConnectHost, port),\n                                60 * 60,\n                                TimeUnit.SECONDS\n                        );\n                    }\n                } catch (Throwable t) {\n                    logger.error(\"update tunnel info error\", t);\n                }\n            }\n        }\n    }, 60, 60, TimeUnit.SECONDS);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "53", "src_id": "M65", "code": "\npublic Map<String, Class<?>> build() {\n    errors.clear();\n    warnings.clear();\n\n    JavaFileManager fileManager = new DynamicJavaFileManager(standardFileManager, dynamicClassLoader);\n\n    DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<>();\n    JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, collector, options, null, compilationUnits);\n\n    try {\n        if (!compilationUnits.isEmpty()) {\n            boolean result = task.call();\n\n            if (!result || collector.getDiagnostics().size() > 0) {\n                for (Diagnostic<? extends JavaFileObject> diagnostic : collector.getDiagnostics()) {\n                    switch (diagnostic.getKind()) {\n                    case NOTE:\n                    case MANDATORY_WARNING:\n                    case WARNING:\n                        warnings.add(diagnostic);\n                        break;\n                    case OTHER:\n                    case ERROR:\n                    default:\n                        errors.add(diagnostic);\n                        break;\n                    }\n                }\n\n                if (!errors.isEmpty()) {\n                    throw new DynamicCompilerException(\"Compilation Error\", errors);\n                }\n            }\n        }\n\n        return dynamicClassLoader.getClasses();\n    } catch (Throwable e) {\n        throw new DynamicCompilerException(e, errors);\n    } finally {\n        compilationUnits.clear();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "54", "src_id": "M183", "code": "\npublic SimpleHttpResponse query(String targetUrl) throws InterruptedException {\n    final Promise<SimpleHttpResponse> httpResponsePromise = GlobalEventExecutor.INSTANCE.newPromise();\n\n    final EventLoopGroup group = new NioEventLoopGroup(1, new DefaultThreadFactory(\"arthas-ProxyClient\", true));\n    ChannelFuture closeFuture = null;\n\n    try {\n        Bootstrap b = new Bootstrap();\n        b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n        b.group(group)\n         .channel(LocalChannel.class)\n         .handler(new ChannelInitializer<LocalChannel>() {\n             @Override\n             protected void initChannel(LocalChannel ch) {\n                 ChannelPipeline p = ch.pipeline();\n                 p.addLast(\n                         new HttpClientCodec(),\n                         new HttpObjectAggregator(ArthasConstants.MAX_HTTP_CONTENT_LENGTH),\n                         new HttpProxyClientHandler(httpResponsePromise)\n                 );\n             }\n         });\n\n        LocalAddress localAddress = new LocalAddress(ArthasConstants.NETTY_LOCAL_ADDRESS);\n        Channel localChannel = b.connect(localAddress).sync().channel();\n\n        // Prepare the HTTP request.\n        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, targetUrl, Unpooled.EMPTY_BUFFER);\n        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n\n        localChannel.writeAndFlush(request);\n\n        closeFuture = localChannel.closeFuture();\n        logger.info(\"proxy client connect to server success, targetUrl: \" + targetUrl);\n\n        return httpResponsePromise.get(5000, TimeUnit.MILLISECONDS);\n    } catch (Throwable e) {\n        logger.error(\"ProxyClient error, targetUrl: {}\", targetUrl, e);\n    } finally {\n        if (closeFuture != null) {\n            closeFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture channelFuture) throws Exception {\n                    group.shutdownGracefully();\n                }\n            });\n        } else {\n            group.shutdownGracefully();\n        }\n    }\n\n    SimpleHttpResponse httpResponse = new SimpleHttpResponse();\n    try {\n        httpResponse.setContent(\"error\".getBytes(\"utf-8\"));\n    } catch (UnsupportedEncodingException e) {\n        // ignore\n    }\n    return httpResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "55", "src_id": "M131", "code": "\n@Override\npublic void write(int ch) throws IOException {\n    synchronized (__client) {\n        ch &= 0xff;\n\n        if (__client._requestedWont(TelnetOption.BINARY)) { // i.e. ASCII\n            if (__lastWasCR) {\n                if (__convertCRtoCRLF) {\n                    __client._sendByte('\\n');\n                    if (ch == '\\n') { // i.e. was CRLF anyway\n                        __lastWasCR = false;\n                        return;\n                    }\n                } else if (ch != '\\n') {\n                    __client._sendByte('\\0'); // RFC854 requires CR NUL for bare CR\n                }\n            }\n\n            switch (ch) {\n            case '\\r':\n                __client._sendByte('\\r');\n                __lastWasCR = true;\n                break;\n            case '\\n':\n                if (!__lastWasCR) { // convert LF to CRLF\n                    __client._sendByte('\\r');\n                }\n                __client._sendByte(ch);\n                __lastWasCR = false;\n                break;\n            case TelnetCommand.IAC:\n                __client._sendByte(TelnetCommand.IAC);\n                __client._sendByte(TelnetCommand.IAC);\n                __lastWasCR = false;\n                break;\n            default:\n                __client._sendByte(ch);\n                __lastWasCR = false;\n                break;\n            }\n        } else if (ch == TelnetCommand.IAC) {\n            __client._sendByte(ch);\n            __client._sendByte(TelnetCommand.IAC);\n        } else {\n            __client._sendByte(ch);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "56", "src_id": "M443", "code": "\nprivate String drawField() {\n    final StringBuilder fieldSB = new StringBuilder();\n\n    final Field[] fields = clazz.getDeclaredFields();\n    if (fields.length > 0) {\n        for (Field field : fields) {\n            final KVView kvView = new KVView(\n                    new TableView.ColumnDefine(TableView.Align.RIGHT),\n                    new TableView.ColumnDefine(50, false, TableView.Align.LEFT)\n            )\n            .add(\"modifier\", StringUtils.modifier(field.getModifiers(), ','))\n            .add(\"type\", StringUtils.classname(field.getType()))\n            .add(\"name\", field.getName());\n\n            final StringBuilder annotationSB = new StringBuilder();\n            final Annotation[] annotationArray = field.getAnnotations();\n            if (annotationArray != null && annotationArray.length > 0) {\n                for (Annotation annotation : annotationArray) {\n                    annotationSB.append(StringUtils.classname(annotation.annotationType())).append(\",\");\n                }\n                if (annotationSB.length() > 0) {\n                    annotationSB.deleteCharAt(annotationSB.length() - 1);\n                }\n                kvView.add(\"annotation\", annotationSB);\n            }\n\n            if (Modifier.isStatic(field.getModifiers())) {\n                final boolean isAccessible = field.isAccessible();\n                try {\n                    field.setAccessible(true);\n                    kvView.add(\"value\", StringUtils.objectToString(field.get(null)));\n                } catch (IllegalAccessException e) {\n                    // ignore\n                } finally {\n                    field.setAccessible(isAccessible);\n                }\n            }\n\n            fieldSB.append(kvView.draw()).append(\"\\n\");\n        }\n    }\n\n    return fieldSB.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "57", "src_id": "M1439", "code": "\npublic static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete) {\n    if (ObjectUtils.isEmpty(array)) {\n        return null;\n    }\n\n    Properties result = new Properties();\n    for (String element : array) {\n        if (charsToDelete != null) {\n            element = deleteAny(element, charsToDelete);\n        }\n\n        String[] splittedElement = split(element, delimiter);\n        if (splittedElement != null) {\n            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n        }\n    }\n\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "58", "src_id": "M47", "code": "\nprivate static long findProcessByTelnetClient(String arthasHomeDir, int telnetPort) {\n    // Start java telnet client\n    List<String> telnetArgs = new ArrayList<>();\n    telnetArgs.add(\"-c\");\n    telnetArgs.add(\"session\");\n    telnetArgs.add(\"--execution-timeout\");\n    telnetArgs.add(\"2000\");\n    // Telnet port, ip\n    telnetArgs.add(\"127.0.0.1\");\n    telnetArgs.add(\"\" + telnetPort);\n\n    try {\n        ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n        String error = null;\n        int status = ProcessUtils.startArthasClient(arthasHomeDir, telnetArgs, out);\n        if (status == STATUS_EXEC_TIMEOUT) {\n            error = \"detection timeout\";\n        } else if (status == STATUS_EXEC_ERROR) {\n            error = \"detection error\";\n            AnsiLog.error(\"process status: {}\", status);\n            AnsiLog.error(\"process output: {}\", out.toString());\n        } else {\n            // Ignore connect error\n        }\n\n        if (error != null) {\n            AnsiLog.error(\"The telnet port {} is used, but process {}, you will connect to an unexpected process.\", telnetPort, error);\n            AnsiLog.error(\"Try to use a different telnet port, for example: java -jar arthas-boot.jar --telnet-port 9998 --http-port -1\");\n            System.exit(1);\n        }\n\n        // Parse output, find java pid\n        String output = out.toString(\"UTF-8\");\n        String javaPidLine = null;\n        Scanner scanner = new Scanner(output);\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.contains(\"JAVA_PID\")) {\n                javaPidLine = line;\n                break;\n            }\n        }\n        if (javaPidLine != null) {\n            // JAVA_PID    10473\n            try {\n                String[] strs = javaPidLine.split(\"JAVA_PID\");\n                if (strs.length > 1) {\n                    return Long.parseLong(strs[strs.length - 1].trim());\n                }\n            } catch (NumberFormatException e) {\n                // Ignore\n            }\n        }\n    } catch (Throwable e) {\n        AnsiLog.error(\"Detection telnet port error\");\n        AnsiLog.error(e);\n    }\n\n    return -1;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "59", "src_id": "M475", "code": "\n@Override\npublic void draw(CommandProcess process, JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n        String group = entry.getKey();\n        List<JvmItemVO> items = entry.getValue();\n\n        table.row(true, label(group).style(Decoration.bold.bold()));\n        for (JvmItemVO item : items) {\n            String valueStr;\n            if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                valueStr = renderMemoryUsage((Map<String, Object>) item.getValue());\n            } else {\n                valueStr = renderItemValue(item.getValue());\n            }\n\n            if (item.getDesc() != null) {\n                table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n            } else {\n                table.row(item.getName(), valueStr);\n            }\n        }\n        table.row(\"\", \"\");\n    }\n\n    process.write(RenderUtil.render(table, process.width()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "60", "src_id": "M1131", "code": "\nprivate ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<>();\n    body.put(\"command\", commandLine);\n\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId())\n            .setBody(body);\n\n    if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED)\n                .setMessage(\"Another command is executing.\");\n        return response;\n    }\n\n    int lock = session.getLock();\n    try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n            response.setState(ApiState.REFUSED)\n                    .setMessage(\"Another job is running.\");\n            logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n            return response;\n        }\n\n        // Create job\n        Job job = this.createJob(commandLine, session, session.getResultDistributor());\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        response.setState(ApiState.SCHEDULED);\n\n        // Add command before exec job\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n        commandRequestModel.setJobId(job.id());\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) {\n            resultDistributor.appendResult(commandRequestModel);\n        }\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n        // Run job\n        job.run();\n\n        return response;\n    } catch (Throwable e) {\n        logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n        session.getResultDistributor().appendResult(commandRequestModel);\n        return response;\n    } finally {\n        if (session.getLock() == lock) {\n            session.unLock();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "61", "src_id": "M493", "code": "\nprivate void renderNode(StringBuilder sb, TraceNode node, Ansi highlighted) {\n    // Render cost: [0.366865ms]\n    if (isPrintCost && node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode) node;\n\n        String costStr = renderCost(methodNode);\n        if (node == maxCostNode) {\n            // The node with max cost will be highlighted\n            sb.append(highlighted.a(costStr).reset().toString());\n        } else {\n            sb.append(costStr);\n        }\n    }\n\n    // Render method name\n    if (node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode) node;\n        // clazz.getName() + \":\" + method.getName() + \"()\"\n        sb.append(methodNode.getClassName()).append(\":\").append(methodNode.getMethodName()).append(\"()\");\n        // #lineNumber\n        if (methodNode.getLineNumber() != -1) {\n            sb.append(\" #\").append(methodNode.getLineNumber());\n        }\n    } else if (node instanceof ThreadNode) {\n        // Render thread info\n        ThreadNode threadNode = (ThreadNode) node;\n        // ts=2020-04-29 10:34:00;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@18b4aac2\n        sb.append(format(\"ts=%s;thread_name=%s;id=%d;is_daemon=%s;priority=%d;TCCL=%s\",\n                DateUtils.formatDateTime(threadNode.getTimestamp()),\n                threadNode.getThreadName(),\n                threadNode.getThreadId(),\n                threadNode.isDaemon(),\n                threadNode.getPriority(),\n                threadNode.getClassloader()));\n\n        // trace_id\n        if (threadNode.getTraceId() != null) {\n            sb.append(\";trace_id=\").append(threadNode.getTraceId());\n        }\n        if (threadNode.getRpcId() != null) {\n            sb.append(\";rpc_id=\").append(threadNode.getRpcId());\n        }\n    } else if (node instanceof ThrowNode) {\n        ThrowNode throwNode = (ThrowNode) node;\n        sb.append(\"throw:\").append(throwNode.getException())\n                .append(\" #\").append(throwNode.getLineNumber())\n                .append(\" [\").append(throwNode.getMessage()).append(\"]\");\n    } else {\n        throw new UnsupportedOperationException(\"unknown trace node: \" + node.getClass());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "62", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoader)))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.level)));\n\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.additivity)))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                                label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                appendersTable.row(label(LoggerHelper.classLoaderHash),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "63", "src_id": "M529", "code": "\n@Override\npublic void draw(CommandProcess process, MonitorModel result) {\n    TableElement table = new TableElement(2, 3, 3, 1, 1, 1, 1, 1).leftCellPadding(1).rightCellPadding(1);\n    table.row(true, label(\"timestamp\").style(Decoration.bold.bold()),\n            label(\"class\").style(Decoration.bold.bold()),\n            label(\"method\").style(Decoration.bold.bold()),\n            label(\"total\").style(Decoration.bold.bold()),\n            label(\"success\").style(Decoration.bold.bold()),\n            label(\"fail\").style(Decoration.bold.bold()),\n            label(\"avg-rt(ms)\").style(Decoration.bold.bold()),\n            label(\"fail-rate\").style(Decoration.bold.bold()));\n\n    final DecimalFormat df = new DecimalFormat(\"0.00\");\n\n    for (MonitorData data : result.getMonitorDataList()) {\n        table.row(\n                DateUtils.formatDateTime(data.getTimestamp()),\n                data.getClassName(),\n                data.getMethodName(),\n                \"\" + data.getTotal(),\n                \"\" + data.getSuccess(),\n                \"\" + data.getFailed(),\n                df.format(div(data.getCost(), data.getTotal())),\n                df.format(100.0d * div(data.getFailed(), data.getTotal())) + \"%\"\n        );\n    }\n\n    process.write(RenderUtil.render(table, process.width()) + \"\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "64", "src_id": "M381", "code": "\n@Override\npublic List<ResultModel> pollResults() {\n    try {\n        lastAccessTime = System.currentTimeMillis();\n        long accessTime = lastAccessTime;\n\n        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n            polling = true;\n            sendingItemCount = 0;\n            long firstResultTime = 0;\n            // Sending delay: time elapsed after firstResultTime\n            long sendingDelay = 0;\n            // Waiting time: time elapsed after access\n            long waitingTime = 0;\n            List<ResultModel> sendingResults = new ArrayList<>(resultBatchSizeLimit);\n\n            while (!closed\n                    && sendingResults.size() < resultBatchSizeLimit\n                    && sendingDelay < 100\n                    && waitingTime < pollTimeLimit) {\n                ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                if (aResult != null) {\n                    sendingResults.add(aResult);\n                    // Whether this is the first retrieved result\n                    if (firstResultTime == 0) {\n                        firstResultTime = System.currentTimeMillis();\n                    }\n                    // Determine whether we should flush immediately\n                    if (shouldFlush(sendingResults, aResult)) {\n                        break;\n                    }\n                } else {\n                    if (firstResultTime > 0) {\n                        // After fetching some data, queue is empty - compute send delay\n                        sendingDelay = System.currentTimeMillis() - firstResultTime;\n                    }\n                    // Compute total waiting time (long-poll max waiting time)\n                    waitingTime = System.currentTimeMillis() - accessTime;\n                }\n            }\n\n            // resultQueue.drainTo(sendingResults, resultSizeLimit - sendingResults.size());\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n            }\n            return sendingResults;\n        }\n    } catch (InterruptedException e) {\n        // e.printStackTrace();\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lastAccessTime = System.currentTimeMillis();\n            polling = false;\n            lock.unlock();\n        }\n    }\n    return Collections.emptyList();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "65", "src_id": "M1199", "code": "\n    private void initializeSlotsCache(Set<HostAndPort> startNodes, JedisClientConfig clientConfig) {\n        if (startNodes.isEmpty()) {\n            throw new JedisClusterOperationException(\"No nodes to initialize cluster slots cache.\");\n        }\n\n        final ArrayList<HostAndPort> startNodeList = new ArrayList<>(startNodes);\n        Collections.shuffle(startNodeList);\n\n        JedisException firstException = null;\n        for (HostAndPort hostAndPort : startNodeList) {\n            try (Connection jedis = new Connection(hostAndPort, clientConfig)) {\n                cache.discoverClusterNodesAndSlots(jedis);\n                return;\n            } catch (JedisException e) {\n                if (firstException == null) firstException = e;\n                // try next nodes\n            }\n        }\n\n        if (System.getProperty(INIT_NO_ERROR_PROPERTY) != null) return;\n\n        JedisClusterOperationException uninitializedException =\n                new JedisClusterOperationException(\"Could not initialize cluster slots cache.\");\n        uninitializedException.addSuppressed(firstException);\n        throw uninitializedException;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "66", "src_id": "M1275", "code": "\n    @Override\n    public Document build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        String id = null;\n        Double score = null;\n        Map<String, Object> fields = null;\n\n        for (KeyValue kv : list) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            switch (key) {\n                case ID_STR:\n                    id = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case SCORE_STR:\n                    score = BuilderFactory.DOUBLE.build(kv.getValue());\n                    break;\n                case FIELDS_STR:\n                    fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                    break;\n                default:\n            }\n        }\n        return new Document(id, score, fields);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "67", "src_id": "M933", "code": "\n    @Deprecated\n    public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n        Builder builder = builder();\n        builder.protocol(copy.getRedisProtocol());\n        builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n        builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n        builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n        Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n        if (credentialsProvider != null) {\n            builder.credentialsProvider(credentialsProvider);\n        } else {\n            builder.user(copy.getUser());\n            builder.password(copy.getPassword());\n        }\n\n        builder.database(copy.getDatabase());\n        builder.clientName(copy.getClientName());\n\n        builder.ssl(copy.isSsl());\n        builder.sslSocketFactory(copy.getSslSocketFactory());\n        builder.sslParameters(copy.getSslParameters());\n        builder.hostnameVerifier(copy.getHostnameVerifier());\n        builder.sslOptions(copy.getSslOptions());\n        builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n        builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n        if (copy.isReadOnlyForRedisClusterReplicas()) builder.readOnlyForRedisClusterReplicas();\n\n        builder.authXManager(copy.getAuthXManager());\n\n        return builder.build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "68", "src_id": "M1159", "code": "\n    @Override\n    public LibraryInfo build(Object data) {\n        if (data == null) return null;\n        List list = (List) data;\n        if (list.isEmpty()) return null;\n\n        if (list.get(0) instanceof KeyValue) {\n            String libname = null, enginename = null, librarycode = null;\n            List<Map<String, Object>> functions = null;\n\n            for (KeyValue kv : (List<KeyValue>) list) {\n                switch (BuilderFactory.STRING.build(kv.getKey())) {\n                    case \"library_name\":\n                        libname = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"engine\":\n                        enginename = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"functions\":\n                        functions = ((List<Object>) kv.getValue())\n                                .stream()\n                                .map(o -> ENCODED_OBJECT_MAP.build(o))\n                                .collect(Collectors.toList());\n                        break;\n                    case \"library_code\":\n                        librarycode = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    default:\n                }\n            }\n            return new LibraryInfo(libname, enginename, functions, librarycode);\n        }\n\n        String libname = STRING.build(list.get(1));\n        String engine = STRING.build(list.get(3));\n        List<Object> rawFunctions = (List<Object>) list.get(5);\n        List<Map<String, Object>> functions = rawFunctions\n                .stream()\n                .map(o -> ENCODED_OBJECT_MAP.build(o))\n                .collect(Collectors.toList());\n        if (list.size() <= 6) {\n            return new LibraryInfo(libname, engine, functions);\n        }\n        String code = STRING.build(list.get(7));\n        return new LibraryInfo(libname, engine, functions, code);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1219", "code": "\n    @Override\n    public void run() {\n        running.set(true);\n\n        while (running.get()) {\n            try {\n                // double check that it is not being shutdown\n                if (!running.get()) break;\n\n                sentinelJedis = new Jedis(node, sentinelClientConfig);\n\n                // code for active refresh\n                List<String> masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n                if (masterAddr == null || masterAddr.size() != 2) {\n                    LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n                } else {\n                    initMaster(toHostAndPort(masterAddr));\n                }\n\n                sentinelJedis.subscribe(new JedisPubSub() {\n                    @Override\n                    public void onMessage(String channel, String message) {\n                        LOG.debug(\"Sentinel {} published: {}.\", node, message);\n\n                        String[] switchMasterMsg = message.split(\" \");\n\n                        if (switchMasterMsg.length > 3) {\n                            if (masterName.equals(switchMasterMsg[0])) {\n                                initMaster(toHostAndPort(switchMasterMsg[3], switchMasterMsg[4]));\n                            } else {\n                                LOG.debug(\n                                        \"Ignoring message on +switch-master for master {}. Our master is {}.\",\n                                        switchMasterMsg[0], masterName);\n                            }\n                        } else {\n                            LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\",\n                                    node, message);\n                        }\n                    }\n                }, \"+switch-master\");\n\n            } catch (JedisException e) {\n                if (running.get()) {\n                    LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node,\n                            subscribeRetryWaitTimeMillis, e);\n                    try {\n                        Thread.sleep(subscribeRetryWaitTimeMillis);\n                    } catch (InterruptedException se) {\n                        LOG.error(\"Sleep interrupted.\", se);\n                    }\n                } else {\n                    LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n                }\n            } finally {\n                IOUtils.closeQuietly(sentinelJedis);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "70", "src_id": "M126", "code": "\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (!(o instanceof CommandObject)) return false;\n\n        Iterator<Rawable> e1 = arguments.iterator();\n        Iterator<Rawable> e2 = ((CommandObject) o).arguments.iterator();\n        while (e1.hasNext() && e2.hasNext()) {\n            Rawable o1 = e1.next();\n            Rawable o2 = e2.next();\n            if (!(o1 == null ? o2 == null : o1.equals(o2))) return false;\n        }\n        if (e1.hasNext() || e2.hasNext()) return false;\n\n        return builder == ((CommandObject) o).builder;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "71", "src_id": "M44", "code": "\n    @Override\n    public String discard() {\n        if (!inMulti) throw new IllegalStateException(\"DISCARD without MULTI\");\n\n        try {\n            // processPipelinedResponses(pipelinedResponses.size());\n            // do nothing\n            connection.sendCommand(DISCARD);\n            String status = connection.getStatusCodeReply();\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n            broken = true;\n            throw jce;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n            pipelinedResponses.clear();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1213", "code": "\n    @Override\n    public Connection getConnection() {\n        final List<ConnectionPool> pools = getShuffledNodesPool();\n\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) continue;\n\n                jedis.ping();\n                return jedis;\n            } catch (JedisException ex) {\n                if (suppressed == null) suppressed = ex; // remembering first suppressed exception\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "73", "src_id": "M934", "code": "\n    private Socket createSslSocket(HostAndPort _hostAndPort, Socket socket) throws IOException, GeneralSecurityException {\n        Socket plainSocket = socket;\n\n        SSLSocketFactory _sslSocketFactory;\n        SSLParameters _sslParameters;\n\n        if (sslOptions != null) {\n            SSLContext _sslContext = sslOptions.createSslContext();\n            _sslSocketFactory = _sslContext.getSocketFactory();\n            _sslParameters = sslOptions.getSslParameters();\n        } else {\n            _sslSocketFactory = this.sslSocketFactory;\n            _sslParameters = this.sslParameters;\n        }\n\n        if (_sslSocketFactory == null) {\n            _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n\n        SSLSocket sslSocket = (SSLSocket) _sslSocketFactory.createSocket(\n                socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (_sslParameters != null) {\n            sslSocket.setSSLParameters(_sslParameters);\n        }\n\n        // allowing HostnameVerifier for both SslOptions and legacy ssl config\n        if (hostnameVerifier != null && !hostnameVerifier.verify(_hostAndPort.getHost(), sslSocket.getSession())) {\n            String message = String.format(\n                    \"The connection to '%s' failed ssl/tls hostname verification.\",\n                    _hostAndPort.getHost());\n            throw new JedisConnectionException(message);\n        }\n\n        return new SSLSocketWrapper(sslSocket, plainSocket);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "74", "src_id": "M1216", "code": "\n    private void initMaster(HostAndPort master) {\n        initPoolLock.lock();\n        try {\n            if (!master.equals(currentMaster)) {\n                currentMaster = master;\n\n                ConnectionPool newPool = createNodePool(currentMaster);\n\n                ConnectionPool existingPool = pool;\n                pool = newPool;\n                LOG.info(\"Created connection pool to master at {}.\", master);\n                if (clientSideCache != null) {\n                    clientSideCache.flush();\n                }\n\n                if (existingPool != null) {\n                    // although we clear the pool, we still have to check the returned object in getResource,\n                    // this call only clears idle instances, not borrowed instances\n                    // existingPool.clear(); // necessary??\n                    existingPool.close();\n                }\n            }\n        } finally {\n            initPoolLock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1275", "code": "\n    @Override\n    public Document build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n\n        String id = null;\n        Double score = null;\n        Map<String, Object> fields = null;\n\n        for (KeyValue kv : list) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            switch (key) {\n                case ID_STR: {\n                    id = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                }\n                case SCORE_STR: {\n                    score = BuilderFactory.DOUBLE.build(kv.getValue());\n                    break;\n                }\n                case FIELDS_STR: {\n                    fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                    break;\n                }\n                default: {\n                    break;\n                }\n            }\n        }\n\n        return new Document(id, score, fields);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "76", "src_id": "M889", "code": "\n    @Override\n    public void addParams(CommandArguments args) {\n        if (timestamp != null) {\n            args.add(TIMESTAMP).add(timestamp);\n        }\n\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            for (Map.Entry<String, String> entry : labels.entrySet()) {\n                args.add(entry.getKey()).add(entry.getValue());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1141", "code": "\n    @Override\n    public final <T> T executeCommand(CommandObject<T> commandObject) {\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n        int consecutiveConnectionFailures = 0;\n        JedisException lastException = null;\n\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n            Connection connection = null;\n            try {\n                connection = provider.getConnection(commandObject.getArguments());\n                return execute(connection, commandObject);\n            } catch (JedisConnectionException jce) {\n                lastException = jce;\n                consecutiveConnectionFailures++;\n                log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n\n                // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n                if (reset) {\n                    consecutiveConnectionFailures = 0;\n                }\n            } finally {\n                if (connection != null) {\n                    connection.close();\n                }\n            }\n\n            if (Instant.now().isAfter(deadline)) {\n                throw new JedisException(\"Retry deadline exceeded.\");\n            }\n        }\n\n        JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n        maxAttemptsException.addSuppressed(lastException);\n        throw maxAttemptsException;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "78", "src_id": "M1057", "code": "\n    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null;\n            Object profileData = null;\n\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8: {\n                        profileData = keyValue.getValue();\n                        break;\n                    }\n                    case RESULTS_STR_REDIS7: {\n                        resultsData = data;\n                        break;\n                    }\n                    case RESULTS_STR_REDIS8: {\n                        resultsData = keyValue.getValue();\n                        break;\n                    }\n                    default: {\n                        break;\n                    }\n                }\n            }\n\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n\n            return KeyValue.of(\n                resultsBuilder.build(resultsData),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData)\n            );\n        }\n\n        return KeyValue.of(\n            resultsBuilder.build(list.get(0)),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1))\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "79", "src_id": "M1102", "code": "\n    @Override\n    public final List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"EXEC without MULTI\");\n        }\n\n        try (Connection connection = failoverProvider.getConnection()) {\n            commands.forEach(command -> connection.sendCommand(command.getKey()));\n            // following connection.getMany(int) flushes anyway, so no flush here.\n\n            // ignore QUEUED (or ERROR)\n            connection.getMany(commands.size());\n\n            // remove extra response builders\n            for (int idx = 0; idx < extraCommandCount.get(); idx++) {\n                commands.poll();\n            }\n\n            connection.sendCommand(EXEC);\n\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n            if (unformatted == null) {\n                commands.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size() - extraCommandCount.get());\n            for (Object rawReply : unformatted) {\n                try {\n                    Response<?> response = commands.poll().getValue();\n                    response.set(rawReply);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                    formatted.add(e);\n                }\n            }\n            return formatted;\n        } finally {\n            inMulti = false;\n            inWatch = false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "80", "src_id": "M1304", "code": "\n    @Override\n    public AggregationResult build(Object data) {\n        List list = (List) data;\n\n        if (list.get(0) instanceof KeyValue) {\n            List<KeyValue> kvList = (List<KeyValue>) data;\n\n            long totalResults = -1;\n            List<Map<String, Object>> results = null;\n            List<String> warnings = null;\n\n            for (KeyValue kv : kvList) {\n                String key = BuilderFactory.STRING.build(kv.getKey());\n                Object rawVal = kv.getValue();\n\n                switch (key) {\n                    case TOTAL_RESULTS_STR: {\n                        totalResults = BuilderFactory.LONG.build(rawVal);\n                        break;\n                    }\n                    case RESULTS_STR: {\n                        List<List<KeyValue>> resList = (List<List<KeyValue>>) rawVal;\n                        results = new ArrayList<>(resList.size());\n                        for (List<KeyValue> rikv : resList) {\n                            for (KeyValue ikv : rikv) {\n                                if (FIELDS_STR.equals(BuilderFactory.STRING.build(ikv.getKey()))) {\n                                    results.add(BuilderFactory.ENCODED_OBJECT_MAP.build(ikv.getValue()));\n                                    break;\n                                }\n                            }\n                        }\n                        break;\n                    }\n                    case WARNINGS_STR: {\n                        warnings = BuilderFactory.STRING_LIST.build(rawVal);\n                        break;\n                    }\n                    default: {\n                        break;\n                    }\n                }\n            }\n\n            return new AggregationResult(totalResults, results, warnings);\n        }\n\n        list = (List<Object>) SafeEncoder.encodeObject(data);\n\n        // the first element is always the number of results\n        long totalResults = (Long) list.get(0);\n        List<Map<String, Object>> results = new ArrayList<>(list.size() - 1);\n\n        for (int i = 1; i < list.size(); i++) {\n            List<Object> mapList = (List<Object>) list.get(i);\n            Map<String, Object> map = new HashMap<>(mapList.size() / 2, 1f);\n\n            for (int j = 0; j < mapList.size(); j += 2) {\n                Object r = mapList.get(j);\n                if (r instanceof JedisDataException) {\n                    throw (JedisDataException) r;\n                }\n                map.put((String) r, mapList.get(j + 1));\n            }\n\n            results.add(map);\n        }\n\n        return new AggregationResult(totalResults, results);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "81", "src_id": "M1219", "code": "\n    @Override\n    public void run() {\n        running.set(true);\n\n        for (;;) {\n            if (!running.get()) {\n                break;\n            }\n\n            try {\n                // double check that it is not being shutdown\n                if (!running.get()) {\n                    break;\n                }\n\n                sentinelJedis = new Jedis(node, sentinelClientConfig);\n\n                // code for active refresh\n                List<String> masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n                if (masterAddr == null || masterAddr.size() != 2) {\n                    LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n                } else {\n                    initMaster(toHostAndPort(masterAddr));\n                }\n\n                sentinelJedis.subscribe(new JedisPubSub() {\n                    @Override\n                    public void onMessage(String channel, String message) {\n                        LOG.debug(\"Sentinel {} published: {}.\", node, message);\n\n                        String[] switchMasterMsg = message.split(\" \");\n\n                        if (switchMasterMsg.length > 3) {\n                            if (masterName.equals(switchMasterMsg[0])) {\n                                initMaster(toHostAndPort(switchMasterMsg[3], switchMasterMsg[4]));\n                            } else {\n                                LOG.debug(\"Ignoring message on +switch-master for master {}. Our master is {}.\",\n                                        switchMasterMsg[0], masterName);\n                            }\n                        } else {\n                            LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\",\n                                    node, message);\n                        }\n                    }\n                }, \"+switch-master\");\n            } catch (JedisException e) {\n                if (running.get()) {\n                    LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node,\n                            subscribeRetryWaitTimeMillis, e);\n                    try {\n                        Thread.sleep(subscribeRetryWaitTimeMillis);\n                    } catch (InterruptedException se) {\n                        LOG.error(\"Sleep interrupted.\", se);\n                    }\n                } else {\n                    LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n                }\n            } finally {\n                IOUtils.closeQuietly(sentinelJedis);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "82", "src_id": "M50", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "83", "src_id": "M1346", "code": "\n    @Override\n    public Map<String, Map<String, Double>> build(Object data) {\n        List rawDataList = (List) data;\n        if (rawDataList.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (rawDataList.get(0) instanceof KeyValue) {\n            KeyValue rawData = (KeyValue) rawDataList.get(0);\n            String header = STRING.build(rawData.getKey());\n            if (!RESULTS.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n\n            List<KeyValue> terms = (List<KeyValue>) rawData.getValue();\n            Map<String, Map<String, Double>> result = new LinkedHashMap<>(terms.size());\n\n            for (KeyValue rawTerm : terms) {\n                String termKey = STRING.build(rawTerm.getKey());\n                List<List<KeyValue>> entriesList = (List<List<KeyValue>>) rawTerm.getValue();\n\n                Map<String, Double> entries = new LinkedHashMap<>(entriesList.size());\n                for (List<KeyValue> entry : entriesList) {\n                    String entryKey = STRING.build(entry.get(0).getKey());\n                    Double entryVal = BuilderFactory.DOUBLE.build(entry.get(0).getValue());\n                    entries.put(entryKey, entryVal);\n                }\n\n                result.put(termKey, entries);\n            }\n\n            return result;\n        }\n\n        Map<String, Map<String, Double>> returnTerms = new LinkedHashMap<>(rawDataList.size());\n\n        for (Object rawData : rawDataList) {\n            List<Object> rawElements = (List<Object>) rawData;\n\n            String header = STRING.build(rawElements.get(0));\n            if (!TERM.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n\n            String term = STRING.build(rawElements.get(1));\n\n            List<List<Object>> list = (List<List<Object>>) rawElements.get(2);\n            Map<String, Double> entries = new LinkedHashMap<>(list.size());\n            for (List<Object> entry : list) {\n                entries.put(STRING.build(entry.get(1)), BuilderFactory.DOUBLE.build(entry.get(0)));\n            }\n\n            returnTerms.put(term, entries);\n        }\n\n        return returnTerms;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "84", "src_id": "M51", "code": "\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, String> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, String> map = new HashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), STRING.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<String, String> map = new HashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), STRING.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "85", "src_id": "M1108", "code": "\n@Override\npublic Object build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    if (!(data instanceof byte[])) {\n        return data;\n    }\n\n    String str = STRING.build(data);\n    if (str.charAt(0) == '{') {\n        try {\n            return new JSONObject(str);\n        } catch (Exception ex) {\n            // Ignore parse errors and return the raw string\n        }\n    } else if (str.charAt(0) == '[') {\n        try {\n            return new JSONArray(str);\n        } catch (Exception ex) {\n            // Ignore parse errors and return the raw string\n        }\n    }\n    return str;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "86", "src_id": "M1275", "code": "\n@Override\npublic Document build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    String id = null;\n    Double score = null;\n    Map<String, Object> fields = null;\n\n    for (KeyValue kv : list) {\n        String key = BuilderFactory.STRING.build(kv.getKey());\n        switch (key) {\n            case ID_STR:\n                id = BuilderFactory.STRING.build(kv.getValue());\n                break;\n            case SCORE_STR:\n                score = BuilderFactory.DOUBLE.build(kv.getValue());\n                break;\n            case FIELDS_STR:\n                fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                break;\n        }\n    }\n    return new Document(id, score, fields);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "87", "src_id": "M1159", "code": "\n@Override\npublic LibraryInfo build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        String libname = null;\n        String enginename = null;\n        String librarycode = null;\n        List<Map<String, Object>> functions = null;\n\n        for (KeyValue kv : (List<KeyValue>) list) {\n            switch (BuilderFactory.STRING.build(kv.getKey())) {\n                case \"library_name\":\n                    libname = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case \"engine\":\n                    enginename = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case \"functions\":\n                    functions = ((List<Object>) kv.getValue())\n                            .stream()\n                            .map(o -> ENCODED_OBJECT_MAP.build(o))\n                            .collect(Collectors.toList());\n                    break;\n                case \"library_code\":\n                    librarycode = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n            }\n        }\n        return new LibraryInfo(libname, enginename, functions, librarycode);\n    }\n\n    String libname = STRING.build(list.get(1));\n    String engine = STRING.build(list.get(3));\n    List<Object> rawFunctions = (List<Object>) list.get(5);\n    List<Map<String, Object>> functions = rawFunctions\n            .stream()\n            .map(o -> ENCODED_OBJECT_MAP.build(o))\n            .collect(Collectors.toList());\n    if (list.size() <= 6) {\n        return new LibraryInfo(libname, engine, functions);\n    }\n    String code = STRING.build(list.get(7));\n    return new LibraryInfo(libname, engine, functions, code);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "88", "src_id": "M934", "code": "\nprivate Socket createSslSocket(HostAndPort _hostAndPort, Socket socket)\n        throws IOException, GeneralSecurityException {\n\n    Socket plainSocket = socket;\n\n    SSLSocketFactory _sslSocketFactory;\n    SSLParameters _sslParameters;\n\n    if (sslOptions != null) {\n        SSLContext _sslContext = sslOptions.createSslContext();\n        _sslSocketFactory = _sslContext.getSocketFactory();\n        _sslParameters = sslOptions.getSslParameters();\n    } else {\n        _sslSocketFactory = this.sslSocketFactory;\n        _sslParameters = this.sslParameters;\n    }\n\n    if (_sslSocketFactory == null) {\n        _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n    }\n\n    SSLSocket sslSocket = (SSLSocket) _sslSocketFactory.createSocket(\n            socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n    if (_sslParameters != null) {\n        sslSocket.setSSLParameters(_sslParameters);\n    }\n\n    // allowing HostnameVerifier for both SslOptions and legacy ssl config\n    if (hostnameVerifier != null\n            && !hostnameVerifier.verify(_hostAndPort.getHost(), sslSocket.getSession())) {\n        String message = String.format(\n                \"The connection to '%s' failed ssl/tls hostname verification.\",\n                _hostAndPort.getHost());\n        throw new JedisConnectionException(message);\n    }\n\n    return new SSLSocketWrapper(sslSocket, plainSocket);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "89", "src_id": "M1304", "code": "\n@Override\npublic AggregationResult build(Object data) {\n    List list = (List) data;\n\n    if (list.get(0) instanceof KeyValue) {\n        List<KeyValue> kvList = (List<KeyValue>) data;\n        long totalResults = -1;\n        List<Map<String, Object>> results = null;\n        List<String> warnings = null;\n\n        for (KeyValue kv : kvList) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            Object rawVal = kv.getValue();\n            switch (key) {\n                case TOTAL_RESULTS_STR:\n                    totalResults = BuilderFactory.LONG.build(rawVal);\n                    break;\n                case RESULTS_STR:\n                    List<List<KeyValue>> resList = (List<List<KeyValue>>) rawVal;\n                    results = new ArrayList<>(resList.size());\n                    for (List<KeyValue> rikv : resList) {\n                        for (KeyValue ikv : rikv) {\n                            if (FIELDS_STR.equals(BuilderFactory.STRING.build(ikv.getKey()))) {\n                                results.add(BuilderFactory.ENCODED_OBJECT_MAP.build(ikv.getValue()));\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                case WARNINGS_STR:\n                    warnings = BuilderFactory.STRING_LIST.build(rawVal);\n                    break;\n            }\n        }\n        return new AggregationResult(totalResults, results, warnings);\n    }\n\n    list = (List<Object>) SafeEncoder.encodeObject(data);\n\n    // the first element is always the number of results\n    long totalResults = (Long) list.get(0);\n    List<Map<String, Object>> results = new ArrayList<>(list.size() - 1);\n\n    for (int i = 1; i < list.size(); i++) {\n        List<Object> mapList = (List<Object>) list.get(i);\n        Map<String, Object> map = new HashMap<>(mapList.size() / 2, 1f);\n        for (int j = 0; j < mapList.size(); j += 2) {\n            Object r = mapList.get(j);\n            if (r instanceof JedisDataException) {\n                throw (JedisDataException) r;\n            }\n            map.put((String) r, mapList.get(j + 1));\n        }\n        results.add(map);\n    }\n    return new AggregationResult(totalResults, results);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "90", "src_id": "M959", "code": "\nprivate void process() {\n    do {\n        Object reply = authenticator.client.getUnflushedObject();\n\n        if (reply instanceof List) {\n            List<Object> listReply = (List<Object>) reply;\n            final Object firstObj = listReply.get(0);\n            if (!(firstObj instanceof byte[])) {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n\n            final byte[] resp = (byte[]) firstObj;\n            if (Arrays.equals(SUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onSubscribe(enchannel, subscribedChannels);\n\n            } else if (Arrays.equals(UNSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onUnsubscribe(enchannel, subscribedChannels);\n\n            } else if (Arrays.equals(MESSAGE.getRaw(), resp)) {\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final Object mesg = listReply.get(2);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                if (mesg instanceof List) {\n                    ((List<byte[]>) mesg).forEach(bmesg -> onMessage(enchannel, encode(bmesg)));\n                } else {\n                    onMessage(enchannel, (mesg == null) ? null : encode((byte[]) mesg));\n                }\n\n            } else if (Arrays.equals(PMESSAGE.getRaw(), resp)) {\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final byte[] bchannel = (byte[]) listReply.get(2);\n                final byte[] bmesg = (byte[]) listReply.get(3);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                final T enmesg = (bmesg == null) ? null : encode(bmesg);\n                onPMessage(enpattern, enchannel, enmesg);\n\n            } else if (Arrays.equals(PSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                onPSubscribe(enpattern, subscribedChannels);\n\n            } else if (Arrays.equals(PUNSUBSCRIBE.getRaw(), resp)) {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                onPUnsubscribe(enpattern, subscribedChannels);\n\n            } else if (Arrays.equals(PONG.getRaw(), resp)) {\n                final byte[] bpattern = (byte[]) listReply.get(1);\n                final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                onPong(enpattern);\n\n            } else {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n\n        } else if (reply instanceof byte[]) {\n            Consumer<Object> resultHandler = authenticator.resultHandler.poll();\n            if (resultHandler == null) {\n                throw new JedisException(\"Unexpected message : \" + SafeEncoder.encode((byte[]) reply));\n            }\n            resultHandler.accept(reply);\n\n        } else {\n            throw new JedisException(\"Unknown message type: \" + reply);\n        }\n    } while (!Thread.currentThread().isInterrupted() && isSubscribed());\n\n    // /* Invalidate instance since this thread is no longer listening */\n    // this.client = null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "91", "src_id": "M1145", "code": "\n@Override\npublic final <T> T broadcastCommand(CommandObject<T> commandObject) {\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n        HostAndPort node = HostAndPort.from(entry.getKey());\n        ConnectionPool pool = entry.getValue();\n\n        try (Connection connection = pool.getResource()) {\n            T aReply = execute(connection, commandObject);\n            bcastError.addReply(node, aReply);\n\n            if (isErrored) {\n                // already errored\n            } else if (reply == null) {\n                reply = aReply; // ok\n            } else if (reply.equals(aReply)) {\n                // ok\n            } else {\n                isErrored = true;\n                reply = null;\n            }\n        } catch (Exception anError) {\n            bcastError.addReply(node, anError);\n            isErrored = true;\n        }\n    }\n\n    if (isErrored) {\n        throw bcastError;\n    }\n    return reply;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "92", "src_id": "M52", "code": "\n@Override\npublic Map<String, Object> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        final Map<String, Object> map = new HashMap<>(list.size(), 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        final Map<String, Object> map = new HashMap<>(list.size() / 2, 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "93", "src_id": "M34", "code": "\n@Override\npublic boolean isCacheable(ProtocolCommand command, List<Object> keys) {\n    if (allowCommands != null && !allowCommands.contains(command)) {\n        return false;\n    }\n    if (denyCommands != null && denyCommands.contains(command)) {\n        return false;\n    }\n\n    for (Object key : keys) {\n        if (!(key instanceof String)) {\n            return false;\n        }\n        if (allowKeys != null && !allowKeys.contains((String) key)) {\n            return false;\n        }\n        if (denyKeys != null && denyKeys.contains((String) key)) {\n            return false;\n        }\n    }\n\n    return DefaultCacheable.isDefaultCacheableCommand(command);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "94", "src_id": "M28", "code": "\n@Override\npublic <T> T executeCommand(final CommandObject<T> commandObject) {\n    final CacheKey cacheKey = new CacheKey(commandObject);\n    if (!cache.isCacheable(cacheKey)) {\n        cache.getStats().nonCacheable();\n        return super.executeCommand(commandObject);\n    }\n\n    CacheEntry<T> cacheEntry = cache.get(cacheKey);\n    if (cacheEntry != null) { // (probable) CACHE HIT !!\n        cacheEntry = validateEntry(cacheEntry);\n        if (cacheEntry != null) {\n            // CACHE HIT confirmed !!!\n            cache.getStats().hit();\n            return cacheEntry.getValue();\n        }\n    }\n\n    // CACHE MISS !!\n    cache.getStats().miss();\n    T value = super.executeCommand(commandObject);\n    cacheEntry = new CacheEntry<>(cacheKey, value, this);\n    cache.set(cacheKey, cacheEntry);\n    // this line actually provides a deep copy of cached object instance\n    value = cacheEntry.getValue();\n    return value;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "95", "src_id": "M1009", "code": "\n@Override\npublic String apply(String input) {\n    StringBuilder output = new StringBuilder();\n    String[] lines = input.split(\"\\n\");\n    int continueCount = 0;\n    int lastStartPos = 0;\n    int lastContinueLineNum = -1;\n    int matchCount = 0;\n\n    for (int lineNum = 0; lineNum < lines.length; ) {\n        String line = this.trimEnd ? StringUtils.stripEnd(lines[lineNum], null) : lines[lineNum];\n        lineNum++;\n\n        final boolean match;\n        if (pattern == null) {\n            match = (ignoreCase ? line.toLowerCase() : line).contains(keyword);\n        } else {\n            match = pattern.matcher(line).find();\n        }\n\n        if (invertMatch != match) {\n            matchCount++;\n\n            if (beforeLines > continueCount) {\n                int n = (lastContinueLineNum == -1)\n                        ? (beforeLines >= lineNum ? 1 : lineNum - beforeLines)\n                        : lineNum - beforeLines - continueCount;\n\n                if (n >= lastContinueLineNum || lastContinueLineNum == -1) {\n                    StringBuilder beforeSb = new StringBuilder();\n                    for (int i = n; i < lineNum; i++) {\n                        appendLine(beforeSb, i, lines[i - 1]);\n                    }\n                    output.insert(lastStartPos, beforeSb);\n                }\n            }\n\n            lastStartPos = output.length();\n            appendLine(output, lineNum, line);\n\n            if (afterLines > continueCount) {\n                int last = lineNum + afterLines - continueCount;\n                if (last > lines.length) {\n                    last = lines.length;\n                }\n                for (int i = lineNum; i < last; i++) {\n                    appendLine(output, i + 1, lines[i]);\n                    lineNum++;\n                    continueCount++;\n                    lastStartPos = output.length();\n                }\n            }\n\n            continueCount++;\n            if (maxCount > 0 && matchCount >= maxCount) {\n                break;\n            }\n        } else {\n            if (continueCount > 0) {\n                lastContinueLineNum = lineNum - 1;\n                continueCount = 0;\n            }\n        }\n    }\n\n    return output.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "96", "src_id": "M87", "code": "\nprivate static List<String> readLines(File batchFile) {\n    List<String> list = new ArrayList<>();\n    BufferedReader br = null;\n    try {\n        br = new BufferedReader(new FileReader(batchFile));\n        String line = br.readLine();\n        while (line != null) {\n            list.add(line);\n            line = br.readLine();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if (br != null) {\n            try {\n                br.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n    }\n    return list;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "97", "src_id": "M454", "code": "\nprivate void renderObject(Object obj, int deep, int expand, final StringBuilder buf) throws ObjectTooLargeException {\n\n    if (obj == null) {\n        appendStringBuilder(buf, \"null\");\n        return;\n    }\n\n    final Class<?> clazz = obj.getClass();\n    final String className = clazz.getSimpleName();\n\n    // 7种基础类型,直接输出@类型[值]\n    if (Integer.class.isInstance(obj)\n            || Long.class.isInstance(obj)\n            || Float.class.isInstance(obj)\n            || Double.class.isInstance(obj)\n            // || Character.class.isInstance(obj)\n            || Short.class.isInstance(obj)\n            || Byte.class.isInstance(obj)\n            || Boolean.class.isInstance(obj)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n    }\n\n    // Char要特殊处理,因为有不可见字符的因素\n    else if (Character.class.isInstance(obj)) {\n        final Character c = (Character) obj;\n\n        // ASCII的可见字符\n        if (c >= 32 && c <= 126) {\n            appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n        }\n\n        // ASCII的控制字符\n        else if (ASCII_MAP.containsKey((byte) c.charValue())) {\n            appendStringBuilder(buf, format(\"@%s[%s]\", className, ASCII_MAP.get((byte) c.charValue())));\n        }\n\n        // 超过ASCII的编码范围\n        else {\n            appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n        }\n    }\n\n    // 字符串类型单独处理\n    else if (String.class.isInstance(obj)) {\n        appendStringBuilder(buf, \"@\");\n        appendStringBuilder(buf, className);\n        appendStringBuilder(buf, \"[\");\n        for (Character c : ((String) obj).toCharArray()) {\n            switch (c) {\n                case '\\n':\n                    appendStringBuilder(buf, \"\\\\n\");\n                    break;\n                case '\\r':\n                    appendStringBuilder(buf, \"\\\\r\");\n                    break;\n                default:\n                    appendStringBuilder(buf, c.toString());\n            }\n        }\n        appendStringBuilder(buf, \"]\");\n    }\n\n    // 集合类输出\n    else if (Collection.class.isInstance(obj)) {\n\n        @SuppressWarnings(\"unchecked\")\n        final Collection<Object> collection = (Collection<Object>) obj;\n\n        // 非根节点或空集合只展示摘要信息\n        if (!isExpand(deep, expand) || collection.isEmpty()) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, collection.isEmpty(), collection.size()));\n        }\n\n        // 展开展示\n        else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n            for (Object e : collection) {\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep + 1; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                renderObject(e, deep + 1, expand, buf);\n                appendStringBuilder(buf, \",\");\n            }\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n                appendStringBuilder(buf, TAB);\n            }\n            appendStringBuilder(buf, \"]\");\n        }\n    }\n\n    // Map类输出\n    else if (Map.class.isInstance(obj)) {\n        @SuppressWarnings(\"unchecked\")\n        final Map<Object, Object> map = (Map<Object, Object>) obj;\n\n        // 非根节点或空集合只展示摘要信息\n        if (!isExpand(deep, expand) || map.isEmpty()) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, map.isEmpty(), map.size()));\n        } else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n            for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep + 1; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                renderObject(entry.getKey(), deep + 1, expand, buf);\n                appendStringBuilder(buf, \":\");\n                renderObject(entry.getValue(), deep + 1, expand, buf);\n                appendStringBuilder(buf, \",\");\n            }\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n                appendStringBuilder(buf, TAB);\n            }\n            appendStringBuilder(buf, \"]\");\n        }\n    }\n\n    // 数组类输出\n    else if (obj.getClass().isArray()) {\n\n        final String typeName = obj.getClass().getSimpleName();\n\n        // int[]\n        if (typeName.equals(\"int[]\")) {\n            final int[] arrays = (int[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (int e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // long[]\n        else if (typeName.equals(\"long[]\")) {\n            final long[] arrays = (long[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (long e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // short[]\n        else if (typeName.equals(\"short[]\")) {\n            final short[] arrays = (short[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (short e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // float[]\n        else if (typeName.equals(\"float[]\")) {\n            final float[] arrays = (float[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (float e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // double[]\n        else if (typeName.equals(\"double[]\")) {\n            final double[] arrays = (double[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (double e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // boolean[]\n        else if (typeName.equals(\"boolean[]\")) {\n            final boolean[] arrays = (boolean[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (boolean e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // char[]\n        else if (typeName.equals(\"char[]\")) {\n            final char[] arrays = (char[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (char e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // byte[]\n        else if (typeName.equals(\"byte[]\")) {\n            final byte[] arrays = (byte[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (byte e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n\n        // Object[]\n        else {\n            final Object[] arrays = (Object[]) obj;\n\n            if (!isExpand(deep, expand) || arrays.length == 0) {\n                appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n            } else {\n                appendStringBuilder(buf, format(\"@%s[\", className));\n                for (Object e : arrays) {\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    renderObject(e, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                }\n                appendStringBuilder(buf, \"\\n\");\n                for (int i = 0; i < deep; i++) {\n                    appendStringBuilder(buf, TAB);\n                }\n                appendStringBuilder(buf, \"]\");\n            }\n        }\n    }\n\n    // Throwable输出\n    else if (Throwable.class.isInstance(obj)) {\n        if (!isExpand(deep, expand)) {\n            appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n        } else {\n            final Throwable throwable = (Throwable) obj;\n            final StringWriter sw = new StringWriter();\n            final PrintWriter pw = new PrintWriter(sw);\n            throwable.printStackTrace(pw);\n            appendStringBuilder(buf, sw.toString());\n        }\n    }\n\n    // Date输出\n    else if (Date.class.isInstance(obj)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\").format(obj)));\n    }\n\n    else if (object instanceof Enum<?>) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n    }\n\n    // 普通Object输出\n    else {\n        if (!isExpand(deep, expand)) {\n            appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n        } else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n            final List<Field> fields;\n            Class<?> objClass = obj.getClass();\n\n            if (GlobalOptions.printParentFields) {\n                fields = new ArrayList<>();\n                // 当父类为null的时候说明到达了最上层的父类(Object类).\n                while (objClass != null) {\n                    fields.addAll(Arrays.asList(objClass.getDeclaredFields()));\n                    objClass = objClass.getSuperclass();\n                }\n            } else {\n                fields = new ArrayList<>(Arrays.asList(objClass.getDeclaredFields()));\n            }\n\n            for (Field field : fields) {\n                field.setAccessible(true);\n                try {\n                    final Object value = field.get(obj);\n\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep + 1; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n                    appendStringBuilder(buf, field.getName());\n                    appendStringBuilder(buf, \"=\");\n                    renderObject(value, deep + 1, expand, buf);\n                    appendStringBuilder(buf, \",\");\n                } catch (ObjectTooLargeException t) {\n                    buf.append(\"...\");\n                    break;\n                } catch (Throwable t) {\n                    // ignore\n                }\n            }\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n                appendStringBuilder(buf, TAB);\n            }\n            appendStringBuilder(buf, \"]\");\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "98", "src_id": "M114", "code": "\npublic boolean isAvailable() {\n    if (!isConnected()) {\n        return false;\n    }\n    try {\n        if (_socket_.getInetAddress() == null) {\n            return false;\n        }\n        if (_socket_.getPort() == 0) {\n            return false;\n        }\n        if (_socket_.getRemoteSocketAddress() == null) {\n            return false;\n        }\n        if (_socket_.isClosed()) {\n            return false;\n        }\n        // These aren't exact checks (a Socket can be half-open), but since we usually\n        // require two-way data transfer, we check these here too:\n        if (_socket_.isInputShutdown()) {\n            return false;\n        }\n        if (_socket_.isOutputShutdown()) {\n            return false;\n        }\n        // ignore the result, catch exceptions:\n        _socket_.getInputStream();\n        _socket_.getOutputStream();\n        return true;\n    } catch (IOException ioex) {\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "99", "src_id": "M716", "code": "\npublic static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n    // 执行失败:输出失败状态\n    table.row(\"IS-RETURN\", \"\" + false);\n    table.row(\"IS-EXCEPTION\", \"\" + true);\n\n    // 执行失败:输出失败异常信息\n    Throwable t = (Throwable) throwableVO.getObject();\n    Throwable cause = (t instanceof InvocationTargetException) ? t.getCause() : t;\n\n    if (throwableVO.needExpand()) {\n        table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n    } else {\n        StringWriter stringWriter = new StringWriter();\n        PrintWriter printWriter = new PrintWriter(stringWriter);\n        try {\n            cause.printStackTrace(printWriter);\n            table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n        } finally {\n            printWriter.close();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "100", "src_id": "M566", "code": "\n@Override\npublic void process(final CommandProcess process) {\n\n    Session session = process.session();\n    timer = new Timer(\"Timer-for-arthas-dashboard-\" + session.getSessionId(), true);\n\n    // ctrl-C support\n    process.interruptHandler(new DashboardInterruptHandler(process, timer));\n\n    // 通过handle回调，在suspend和end时停止timer，resume时重启timer\n    Handler<Void> stopHandler =\n            new Handler<Void>() {\n                @Override\n                public void handle(Void event) {\n                    stop();\n                }\n            };\n\n    Handler<Void> restartHandler =\n            new Handler<Void>() {\n                @Override\n                public void handle(Void event) {\n                    restart(process);\n                }\n            };\n\n    process.suspendHandler(stopHandler);\n    process.resumeHandler(restartHandler);\n    process.endHandler(stopHandler);\n\n    // q exit support\n    process.stdinHandler(new QExitHandler(process));\n\n    // start the timer\n    timer.scheduleAtFixedRate(new DashboardTimerTask(process), 0, getInterval());\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "101", "src_id": "M443", "code": "\nprivate String drawField() {\n\n    final StringBuilder fieldSB = new StringBuilder();\n\n    final Field[] fields = clazz.getDeclaredFields();\n    if (fields.length > 0) {\n        for (Field field : fields) {\n            final KVView kvView =\n                    new KVView(\n                                    new TableView.ColumnDefine(TableView.Align.RIGHT),\n                                    new TableView.ColumnDefine(50, false, TableView.Align.LEFT))\n                            .add(\"modifier\", StringUtils.modifier(field.getModifiers(), ','))\n                            .add(\"type\", StringUtils.classname(field.getType()))\n                            .add(\"name\", field.getName());\n\n            final StringBuilder annotationSB = new StringBuilder();\n            final Annotation[] annotationArray = field.getAnnotations();\n            if (annotationArray != null && annotationArray.length > 0) {\n                for (Annotation annotation : annotationArray) {\n                    annotationSB.append(StringUtils.classname(annotation.annotationType())).append(\",\");\n                }\n                if (annotationSB.length() > 0) {\n                    annotationSB.deleteCharAt(annotationSB.length() - 1);\n                }\n                kvView.add(\"annotation\", annotationSB);\n            }\n\n            if (Modifier.isStatic(field.getModifiers())) {\n                final boolean isAccessible = field.isAccessible();\n                try {\n                    field.setAccessible(true);\n                    kvView.add(\"value\", StringUtils.objectToString(field.get(null)));\n                } catch (IllegalAccessException e) {\n                    // ignore\n                } finally {\n                    field.setAccessible(isAccessible);\n                }\n            }\n\n            fieldSB.append(kvView.draw()).append(\"\\n\");\n        }\n    }\n\n    return fieldSB.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "102", "src_id": "M270", "code": "\nprivate static String normalizeArch(String value) {\n    value = normalize(value);\n\n    if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n        return \"x86_64\";\n    }\n    if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n        return \"x86_32\";\n    }\n    if (value.matches(\"^(ia64w?|itanium64)$\")) {\n        return \"itanium_64\";\n    }\n    if (\"ia64n\".equals(value)) {\n        return \"itanium_32\";\n    }\n    if (value.matches(\"^(sparc|sparc32)$\")) {\n        return \"sparc_32\";\n    }\n    if (value.matches(\"^(sparcv9|sparc64)$\")) {\n        return \"sparc_64\";\n    }\n    if (value.matches(\"^(arm|arm32)$\")) {\n        return \"arm_32\";\n    }\n    if (\"aarch64\".equals(value)) {\n        return \"aarch_64\";\n    }\n    if (value.matches(\"^(mips|mips32)$\")) {\n        return \"mips_32\";\n    }\n    if (value.matches(\"^(mipsel|mips32el)$\")) {\n        return \"mipsel_32\";\n    }\n    if (\"mips64\".equals(value)) {\n        return \"mips_64\";\n    }\n    if (\"mips64el\".equals(value)) {\n        return \"mipsel_64\";\n    }\n    if (value.matches(\"^(ppc|ppc32)$\")) {\n        return \"ppc_32\";\n    }\n    if (value.matches(\"^(ppcle|ppc32le)$\")) {\n        return \"ppcle_32\";\n    }\n    if (\"ppc64\".equals(value)) {\n        return \"ppc_64\";\n    }\n    if (\"ppc64le\".equals(value)) {\n        return \"ppcle_64\";\n    }\n    if (\"s390\".equals(value)) {\n        return \"s390_32\";\n    }\n    if (\"s390x\".equals(value)) {\n        return \"s390_64\";\n    }\n    return value;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "103", "src_id": "M232", "code": "\npublic void start() throws Exception {\n    // Configure SSL.\n    final SslContext sslCtx;\n    if (ssl) {\n        SelfSignedCertificate ssc = new SelfSignedCertificate();\n        sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n    } else {\n        sslCtx = null;\n    }\n\n    ServerBootstrap b = new ServerBootstrap();\n    b.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .handler(new LoggingHandler(LogLevel.INFO))\n            .childHandler(new TunnelSocketServerInitializer(this, sslCtx));\n\n    if (StringUtils.isBlank(host)) {\n        channel = b.bind(port).sync().channel();\n    } else {\n        channel = b.bind(host, port).sync().channel();\n    }\n\n    logger.info(\"Tunnel server listen at {}:{}\", host, port);\n\n    workerGroup.scheduleWithFixedDelay(\n            new Runnable() {\n                @Override\n                public void run() {\n                    agentInfoMap.entrySet()\n                            .removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n                    clientConnectionInfoMap.entrySet()\n                            .removeIf(e -> !e.getValue().getChannelHandlerContext().channel().isActive());\n\n                    // 更新集群key信息\n                    if (tunnelClusterStore != null && clientConnectHost != null) {\n                        try {\n                            for (Entry<String, AgentInfo> entry : agentInfoMap.entrySet()) {\n                                tunnelClusterStore.addAgent(\n                                        entry.getKey(),\n                                        new AgentClusterInfo(entry.getValue(), clientConnectHost, port),\n                                        60 * 60,\n                                        TimeUnit.SECONDS);\n                            }\n                        } catch (Throwable t) {\n                            logger.error(\"update tunnel info error\", t);\n                        }\n                    }\n                }\n            },\n            60,\n            60,\n            TimeUnit.SECONDS);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "104", "src_id": "M1354", "code": "\npublic static String nullSafeToString(byte[] array) {\n    if (array == null) {\n        return \"null\";\n    }\n    int length = array.length;\n    if (length == 0) {\n        return \"{}\";\n    }\n\n    StringBuilder sb = new StringBuilder(\"{\");\n    for (int i = 0; i < length; i++) {\n        if (i > 0) {\n            sb.append(\", \");\n        }\n        sb.append(array[i]);\n    }\n    sb.append(\"}\");\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "105", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        for (Map.Entry entry : labels.entrySet()) {\n            args.add(entry.getKey()).add(entry.getValue());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "106", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<String, String>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            if (stringEscape) {\n                str = escape((String) obj);\n            } else {\n                str = (String) obj;\n            }\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "107", "src_id": "M1197", "code": "\npublic final B nextBatch() {\n    if (roundRobinCompleted) {\n        throw new NoSuchElementException();\n    }\n\n    CommandArguments args;\n    if (iterationCompleted) {\n        connection = connections.poll();\n        args = initCommandArguments();\n    } else {\n        args = nextCommandArguments(lastReply);\n    }\n\n    Object rawReply;\n    if (connection.getValue() instanceof Connection) {\n        rawReply = ((Connection) connection.getValue()).executeCommand(args);\n    } else if (connection.getValue() instanceof Pool) {\n        try (Connection c = ((Pool<Connection>) connection.getValue()).getResource()) {\n            rawReply = c.executeCommand(args);\n        }\n    } else {\n        throw new IllegalArgumentException(connection.getValue().getClass() + \"is not supported.\");\n    }\n\n    lastReply = builder.build(rawReply);\n    iterationCompleted = isNodeCompleted(lastReply);\n    if (iterationCompleted) {\n        if (connections.isEmpty()) {\n            roundRobinCompleted = true;\n        }\n    }\n    return lastReply;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "108", "src_id": "M1251", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    args.addParams(fieldName);\n    args.add(TEXT);\n\n    if (indexMissing) {\n        args.add(INDEXMISSING);\n    }\n    if (indexEmpty) {\n        args.add(INDEXEMPTY);\n    }\n\n    if (weight != null) {\n        args.add(WEIGHT).add(weight);\n    }\n\n    if (noStem) {\n        args.add(NOSTEM);\n    }\n\n    if (phoneticMatcher != null) {\n        args.add(PHONETIC).add(phoneticMatcher);\n    }\n\n    if (withSuffixTrie) {\n        args.add(WITHSUFFIXTRIE);\n    }\n\n    if (sortableUNF) {\n        args.add(SORTABLE).add(UNF);\n    } else if (sortable) {\n        args.add(SORTABLE);\n    }\n\n    if (noIndex) {\n        args.add(NOINDEX);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "109", "src_id": "M873", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (fromTimestamp == null) {\n        args.add(MINUS);\n    } else {\n        args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n        args.add(PLUS);\n    } else {\n        args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n        args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n        args.add(FILTER_BY_TS);\n        for (long ts : filterByTimestamps) {\n            args.add(toByteArray(ts));\n        }\n    }\n\n    if (filterByValues != null) {\n        args.add(FILTER_BY_VALUE);\n        for (double value : filterByValues) {\n            args.add(toByteArray(value));\n        }\n    }\n\n    if (count != null) {\n        args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n        if (align != null) {\n            args.add(ALIGN).add(align);\n        }\n\n        args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n        if (bucketTimestamp != null) {\n            args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n        }\n\n        if (empty) {\n            args.add(EMPTY);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "110", "src_id": "M1349", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (dataType != null) {\n        args.add(ON).add(dataType);\n    }\n\n    if (prefix != null) {\n        args.add(PREFIX).add(prefix.size()).addObjects(prefix);\n    }\n\n    if (filter != null) {\n        args.add(FILTER).add(filter);\n    }\n\n    if (language != null) {\n        args.add(LANGUAGE).add(language);\n    }\n    if (languageField != null) {\n        args.add(LANGUAGE_FIELD).add(languageField);\n    }\n\n    if (score != null) {\n        args.add(SCORE).add(score);\n    }\n    if (scoreField != null) {\n        args.add(SCORE_FIELD).add(scoreField);\n    }\n\n    if (maxTextFields) {\n        args.add(MAXTEXTFIELDS);\n    }\n\n    if (noOffsets) {\n        args.add(NOOFFSETS);\n    }\n\n    if (temporary != null) {\n        args.add(TEMPORARY).add(temporary);\n    }\n\n    if (noHL) {\n        args.add(NOHL);\n    }\n\n    if (noFields) {\n        args.add(NOFIELDS);\n    }\n\n    if (noFreqs) {\n        args.add(NOFREQS);\n    }\n\n    if (stopwords != null) {\n        args.add(STOPWORDS).add(stopwords.size());\n        for (Object w : stopwords) {\n            args.add(w);\n        }\n    }\n\n    if (skipInitialScan) {\n        args.add(SKIPINITIALSCAN);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "111", "src_id": "M55", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<String, Long> build(Object data) {\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        final Map<String, Long> map = new LinkedHashMap<String, Long>(list.size(), 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        final Map<String, Long> map = new LinkedHashMap<String, Long>(list.size() / 2, 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "112", "src_id": "M1351", "code": "\n@Override\npublic SearchResult build(Object data) {\n    List<Object> resp = (List<Object>) data;\n\n    int step = 1;\n    int scoreOffset = 0;\n    int contentOffset = 1;\n    if (hasScores) {\n        step += 1;\n        scoreOffset = 1;\n        contentOffset += 1;\n    }\n    if (hasContent) {\n        step += 1;\n    }\n\n    long totalResults = (Long) resp.get(0);\n    List<Document> documents = new ArrayList<Document>(resp.size() - 1);\n\n    for (int i = 1; i < resp.size(); i += step) {\n        String id = BuilderFactory.STRING.build(resp.get(i));\n        double score = hasScores ? BuilderFactory.DOUBLE.build(resp.get(i + scoreOffset)) : 1.0;\n        List<byte[]> fields = hasContent ? (List<byte[]>) resp.get(i + contentOffset) : null;\n\n        documents.add(Document.load(id, score, fields, decode, isFieldDecode));\n    }\n\n    return new SearchResult(totalResults, documents);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "113", "src_id": "M1298", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (type != null) {\n        args.add(SearchKeyword.ON.name());\n        args.add(type.name());\n    }\n\n    if (prefixes != null && prefixes.length > 0) {\n        args.add(SearchKeyword.PREFIX.name());\n        args.add(Integer.toString(prefixes.length));\n        args.addObjects((Object[]) prefixes);\n    }\n\n    if (filter != null) {\n        args.add(SearchKeyword.FILTER.name());\n        args.add(filter);\n    }\n\n    if (languageField != null) {\n        args.add(SearchKeyword.LANGUAGE_FIELD.name());\n        args.add(languageField);\n    }\n\n    if (language != null) {\n        args.add(SearchKeyword.LANGUAGE.name());\n        args.add(language);\n    }\n\n    if (scoreFiled != null) {\n        args.add(SearchKeyword.SCORE_FIELD.name());\n        args.add(scoreFiled);\n    }\n\n    if (score != 1.0) {\n        args.add(SearchKeyword.SCORE.name());\n        args.add(Double.toString(score));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "115", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry)\n{\n    lock.lock();\n    try\n    {\n        entry = putIntoStore(cacheKey, entry);\n        EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null)\n        {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (Object redisKey : cacheKey.getRedisKeys())\n        {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey))\n            {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            }\n            else\n            {\n                Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n        stats.load();\n        return entry;\n    }\n    finally\n    {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "116", "src_id": "M55", "code": "\n@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<String, Long> build(Object data)\n{\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty())\n    {\n        return Collections.emptyMap();\n    }\n\n    if (list.get(0) instanceof KeyValue)\n    {\n        final Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n        }\n        return map;\n    }\n    else\n    {\n        final Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext())\n        {\n            map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n        }\n        return map;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1145", "code": "\n@Override\npublic final <T> T broadcastCommand(CommandObject<T> commandObject)\n{\n    Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n\n    boolean isErrored = false;\n    T reply = null;\n    JedisBroadcastException bcastError = new JedisBroadcastException();\n    for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet())\n    {\n        HostAndPort node = HostAndPort.from(entry.getKey());\n        ConnectionPool pool = entry.getValue();\n        try (Connection connection = pool.getResource())\n        {\n            T aReply = execute(connection, commandObject);\n            bcastError.addReply(node, aReply);\n            if (isErrored)\n            {\n                // already errored\n            }\n            else if (reply == null)\n            {\n                reply = aReply; // ok\n            }\n            else if (reply.equals(aReply))\n            {\n                // ok\n            }\n            else\n            {\n                isErrored = true;\n                reply = null;\n            }\n        }\n        catch (Exception anError)\n        {\n            bcastError.addReply(node, anError);\n            isErrored = true;\n        }\n    }\n    if (isErrored)\n    {\n        throw bcastError;\n    }\n    return reply;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1141", "code": "\n@Override\npublic final <T> T executeCommand(CommandObject<T> commandObject)\n{\n\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    int consecutiveConnectionFailures = 0;\n    JedisException lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--)\n    {\n        Connection connection = null;\n        try\n        {\n            connection = provider.getConnection(commandObject.getArguments());\n\n            return execute(connection, commandObject);\n        }\n        catch (JedisConnectionException jce)\n        {\n            lastException = jce;\n            ++consecutiveConnectionFailures;\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n            boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n            if (reset)\n            {\n                consecutiveConnectionFailures = 0;\n            }\n        }\n        finally\n        {\n            if (connection != null)\n            {\n                connection.close();\n            }\n        }\n        if (Instant.now().isAfter(deadline))\n        {\n            throw new JedisException(\"Retry deadline exceeded.\");\n        }\n    }\n\n    JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1346", "code": "\n@Override\npublic Map<String, Map<String, Double>> build(Object data)\n{\n    List rawDataList = (List) data;\n    if (rawDataList.isEmpty())\n    {\n        return Collections.emptyMap();\n    }\n\n    if (rawDataList.get(0) instanceof KeyValue)\n    {\n        KeyValue rawData = (KeyValue) rawDataList.get(0);\n        String header = STRING.build(rawData.getKey());\n        if (!RESULTS.equals(header))\n        {\n            throw new IllegalStateException(\"Unrecognized header: \" + header);\n        }\n\n        return ((List<KeyValue>) rawData.getValue()).stream().collect(Collectors.toMap(\n            rawTerm -> STRING.build(rawTerm.getKey()),\n            rawTerm -> ((List<List<KeyValue>>) rawTerm.getValue()).stream()\n                .collect(Collectors.toMap(entry -> STRING.build(entry.get(0).getKey()),\n                    entry -> BuilderFactory.DOUBLE.build(entry.get(0).getValue()))),\n            (x, y) -> x, LinkedHashMap::new));\n    }\n\n    Map<String, Map<String, Double>> returnTerms = new LinkedHashMap<>(rawDataList.size());\n\n    for (Object rawData : rawDataList)\n    {\n        List<Object> rawElements = (List<Object>) rawData;\n\n        String header = STRING.build(rawElements.get(0));\n        if (!TERM.equals(header))\n        {\n            throw new IllegalStateException(\"Unrecognized header: \" + header);\n        }\n        String term = STRING.build(rawElements.get(1));\n\n        List<List<Object>> list = (List<List<Object>>) rawElements.get(2);\n        Map<String, Double> entries = new LinkedHashMap<>(list.size());\n        list.forEach(entry -> entries.put(STRING.build(entry.get(1)), BuilderFactory.DOUBLE.build(entry.get(0))));\n\n        returnTerms.put(term, entries);\n    }\n    return returnTerms;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "120", "src_id": "M1102", "code": "\n@Override\npublic final List<Object> exec()\n{\n    if (!inMulti)\n    {\n        throw new IllegalStateException(\"EXEC without MULTI\");\n    }\n\n    try (Connection connection = failoverProvider.getConnection())\n    {\n\n        commands.forEach((command) -> connection.sendCommand(command.getKey()));\n        // following connection.getMany(int) flushes anyway, so no flush here.\n\n        // ignore QUEUED (or ERROR)\n        connection.getMany(commands.size());\n\n        // remove extra response builders\n        for (int idx = 0; idx < extraCommandCount.get(); ++idx)\n        {\n            commands.poll();\n        }\n\n        connection.sendCommand(EXEC);\n\n        List<Object> unformatted = connection.getObjectMultiBulkReply();\n        if (unformatted == null)\n        {\n            commands.clear();\n            return null;\n        }\n\n        List<Object> formatted = new ArrayList<>(unformatted.size() - extraCommandCount.get());\n        for (Object rawReply : unformatted)\n        {\n            try\n            {\n                Response<?> response = commands.poll().getValue();\n                response.set(rawReply);\n                formatted.add(response.get());\n            }\n            catch (JedisDataException e)\n            {\n                formatted.add(e);\n            }\n        }\n        return formatted;\n\n    }\n    finally\n    {\n        inMulti = false;\n        inWatch = false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "121", "src_id": "M925", "code": "\nprivate void process()\n{\n\n    do\n    {\n        Object reply = authenticator.client.getUnflushedObject();\n\n        if (reply instanceof List)\n        {\n            List<Object> listReply = (List<Object>) reply;\n            final Object firstObj = listReply.get(0);\n            if (!(firstObj instanceof byte[]))\n            {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n            final byte[] resp = (byte[]) firstObj;\n            if (Arrays.equals(SSUBSCRIBE.getRaw(), resp))\n            {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onSSubscribe(enchannel, subscribedChannels);\n            }\n            else if (Arrays.equals(SUNSUBSCRIBE.getRaw(), resp))\n            {\n                subscribedChannels = ((Long) listReply.get(2)).intValue();\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                onSUnsubscribe(enchannel, subscribedChannels);\n            }\n            else if (Arrays.equals(SMESSAGE.getRaw(), resp))\n            {\n                final byte[] bchannel = (byte[]) listReply.get(1);\n                final byte[] bmesg = (byte[]) listReply.get(2);\n                final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                final T enmesg = (bmesg == null) ? null : encode(bmesg);\n                onSMessage(enchannel, enmesg);\n            }\n            else\n            {\n                throw new JedisException(\"Unknown message type: \" + firstObj);\n            }\n        }\n        else if (reply instanceof byte[])\n        {\n            Consumer<Object> resultHandler = authenticator.resultHandler.poll();\n            if (resultHandler == null)\n            {\n                throw new JedisException(\"Unexpected message : \" + SafeEncoder.encode((byte[]) reply));\n            }\n            resultHandler.accept(reply);\n        }\n        else\n        {\n            throw new JedisException(\"Unknown message type: \" + reply);\n        }\n    }\n    while (!Thread.currentThread().isInterrupted() && isSubscribed());\n\n//    /* Invalidate instance since this thread is no longer listening */\n//    this.client = null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "122", "src_id": "M126", "code": "\n@Override\npublic boolean equals(Object o)\n{\n    if (o == this)\n    {\n        return true;\n    }\n    if (!(o instanceof CommandObject))\n    {\n        return false;\n    }\n\n    Iterator<Rawable> e1 = arguments.iterator();\n    Iterator<Rawable> e2 = ((CommandObject) o).arguments.iterator();\n    while (e1.hasNext() && e2.hasNext())\n    {\n        Rawable o1 = e1.next();\n        Rawable o2 = e2.next();\n        if (!(o1 == null ? o2 == null : o1.equals(o2)))\n        {\n            return false;\n        }\n    }\n    if (e1.hasNext() || e2.hasNext())\n    {\n        return false;\n    }\n\n    return builder == ((CommandObject) o).builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "123", "src_id": "M918", "code": "\npublic CommandArguments add(Object arg)\n{\n    if (arg == null)\n    {\n        throw new IllegalArgumentException(\"null is not a valid argument.\");\n    }\n    else if (arg instanceof Rawable)\n    {\n        args.add((Rawable) arg);\n    }\n    else if (arg instanceof byte[])\n    {\n        args.add(RawableFactory.from((byte[]) arg));\n    }\n    else if (arg instanceof Boolean)\n    {\n        args.add(RawableFactory.from((Boolean) arg));\n    }\n    else if (arg instanceof Integer)\n    {\n        args.add(RawableFactory.from((Integer) arg));\n    }\n    else if (arg instanceof Long)\n    {\n        args.add(RawableFactory.from((Long) arg));\n    }\n    else if (arg instanceof Double)\n    {\n        args.add(RawableFactory.from((Double) arg));\n    }\n    else if (arg instanceof float[])\n    {\n        args.add(RawableFactory.from(RediSearchUtil.toByteArray((float[]) arg)));\n    }\n    else if (arg instanceof String)\n    {\n        args.add(RawableFactory.from((String) arg));\n    }\n    else if (arg instanceof GeoCoordinate)\n    {\n        GeoCoordinate geo = (GeoCoordinate) arg;\n        args.add(RawableFactory.from(geo.getLongitude() + \",\" + geo.getLatitude()));\n    }\n    else\n    {\n        args.add(RawableFactory.from(String.valueOf(arg)));\n    }\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "124", "src_id": "M1216", "code": "\nprivate void initMaster(HostAndPort master)\n{\n    initPoolLock.lock();\n\n    try\n    {\n        if (!master.equals(currentMaster))\n        {\n            currentMaster = master;\n\n            ConnectionPool newPool = createNodePool(currentMaster);\n\n            ConnectionPool existingPool = pool;\n            pool = newPool;\n            LOG.info(\"Created connection pool to master at {}.\", master);\n            if (clientSideCache != null)\n            {\n                clientSideCache.flush();\n            }\n\n            if (existingPool != null)\n            {\n                // although we clear the pool, we still have to check the returned object in getResource,\n                // this call only clears idle instances, not borrowed instances\n                // existingPool.clear(); // necessary??\n                existingPool.close();\n            }\n        }\n    }\n    finally\n    {\n        initPoolLock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "125", "src_id": "M361", "code": "\nprivate static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n\ttry {\n\t\tif (!isValidJakartaMailPart(part)) {\n\t\t\tlog.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n\t\t\treturn;\n\t\t}\n\t\tClass<?> partClass = part.getClass();\n\t\tMethod isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n\t\tMethod getContent = partClass.getMethod(\"getContent\");\n\t\tMethod getDisposition = partClass.getMethod(\"getDisposition\");\n\t\tMethod getFileName = partClass.getMethod(\"getFileName\");\n\t\tMethod getContentType = partClass.getMethod(\"getContentType\");\n\t\tMethod getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n\t\tObject disposition = getDisposition.invoke(part);\n\t\tString filename = (String) getFileName.invoke(part);\n\t\tString contentType = (String) getContentType.invoke(part);\n\n\t\tif ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n\t\t\tcontent.setTextBody((String) getContent.invoke(part));\n\t\t} else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n\t\t\tcontent.setHtmlBody((String) getContent.invoke(part));\n\t\t} else if (\"attachment\".equalsIgnoreCase((String) disposition)\n\t\t\t\t|| (filename != null && !filename.trim().isEmpty())) {\n\t\t\tcontent.setAttachmentCount(content.getAttachmentCount() + 1);\n\n\t\t\t// Always extract basic attachment metadata for display\n\t\t\tif (filename != null && !filename.trim().isEmpty()) {\n\t\t\t\t// Create attachment with metadata only\n\t\t\t\tEmailAttachment attachment = new EmailAttachment();\n\t\t\t\t// Apply MIME decoding to filename to handle encoded attachment names\n\t\t\t\tattachment.setFilename(safeMimeDecode(filename));\n\t\t\t\tattachment.setContentType(contentType);\n\n\t\t\t\t// Check if it's an embedded image\n\t\t\t\tString[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n\t\t\t\tif (contentIdHeaders != null && contentIdHeaders.length > 0) {\n\t\t\t\t\tattachment.setEmbedded(true);\n\t\t\t\t\t// Store the Content-ID, removing angle brackets if present\n\t\t\t\t\tString contentId = contentIdHeaders[0];\n\t\t\t\t\tif (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n\t\t\t\t\t\tcontentId = contentId.substring(1, contentId.length() - 1);\n\t\t\t\t\t}\n\t\t\t\t\tattachment.setContentId(contentId);\n\t\t\t\t}\n\n\t\t\t\t// Extract attachment data if attachments should be included OR if it's an embedded image\n\t\t\t\tif ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject attachmentContent = getContent.invoke(part);\n\t\t\t\t\t\tbyte[] attachmentData = null;\n\n\t\t\t\t\t\tif (attachmentContent instanceof java.io.InputStream inputStream) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tattachmentData = inputStream.readAllBytes();\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\tlog.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (attachmentContent instanceof byte[] byteArray) {\n\t\t\t\t\t\t\tattachmentData = byteArray;\n\t\t\t\t\t\t} else if (attachmentContent instanceof String stringContent) {\n\t\t\t\t\t\t\tattachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (attachmentData != null) {\n\t\t\t\t\t\t\t// Check size limit (use default 10MB if request is null)\n\t\t\t\t\t\t\tlong maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n\t\t\t\t\t\t\tlong maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n\t\t\t\t\t\t\tif (attachmentData.length <= maxSizeBytes) {\n\t\t\t\t\t\t\t\tattachment.setData(attachmentData);\n\t\t\t\t\t\t\t\tattachment.setSizeBytes(attachmentData.length);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// For embedded images, always include data regardless of size\n\t\t\t\t\t\t\t\t// to ensure inline display works\n\t\t\t\t\t\t\t\tif (attachment.isEmbedded()) {\n\t\t\t\t\t\t\t\t\tattachment.setData(attachmentData);\n\t\t\t\t\t\t\t\t\tattachment.setSizeBytes(attachmentData.length);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Still show attachment info even if too large\n\t\t\t\t\t\t\t\t\tattachment.setSizeBytes(attachmentData.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tlog.warn(\"Error extracting attachment data: {}\", e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add attachment to the list for display (with or without data)\n\t\t\t\tcontent.getAttachments().add(attachment);\n\t\t\t}\n\t\t} else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n\t\t\t// Handle nested multipart content\n\t\t\ttry {\n\t\t\t\tObject multipartContent = getContent.invoke(part);\n\t\t\t\tClass<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n\t\t\t\tif (multipartClass.isInstance(multipartContent)) {\n\t\t\t\t\tprocessMultipartAdvanced(multipartContent, content, request);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"Error processing multipart content: {}\", e.getMessage());\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t\tlog.warn(\"Error processing multipart part: {}\", e.getMessage());\n\t}\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "126", "src_id": "M343", "code": "\nprivate static EmailContent extractEmailContentAdvanced(byte[] emlBytes, EmlToPdfRequest request) {\n\ttry {\n\t\t// Use Jakarta Mail for processing\n\t\tClass<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n\t\tClass<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n\n\t\tMethod getDefaultInstance = sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n\t\tObject session = getDefaultInstance.invoke(null, new Properties());\n\n\t\t// Cast the session object to the proper type for the constructor\n\t\tClass<?>[] constructorArgs = new Class<?>[] { sessionClass, InputStream.class };\n\t\tConstructor<?> mimeMessageConstructor = mimeMessageClass.getConstructor(constructorArgs);\n\t\tObject message = mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n\n\t\treturn extractEmailContentAdvanced(message, request);\n\t} catch (ReflectiveOperationException e) {\n\t\t// Create basic EmailContent from basic processing\n\t\tEmailContent content = new EmailContent();\n\t\tcontent.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n\t\treturn content;\n\t}\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "127", "src_id": "M356", "code": "\nprivate static void appendEnhancedStyles(StringBuilder html) {\n\tint fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n\tString textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n\tString backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n\tString borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n\thtml.append(\"body {\\n\");\n\thtml.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n\thtml.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n\thtml.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n\thtml.append(\"  color: \").append(textColor).append(\";\\n\");\n\thtml.append(\"  margin: 0;\\n\");\n\thtml.append(\"  padding: 16px;\\n\");\n\thtml.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n\thtml.append(\"}\\n\\n\");\n\n\thtml.append(\".email-container {\\n\");\n\thtml.append(\"  width: 100%;\\n\");\n\thtml.append(\"  max-width: 100%;\\n\");\n\thtml.append(\"  margin: 0 auto;\\n\");\n\thtml.append(\"}\\n\\n\");\n\n\thtml.append(\".email-header {\\n\");\n\thtml.append(\"  padding-bottom: 10px;\\n\");\n\thtml.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n\thtml.append(\"  margin-bottom: 10px;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".email-header h1 {\\n\");\n\thtml.append(\"  margin: 0 0 10px 0;\\n\");\n\thtml.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n\thtml.append(\"  font-weight: bold;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".email-meta div {\\n\");\n\thtml.append(\"  margin-bottom: 2px;\\n\");\n\thtml.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n\thtml.append(\"}\\n\\n\");\n\n\thtml.append(\".email-body {\\n\");\n\thtml.append(\"  word-wrap: break-word;\\n\");\n\thtml.append(\"}\\n\\n\");\n\n\thtml.append(\".attachment-section {\\n\");\n\thtml.append(\"  margin-top: 15px;\\n\");\n\thtml.append(\"  padding: 10px;\\n\");\n\thtml.append(\"  background-color: \").append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\");\n\thtml.append(\"  border: 1px solid \").append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\");\n\thtml.append(\"  border-radius: 3px;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-section h3 {\\n\");\n\thtml.append(\"  margin: 0 0 8px 0;\\n\");\n\thtml.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-item {\\n\");\n\thtml.append(\"  padding: 5px 0;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-icon {\\n\");\n\thtml.append(\"  margin-right: 5px;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-details, .attachment-type {\\n\");\n\thtml.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n\thtml.append(\"  color: #555555;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n\thtml.append(\"  margin-top: 8px;\\n\");\n\thtml.append(\"  padding: 6px;\\n\");\n\thtml.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n\thtml.append(\"  border-radius: 3px;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-inclusion-note {\\n\");\n\thtml.append(\"  background-color: #e6ffed;\\n\");\n\thtml.append(\"  border: 1px solid #d4f7dc;\\n\");\n\thtml.append(\"  color: #006420;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-info-note {\\n\");\n\thtml.append(\"  background-color: #fff9e6;\\n\");\n\thtml.append(\"  border: 1px solid #fff0c2;\\n\");\n\thtml.append(\"  color: #664d00;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-link-container {\\n\");\n\thtml.append(\"  display: flex;\\n\");\n\thtml.append(\"  align-items: center;\\n\");\n\thtml.append(\"  padding: 8px;\\n\");\n\thtml.append(\"  background-color: #f8f9fa;\\n\");\n\thtml.append(\"  border: 1px solid #dee2e6;\\n\");\n\thtml.append(\"  border-radius: 4px;\\n\");\n\thtml.append(\"  margin: 4px 0;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-link-container:hover {\\n\");\n\thtml.append(\"  background-color: #e9ecef;\\n\");\n\thtml.append(\"}\\n\\n\");\n\thtml.append(\".attachment-note {\\n\");\n\thtml.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n\thtml.append(\"  color: #6c757d;\\n\");\n\thtml.append(\"  font-style: italic;\\n\");\n\thtml.append(\"  margin-left: 8px;\\n\");\n\thtml.append(\"}\\n\\n\");\n\n\t// Basic image styling: ensure images are responsive but not overly constrained.\n\thtml.append(\"img {\\n\");\n\thtml.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n\thtml.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n\thtml.append(\"  display: block;\\n\"); // Avoid extra space below images\n\thtml.append(\"}\\n\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "128", "src_id": "M348", "code": "\nprivate static String extractBasicHeader(String emlContent, String headerName) {\n\ttry {\n\t\tString[] lines = emlContent.split(\"\\r?\\n\");\n\t\tfor (int i = 0; i < lines.length; i++) {\n\t\t\tString line = lines[i];\n\t\t\tif (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n\t\t\t\tStringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n\t\t\t\t// Handle multi-line headers\n\t\t\t\tfor (int j = i + 1; j < lines.length; j++) {\n\t\t\t\t\tif (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n\t\t\t\t\t\tvalue.append(\" \").append(lines[j].trim());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Apply MIME header decoding\n\t\t\t\treturn safeMimeDecode(value.toString());\n\t\t\t}\n\t\t\tif (line.trim().isEmpty()) break;\n\t\t}\n\t} catch (RuntimeException e) {\n\t\tlog.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n\t}\n\treturn \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "129", "src_id": "M454", "code": "\n    private void setupMainFrame() {\n        frame = new JFrame(\"Stirling-PDF\");\n        frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n        frame.setUndecorated(true);\n        frame.setOpacity(0.0f);\n\n        final JPanel contentPane = new JPanel(new BorderLayout());\n        contentPane.setDoubleBuffered(true);\n        contentPane.add(browser.getUIComponent(), BorderLayout.CENTER);\n        frame.setContentPane(contentPane);\n\n        frame.addWindowListener(new java.awt.event.WindowAdapter() {\n            @Override\n            public void windowClosing(java.awt.event.WindowEvent windowEvent) {\n                cleanup();\n                System.exit(0);\n            }\n        });\n\n        frame.setSize(UIScaling.scaleWidth(1280), UIScaling.scaleHeight(800));\n        frame.setLocationRelativeTo(null);\n\n        loadIcon();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "130", "src_id": "M604", "code": "\n    @PostMapping(value = \"/form-fields\", consumes = \"multipart/form-data\")\n    @Operation(\n            summary = \"Get form field information\",\n            description = \"Returns count and details of form fields. Input:PDF Output:JSON Type:SISO\")\n    public Map<String, Object> getFormFields(@ModelAttribute PDFFile file) throws IOException {\n        try (PDDocument document = pdfDocumentFactory.load(file.getFileInput())) {\n            final Map<String, Object> formInfo = new HashMap<>();\n            final PDAcroForm form = document.getDocumentCatalog().getAcroForm();\n\n            if (form == null) {\n                formInfo.put(\"fieldCount\", 0);\n                formInfo.put(\"hasXFA\", false);\n                formInfo.put(\"isSignaturesExist\", false);\n                return formInfo;\n            }\n\n            formInfo.put(\"fieldCount\", form.getFields().size());\n            formInfo.put(\"hasXFA\", form.hasXFA());\n            formInfo.put(\"isSignaturesExist\", form.isSignaturesExist());\n            return formInfo;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "131", "src_id": "M443", "code": "\n    private void checkAndRefreshExplorer() {\n        if (!IS_WINDOWS) return;\n        if (timeAt90Percent != -1) return;\n\n        timeAt90Percent = System.currentTimeMillis();\n        stuckTimer = new Timer(1000, e -> {\n            final long currentTime = System.currentTimeMillis();\n            if (currentTime - timeAt90Percent > stuckThreshold) {\n                try {\n                    log.debug(\"Attempting Windows explorer refresh due to 90% stuck state\");\n                    final String currentDir = System.getProperty(\"user.dir\");\n\n                    // Store current explorer PIDs before we start new one\n                    final Set<String> existingPids = new HashSet<>();\n                    final ProcessBuilder listExplorer = new ProcessBuilder(\n                            \"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\",\n                            \"get\", \"ProcessId\", \"/format:csv\");\n                    final Process process = listExplorer.start();\n                    final BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                    String line;\n                    while ((line = BoundedLineReader.readLine(reader, 5_000_000)) != null) {\n                        if (line.matches(\".*\\\\d+.*\")) { // Contains numbers\n                            final String[] parts = line.trim().split(\",\");\n                            if (parts.length >= 2) {\n                                existingPids.add(parts[parts.length - 1].trim());\n                            }\n                        }\n                    }\n                    process.waitFor(2, TimeUnit.SECONDS);\n\n                    // Start new explorer\n                    final ProcessBuilder pb = new ProcessBuilder(\n                            \"cmd\", \"/c\", \"start\", \"/min\", \"/b\", \"explorer.exe\", currentDir);\n                    pb.redirectErrorStream(true);\n                    explorerProcess = pb.start();\n\n                    // Schedule cleanup\n                    final Timer cleanupTimer = new Timer(2000, cleanup -> {\n                        try {\n                            final ProcessBuilder findNewExplorer = new ProcessBuilder(\n                                    \"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\",\n                                    \"get\", \"ProcessId\", \"/format:csv\");\n                            final Process newProcess = findNewExplorer.start();\n                            final BufferedReader newReader = new BufferedReader(\n                                    new InputStreamReader(newProcess.getInputStream()));\n                            String newLine;\n                            while ((newLine = BoundedLineReader.readLine(newReader, 5_000_000)) != null) {\n                                if (newLine.matches(\".*\\\\d+.*\")) {\n                                    final String[] parts = newLine.trim().split(\",\");\n                                    if (parts.length >= 2) {\n                                        final String pid = parts[parts.length - 1].trim();\n                                        if (!existingPids.contains(pid)) {\n                                            log.debug(\"Found new explorer.exe with PID: \" + pid);\n                                            final ProcessBuilder killProcess = new ProcessBuilder(\n                                                    \"taskkill\", \"/PID\", pid, \"/F\");\n                                            killProcess.redirectErrorStream(true);\n                                            final Process killResult = killProcess.start();\n                                            killResult.waitFor(2, TimeUnit.SECONDS);\n                                            log.debug(\"Explorer process terminated: \" + pid);\n                                        }\n                                    }\n                                }\n                            }\n                            newProcess.waitFor(2, TimeUnit.SECONDS);\n                        } catch (Exception ex) {\n                            log.error(\"Error cleaning up Windows explorer process\", ex);\n                        }\n                    });\n                    cleanupTimer.setRepeats(false);\n                    cleanupTimer.start();\n                    stuckTimer.stop();\n                } catch (Exception ex) {\n                    log.error(\"Error refreshing Windows explorer\", ex);\n                }\n            }\n        });\n        stuckTimer.setRepeats(true);\n        stuckTimer.start();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "132", "src_id": "M542", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/compress-pdf\")\n    @Operation(\n            summary = \"Optimize PDF file\",\n            description = \"This endpoint accepts a PDF file and optimizes it based on the provided parameters. Input:PDF Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> optimizePdf(@ModelAttribute OptimizePdfRequest request) throws Exception {\n        final MultipartFile inputFile = request.getFileInput();\n        Integer optimizeLevel = request.getOptimizeLevel();\n        final String expectedOutputSizeString = request.getExpectedOutputSize();\n        final Boolean convertToGrayscale = request.getGrayscale();\n\n        if (expectedOutputSizeString == null && optimizeLevel == null) {\n            throw new Exception(\"Both expected output size and optimize level are not specified\");\n        }\n\n        long expectedOutputSize = 0L;\n        boolean autoMode = false;\n        if (expectedOutputSizeString != null && expectedOutputSizeString.length() > 1) {\n            expectedOutputSize = GeneralUtils.convertSizeToBytes(expectedOutputSizeString);\n            autoMode = true;\n        }\n\n        // Create initial input file\n        final Path originalFile = Files.createTempFile(\"original_\", \".pdf\");\n        inputFile.transferTo(originalFile.toFile());\n        final long inputFileSize = Files.size(originalFile);\n\n        Path currentFile = Files.createTempFile(\"working_\", \".pdf\");\n        Files.copy(originalFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n\n        // Keep track of all temporary files for cleanup\n        final List<Path> tempFiles = new ArrayList<>();\n        tempFiles.add(originalFile);\n        tempFiles.add(currentFile);\n\n        try {\n            int level = optimizeLevel != null ? optimizeLevel : 1;\n\n            if (autoMode) {\n                final double sizeReductionRatio = expectedOutputSize / (double) inputFileSize;\n                level = determineOptimizeLevel(sizeReductionRatio);\n            }\n\n            boolean sizeMet = false;\n            boolean imageCompressionApplied = false;\n            boolean externalCompressionApplied = false;\n\n            while (!sizeMet && level <= 9) {\n                // Apply external compression first\n                if (!externalCompressionApplied) {\n                    boolean ghostscriptSuccess = false;\n\n                    if (isGhostscriptEnabled()) {\n                        try {\n                            applyGhostscriptCompression(request, level, currentFile, tempFiles);\n                            log.info(\"Ghostscript compression applied successfully\");\n                            ghostscriptSuccess = true;\n                        } catch (IOException e) {\n                            log.warn(\"Ghostscript compression failed, trying fallback methods\");\n                        }\n                    }\n\n                    if (!ghostscriptSuccess && isQpdfEnabled() && level <= 3) {\n                        try {\n                            applyQpdfCompression(request, level, currentFile, tempFiles);\n                            log.info(\"QPDF compression applied successfully\");\n                        } catch (IOException e) {\n                            log.warn(\"QPDF compression also failed\");\n                        }\n                    }\n\n                    if (!ghostscriptSuccess && !isQpdfEnabled()) {\n                        log.info(\"No external compression tools available, using image compression only\");\n                    }\n\n                    externalCompressionApplied = true;\n\n                    if (ghostscriptSuccess) {\n                        imageCompressionApplied = true;\n                    }\n                }\n\n                // Apply image compression for levels 4+ only if Ghostscript didn't run\n                if ((level >= 4 || Boolean.TRUE.equals(convertToGrayscale)) && !imageCompressionApplied) {\n                    final double scaleFactor = switch (level) {\n                        case 4 -> 0.95;\n                        case 5 -> 0.9;\n                        case 6 -> 0.8;\n                        case 7 -> 0.7;\n                        case 8 -> 0.65;\n                        case 9 -> 0.5;\n                        default -> 1.0;\n                    };\n\n                    log.info(\"Applying image compression with scale factor: {}\", scaleFactor);\n                    final Path compressedImageFile = compressImagesInPDF(\n                            currentFile,\n                            scaleFactor,\n                            0.7f,\n                            Boolean.TRUE.equals(convertToGrayscale));\n\n                    tempFiles.add(compressedImageFile);\n                    currentFile = compressedImageFile;\n                    imageCompressionApplied = true;\n                }\n\n                // Check if target size reached or not in auto mode\n                final long outputFileSize = Files.size(currentFile);\n                if (outputFileSize <= expectedOutputSize || !autoMode) {\n                    sizeMet = true;\n                } else {\n                    final int newOptimizeLevel = incrementOptimizeLevel(level, outputFileSize, expectedOutputSize);\n\n                    if (newOptimizeLevel == level) {\n                        if (autoMode) {\n                            log.info(\"Maximum optimization level reached without meeting target size.\");\n                            sizeMet = true;\n                        }\n                    } else {\n                        imageCompressionApplied = false;\n                        externalCompressionApplied = false;\n                        level = newOptimizeLevel;\n                    }\n                }\n            }\n\n            // Use original if optimized file is somehow larger\n            final long finalFileSize = Files.size(currentFile);\n            if (finalFileSize >= inputFileSize) {\n                log.warn(\"Optimized file is larger than the original. Using the original file instead.\");\n                currentFile = originalFile;\n            }\n\n            final String outputFilename = Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                    .replaceFirst(\"[.][^.]+$\", \"\") + \"_Optimized.pdf\";\n\n            return WebResponseUtils.pdfDocToWebResponse(\n                    pdfDocumentFactory.load(currentFile.toFile()), outputFilename);\n        } finally {\n            for (Path tempFile : tempFiles) {\n                try {\n                    Files.deleteIfExists(tempFile);\n                } catch (IOException e) {\n                    log.warn(\"Failed to delete temporary file: \" + tempFile, e);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "133", "src_id": "M625", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        final MultipartFile inputFile = request.getFileInput();\n        final boolean readonly = true;\n\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n            final ObjectMapper objectMapper = new ObjectMapper();\n            final ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n            // Metadata using PDFBox\n            final PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            final ObjectNode metadata = objectMapper.createObjectNode();\n            final ObjectNode basicInfo = objectMapper.createObjectNode();\n            final ObjectNode docInfoNode = objectMapper.createObjectNode();\n            final ObjectNode compliancy = objectMapper.createObjectNode();\n            final ObjectNode encryption = objectMapper.createObjectNode();\n            final ObjectNode other = objectMapper.createObjectNode();\n\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n\n            // Total file size of the PDF\n            final long fileSizeInBytes = inputFile.getSize();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n            // Number of words, paragraphs, and images in the entire document\n            final String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            final String[] words = fullText.split(\"\\\\s+\");\n            final int wordCount = words.length;\n            final int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n\n            final int charCount = fullText.length();\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            boolean hasCompression = false;\n            final String compressionType = \"None\";\n            basicInfo.put(\"Compression\", hasCompression);\n            if (hasCompression) basicInfo.put(\"CompressionType\", compressionType);\n\n            final String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n            final PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            final String pageMode = catalog.getPageMode().name();\n\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n            final PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            final ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n\n            final ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n\n            // embedded files\n            if (catalog.getNames() != null) {\n                final PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                final ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n\n                if (efTree != null) {\n                    final Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            final ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n                            final PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n\n            // attachments\n            final ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        final ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n\n            // Javascript\n            final PDDocumentNameDictionary namesDict = catalog.getNames();\n            final ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                final PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        final Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            final ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n\n                            final PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                final String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n\n            // Layers\n            final PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            final ArrayNode layersArray = objectMapper.createArrayNode();\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    final ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n            other.set(\"Layers\", layersArray);\n\n            // Structure Tree\n            final PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            try {\n                if (structureTreeRoot != null) {\n                    final ArrayNode structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                }\n            } catch (Exception e) {\n                log.error(\"exception\", e);\n            }\n\n            final boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n            final boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n            final boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n            final boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n            final boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n            final boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\");\n            final boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\");\n\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n            final PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            final ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n            final PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            String xmpString = null;\n            if (pdMetadata != null) {\n                try (COSInputStream is = pdMetadata.createInputStream()) {\n                    final DomXmpParser domXmpParser = new DomXmpParser();\n                    final XMPMetadata xmpMeta = domXmpParser.parse(is);\n\n                    final ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    new XmpSerializer().serialize(xmpMeta, os, true);\n                    xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                } catch (XmpParsingException e) {\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        final byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", xmpString);\n\n            if (pdfBoxDoc.isEncrypted()) {\n                encryption.put(\"IsEncrypted\", true);\n                final PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n            } else {\n                encryption.put(\"IsEncrypted\", false);\n            }\n\n            final ObjectNode permissionsNode = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n\n            final ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                final ObjectNode pageInfo = objectMapper.createObjectNode();\n                final PDPage page = pdfBoxDoc.getPage(pageNum);\n\n                final PDRectangle mediaBox = page.getMediaBox();\n                final float width = mediaBox.getWidth();\n                final float height = mediaBox.getHeight();\n\n                final ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n\n                final PDRectangle cropBox = page.getCropBox();\n                pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n\n                final PDRectangle bleedBox = page.getBleedBox();\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n\n                final PDRectangle trimBox = page.getTrimBox();\n                pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n\n                final PDRectangle artBox = page.getArtBox();\n                pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n\n                final PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n                final String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length());\n\n                final List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) subtypeCount++;\n                    if (annotation.getContents() != null) contentsCount++;\n                }\n                final ObjectNode annotationsObject = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n\n                final ArrayNode imagesArray = objectMapper.createArrayNode();\n                final PDResources resources = page.getResources();\n                for (COSName name : resources.getXObjectNames()) {\n                    final PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        final ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null\n                                && image.getMetadata().getFile() != null\n                                && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n\n                final ArrayNode linksArray = objectMapper.createArrayNode();\n                final Set<String> uniqueURIs = new HashSet<>();\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation) {\n                        if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                            final String uri = uriAction.getURI();\n                            uniqueURIs.add(uri);\n                        }\n                    }\n                }\n                for (String uri : uniqueURIs) {\n                    final ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n                pageInfo.set(\"Links\", linksArray);\n\n                final ArrayNode fontsArray = objectMapper.createArrayNode();\n                final Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                for (COSName fontName : resources.getFontNames()) {\n                    final PDFont font = resources.getFont(fontName);\n                    final ObjectNode fontNode = objectMapper.createObjectNode();\n\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n\n                    final PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        final int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n\n                    final String uniqueKey = fontNode.toString();\n                    if (uniqueFontsMap.containsKey(uniqueKey)) {\n                        final ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        final int count = existingFontNode.get(\"Count\").asInt() + 1;\n                        existingFontNode.put(\"Count\", count);\n                    } else {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    }\n                }\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", fontsArray);\n\n                final ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                final Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n                for (COSName name : colorSpaceNames) {\n                    final PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        final PDStream iccData = iccBased.getPDStream();\n                        final byte[] iccBytes = iccData.toByteArray();\n                        final ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n                final Map<String, Integer> xObjectCountMap = new HashMap<>();\n                for (COSName name : resources.getXObjectNames()) {\n                    final PDXObject xObject = resources.getXObject(name);\n                    final String xObjectType;\n                    if (xObject instanceof PDImageXObject) {\n                        xObjectType = \"Image\";\n                    } else if (xObject instanceof PDFormXObject) {\n                        xObjectType = \"Form\";\n                    } else {\n                        xObjectType = \"Other\";\n                    }\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                final ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n                final ArrayNode multimediaArray = objectMapper.createArrayNode();\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        final ObjectNode multimediaNode = objectMapper.createObjectNode();\n                        multimediaArray.add(multimediaNode);\n                    }\n                }\n                pageInfo.set(\"Multimedia\", multimediaArray);\n\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Encryption\", encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode);\n            jsonOutput.set(\"Other\", other);\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n            final String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(\n                    jsonString.getBytes(StandardCharsets.UTF_8),\n                    \"response.json\",\n                    MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "134", "src_id": "M518", "code": "\n    public static boolean isBlankImage(BufferedImage image, int threshold, double whitePercent, int blurSize) {\n        if (image == null) {\n            log.info(\"Error: Image is null\");\n            return false;\n        }\n\n        int whitePixels = 0;\n        final int totalPixels = image.getWidth() * image.getHeight();\n\n        for (int i = 0; i < image.getHeight(); i++) {\n            for (int j = 0; j < image.getWidth(); j++) {\n                final int color = image.getRGB(j, i) & 0xFF;\n                if (color >= 255 - threshold) {\n                    whitePixels++;\n                }\n            }\n        }\n\n        final double whitePixelPercentage = (whitePixels / (double) totalPixels) * 100;\n        log.info(String.format(\"Page has white pixel percent of %.2f%%\", whitePixelPercentage));\n\n        return whitePixelPercentage >= whitePercent;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "135", "src_id": "M483", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/filter-page-count\")\n    @Operation(\n            summary = \"Checks if a PDF is greater, less or equal to a setPageCount\",\n            description = \"Input:PDF Output:Boolean Type:SISO\")\n    public ResponseEntity<byte[]> pageCount(@ModelAttribute PDFComparisonAndCount request)\n            throws IOException, InterruptedException {\n        final MultipartFile inputFile = request.getFileInput();\n        final int pageCount = request.getPageCount();\n        final String comparator = request.getComparator();\n\n        final PDDocument document = pdfDocumentFactory.load(inputFile);\n        final int actualPageCount = document.getNumberOfPages();\n\n        boolean valid;\n        switch (comparator) {\n            case \"Greater\":\n                valid = actualPageCount > pageCount;\n                break;\n            case \"Equal\":\n                valid = actualPageCount == pageCount;\n                break;\n            case \"Less\":\n                valid = actualPageCount < pageCount;\n                break;\n            default:\n                throw ExceptionUtils.createInvalidArgumentException(\"comparator\", comparator);\n        }\n\n        if (valid) return WebResponseUtils.multiPartFileToWebResponse(inputFile);\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "136", "src_id": "M475", "code": "\n    private void handleSplitBySize(PDDocument sourceDocument, long maxBytes, ZipOutputStream zipOut, String baseFilename)\n            throws IOException {\n        log.debug(\"Starting handleSplitBySize with maxBytes={}\", maxBytes);\n\n        PDDocument currentDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(sourceDocument);\n        int fileIndex = 1;\n        final int totalPages = sourceDocument.getNumberOfPages();\n        int pageAdded = 0;\n\n        final int baseCheckFrequency = 5;\n\n        for (int pageIndex = 0; pageIndex < totalPages; pageIndex++) {\n            final PDPage page = sourceDocument.getPage(pageIndex);\n            log.debug(\"Processing page {} of {}\", pageIndex + 1, totalPages);\n\n            final PDPage newPage = new PDPage(page.getCOSObject());\n            currentDoc.addPage(newPage);\n            pageAdded++;\n\n            final boolean shouldCheckSize =\n                    (pageAdded % baseCheckFrequency == 0) || (pageIndex == totalPages - 1) || (pageAdded >= 20);\n\n            if (shouldCheckSize) {\n                log.debug(\"Performing size check after {} pages\", pageAdded);\n                final ByteArrayOutputStream checkSizeStream = new ByteArrayOutputStream();\n                currentDoc.save(checkSizeStream);\n                final long actualSize = checkSizeStream.size();\n                log.debug(\"Current document size: {} bytes (max: {} bytes)\", actualSize, maxBytes);\n\n                if (actualSize > maxBytes) {\n                    if (currentDoc.getNumberOfPages() > 1) {\n                        currentDoc.removePage(currentDoc.getNumberOfPages() - 1);\n                        pageIndex--;\n                        log.debug(\"Size limit exceeded - removed last page\");\n                    }\n\n                    log.debug(\"Saving document with {} pages as part {}\", currentDoc.getNumberOfPages(), fileIndex);\n                    saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n                    currentDoc = new PDDocument();\n                    pageAdded = 0;\n                } else if (pageIndex < totalPages - 1) {\n                    if (actualSize < maxBytes * 0.75 && pageAdded > 0) {\n                        final int pagesToLookAhead = Math.min(5, totalPages - pageIndex - 1);\n                        if (pagesToLookAhead > 0) {\n                            log.debug(\"Testing {} upcoming pages for potential addition\", pagesToLookAhead);\n\n                            final PDDocument testDoc = new PDDocument();\n                            for (int i = 0; i < currentDoc.getNumberOfPages(); i++) {\n                                testDoc.addPage(new PDPage(currentDoc.getPage(i).getCOSObject()));\n                            }\n\n                            int extraPagesAdded = 0;\n                            for (int i = 0; i < pagesToLookAhead; i++) {\n                                final int testPageIndex = pageIndex + 1 + i;\n                                final PDPage testPage = sourceDocument.getPage(testPageIndex);\n                                testDoc.addPage(new PDPage(testPage.getCOSObject()));\n\n                                final ByteArrayOutputStream testStream = new ByteArrayOutputStream();\n                                testDoc.save(testStream);\n                                final long testSize = testStream.size();\n\n                                if (testSize <= maxBytes) {\n                                    extraPagesAdded++;\n                                    log.debug(\"Test: Can add page {} (size would be {})\", testPageIndex + 1, testSize);\n                                } else {\n                                    log.debug(\"Test: Cannot add page {} (size would be {})\", testPageIndex + 1, testSize);\n                                    break;\n                                }\n                            }\n\n                            testDoc.close();\n\n                            if (extraPagesAdded > 0) {\n                                log.debug(\"Adding {} verified pages ahead\", extraPagesAdded);\n                                for (int i = 0; i < extraPagesAdded; i++) {\n                                    final int extraPageIndex = pageIndex + 1 + i;\n                                    final PDPage extraPage = sourceDocument.getPage(extraPageIndex);\n                                    currentDoc.addPage(new PDPage(extraPage.getCOSObject()));\n                                }\n                                pageIndex += extraPagesAdded;\n                                pageAdded += extraPagesAdded;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (currentDoc.getNumberOfPages() > 0) {\n            log.debug(\"Saving final document with {} pages as part {}\", currentDoc.getNumberOfPages(), fileIndex);\n            saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n        }\n\n        log.debug(\"Completed handleSplitBySize with {} document parts created\", fileIndex - 1);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "137", "src_id": "M291", "code": "\n    public static File convertMultipartFileToFile(MultipartFile multipartFile) throws IOException {\n        String customTempDir = System.getenv(\"STIRLING_TEMPFILES_DIRECTORY\");\n        if (customTempDir == null || customTempDir.isEmpty()) {\n            customTempDir = System.getProperty(\"stirling.tempfiles.directory\");\n        }\n\n        final Path tempDir = (customTempDir != null && !customTempDir.isEmpty())\n                ? Path.of(customTempDir)\n                : Path.of(System.getProperty(\"java.io.tmpdir\"), \"stirling-pdf\");\n\n        if (!Files.exists(tempDir)) {\n            Files.createDirectories(tempDir);\n        }\n\n        final File tempFile = Files.createTempFile(tempDir, \"stirling-pdf-\", null).toFile();\n\n        try (InputStream inputStream = multipartFile.getInputStream();\n             FileOutputStream outputStream = new FileOutputStream(tempFile)) {\n\n            final byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n        }\n        return tempFile;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "138", "src_id": "M254", "code": "\n    private void cleanupTempFiles() {\n        try {\n            final Set<Path> files = registry.getAllRegisteredFiles();\n            int deletedCount = 0;\n\n            for (Path file : files) {\n                try {\n                    if (Files.exists(file)) {\n                        Files.deleteIfExists(file);\n                        deletedCount++;\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Failed to delete temp file during shutdown: {}\", file, e);\n                }\n            }\n\n            final Set<Path> directories = registry.getTempDirectories();\n            for (Path dir : directories) {\n                try {\n                    if (Files.exists(dir)) {\n                        GeneralUtils.deleteDirectory(dir);\n                        deletedCount++;\n                    }\n                } catch (IOException e) {\n                    log.warn(\"Failed to delete temp directory during shutdown: {}\", dir, e);\n                }\n            }\n\n            log.info(\"Shutdown cleanup complete. Deleted {} temporary files/directories\", deletedCount);\n            registry.clear();\n        } catch (Exception e) {\n            log.error(\"Error during shutdown cleanup\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "139", "src_id": "M749", "code": "\nprivate Object convertAttrValue(String attributeName, Object originAttrValue) {\n    Object attrValue = originAttrValue;\n    try {\n        if (originAttrValue instanceof ObjectName) {\n            attrValue = String.valueOf(originAttrValue);\n        } else if (attrValue instanceof CompositeData) {\n            // MBean java.lang:type=MemoryPool,name=*\n            CompositeData compositeData = (CompositeData) attrValue;\n            attrValue = convertCompositeData(attributeName, compositeData);\n        } else if (attrValue instanceof CompositeData[]) {\n            // MBean com.sun.management:type=HotSpotDiagnostic\n            CompositeData[] compositeDataArray = (CompositeData[]) attrValue;\n            List<Map<String, Object>> dataList = new ArrayList<>(compositeDataArray.length);\n            for (CompositeData compositeData : compositeDataArray) {\n                dataList.add(convertCompositeData(attributeName, compositeData));\n            }\n            attrValue = dataList;\n        } else if (attrValue instanceof TabularData) {\n            // MBean java.lang:type=GarbageCollector,name=*\n            TabularData tabularData = (TabularData) attrValue;\n            @SuppressWarnings(\"unchecked\")\n            Collection<CompositeData> compositeDataList =\n                    (Collection<CompositeData>) tabularData.values();\n            List<Map<String, Object>> dataList = new ArrayList<>(compositeDataList.size());\n            for (CompositeData compositeData : compositeDataList) {\n                dataList.add(convertCompositeData(attributeName, compositeData));\n            }\n            attrValue = dataList;\n        }\n    } catch (Throwable e) {\n        logger.error(\"convert mbean attribute error, attribute: {}={}\", attributeName, originAttrValue, e);\n        attrValue = String.valueOf(originAttrValue);\n    }\n    return attrValue;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "140", "src_id": "M397", "code": "\npublic static int getItemCount(ResultModel model) {\n    // If the model implements Countable, let it report its own size\n    if (model instanceof Countable) {\n        return ((Countable) model).size();\n    }\n\n    // For regular models, use reflection to count elements in container-type fields\n    // Cache Field objects to minimize overhead\n    Class<?> modelClass = model.getClass();\n    List<Field> fields = modelFieldMap.get(modelClass.getName());\n    if (fields == null) {\n        fields = new ArrayList<>();\n        Field[] declaredFields = modelClass.getDeclaredFields();\n        for (Field field : declaredFields) {\n            Class<?> fieldClass = field.getType();\n            // Cache fields that are List/Map/Array/Countable for counting later\n            if (Collection.class.isAssignableFrom(fieldClass)\n                    || Map.class.isAssignableFrom(fieldClass)\n                    || Countable.class.isAssignableFrom(fieldClass)\n                    || fieldClass.isArray()) {\n                field.setAccessible(true);\n                fields.add(field);\n            }\n        }\n        List<Field> oldFields = modelFieldMap.putIfAbsent(modelClass.getName(), fields);\n        if (oldFields != null) {\n            fields = oldFields;\n        }\n    }\n\n    // Count items in the model instance\n    int count = 0;\n    try {\n        for (Field field : fields) {\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n            Object value = field.get(model);\n            if (value != null) {\n                if (value instanceof Collection) {\n                    count += ((Collection<?>) value).size();\n                } else if (value.getClass().isArray()) {\n                    count += Array.getLength(value);\n                } else if (value instanceof Map) {\n                    count += ((Map<?, ?>) value).size();\n                } else if (value instanceof Countable) {\n                    count += ((Countable) value).size();\n                }\n            }\n        }\n    } catch (Exception e) {\n        logger.error(\"get item count of result model failed, model: {}\", JSON.toJSONString(model), e);\n    }\n\n    return count > 0 ? count : 1;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "141", "src_id": "M1118", "code": "\npublic void evictSessions() {\n    long now = System.currentTimeMillis();\n    List<Session> toClose = new ArrayList<>();\n    for (Session session : sessions.values()) {\n        // Do not close if there is still a job running (e.g., trace command may wait a long time)\n        // TODO check background job size\n        if (now - session.getLastAccessTime() > sessionTimeoutMillis\n                && session.getForegroundJob() == null) {\n            toClose.add(session);\n        }\n        evictConsumers(session);\n    }\n    for (Session session : toClose) {\n        // Interrupt foreground job\n        Job job = session.getForegroundJob();\n        if (job != null) {\n            job.interrupt();\n        }\n        long timeOutInMinutes = sessionTimeoutMillis / 1000 / 60;\n        String reason = String.format(\"session is inactive for %d min(s).\", timeOutInMinutes);\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) {\n            resultDistributor.appendResult(new MessageModel(reason));\n        }\n        this.removeSession(session.getSessionId());\n        logger.info(\"Removing inactive session: {}, last access time: {}\", session.getSessionId(), session.getLastAccessTime());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "142", "src_id": "M526", "code": "\nprivate TableElement drawTomcatInfo(TomcatInfoVO tomcatInfo) {\n    if (tomcatInfo == null) {\n        return null;\n    }\n\n    // Header\n    TableElement table = new TableElement(1, 1).rightCellPadding(1);\n    table.add(\n            new RowElement()\n                    .style(Decoration.bold.fg(Color.black).bg(Color.white))\n                    .add(\"Tomcat\", \"\"));\n\n    if (tomcatInfo.getConnectorStats() != null) {\n        for (TomcatInfoVO.ConnectorStats connectorStat : tomcatInfo.getConnectorStats()) {\n            table.add(new RowElement().style(Decoration.bold.bold()).add(\"connector\", connectorStat.getName()));\n            table.row(\"QPS\", String.format(\"%.2f\", connectorStat.getQps()));\n            table.row(\"RT(ms)\", String.format(\"%.2f\", connectorStat.getRt()));\n            table.row(\"error/s\", String.format(\"%.2f\", connectorStat.getError()));\n            table.row(\"received/s\", formatBytes(connectorStat.getReceived()));\n            table.row(\"sent/s\", formatBytes(connectorStat.getSent()));\n        }\n    }\n\n    if (tomcatInfo.getThreadPools() != null) {\n        for (TomcatInfoVO.ThreadPool threadPool : tomcatInfo.getThreadPools()) {\n            table.add(new RowElement().style(Decoration.bold.bold()).add(\"threadpool\", threadPool.getName()));\n            table.row(\"busy\", String.valueOf(threadPool.getBusy()));\n            table.row(\"total\", String.valueOf(threadPool.getTotal()));\n        }\n    }\n    return table;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "143", "src_id": "M1130", "code": "\nprivate ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n    boolean oneTimeAccess = session.get(ONETIME_SESSION_KEY) != null;\n\n    try {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<>();\n        body.put(\"command\", commandLine);\n\n        ApiResponse response = new ApiResponse()\n                .setSessionId(session.getSessionId())\n                .setBody(body);\n\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n\n        int lock = session.getLock();\n        PackingResultDistributor packingResultDistributor = null;\n        Job job = null;\n        try {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n\n            packingResultDistributor = new PackingResultDistributorImpl(session);\n            // Distribute result message both to origin session channel and request channel\n            // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n            job = this.createJob(commandLine, session, packingResultDistributor);\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n            job.run();\n\n        } catch (Throwable e) {\n            logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n            response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n            return response;\n        } finally {\n            if (session.getLock() == lock) {\n                session.unLock();\n            }\n        }\n\n        // Wait for job completed or timeout\n        Integer timeout = apiRequest.getExecTimeout();\n        if (timeout == null || timeout <= 0) {\n            timeout = DEFAULT_EXEC_TIMEOUT;\n        }\n        boolean timeExpired = !waitForJob(job, timeout);\n        if (timeExpired) {\n            logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n            job.interrupt();\n            response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n        } else {\n            response.setState(ApiState.SUCCEEDED);\n        }\n\n        // Package results\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        body.put(\"timeExpired\", timeExpired);\n        if (timeExpired) {\n            body.put(\"timeout\", timeout);\n        }\n        body.put(\"results\", packingResultDistributor.getResults());\n\n        return response.setSessionId(session.getSessionId()).setBody(body);\n    } finally {\n        if (oneTimeAccess) {\n            sessionManager.removeSession(session.getSessionId());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "144", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(String.valueOf(info.get(LoggerHelper.name))))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(String.valueOf(info.get(LoggerHelper.classLoader))))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(String.valueOf(info.get(LoggerHelper.classLoaderHash))))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(String.valueOf(info.get(LoggerHelper.level))));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(String.valueOf(info.get(LoggerHelper.effectiveLevel))));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(String.valueOf(info.get(LoggerHelper.config))));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                        label(String.valueOf(info.get(LoggerHelper.additivity))))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                        label(String.valueOf(info.get(LoggerHelper.codeSource))));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders =\n                (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                                label(String.valueOf(appenderInfo.get(LoggerHelper.name))));\n                appendersTable.row(label(LoggerHelper.clazz), label(appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(String.valueOf(info.get(LoggerHelper.classLoader))));\n                appendersTable.row(label(LoggerHelper.classLoaderHash), label(String.valueOf(info.get(LoggerHelper.classLoaderHash))));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(String.valueOf(appenderInfo.get(LoggerHelper.file))));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target), label(String.valueOf(appenderInfo.get(LoggerHelper.target))));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking), label(String.valueOf(appenderInfo.get(LoggerHelper.blocking))));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef), label(String.valueOf(appenderInfo.get(LoggerHelper.appenderRef))));\n                }\n            }\n\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "145", "src_id": "M493", "code": "\nprivate void renderNode(StringBuilder sb, TraceNode node, Ansi highlighted) {\n    // Render cost: [0.366865ms]\n    if (isPrintCost && node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode) node;\n\n        String costStr = renderCost(methodNode);\n        if (node == maxCostNode) {\n            // The node with max cost will be highlighted\n            sb.append(highlighted.a(costStr).reset().toString());\n        } else {\n            sb.append(costStr);\n        }\n    }\n\n    // Render method name\n    if (node instanceof MethodNode) {\n        MethodNode methodNode = (MethodNode) node;\n        // clazz.getName() + \":\" + method.getName() + \"()\"\n        sb.append(methodNode.getClassName()).append(\":\").append(methodNode.getMethodName()).append(\"()\");\n        // #lineNumber\n        if (methodNode.getLineNumber() != -1) {\n            sb.append(\" #\").append(methodNode.getLineNumber());\n        }\n    } else if (node instanceof ThreadNode) {\n        // Render thread info\n        ThreadNode threadNode = (ThreadNode) node;\n        // ts=2020-04-29 10:34:00;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@18b4aac2\n        sb.append(format(\"ts=%s;thread_name=%s;id=%d;is_daemon=%s;priority=%d;TCCL=%s\",\n                DateUtils.formatDateTime(threadNode.getTimestamp()),\n                threadNode.getThreadName(),\n                threadNode.getThreadId(),\n                threadNode.isDaemon(),\n                threadNode.getPriority(),\n                threadNode.getClassloader()));\n\n        // trace_id\n        if (threadNode.getTraceId() != null) {\n            sb.append(\";trace_id=\").append(threadNode.getTraceId());\n        }\n        if (threadNode.getRpcId() != null) {\n            sb.append(\";rpc_id=\").append(threadNode.getRpcId());\n        }\n    } else if (node instanceof ThrowNode) {\n        ThrowNode throwNode = (ThrowNode) node;\n        sb.append(\"throw:\").append(throwNode.getException())\n                .append(\" #\").append(throwNode.getLineNumber())\n                .append(\" [\").append(throwNode.getMessage()).append(\"]\");\n    } else {\n        throw new UnsupportedOperationException(\"unknown trace node: \" + node.getClass());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "146", "src_id": "M355", "code": "\nprivate static String processInlineImages(final String htmlContent, final EmailContent emailContent) {\n    if (htmlContent == null || emailContent == null) {\n        return htmlContent;\n    }\n\n    // Create a map of Content-ID to attachment data\n    final Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n    for (final EmailAttachment attachment : emailContent.getAttachments()) {\n        if (attachment.isEmbedded()\n                && attachment.getContentId() != null\n                && attachment.getData() != null) {\n            contentIdMap.put(attachment.getContentId(), attachment);\n        }\n    }\n\n    if (contentIdMap.isEmpty()) {\n        return htmlContent;\n    }\n\n    // Pattern to match cid: references in img src attributes\n    final Pattern cidPattern = Pattern.compile(\n            \"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\",\n            Pattern.CASE_INSENSITIVE);\n    final Matcher matcher = cidPattern.matcher(htmlContent);\n\n    final StringBuffer result = new StringBuffer();\n    while (matcher.find()) {\n        final String contentId = matcher.group(1);\n        final EmailAttachment attachment = contentIdMap.get(contentId);\n\n        if (attachment != null && attachment.getData() != null) {\n            // Convert to data URI\n            String mimeType = attachment.getContentType();\n            if (mimeType == null || mimeType.isEmpty()) {\n                // Try to determine MIME type from filename\n                final String filename = attachment.getFilename();\n                if (filename != null) {\n                    final String filenameLower = filename.toLowerCase();\n                    if (filenameLower.endsWith(\".png\")) {\n                        mimeType = \"image/png\";\n                    } else if (filenameLower.endsWith(\".jpg\") || filenameLower.endsWith(\".jpeg\")) {\n                        mimeType = \"image/jpeg\";\n                    } else if (filenameLower.endsWith(\".gif\")) {\n                        mimeType = \"image/gif\";\n                    } else if (filenameLower.endsWith(\".bmp\")) {\n                        mimeType = \"image/bmp\";\n                    } else {\n                        mimeType = \"image/png\"; // fallback\n                    }\n                } else {\n                    mimeType = \"image/png\"; // fallback\n                }\n            }\n\n            final String base64Data = Base64.getEncoder().encodeToString(attachment.getData());\n            final String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n\n            // Replace the cid: reference with the data URI\n            final String replacement = matcher.group(0)\n                    .replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n        } else {\n            // Keep original if attachment not found\n            matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n        }\n    }\n    matcher.appendTail(result);\n\n    return result.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "147", "src_id": "M362", "code": "\nprivate static String generateEnhancedEmailHtml(final EmailContent content, final EmlToPdfRequest request) {\n    final StringBuilder html = new StringBuilder();\n\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(content.getSubject())).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(content.getSubject())).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \")\n            .append(escapeHtml(content.getFrom()))\n            .append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \")\n            .append(escapeHtml(content.getTo()))\n            .append(\"</div>\\n\");\n\n    if (content.getDate() != null) {\n        html.append(\"<div><strong>Date:</strong> \")\n                .append(formatEmailDate(content.getDate()))\n                .append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    if (content.getHtmlBody() != null && !content.getHtmlBody().trim().isEmpty()) {\n        html.append(processEmailHtmlBody(content.getHtmlBody(), content));\n    } else if (content.getTextBody() != null && !content.getTextBody().trim().isEmpty()) {\n        html.append(\"<div class=\\\"text-body\\\">\");\n        html.append(convertTextToHtml(content.getTextBody()));\n        html.append(\"</div>\");\n    } else {\n        html.append(\"<div class=\\\"no-content\\\">\");\n        html.append(\"<p><em>No content available</em></p>\");\n        html.append(\"</div>\");\n    }\n    html.append(\"</div>\\n\");\n\n    if (content.getAttachmentCount() > 0 || !content.getAttachments().isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        final int displayedAttachmentCount =\n                content.getAttachmentCount() > 0\n                        ? content.getAttachmentCount()\n                        : content.getAttachments().size();\n        html.append(\"<h3>Attachments (\").append(displayedAttachmentCount).append(\")</h3>\\n\");\n\n        if (!content.getAttachments().isEmpty()) {\n            for (final EmailAttachment attachment : content.getAttachments()) {\n                // Create attachment info with paperclip emoji before filename\n                final String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n                attachment.setEmbeddedFilename(\n                        attachment.getEmbeddedFilename() != null\n                                ? attachment.getEmbeddedFilename()\n                                : attachment.getFilename());\n\n                html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\")\n                        .append(uniqueId)\n                        .append(\"\\\">\")\n                        .append(\"<span class=\\\"attachment-icon\\\">\")\n                        .append(MimeConstants.ATTACHMENT_MARKER)\n                        .append(\"</span> \")\n                        .append(\"<span class=\\\"attachment-name\\\">\")\n                        .append(escapeHtml(safeMimeDecode(attachment.getFilename())))\n                        .append(\"</span>\");\n\n                final String sizeStr = formatFileSize(attachment.getSizeBytes());\n                html.append(\" <span class=\\\"attachment-details\\\">(\").append(sizeStr);\n                if (attachment.getContentType() != null && !attachment.getContentType().isEmpty()) {\n                    html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                }\n                html.append(\")</span></div>\\n\");\n            }\n        }\n\n        if (request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\"<p><em>Attachments are embedded in the file.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "148", "src_id": "M356", "code": "\nprivate static void appendEnhancedStyles(final StringBuilder html) {\n    final int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n    final String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n    final String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n    final String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n    html.append(\"body {\\n\");\n    html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n    html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n    html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n    html.append(\"  color: \").append(textColor).append(\";\\n\");\n    html.append(\"  margin: 0;\\n\");\n    html.append(\"  padding: 16px;\\n\");\n    html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-container {\\n\");\n    html.append(\"  width: 100%;\\n\");\n    html.append(\"  max-width: 100%;\\n\");\n    html.append(\"  margin: 0 auto;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-header {\\n\");\n    html.append(\"  padding-bottom: 10px;\\n\");\n    html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n    html.append(\"  margin-bottom: 10px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-header h1 {\\n\");\n    html.append(\"  margin: 0 0 10px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n    html.append(\"  font-weight: bold;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".email-meta div {\\n\");\n    html.append(\"  margin-bottom: 2px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".email-body {\\n\");\n    html.append(\"  word-wrap: break-word;\\n\");\n    html.append(\"}\\n\\n\");\n\n    html.append(\".attachment-section {\\n\");\n    html.append(\"  margin-top: 15px;\\n\");\n    html.append(\"  padding: 10px;\\n\");\n    html.append(\"  background-color: \")\n            .append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border: 1px solid \")\n            .append(StyleConstants.ATTACHMENT_BORDER_COLOR)\n            .append(\";\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-section h3 {\\n\");\n    html.append(\"  margin: 0 0 8px 0;\\n\");\n    html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-item {\\n\");\n    html.append(\"  padding: 5px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-icon {\\n\");\n    html.append(\"  margin-right: 5px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-details, .attachment-type {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  color: #555555;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n    html.append(\"  margin-top: 8px;\\n\");\n    html.append(\"  padding: 6px;\\n\");\n    html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n    html.append(\"  border-radius: 3px;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-inclusion-note {\\n\");\n    html.append(\"  background-color: #e6ffed;\\n\");\n    html.append(\"  border: 1px solid #d4f7dc;\\n\");\n    html.append(\"  color: #006420;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-info-note {\\n\");\n    html.append(\"  background-color: #fff9e6;\\n\");\n    html.append(\"  border: 1px solid #fff0c2;\\n\");\n    html.append(\"  color: #664d00;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container {\\n\");\n    html.append(\"  display: flex;\\n\");\n    html.append(\"  align-items: center;\\n\");\n    html.append(\"  padding: 8px;\\n\");\n    html.append(\"  background-color: #f8f9fa;\\n\");\n    html.append(\"  border: 1px solid #dee2e6;\\n\");\n    html.append(\"  border-radius: 4px;\\n\");\n    html.append(\"  margin: 4px 0;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-link-container:hover {\\n\");\n    html.append(\"  background-color: #e9ecef;\\n\");\n    html.append(\"}\\n\\n\");\n    html.append(\".attachment-note {\\n\");\n    html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n    html.append(\"  color: #6c757d;\\n\");\n    html.append(\"  font-style: italic;\\n\");\n    html.append(\"  margin-left: 8px;\\n\");\n    html.append(\"}\\n\\n\");\n\n    // Basic image styling: ensure images are responsive but not overly constrained.\n    html.append(\"img {\\n\");\n    html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n    html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n    html.append(\"  display: block;\\n\"); // Avoid extra space below images\n    html.append(\"}\\n\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "149", "src_id": "M359", "code": "\nprivate static EmailContent extractEmailContentAdvanced(final Object message, final EmlToPdfRequest request) {\n    final EmailContent content = new EmailContent();\n\n    try {\n        final Class<?> messageClass = message.getClass();\n\n        // Extract headers via reflection\n        final Method getSubject = messageClass.getMethod(\"getSubject\");\n        final String subject = (String) getSubject.invoke(message);\n        content.setSubject(subject != null ? safeMimeDecode(subject) : \"No Subject\");\n\n        final Method getFrom = messageClass.getMethod(\"getFrom\");\n        final Object[] fromAddresses = (Object[]) getFrom.invoke(message);\n        content.setFrom(fromAddresses != null && fromAddresses.length > 0\n                ? safeMimeDecode(fromAddresses[0].toString()) : \"\");\n\n        final Method getAllRecipients = messageClass.getMethod(\"getAllRecipients\");\n        final Object[] recipients = (Object[]) getAllRecipients.invoke(message);\n        content.setTo(recipients != null && recipients.length > 0\n                ? safeMimeDecode(recipients[0].toString()) : \"\");\n\n        final Method getSentDate = messageClass.getMethod(\"getSentDate\");\n        content.setDate((Date) getSentDate.invoke(message));\n\n        // Extract content\n        final Method getContent = messageClass.getMethod(\"getContent\");\n        final Object messageContent = getContent.invoke(message);\n\n        if (messageContent instanceof final String stringContent) {\n            final Method getContentType = messageClass.getMethod(\"getContentType\");\n            final String contentType = (String) getContentType.invoke(message);\n            if (contentType != null && contentType.toLowerCase().contains(\"text/html\")) {\n                content.setHtmlBody(stringContent);\n            } else {\n                content.setTextBody(stringContent);\n            }\n        } else {\n            // Handle multipart content\n            try {\n                final Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(messageContent)) {\n                    processMultipartAdvanced(messageContent, content, request);\n                }\n            } catch (final Exception e) {\n                log.warn(\"Error processing content: {}\", e.getMessage());\n            }\n        }\n\n    } catch (final Exception e) {\n        content.setSubject(\"Email Conversion\");\n        content.setFrom(\"Unknown\");\n        content.setTo(\"Unknown\");\n        content.setTextBody(\"Email content could not be parsed with advanced processing\");\n    }\n\n    return content;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "150", "src_id": "M894", "code": "\npublic static RequestCreator loadScaledDownThumbnail(final Context context,\n                                                     @NonNull final List<Image> images) {\n    // scale down the notification thumbnail for performance\n    return PicassoHelper.loadThumbnail(images)\n            .transform(new Transformation() {\n                @Override\n                public Bitmap transform(final Bitmap source) {\n                    if (DEBUG) {\n                        Log.d(TAG, \"Thumbnail - transform() called\");\n                    }\n\n                    final float maxWidth = context.getResources()\n                            .getDimension(R.dimen.player_notification_thumbnail_width);\n                    final float targetWidth = Math.min(maxWidth, source.getWidth());\n                    final int width = (int) targetWidth;\n                    final int height = (int) (source.getHeight() / (source.getWidth() / targetWidth));\n\n                    final Bitmap result = BitmapCompat.createScaledBitmap(\n                            source, width, height, null, true);\n\n                    if (result == source || !result.isMutable()) {\n                        // create a new mutable bitmap to prevent strange crashes on some devices (see #4638)\n                        final float altWidth = targetWidth - 1f;\n                        final int width2 = (int) altWidth;\n                        final int height2 = (int) (source.getHeight()\n                                / (source.getWidth() / altWidth));\n                        final Bitmap copied = BitmapCompat.createScaledBitmap(\n                                source, width2, height2, null, true);\n                        source.recycle();\n                        return copied;\n                    }\n\n                    source.recycle();\n                    return result;\n                }\n\n                @Override\n                public String key() {\n                    return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n                }\n            });\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "151", "src_id": "M369", "code": "\nprivate void buildQualityMenu() {\n    if (qualityPopupMenu == null) {\n        return;\n    }\n    qualityPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_QUALITY);\n\n    final List<VideoStream> availableStreams = Optional.ofNullable(player.getCurrentMetadata())\n            .flatMap(MediaItemTag::getMaybeQuality)\n            .map(MediaItemTag.Quality::getSortedVideoStreams)\n            .orElse(null);\n    if (availableStreams == null) {\n        return;\n    }\n\n    for (int i = 0; i < availableStreams.size(); i++) {\n        final VideoStream videoStream = availableStreams.get(i);\n        qualityPopupMenu.getMenu().add(\n                POPUP_MENU_ID_QUALITY,\n                i,\n                Menu.NONE,\n                MediaFormat.getNameById(videoStream.getFormatId()) + \" \" + videoStream.getResolution()\n        );\n    }\n    qualityPopupMenu.setOnMenuItemClickListener(this);\n    qualityPopupMenu.setOnDismissListener(this);\n\n    player.getSelectedVideoStream()\n            .ifPresent(s -> binding.qualityTextView.setText(s.getResolution()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "152", "src_id": "M372", "code": "\nprivate void buildCaptionMenu(@NonNull final List<String> availableLanguages) {\n    if (captionPopupMenu == null) {\n        return;\n    }\n    captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n\n    captionPopupMenu.setOnDismissListener(this);\n\n    // add option for turning off caption\n    final MenuItem captionOffItem = captionPopupMenu.getMenu().add(\n            POPUP_MENU_ID_CAPTION, 0, Menu.NONE, R.string.caption_none);\n    captionOffItem.setOnMenuItemClickListener(menuItem -> {\n        final int textRendererIndex = player.getCaptionRendererIndex();\n        if (textRendererIndex != RENDERER_UNAVAILABLE) {\n            player.getTrackSelector().setParameters(\n                    player.getTrackSelector()\n                            .buildUponParameters()\n                            .setRendererDisabled(textRendererIndex, true)\n            );\n        }\n        player.getPrefs().edit()\n                .remove(context.getString(R.string.caption_user_set_key))\n                .apply();\n        return true;\n    });\n\n    // add all available captions\n    for (int i = 0; i < availableLanguages.size(); i++) {\n        final String captionLanguage = availableLanguages.get(i);\n        final MenuItem captionItem = captionPopupMenu.getMenu().add(\n                POPUP_MENU_ID_CAPTION, i + 1, Menu.NONE, captionLanguage);\n        captionItem.setOnMenuItemClickListener(menuItem -> {\n            final int textRendererIndex = player.getCaptionRendererIndex();\n            if (textRendererIndex != RENDERER_UNAVAILABLE) {\n                // DefaultTrackSelector selection order:\n                // 1. ANY track exactly matching preferred language name\n                // 2. ANY track exactly matching preferred language stem\n                // 3. ROLE_FLAG_CAPTION track matching preferred language stem\n                // 4. ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND track matching preferred language stem\n                player.getTrackSelector().setParameters(\n                        player.getTrackSelector()\n                                .buildUponParameters()\n                                .setPreferredTextLanguages(\n                                        captionLanguage,\n                                        PlayerHelper.captionLanguageStemOf(captionLanguage)\n                                )\n                                .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                                .setRendererDisabled(textRendererIndex, false)\n                );\n                player.getPrefs().edit()\n                        .putString(context.getString(R.string.caption_user_set_key), captionLanguage)\n                        .apply();\n            }\n            return true;\n        });\n    }\n    captionPopupMenu.setOnDismissListener(this);\n\n    // apply caption language from previous user preference\n    final int textRendererIndex = player.getCaptionRendererIndex();\n    if (textRendererIndex == RENDERER_UNAVAILABLE) {\n        return;\n    }\n\n    // if user prefers to show no caption, then disable the renderer\n    final String userPreferredLanguage =\n            player.getPrefs().getString(context.getString(R.string.caption_user_set_key), null);\n    if (userPreferredLanguage == null) {\n        player.getTrackSelector().setParameters(\n                player.getTrackSelector().buildUponParameters()\n                        .setRendererDisabled(textRendererIndex, true)\n        );\n        return;\n    }\n\n    // only set preferred language if it does not match the user preference\n    final List<String> selectedPreferredLanguages =\n            player.getTrackSelector().getParameters().preferredTextLanguages;\n    if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n        player.getTrackSelector().setParameters(\n                player.getTrackSelector().buildUponParameters()\n                        .setPreferredTextLanguages(\n                                userPreferredLanguage,\n                                PlayerHelper.captionLanguageStemOf(userPreferredLanguage)\n                        )\n                        .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                        .setRendererDisabled(textRendererIndex, false)\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "153", "src_id": "M527", "code": "\n@SuppressLint(\"PrivateResource\") // we currently use Exoplayer's internal strings and icons\n@Nullable\npublic static NotificationActionData fromNotificationActionEnum(\n        @NonNull final Player player,\n        @NotificationConstants.Action final int selectedAction\n) {\n    final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n    final Context ctx = player.getContext();\n\n    switch (selectedAction) {\n        case NotificationConstants.PREVIOUS:\n            return new NotificationActionData(\n                    ACTION_PLAY_PREVIOUS,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description),\n                    baseActionIcon\n            );\n\n        case NotificationConstants.NEXT:\n            return new NotificationActionData(\n                    ACTION_PLAY_NEXT,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description),\n                    baseActionIcon\n            );\n\n        case NotificationConstants.REWIND:\n            return new NotificationActionData(\n                    ACTION_FAST_REWIND,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description),\n                    baseActionIcon\n            );\n\n        case NotificationConstants.FORWARD:\n            return new NotificationActionData(\n                    ACTION_FAST_FORWARD,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description),\n                    baseActionIcon\n            );\n\n        case NotificationConstants.SMART_REWIND_PREVIOUS:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PREVIOUS,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_previous\n                );\n            }\n            return new NotificationActionData(\n                    ACTION_FAST_REWIND,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_controls_rewind\n            );\n\n        case NotificationConstants.SMART_FORWARD_NEXT:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(\n                        ACTION_PLAY_NEXT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_next\n                );\n            }\n            return new NotificationActionData(\n                    ACTION_FAST_FORWARD,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_controls_fastforward\n            );\n\n        case NotificationConstants.PLAY_PAUSE_BUFFERING:\n            if (player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PAUSE,\n                        ctx.getString(R.string.notification_action_buffering),\n                        R.drawable.ic_hourglass_top\n                );\n            }\n            // fallthrough\n        case NotificationConstants.PLAY_PAUSE:\n            if (player.getCurrentState() == Player.STATE_COMPLETED) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description),\n                        R.drawable.ic_replay\n                );\n            }\n            if (player.isPlaying()\n                    || player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_pause\n                );\n            }\n            return new NotificationActionData(\n                    ACTION_PLAY_PAUSE,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_play_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_notification_play\n            );\n\n        case NotificationConstants.REPEAT:\n            if (player.getRepeatMode() == REPEAT_MODE_ALL) {\n                return new NotificationActionData(\n                        ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_all_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_all\n                );\n            }\n            if (player.getRepeatMode() == REPEAT_MODE_ONE) {\n                return new NotificationActionData(\n                        ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_one_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_one\n                );\n            }\n            return new NotificationActionData(\n                    ACTION_REPEAT,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_repeat_off_description),\n                    com.google.android.exoplayer2.ext.mediasession.R.drawable.exo_media_action_repeat_off\n            );\n\n        case NotificationConstants.SHUFFLE:\n            if (player.getPlayQueue() != null && player.getPlayQueue().isShuffled()) {\n                return new NotificationActionData(\n                        ACTION_SHUFFLE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_shuffle_on_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_on\n                );\n            }\n            return new NotificationActionData(\n                    ACTION_SHUFFLE,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_shuffle_off_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_off\n            );\n\n        case NotificationConstants.CLOSE:\n            return new NotificationActionData(\n                    ACTION_CLOSE,\n                    ctx.getString(R.string.close),\n                    R.drawable.ic_close\n            );\n\n        case NotificationConstants.NOTHING:\n        default:\n            // do nothing\n            return null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "154", "src_id": "M16", "code": "\nprivate void handleCookiesFromUrl(@Nullable final String url) {\n    if (MainActivity.DEBUG) {\n        Log.d(TAG, \"handleCookiesFromUrl: url=\" + (url == null ? \"null\" : url));\n    }\n    if (url == null) {\n        return;\n    }\n\n    final String cookies = CookieManager.getInstance().getCookie(url);\n    handleCookies(cookies);\n\n    // sometimes cookies are inside the url\n    final int abuseStart = url.indexOf(\"google_abuse=\");\n    if (abuseStart != -1) {\n        final int abuseEnd = url.indexOf(\"+path\");\n        try {\n            handleCookies(Utils.decodeUrlUtf8(url.substring(abuseStart + 13, abuseEnd)));\n        } catch (final StringIndexOutOfBoundsException e) {\n            if (MainActivity.DEBUG) {\n                Log.e(TAG, \"handleCookiesFromUrl: invalid google abuse starting at \"\n                        + abuseStart + \" and ending at \" + abuseEnd + \" for url \" + url, e);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "155", "src_id": "M456", "code": "\npublic void toggleFullscreen() {\n    if (DEBUG) {\n        Log.d(TAG, \"toggleFullscreen() called\");\n    }\n\n    final PlayerServiceEventListener fragmentListener =\n            player.getFragmentListener().orElse(null);\n    if (fragmentListener == null || player.exoPlayerIsNull()) {\n        return;\n    }\n\n    isFullscreen = !isFullscreen;\n    if (isFullscreen) {\n        // Android needs tens milliseconds to send new insets; hide controls to avoid visual jump\n        hideControls(0, 0);\n    } else {\n        // apply window insets because Android will not do it when rotating to portrait\n        binding.playbackControlRoot.setPadding(0, 0, 0, 0);\n    }\n    fragmentListener.onFullscreenStateChanged(isFullscreen);\n\n    final int visible = isFullscreen ? View.VISIBLE : View.GONE;\n    final int gone = isFullscreen ? View.GONE : View.VISIBLE;\n    binding.titleTextView.setVisibility(visible);\n    binding.channelTextView.setVisibility(visible);\n    binding.playerCloseButton.setVisibility(gone);\n    setupScreenRotationButton();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "156", "src_id": "M217", "code": "\nprivate void initPlayer(final boolean playOnReady) {\n    if (DEBUG) {\n        Log.d(TAG, \"initPlayer() called with: playOnReady = [\" + playOnReady + \"]\");\n    }\n\n    simpleExoPlayer = new ExoPlayer.Builder(context, renderFactory)\n            .setTrackSelector(trackSelector)\n            .setLoadControl(loadController)\n            .setUsePlatformDiagnostics(false)\n            .build();\n    simpleExoPlayer.addListener(this);\n    simpleExoPlayer.setPlayWhenReady(playOnReady);\n    simpleExoPlayer.setSeekParameters(PlayerHelper.getSeekParameters(context));\n    simpleExoPlayer.setWakeMode(C.WAKE_MODE_NETWORK);\n    simpleExoPlayer.setHandleAudioBecomingNoisy(true);\n\n    audioReactor = new AudioReactor(context, simpleExoPlayer);\n\n    registerBroadcastReceiver();\n\n    // setup UIs\n    UIs.call(PlayerUi::initPlayer);\n\n    // disable media tunneling if requested by the user from ExoPlayer settings\n    final boolean disableTunneling = PreferenceManager.getDefaultSharedPreferences(context)\n            .getBoolean(context.getString(R.string.disable_media_tunneling_key), false);\n    if (!disableTunneling) {\n        trackSelector.setParameters(\n                trackSelector.buildUponParameters().setTunnelingEnabled(true)\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "157", "src_id": "M467", "code": "\nprivate MediaMetadataCompat buildMediaMetadata() {\n    if (DEBUG) {\n        Log.d(TAG, \"buildMediaMetadata called\");\n    }\n\n    // set title and artist\n    final MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder()\n            .putString(MediaMetadataCompat.METADATA_KEY_TITLE, player.getVideoTitle())\n            .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, player.getUploaderName());\n\n    // set duration (-1 for livestreams or if unknown)\n    final long duration = player.getCurrentStreamInfo()\n            .filter(info -> !StreamTypeUtil.isLiveStream(info.getStreamType()))\n            .map(info -> info.getDuration() * 1000L)\n            .orElse(-1L);\n    builder.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration);\n\n    // set album art, unless the user asked not to, or there is no thumbnail available\n    final boolean showThumbnail =\n            player.getPrefs().getBoolean(context.getString(R.string.show_thumbnail_key), true);\n    Optional.ofNullable(player.getThumbnail())\n            .filter(bitmap -> showThumbnail)\n            .ifPresent(bitmap -> {\n                builder.putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, bitmap);\n                builder.putBitmap(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON, bitmap);\n            });\n\n    return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "158", "src_id": "M460", "code": "\npublic MediaDescriptionCompat getQueueMetadata(final int index) {\n    if (player.getPlayQueue() == null) {\n        return null;\n    }\n    final PlayQueueItem item = player.getPlayQueue().getItem(index);\n    if (item == null) {\n        return null;\n    }\n\n    final MediaDescriptionCompat.Builder descBuilder = new MediaDescriptionCompat.Builder()\n            .setMediaId(String.valueOf(index))\n            .setTitle(item.getTitle())\n            .setSubtitle(item.getUploader());\n\n    // set additional metadata for A2DP/AVRCP (audio/video Bluetooth profiles)\n    final Bundle additionalMetadata = new Bundle();\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_TITLE, item.getTitle());\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_ARTIST, item.getUploader());\n    additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, item.getDuration() * 1000);\n    additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, index + 1L);\n    additionalMetadata.putLong(\n            MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, player.getPlayQueue().size());\n    descBuilder.setExtras(additionalMetadata);\n\n    try {\n        descBuilder.setIconUri(Uri.parse(\n                ImageStrategy.choosePreferredImage(item.getThumbnails())));\n    } catch (final Throwable e) {\n        // no thumbnail available at all, or the user disabled image loading,\n        // or the obtained url is not a valid `Uri`\n    }\n\n    return descBuilder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "159", "src_id": "M543", "code": "\nprivate synchronized NotificationCompat.Builder createNotification() {\n    if (DEBUG) {\n        Log.d(TAG, \"createNotification()\");\n    }\n    notificationManager = NotificationManagerCompat.from(player.getContext());\n    final NotificationCompat.Builder builder = new NotificationCompat.Builder(\n            player.getContext(),\n            player.getContext().getString(R.string.notification_channel_id)\n    );\n    final MediaStyle mediaStyle = new MediaStyle();\n\n    // setup media style (compact notification slots and media session)\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n        // notification actions are ignored on Android 13+, replaced by code in MediaSessionPlayerUi\n        final int[] compactSlots = initializeNotificationSlots();\n        mediaStyle.setShowActionsInCompactView(compactSlots);\n    }\n    player.UIs()\n            .get(MediaSessionPlayerUi.class)\n            .flatMap(MediaSessionPlayerUi::getSessionToken)\n            .ifPresent(mediaStyle::setMediaSession);\n\n    // setup notification builder\n    builder.setStyle(mediaStyle)\n            .setPriority(NotificationCompat.PRIORITY_HIGH)\n            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n            .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n            .setShowWhen(false)\n            .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n            .setColor(ContextCompat.getColor(player.getContext(), R.color.dark_background_color))\n            .setColorized(player.getPrefs().getBoolean(\n                    player.getContext().getString(R.string.notification_colorize_key), true))\n            .setDeleteIntent(PendingIntentCompat.getBroadcast(\n                    player.getContext(),\n                    NOTIFICATION_ID,\n                    new Intent(ACTION_CLOSE),\n                    FLAG_UPDATE_CURRENT,\n                    false\n            ));\n\n    // set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n    setLargeIcon(builder);\n\n    return builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "160", "src_id": "M1620", "code": "\n    void fastPath(Subscriber<? super R> a, Iterator<? extends R> iterator) {\n        for (;;) {\n            if (cancelled) {\n                return;\n            }\n\n            R v;\n            try {\n                v = iterator.next();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                a.onError(ex);\n                return;\n            }\n\n            a.onNext(v);\n\n            if (cancelled) {\n                return;\n            }\n\n            boolean b;\n            try {\n                b = iterator.hasNext();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                a.onError(ex);\n                return;\n            }\n\n            if (!b) {\n                a.onComplete();\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "161", "src_id": "M1380", "code": "\n    @Override\n    public void onComplete() {\n        if (done) {\n            return;\n        }\n        try {\n            onComplete.run();\n        } catch (Throwable e) {\n            fail(e);\n            return;\n        }\n\n        done = true;\n        downstream.onComplete();\n\n        try {\n            onAfterTerminate.run();\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            RxJavaPlugins.onError(e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "162", "src_id": "M1939", "code": "\n    @Override\n    public void run(long n) {\n        long emitted = 0L;\n        Iterator<T> iterator = this.iterator;\n        ConditionalSubscriber<? super T> downstream = this.downstream;\n\n        for (;;) {\n\n            if (cancelled) {\n                clear();\n                break;\n            } else {\n                T next;\n                try {\n                    next = Objects.requireNonNull(iterator.next(), \"The Stream's Iterator returned a null value\");\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    downstream.onError(ex);\n                    cancelled = true;\n                    continue;\n                }\n\n                if (downstream.tryOnNext(next)) {\n                    emitted++;\n                }\n\n                if (cancelled) {\n                    continue;\n                }\n\n                try {\n                    if (!iterator.hasNext()) {\n                        downstream.onComplete();\n                        cancelled = true;\n                        continue;\n                    }\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    downstream.onError(ex);\n                    cancelled = true;\n                    continue;\n                }\n\n                if (emitted != n) {\n                    continue;\n                }\n            }\n\n            n = get();\n            if (emitted == n) {\n                if (compareAndSet(n, 0L)) {\n                    break;\n                }\n                n = get();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "163", "src_id": "M1099", "code": "\n    void replay(CacheSubscription<T> consumer) {\n        // ensure only one replay runs at a time\n        if (consumer.getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        long index = consumer.index;\n        int offset = consumer.offset;\n        Node<T> node = consumer.node;\n        AtomicLong requested = consumer.requested;\n        Subscriber<? super T> downstream = consumer.downstream;\n        int capacity = capacityHint;\n\n        for (;;) {\n            boolean sourceDone = done;\n            boolean empty = size == index;\n\n            if (sourceDone && empty) {\n                consumer.node = null;\n                Throwable ex = error;\n                if (ex != null) {\n                    downstream.onError(ex);\n                } else {\n                    downstream.onComplete();\n                }\n                return;\n            }\n\n            if (!empty) {\n                long consumerRequested = requested.get();\n                if (consumerRequested == Long.MIN_VALUE) {\n                    consumer.node = null;\n                    return;\n                }\n                if (consumerRequested != index) {\n                    if (offset == capacity) {\n                        node = node.next;\n                        offset = 0;\n                    }\n\n                    downstream.onNext(node.values[offset]);\n\n                    offset++;\n                    index++;\n                    continue;\n                }\n            }\n\n            consumer.index = index;\n            consumer.offset = offset;\n            consumer.node = node;\n            missed = consumer.addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "164", "src_id": "M284", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        Observer<? super R> downstream = this.downstream;\n        SimpleQueue<T> queue = this.queue;\n        AtomicThrowable errors = this.errors;\n\n        for (;;) {\n\n            if (!active) {\n\n                if (cancelled) {\n                    queue.clear();\n                    return;\n                }\n\n                if (!tillTheEnd) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        queue.clear();\n                        cancelled = true;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n                }\n\n                boolean d = done;\n\n                T v;\n                try {\n                    v = queue.poll();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    cancelled = true;\n                    this.upstream.dispose();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                boolean empty = v == null;\n\n                if (d && empty) {\n                    cancelled = true;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (!empty) {\n                    ObservableSource<? extends R> o;\n\n                    try {\n                        o = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null ObservableSource\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelled = true;\n                        this.upstream.dispose();\n                        queue.clear();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (o instanceof Supplier) {\n                        R w;\n                        try {\n                            w = ((Supplier<R>) o).get();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            errors.tryAddThrowableOrReport(ex);\n                            continue;\n                        }\n\n                        if (w != null && !cancelled) {\n                            downstream.onNext(w);\n                        }\n                        continue;\n                    } else {\n                        active = true;\n                        o.subscribe(observer);\n                    }\n                }\n            }\n\n            if (decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "165", "src_id": "M1908", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n\n        final Subscriber<? super R> downstream = this.downstream;\n        final SimpleQueue<T> queue = this.queue;\n        final AtomicThrowable error = this.error;\n        Iterator<? extends R> iterator = this.currentIterator;\n        long requested = this.requested.get();\n        long emitted = this.emitted;\n        final int limit = prefetch - (prefetch >> 2);\n        boolean canRequest = sourceMode != QueueFuseable.SYNC;\n\n        for (;;) {\n            if (cancelled) {\n                queue.clear();\n                clearCurrentSuppressCloseError();\n            } else {\n                boolean isDone = upstreamDone;\n                if (error.get() != null) {\n                    downstream.onError(error.get());\n                    cancelled = true;\n                    continue;\n                }\n\n                if (iterator == null) {\n                    T t;\n                    try {\n                        t = queue.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        trySignalError(downstream, ex);\n                        continue;\n                    }\n\n                    boolean isEmpty = t == null;\n\n                    if (isDone && isEmpty) {\n                        downstream.onComplete();\n                        cancelled = true;\n                    } else if (!isEmpty) {\n                        if (canRequest && ++consumed == limit) {\n                            consumed = 0;\n                            upstream.request(limit);\n                        }\n\n                        Stream<? extends R> stream;\n                        try {\n                            stream = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null Stream\");\n                            iterator = stream.iterator();\n\n                            if (iterator.hasNext()) {\n                                currentIterator = iterator;\n                                currentCloseable = stream;\n                            } else {\n                                iterator = null;\n                            }\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            trySignalError(downstream, ex);\n                        }\n                        continue;\n                    }\n                }\n                if (iterator != null && emitted != requested) {\n                    R item;\n                    try {\n                        item = Objects.requireNonNull(iterator.next(), \"The Stream.Iterator returned a null value\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        trySignalError(downstream, ex);\n                        continue;\n                    }\n\n                    if (!cancelled) {\n                        downstream.onNext(item);\n                        emitted++;\n\n                        if (!cancelled) {\n                            try {\n                                if (!iterator.hasNext()) {\n                                    iterator = null;\n                                    clearCurrentRethrowCloseError();\n                                }\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                trySignalError(downstream, ex);\n                            }\n                        }\n                    }\n                    continue;\n                }\n            }\n\n            this.emitted = emitted;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n            requested = this.requested.get();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1237", "code": "\n    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        final Subscriber<? super R> a = downstream;\n        final ZipSubscriber<T, R>[] qs = subscribers;\n        final int n = qs.length;\n        Object[] values = current;\n\n        int missed = 1;\n\n        for (;;) {\n            long r = requested.get();\n            long e = 0L;\n\n            while (r != e) {\n\n                if (cancelled) {\n                    return;\n                }\n\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                boolean empty = false;\n\n                for (int j = 0; j < n; j++) {\n                    ZipSubscriber<T, R> inner = qs[j];\n                    if (values[j] == null) {\n                        boolean d = inner.done;\n                        SimpleQueue<T> q = inner.queue;\n                        T v = null;\n                        try {\n                            v = q != null ? q.poll() : null;\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            errors.tryAddThrowableOrReport(ex);\n                            if (!delayErrors) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            d = true;\n                        }\n\n                        boolean sourceEmpty = v == null;\n                        if (d && sourceEmpty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n                        if (!sourceEmpty) {\n                            values[j] = v;\n                        } else {\n                            empty = true;\n                        }\n                    }\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                R v;\n                try {\n                    v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    cancelAll();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                a.onNext(v);\n                e++;\n\n                Arrays.fill(values, null);\n            }\n\n            if (r == e) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                for (int j = 0; j < n; j++) {\n                    ZipSubscriber<T, R> inner = qs[j];\n                    if (values[j] == null) {\n                        boolean d = inner.done;\n                        SimpleQueue<T> q = inner.queue;\n                        T v = null;\n                        try {\n                            v = q != null ? q.poll() : null;\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            errors.tryAddThrowableOrReport(ex);\n                            if (!delayErrors) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            d = true;\n                        }\n                        boolean empty = v == null;\n                        if (d && empty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n                        if (!empty) {\n                            values[j] = v;\n                        }\n                    }\n                }\n            }\n\n            if (e != 0L) {\n                for (ZipSubscriber<T, R> inner : qs) {\n                    inner.request(e);\n                }\n                if (r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "167", "src_id": "M409", "code": "\n    @Override\n    Node getHead() {\n        long timeLimit = scheduler.now(unit) - maxAge;\n        Node prev = get();\n        Node next = prev.get();\n        for (;;) {\n            if (next == null) {\n                break;\n            }\n            Timed<?> v = (Timed<?>) next.value;\n            if (NotificationLite.isComplete(v.value()) || NotificationLite.isError(v.value())) {\n                break;\n            }\n            if (v.time() <= timeLimit) {\n                prev = next;\n                next = next.get();\n            } else {\n                break;\n            }\n        }\n        return prev;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "168", "src_id": "M2271", "code": "\n    @SuppressWarnings(\"unchecked\")\n    void remove(AsyncSubscription<T> ps) {\n        for (;;) {\n            AsyncSubscription<T>[] a = subscribers.get();\n            int n = a.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            AsyncSubscription<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new AsyncSubscription[n - 1];\n                System.arraycopy(a, 0, b, 0, j);\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n            if (subscribers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "169", "src_id": "M335", "code": "\n    @Override\n    public void onSubscribe(Disposable d) {\n        if (DisposableHelper.validate(this.upstream, d)) {\n            this.upstream = d;\n            if (d instanceof QueueDisposable) {\n                @SuppressWarnings(\"unchecked\")\n                QueueDisposable<T> qd = (QueueDisposable<T>) d;\n\n                int m = qd.requestFusion(QueueDisposable.ANY);\n                if (m == QueueDisposable.SYNC) {\n                    fusionMode = m;\n                    queue = qd;\n                    done = true;\n\n                    downstream.onSubscribe(this);\n                    drain();\n                    return;\n                }\n\n                if (m == QueueDisposable.ASYNC) {\n                    fusionMode = m;\n                    queue = qd;\n\n                    downstream.onSubscribe(this);\n                    return;\n                }\n            }\n\n            queue = new SpscLinkedArrayQueue<>(bufferSize);\n            downstream.onSubscribe(this);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "170", "src_id": "M478", "code": "\nprivate void saveDocumentToZip(PDDocument document, ZipOutputStream zipOut, String baseFilename, int index) throws IOException {\n    log.debug(\"Starting saveDocumentToZip for document part {}\", index);\n\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n\n    try {\n        log.debug(\"Saving document part {} to byte array\", index);\n        document.save(outStream);\n        log.debug(\"Successfully saved document part {} ({} bytes)\", index, outStream.size());\n    } catch (Exception e) {\n        log.error(\"Error saving document part {} to byte array\", index, e);\n        throw ExceptionUtils.createFileProcessingException(\"split\", e);\n    }\n\n    try {\n        log.debug(\"Closing document part {}\", index);\n        document.close();\n        log.debug(\"Successfully closed document part {}\", index);\n    } catch (Exception e) {\n        log.error(\"Error closing document part {}\", index, e);\n        // Continue despite close error\n    }\n\n    try {\n        String entryName = baseFilename + \"_\" + index + \".pdf\";\n        log.debug(\"Creating ZIP entry: {}\", entryName);\n\n        ZipEntry zipEntry = new ZipEntry(entryName);\n        zipOut.putNextEntry(zipEntry);\n\n        byte[] bytes = outStream.toByteArray();\n        log.debug(\"Writing {} bytes to ZIP entry\", bytes.length);\n\n        zipOut.write(bytes);\n\n        log.debug(\"Closing ZIP entry\");\n        zipOut.closeEntry();\n\n        log.debug(\"Successfully added document part {} to ZIP\", index);\n    } catch (Exception e) {\n        log.error(\"Error adding document part {} to ZIP\", index, e);\n        throw ExceptionUtils.createFileProcessingException(\"split\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "171", "src_id": "M101", "code": "\nprivate void processRequest(int limitPerDay,\n                            String identifier,\n                            Map<String, Bucket> buckets,\n                            HttpServletRequest request,\n                            HttpServletResponse response,\n                            FilterChain filterChain) throws IOException, ServletException {\n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n\n    if (!probe.isConsumed()) {\n        long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n        response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n        response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        return;\n    }\n\n    response.setHeader(\"X-Rate-Limit-Remaining\",\n            stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n\n    filterChain.doFilter(request, response);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "172", "src_id": "M38", "code": "\n@SuppressWarnings(\"deprecation\")\npublic void migrateEnterpriseSettingsToPremium(ApplicationProperties applicationProperties) {\n    EnterpriseEdition enterpriseEdition = applicationProperties.getEnterpriseEdition();\n    Premium premium = applicationProperties.getPremium();\n\n    if (enterpriseEdition == null || premium == null) {\n        return;\n    }\n\n    final String ZERO_KEY = \"00000000-0000-0000-0000-000000000000\";\n\n    // Copy the license key if it's set in enterprise but not in premium\n    if (premium.getKey() == null || ZERO_KEY.equals(premium.getKey())) {\n        if (enterpriseEdition.getKey() != null && !ZERO_KEY.equals(enterpriseEdition.getKey())) {\n            premium.setKey(enterpriseEdition.getKey());\n        }\n    }\n\n    // Copy enabled state if enterprise is enabled but premium is not\n    if (!premium.isEnabled() && enterpriseEdition.isEnabled()) {\n        premium.setEnabled(true);\n    }\n\n    // Copy SSO auto login setting\n    if (!premium.getProFeatures().isSsoAutoLogin() && enterpriseEdition.isSsoAutoLogin()) {\n        premium.getProFeatures().setSsoAutoLogin(true);\n    }\n\n    Premium.ProFeatures.CustomMetadata premiumMetadata = premium.getProFeatures().getCustomMetadata();\n    EnterpriseEdition.CustomMetadata enterpriseMetadata = enterpriseEdition.getCustomMetadata();\n\n    if (enterpriseMetadata == null || premiumMetadata == null) {\n        return;\n    }\n\n    // Copy autoUpdateMetadata setting\n    if (!premiumMetadata.isAutoUpdateMetadata() && enterpriseMetadata.isAutoUpdateMetadata()) {\n        premiumMetadata.setAutoUpdateMetadata(true);\n    }\n\n    // Copy author if not set in premium but set in enterprise\n    if ((premiumMetadata.getAuthor() == null\n            || premiumMetadata.getAuthor().trim().isEmpty()\n            || \"username\".equals(premiumMetadata.getAuthor()))\n            && enterpriseMetadata.getAuthor() != null\n            && !enterpriseMetadata.getAuthor().trim().isEmpty()) {\n        premiumMetadata.setAuthor(enterpriseMetadata.getAuthor());\n    }\n\n    // Copy creator if not set in premium but set in enterprise and different from default\n    if ((premiumMetadata.getCreator() == null || \"Stirling-PDF\".equals(premiumMetadata.getCreator()))\n            && enterpriseMetadata.getCreator() != null\n            && !\"Stirling-PDF\".equals(enterpriseMetadata.getCreator())) {\n        premiumMetadata.setCreator(enterpriseMetadata.getCreator());\n    }\n\n    // Copy producer if not set in premium but set in enterprise and different from default\n    if ((premiumMetadata.getProducer() == null || \"Stirling-PDF\".equals(premiumMetadata.getProducer()))\n            && enterpriseMetadata.getProducer() != null\n            && !\"Stirling-PDF\".equals(enterpriseMetadata.getProducer())) {\n        premiumMetadata.setProducer(enterpriseMetadata.getProducer());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "173", "src_id": "M543", "code": "\nprivate void applyGhostscriptCompression(OptimizePdfRequest request,\n                                         int optimizeLevel,\n                                         Path currentFile,\n                                         List<Path> tempFiles) throws IOException {\n    long preGsSize = Files.size(currentFile);\n    log.info(\"Pre-Ghostscript file size: {}\", GeneralUtils.formatBytes(preGsSize));\n\n    Path gsOutputFile = Files.createTempFile(\"gs_output_\", \".pdf\");\n    tempFiles.add(gsOutputFile);\n\n    List<String> command = new ArrayList<>();\n    command.add(\"gs\");\n    command.add(\"-sDEVICE=pdfwrite\");\n    command.add(\"-dCompatibilityLevel=1.5\");\n    command.add(\"-dNOPAUSE\");\n    command.add(\"-dQUIET\");\n    command.add(\"-dBATCH\");\n\n    switch (optimizeLevel) {\n        case 1:\n            command.add(\"-dPDFSETTINGS=/prepress\");\n            break;\n        case 2:\n            command.add(\"-dPDFSETTINGS=/printer\");\n            break;\n        case 3:\n            command.add(\"-dPDFSETTINGS=/ebook\");\n            break;\n        case 4:\n        case 5:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            break;\n        case 6:\n        case 7:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            command.add(\"-dColorImageResolution=150\");\n            command.add(\"-dGrayImageResolution=150\");\n            command.add(\"-dMonoImageResolution=300\");\n            break;\n        case 8:\n        case 9:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            command.add(\"-dColorImageResolution=100\");\n            command.add(\"-dGrayImageResolution=100\");\n            command.add(\"-dMonoImageResolution=200\");\n            break;\n        case 10:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            command.add(\"-dColorImageResolution=72\");\n            command.add(\"-dGrayImageResolution=72\");\n            command.add(\"-dMonoImageResolution=150\");\n            break;\n        default:\n            command.add(\"-dPDFSETTINGS=/screen\");\n            break;\n    }\n\n    command.add(\"-sOutputFile=\" + gsOutputFile.toString());\n    command.add(currentFile.toString());\n\n    ProcessExecutorResult returnCode = null;\n\n    try {\n        returnCode = ProcessExecutor.getInstance(ProcessExecutor.Processes.GHOSTSCRIPT)\n                .runCommandWithOutputHandling(command);\n\n        if (returnCode.getRc() == 0) {\n            Files.copy(gsOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n\n            long postGsSize = Files.size(currentFile);\n            double gsReduction = 100.0 - ((postGsSize * 100.0) / preGsSize);\n            log.info(\"Post-Ghostscript file size: {} (reduced by {}%)\",\n                    GeneralUtils.formatBytes(postGsSize), String.format(\"%.1f\", gsReduction));\n            return;\n        }\n\n        log.warn(\"Ghostscript compression failed with return code: {}\", returnCode.getRc());\n        throw new IOException(\"Ghostscript compression failed\");\n    } catch (Exception e) {\n        log.warn(\"Ghostscript compression failed, will fallback to other methods\", e);\n        throw new IOException(\"Ghostscript compression failed\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "174", "src_id": "M256", "code": "\nprivate Object executeWithRetries(ProceedingJoinPoint joinPoint,\n                                  Object[] args,\n                                  boolean async,\n                                  long timeout,\n                                  int maxRetries,\n                                  boolean trackProgress,\n                                  boolean queueable,\n                                  int resourceWeight) {\n    AtomicReference<String> jobIdRef = new AtomicReference<>();\n\n    return jobExecutorService.runJobGeneric(\n            async,\n            () -> {\n                Throwable lastException = null;\n\n                for (int currentAttempt = 1; currentAttempt <= maxRetries; currentAttempt++) {\n                    try {\n                        if (trackProgress && async) {\n                            if (jobIdRef.get() == null) {\n                                jobIdRef.set(getJobIdFromContext());\n                            }\n\n                            String jobId = jobIdRef.get();\n                            if (jobId != null) {\n                                log.debug(\"Tracking progress for job {} (attempt {}/{})\",\n                                        jobId, currentAttempt, maxRetries);\n                            }\n                        }\n\n                        return joinPoint.proceed(args);\n                    } catch (Throwable ex) {\n                        lastException = ex;\n\n                        log.error(\"AutoJobAspect caught exception during job execution (attempt {}/{}): {}\",\n                                currentAttempt, maxRetries, ex.getMessage(), ex);\n\n                        if (currentAttempt >= maxRetries) {\n                            break;\n                        }\n\n                        log.info(\"Retrying operation, attempt {}/{}\", currentAttempt + 1, maxRetries);\n\n                        if (trackProgress && async) {\n                            String jobId = jobIdRef.get();\n                            if (jobId != null) {\n                                log.debug(\"Recording retry attempt for job {} in TaskManager\", jobId);\n                            }\n                        }\n\n                        long delayMs = RETRY_BASE_DELAY.toMillis() * currentAttempt;\n\n                        CompletableFuture<Object> delayedRetry = new CompletableFuture<>();\n                        CompletableFuture.delayedExecutor(delayMs, TimeUnit.MILLISECONDS).execute(() -> delayedRetry.complete(null));\n\n                        try {\n                            delayedRetry.join();\n                        } catch (Exception e) {\n                            Thread.currentThread().interrupt();\n                            break;\n                        }\n                    }\n                }\n\n                if (lastException != null) {\n                    throw new RuntimeException(\"Job failed after \" + maxRetries + \" attempts: \" + lastException.getMessage(), lastException);\n                }\n\n                throw new RuntimeException(\"Job failed but no exception was recorded\");\n            },\n            timeout,\n            queueable,\n            resourceWeight);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "175", "src_id": "M813", "code": "\npublic void init() {\n    // PageOps\n    addEndpointToGroup(\"PageOps\", \"remove-pages\");\n    addEndpointToGroup(\"PageOps\", \"merge-pdfs\");\n    addEndpointToGroup(\"PageOps\", \"split-pdfs\");\n    addEndpointToGroup(\"PageOps\", \"pdf-organizer\");\n    addEndpointToGroup(\"PageOps\", \"rotate-pdf\");\n    addEndpointToGroup(\"PageOps\", \"multi-page-layout\");\n    addEndpointToGroup(\"PageOps\", \"scale-pages\");\n    addEndpointToGroup(\"PageOps\", \"adjust-contrast\");\n    addEndpointToGroup(\"PageOps\", \"crop\");\n    addEndpointToGroup(\"PageOps\", \"auto-split-pdf\");\n    addEndpointToGroup(\"PageOps\", \"extract-page\");\n    addEndpointToGroup(\"PageOps\", \"pdf-to-single-page\");\n    addEndpointToGroup(\"PageOps\", \"split-by-size-or-count\");\n    addEndpointToGroup(\"PageOps\", \"overlay-pdf\");\n    addEndpointToGroup(\"PageOps\", \"split-pdf-by-sections\");\n\n    // Convert\n    addEndpointToGroup(\"Convert\", \"pdf-to-img\");\n    addEndpointToGroup(\"Convert\", \"img-to-pdf\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-pdfa\");\n    addEndpointToGroup(\"Convert\", \"file-to-pdf\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-word\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-presentation\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-text\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-html\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-xml\");\n    addEndpointToGroup(\"Convert\", \"html-to-pdf\");\n    addEndpointToGroup(\"Convert\", \"url-to-pdf\");\n    addEndpointToGroup(\"Convert\", \"markdown-to-pdf\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-csv\");\n    addEndpointToGroup(\"Convert\", \"pdf-to-markdown\");\n    addEndpointToGroup(\"Convert\", \"eml-to-pdf\");\n\n    // Security\n    addEndpointToGroup(\"Security\", \"add-password\");\n    addEndpointToGroup(\"Security\", \"remove-password\");\n    addEndpointToGroup(\"Security\", \"change-permissions\");\n    addEndpointToGroup(\"Security\", \"add-watermark\");\n    addEndpointToGroup(\"Security\", \"cert-sign\");\n    addEndpointToGroup(\"Security\", \"remove-cert-sign\");\n    addEndpointToGroup(\"Security\", \"sanitize-pdf\");\n    addEndpointToGroup(\"Security\", \"auto-redact\");\n    addEndpointToGroup(\"Security\", \"redact\");\n\n    // Other\n    addEndpointToGroup(\"Other\", \"ocr-pdf\");\n    addEndpointToGroup(\"Other\", \"add-image\");\n    addEndpointToGroup(\"Other\", \"compress-pdf\");\n    addEndpointToGroup(\"Other\", \"extract-images\");\n    addEndpointToGroup(\"Other\", \"change-metadata\");\n    addEndpointToGroup(\"Other\", \"extract-image-scans\");\n    addEndpointToGroup(\"Other\", \"sign\");\n    addEndpointToGroup(\"Other\", \"flatten\");\n    addEndpointToGroup(\"Other\", \"repair\");\n    addEndpointToGroup(\"Other\", \"unlock-pdf-forms\");\n    addEndpointToGroup(\"Other\", REMOVE_BLANKS);\n    addEndpointToGroup(\"Other\", \"remove-annotations\");\n    addEndpointToGroup(\"Other\", \"compare\");\n    addEndpointToGroup(\"Other\", \"add-page-numbers\");\n    addEndpointToGroup(\"Other\", \"auto-rename\");\n    addEndpointToGroup(\"Other\", \"get-info-on-pdf\");\n    addEndpointToGroup(\"Other\", \"show-javascript\");\n    addEndpointToGroup(\"Other\", \"remove-image-pdf\");\n    addEndpointToGroup(\"Other\", \"add-attachments\");\n\n    // CLI\n    addEndpointToGroup(\"CLI\", \"compress-pdf\");\n    addEndpointToGroup(\"CLI\", \"extract-image-scans\");\n    addEndpointToGroup(\"CLI\", \"repair\");\n    addEndpointToGroup(\"CLI\", \"pdf-to-pdfa\");\n    addEndpointToGroup(\"CLI\", \"file-to-pdf\");\n    addEndpointToGroup(\"CLI\", \"pdf-to-word\");\n    addEndpointToGroup(\"CLI\", \"pdf-to-presentation\");\n    addEndpointToGroup(\"CLI\", \"pdf-to-html\");\n    addEndpointToGroup(\"CLI\", \"pdf-to-xml\");\n    addEndpointToGroup(\"CLI\", \"ocr-pdf\");\n    addEndpointToGroup(\"CLI\", \"html-to-pdf\");\n    addEndpointToGroup(\"CLI\", \"url-to-pdf\");\n    addEndpointToGroup(\"CLI\", \"pdf-to-rtf\");\n\n    // Python\n    addEndpointToGroup(\"Python\", \"extract-image-scans\");\n    addEndpointToGroup(\"Python\", \"html-to-pdf\");\n    addEndpointToGroup(\"Python\", \"url-to-pdf\");\n    addEndpointToGroup(\"Python\", \"file-to-pdf\");\n\n    // OpenCV\n    addEndpointToGroup(\"OpenCV\", \"extract-image-scans\");\n\n    // LibreOffice\n    addEndpointToGroup(\"LibreOffice\", \"file-to-pdf\");\n    addEndpointToGroup(\"LibreOffice\", \"pdf-to-word\");\n    addEndpointToGroup(\"LibreOffice\", \"pdf-to-presentation\");\n    addEndpointToGroup(\"LibreOffice\", \"pdf-to-rtf\");\n    addEndpointToGroup(\"LibreOffice\", \"pdf-to-html\");\n    addEndpointToGroup(\"LibreOffice\", \"pdf-to-xml\");\n    addEndpointToGroup(\"LibreOffice\", \"pdf-to-pdfa\");\n\n    // Unoconvert\n    addEndpointToGroup(\"Unoconvert\", \"file-to-pdf\");\n\n    // Java\n    addEndpointToGroup(\"Java\", \"merge-pdfs\");\n    addEndpointToGroup(\"Java\", \"remove-pages\");\n    addEndpointToGroup(\"Java\", \"split-pdfs\");\n    addEndpointToGroup(\"Java\", \"pdf-organizer\");\n    addEndpointToGroup(\"Java\", \"rotate-pdf\");\n    addEndpointToGroup(\"Java\", \"pdf-to-img\");\n    addEndpointToGroup(\"Java\", \"img-to-pdf\");\n    addEndpointToGroup(\"Java\", \"add-password\");\n    addEndpointToGroup(\"Java\", \"remove-password\");\n    addEndpointToGroup(\"Java\", \"change-permissions\");\n    addEndpointToGroup(\"Java\", \"add-watermark\");\n    addEndpointToGroup(\"Java\", \"add-image\");\n    addEndpointToGroup(\"Java\", \"extract-images\");\n    addEndpointToGroup(\"Java\", \"change-metadata\");\n    addEndpointToGroup(\"Java\", \"cert-sign\");\n    addEndpointToGroup(\"Java\", \"remove-cert-sign\");\n    addEndpointToGroup(\"Java\", \"multi-page-layout\");\n    addEndpointToGroup(\"Java\", \"scale-pages\");\n    addEndpointToGroup(\"Java\", \"add-page-numbers\");\n    addEndpointToGroup(\"Java\", \"auto-rename\");\n    addEndpointToGroup(\"Java\", \"auto-split-pdf\");\n    addEndpointToGroup(\"Java\", \"sanitize-pdf\");\n    addEndpointToGroup(\"Java\", \"crop\");\n    addEndpointToGroup(\"Java\", \"get-info-on-pdf\");\n    addEndpointToGroup(\"Java\", \"extract-page\");\n    addEndpointToGroup(\"Java\", \"pdf-to-single-page\");\n    addEndpointToGroup(\"Java\", \"markdown-to-pdf\");\n    addEndpointToGroup(\"Java\", \"show-javascript\");\n    addEndpointToGroup(\"Java\", \"auto-redact\");\n    addEndpointToGroup(\"Java\", \"redact\");\n    addEndpointToGroup(\"Java\", \"pdf-to-csv\");\n    addEndpointToGroup(\"Java\", \"split-by-size-or-count\");\n    addEndpointToGroup(\"Java\", \"overlay-pdf\");\n    addEndpointToGroup(\"Java\", \"split-pdf-by-sections\");\n    addEndpointToGroup(\"Java\", REMOVE_BLANKS);\n    addEndpointToGroup(\"Java\", \"pdf-to-text\");\n    addEndpointToGroup(\"Java\", \"remove-image-pdf\");\n    addEndpointToGroup(\"Java\", \"pdf-to-markdown\");\n    addEndpointToGroup(\"Java\", \"add-attachments\");\n    addEndpointToGroup(\"Java\", \"compress-pdf\");\n\n    // Javascript\n    addEndpointToGroup(\"Javascript\", \"pdf-organizer\");\n    addEndpointToGroup(\"Javascript\", \"sign\");\n    addEndpointToGroup(\"Javascript\", \"compare\");\n    addEndpointToGroup(\"Javascript\", \"adjust-contrast\");\n\n    // qpdf\n    addEndpointToGroup(\"qpdf\", \"repair\");\n    addEndpointToGroup(\"qpdf\", \"compress-pdf\");\n\n    // Ghostscript\n    addEndpointToGroup(\"Ghostscript\", \"repair\");\n    addEndpointToGroup(\"Ghostscript\", \"compress-pdf\");\n\n    // tesseract\n    addEndpointToGroup(\"tesseract\", \"ocr-pdf\");\n\n    // OCRmyPDF\n    addEndpointToGroup(\"OCRmyPDF\", \"ocr-pdf\");\n\n    // Multi-tool endpoints\n    addEndpointAlternative(\"repair\", \"qpdf\");\n    addEndpointAlternative(\"repair\", \"Ghostscript\");\n    addEndpointAlternative(\"compress-pdf\", \"qpdf\");\n    addEndpointAlternative(\"compress-pdf\", \"Ghostscript\");\n    addEndpointAlternative(\"compress-pdf\", \"Java\");\n    addEndpointAlternative(\"ocr-pdf\", \"tesseract\");\n    addEndpointAlternative(\"ocr-pdf\", \"OCRmyPDF\");\n\n    // file-to-pdf alternatives\n    addEndpointAlternative(\"file-to-pdf\", \"LibreOffice\");\n    addEndpointAlternative(\"file-to-pdf\", \"Python\");\n    addEndpointAlternative(\"file-to-pdf\", \"Unoconvert\");\n\n    // pdf-to-html / pdf-to-markdown alternatives\n    addEndpointAlternative(\"pdf-to-html\", \"LibreOffice\");\n    addEndpointAlternative(\"pdf-to-html\", \"Pdftohtml\");\n    addEndpointAlternative(\"pdf-to-markdown\", \"Pdftohtml\");\n\n    // markdown-to-pdf alternatives\n    addEndpointAlternative(\"markdown-to-pdf\", \"Weasyprint\");\n    addEndpointAlternative(\"markdown-to-pdf\", \"Java\");\n\n    // Weasyprint\n    addEndpointToGroup(\"Weasyprint\", \"html-to-pdf\");\n    addEndpointToGroup(\"Weasyprint\", \"url-to-pdf\");\n    addEndpointToGroup(\"Weasyprint\", \"markdown-to-pdf\");\n    addEndpointToGroup(\"Weasyprint\", \"eml-to-pdf\");\n\n    // Pdftohtml\n    addEndpointToGroup(\"Pdftohtml\", \"pdf-to-html\");\n    addEndpointToGroup(\"Pdftohtml\", \"pdf-to-markdown\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "176", "src_id": "M318", "code": "\npublic static byte[] overlayImage(CustomPDFDocumentFactory pdfDocumentFactory,\n                                  byte[] pdfBytes,\n                                  byte[] imageBytes,\n                                  float x,\n                                  float y,\n                                  boolean everyPage) throws IOException {\n    PDDocument document = pdfDocumentFactory.load(pdfBytes);\n\n    int pages = document.getNumberOfPages();\n\n    for (int i = 0; i < pages; i++) {\n        PDPage page = document.getPage(i);\n\n        try (PDPageContentStream contentStream =\n                     new PDPageContentStream(document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {\n            PDImageXObject image = PDImageXObject.createFromByteArray(document, imageBytes, \"\");\n            contentStream.drawImage(image, x, y);\n\n            log.info(\"Image successfully overlayed onto PDF\");\n\n            if (!everyPage && i == 0) {\n                break;\n            }\n        } catch (IOException e) {\n            log.error(\"Error overlaying image onto PDF\", e);\n            throw e;\n        }\n    }\n\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    document.save(baos);\n    log.info(\"PDF successfully saved to byte array\");\n\n    return baos.toByteArray();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "177", "src_id": "M310", "code": "\npublic static PDRectangle textToPageSize(String size) {\n    switch (size.toUpperCase()) {\n        case \"A0\":\n            return PDRectangle.A0;\n        case \"A1\":\n            return PDRectangle.A1;\n        case \"A2\":\n            return PDRectangle.A2;\n        case \"A3\":\n            return PDRectangle.A3;\n        case \"A4\":\n            return PDRectangle.A4;\n        case \"A5\":\n            return PDRectangle.A5;\n        case \"A6\":\n            return PDRectangle.A6;\n        case \"LETTER\":\n            return PDRectangle.LETTER;\n        case \"LEGAL\":\n            return PDRectangle.LEGAL;\n        default:\n            throw ExceptionUtils.createInvalidPageSizeException(size);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "178", "src_id": "M208", "code": "\nprivate long parseSessionTimeout(String timeout) {\n    if (timeout == null || timeout.isEmpty()) {\n        return 30 * 60 * 1000; // Default: 30 minutes\n    }\n\n    try {\n        String value = timeout.replaceAll(\"[^\\\\d.]\", \"\");\n        String unit = timeout.replaceAll(\"[\\\\d.]\", \"\");\n\n        double numericValue = Double.parseDouble(value);\n\n        switch (unit.toLowerCase()) {\n            case \"s\":\n                return (long) (numericValue * 1000);\n            case \"m\":\n                return (long) (numericValue * 60 * 1000);\n            case \"h\":\n                return (long) (numericValue * 60 * 60 * 1000);\n            case \"d\":\n                return (long) (numericValue * 24 * 60 * 60 * 1000);\n            default:\n                return (long) (numericValue * 60 * 1000); // Default to minutes\n        }\n    } catch (Exception e) {\n        log.warn(\"Could not parse session timeout '{}', using default\", timeout);\n        return 30 * 60 * 1000; // Default: 30 minutes\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "179", "src_id": "M183", "code": "\npublic Map<String, Object> captureServerMetrics() {\n    Map<String, Object> metrics = new HashMap<>();\n\n    try {\n        // Application version / deployment\n        metrics.put(\"app_version\", appVersion);\n\n        String deploymentType = \"JAR\";\n        if (\"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"))) {\n            deploymentType = \"EXE\";\n        } else if (isRunningInDocker()) {\n            deploymentType = \"DOCKER\";\n        }\n\n        metrics.put(\"deployment_type\", deploymentType);\n        metrics.put(\"mounted_config_dir\", configDirMounted);\n\n        // System info\n        metrics.put(\"os_name\", System.getProperty(\"os.name\"));\n        metrics.put(\"os_version\", System.getProperty(\"os.version\"));\n        metrics.put(\"java_version\", System.getProperty(\"java.version\"));\n        metrics.put(\"user_name\", System.getProperty(\"user.name\"));\n        metrics.put(\"user_home\", System.getProperty(\"user.home\"));\n        metrics.put(\"user_dir\", System.getProperty(\"user.dir\"));\n\n        // CPU and Memory\n        metrics.put(\"cpu_cores\", Runtime.getRuntime().availableProcessors());\n        metrics.put(\"total_memory\", Runtime.getRuntime().totalMemory());\n        metrics.put(\"free_memory\", Runtime.getRuntime().freeMemory());\n\n        // Network and Server Identity\n        InetAddress localHost = InetAddress.getLocalHost();\n        metrics.put(\"ip_address\", localHost.getHostAddress());\n        metrics.put(\"hostname\", localHost.getHostName());\n        metrics.put(\"mac_address\", getMacAddress());\n\n        // JVM info\n        metrics.put(\"jvm_vendor\", System.getProperty(\"java.vendor\"));\n        metrics.put(\"jvm_version\", System.getProperty(\"java.vm.version\"));\n\n        // Locale and Timezone\n        metrics.put(\"system_language\", System.getProperty(\"user.language\"));\n        metrics.put(\"system_country\", System.getProperty(\"user.country\"));\n        metrics.put(\"timezone\", TimeZone.getDefault().getID());\n        metrics.put(\"locale\", Locale.getDefault().toString());\n\n        // Disk info\n        File root = new File(\".\");\n        metrics.put(\"total_disk_space\", root.getTotalSpace());\n        metrics.put(\"free_disk_space\", root.getFreeSpace());\n\n        // Process info\n        metrics.put(\"process_id\", ProcessHandle.current().pid());\n\n        // JVM metrics\n        RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n        metrics.put(\"jvm_uptime_ms\", runtimeMXBean.getUptime());\n        metrics.put(\"jvm_start_time\", runtimeMXBean.getStartTime());\n\n        // Memory metrics\n        MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n        metrics.put(\"heap_memory_usage\", memoryMXBean.getHeapMemoryUsage().getUsed());\n        metrics.put(\"non_heap_memory_usage\", memoryMXBean.getNonHeapMemoryUsage().getUsed());\n\n        // CPU metrics\n        OperatingSystemMXBean osMXBean = ManagementFactory.getOperatingSystemMXBean();\n        metrics.put(\"system_load_average\", osMXBean.getSystemLoadAverage());\n\n        // Thread metrics\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        metrics.put(\"thread_count\", threadMXBean.getThreadCount());\n        metrics.put(\"daemon_thread_count\", threadMXBean.getDaemonThreadCount());\n        metrics.put(\"peak_thread_count\", threadMXBean.getPeakThreadCount());\n\n        // Garbage collection metrics\n        for (GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n            metrics.put(\"gc_\" + gcBean.getName() + \"_count\", gcBean.getCollectionCount());\n            metrics.put(\"gc_\" + gcBean.getName() + \"_time\", gcBean.getCollectionTime());\n        }\n\n        // Network interfaces\n        metrics.put(\"network_interfaces\", getNetworkInterfacesInfo());\n\n        // Docker detection and stats\n        boolean isDocker = isRunningInDocker();\n        if (isDocker) {\n            metrics.put(\"docker_metrics\", getDockerMetrics());\n        }\n\n        metrics.put(\"application_properties\", captureApplicationProperties());\n\n        if (userService != null) {\n            metrics.put(\"total_users_created\", userService.getTotalUsersCount());\n        }\n    } catch (Exception e) {\n        metrics.put(\"error\", e.getMessage());\n    }\n\n    return metrics;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "180", "src_id": "M483", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/filter-page-count\")\n    @Operation(\n            summary = \"Checks if a PDF is greater, less or equal to a setPageCount\",\n            description = \"Input:PDF Output:Boolean Type:SISO\")\n    public ResponseEntity<byte[]> pageCount(@ModelAttribute final PDFComparisonAndCount request)\n            throws IOException, InterruptedException {\n        final MultipartFile inputFile = request.getFileInput();\n        final int pageCount = request.getPageCount();\n        final String comparator = request.getComparator();\n\n        // Load the PDF\n        final PDDocument document = pdfDocumentFactory.load(inputFile);\n        final int actualPageCount = document.getNumberOfPages();\n\n        boolean valid = false;\n        // Perform the comparison\n        switch (comparator) {\n            case \"Greater\":\n                valid = actualPageCount > pageCount;\n                break;\n            case \"Equal\":\n                valid = actualPageCount == pageCount;\n                break;\n            case \"Less\":\n                valid = actualPageCount < pageCount;\n                break;\n            default:\n                throw ExceptionUtils.createInvalidArgumentException(\"comparator\", comparator);\n        }\n\n        if (valid) {\n            return WebResponseUtils.multiPartFileToWebResponse(inputFile);\n        }\n        return null;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "181", "src_id": "M602", "code": "\n    @PostMapping(value = \"/document-properties\", consumes = \"multipart/form-data\")\n    @Operation(\n            summary = \"Get PDF document properties\",\n            description = \"Returns title, author, subject, etc. Input:PDF Output:JSON Type:SISO\")\n    public Map<String, String> getDocumentProperties(@ModelAttribute final PDFFile file)\n            throws IOException {\n        // Load the document in read-only mode to prevent modifications and ensure the integrity of\n        // the original file.\n        try (PDDocument document = pdfDocumentFactory.load(file.getFileInput(), true)) {\n            final PDDocumentInformation info = document.getDocumentInformation();\n            final Map<String, String> properties = new HashMap<>();\n            properties.put(\"title\", info.getTitle());\n            properties.put(\"author\", info.getAuthor());\n            properties.put(\"subject\", info.getSubject());\n            properties.put(\"keywords\", info.getKeywords());\n            properties.put(\"creator\", info.getCreator());\n            properties.put(\"producer\", info.getProducer());\n            properties.put(\"creationDate\", info.getCreationDate().toString());\n            properties.put(\"modificationDate\", info.getModificationDate().toString());\n            return properties;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "182", "src_id": "M581", "code": "\n    public List<PDDocument> splitPdfPages(\n            final PDDocument document, final int horizontalDivisions, final int verticalDivisions)\n            throws IOException {\n        final List<PDDocument> splitDocuments = new ArrayList<>();\n\n        for (final PDPage originalPage : document.getPages()) {\n            final PDRectangle originalMediaBox = originalPage.getMediaBox();\n            final float width = originalMediaBox.getWidth();\n            final float height = originalMediaBox.getHeight();\n            final float subPageWidth = width / horizontalDivisions;\n            final float subPageHeight = height / verticalDivisions;\n\n            final LayerUtility layerUtility = new LayerUtility(document);\n\n            for (int i = 0; i < horizontalDivisions; i++) {\n                for (int j = 0; j < verticalDivisions; j++) {\n                    final PDDocument subDoc = new PDDocument();\n                    final PDPage subPage = new PDPage(new PDRectangle(subPageWidth, subPageHeight));\n                    subDoc.addPage(subPage);\n\n                    final PDFormXObject form =\n                            layerUtility.importPageAsForm(\n                                    document, document.getPages().indexOf(originalPage));\n\n                    try (PDPageContentStream contentStream =\n                            new PDPageContentStream(\n                                    subDoc, subPage, AppendMode.APPEND, true, true)) {\n                        // Set clipping area and position\n                        final float translateX = -subPageWidth * i;\n\n                        // float translateY = height - subPageHeight * (verticalDivisions - j);\n                        final float translateY = -subPageHeight * (verticalDivisions - 1 - j);\n\n                        contentStream.saveGraphicsState();\n                        contentStream.addRect(0, 0, subPageWidth, subPageHeight);\n                        contentStream.clip();\n                        contentStream.transform(new Matrix(1, 0, 0, 1, translateX, translateY));\n\n                        // Draw the form\n                        contentStream.drawForm(form);\n                        contentStream.restoreGraphicsState();\n                    }\n\n                    splitDocuments.add(subDoc);\n                }\n            }\n        }\n\n        return splitDocuments;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "183", "src_id": "M808", "code": "\n    public boolean isEndpointEnabled(final String endpoint) {\n        final String original = endpoint;\n        final String normalizedEndpoint = endpoint.startsWith(\"/\") ? endpoint.substring(1) : endpoint;\n\n        // Rule 1: Explicit flag wins - if disabled via disableEndpoint(), stay disabled\n        final Boolean explicitStatus = endpointStatuses.get(normalizedEndpoint);\n        if (Boolean.FALSE.equals(explicitStatus)) {\n            log.debug(\"isEndpointEnabled('{}') -> false (explicitly disabled)\", original);\n            return false;\n        }\n\n        // Rule 2: Functional-group override - check if endpoint belongs to any disabled functional\n        // group\n        for (final String group : endpointGroups.keySet()) {\n            if (disabledGroups.contains(group) && endpointGroups.get(group).contains(normalizedEndpoint)) {\n                // Skip tool groups (qpdf, OCRmyPDF, Ghostscript, LibreOffice, etc.)\n                if (!isToolGroup(group)) {\n                    log.debug(\n                            \"isEndpointEnabled('{}') -> false (functional group '{}' disabled)\",\n                            original,\n                            group);\n                    return false;\n                }\n            }\n        }\n\n        // Rule 3: Tool-group fallback - check if at least one alternative tool group is enabled\n        final Set<String> alternatives = endpointAlternatives.get(normalizedEndpoint);\n        if (alternatives != null && !alternatives.isEmpty()) {\n            final boolean hasEnabledToolGroup =\n                    alternatives.stream().anyMatch(toolGroup -> !disabledGroups.contains(toolGroup));\n            log.debug(\n                    \"isEndpointEnabled('{}') -> {} (tool groups check)\",\n                    original,\n                    hasEnabledToolGroup);\n            return hasEnabledToolGroup;\n        }\n\n        // Rule 4: Single-dependency check - if no alternatives defined, check if endpoint belongs\n        // to any disabled tool groups\n        for (final String group : endpointGroups.keySet()) {\n            if (isToolGroup(group)\n                    && disabledGroups.contains(group)\n                    && endpointGroups.get(group).contains(normalizedEndpoint)) {\n                log.debug(\n                        \"isEndpointEnabled('{}') -> false (single tool group '{}' disabled, no alternatives)\",\n                        original,\n                        group);\n                return false;\n            }\n        }\n\n        // Default: enabled if not explicitly disabled\n        final boolean enabled = !Boolean.FALSE.equals(explicitStatus);\n        log.debug(\"isEndpointEnabled('{}') -> {} (default)\", original, enabled);\n        return enabled;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "184", "src_id": "M456", "code": "\n    private void setupLoadHandler() {\n        final long initStartTime = System.currentTimeMillis();\n        log.info(\"Setting up load handler at: {}\", initStartTime);\n\n        client.addLoadHandler(\n                new CefLoadHandlerAdapter() {\n                    @Override\n                    public void onLoadingStateChange(\n                            final CefBrowser browser,\n                            final boolean isLoading,\n                            final boolean canGoBack,\n                            final boolean canGoForward) {\n                        log.debug(\n                                \"Loading state change - isLoading: {}, canGoBack: {}, canGoForward:\"\n                                        + \" {}, browserInitialized: {}, Time elapsed: {}ms\",\n                                isLoading,\n                                canGoBack,\n                                canGoForward,\n                                browserInitialized,\n                                System.currentTimeMillis() - initStartTime);\n\n                        if (!isLoading && !browserInitialized) {\n                            log.info(\n                                    \"Browser finished loading, preparing to initialize UI\"\n                                            + \" components\");\n                            browserInitialized = true;\n                            SwingUtilities.invokeLater(\n                                    () -> {\n                                        try {\n                                            if (loadingWindow != null) {\n                                                log.info(\"Starting UI initialization sequence\");\n\n                                                // Close loading window first\n                                                loadingWindow.setVisible(false);\n                                                loadingWindow.dispose();\n                                                loadingWindow = null;\n                                                log.info(\"Loading window disposed\");\n\n                                                // Then setup the main frame\n                                                frame.setVisible(false);\n                                                frame.dispose();\n                                                frame.setOpacity(1.0f);\n                                                frame.setUndecorated(false);\n                                                frame.pack();\n                                                frame.setSize(\n                                                        UIScaling.scaleWidth(1280),\n                                                        UIScaling.scaleHeight(800));\n                                                frame.setLocationRelativeTo(null);\n                                                log.debug(\"Frame reconfigured\");\n\n                                                // Show the main frame\n                                                frame.setVisible(true);\n                                                frame.requestFocus();\n                                                frame.toFront();\n                                                log.info(\"Main frame displayed and focused\");\n\n                                                // Focus the browser component\n                                                final Timer focusTimer =\n                                                        new Timer(\n                                                                100,\n                                                                e -> {\n                                                                    try {\n                                                                        browser.getUIComponent()\n                                                                                .requestFocus();\n                                                                        log.info(\n                                                                                \"Browser component\"\n                                                                                        + \" focused\");\n                                                                    } catch (final Exception ex) {\n                                                                        log.error(\n                                                                                \"Error focusing\"\n                                                                                        + \" browser\",\n                                                                                ex);\n                                                                    }\n                                                                });\n                                                focusTimer.setRepeats(false);\n                                                focusTimer.start();\n                                            }\n                                        } catch (final Exception e) {\n                                            log.error(\"Error during UI initialization\", e);\n                                            // Attempt cleanup on error\n                                            if (loadingWindow != null) {\n                                                loadingWindow.dispose();\n                                                loadingWindow = null;\n                                            }\n                                            if (frame != null) {\n                                                frame.setVisible(true);\n                                                frame.requestFocus();\n                                            }\n                                        }\n                                    });\n                        }\n                    }\n                });\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "185", "src_id": "M577", "code": "\n    private void processWithTesseract(\n            final List<String> selectedLanguages,\n            final String ocrType,\n            final Path tempInputFile,\n            final Path tempOutputFile)\n            throws IOException, InterruptedException {\n\n        // Create temp directory for Tesseract processing\n        try (TempDirectory tempDir = new TempDirectory(tempFileManager)) {\n            final File tempOutputDir = new File(tempDir.getPath().toFile(), \"output\");\n            final File tempImagesDir = new File(tempDir.getPath().toFile(), \"images\");\n            final File finalOutputFile = new File(tempDir.getPath().toFile(), \"final_output.pdf\");\n\n            // Create directories\n            tempOutputDir.mkdirs();\n            tempImagesDir.mkdirs();\n\n            final PDFMergerUtility merger = new PDFMergerUtility();\n            merger.setDestinationFileName(finalOutputFile.toString());\n\n            try (PDDocument document = pdfDocumentFactory.load(tempInputFile.toFile())) {\n                final PDFRenderer pdfRenderer = new PDFRenderer(document);\n                final int pageCount = document.getNumberOfPages();\n\n                for (int pageNum = 0; pageNum < pageCount; pageNum++) {\n                    final PDPage page = document.getPage(pageNum);\n                    boolean hasText = false;\n\n                    // Check for existing text\n                    try (PDDocument tempDoc = new PDDocument()) {\n                        tempDoc.addPage(page);\n                        final PDFTextStripper stripper = new PDFTextStripper();\n                        hasText = !stripper.getText(tempDoc).trim().isEmpty();\n                    }\n\n                    final boolean shouldOcr =\n                            switch (ocrType) {\n                                case \"skip-text\" -> !hasText;\n                                case \"force-ocr\" -> true;\n                                default -> true;\n                            };\n\n                    final File pageOutputPath =\n                            new File(tempOutputDir, String.format(\"page_%d.pdf\", pageNum));\n\n                    if (shouldOcr) {\n                        // Convert page to image\n                        final BufferedImage image = pdfRenderer.renderImageWithDPI(pageNum, 300);\n                        final File imagePath =\n                                new File(tempImagesDir, String.format(\"page_%d.png\", pageNum));\n                        ImageIO.write(image, \"png\", imagePath);\n\n                        // Build OCR command\n                        final List<String> command = new ArrayList<>();\n                        command.add(\"tesseract\");\n                        command.add(imagePath.toString());\n                        command.add(\n                                new File(tempOutputDir, String.format(\"page_%d\", pageNum))\n                                        .toString());\n                        command.add(\"-l\");\n                        command.add(String.join(\"+\", selectedLanguages));\n                        command.add(\"pdf\"); // Always output PDF\n\n                        final ProcessExecutorResult result =\n                                ProcessExecutor.getInstance(ProcessExecutor.Processes.TESSERACT)\n                                        .runCommandWithOutputHandling(command);\n\n                        if (result.getRc() != 0) {\n                            throw ExceptionUtils.createRuntimeException(\n                                    \"error.commandFailed\",\n                                    \"{0} command failed with exit code: {1}\",\n                                    null,\n                                    \"Tesseract\",\n                                    result.getRc());\n                        }\n\n                        // Add OCR'd PDF to merger\n                        merger.addSource(pageOutputPath);\n                    } else {\n                        // Save original page without OCR\n                        try (PDDocument pageDoc = new PDDocument()) {\n                            pageDoc.addPage(page);\n                            pageDoc.save(pageOutputPath);\n                            merger.addSource(pageOutputPath);\n                        }\n                    }\n                }\n            }\n\n            // Merge all pages into final PDF\n            merger.mergeDocuments(null);\n\n            // Copy final output to the expected location\n            Files.copy(\n                    finalOutputFile.toPath(),\n                    tempOutputFile,\n                    java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "186", "src_id": "M29", "code": "\n    private boolean processJWTLicensePayload(final String payload, final LicenseContext context) {\n        try {\n            log.info(\"Processing license payload: {}\", payload);\n\n            final JSONObject licenseData = new JSONObject(payload);\n\n            JSONObject licenseObj = licenseData.optJSONObject(\"license\");\n            if (licenseObj == null) {\n                final String id = licenseData.optString(\"id\", null);\n                if (id != null) {\n                    log.info(\"Found license ID: {}\", id);\n                    licenseObj = licenseData; // Use the root object as the license object\n                } else {\n                    log.error(\"License data not found in payload\");\n                    return false;\n                }\n            }\n\n            final String licenseId = licenseObj.optString(\"id\", \"unknown\");\n            log.info(\"Processing license with ID: {}\", licenseId);\n\n            // Check for floating license in license object\n            context.isFloatingLicense = licenseObj.optBoolean(\"floating\", false);\n            context.maxMachines = licenseObj.optInt(\"maxMachines\", 1);\n            if (context.isFloatingLicense) {\n                log.info(\"Detected floating license with max machines: {}\", context.maxMachines);\n            }\n\n            // Check expiry date\n            final String expiryStr = licenseObj.optString(\"expiry\", null);\n            if (expiryStr != null && !\"null\".equals(expiryStr)) {\n                final java.time.Instant expiry = java.time.Instant.parse(expiryStr);\n                final java.time.Instant now = java.time.Instant.now();\n\n                if (now.isAfter(expiry)) {\n                    log.error(\"License has expired on {}\", expiryStr);\n                    return false;\n                }\n\n                log.info(\"License valid until {}\", expiryStr);\n            } else {\n                log.info(\"License has no expiration date\");\n            }\n\n            // Extract account, product, policy info\n            final JSONObject accountObj = licenseData.optJSONObject(\"account\");\n            if (accountObj != null) {\n                final String accountId = accountObj.optString(\"id\", \"unknown\");\n                log.info(\"License belongs to account: {}\", accountId);\n\n                // Verify this matches your expected account ID\n                if (!ACCOUNT_ID.equals(accountId)) {\n                    log.warn(\"License account ID does not match expected account ID\");\n                    // You might want to fail verification here depending on your requirements\n                }\n            }\n\n            // Extract policy information if available\n            final JSONObject policyObj = licenseData.optJSONObject(\"policy\");\n            if (policyObj != null) {\n                final String policyId = policyObj.optString(\"id\", \"unknown\");\n                log.info(\"License uses policy: {}\", policyId);\n\n                // Check for floating license in policy\n                final boolean policyFloating = policyObj.optBoolean(\"floating\", false);\n                final int policyMaxMachines = policyObj.optInt(\"maxMachines\", 1);\n\n                // Policy settings take precedence\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                    log.info(\n                            \"Policy defines floating license with max machines: {}\",\n                            context.maxMachines);\n                }\n\n                // Extract max users and isEnterprise from policy or metadata\n                int users = policyObj.optInt(\"users\", 1);\n                context.isEnterpriseLicense = policyObj.optBoolean(\"isEnterprise\", false);\n\n                if (users > 0) {\n                    applicationProperties.getPremium().setMaxUsers(users);\n                    log.info(\"License allows for {} users\", users);\n                } else {\n                    // Try to get users from metadata if present\n                    final Object metadataObj = policyObj.opt(\"metadata\");\n                    if (metadataObj instanceof JSONObject metadata) {\n                        users = metadata.optInt(\"users\", 1);\n                        applicationProperties.getPremium().setMaxUsers(users);\n                        log.info(\"License allows for {} users (from metadata)\", users);\n\n                        // Check for isEnterprise flag in metadata\n                        context.isEnterpriseLicense = metadata.optBoolean(\"isEnterprise\", false);\n                    } else {\n                        // Default value\n                        applicationProperties.getPremium().setMaxUsers(1);\n                        log.info(\"Using default of 1 user for license\");\n                    }\n                }\n            }\n\n            return true;\n        } catch (final Exception e) {\n            log.error(\"Error processing license payload: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "187", "src_id": "M557", "code": "\n    @PostMapping(value = \"/add-page-numbers\", consumes = \"multipart/form-data\")\n    @Operation(\n            summary = \"Add page numbers to a PDF document\",\n            description =\n                    \"This operation takes an input PDF file and adds page numbers to it. Input:PDF\"\n                            + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> addPageNumbers(@ModelAttribute final AddPageNumbersRequest request)\n            throws IOException {\n\n        final MultipartFile file = request.getFileInput();\n        final String customMargin = request.getCustomMargin();\n        final int position = request.getPosition();\n        int pageNumber = request.getStartingNumber();\n        String pagesToNumber = request.getPagesToNumber();\n        String customText = request.getCustomText();\n        final float fontSize = request.getFontSize();\n        final String fontType = request.getFontType();\n\n        final PDDocument document = pdfDocumentFactory.load(file);\n        final float marginFactor;\n        switch (customMargin.toLowerCase()) {\n            case \"small\":\n                marginFactor = 0.02f;\n                break;\n            case \"large\":\n                marginFactor = 0.05f;\n                break;\n            case \"x-large\":\n                marginFactor = 0.075f;\n                break;\n            case \"medium\":\n            default:\n                marginFactor = 0.035f;\n                break;\n        }\n\n        if (pagesToNumber == null || pagesToNumber.isEmpty()) {\n            pagesToNumber = \"all\";\n        }\n        if (customText == null || customText.isEmpty()) {\n            customText = \"{n}\";\n        }\n        final List<Integer> pagesToNumberList =\n                GeneralUtils.parsePageList(pagesToNumber.split(\",\"), document.getNumberOfPages());\n\n        for (final int i : pagesToNumberList) {\n            final PDPage page = document.getPage(i);\n            final PDRectangle pageSize = page.getMediaBox();\n\n            final String text =\n                    customText\n                            .replace(\"{n}\", String.valueOf(pageNumber))\n                            .replace(\"{total}\", String.valueOf(document.getNumberOfPages()))\n                            .replace(\n                                    \"{filename}\",\n                                    Filenames.toSimpleFileName(file.getOriginalFilename())\n                                            .replaceFirst(\"[.][^.]+$\", \"\"));\n\n            final PDType1Font currentFont =\n                    switch (fontType.toLowerCase()) {\n                        case \"courier\" -> new PDType1Font(Standard14Fonts.FontName.COURIER);\n                        case \"times\" -> new PDType1Font(Standard14Fonts.FontName.TIMES_ROMAN);\n                        default -> new PDType1Font(Standard14Fonts.FontName.HELVETICA);\n                    };\n\n            float x, y;\n\n            if (position == 5) {\n                // Calculate text width and font metrics\n                final float textWidth = currentFont.getStringWidth(text) / 1000 * fontSize;\n\n                final float ascent = currentFont.getFontDescriptor().getAscent() / 1000 * fontSize;\n                final float descent = currentFont.getFontDescriptor().getDescent() / 1000 * fontSize;\n\n                final float centerX = pageSize.getLowerLeftX() + (pageSize.getWidth() / 2);\n                final float centerY = pageSize.getLowerLeftY() + (pageSize.getHeight() / 2);\n\n                x = centerX - (textWidth / 2);\n                y = centerY - (ascent + descent) / 2;\n            } else {\n                final int xGroup = (position - 1) % 3;\n                final int yGroup = 2 - (position - 1) / 3;\n\n                x =\n                        switch (xGroup) {\n                            case 0 ->\n                                    pageSize.getLowerLeftX()\n                                            + marginFactor * pageSize.getWidth(); // left\n                            case 1 ->\n                                    pageSize.getLowerLeftX() + (pageSize.getWidth() / 2); // center\n                            default ->\n                                    pageSize.getUpperRightX()\n                                            - marginFactor * pageSize.getWidth(); // right\n                        };\n\n                y =\n                        switch (yGroup) {\n                            case 0 ->\n                                    pageSize.getLowerLeftY()\n                                            + marginFactor * pageSize.getHeight(); // bottom\n                            case 1 ->\n                                    pageSize.getLowerLeftY() + (pageSize.getHeight() / 2); // middle\n                            default ->\n                                    pageSize.getUpperRightY()\n                                            - marginFactor * pageSize.getHeight(); // top\n                        };\n            }\n\n            final PDPageContentStream contentStream =\n                    new PDPageContentStream(\n                            document, page, PDPageContentStream.AppendMode.APPEND, true, true);\n            contentStream.beginText();\n            contentStream.setFont(currentFont, fontSize);\n            contentStream.newLineAtOffset(x, y);\n            contentStream.showText(text);\n            contentStream.endText();\n            contentStream.close();\n\n            pageNumber++;\n        }\n\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        document.save(baos);\n        document.close();\n\n        return WebResponseUtils.bytesToWebResponse(\n                baos.toByteArray(),\n                Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\")\n                        + \"_numbersAdded.pdf\",\n                MediaType.APPLICATION_PDF);\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "188", "src_id": "M193", "code": "\n    public int calculateDynamicQueueCapacity(final int baseCapacity, final int minCapacity) {\n        final ResourceMetrics metrics = latestMetrics.get();\n        final ResourceStatus status = currentStatus.get();\n\n        // Simple linear reduction based on memory and CPU load\n        double capacityFactor =\n                switch (status) {\n                    case OK -> 1.0;\n                    case WARNING -> 0.6;\n                    case CRITICAL -> 0.3;\n                };\n\n        // Apply additional reduction based on specific memory pressure\n        if (metrics.memoryUsage > 0.8) {\n            capacityFactor *= 0.5; // Further reduce capacity under memory pressure\n        }\n\n        // Calculate capacity with minimum safeguard\n        final int capacity = (int) Math.max(minCapacity, Math.ceil(baseCapacity * capacityFactor));\n\n        log.debug(\n                \"Dynamic queue capacity: {} (base: {}, factor: {:.2f}, status: {})\",\n                capacity,\n                baseCapacity,\n                capacityFactor,\n                status);\n\n        return capacity;\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "189", "src_id": "M141", "code": "\n    public StreamCacheCreateFunction getStreamCacheFunction(final long contentSize) {\n        final long maxMemory = Runtime.getRuntime().maxMemory();\n        final long freeMemory = Runtime.getRuntime().freeMemory();\n        final long totalMemory = Runtime.getRuntime().totalMemory();\n        final long usedMemory = totalMemory - freeMemory;\n\n        // Calculate percentage of free memory\n        final double freeMemoryPercent = (double) (maxMemory - usedMemory) / maxMemory * 100;\n        final long actualFreeMemory = maxMemory - usedMemory;\n\n        // Log memory status\n        log.debug(\n                \"Memory status - Free: {}MB ({}%), Used: {}MB, Max: {}MB\",\n                actualFreeMemory / (1024 * 1024),\n                String.format(\"%.2f\", freeMemoryPercent),\n                usedMemory / (1024 * 1024),\n                maxMemory / (1024 * 1024));\n\n        // If free memory is critically low, always use file-based caching\n        if (freeMemoryPercent < MIN_FREE_MEMORY_PERCENTAGE\n                || actualFreeMemory < MIN_FREE_MEMORY_BYTES) {\n            log.debug(\n                    \"Low memory detected ({}%), forcing file-based cache\",\n                    String.format(\"%.2f\", freeMemoryPercent));\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupTempFileOnly());\n        } else if (contentSize < SMALL_FILE_THRESHOLD) {\n            log.debug(\"Using memory-only cache for small document ({}KB)\", contentSize / 1024);\n            return IOUtils.createMemoryOnlyStreamCache();\n        } else if (contentSize < LARGE_FILE_THRESHOLD) {\n            // For medium files (10-50MB), use a mixed approach\n            log.debug(\n                    \"Using mixed memory/file cache for medium document ({}MB)\",\n                    contentSize / (1024 * 1024));\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupMixed(LARGE_FILE_USAGE));\n        } else {\n            log.debug(\"Using file-based cache for large document\");\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupTempFileOnly());\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "190", "src_id": "M345", "code": "\n@Override\npublic void onStopTrackingTouch(final SeekBar seekBar) {\n    if (DEBUG) {\n        Log.d(TAG, \"onStopTrackingTouch() called with: seekBar = [\" + seekBar + \"]\");\n    }\n\n    final int p = seekBar.getProgress();\n    player.seekTo(p);\n    if (player.getExoPlayer().getDuration() == p) {\n        player.getExoPlayer().play();\n    }\n\n    binding.playbackCurrentTime.setText(getTimeString(p));\n    animate(binding.currentDisplaySeek, false, 200, AnimationType.SCALE_AND_ALPHA);\n    animate(binding.currentSeekbarPreviewThumbnail, false, 200, AnimationType.SCALE_AND_ALPHA);\n\n    if (player.getCurrentState() == STATE_PAUSED_SEEK) {\n        player.changeState(STATE_BUFFERING);\n    }\n    if (!player.isProgressLoopRunning()) {\n        player.startProgressLoop();\n    }\n\n    showControlsThenHide();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "191", "src_id": "M374", "code": "\n@Override\npublic boolean onMenuItemClick(@NonNull final MenuItem menuItem) {\n    if (DEBUG) {\n        Log.d(TAG, \"onMenuItemClick() called with: \"\n                + \"menuItem = [\" + menuItem + \"], \"\n                + \"menuItem.getItemId = [\" + menuItem.getItemId() + \"]\");\n    }\n\n    final int g = menuItem.getGroupId();\n    if (g == POPUP_MENU_ID_QUALITY) {\n        onQualityItemClick(menuItem);\n        return true;\n    }\n    if (g == POPUP_MENU_ID_AUDIO_TRACK) {\n        onAudioTrackItemClick(menuItem);\n        return true;\n    }\n    if (g == POPUP_MENU_ID_PLAYBACK_SPEED) {\n        final int i = menuItem.getItemId();\n        final float s = PLAYBACK_SPEEDS[i];\n        player.setPlaybackSpeed(s);\n        binding.playbackSpeed.setText(formatSpeed(s));\n    }\n\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "192", "src_id": "M684", "code": "\nprivate void monitorSubscription(final ChannelInfo info) {\n    final Consumer<Throwable> err = throwable -> {\n        animate(binding.channelSubscribeButton, false, 100);\n        showSnackBarError(new ErrorInfo(throwable, UserAction.SUBSCRIPTION_GET,\n                \"Get subscription status\", currentInfo));\n    };\n\n    final Observable<List<SubscriptionEntity>> o = subscriptionManager\n            .subscriptionTable()\n            .getSubscriptionFlowable(info.getServiceId(), info.getUrl())\n            .toObservable();\n\n    disposables.add(\n            o.observeOn(AndroidSchedulers.mainThread())\n             .subscribe(getSubscribeUpdateMonitor(info), err)\n    );\n\n    disposables.add(\n            o.map(List::isEmpty)\n             .distinctUntilChanged()\n             .observeOn(AndroidSchedulers.mainThread())\n             .subscribe(isEmpty -> updateSubscribeButton(!isEmpty), err)\n    );\n\n    disposables.add(\n            o.map(List::isEmpty)\n             .distinctUntilChanged()\n             .skip(1)\n             .filter(x -> NotificationHelper.areNewStreamsNotificationsEnabled(requireContext()))\n             .observeOn(AndroidSchedulers.mainThread())\n             .subscribe(isEmpty -> {\n                 if (!isEmpty) {\n                     showNotifySnackbar();\n                 }\n             }, err)\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "193", "src_id": "M754", "code": "\nprivate void runOnVisible(final Consumer<AppCompatActivity> runnable) {\n    getActivityContext().ifPresentOrElse(c -> {\n        if (getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED)) {\n            c.runOnUiThread(() -> {\n                runnable.accept(c);\n                inFlight(false);\n            });\n            return;\n        }\n\n        getLifecycle().addObserver(new DefaultLifecycleObserver() {\n            @Override\n            public void onResume(@NonNull final LifecycleOwner owner) {\n                getLifecycle().removeObserver(this);\n                getActivityContext().ifPresentOrElse(c2 ->\n                        c2.runOnUiThread(() -> {\n                            runnable.accept(c2);\n                            inFlight(false);\n                        }),\n                        () -> inFlight(false)\n                );\n            }\n        });\n\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q && !c.isChangingConfigurations()) {\n            final Intent i = new Intent(c, RouterActivity.class);\n            i.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n            startActivity(i);\n        }\n    }, () -> inFlight(false));\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "194", "src_id": "M950", "code": "\npublic static void showMetaInfoInTextView(@Nullable final List<MetaInfo> metaInfos,\n                                          final TextView metaInfoTextView,\n                                          final View metaInfoSeparator,\n                                          final CompositeDisposable disposables) {\n    final Context ctx = metaInfoTextView.getContext();\n    if (metaInfos == null || metaInfos.isEmpty()\n            || !PreferenceManager.getDefaultSharedPreferences(ctx)\n                                 .getBoolean(ctx.getString(R.string.show_meta_info_key), true)) {\n        metaInfoTextView.setVisibility(View.GONE);\n        metaInfoSeparator.setVisibility(View.GONE);\n        return;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    for (final MetaInfo mi : metaInfos) {\n        if (!isNullOrEmpty(mi.getTitle())) {\n            sb.append(\"<b>\").append(mi.getTitle()).append(\"</b>\")\n              .append(Localization.DOT_SEPARATOR);\n        }\n\n        String s = mi.getContent().getContent().trim();\n        if (s.endsWith(\".\")) {\n            s = s.substring(0, s.length() - 1);\n        }\n        sb.append(s);\n\n        for (int i = 0; i < mi.getUrls().size(); i++) {\n            if (i == 0) {\n                sb.append(Localization.DOT_SEPARATOR);\n            } else {\n                sb.append(\"<br/><br/>\");\n            }\n\n            sb.append(\"<a href=\\\"\").append(mi.getUrls().get(i)).append(\"\\\">\")\n              .append(capitalizeIfAllUppercase(mi.getUrlTexts().get(i).trim()))\n              .append(\"</a>\");\n        }\n    }\n\n    metaInfoSeparator.setVisibility(View.VISIBLE);\n    TextLinkifier.fromHtml(metaInfoTextView, sb.toString(),\n            HtmlCompat.FROM_HTML_SEPARATOR_LINE_BREAK_HEADING, null, null, disposables,\n            SET_LINK_MOVEMENT_METHOD);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "195", "src_id": "M257", "code": "\n@Override // own playback listener\npublic void onPlaybackSynchronize(@NonNull final PlayQueueItem item, final boolean wasBlocked) {\n    if (DEBUG) {\n        Log.d(TAG, \"Playback - onPlaybackSynchronize(was blocked: \" + wasBlocked\n                + \") called with item=[\" + item.getTitle() + \"], url=[\" + item.getUrl() + \"]\");\n    }\n    if (exoPlayerIsNull() || playQueue == null || currentItem == item) {\n        return;\n    }\n\n    final int pqIdx = playQueue.indexOf(item);\n    final int plIdx = simpleExoPlayer.getCurrentMediaItemIndex();\n    final int plSize = simpleExoPlayer.getCurrentTimeline().getWindowCount();\n    final boolean removeThumb = currentItem == null\n            || currentItem.getServiceId() != item.getServiceId()\n            || !currentItem.getUrl().equals(item.getUrl());\n\n    currentItem = item;\n\n    if (pqIdx != playQueue.getIndex()) {\n        Log.e(TAG, \"Playback - Play Queue may be not in sync: item index=[\" + pqIdx + \"], \"\n                + \"queue index=[\" + playQueue.getIndex() + \"]\");\n        return;\n    }\n\n    if ((plSize > 0 && pqIdx >= plSize) || pqIdx < 0) {\n        Log.e(TAG, \"Playback - Trying to seek to invalid index=[\" + pqIdx\n                + \"] with playlist length=[\" + plSize + \"]\");\n        return;\n    }\n\n    if (wasBlocked || plIdx != pqIdx || !isPlaying()) {\n        if (DEBUG) {\n            Log.d(TAG, \"Playback - Rewinding to correct index=[\" + pqIdx + \"], \"\n                    + \"from=[\" + plIdx + \"], size=[\" + plSize + \"].\");\n        }\n\n        if (removeThumb) {\n            onThumbnailLoaded(null);\n        }\n\n        if (item.getRecoveryPosition() != PlayQueueItem.RECOVERY_UNSET) {\n            simpleExoPlayer.seekTo(pqIdx, item.getRecoveryPosition());\n            playQueue.unsetRecovery(pqIdx);\n        } else {\n            simpleExoPlayer.seekToDefaultPosition(pqIdx);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "196", "src_id": "M887", "code": "\n@Nullable\nstatic String choosePreferredImage(@NonNull final List<Image> images,\n                                   final PreferredImageQuality nonNoneQuality) {\n    final double wOverH = images.stream()\n            .filter(i -> i.getHeight() != HEIGHT_UNKNOWN && i.getWidth() != WIDTH_UNKNOWN)\n            .mapToDouble(i -> ((double) i.getWidth()) / i.getHeight())\n            .findFirst()\n            .orElse(1.0);\n\n    final Image.ResolutionLevel pref = nonNoneQuality.toResolutionLevel();\n    final Comparator<Image> first = Comparator\n            .<Image>comparingInt(i -> {\n                if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.UNKNOWN) {\n                    return 3;\n                } else if (i.getEstimatedResolutionLevel() == pref) {\n                    return 0;\n                } else if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.MEDIUM) {\n                    return 1;\n                } else {\n                    return 2;\n                }\n            })\n            .thenComparing(i ->\n                    i.getHeight() == HEIGHT_UNKNOWN && i.getWidth() == WIDTH_UNKNOWN);\n\n    final Comparator<Image> last = switch (nonNoneQuality) {\n        case NONE -> first; // unreachable\n        case LOW -> first.thenComparingDouble(i -> {\n            final double px = estimatePixelCount(i, wOverH);\n            return Math.abs(px - BEST_LOW_H * BEST_LOW_H * wOverH);\n        });\n        case MEDIUM -> first.thenComparingDouble(i -> {\n            final double px = estimatePixelCount(i, wOverH);\n            return Math.abs(px - BEST_MEDIUM_H * BEST_MEDIUM_H * wOverH);\n        });\n        case HIGH -> first.thenComparingDouble(i -> -estimatePixelCount(i, wOverH));\n    };\n\n    return images.stream()\n            .min(last)\n            .map(Image::getUrl)\n            .orElse(null);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "197", "src_id": "M667", "code": "\nprivate void updateTabLayoutPosition() {\n    final ScrollableTabLayout tabLayout = binding.mainTabLayout;\n    final ViewPager viewPager = binding.pager;\n    final boolean bottom = mainTabsPositionBottom;\n\n    final RelativeLayout.LayoutParams tabParams =\n            (RelativeLayout.LayoutParams) tabLayout.getLayoutParams();\n    final RelativeLayout.LayoutParams pagerParams =\n            (RelativeLayout.LayoutParams) viewPager.getLayoutParams();\n\n    tabParams.removeRule(bottom ? ALIGN_PARENT_TOP : ALIGN_PARENT_BOTTOM);\n    tabParams.addRule(bottom ? ALIGN_PARENT_BOTTOM : ALIGN_PARENT_TOP);\n    pagerParams.removeRule(bottom ? BELOW : ABOVE);\n    pagerParams.addRule(bottom ? ABOVE : BELOW, R.id.main_tab_layout);\n    tabLayout.setSelectedTabIndicatorGravity(\n            bottom ? INDICATOR_GRAVITY_TOP : INDICATOR_GRAVITY_BOTTOM);\n\n    tabLayout.setLayoutParams(tabParams);\n    viewPager.setLayoutParams(pagerParams);\n\n    tabLayout.setBackgroundColor(ThemeHelper.resolveColorFromAttr(requireContext(),\n            bottom ? android.R.attr.windowBackground : R.attr.colorPrimary));\n\n    @ColorInt final int iconColor = bottom\n            ? ThemeHelper.resolveColorFromAttr(requireContext(), android.R.attr.colorAccent)\n            : Color.WHITE;\n    tabLayout.setTabRippleColor(ColorStateList.valueOf(iconColor).withAlpha(32));\n    tabLayout.setTabIconTint(ColorStateList.valueOf(iconColor));\n    tabLayout.setSelectedTabIndicatorColor(iconColor);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "198", "src_id": "M395", "code": "\n@Override\nprotected void setupElementsVisibility() {\n    binding.fullScreenButton.setVisibility(View.VISIBLE);\n    binding.screenRotationButton.setVisibility(View.GONE);\n    binding.resizeTextView.setVisibility(View.GONE);\n    binding.getRoot().findViewById(R.id.metadataView).setVisibility(View.GONE);\n    binding.queueButton.setVisibility(View.GONE);\n    binding.segmentsButton.setVisibility(View.GONE);\n    binding.moreOptionsButton.setVisibility(View.GONE);\n    binding.topControls.setOrientation(LinearLayout.HORIZONTAL);\n    binding.primaryControls.getLayoutParams().width = WRAP_CONTENT;\n    binding.secondaryControls.setAlpha(1.0f);\n    binding.secondaryControls.setVisibility(View.VISIBLE);\n    binding.secondaryControls.setTranslationY(0);\n    binding.share.setVisibility(View.GONE);\n    binding.playWithKodi.setVisibility(View.GONE);\n    binding.openInBrowser.setVisibility(View.GONE);\n    binding.switchMute.setVisibility(View.GONE);\n    binding.playerCloseButton.setVisibility(View.GONE);\n    binding.topControls.bringToFront();\n    binding.topControls.setClickable(false);\n    binding.topControls.setFocusable(false);\n    binding.bottomControls.bringToFront();\n    super.setupElementsVisibility();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "199", "src_id": "M338", "code": "\nprivate void updateEndScreenThumbnail(@Nullable final Bitmap thumbnail) {\n    if (thumbnail == null) {\n        binding.endScreen.setImageDrawable(null);\n        return;\n    }\n\n    final float h = calculateMaxEndScreenThumbnailHeight(thumbnail);\n    final Bitmap end = BitmapCompat.createScaledBitmap(\n            thumbnail,\n            (int) (thumbnail.getWidth() / (thumbnail.getHeight() / h)),\n            (int) h,\n            null,\n            true\n    );\n\n    if (DEBUG) {\n        Log.d(TAG, \"Thumbnail - onThumbnailLoaded() called with: \"\n                + \"currentThumbnail = [\" + thumbnail + \"], \"\n                + thumbnail.getWidth() + \"x\" + thumbnail.getHeight()\n                + \", scaled end screen height = \" + h\n                + \", scaled end screen width = \" + end.getWidth());\n    }\n\n    binding.endScreen.setImageBitmap(end);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1058", "code": "\n    private void startMission(Intent intent) {\n        final String[] urls = intent.getStringArrayExtra(EXTRA_URLS);\n        final Uri path = IntentCompat.getParcelableExtra(intent, EXTRA_PATH, Uri.class);\n        final Uri parentPath = IntentCompat.getParcelableExtra(intent, EXTRA_PARENT_PATH, Uri.class);\n        final int threads = intent.getIntExtra(EXTRA_THREADS, 1);\n        final char kind = intent.getCharExtra(EXTRA_KIND, '?');\n        final String psName = intent.getStringExtra(EXTRA_POSTPROCESSING_NAME);\n        final String[] psArgs = intent.getStringArrayExtra(EXTRA_POSTPROCESSING_ARGS);\n        final String source = intent.getStringExtra(EXTRA_SOURCE);\n        final long nearLength = intent.getLongExtra(EXTRA_NEAR_LENGTH, 0);\n        final String tag = intent.getStringExtra(EXTRA_STORAGE_TAG);\n        final var recovery = IntentCompat.getParcelableArrayListExtra(intent, EXTRA_RECOVERY_INFO, MissionRecoveryInfo.class);\n        Objects.requireNonNull(recovery);\n\n        final StoredFileHelper storage;\n        try {\n            storage = new StoredFileHelper(this, parentPath, path, tag);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        final Postprocessing ps = psName == null ? null : Postprocessing.getAlgorithm(psName, psArgs);\n\n        final DownloadMission mission = new DownloadMission(urls, storage, kind, ps);\n        mission.threadCount = threads;\n        mission.source = source;\n        mission.nearLength = nearLength;\n        mission.recoveryInfo = recovery.toArray(new MissionRecoveryInfo[0]);\n\n        if (ps != null) {\n            ps.setTemporalDir(DownloadManager.pickAvailableTemporalDir(this));\n        }\n\n        handleConnectivityState(true);\n\n        mManager.startMission(mission);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1037", "code": "\n    public void pause() {\n        if (!running) {\n            return;\n        }\n\n        if (isPsRunning()) {\n            if (DEBUG) {\n                Log.w(TAG, \"pause during post-processing is not applicable.\");\n            }\n            return;\n        }\n\n        running = false;\n        notify(DownloadManagerService.MESSAGE_PAUSED);\n\n        if (init != null && init.isAlive()) {\n            // NOTE: if start() method is running ¡will no have effect!\n            init.interrupt();\n            synchronized (LOCK) {\n                resetState(false, true, ERROR_NOTHING);\n            }\n            return;\n        }\n\n        if (DEBUG && unknownLength) {\n            Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n        }\n\n        init = null;\n        pauseThreads();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "202", "src_id": "M1081", "code": "\n    void handleConnectivityState(NetworkState currentStatus, boolean updateOnly) {\n        if (currentStatus == mLastNetworkStatus) {\n            return;\n        }\n\n        mLastNetworkStatus = currentStatus;\n\n        if (currentStatus == NetworkState.Unavailable) {\n            return;\n        }\n\n        if (!mSelfMissionsControl || updateOnly) {\n            return; // don't touch anything without the user interaction\n        }\n\n        final boolean isMetered = mPrefMeteredDownloads && mLastNetworkStatus == NetworkState.MeteredOperating;\n\n        synchronized (this) {\n            for (DownloadMission mission : mMissionsPending) {\n                if (mission.isCorrupt() || mission.isPsRunning()) {\n                    continue;\n                }\n\n                if (mission.running && isMetered) {\n                    mission.pause();\n                } else if (!mission.running && !isMetered && mission.enqueued) {\n                    mission.start();\n                    if (mPrefQueueLimit) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "203", "src_id": "M1099", "code": "\n    @SuppressLint(\"DefaultLocale\")\n    private void updateProgress(ViewHolderItem h) {\n        if (h == null || h.item == null || h.item.mission instanceof FinishedMission) {\n            return;\n        }\n\n        final DownloadMission mission = (DownloadMission) h.item.mission;\n        final double done = mission.done;\n        final long length = mission.getLength();\n        final long now = System.currentTimeMillis();\n        final boolean hasError = mission.errCode != ERROR_NOTHING;\n\n        // hide on error\n        // show if current resource length is not fetched\n        // show if length is unknown\n        h.progress.setMarquee(\n                mission.isRecovering() || (!hasError && (!mission.isInitialized() || mission.unknownLength))\n        );\n\n        double progress;\n        if (mission.unknownLength) {\n            progress = Double.NaN;\n            h.progress.setProgress(0.0f);\n        } else {\n            progress = done / length;\n        }\n\n        if (hasError) {\n            h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n            h.status.setText(R.string.msg_error);\n        } else if (isNotFinite(progress)) {\n            h.status.setText(UNDEFINED_PROGRESS);\n        } else {\n            h.status.setText(String.format(\"%.2f%%\", progress * 100));\n            h.progress.setProgress(progress);\n        }\n\n        final String sizeStr = Utility.formatBytes(length).concat(\"  \");\n        @StringRes int state;\n\n        if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n            h.size.setText(sizeStr);\n            return;\n        } else if (!mission.running) {\n            state = mission.enqueued ? R.string.queued : R.string.paused;\n        } else if (mission.isPsRunning()) {\n            state = R.string.post_processing;\n        } else if (mission.isRecovering()) {\n            state = R.string.recovering;\n        } else {\n            state = 0;\n        }\n\n        if (state != 0) {\n            // update state without download speed\n            h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n            h.resetSpeedMeasure();\n            return;\n        }\n\n        if (h.lastTimestamp < 0) {\n            h.size.setText(sizeStr);\n            h.lastTimestamp = now;\n            h.lastDone = done;\n            return;\n        }\n\n        final long deltaTime = now - h.lastTimestamp;\n        final double deltaDone = done - h.lastDone;\n\n        if (h.lastDone > done) {\n            h.lastDone = done;\n            h.size.setText(sizeStr);\n            return;\n        }\n\n        if (deltaDone > 0 && deltaTime > 0) {\n            final float speed = (float) ((deltaDone * 1000d) / deltaTime);\n            float averageSpeed = speed;\n\n            if (h.lastSpeedIdx < 0) {\n                Arrays.fill(h.lastSpeed, speed);\n                h.lastSpeedIdx = 0;\n            } else {\n                for (int i = 0; i < h.lastSpeed.length; i++) {\n                    averageSpeed += h.lastSpeed[i];\n                }\n                averageSpeed /= h.lastSpeed.length + 1.0f;\n            }\n\n            final String speedStr = Utility.formatSpeed(averageSpeed);\n            final String etaStr;\n\n            if (mission.unknownLength) {\n                etaStr = \"\";\n            } else {\n                final long eta = (long) Math.ceil((length - done) / averageSpeed);\n                etaStr = Utility.formatBytes((long) done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n            }\n\n            h.size.setText(sizeStr.concat(etaStr).concat(speedStr));\n\n            h.lastTimestamp = now;\n            h.lastDone = done;\n            h.lastSpeed[h.lastSpeedIdx++] = speed;\n\n            if (h.lastSpeedIdx >= h.lastSpeed.length) {\n                h.lastSpeedIdx = 0;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "204", "src_id": "M852", "code": "\n    public InputStream getView(final int size) {\n        if (view == null) {\n            view = new InputStream() {\n                @Override\n                public int read() throws IOException {\n                    if (viewSize < 1) {\n                        return -1;\n                    }\n                    final int res = DataReader.this.read();\n                    if (res > 0) {\n                        viewSize--;\n                    }\n                    return res;\n                }\n\n                @Override\n                public int read(final byte[] buffer) throws IOException {\n                    return read(buffer, 0, buffer.length);\n                }\n\n                @Override\n                public int read(final byte[] buffer, final int offset, final int count) throws IOException {\n                    if (viewSize < 1) {\n                        return -1;\n                    }\n\n                    final int res = DataReader.this.read(buffer, offset, Math.min(viewSize, count));\n                    viewSize -= res;\n\n                    return res;\n                }\n\n                @Override\n                public long skip(final long amount) throws IOException {\n                    if (viewSize < 1) {\n                        return 0;\n                    }\n\n                    final int res = (int) DataReader.this.skipBytes(Math.min(amount, viewSize));\n                    viewSize -= res;\n\n                    return res;\n                }\n\n                @Override\n                public int available() {\n                    return viewSize;\n                }\n\n                @Override\n                public void close() {\n                    viewSize = 0;\n                }\n\n                @Override\n                public boolean markSupported() {\n                    return false;\n                }\n            };\n        }\n\n        viewSize = size;\n\n        return view;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "205", "src_id": "M850", "code": "\n    public int read(final byte[] buffer, final int off, final int c) throws IOException {\n        int offset = off;\n        int count = c;\n\n        if (readCount < 0) {\n            return -1;\n        }\n\n        int total = 0;\n\n        if (count >= readBuffer.length) {\n            if (readCount > 0) {\n                System.arraycopy(readBuffer, readOffset, buffer, offset, readCount);\n                readOffset += readCount;\n\n                offset += readCount;\n                count -= readCount;\n\n                total = readCount;\n                readCount = 0;\n            }\n            total += Math.max(stream.read(buffer, offset, count), 0);\n        } else {\n            while (count > 0 && !fillBuffer()) {\n                final int read = Math.min(readCount, count);\n                System.arraycopy(readBuffer, readOffset, buffer, offset, read);\n\n                readOffset += read;\n                readCount -= read;\n\n                offset += read;\n                count -= read;\n\n                total += read;\n            }\n        }\n\n        position += total;\n        return total;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "206", "src_id": "M803", "code": "\n    public void parse() throws IOException, NoSuchElementException {\n        if (selectedTrack > -1) {\n            return;\n        }\n\n        box = readBox(ATOM_FTYP);\n        brands = parseFtyp(box);\n        switch (brands[0]) {\n            case BRAND_DASH:\n            case BRAND_ISO5: // ¿why not?\n                break;\n            default:\n                throw new NoSuchElementException(\n                        \"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \"\n                                + boxName(brands[0])\n                );\n        }\n\n        Moov moov = null;\n        int i;\n\n        while (box.type != ATOM_MOOF) {\n            ensure(box);\n            box = readBox();\n\n            switch (box.type) {\n                case ATOM_MOOV:\n                    moov = parseMoov(box);\n                    break;\n                case ATOM_SIDX:\n                case ATOM_MFRA:\n                    break;\n            }\n        }\n\n        if (moov == null) {\n            throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n        }\n\n        tracks = new Mp4Track[moov.trak.length];\n\n        for (i = 0; i < tracks.length; i++) {\n            tracks[i] = new Mp4Track();\n            tracks[i].trak = moov.trak[i];\n\n            if (moov.mvexTrex != null) {\n                for (final Trex mvexTrex : moov.mvexTrex) {\n                    if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n                        tracks[i].trex = mvexTrex;\n                    }\n                }\n            }\n\n            switch (moov.trak[i].mdia.hdlr.subType) {\n                case HANDLER_VIDE:\n                    tracks[i].kind = TrackKind.Video;\n                    break;\n                case HANDLER_SOUN:\n                    tracks[i].kind = TrackKind.Audio;\n                    break;\n                case HANDLER_SUBT:\n                    tracks[i].kind = TrackKind.Subtitles;\n                    break;\n                default:\n                    tracks[i].kind = TrackKind.Other;\n                    break;\n            }\n        }\n\n        backupBox = box;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "207", "src_id": "M1066", "code": "\n    private void loadPendingMissions(Context ctx) {\n        final File[] subs = mPendingMissionsDir.listFiles();\n\n        if (subs == null) {\n            Log.e(TAG, \"listFiles() returned null\");\n            return;\n        }\n        if (subs.length < 1) {\n            return;\n        }\n        if (DEBUG) {\n            Log.d(TAG, \"Loading pending downloads from directory: \" + mPendingMissionsDir.getAbsolutePath());\n        }\n\n        final File tempDir = pickAvailableTemporalDir(ctx);\n        Log.i(TAG, \"using '\" + tempDir + \"' as temporal directory\");\n\n        for (File sub : subs) {\n            if (!sub.isFile()) {\n                continue;\n            }\n            if (sub.getName().equals(\".tmp\")) {\n                continue;\n            }\n\n            final DownloadMission mis = Utility.readFromFile(sub);\n            if (mis == null || mis.isFinished() || mis.hasInvalidStorage()) {\n                //noinspection ResultOfMethodCallIgnored\n                sub.delete();\n                continue;\n            }\n\n            mis.threads = new Thread[0];\n\n            final boolean exists;\n            try {\n                mis.storage = StoredFileHelper.deserialize(mis.storage, ctx);\n                exists = !mis.storage.isInvalid() && mis.storage.existsAsFile();\n            } catch (Exception ex) {\n                Log.e(TAG, \"Failed to load the file source of \" + mis.storage.toString(), ex);\n                mis.storage.invalidate();\n                exists = false;\n            }\n\n            if (mis.isPsRunning()) {\n                if (mis.psAlgorithm.worksOnSameFile) {\n                    // Incomplete post-processing results in a corrupted download file\n                    // because the selected algorithm works on the same file to save space.\n                    // the file will be deleted if the storage API\n                    // is Java IO (avoid showing the \"Save as...\" dialog)\n                    if (exists && mis.storage.isDirect() && !mis.storage.delete()) {\n                        Log.w(TAG, \"Unable to delete incomplete download file: \" + sub.getPath());\n                    }\n                }\n\n                mis.psState = 0;\n                mis.errCode = DownloadMission.ERROR_POSTPROCESSING_STOPPED;\n            } else if (!exists) {\n                tryRecover(mis);\n\n                // the progress is lost, reset mission state\n                if (mis.isInitialized()) {\n                    mis.resetState(true, true, DownloadMission.ERROR_PROGRESS_LOST);\n                }\n            }\n\n            if (mis.psAlgorithm != null) {\n                mis.psAlgorithm.cleanupTemporalDir();\n                mis.psAlgorithm.setTemporalDir(tempDir);\n            }\n\n            mis.metadata = sub;\n            mis.maxRetry = mPrefMaxRetry;\n            mis.mHandler = mHandler;\n\n            mMissionsPending.add(mis);\n        }\n\n        if (mMissionsPending.size() > 1) {\n            Collections.sort(mMissionsPending, Comparator.comparingLong(Mission::getTimestamp));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "208", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n            for (;;) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                // noting to do here\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n\n            final boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "209", "src_id": "M361", "code": "\nprivate static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n    try {\n        if (!isValidJakartaMailPart(part)) {\n            log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n            return;\n        }\n\n        Class<?> partClass = part.getClass();\n        Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n        Method getContent = partClass.getMethod(\"getContent\");\n        Method getDisposition = partClass.getMethod(\"getDisposition\");\n        Method getFileName = partClass.getMethod(\"getFileName\");\n        Method getContentType = partClass.getMethod(\"getContentType\");\n        Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n        Object disposition = getDisposition.invoke(part);\n        String filename = (String) getFileName.invoke(part);\n        String contentType = (String) getContentType.invoke(part);\n\n        if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n            content.setTextBody((String) getContent.invoke(part));\n        } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n            content.setHtmlBody((String) getContent.invoke(part));\n        } else if (\"attachment\".equalsIgnoreCase((String) disposition)\n                || (filename != null && !filename.trim().isEmpty())) {\n\n            content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n            // Always extract basic attachment metadata for display\n            if (filename != null && !filename.trim().isEmpty()) {\n                // Create attachment with metadata only\n                EmailAttachment attachment = new EmailAttachment();\n                // Apply MIME decoding to filename to handle encoded attachment names\n                attachment.setFilename(safeMimeDecode(filename));\n                attachment.setContentType(contentType);\n\n                // Check if it's an embedded image\n                String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n                if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                    attachment.setEmbedded(true);\n                    // Store the Content-ID, removing angle brackets if present\n                    String contentId = contentIdHeaders[0];\n                    if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                        contentId = contentId.substring(1, contentId.length() - 1);\n                    }\n                    attachment.setContentId(contentId);\n                }\n\n                // Extract attachment data if attachments should be included OR if it's an embedded image (needed for inline display)\n                if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n                    try {\n                        Object attachmentContent = getContent.invoke(part);\n                        byte[] attachmentData = null;\n\n                        if (attachmentContent instanceof java.io.InputStream) {\n                            java.io.InputStream inputStream = (java.io.InputStream) attachmentContent;\n                            try {\n                                attachmentData = inputStream.readAllBytes();\n                            } catch (IOException e) {\n                                log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n                            }\n                        } else if (attachmentContent instanceof byte[]) {\n                            byte[] byteArray = (byte[]) attachmentContent;\n                            attachmentData = byteArray;\n                        } else if (attachmentContent instanceof String) {\n                            String stringContent = (String) attachmentContent;\n                            attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n                        }\n\n                        if (attachmentData != null) {\n                            // Check size limit (use default 10MB if request is null)\n                            long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                            long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                            if (attachmentData.length <= maxSizeBytes) {\n                                attachment.setData(attachmentData);\n                                attachment.setSizeBytes(attachmentData.length);\n                            } else {\n                                // For embedded images, always include data regardless of size to ensure inline display works\n                                if (attachment.isEmbedded()) {\n                                    attachment.setData(attachmentData);\n                                    attachment.setSizeBytes(attachmentData.length);\n                                } else {\n                                    // Still show attachment info even if too large\n                                    attachment.setSizeBytes(attachmentData.length);\n                                }\n                            }\n                        }\n                    } catch (Exception e) {\n                        log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n                    }\n                }\n\n                // Add attachment to the list for display (with or without data)\n                content.getAttachments().add(attachment);\n            }\n        } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n            // Handle nested multipart content\n            try {\n                Object multipartContent = getContent.invoke(part);\n                Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(multipartContent)) {\n                    processMultipartAdvanced(multipartContent, content, request);\n                }\n            } catch (Exception e) {\n                log.warn(\"Error processing multipart content: {}\", e.getMessage());\n            }\n        }\n\n    } catch (Exception e) {\n        log.warn(\"Error processing multipart part: {}\", e.getMessage());\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "210", "src_id": "M347", "code": "\nprivate static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n    // Create attachment info with paperclip emoji before filename\n    attachmentInfo\n            .append(\"<div class=\\\"attachment-item\\\">\")\n            .append(\"<span class=\\\"attachment-icon\\\">\")\n            .append(MimeConstants.ATTACHMENT_MARKER)\n            .append(\"</span> \")\n            .append(\"<span class=\\\"attachment-name\\\">\")\n            .append(escapeHtml(filename))\n            .append(\"</span>\");\n\n    // Add content type and encoding info\n    if (!contentType.isEmpty() || !encoding.isEmpty()) {\n        attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n        if (!contentType.isEmpty()) {\n            attachmentInfo.append(escapeHtml(contentType));\n        }\n        if (!encoding.isEmpty()) {\n            if (!contentType.isEmpty()) {\n                attachmentInfo.append(\", \");\n            }\n            attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n        }\n        attachmentInfo.append(\")</span>\");\n    }\n    attachmentInfo.append(\"</div>\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "211", "src_id": "M567", "code": "\n@PostMapping(value = \"/scanner-effect\", consumes = \"multipart/form-data\")\n@Operation(\n        summary = \"Apply scanner effect to PDF\",\n        description =\n                \"Applies various effects to simulate a scanned document, including rotation, noise, and edge softening. Input:PDF Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> scannerEffect(@Valid @ModelAttribute ScannerEffectRequest request) throws IOException {\n    MultipartFile file = request.getFileInput();\n\n    // Apply preset first if needed\n    if (!request.isAdvancedEnabled()) {\n        switch (request.getQuality()) {\n            case high:\n                request.applyHighQualityPreset();\n                break;\n            case medium:\n                request.applyMediumQualityPreset();\n                break;\n            case low:\n                request.applyLowQualityPreset();\n                break;\n            default:\n                break;\n        }\n    }\n\n    // Extract values after preset application\n    int baseRotation = request.getRotationValue() + request.getRotate();\n    int rotateVariance = request.getRotateVariance();\n    int borderPx = request.getBorder();\n    float brightness = request.getBrightness();\n    float contrast = request.getContrast();\n    float blur = request.getBlur();\n    float noise = request.getNoise();\n    boolean yellowish = request.isYellowish();\n    int resolution = request.getResolution();\n    ScannerEffectRequest.Colorspace colorspace = request.getColorspace();\n\n    try (PDDocument document = pdfDocumentFactory.load(file)) {\n        PDDocument outputDocument = new PDDocument();\n        PDFRenderer pdfRenderer = new PDFRenderer(document);\n\n        for (int i = 0; i < document.getNumberOfPages(); i++) {\n            // Get page dimensions to calculate safe resolution\n            PDRectangle pageSize = document.getPage(i).getMediaBox();\n            float pageWidthPts = pageSize.getWidth();\n            float pageHeightPts = pageSize.getHeight();\n\n            // Calculate what the image dimensions would be at the requested resolution\n            int projectedWidth = (int) Math.ceil(pageWidthPts * resolution / 72.0);\n            int projectedHeight = (int) Math.ceil(pageHeightPts * resolution / 72.0);\n            long projectedPixels = (long) projectedWidth * projectedHeight;\n\n            // Calculate safe resolution that stays within limits\n            int safeResolution = resolution;\n            if (projectedWidth > MAX_IMAGE_WIDTH\n                    || projectedHeight > MAX_IMAGE_HEIGHT\n                    || projectedPixels > MAX_IMAGE_PIXELS) {\n                double widthScale = (double) MAX_IMAGE_WIDTH / projectedWidth;\n                double heightScale = (double) MAX_IMAGE_HEIGHT / projectedHeight;\n                double pixelScale = Math.sqrt((double) MAX_IMAGE_PIXELS / projectedPixels);\n                double minScale = Math.min(Math.min(widthScale, heightScale), pixelScale);\n                safeResolution = (int) Math.max(72, resolution * minScale);\n\n                log.warn(\n                        \"Page {} would be too large at {}dpi ({}x{} pixels). Reducing to {}dpi\",\n                        i + 1,\n                        resolution,\n                        projectedWidth,\n                        projectedHeight,\n                        safeResolution);\n            }\n\n            // Render page to image with safe resolution\n            BufferedImage image = pdfRenderer.renderImageWithDPI(i, safeResolution);\n\n            log.debug(\n                    \"Processing page {} with dimensions {}x{} ({} pixels) at {}dpi\",\n                    i + 1,\n                    image.getWidth(),\n                    image.getHeight(),\n                    (long) image.getWidth() * image.getHeight(),\n                    safeResolution);\n\n            // 1. Convert to grayscale or keep color\n            BufferedImage processed;\n            if (colorspace == ScannerEffectRequest.Colorspace.grayscale) {\n                processed = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);\n                Graphics2D gGray = processed.createGraphics();\n                gGray.setColor(Color.BLACK);\n                gGray.fillRect(0, 0, image.getWidth(), image.getHeight());\n                gGray.drawImage(image, 0, 0, null);\n                gGray.dispose();\n\n                // Convert to grayscale manually\n                for (int y = 0; y < processed.getHeight(); y++) {\n                    for (int x = 0; x < processed.getWidth(); x++) {\n                        int rgb = processed.getRGB(x, y);\n                        int r = (rgb >> 16) & 0xFF;\n                        int g = (rgb >> 8) & 0xFF;\n                        int b = rgb & 0xFF;\n                        int gray = (r + g + b) / 3;\n                        int grayRGB = (gray << 16) | (gray << 8) | gray;\n                        processed.setRGB(x, y, grayRGB);\n                    }\n                }\n            } else {\n                processed = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);\n                Graphics2D gCol = processed.createGraphics();\n                gCol.drawImage(image, 0, 0, null);\n                gCol.dispose();\n            }\n\n            // 2. Add border with randomized grey gradient\n            int baseW = processed.getWidth() + 2 * borderPx;\n            int baseH = processed.getHeight() + 2 * borderPx;\n            boolean vertical = RANDOM.nextBoolean();\n            float startGrey = 0.6f + 0.3f * RANDOM.nextFloat();\n            float endGrey = 0.6f + 0.3f * RANDOM.nextFloat();\n            Color startColor = new Color(Math.round(startGrey * 255), Math.round(startGrey * 255), Math.round(startGrey * 255));\n            Color endColor = new Color(Math.round(endGrey * 255), Math.round(endGrey * 255), Math.round(endGrey * 255));\n            BufferedImage composed = new BufferedImage(baseW, baseH, processed.getType());\n            Graphics2D gBg = composed.createGraphics();\n            for (int y = 0; y < baseH; y++) {\n                for (int x = 0; x < baseW; x++) {\n                    float frac = vertical ? (float) y / (baseH - 1) : (float) x / (baseW - 1);\n                    int r = Math.round(startColor.getRed() + (endColor.getRed() - startColor.getRed()) * frac);\n                    int g = Math.round(startColor.getGreen() + (endColor.getGreen() - startColor.getGreen()) * frac);\n                    int b = Math.round(startColor.getBlue() + (endColor.getBlue() - startColor.getBlue()) * frac);\n                    composed.setRGB(x, y, new Color(r, g, b).getRGB());\n                }\n            }\n            gBg.drawImage(processed, borderPx, borderPx, null);\n            gBg.dispose();\n\n            // 3. Rotate the entire composed image\n            double pageRotation = baseRotation;\n            if (baseRotation != 0 || rotateVariance != 0) {\n                pageRotation += (RANDOM.nextDouble() * 2 - 1) * rotateVariance;\n            }\n\n            BufferedImage rotated;\n            int w = composed.getWidth();\n            int h = composed.getHeight();\n            int rotW = w;\n            int rotH = h;\n\n            // Skip rotation entirely if no rotation is needed\n            if (pageRotation == 0) {\n                rotated = composed;\n            } else {\n                double radians = Math.toRadians(pageRotation);\n                double sin = Math.abs(Math.sin(radians));\n                double cos = Math.abs(Math.cos(radians));\n                rotW = (int) Math.floor(w * cos + h * sin);\n                rotH = (int) Math.floor(h * cos + w * sin);\n                BufferedImage rotatedBg = new BufferedImage(rotW, rotH, composed.getType());\n                Graphics2D gBgRot = rotatedBg.createGraphics();\n                for (int y = 0; y < rotH; y++) {\n                    for (int x = 0; x < rotW; x++) {\n                        float frac = vertical ? (float) y / (rotH - 1) : (float) x / (rotW - 1);\n                        int r = Math.round(startColor.getRed() + (endColor.getRed() - startColor.getRed()) * frac);\n                        int g = Math.round(startColor.getGreen() + (endColor.getGreen() - startColor.getGreen()) * frac);\n                        int b = Math.round(startColor.getBlue() + (endColor.getBlue() - startColor.getBlue()) * frac);\n                        rotatedBg.setRGB(x, y, new Color(r, g, b).getRGB());\n                    }\n                }\n                gBgRot.dispose();\n                rotated = new BufferedImage(rotW, rotH, composed.getType());\n                Graphics2D g2d = rotated.createGraphics();\n                g2d.drawImage(rotatedBg, 0, 0, null);\n                AffineTransform at = new AffineTransform();\n                at.translate((rotW - w) / 2.0, (rotH - h) / 2.0);\n                at.rotate(radians, w / 2.0, h / 2.0);\n                g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n                g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n                g2d.drawImage(composed, at, null);\n                g2d.dispose();\n            }\n\n            // 4. Scale and center the rotated image to cover the original page size\n            PDRectangle origPageSize = document.getPage(i).getMediaBox();\n            float origW = origPageSize.getWidth();\n            float origH = origPageSize.getHeight();\n            float scale = Math.max(origW / rotW, origH / rotH);\n            float drawW = rotW * scale;\n            float drawH = rotH * scale;\n            float offsetX = (origW - drawW) / 2f;\n            float offsetY = (origH - drawH) / 2f;\n\n            // 5. Apply adaptive blur and edge softening\n            BufferedImage softened = softenEdges(\n                    rotated,\n                    Math.max(10, Math.round(Math.min(rotW, rotH) * 0.02f)),\n                    startColor,\n                    endColor,\n                    vertical);\n            BufferedImage blurred = applyGaussianBlur(softened, blur);\n\n            // 6. Adjust brightness and contrast\n            BufferedImage adjusted = adjustBrightnessContrast(blurred, brightness, contrast);\n\n            // 7. Add noise and yellowish effect to the content\n            if (yellowish) {\n                applyYellowishEffect(adjusted);\n            }\n            addGaussianNoise(adjusted, noise);\n\n            // 8. Write to PDF\n            PDPage newPage = new PDPage(new PDRectangle(origW, origH));\n            outputDocument.addPage(newPage);\n            try (PDPageContentStream contentStream = new PDPageContentStream(outputDocument, newPage)) {\n                PDImageXObject pdImage = LosslessFactory.createFromImage(outputDocument, adjusted);\n                contentStream.drawImage(pdImage, offsetX, offsetY, drawW, drawH);\n            }\n        }\n\n        // Save to byte array\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        outputDocument.save(outputStream);\n        outputDocument.close();\n\n        String outputFilename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_scanner_effect.pdf\";\n\n        return WebResponseUtils.bytesToWebResponse(outputStream.toByteArray(), outputFilename, MediaType.APPLICATION_PDF);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "212", "src_id": "M509", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n@Operation(\n        summary = \"Convert EML to PDF\",\n        description =\n                \"This endpoint converts EML (email) files to PDF format with extensive\"\n                        + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n                        + \" and HTML debug output. Input: EML file, Output: PDF\"\n                        + \" or HTML file. Type: SISO\")\npublic ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n    MultipartFile inputFile = request.getFileInput();\n    String originalFilename = inputFile.getOriginalFilename();\n\n    // Validate input\n    if (inputFile.isEmpty()) {\n        log.error(\"No file provided for EML to PDF conversion.\");\n        return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    if (originalFilename == null || originalFilename.trim().isEmpty()) {\n        log.error(\"Filename is null or empty.\");\n        return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    // Validate file type - support EML\n    String lowerFilename = originalFilename.toLowerCase();\n    if (!lowerFilename.endsWith(\".eml\")) {\n        log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n        return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n    }\n\n    String baseFilename = Filenames.toSimpleFileName(originalFilename);\n\n    try {\n        byte[] fileBytes = inputFile.getBytes();\n\n        if (request.isDownloadHtml()) {\n            try {\n                String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(\n                        htmlContent.getBytes(StandardCharsets.UTF_8),\n                        baseFilename + \".html\",\n                        MediaType.TEXT_HTML);\n            } catch (IOException | IllegalArgumentException e) {\n                log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n            }\n        }\n\n        // Convert EML to PDF with enhanced options\n        try {\n            byte[] pdfBytes = EmlToPdf.convertEmlToPdf(\n                    runtimePathConfig.getWeasyPrintPath(),\n                    request,\n                    fileBytes,\n                    originalFilename,\n                    false,\n                    pdfDocumentFactory,\n                    tempFileManager);\n\n            if (pdfBytes == null || pdfBytes.length == 0) {\n                log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n            }\n            log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n            return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n        } catch (IllegalArgumentException e) {\n            String errorMessage = buildErrorMessage(e, originalFilename);\n            log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        } catch (RuntimeException e) {\n            String errorMessage = buildErrorMessage(e, originalFilename);\n            log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n        }\n\n    } catch (IOException e) {\n        log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "213", "src_id": "M254", "code": "\nprivate void distributedConfigureServers(final int count) throws IOException {\n    final StringBuilder sbClient = new StringBuilder();\n    final StringBuilder sbServer = new StringBuilder();\n    try {\n        for (int i = 0; i < count; i++) {\n            final String[] r = QuorumPeerInstance.createServer(im, i);\n            if (i > 0) {\n                sbClient.append(',');\n                sbServer.append(',');\n            }\n            sbClient.append(r[0]); // r[0] == \"host:clientPort\"\n            sbServer.append(r[1]); // r[1] == \"host:leaderPort:leaderElectionPort\"\n            sbServer.append(';').append(r[0].split(\":\")[1]); // Appending \";clientPort\"\n        }\n        serverHostPort = sbClient.toString();\n        quorumHostPort = sbServer.toString();\n    } catch (final Exception e) {\n        final IOException ioe = new IOException(e.getMessage());\n        ioe.setStackTrace(e.getStackTrace());\n        throw ioe;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "214", "src_id": "M39", "code": "\nprivate void initComponents() {\n    setSize(toasterWidth, toasterHeight);\n    message.setFont(getToasterMessageFont());\n\n    final JPanel externalPanel = new JPanel(new BorderLayout(1, 1));\n    externalPanel.setBackground(getBorderColor());\n\n    final JPanel innerPanel = new JPanel(new BorderLayout(getMargin(), getMargin()));\n    innerPanel.setBackground(getToasterColor());\n\n    message.setBackground(getToasterColor());\n    message.setMargin(new Insets(2, 2, 2, 2));\n    message.setLineWrap(true);\n    message.setWrapStyleWord(true);\n\n    final EtchedBorder etchedBorder = (EtchedBorder) BorderFactory.createEtchedBorder();\n    externalPanel.setBorder(etchedBorder);\n\n    externalPanel.add(innerPanel);\n    message.setForeground(getMessageColor());\n    innerPanel.add(iconLabel, BorderLayout.WEST);\n    innerPanel.add(message, BorderLayout.CENTER);\n    getContentPane().add(externalPanel);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "215", "src_id": "M1130", "code": "\npublic synchronized Map<String, Object> getConnectionInfo(final boolean brief) {\n    final Map<String, Object> info = new LinkedHashMap<>();\n    info.put(\"remote_socket_address\", getRemoteSocketAddress());\n    info.put(\"interest_ops\", getInterestOps());\n    info.put(\"outstanding_requests\", getOutstandingRequests());\n    info.put(\"packets_received\", getPacketsReceived());\n    info.put(\"packets_sent\", getPacketsSent());\n    if (!brief) {\n        info.put(\"session_id\", getSessionId());\n        info.put(\"last_operation\", getLastOperation());\n        info.put(\"established\", getEstablished());\n        info.put(\"session_timeout\", getSessionTimeout());\n        info.put(\"last_cxid\", getLastCxid());\n        info.put(\"last_zxid\", getLastZxid());\n        info.put(\"last_response_time\", getLastResponseTime());\n        info.put(\"last_latency\", getLastLatency());\n        info.put(\"min_latency\", getMinLatency());\n        info.put(\"avg_latency\", getAvgLatency());\n        info.put(\"max_latency\", getMaxLatency());\n    }\n    return info;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "216", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (final RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (final Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        // Close connections still pending on the selector. Any others\n        // with in-flight work, let drain out of the work queue.\n        for (final SelectionKey key : selector.keys()) {\n            final NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        // This will wake up the accept thread and the other selector\n        // threads, and tell the worker thread pool to begin shutdown.\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "217", "src_id": "M1043", "code": "\nvoid handleWrite(final SelectionKey k) throws IOException {\n    if (outgoingBuffers.isEmpty()) {\n        return;\n    }\n\n    // This is going to reset the buffer position to 0 and the limit to the size of the buffer,\n    // so that we can fill it with data from the non-direct buffers that we need to send.\n    final ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n    if (directBuffer == null) {\n        final ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n        // Use gathered write call. This updates the positions of the byte buffers to reflect the\n        // bytes that were written out.\n        sock.write(outgoingBuffers.toArray(bufferList));\n\n        // Remove the buffers that we have sent\n        ByteBuffer bb;\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (bb.remaining() > 0) {\n                break;\n            }\n            outgoingBuffers.remove();\n        }\n        return;\n    }\n\n    directBuffer.clear();\n\n    for (ByteBuffer b : outgoingBuffers) {\n        if (directBuffer.remaining() < b.remaining()) {\n            // When we call put later, if the directBuffer is too small to hold everything,\n            // nothing will be copied, so we've got to slice the buffer if it's too big.\n            b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n        }\n        // put() is going to modify the positions of both buffers, but we don't want to change\n        // the position of the source buffers (we'll do that after the send, if needed), so\n        // we save and reset the position after the copy.\n        final int p = b.position();\n        directBuffer.put(b);\n        b.position(p);\n        if (directBuffer.remaining() == 0) {\n            break;\n        }\n    }\n\n    // Do the flip: limit becomes position, position gets set to 0. This sets us up for the write.\n    directBuffer.flip();\n\n    int sent = sock.write(directBuffer);\n\n    ByteBuffer bb;\n    // Remove the buffers that we have sent\n    while ((bb = outgoingBuffers.peek()) != null) {\n        if (bb == ServerCnxnFactory.closeConn) {\n            throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n        }\n        if (bb == packetSentinel) {\n            packetSent();\n        }\n        if (sent < bb.remaining()) {\n            // We only partially sent this buffer, so we update the position and exit the loop.\n            bb.position(bb.position() + sent);\n            break;\n        }\n        // We've sent the whole buffer, so drop the buffer\n        sent -= bb.remaining();\n        outgoingBuffers.remove();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "218", "src_id": "M577", "code": "\npublic Long update(final E elem, final int timeout) {\n    Long prevExpiryTime = elemMap.get(elem);\n    final long now = Time.currentElapsedTime();\n    final Long newExpiryTime = roundToNextInterval(now + timeout);\n\n    if (newExpiryTime.equals(prevExpiryTime)) {\n        // No change, so nothing to update\n        return null;\n    }\n\n    // First add the elem to the new expiry time bucket in expiryMap.\n    Set<E> set = expiryMap.get(newExpiryTime);\n    if (set == null) {\n        // Construct a ConcurrentHashSet using a ConcurrentHashMap\n        set = Collections.newSetFromMap(new ConcurrentHashMap<>());\n        // Put the new set in the map, but only if another thread hasn't beaten us to it\n        final Set<E> existingSet = expiryMap.putIfAbsent(newExpiryTime, set);\n        if (existingSet != null) {\n            set = existingSet;\n        }\n    }\n    set.add(elem);\n\n    // Map the elem to the new expiry time. If a different previous mapping was present,\n    // clean up the previous expiry bucket.\n    prevExpiryTime = elemMap.put(elem, newExpiryTime);\n    if (prevExpiryTime != null && !newExpiryTime.equals(prevExpiryTime)) {\n        final Set<E> prevSet = expiryMap.get(prevExpiryTime);\n        if (prevSet != null) {\n            prevSet.remove(elem);\n        }\n    }\n    return newExpiryTime;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "219", "src_id": "M219", "code": "\npublic static synchronized ZooKeeper getClient(final String contextPath,\n                                               final String session,\n                                               final int expireTime) throws IOException {\n    final String connectionId = concat(contextPath, session);\n\n    ZooKeeper zk = zkMap.get(connectionId);\n    if (zk == null) {\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"creating new connection for : '%s'\", connectionId));\n        }\n        final Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n        for (final Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n        }\n\n        zkMap.put(connectionId, zk);\n\n        // a session should automatically expire after an amount of time\n        if (session != null) {\n            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "220", "src_id": "M282", "code": "\n@Test\npublic void testSimpleCase() throws Exception {\n    configureServers(serverCount);\n    configureClients(clientCount, SimpleClient.class, getHostPort());\n    final Stat stat = new Stat();\n    startServers();\n    LOG.debug(\"Connecting to \" + getHostPort());\n    final ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n    waitForConnect(zk, 10000);\n    zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    startClients();\n\n    // Check that all clients connect properly\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            try {\n                final byte[] b = zk.getData(\"/simpleCase/\" + i, false, stat);\n                Assert.assertEquals(\"orig\", new String(b));\n            } catch (final NoNodeException e) {\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"Max tries exceeded on client \" + i);\n                }\n                Thread.sleep(1000);\n            }\n        }\n    }\n\n    // Kill half the servers, make a change, restart the dead\n    // servers, and then bounce the other servers one by one\n    for (int i = 0; i < getServerCount(); i++) {\n        stopServer(i);\n        if (i + 1 > getServerCount() / 2) {\n            startServer(i);\n        } else if (i + 1 == getServerCount() / 2) {\n            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n            try {\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            } catch (final ConnectionLossException e) {\n                Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            }\n            for (int j = 0; j < i; j++) {\n                LOG.info(\"Starting server \" + j);\n                startServer(i);\n            }\n        }\n    }\n    Thread.sleep(100); // wait for things to stabilize\n    Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    try {\n        zk.getData(\"/simpleCase\", false, stat);\n    } catch (final ConnectionLossException e) {\n        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    }\n\n    // check that the change has propagated to everyone\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            final byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n            if (new String(data).equals(\"new\")) {\n                break;\n            }\n            if (j + 1 == maxTries) {\n                Assert.fail(\"max tries exceeded for \" + i);\n            }\n            Thread.sleep(1000);\n        }\n    }\n\n    // send out the kill signal\n    zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n\n    // watch for everyone to die\n    for (int i = 0; i < getClientCount(); i++) {\n        try {\n            for (int j = 0; j < maxTries; j++) {\n                zk.getData(\"/simpleCase/\" + i, false, stat);\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                }\n                Thread.sleep(200);\n            }\n        } catch (final NoNodeException e) {\n            // Great this is what we were hoping for!\n        }\n    }\n\n    stopClients();\n    stopServers();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "221", "src_id": "M211", "code": "\npublic static void main(String[] args) throws IOException {\n    final RandomAccessFileReader f = new RandomAccessFileReader(new File(args[0]));\n\n    final long pos0 = f.getPosition();\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    System.out.println(\"=============\");\n    final long pos1 = f.getPosition();\n    System.out.println(\"pos: \" + pos1);\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    System.out.println(\"=============\");\n    f.seek(pos1);\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    System.out.println(\"=============\");\n    f.seek(pos0);\n    for (int i = 0; i < 5; i++) {\n        System.out.println(f.readLine());\n    }\n    final long pos2 = f.getPosition();\n    System.out.println(\"=============\");\n    System.out.println(f.readLine());\n    f.seek(pos2);\n    System.out.println(f.readLine());\n    f.close();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "222", "src_id": "M168", "code": "\nprivate StringArg readStringArg() throws IOException, FilterException {\n    int c = reader.read();\n    int last = 0;\n    if (c != '\"') {\n        throw new FilterException(\"Check the parser, trying to read a string that doesn't begin with quotes\");\n    }\n    final StringBuffer buffer = new StringBuffer();\n    while (reader.ready()) {\n        last = c;\n        c = reader.read();\n        if (c == -1) {\n            break;\n        }\n\n        if (c == '\"' && last != '\\\\') {\n            return new StringArg(buffer.toString());\n        } else {\n            buffer.append((char) c);\n        }\n    }\n    throw new FilterException(\"Unterminated string\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "223", "src_id": "M196", "code": "\npublic static void main(final String[] args) throws IOException {\n    final MergedLogSource source = new MergedLogSource(args);\n\n    final PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n    final PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n    final PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n    final PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n    LogIterator iter;\n\n    System.out.println(source);\n    iter = source.iterator();\n    long currentms = 0;\n    long currentsec = 0;\n    long currentmin = 0;\n    long currenthour = 0;\n    final Set<Long> zxids_ms = new HashSet<Long>();\n    long zxid_sec = 0;\n    long zxid_min = 0;\n    long zxid_hour = 0;\n\n    while (iter.hasNext()) {\n        final LogEntry e = iter.next();\n        final TransactionEntry cxn = (TransactionEntry) e;\n\n        final long ms = cxn.getTimestamp();\n        final long sec = ms / MS_PER_SEC;\n        final long min = ms / MS_PER_MIN;\n        final long hour = ms / MS_PER_HOUR;\n\n        if (currentms != ms && currentms != 0) {\n            ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n\n            zxid_sec += zxids_ms.size();\n            zxid_min += zxids_ms.size();\n            zxid_hour += zxids_ms.size();\n            zxids_ms.clear();\n        }\n\n        if (currentsec != sec && currentsec != 0) {\n            ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n            zxid_sec = 0;\n        }\n\n        if (currentmin != min && currentmin != 0) {\n            ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n            zxid_min = 0;\n        }\n\n        if (currenthour != hour && currenthour != 0) {\n            ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n            zxid_hour = 0;\n        }\n\n        currentms = ms;\n        currentsec = sec;\n        currentmin = min;\n        currenthour = hour;\n\n        zxids_ms.add(cxn.getZxid());\n    }\n\n    iter.close();\n    ps_ms.close();\n    ps_sec.close();\n    ps_min.close();\n    ps_hour.close();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "224", "src_id": "M174", "code": "\nprivate LogEntry readNextEntry() {\n    LogEntry e = null;\n    try {\n        long crcValue;\n        byte[] bytes;\n        try {\n            crcValue = logStream.readLong(\"crcvalue\");\n            bytes = logStream.readBuffer(\"txnEntry\");\n        } catch (EOFException ex) {\n            return null;\n        }\n\n        if (bytes.length == 0) {\n            return null;\n        }\n        final Checksum crc = new Adler32();\n        crc.update(bytes, 0, bytes.length);\n        if (crcValue != crc.getValue()) {\n            throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n        }\n\n        final TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n        final TxnHeader hdr = logEntry.getHeader();\n        final Record r = logEntry.getTxn();\n\n        switch (hdr.getType()) {\n            case OpCode.createSession: {\n                e = new TransactionEntry(\n                        hdr.getTime(),\n                        hdr.getClientId(),\n                        hdr.getCxid(),\n                        hdr.getZxid(),\n                        \"createSession\");\n            }\n                break;\n            case OpCode.closeSession: {\n                e = new TransactionEntry(\n                        hdr.getTime(),\n                        hdr.getClientId(),\n                        hdr.getCxid(),\n                        hdr.getZxid(),\n                        \"closeSession\");\n            }\n                break;\n            case OpCode.create:\n                if (r != null) {\n                    final CreateTxn create = (CreateTxn) r;\n                    final String path = create.getPath();\n                    e = new TransactionEntry(\n                            hdr.getTime(),\n                            hdr.getClientId(),\n                            hdr.getCxid(),\n                            hdr.getZxid(),\n                            \"create\",\n                            path);\n                }\n                break;\n            case OpCode.setData:\n                if (r != null) {\n                    final SetDataTxn set = (SetDataTxn) r;\n                    final String path = set.getPath();\n                    e = new TransactionEntry(\n                            hdr.getTime(),\n                            hdr.getClientId(),\n                            hdr.getCxid(),\n                            hdr.getZxid(),\n                            \"setData\",\n                            path);\n                }\n                break;\n            case OpCode.setACL:\n                if (r != null) {\n                    final SetACLTxn setacl = (SetACLTxn) r;\n                    final String path = setacl.getPath();\n                    e = new TransactionEntry(\n                            hdr.getTime(),\n                            hdr.getClientId(),\n                            hdr.getCxid(),\n                            hdr.getZxid(),\n                            \"setACL\",\n                            path);\n                }\n                break;\n            case OpCode.error:\n                if (r != null) {\n                    final ErrorTxn error = (ErrorTxn) r;\n                    e = new TransactionEntry(\n                            hdr.getTime(),\n                            hdr.getClientId(),\n                            hdr.getCxid(),\n                            hdr.getZxid(),\n                            \"error\",\n                            \"Error: \" + error.getErr());\n                }\n                break;\n            default:\n                LOG.info(\"Unknown op: \" + hdr.getType());\n                break;\n        }\n\n        if (logStream.readByte(\"EOR\") != 'B') {\n            throw new EOFException(\"Last transaction was partial.\");\n        }\n    } catch (Exception ex) {\n        LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n        return null;\n    }\n    return e;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "225", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        // Close connections still pending on the selector. Any others\n        // with in-flight work, let drain out of the work queue.\n        for (SelectionKey key : selector.keys()) {\n            final NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        // This will wake up the accept thread and the other selector\n        // threads, and tell the worker thread pool to begin shutdown.\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "226", "src_id": "M286", "code": "\npublic void reconfigureInstance(final String name, final String params)\n        throws NoAssignmentException, InterruptedException, KeeperException {\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n    }\n    final Assigned assigned = instanceToAssignment.get(name);\n    if (assigned == null) {\n        throw new NoAssignmentException();\n    }\n    KeeperException lastException = null;\n    for (int i = 0; i < maxTries; i++) {\n        try {\n            zk.setData(\n                    assignmentsNode + '/' + assigned.container + '/' + name,\n                    (\"update \" + params).getBytes(),\n                    -1);\n            break;\n        } catch (ConnectionLossException e) {\n            lastException = e;\n        }\n    }\n    if (lastException != null) {\n        throw lastException;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "227", "src_id": "M1046", "code": "\npublic static void closeSock(final SocketChannel sock) {\n    if (!sock.isOpen()) {\n        return;\n    }\n\n    try {\n        /*\n         * The following sequence of code is stupid! You would think that\n         * only sock.close() is needed, but alas, it doesn't work that way.\n         * If you just do sock.close() there are cases where the socket\n         * doesn't actually close...\n         */\n        sock.socket().shutdownOutput();\n    } catch (IOException e) {\n        // This is a relatively common exception that we can't avoid\n        LOG.debug(\"ignoring exception during output shutdown\", e);\n    }\n    try {\n        sock.socket().shutdownInput();\n    } catch (IOException e) {\n        // This is a relatively common exception that we can't avoid\n        LOG.debug(\"ignoring exception during input shutdown\", e);\n    }\n    try {\n        sock.socket().close();\n    } catch (IOException e) {\n        LOG.debug(\"ignoring exception during socket close\", e);\n    }\n    try {\n        sock.close();\n    } catch (IOException e) {\n        LOG.debug(\"ignoring exception during socketchannel close\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "228", "src_id": "M149", "code": "\nString handleRequest(final JsonRequest request) throws Exception {\n    long starttime = request.getNumber(\"start\", 0);\n    long endtime = request.getNumber(\"end\", 0);\n    final long period = request.getNumber(\"period\", 0);\n    final String filterstr = request.getString(\"filter\", \"\");\n\n    FilterOp fo = null;\n    if (filterstr.length() > 0) {\n        fo = new FilterParser(filterstr).parse();\n    }\n\n    if (starttime == 0) {\n        starttime = source.getStartTime();\n    }\n    if (endtime == 0) {\n        if (period > 0) {\n            endtime = starttime + period;\n        } else {\n            endtime = starttime + DEFAULT_PERIOD;\n        }\n    }\n\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", period=\" + period + \")\");\n    }\n\n    final LogIterator iterator = (fo != null)\n            ? source.iterator(starttime, endtime, fo)\n            : source.iterator(starttime, endtime);\n    return new JsonGenerator(iterator).toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "229", "src_id": "M370", "code": "\n@Override\nvoid cleanup() {\n    if (sockKey != null) {\n        final SocketChannel sock = (SocketChannel) sockKey.channel();\n        sockKey.cancel();\n        try {\n            sock.socket().shutdownInput();\n        } catch (IOException e) {\n            LOG.debug(\"Ignoring exception during shutdown input\", e);\n        }\n        try {\n            sock.socket().shutdownOutput();\n        } catch (IOException e) {\n            LOG.debug(\"Ignoring exception during shutdown output\", e);\n        }\n        try {\n            sock.socket().close();\n        } catch (IOException e) {\n            LOG.debug(\"Ignoring exception during socket close\", e);\n        }\n        try {\n            sock.close();\n        } catch (IOException e) {\n            LOG.debug(\"Ignoring exception during channel close\", e);\n        }\n    }\n    try {\n        Thread.sleep(100);\n    } catch (InterruptedException e) {\n        LOG.debug(\"SendThread interrupted during sleep, ignoring\");\n    }\n    sockKey = null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "230", "src_id": "M40", "code": "\nprotected void animateVertically(final int posx, final int fromY, final int toY)\n        throws InterruptedException {\n    toaster.setLocation(posx, fromY);\n    if (toY < fromY) {\n        for (int i = fromY; i > toY; i -= step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    } else {\n        for (int i = fromY; i < toY; i += step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    }\n    toaster.setLocation(posx, toY);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "231", "src_id": "M1043", "code": "\nprivate void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    final Thread thread = Thread.currentThread();\n\n    notifyPostProcessing(1);\n\n    if (DEBUG) {\n        thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n\n    Exception exception = null;\n\n    try {\n        psAlgorithm.run(this);\n    } catch (Exception err) {\n        Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n        if (err instanceof InterruptedIOException\n                || err instanceof ClosedByInterruptException\n                || thread.isInterrupted()) {\n            notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) {\n            errCode = ERROR_POSTPROCESSING;\n        }\n\n        exception = err;\n    } finally {\n        notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n        if (exception == null) {\n            exception = errObject;\n        }\n        notifyError(ERROR_POSTPROCESSING, exception);\n        return;\n    }\n\n    notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "232", "src_id": "M1050", "code": "\n@Override\npublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n    if (oldVersion == 2) {\n        db.execSQL(\"ALTER TABLE \" + MISSIONS_TABLE_NAME_v2 + \" ADD COLUMN \" + KEY_KIND + \" TEXT;\");\n        oldVersion++;\n    }\n\n    if (oldVersion == 3) {\n        final String KEY_LOCATION = \"location\";\n        final String KEY_NAME = \"name\";\n\n        db.execSQL(MISSIONS_CREATE_TABLE);\n\n        Cursor cursor =\n                db.query(MISSIONS_TABLE_NAME_v2, null, null, null, null, null, KEY_TIMESTAMP);\n        try {\n            final int count = cursor.getCount();\n            if (count > 0) {\n                db.beginTransaction();\n                try {\n                    while (cursor.moveToNext()) {\n                        ContentValues values = new ContentValues();\n                        values.put(KEY_SOURCE, cursor.getString(cursor.getColumnIndex(KEY_SOURCE)));\n                        values.put(KEY_DONE, cursor.getString(cursor.getColumnIndex(KEY_DONE)));\n                        values.put(\n                                KEY_TIMESTAMP,\n                                cursor.getLong(cursor.getColumnIndex(KEY_TIMESTAMP)));\n                        values.put(KEY_KIND, cursor.getString(cursor.getColumnIndex(KEY_KIND)));\n                        values.put(\n                                KEY_PATH,\n                                Uri.fromFile(\n                                                new File(\n                                                        cursor.getString(\n                                                                cursor.getColumnIndex(\n                                                                        KEY_LOCATION)),\n                                                        cursor.getString(\n                                                                cursor.getColumnIndex(KEY_NAME))))\n                                        .toString());\n\n                        db.insert(FINISHED_TABLE_NAME, null, values);\n                    }\n                    db.setTransactionSuccessful();\n                } finally {\n                    db.endTransaction();\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n        db.execSQL(\"DROP TABLE \" + MISSIONS_TABLE_NAME_v2);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "233", "src_id": "M870", "code": "\n@SuppressWarnings(\"MethodLength\")\npublic void build(final SharpStream output) throws IOException {\n    if (done) {\n        throw new RuntimeException(\"already done\");\n    }\n    if (!output.canWrite()) {\n        throw new IOException(\"the provided output is not writable\");\n    }\n\n    // WARNING: the muxer requires at least 8 samples of every track\n    //          not allowed for very short tracks (less than 0.5 seconds)\n    outStream = output;\n    long read = 8; // mdat box header size\n    long totalSampleSize = 0;\n    final int[] sampleExtra = new int[readers.length];\n    final int[] defaultMediaTime = new int[readers.length];\n    final int[] defaultSampleDuration = new int[readers.length];\n    final int[] sampleCount = new int[readers.length];\n\n    final TablesInfo[] tablesInfo = new TablesInfo[tracks.length];\n    for (int i = 0; i < tablesInfo.length; i++) {\n        tablesInfo[i] = new TablesInfo();\n    }\n\n    final int singleSampleBuffer;\n    if (tracks.length == 1 && tracks[0].kind == TrackKind.Audio) {\n        // near 1 second of audio data per chunk, avoid split the audio stream in large chunks\n        singleSampleBuffer = tracks[0].trak.mdia.mdhdTimeScale / 1000;\n    } else {\n        singleSampleBuffer = -1;\n    }\n\n    for (int i = 0; i < readers.length; i++) {\n        int samplesSize = 0;\n        int sampleSizeChanges = 0;\n        int compositionOffsetLast = -1;\n\n        Mp4DashChunk chunk;\n        while ((chunk = readers[i].getNextChunk(true)) != null) {\n\n            if (defaultMediaTime[i] < 1 && chunk.moof.traf.tfhd.defaultSampleDuration > 0) {\n                defaultMediaTime[i] = chunk.moof.traf.tfhd.defaultSampleDuration;\n            }\n\n            read += chunk.moof.traf.trun.chunkSize;\n            sampleExtra[i] += chunk.moof.traf.trun.chunkDuration; // calculate track duration\n\n            TrunEntry info;\n            while ((info = chunk.getNextSampleInfo()) != null) {\n                if (info.isKeyframe) {\n                    tablesInfo[i].stss++;\n                }\n\n                if (info.sampleDuration > defaultSampleDuration[i]) {\n                    defaultSampleDuration[i] = info.sampleDuration;\n                }\n\n                tablesInfo[i].stsz++;\n                if (samplesSize != info.sampleSize) {\n                    samplesSize = info.sampleSize;\n                    sampleSizeChanges++;\n                }\n\n                if (info.hasCompositionTimeOffset) {\n                    if (info.sampleCompositionTimeOffset != compositionOffsetLast) {\n                        tablesInfo[i].ctts++;\n                        compositionOffsetLast = info.sampleCompositionTimeOffset;\n                    }\n                }\n\n                totalSampleSize += info.sampleSize;\n            }\n        }\n\n        if (defaultMediaTime[i] < 1) {\n            defaultMediaTime[i] = defaultSampleDuration[i];\n        }\n\n        readers[i].rewind();\n\n        if (singleSampleBuffer > 0) {\n            initChunkTables(tablesInfo[i], singleSampleBuffer, singleSampleBuffer);\n        } else {\n            initChunkTables(tablesInfo[i], SAMPLES_PER_CHUNK_INIT, SAMPLES_PER_CHUNK);\n        }\n\n        sampleCount[i] = tablesInfo[i].stsz;\n\n        if (sampleSizeChanges == 1) {\n            tablesInfo[i].stsz = 0;\n            tablesInfo[i].stszDefault = samplesSize;\n        } else {\n            tablesInfo[i].stszDefault = 0;\n        }\n\n        if (tablesInfo[i].stss == tablesInfo[i].stsz) {\n            tablesInfo[i].stss = -1; // for audio tracks (all samples are keyframes)\n        }\n\n        // ensure track duration\n        if (tracks[i].trak.tkhd.duration < 1) {\n            tracks[i].trak.tkhd.duration = sampleExtra[i]; // this never should happen\n        }\n    }\n\n    final boolean is64 = read > THRESHOLD_FOR_CO64;\n\n    // calculate the moov size\n    final int auxSize = makeMoov(defaultMediaTime, tablesInfo, is64);\n\n    if (auxSize < THRESHOLD_MOOV_LENGTH) {\n        auxBuffer = ByteBuffer.allocate(auxSize); // cache moov in the memory\n    }\n\n    moovSimulation = false;\n    writeOffset = 0;\n\n    final int ftypSize = makeFtyp();\n\n    // reserve moov space in the output stream\n    if (auxSize > 0) {\n        int length = auxSize;\n        final byte[] buffer = new byte[64 * 1024]; // 64 KiB\n        while (length > 0) {\n            final int count = Math.min(length, buffer.length);\n            outWrite(buffer, count);\n            length -= count;\n        }\n    }\n\n    if (auxBuffer == null) {\n        outSeek(ftypSize);\n    }\n\n    // tablesInfo contains row counts\n    // and after returning from makeMoov() will contain those table offsets\n    makeMoov(defaultMediaTime, tablesInfo, is64);\n\n    // write tables: stts stsc sbgp\n    // reset for ctts table: sampleCount sampleExtra\n    for (int i = 0; i < readers.length; i++) {\n        writeEntryArray(tablesInfo[i].stts, 2, sampleCount[i], defaultSampleDuration[i]);\n        writeEntryArray(\n                tablesInfo[i].stsc, tablesInfo[i].stscBEntries.length, tablesInfo[i].stscBEntries);\n        tablesInfo[i].stscBEntries = null;\n        if (tablesInfo[i].ctts > 0) {\n            sampleCount[i] = 1; // the index is not base zero\n            sampleExtra[i] = -1;\n        }\n        if (tablesInfo[i].sbgp > 0) {\n            writeEntryArray(tablesInfo[i].sbgp, 1, sampleCount[i]);\n        }\n    }\n\n    if (auxBuffer == null) {\n        outRestore();\n    }\n\n    outWrite(makeMdat(totalSampleSize, is64));\n\n    final int[] sampleIndex = new int[readers.length];\n    final int[] sizes = new int[singleSampleBuffer > 0 ? singleSampleBuffer : SAMPLES_PER_CHUNK];\n    final int[] sync = new int[singleSampleBuffer > 0 ? singleSampleBuffer : SAMPLES_PER_CHUNK];\n\n    int written = readers.length;\n    while (written > 0) {\n        written = 0;\n\n        for (int i = 0; i < readers.length; i++) {\n            if (sampleIndex[i] < 0) {\n                continue; // track is done\n            }\n\n            final long chunkOffset = writeOffset;\n            int syncCount = 0;\n            final int limit;\n            if (singleSampleBuffer > 0) {\n                limit = singleSampleBuffer;\n            } else {\n                limit = sampleIndex[i] == 0 ? SAMPLES_PER_CHUNK_INIT : SAMPLES_PER_CHUNK;\n            }\n\n            int j = 0;\n            for (; j < limit; j++) {\n                final Mp4DashSample sample = getNextSample(i);\n\n                if (sample == null) {\n                    if (tablesInfo[i].ctts > 0 && sampleExtra[i] >= 0) {\n                        writeEntryArray(\n                                tablesInfo[i].ctts,\n                                1,\n                                sampleCount[i],\n                                sampleExtra[i]); // flush last entries\n                        outRestore();\n                    }\n                    sampleIndex[i] = -1;\n                    break;\n                }\n\n                sampleIndex[i]++;\n\n                if (tablesInfo[i].ctts > 0) {\n                    if (sample.info.sampleCompositionTimeOffset == sampleExtra[i]) {\n                        sampleCount[i]++;\n                    } else {\n                        if (sampleExtra[i] >= 0) {\n                            tablesInfo[i].ctts =\n                                    writeEntryArray(\n                                            tablesInfo[i].ctts, 2, sampleCount[i], sampleExtra[i]);\n                            outRestore();\n                        }\n                        sampleCount[i] = 1;\n                        sampleExtra[i] = sample.info.sampleCompositionTimeOffset;\n                    }\n                }\n\n                if (tablesInfo[i].stss > 0 && sample.info.isKeyframe) {\n                    sync[syncCount++] = sampleIndex[i];\n                }\n\n                if (tablesInfo[i].stsz > 0) {\n                    sizes[j] = sample.data.length;\n                }\n\n                outWrite(sample.data, sample.data.length);\n            }\n\n            if (j > 0) {\n                written++;\n\n                if (tablesInfo[i].stsz > 0) {\n                    tablesInfo[i].stsz = writeEntryArray(tablesInfo[i].stsz, j, sizes);\n                }\n\n                if (syncCount > 0) {\n                    tablesInfo[i].stss = writeEntryArray(tablesInfo[i].stss, syncCount, sync);\n                }\n\n                if (tablesInfo[i].stco > 0) {\n                    if (is64) {\n                        tablesInfo[i].stco = writeEntry64(tablesInfo[i].stco, chunkOffset);\n                    } else {\n                        tablesInfo[i].stco =\n                                writeEntryArray(tablesInfo[i].stco, 1, (int) chunkOffset);\n                    }\n                }\n\n                outRestore();\n            }\n        }\n    }\n\n    if (auxBuffer != null) {\n        // dump moov\n        outSeek(ftypSize);\n        outStream.write(auxBuffer.array(), 0, auxBuffer.capacity());\n        auxBuffer = null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "234", "src_id": "M1024", "code": "\n@Override\npublic void run() {\n    if (mMission.current > 0) {\n        mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n    }\n\n    int retryCount = 0;\n    int httpCode = 204;\n\n    while (true) {\n        try {\n            if (mMission.blocks == null && mMission.current == 0) {\n                // calculate the whole size of the mission\n                long finalLength = 0;\n                long lowestSize = Long.MAX_VALUE;\n\n                for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                    mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (Thread.interrupted()) {\n                        return;\n                    }\n                    final long length = Utility.getTotalContentLength(mConn);\n\n                    if (i == 0) {\n                        httpCode = mConn.getResponseCode();\n                        mMission.length = length;\n                    }\n\n                    if (length > 0) {\n                        finalLength += length;\n                    }\n                    if (length < lowestSize) {\n                        lowestSize = length;\n                    }\n                }\n\n                mMission.nearLength = finalLength;\n\n                // reserve space at the start of the file\n                if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                    if (lowestSize < 1) {\n                        // the length is unknown use the default size\n                        mMission.offsets[0] = RESERVE_SPACE_DEFAULT;\n                    } else {\n                        // use the smallest resource size to download, otherwise, use the maximum\n                        mMission.offsets[0] =\n                                lowestSize < RESERVE_SPACE_MAXIMUM\n                                        ? lowestSize\n                                        : RESERVE_SPACE_MAXIMUM;\n                    }\n                }\n            } else {\n                // ask for the current resource length\n                mConn = mMission.openConnection(true, 0, 0);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                httpCode = mConn.getResponseCode();\n                mMission.length = Utility.getTotalContentLength(mConn);\n            }\n\n            if (mMission.length == 0 || httpCode == 204) {\n                mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                return;\n            }\n\n            // check for dynamic generated content\n            if (mMission.length == -1 && mConn.getResponseCode() == 200) {\n                mMission.blocks = new int[0];\n                mMission.length = 0;\n                mMission.unknownLength = true;\n\n                if (DEBUG) {\n                    Log.d(TAG, \"falling back (unknown length)\");\n                }\n            } else {\n                // Open again\n                mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                synchronized (mMission.LOCK) {\n                    if (mConn.getResponseCode() == 206) {\n\n                        if (mMission.threadCount > 1) {\n                            int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                            if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) {\n                                count++;\n                            }\n\n                            mMission.blocks = new int[count];\n                        } else {\n                            // if one thread is required don't calculate blocks, is useless\n                            mMission.blocks = new int[0];\n                            mMission.unknownLength = false;\n                        }\n\n                        if (DEBUG) {\n                            Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                        }\n                    } else {\n                        // Fallback to single thread\n                        mMission.blocks = new int[0];\n                        mMission.unknownLength = false;\n\n                        if (DEBUG) {\n                            Log.d(\n                                    TAG,\n                                    \"falling back due http response code = \"\n                                            + mConn.getResponseCode());\n                        }\n                    }\n                }\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n            }\n\n            try (SharpStream fs = mMission.storage.getStream()) {\n                fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                fs.seek(mMission.offsets[mMission.current]);\n            }\n\n            if (!mMission.running || Thread.interrupted()) {\n                return;\n            }\n\n            if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                final String entityTag = mConn.getHeaderField(\"ETAG\");\n                final String lastModified = mConn.getHeaderField(\"Last-Modified\");\n                final MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n\n                if (!TextUtils.isEmpty(entityTag)) {\n                    recovery.setValidateCondition(entityTag);\n                } else if (!TextUtils.isEmpty(lastModified)) {\n                    // Note: this is less precise\n                    recovery.setValidateCondition(lastModified);\n                } else {\n                    recovery.setValidateCondition(null);\n                }\n            }\n\n            mMission.running = false;\n            break;\n        } catch (InterruptedIOException | ClosedByInterruptException e) {\n            return;\n        } catch (Exception e) {\n            if (!mMission.running || super.isInterrupted()) {\n                return;\n            }\n\n            if (e instanceof DownloadMission.HttpError\n                    && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired\n                interrupt();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                return;\n            }\n\n            if (retryCount++ > mMission.maxRetry) {\n                Log.e(TAG, \"initializer failed\", e);\n                mMission.notifyError(e);\n                return;\n            }\n\n            Log.e(TAG, \"initializer failed, retrying\", e);\n        }\n    }\n\n    mMission.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "235", "src_id": "M1106", "code": "\nprivate void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n    StringBuilder request = new StringBuilder(256);\n    request.append(mission.source);\n\n    request.append(\" [\");\n    if (mission.recoveryInfo != null) {\n        for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n            request.append(' ')\n                    .append(recovery.toString())\n                    .append(' ');\n        }\n    }\n    request.append(\"]\");\n\n    String service;\n    try {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e) {\n        service = ErrorInfo.SERVICE_NONE;\n    }\n\n    ErrorUtil.createNotification(\n            mContext,\n            new ErrorInfo(\n                    ErrorInfo.Companion.throwableToStringList(mission.errObject),\n                    action,\n                    service,\n                    request.toString(),\n                    reason));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "236", "src_id": "M1055", "code": "\npublic void updateMission(Mission mission) {\n    final ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n    final SQLiteDatabase database = getWritableDatabase();\n    final String ts = String.valueOf(mission.timestamp);\n\n    final int rowsAffected;\n\n    if (mission instanceof FinishedMission) {\n        if (mission.storage.isInvalid()) {\n            rowsAffected =\n                    database.update(\n                            FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new String[] {ts});\n        } else {\n            rowsAffected =\n                    database.update(\n                            FINISHED_TABLE_NAME,\n                            values,\n                            KEY_PATH + \" = ?\",\n                            new String[] {mission.storage.getUri().toString()});\n        }\n    } else {\n        throw new UnsupportedOperationException(\"DownloadMission\");\n    }\n\n    if (rowsAffected != 1) {\n        Log.e(\n                \"FinishedMissionStore\",\n                \"Expected 1 row to be affected by update but got \" + rowsAffected);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "237", "src_id": "M877", "code": "\nprivate int make(final int type, final int extra, final int columns, final int rows)\n        throws IOException {\n    final byte base = 16;\n    final int size = columns * rows * 4;\n    int total = size + base;\n    int offset = auxOffset();\n\n    if (extra >= 0) {\n        total += 4;\n    }\n\n    auxWrite(\n            ByteBuffer.allocate(12)\n                    .putInt(total)\n                    .putInt(type)\n                    .putInt(0x00) // default version & flags\n                    .array());\n\n    if (extra >= 0) {\n        offset += 4;\n        auxWrite(extra);\n    }\n\n    auxWrite(rows);\n    auxSkip(size);\n\n    return offset + base;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "238", "src_id": "M1079", "code": "\nboolean runMissions() {\n    synchronized (this) {\n        if (mMissionsPending.size() < 1) {\n            return false;\n        }\n        if (!canDownloadInCurrentNetwork()) {\n            return false;\n        }\n\n        if (mPrefQueueLimit) {\n            for (DownloadMission mission : mMissionsPending) {\n                if (!mission.isFinished() && mission.running) {\n                    return true;\n                }\n            }\n        }\n\n        boolean flag = false;\n        for (DownloadMission mission : mMissionsPending) {\n            if (mission.running || !mission.enqueued || mission.isFinished()) {\n                continue;\n            }\n\n            resumeMission(mission);\n            if (mission.errCode != DownloadMission.ERROR_NOTHING) {\n                continue;\n            }\n\n            if (mPrefQueueLimit) {\n                return true;\n            }\n            flag = true;\n        }\n\n        return flag;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "239", "src_id": "M1036", "code": "\npublic void start() {\n    if (running || isFinished() || urls.length < 1) {\n        return;\n    }\n\n    // ensure that the previous state is completely paused.\n    joinForThreads(10000);\n\n    running = true;\n    errCode = ERROR_NOTHING;\n\n    if (hasInvalidStorage()) {\n        notifyError(ERROR_FILE_CREATION, null);\n        return;\n    }\n\n    if (current >= urls.length) {\n        notifyFinished();\n        return;\n    }\n\n    notify(DownloadManagerService.MESSAGE_RUNNING);\n\n    if (urls[current] == null) {\n        doRecover(ERROR_RESOURCE_GONE);\n        return;\n    }\n\n    if (blocks == null) {\n        initializer();\n        return;\n    }\n\n    init = null;\n    finishCount = 0;\n    blockAcquired = new boolean[blocks.length];\n\n    if (blocks.length < 1) {\n        threads = new Thread[] {runAsync(1, new DownloadRunnableFallback(this))};\n    } else {\n        int remainingBlocks = 0;\n        for (int block : blocks) {\n            if (block >= 0) {\n                remainingBlocks++;\n            }\n        }\n\n        if (remainingBlocks < 1) {\n            notifyFinished();\n            return;\n        }\n\n        threads = new Thread[Math.min(threadCount, remainingBlocks)];\n\n        for (int i = 0; i < threads.length; i++) {\n            threads[i] = runAsync(i + 1, new DownloadRunnable(this, i));\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "240", "src_id": "M951", "code": "\n@Override\nprotected void subscribeActual(CompletableObserver downstream) {\n    final InnerCompletableCache inner = new InnerCompletableCache(downstream);\n    downstream.onSubscribe(inner);\n\n    if (add(inner)) {\n        if (inner.isDisposed()) {\n            remove(inner);\n        }\n        if (once.compareAndSet(false, true)) {\n            source.subscribe(this);\n        }\n        return;\n    }\n\n    final Throwable ex = error;\n    if (ex != null) {\n        downstream.onError(ex);\n    } else {\n        downstream.onComplete();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "241", "src_id": "M961", "code": "\n@Override\npublic boolean tryOnError(Throwable throwable) {\n    if (throwable == null) {\n        throwable = ExceptionHelper.createNullPointerException(\"onError called with a null Throwable.\");\n    }\n\n    if (get() == DisposableHelper.DISPOSED) {\n        return false;\n    }\n\n    final Disposable upstream = getAndSet(DisposableHelper.DISPOSED);\n    if (upstream == DisposableHelper.DISPOSED) {\n        return false;\n    }\n\n    try {\n        downstream.onError(throwable);\n    } finally {\n        if (upstream != null) {\n            upstream.dispose();\n        }\n    }\n    return true;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "242", "src_id": "M453", "code": "\n@SuppressWarnings(\"unchecked\")\npublic static <T, R> boolean tryScalarXMapSubscribe(\n        ObservableSource<T> source,\n        Observer<? super R> observer,\n        Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\n\n    if (source instanceof Supplier) {\n        final T value;\n        try {\n            value = ((Supplier<T>) source).get();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            EmptyDisposable.error(ex, observer);\n            return true;\n        }\n\n        if (value == null) {\n            EmptyDisposable.complete(observer);\n            return true;\n        }\n\n        final ObservableSource<? extends R> nextSource;\n        try {\n            nextSource = Objects.requireNonNull(\n                    mapper.apply(value), \"The mapper returned a null ObservableSource\");\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            EmptyDisposable.error(ex, observer);\n            return true;\n        }\n\n        if (nextSource instanceof Supplier) {\n            final R mappedValue;\n            try {\n                mappedValue = ((Supplier<R>) nextSource).get();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                EmptyDisposable.error(ex, observer);\n                return true;\n            }\n\n            if (mappedValue == null) {\n                EmptyDisposable.complete(observer);\n                return true;\n            }\n\n            final ScalarDisposable<R> sd = new ScalarDisposable<>(observer, mappedValue);\n            observer.onSubscribe(sd);\n            sd.run();\n        } else {\n            nextSource.subscribe(observer);\n        }\n\n        return true;\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "243", "src_id": "M267", "code": "\nvoid drainLoop() {\n    int missed = 1;\n\n    final Observer<? super R> downstream = this.downstream;\n    final AtomicInteger activeCount = active;\n    final AtomicReference<SpscLinkedArrayQueue<R>> queueRef = queue;\n\n    for (;;) {\n        for (;;) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            if (!delayErrors) {\n                final Throwable ex = errors.get();\n                if (ex != null) {\n                    clear();\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n            }\n\n            final boolean done = activeCount.get() == 0;\n            final SpscLinkedArrayQueue<R> q = queueRef.get();\n            final R item = q != null ? q.poll() : null;\n            final boolean empty = item == null;\n\n            if (done && empty) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            downstream.onNext(item);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "244", "src_id": "M1163", "code": "\n@Override\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    final SimplePlainQueue<Object> queue = this.queue;\n    final Subscriber<? super Flowable<T>> downstream = this.downstream;\n    UnicastProcessor<T> window = this.window;\n\n    for (;;) {\n        if (upstreamCancelled) {\n            queue.clear();\n            window = null;\n            this.window = null;\n        } else {\n            final boolean isDone = done;\n            final Object signal = queue.poll();\n            final boolean isEmpty = signal == null;\n\n            if (isDone && isEmpty) {\n                final Throwable ex = error;\n                if (ex != null) {\n                    if (window != null) {\n                        window.onError(ex);\n                    }\n                    downstream.onError(ex);\n                } else {\n                    if (window != null) {\n                        window.onComplete();\n                    }\n                    downstream.onComplete();\n                }\n                cleanupResources();\n                upstreamCancelled = true;\n                continue;\n            } else if (!isEmpty) {\n                if (signal instanceof WindowBoundaryRunnable) {\n                    final WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) signal;\n                    if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                        this.count = 0;\n                        window = createNewWindow(window);\n                    }\n                } else if (window != null) {\n                    @SuppressWarnings(\"unchecked\")\n                    final T item = (T) signal;\n                    window.onNext(item);\n\n                    final long c = this.count + 1;\n                    if (c == maxSize) {\n                        this.count = 0;\n                        window = createNewWindow(window);\n                    } else {\n                        this.count = c;\n                    }\n                }\n                continue;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "245", "src_id": "M598", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    final Subscriber<? super R> downstream = this.downstream;\n    Iterator<? extends R> itLocal = this.it;\n\n    if (outputFused && itLocal != null) {\n        downstream.onNext(null);\n        downstream.onComplete();\n        return;\n    }\n\n    int missed = 1;\n\n    for (;;) {\n        if (itLocal != null) {\n            final long requestedCount = requested.get();\n\n            if (requestedCount == Long.MAX_VALUE) {\n                fastPath(downstream, itLocal);\n                return;\n            }\n\n            long emittedCount = 0L;\n\n            while (emittedCount != requestedCount) {\n                if (cancelled) {\n                    return;\n                }\n\n                final R value;\n                try {\n                    value = Objects.requireNonNull(itLocal.next(), \"The iterator returned a null value\");\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    downstream.onError(ex);\n                    return;\n                }\n\n                downstream.onNext(value);\n\n                if (cancelled) {\n                    return;\n                }\n\n                emittedCount++;\n\n                final boolean hasMore;\n                try {\n                    hasMore = itLocal.hasNext();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    downstream.onError(ex);\n                    return;\n                }\n\n                if (!hasMore) {\n                    downstream.onComplete();\n                    return;\n                }\n            }\n\n            if (emittedCount != 0L) {\n                BackpressureHelper.produced(requested, emittedCount);\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n\n        if (itLocal == null) {\n            itLocal = it;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "246", "src_id": "M1224", "code": "\nvoid drainLoop() {\n    final Subscriber<? super T> downstream = this.downstream;\n\n    int missed = 1;\n    long emittedCount = emitted;\n    int consumedCount = consumed;\n    final int requestLimit = limit;\n\n    for (;;) {\n        final long requestedCount = requested.get();\n\n        while (emittedCount != requestedCount) {\n            if (cancelled) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            int other = otherState;\n            if (other == OTHER_STATE_HAS_VALUE) {\n                final T v = singleItem;\n                singleItem = null;\n                otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                other = OTHER_STATE_CONSUMED_OR_EMPTY;\n\n                downstream.onNext(v);\n                emittedCount++;\n                continue;\n            }\n\n            final boolean mainDoneLocal = mainDone;\n            final SimplePlainQueue<T> q = queue;\n            final T v = q != null ? q.poll() : null;\n            final boolean empty = v == null;\n\n            if (mainDoneLocal && empty && other == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                queue = null;\n                downstream.onComplete();\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            downstream.onNext(v);\n            emittedCount++;\n\n            if (++consumedCount == requestLimit) {\n                consumedCount = 0;\n                mainSubscription.get().request(requestLimit);\n            }\n        }\n\n        if (emittedCount == requestedCount) {\n            if (cancelled) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            final boolean mainDoneLocal = mainDone;\n            final SimplePlainQueue<T> q = queue;\n            final boolean empty = q == null || q.isEmpty();\n\n            if (mainDoneLocal && empty && otherState == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                queue = null;\n                downstream.onComplete();\n                return;\n            }\n        }\n\n        emitted = emittedCount;\n        consumed = consumedCount;\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "247", "src_id": "M142", "code": "\n@Override\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n\n    final Subscriber<? super R> downstream = this.downstream;\n    final ErrorMode errorMode = this.errorMode;\n    final SimpleQueue<T> queue = this.queue;\n    final AtomicThrowable errors = this.errors;\n    final AtomicLong requested = this.requested;\n    final int limit = prefetch - (prefetch >> 1);\n    final boolean syncFused = this.syncFused;\n\n    for (;;) {\n        for (;;) {\n            if (cancelled) {\n                queue.clear();\n                item = null;\n                break;\n            }\n\n            final int s = state;\n\n            if (errors.get() != null) {\n                if (errorMode == ErrorMode.IMMEDIATE\n                        || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) {\n                    queue.clear();\n                    item = null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n            }\n\n            if (s == STATE_INACTIVE) {\n                final boolean d = done;\n                final T v;\n                try {\n                    v = queue.poll();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.cancel();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                final boolean empty = v == null;\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                if (!syncFused) {\n                    final int c = consumed + 1;\n                    if (c == limit) {\n                        consumed = 0;\n                        upstream.request(limit);\n                    } else {\n                        consumed = c;\n                    }\n                }\n\n                final MaybeSource<? extends R> ms;\n                try {\n                    ms = Objects.requireNonNull(\n                            mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.cancel();\n                    queue.clear();\n                    errors.tryAddThrowableOrReport(ex);\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                state = STATE_ACTIVE;\n                ms.subscribe(inner);\n                break;\n            } else if (s == STATE_RESULT_VALUE) {\n                final long e = emitted;\n                if (e != requested.get()) {\n                    final R w = item;\n                    item = null;\n\n                    downstream.onNext(w);\n\n                    emitted = e + 1;\n                    state = STATE_INACTIVE;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "248", "src_id": "M2196", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid remove(@NonNull SingleDisposable<T> inner) {\n    for (;;) {\n        final SingleDisposable<T>[] current = observers.get();\n        final int n = current.length;\n\n        if (n == 0) {\n            return;\n        }\n\n        int idx = -1;\n        for (int i = 0; i < n; i++) {\n            if (current[i] == inner) {\n                idx = i;\n                break;\n            }\n        }\n\n        if (idx < 0) {\n            return;\n        }\n\n        final SingleDisposable<T>[] next;\n        if (n == 1) {\n            next = EMPTY;\n        } else {\n            next = new SingleDisposable[n - 1];\n            System.arraycopy(current, 0, next, 0, idx);\n            System.arraycopy(current, idx + 1, next, idx, n - idx - 1);\n        }\n\n        if (observers.compareAndSet(current, next)) {\n            return;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "249", "src_id": "M2269", "code": "\n@Override\nprotected void subscribeActual(@NonNull Subscriber<? super T> subscriber) {\n    final AsyncSubscription<T> subscription = new AsyncSubscription<>(subscriber, this);\n    subscriber.onSubscribe(subscription);\n\n    if (add(subscription)) {\n        if (subscription.isCancelled()) {\n            remove(subscription);\n        }\n        return;\n    }\n\n    final Throwable ex = error;\n    if (ex != null) {\n        subscriber.onError(ex);\n        return;\n    }\n\n    final T v = value;\n    if (v != null) {\n        subscription.complete(v);\n    } else {\n        subscription.onComplete();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "250", "src_id": "M343", "code": "\nprivate static EmailContent extractEmailContentAdvanced(byte[] emlBytes, EmlToPdfRequest request) {\n  try {\n    // Use Jakarta Mail for processing\n    Class<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n    Class<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n\n    Method getDefaultInstance = sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n    Object session = getDefaultInstance.invoke(null, new Properties());\n\n    // Cast the session object to the proper type for the constructor\n    Class<?>[] constructorArgs = new Class<?>[] { sessionClass, InputStream.class };\n    Constructor<?> mimeMessageConstructor = mimeMessageClass.getConstructor(constructorArgs);\n    Object message = mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n\n    return extractEmailContentAdvanced(message, request);\n\n  } catch (ReflectiveOperationException e) {\n    // Create basic EmailContent from basic processing\n    EmailContent content = new EmailContent();\n    content.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n    return content;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "251", "src_id": "M347", "code": "\nprivate static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n  // Create attachment info with paperclip emoji before filename\n  attachmentInfo\n      .append(\"<div class=\\\"attachment-item\\\">\")\n      .append(\"<span class=\\\"attachment-icon\\\">\")\n      .append(MimeConstants.ATTACHMENT_MARKER)\n      .append(\"</span> \")\n      .append(\"<span class=\\\"attachment-name\\\">\")\n      .append(escapeHtml(filename))\n      .append(\"</span>\");\n\n  // Add content type and encoding info\n  if (!contentType.isEmpty() || !encoding.isEmpty()) {\n    attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n    if (!contentType.isEmpty()) {\n      attachmentInfo.append(escapeHtml(contentType));\n    }\n    if (!encoding.isEmpty()) {\n      if (!contentType.isEmpty()) {\n        attachmentInfo.append(\", \");\n      }\n      attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n    }\n    attachmentInfo.append(\")</span>\");\n  }\n  attachmentInfo.append(\"</div>\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "252", "src_id": "M361", "code": "\nprivate static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n  try {\n    if (!isValidJakartaMailPart(part)) {\n      log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n      return;\n    }\n\n    Class<?> partClass = part.getClass();\n    Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n    Method getContent = partClass.getMethod(\"getContent\");\n    Method getDisposition = partClass.getMethod(\"getDisposition\");\n    Method getFileName = partClass.getMethod(\"getFileName\");\n    Method getContentType = partClass.getMethod(\"getContentType\");\n    Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n\n    Object disposition = getDisposition.invoke(part);\n    String filename = (String) getFileName.invoke(part);\n    String contentType = (String) getContentType.invoke(part);\n\n    if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n      content.setTextBody((String) getContent.invoke(part));\n\n    } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n      content.setHtmlBody((String) getContent.invoke(part));\n\n    } else if (\"attachment\".equalsIgnoreCase((String) disposition)\n        || (filename != null && !filename.trim().isEmpty())) {\n\n      content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n      // Always extract basic attachment metadata for display\n      if (filename != null && !filename.trim().isEmpty()) {\n        // Create attachment with metadata only\n        EmailAttachment attachment = new EmailAttachment();\n        // Apply MIME decoding to filename to handle encoded attachment names\n        attachment.setFilename(safeMimeDecode(filename));\n        attachment.setContentType(contentType);\n\n        // Check if it's an embedded image\n        String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n        if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n          attachment.setEmbedded(true);\n          // Store the Content-ID, removing angle brackets if present\n          String contentId = contentIdHeaders[0];\n          if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n            contentId = contentId.substring(1, contentId.length() - 1);\n          }\n          attachment.setContentId(contentId);\n        }\n\n        // Extract attachment data if attachments should be included OR if it's an embedded image\n        // (needed for inline display)\n        if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n          try {\n            Object attachmentContent = getContent.invoke(part);\n            byte[] attachmentData = null;\n\n            if (attachmentContent instanceof java.io.InputStream inputStream) {\n              try {\n                attachmentData = inputStream.readAllBytes();\n              } catch (IOException e) {\n                log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n              }\n            } else if (attachmentContent instanceof byte[] byteArray) {\n              attachmentData = byteArray;\n            } else if (attachmentContent instanceof String stringContent) {\n              attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n            }\n\n            if (attachmentData != null) {\n              // Check size limit (use default 10MB if request is null)\n              long maxSizeMB = (request != null) ? request.getMaxAttachmentSizeMB() : 10L;\n              long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n              if (attachmentData.length <= maxSizeBytes) {\n                attachment.setData(attachmentData);\n                attachment.setSizeBytes(attachmentData.length);\n              } else {\n                // For embedded images, always include data regardless of size to ensure inline display works\n                if (attachment.isEmbedded()) {\n                  attachment.setData(attachmentData);\n                  attachment.setSizeBytes(attachmentData.length);\n                } else {\n                  // Still show attachment info even if too large\n                  attachment.setSizeBytes(attachmentData.length);\n                }\n              }\n            }\n          } catch (Exception e) {\n            log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n          }\n        }\n\n        // Add attachment to the list for display (with or without data)\n        content.getAttachments().add(attachment);\n      }\n\n    } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n      // Handle nested multipart content\n      try {\n        Object multipartContent = getContent.invoke(part);\n        Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n        if (multipartClass.isInstance(multipartContent)) {\n          processMultipartAdvanced(multipartContent, content, request);\n        }\n      } catch (Exception e) {\n        log.warn(\"Error processing multipart content: {}\", e.getMessage());\n      }\n    }\n\n  } catch (Exception e) {\n    log.warn(\"Error processing multipart part: {}\", e.getMessage());\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "253", "src_id": "M509", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n@Operation(\n    summary = \"Convert EML to PDF\",\n    description = \"This endpoint converts EML (email) files to PDF format with extensive\"\n        + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n        + \" and HTML debug output. Input: EML file, Output: PDF\"\n        + \" or HTML file. Type: SISO\")\npublic ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n\n  MultipartFile inputFile = request.getFileInput();\n  String originalFilename = inputFile.getOriginalFilename();\n\n  // Validate input\n  if (inputFile.isEmpty()) {\n    log.error(\"No file provided for EML to PDF conversion.\");\n    return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n  }\n\n  if (originalFilename == null || originalFilename.trim().isEmpty()) {\n    log.error(\"Filename is null or empty.\");\n    return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n  }\n\n  // Validate file type - support EML\n  String lowerFilename = originalFilename.toLowerCase();\n  if (!lowerFilename.endsWith(\".eml\")) {\n    log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n    return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n  }\n\n  String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n\n  try {\n    byte[] fileBytes = inputFile.getBytes();\n\n    if (request.isDownloadHtml()) {\n      try {\n        String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n        log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n        return WebResponseUtils.bytesToWebResponse(\n            htmlContent.getBytes(StandardCharsets.UTF_8),\n            baseFilename + \".html\",\n            MediaType.TEXT_HTML);\n      } catch (IOException | IllegalArgumentException e) {\n        log.error(\"HTML conversion failed for {}\", originalFilename, e);\n        return ResponseEntity\n            .status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n      }\n    }\n\n    // Convert EML to PDF with enhanced options\n    try {\n      byte[] pdfBytes = EmlToPdf.convertEmlToPdf(\n          runtimePathConfig.getWeasyPrintPath(), // Use configured WeasyPrint path\n          request,\n          fileBytes,\n          originalFilename,\n          false,\n          pdfDocumentFactory,\n          tempFileManager);\n\n      if (pdfBytes == null || pdfBytes.length == 0) {\n        log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n        return ResponseEntity\n            .status(HttpStatus.INTERNAL_SERVER_ERROR)\n            .body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n      }\n      log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n      return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf, MediaType.APPLICATION_PDF\");\n\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n      return ResponseEntity\n          .status(HttpStatus.INTERNAL_SERVER_ERROR)\n          .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n    } catch (IllegalArgumentException e) {\n      String errorMessage = buildErrorMessage(e, originalFilename);\n      log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n    } catch (RuntimeException e) {\n      String errorMessage = buildErrorMessage(e, originalFilename);\n      log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n    }\n\n  } catch (IOException e) {\n    log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "254", "src_id": "M1281", "code": "\n    @Override\n    protected void subscribeActual(final Subscriber<? super T> s) {\n        PublishConnection<T> conn;\n\n        for (;;) {\n            conn = current.get();\n\n            // don't create a fresh connection if the current is disposed\n            if (conn == null) {\n                final PublishConnection<T> fresh = new PublishConnection<>(current, bufferSize);\n                if (!current.compareAndSet(conn, fresh)) {\n                    continue;\n                }\n                conn = fresh;\n            }\n\n            break;\n        }\n\n        final InnerSubscription<T> inner = new InnerSubscription<>(s, conn);\n        s.onSubscribe(inner);\n\n        if (conn.add(inner)) {\n            if (inner.isCancelled()) {\n                conn.remove(inner);\n            } else {\n                conn.drain();\n            }\n            return;\n        }\n\n        final Throwable ex = conn.error;\n        if (ex != null) {\n            inner.downstream.onError(ex);\n        } else {\n            inner.downstream.onComplete();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "255", "src_id": "M1061", "code": "\n        @Override\n        Node getHead() {\n            final long timeLimit = scheduler.now(unit) - maxAge;\n\n            Node prev = get();\n            Node next = prev.get();\n\n            for (;;) {\n                if (next == null) {\n                    break;\n                }\n\n                final Timed<?> v = (Timed<?>) next.value;\n\n                if (NotificationLite.isComplete(v.value()) || NotificationLite.isError(v.value())) {\n                    break;\n                }\n\n                if (v.time() <= timeLimit) {\n                    prev = next;\n                    next = next.get();\n                } else {\n                    break;\n                }\n            }\n\n            return prev;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "256", "src_id": "M125", "code": "\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n\n            final Subscriber<? super R> downstream = this.downstream;\n            final AtomicThrowable errors = this.errors;\n            final AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n            final AtomicLong requested = this.requested;\n\n            long emitted = this.emitted;\n\n            for (;;) {\n\n                for (;;) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (errors.get() != null) {\n                        if (!delayErrors) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    final boolean d = done;\n                    final SwitchMapMaybeObserver<R> current = inner.get();\n                    final boolean empty = current == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty || current.item == null || emitted == requested.get()) {\n                        break;\n                    }\n\n                    inner.compareAndSet(current, null);\n\n                    downstream.onNext(current.item);\n\n                    emitted++;\n                }\n\n                this.emitted = emitted;\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "257", "src_id": "M341", "code": "\n        @Override\n        public void run() {\n            for (;;) {\n                if (disposed) {\n                    queue.clear();\n                    return;\n                }\n\n                if (!active) {\n\n                    final boolean d = done;\n\n                    T t;\n\n                    try {\n                        t = queue.poll();\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        dispose();\n                        queue.clear();\n                        downstream.onError(ex);\n                        worker.dispose();\n                        return;\n                    }\n\n                    final boolean empty = t == null;\n\n                    if (d && empty) {\n                        disposed = true;\n                        downstream.onComplete();\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        final ObservableSource<? extends U> o;\n                        try {\n                            o = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            dispose();\n                            queue.clear();\n                            downstream.onError(ex);\n                            worker.dispose();\n                            return;\n                        }\n\n                        active = true;\n                        o.subscribe(inner);\n                    }\n                }\n\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "258", "src_id": "M55", "code": "\n        @Override\n        void drain() {\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n\n            final Observer<? super R> downstream = this.downstream;\n            final ErrorMode errorMode = this.errorMode;\n            final SimpleQueue<T> queue = this.queue;\n            final AtomicThrowable errors = this.errors;\n\n            for (;;) {\n\n                for (;;) {\n                    if (disposed) {\n                        queue.clear();\n                        item = null;\n                        break;\n                    }\n\n                    final int s = state;\n\n                    if (errors.get() != null) {\n                        if (errorMode == ErrorMode.IMMEDIATE\n                                || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) {\n                            queue.clear();\n                            item = null;\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n                    }\n\n                    if (s == STATE_INACTIVE) {\n                        final boolean d = done;\n\n                        T v;\n\n                        try {\n                            v = queue.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            disposed = true;\n                            upstream.dispose();\n                            errors.tryAddThrowableOrReport(ex);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        final boolean empty = v == null;\n\n                        if (d && empty) {\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n\n                        final MaybeSource<? extends R> ms;\n\n                        try {\n                            ms = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            upstream.dispose();\n                            queue.clear();\n                            errors.tryAddThrowableOrReport(ex);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                        state = STATE_ACTIVE;\n                        ms.subscribe(inner);\n                        break;\n                    } else if (s == STATE_RESULT_VALUE) {\n                        final R w = item;\n                        item = null;\n                        downstream.onNext(w);\n\n                        state = STATE_INACTIVE;\n                    } else {\n                        break;\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "259", "src_id": "M1425", "code": "\n        @Override\n        public void run() {\n\n            for (;;) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!active) {\n\n                    final boolean d = done;\n\n                    if (d && !veryEnd) {\n                        final Throwable ex = errors.get();\n                        if (ex != null) {\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n                    }\n\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    final boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n                    if (!empty) {\n                        final Publisher<? extends R> p;\n\n                        try {\n                            p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                        } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n                        if (sourceMode != QueueSubscription.SYNC) {\n                            final int c = consumed + 1;\n                            if (c == limit) {\n                                consumed = 0;\n                                upstream.request(c);\n                            } else {\n                                consumed = c;\n                            }\n                        }\n\n                        if (p instanceof Supplier) {\n                            @SuppressWarnings(\"unchecked\")\n                            final Supplier<R> supplier = (Supplier<R>) p;\n\n                            R vr;\n\n                            try {\n                                vr = supplier.get();\n                            } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n                                vr = null;\n                            }\n\n                            if (vr == null || cancelled) {\n                                continue;\n                            }\n\n                            if (inner.isUnbounded()) {\n                                downstream.onNext(vr);\n                                continue;\n                            } else {\n                                active = true;\n                                inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                            }\n                        } else {\n                            active = true;\n                            p.subscribe(inner);\n                        }\n                    }\n                }\n                if (decrementAndGet() == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "260", "src_id": "M1003", "code": "\n        void drain() {\n            if (wip.getAndIncrement() != 0) {\n                return;\n            }\n\n            int missed = 1;\n\n            SimpleQueue<T> q = queue;\n\n            int upstreamConsumed = consumed;\n            final int localLimit = limit;\n            final boolean canRequest = sourceMode != QueueSubscription.SYNC;\n            final AtomicReference<MulticastSubscription<T>[]> subs = subscribers;\n\n            MulticastSubscription<T>[] array = subs.get();\n\n            outer:\n            for (;;) {\n\n                int n = array.length;\n\n                if (q != null && n != 0) {\n                    long r = Long.MAX_VALUE;\n\n                    for (final MulticastSubscription<T> ms : array) {\n                        final long u = ms.get() - ms.emitted;\n                        if (u != Long.MIN_VALUE) {\n                            if (r > u) {\n                                r = u;\n                            }\n                        } else {\n                            n--;\n                        }\n                    }\n\n                    if (n == 0) {\n                        r = 0;\n                    }\n\n                    while (r != 0) {\n                        if (isDisposed()) {\n                            q.clear();\n                            return;\n                        }\n\n                        final boolean d = done;\n\n                        if (d && !delayError) {\n                            final Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                                return;\n                            }\n                        }\n\n                        T v;\n\n                        try {\n                            v = q.poll();\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            SubscriptionHelper.cancel(upstream);\n                            errorAll(ex);\n                            return;\n                        }\n\n                        final boolean empty = v == null;\n\n                        if (d && empty) {\n                            final Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                            } else {\n                                completeAll();\n                            }\n                            return;\n                        }\n\n                        if (empty) {\n                            break;\n                        }\n\n                        boolean subscribersChange = false;\n\n                        for (final MulticastSubscription<T> ms : array) {\n                            final long msr = ms.get();\n                            if (msr != Long.MIN_VALUE) {\n                                if (msr != Long.MAX_VALUE) {\n                                    ms.emitted++;\n                                }\n                                ms.downstream.onNext(v);\n                            } else {\n                                subscribersChange = true;\n                            }\n                        }\n\n                        r--;\n\n                        if (canRequest && ++upstreamConsumed == localLimit) {\n                            upstreamConsumed = 0;\n                            upstream.get().request(localLimit);\n                        }\n\n                        final MulticastSubscription<T>[] freshArray = subs.get();\n                        if (subscribersChange || freshArray != array) {\n                            array = freshArray;\n                            continue outer;\n                        }\n                    }\n\n                    if (r == 0) {\n                        if (isDisposed()) {\n                            q.clear();\n                            return;\n                        }\n\n                        final boolean d = done;\n\n                        if (d && !delayError) {\n                            final Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                                return;\n                            }\n                        }\n\n                        if (d && q.isEmpty()) {\n                            final Throwable ex = error;\n                            if (ex != null) {\n                                errorAll(ex);\n                            } else {\n                                completeAll();\n                            }\n                            return;\n                        }\n                    }\n                }\n\n                consumed = upstreamConsumed;\n\n                missed = wip.addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n\n                if (q == null) {\n                    q = queue;\n                }\n                array = subs.get();\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "261", "src_id": "M1237", "code": "\n        void drain() {\n\n            if (getAndIncrement() != 0) {\n                return;\n            }\n\n            final Subscriber<? super R> a = downstream;\n            final ZipSubscriber<T, R>[] qs = subscribers;\n            final int n = qs.length;\n            final Object[] values = current;\n\n            int missed = 1;\n\n            for (;;) {\n\n                final long r = requested.get();\n                long e = 0L;\n\n                while (r != e) {\n\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!delayErrors && errors.get() != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    boolean empty = false;\n\n                    for (int j = 0; j < n; j++) {\n                        final ZipSubscriber<T, R> inner = qs[j];\n\n                        if (values[j] == null) {\n                            boolean d = inner.done;\n                            final SimpleQueue<T> q = inner.queue;\n                            T v = null;\n\n                            try {\n                                v = q != null ? q.poll() : null;\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n                                d = true;\n                            }\n\n                            final boolean sourceEmpty = v == null;\n                            if (d && sourceEmpty) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            if (!sourceEmpty) {\n                                values[j] = v;\n                            } else {\n                                empty = true;\n                            }\n                        }\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    final R v;\n                    try {\n                        v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n                    } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelAll();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    a.onNext(v);\n\n                    e++;\n\n                    Arrays.fill(values, null);\n                }\n\n                if (r == e) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    if (!delayErrors && errors.get() != null) {\n                        cancelAll();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                    for (int j = 0; j < n; j++) {\n                        final ZipSubscriber<T, R> inner = qs[j];\n\n                        if (values[j] == null) {\n                            boolean d = inner.done;\n                            final SimpleQueue<T> q = inner.queue;\n                            T v = null;\n\n                            try {\n                                v = q != null ? q.poll() : null;\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n                                d = true;\n                            }\n\n                            final boolean empty = v == null;\n                            if (d && empty) {\n                                cancelAll();\n                                errors.tryTerminateConsumer(a);\n                                return;\n                            }\n                            if (!empty) {\n                                values[j] = v;\n                            }\n                        }\n                    }\n\n                }\n\n                if (e != 0L) {\n\n                    for (final ZipSubscriber<T, R> inner : qs) {\n                        inner.request(e);\n                    }\n\n                    if (r != Long.MAX_VALUE) {\n                        requested.addAndGet(-e);\n                    }\n                }\n\n                missed = addAndGet(-missed);\n                if (missed == 0) {\n                    break;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "262", "src_id": "M558", "code": "\n        void innerSuccess(final InnerObserver inner, final R value) {\n            set.delete(inner);\n\n            if (get() == 0 && compareAndSet(0, 1)) {\n                downstream.onNext(value);\n\n                final boolean d = active.decrementAndGet() == 0;\n                final SpscLinkedArrayQueue<R> q = queue.get();\n\n                if (d && (q == null || q.isEmpty())) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                if (decrementAndGet() == 0) {\n                    return;\n                }\n            } else {\n                final SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n                synchronized (q) {\n                    q.offer(value);\n                }\n                active.decrementAndGet();\n                if (getAndIncrement() != 0) {\n                    return;\n                }\n            }\n\n            drainLoop();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "263", "src_id": "M2273", "code": "\n    @Override\n    public void onSubscribe(final Subscription s) {\n        boolean cancel;\n\n        if (!done) {\n            synchronized (this) {\n                if (done) {\n                    cancel = true;\n                } else {\n                    if (emitting) {\n                        AppendOnlyLinkedArrayList<Object> q = queue;\n                        if (q == null) {\n                            q = new AppendOnlyLinkedArrayList<>(4);\n                            queue = q;\n                        }\n                        q.add(NotificationLite.subscription(s));\n                        return;\n                    }\n                    emitting = true;\n                    cancel = false;\n                }\n            }\n        } else {\n            cancel = true;\n        }\n\n        if (cancel) {\n            s.cancel();\n        } else {\n            actual.onSubscribe(s);\n            emitLoop();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "264", "src_id": "M520", "code": "\n@Override\npublic void close() throws IOException {\n    boolean triedToClose = false;\n    boolean success = false;\n    try {\n        flush();\n        ((FileOutputStream) out).getFD().sync();\n\n        triedToClose = true;\n        super.close();\n        success = true;\n    } finally {\n        if (success) {\n            boolean renamed = tmpFile.renameTo(origFile);\n            if (!renamed) {\n                // On windows, renameTo does not replace.\n                if (!origFile.delete() || !tmpFile.renameTo(origFile)) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            }\n        } else {\n            if (!triedToClose) {\n                // If we failed when flushing, try to close it to not leak an FD\n                IOUtils.closeStream(out);\n            }\n            // close wasn't successful, try to delete the tmp file\n            if (!tmpFile.delete()) {\n                LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "265", "src_id": "M1043", "code": "\nvoid handleWrite(SelectionKey k) throws IOException {\n    if (outgoingBuffers.isEmpty()) {\n        return;\n    }\n\n    /*\n     * This is going to reset the buffer position to 0 and the limit to the size of the buffer,\n     * so that we can fill it with data from the non-direct buffers that we need to send.\n     */\n    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n    if (directBuffer == null) {\n        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n        // Use gathered write call. This updates the positions of the byte buffers to reflect the bytes that were written out.\n        sock.write(outgoingBuffers.toArray(bufferList));\n\n        // Remove the buffers that we have sent\n        ByteBuffer bb;\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (bb.remaining() > 0) {\n                break;\n            }\n            outgoingBuffers.remove();\n        }\n    } else {\n        directBuffer.clear();\n\n        for (ByteBuffer b : outgoingBuffers) {\n            if (directBuffer.remaining() < b.remaining()) {\n                /*\n                 * When we call put later, if the directBuffer is too small to hold everything, nothing will be copied,\n                 * so we've got to slice the buffer if it's too big.\n                 */\n                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n            }\n            /*\n             * put() is going to modify the positions of both buffers, but we don't want to change the position of\n             * the source buffers (we'll do that after the send, if needed), so we save and reset the position after the copy\n             */\n            int p = b.position();\n            directBuffer.put(b);\n            b.position(p);\n            if (directBuffer.remaining() == 0) {\n                break;\n            }\n        }\n        /*\n         * Do the flip: limit becomes position, position gets set to 0. This sets us up for the write.\n         */\n        directBuffer.flip();\n\n        int sent = sock.write(directBuffer);\n\n        ByteBuffer bb;\n\n        // Remove the buffers that we have sent\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (sent < bb.remaining()) {\n                /*\n                 * We only partially sent this buffer, so we update the position and exit the loop.\n                 */\n                bb.position(bb.position() + sent);\n                break;\n            }\n            // We've sent the whole buffer, so drop the buffer\n            sent -= bb.remaining();\n            outgoingBuffers.remove();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "266", "src_id": "M196", "code": "\npublic static void main(String[] args) throws IOException {\n    MergedLogSource source = new MergedLogSource(args);\n\n    PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n    PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n    PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n    PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n    LogIterator iter;\n\n    System.out.println(source);\n    iter = source.iterator();\n    long currentms = 0;\n    long currentsec = 0;\n    long currentmin = 0;\n    long currenthour = 0;\n    Set<Long> zxids_ms = new HashSet<Long>();\n    long zxid_sec = 0;\n    long zxid_min = 0;\n    long zxid_hour = 0;\n\n    while (iter.hasNext()) {\n        LogEntry e = iter.next();\n        TransactionEntry cxn = (TransactionEntry) e;\n\n        long ms = cxn.getTimestamp();\n        long sec = ms / MS_PER_SEC;\n        long min = ms / MS_PER_MIN;\n        long hour = ms / MS_PER_HOUR;\n\n        if (currentms != ms && currentms != 0) {\n            ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n\n            zxid_sec += zxids_ms.size();\n            zxid_min += zxids_ms.size();\n            zxid_hour += zxids_ms.size();\n            zxids_ms.clear();\n        }\n\n        if (currentsec != sec && currentsec != 0) {\n            ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n\n            zxid_sec = 0;\n        }\n\n        if (currentmin != min && currentmin != 0) {\n            ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n\n            zxid_min = 0;\n        }\n\n        if (currenthour != hour && currenthour != 0) {\n            ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n\n            zxid_hour = 0;\n        }\n\n        currentms = ms;\n        currentsec = sec;\n        currentmin = min;\n        currenthour = hour;\n\n        zxids_ms.add(cxn.getZxid());\n    }\n\n    iter.close();\n    ps_ms.close();\n    ps_sec.close();\n    ps_min.close();\n    ps_hour.close();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "267", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        // Close connections still pending on the selector. Any others with in-flight work, let drain out of the work queue.\n        for (SelectionKey key : selector.keys()) {\n            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        // This will wake up the accept thread and the other selector threads, and tell the worker thread pool to begin shutdown.\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "268", "src_id": "M290", "code": "\npublic String getStatus(String name, long timeout) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    byte[] data = null;\n    long endTime = Time.currentElapsedTime() + timeout;\n    KeeperException lastException = null;\n    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n        try {\n            data = zk.getData(reportsNode + '/' + name, false, stat);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n            }\n            lastException = null;\n            break;\n        } catch (ConnectionLossException e) {\n            lastException = e;\n        } catch (NoNodeException e) {\n            final Object eventObj = new Object();\n            synchronized (eventObj) {\n                // wait for the node to appear\n                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {\n                    @Override\n                    public void process(WatchedEvent event) {\n                        synchronized (eventObj) {\n                            eventObj.notifyAll();\n                        }\n                    }\n                });\n                if (eStat == null) {\n                    eventObj.wait(endTime - Time.currentElapsedTime());\n                }\n            }\n            lastException = e;\n        }\n    }\n    if (lastException != null) {\n        throw lastException;\n    }\n    return new String(data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "269", "src_id": "M192", "code": "\nprivate void init() throws IOException {\n    File f = new File(file);\n    RandomAccessFileReader in = new RandomAccessFileReader(f);\n    SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n    Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n\n    long lastFp = in.getPosition();\n    String line = in.readLine();\n    Matcher m = null;\n\n    // if we have read data from the file, and it matches the timep pattern\n    if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n        starttime = timestampFromText(dateformat, m.group(1));\n    } else {\n        throw new IOException(\"Invalid log format. First line doesn't start with time\");\n    }\n\n    /*\n     * Count number of log entries. Any line starting with a timestamp counts as an entry\n     */\n    String lastentry = line;\n    try {\n        while (line != null) {\n            m = timep.matcher(line);\n            if (m.lookingAt()) {\n                if (size % skipN == 0) {\n                    long time = timestampFromText(dateformat, m.group(1));\n                    skiplist.addMark(time, lastFp, size);\n                }\n                size++;\n                lastentry = line;\n            }\n            if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                serverid = Integer.valueOf(m.group(1));\n            }\n\n            lastFp = in.getPosition();\n            line = in.readLine();\n        }\n    } catch (EOFException eof) {\n        // ignore, simply end of file, though really (line!=null) should have caught this\n    } finally {\n        in.close();\n    }\n\n    m = timep.matcher(lastentry);\n    if (m.lookingAt()) {\n        endtime = timestampFromText(dateformat, m.group(1));\n    } else {\n        throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "270", "src_id": "M254", "code": "\nprivate void distributedConfigureServers(int count) throws IOException {\n    StringBuilder sbClient = new StringBuilder();\n    StringBuilder sbServer = new StringBuilder();\n    try {\n        for (int i = 0; i < count; i++) {\n            String[] r = QuorumPeerInstance.createServer(im, i);\n            if (i > 0) {\n                sbClient.append(',');\n                sbServer.append(',');\n            }\n            sbClient.append(r[0]); // r[0] == \"host:clientPort\"\n            sbServer.append(r[1]); // r[1] == \"host:leaderPort:leaderElectionPort\"\n            String[] hostPort = r[0].split(\":\");\n            sbServer.append(';').append(hostPort[1]); // Appending \";clientPort\"\n        }\n        serverHostPort = sbClient.toString();\n        quorumHostPort = sbServer.toString();\n    } catch (Exception e) {\n        IOException ioe = new IOException(e.getMessage());\n        ioe.setStackTrace(e.getStackTrace());\n        throw ioe;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "271", "src_id": "M40", "code": "\nprotected void animateVertically(int posx, int fromY, int toY) throws InterruptedException {\n    toaster.setLocation(posx, fromY);\n    if (toY < fromY) {\n        for (int i = fromY; i > toY; i -= step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    } else {\n        for (int i = fromY; i < toY; i += step) {\n            toaster.setLocation(posx, i);\n            Thread.sleep(stepTime);\n        }\n    }\n    toaster.setLocation(posx, toY);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "272", "src_id": "M1130", "code": "\npublic synchronized Map<String, Object> getConnectionInfo(boolean brief) {\n    Map<String, Object> info = new LinkedHashMap<>();\n    info.put(\"remote_socket_address\", getRemoteSocketAddress());\n    info.put(\"interest_ops\", getInterestOps());\n    info.put(\"outstanding_requests\", getOutstandingRequests());\n    info.put(\"packets_received\", getPacketsReceived());\n    info.put(\"packets_sent\", getPacketsSent());\n    if (!brief) {\n        info.put(\"session_id\", getSessionId());\n        info.put(\"last_operation\", getLastOperation());\n        info.put(\"established\", getEstablished());\n        info.put(\"session_timeout\", getSessionTimeout());\n        info.put(\"last_cxid\", getLastCxid());\n        info.put(\"last_zxid\", getLastZxid());\n        info.put(\"last_response_time\", getLastResponseTime());\n        info.put(\"last_latency\", getLastLatency());\n        info.put(\"min_latency\", getMinLatency());\n        info.put(\"avg_latency\", getAvgLatency());\n        info.put(\"max_latency\", getMaxLatency());\n    }\n    return info;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "273", "src_id": "M1036", "code": "\npublic void start() {\n  if (running || isFinished() || urls.length < 1) return;\n\n  // ensure that the previous state is completely paused.\n  joinForThreads(10000);\n\n  running = true;\n  errCode = ERROR_NOTHING;\n\n  if (hasInvalidStorage()) {\n    notifyError(ERROR_FILE_CREATION, null);\n    return;\n  }\n\n  if (current >= urls.length) {\n    notifyFinished();\n    return;\n  }\n\n  notify(DownloadManagerService.MESSAGE_RUNNING);\n\n  if (urls[current] == null) {\n    doRecover(ERROR_RESOURCE_GONE);\n    return;\n  }\n\n  if (blocks == null) {\n    initializer();\n    return;\n  }\n\n  init = null;\n  finishCount = 0;\n  blockAcquired = new boolean[blocks.length];\n\n  if (blocks.length < 1) {\n    threads = new Thread[] { runAsync(1, new DownloadRunnableFallback(this)) };\n  } else {\n    int remainingBlocks = 0;\n    for (int block : blocks) if (block >= 0) remainingBlocks++;\n\n    if (remainingBlocks < 1) {\n      notifyFinished();\n      return;\n    }\n\n    threads = new Thread[Math.min(threadCount, remainingBlocks)];\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = runAsync(i + 1, new DownloadRunnable(this, i));\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "274", "src_id": "M803", "code": "\npublic void parse() throws IOException, NoSuchElementException {\n  if (selectedTrack > -1) return;\n\n  box = readBox(ATOM_FTYP);\n  brands = parseFtyp(box);\n  switch (brands[0]) {\n    case BRAND_DASH:\n    case BRAND_ISO5: // ¿why not?\n      break;\n    default:\n      throw new NoSuchElementException(\n          \"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \" + boxName(brands[0]));\n  }\n\n  Moov moov = null;\n  int i;\n\n  while (box.type != ATOM_MOOF) {\n    ensure(box);\n    box = readBox();\n\n    switch (box.type) {\n      case ATOM_MOOV:\n        moov = parseMoov(box);\n        break;\n      case ATOM_SIDX:\n      case ATOM_MFRA:\n        break;\n    }\n  }\n\n  if (moov == null) {\n    throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n  }\n\n  tracks = new Mp4Track[moov.trak.length];\n\n  for (i = 0; i < tracks.length; i++) {\n    tracks[i] = new Mp4Track();\n    tracks[i].trak = moov.trak[i];\n\n    if (moov.mvexTrex != null) {\n      for (final Trex mvexTrex : moov.mvexTrex) {\n        if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n          tracks[i].trex = mvexTrex;\n        }\n      }\n    }\n\n    switch (moov.trak[i].mdia.hdlr.subType) {\n      case HANDLER_VIDE:\n        tracks[i].kind = TrackKind.Video;\n        break;\n      case HANDLER_SOUN:\n        tracks[i].kind = TrackKind.Audio;\n        break;\n      case HANDLER_SUBT:\n        tracks[i].kind = TrackKind.Subtitles;\n        break;\n      default:\n        tracks[i].kind = TrackKind.Other;\n        break;\n    }\n  }\n\n  backupBox = box;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "275", "src_id": "M1031", "code": "\nvoid establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n  final int statusCode = conn.getResponseCode();\n\n  if (DEBUG) {\n    Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n    Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n    Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n    Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n  }\n\n  switch (statusCode) {\n    case 204:\n    case 205:\n    case 207:\n      throw new HttpError(statusCode);\n    case 416:\n      return; // let the download thread handle this error\n    default:\n      if (statusCode < 200 || statusCode > 299) {\n        throw new HttpError(statusCode);\n      }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "276", "src_id": "M827", "code": "\nprivate Elst parseEdts(final Box ref) throws IOException {\n  final Box b = untilBox(ref, ATOM_ELST);\n  if (b == null) return null;\n\n  final Elst obj = new Elst();\n\n  final boolean v1 = stream.read() == 1;\n  stream.skipBytes(3); // flags\n\n  final int entryCount = stream.readInt();\n  if (entryCount < 1) {\n    obj.bMediaRate = 0x00010000; // default media rate (1.0)\n    return obj;\n  }\n\n  if (v1) {\n    stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n    obj.mediaTime = stream.readLong();\n    // ignore all remain entries\n    stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n  } else {\n    stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n    obj.mediaTime = stream.readInt();\n  }\n\n  obj.bMediaRate = stream.readInt();\n  return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "277", "src_id": "M1144", "code": "\n@Override\npublic void write(byte[] b, int off, int len) throws IOException {\n  if (len == 0) return;\n\n  final long offsetOut = out.getOffset();\n  final long offsetAux = aux.getOffset();\n  final long end = callback.check();\n\n  long available;\n  if (end == -1) {\n    available = Integer.MAX_VALUE;\n  } else if (end < offsetOut) {\n    throw new IOException(\"The reported offset is invalid: \" + end + \"<\" + offsetOut);\n  } else {\n    available = end - offsetOut;\n  }\n\n  final boolean usingAux = aux.length > 0 && offsetOut >= out.length;\n  final boolean underflow = offsetAux < aux.length || offsetOut < out.length;\n\n  if (usingAux) {\n    // before continue calculate the final length of aux\n    long length = offsetAux + len;\n    if (underflow) {\n      if (aux.length > length) {\n        length = aux.length; // the length is not changed\n      }\n    } else {\n      length = aux.length + len;\n    }\n\n    aux.write(b, off, len);\n\n    if (length >= THRESHOLD_AUX_LENGTH && length <= available) {\n      flushAuxiliar(available);\n    }\n  } else {\n    if (underflow) {\n      available = out.length - offsetOut;\n    }\n\n    final int length = Math.min(len, (int) Math.min(Integer.MAX_VALUE, available));\n    out.write(b, off, length);\n\n    len -= length;\n    off += length;\n\n    if (len > 0) {\n      aux.write(b, off, len);\n    }\n  }\n\n  if (onProgress != null) {\n    final long absoluteOffset = out.getOffset() + aux.getOffset();\n    if (absoluteOffset > reportPosition) {\n      reportPosition = absoluteOffset + NOTIFY_BYTES_INTERVAL;\n      onProgress.report(absoluteOffset);\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "278", "src_id": "M1048", "code": "\n@Override\npublic void run() {\n  boolean done;\n  long start = mMission.fallbackResumeOffset;\n\n  if (DEBUG && !mMission.unknownLength && start > 0) {\n    Log.i(TAG, \"Resuming a single-thread download at \" + start);\n  }\n\n  try {\n    final long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n    final int mId = 1;\n    mConn = mMission.openConnection(false, rangeStart, -1);\n\n    if (mRetryCount == 0 && rangeStart == -1) {\n      // workaround: bypass android connection pool\n      mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n    }\n\n    mMission.establishConnection(mId, mConn);\n\n    // check if the download can be resumed\n    if (mConn.getResponseCode() == 416 && start > 0) {\n      mMission.notifyProgress(-start);\n      start = 0;\n      mRetryCount--;\n      throw new DownloadMission.HttpError(416);\n    }\n\n    // secondary check for the file length\n    if (!mMission.unknownLength) {\n      mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n    }\n\n    if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n      // restart amount of bytes downloaded\n      mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n    }\n\n    mF = mMission.storage.getStream();\n    mF.seek(mMission.offsets[mMission.current] + start);\n\n    mIs = mConn.getInputStream();\n\n    final byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n    int len = 0;\n\n    while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n      mF.write(buf, 0, len);\n      start += len;\n      mMission.notifyProgress(len);\n    }\n\n    dispose();\n\n    // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n    done = len == -1;\n  } catch (Exception e) {\n    dispose();\n\n    mMission.fallbackResumeOffset = start;\n\n    if (!mMission.running || e instanceof ClosedByInterruptException) return;\n\n    if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n      // for youtube streams. The url has expired, recover\n      dispose();\n      mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n      return;\n    }\n\n    if (mRetryCount++ >= mMission.maxRetry) {\n      mMission.notifyError(e);\n      return;\n    }\n\n    if (DEBUG) {\n      Log.e(TAG, \"got exception, retrying...\", e);\n    }\n\n    run(); // try again\n    return;\n  }\n\n  if (done) {\n    mMission.notifyFinished();\n  } else {\n    mMission.fallbackResumeOffset = start;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "279", "src_id": "M1086", "code": "\nprivate ArrayList<Object> getSpecialItems() {\n  synchronized (DownloadManager.this) {\n    final ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n    final ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n    final List<Mission> remove = new ArrayList<>(hidden);\n\n    // hide missions (if required)\n    remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n    int fakeTotal = pending.size();\n    if (fakeTotal > 0) fakeTotal++;\n\n    fakeTotal += finished.size();\n    if (finished.size() > 0) fakeTotal++;\n\n    final ArrayList<Object> list = new ArrayList<>(fakeTotal);\n    if (pending.size() > 0) {\n      list.add(PENDING);\n      list.addAll(pending);\n    }\n    if (finished.size() > 0) {\n      list.add(FINISHED);\n      list.addAll(finished);\n    }\n\n    hasFinished = finished.size() > 0;\n    return list;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "280", "src_id": "M1067", "code": "\nvoid startMission(DownloadMission mission) {\n  synchronized (this) {\n    mission.timestamp = System.currentTimeMillis();\n    mission.mHandler = mHandler;\n    mission.maxRetry = mPrefMaxRetry;\n\n    // create metadata file\n    while (true) {\n      mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n      if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n        try {\n          if (!mission.metadata.createNewFile()) {\n            throw new RuntimeException(\"Cant create download metadata file\");\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n        break;\n      }\n      mission.timestamp = System.currentTimeMillis();\n    }\n\n    mSelfMissionsControl = true;\n    mMissionsPending.add(mission);\n\n    // Before continue, save the metadata in case the internet connection is not available\n    Utility.writeToFile(mission.metadata, mission);\n\n    if (mission.storage == null) {\n      // noting to do here\n      mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n      if (mission.errObject != null) mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n      return;\n    }\n\n    final boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n    if (canDownloadInCurrentNetwork() && start) {\n      mission.start();\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "281", "src_id": "M1117", "code": "\nprivate void showPopupMenu() {\n  retry.setVisible(false);\n  cancel.setVisible(false);\n  start.setVisible(false);\n  pause.setVisible(false);\n  open.setVisible(false);\n  queue.setVisible(false);\n  showError.setVisible(false);\n  delete.setVisible(false);\n  source.setVisible(false);\n  checksum.setVisible(false);\n\n  final DownloadMission mission = item.mission instanceof DownloadMission ? (DownloadMission) item.mission : null;\n\n  if (mission != null) {\n    if (mission.hasInvalidStorage()) {\n      retry.setVisible(true);\n      delete.setVisible(true);\n      showError.setVisible(true);\n    } else if (mission.isPsRunning()) {\n      switch (mission.errCode) {\n        case ERROR_INSUFFICIENT_STORAGE:\n        case ERROR_POSTPROCESSING_HOLD:\n          retry.setVisible(true);\n          cancel.setVisible(true);\n          showError.setVisible(true);\n          break;\n      }\n    } else {\n      if (mission.running) {\n        pause.setVisible(true);\n      } else {\n        if (mission.errCode != ERROR_NOTHING) {\n          showError.setVisible(true);\n        }\n\n        queue.setChecked(mission.enqueued);\n\n        delete.setVisible(true);\n\n        final boolean flag = !mission.isPsFailed() && mission.urls.length > 0;\n        start.setVisible(flag);\n        queue.setVisible(flag);\n      }\n    }\n  } else {\n    open.setVisible(true);\n    delete.setVisible(true);\n    checksum.setVisible(true);\n  }\n\n  if (item.mission.source != null && !item.mission.source.isEmpty()) {\n    source.setVisible(true);\n  }\n\n  popupMenu.show();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "282", "src_id": "M362", "code": "\nvoid drainFused() {\n  int missed = 1;\n\n  for (;;) {\n    if (disposed) {\n      return;\n    }\n\n    boolean d = done;\n    Throwable ex = error;\n\n    if (!delayError && d && ex != null) {\n      disposed = true;\n      downstream.onError(error);\n      worker.dispose();\n      return;\n    }\n\n    downstream.onNext(null);\n\n    if (d) {\n      disposed = true;\n      ex = error;\n      if (ex != null) {\n        downstream.onError(ex);\n      } else {\n        downstream.onComplete();\n      }\n      worker.dispose();\n      return;\n    }\n\n    missed = addAndGet(-missed);\n    if (missed == 0) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "283", "src_id": "M1685", "code": "\nvoid dispose(List<Disposable> set) {\n  if (set == null) {\n    return;\n  }\n\n  List<Throwable> errors = null;\n  for (Disposable o : set) {\n    try {\n      o.dispose();\n    } catch (Throwable ex) {\n      Exceptions.throwIfFatal(ex);\n      if (errors == null) {\n        errors = new ArrayList<>();\n      }\n      errors.add(ex);\n    }\n  }\n\n  if (errors != null) {\n    if (errors.size() == 1) {\n      throw ExceptionHelper.wrapOrThrow(errors.get(0));\n    }\n    throw new CompositeException(errors);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "284", "src_id": "M1503", "code": "\n@Override\npublic void onComplete() {\n  if (wip.getAndIncrement() == 0) {\n    Publisher<? extends T>[] sources = this.sources;\n    int n = sources.length;\n    int i = index;\n\n    for (;;) {\n      if (i == n) {\n        List<Throwable> list = errors;\n        if (list != null) {\n          if (list.size() == 1) {\n            downstream.onError(list.get(0));\n          } else {\n            downstream.onError(new CompositeException(list));\n          }\n        } else {\n          downstream.onComplete();\n        }\n        return;\n      }\n\n      Publisher<? extends T> p = sources[i];\n\n      if (p == null) {\n        Throwable ex = new NullPointerException(\"A Publisher entry is null\");\n        if (delayError) {\n          List<Throwable> list = errors;\n          if (list == null) {\n            list = new ArrayList<>(n - i + 1);\n            errors = list;\n          }\n          list.add(ex);\n          i++;\n          continue;\n        } else {\n          downstream.onError(ex);\n          return;\n        }\n      } else {\n        long r = produced;\n        if (r != 0L) {\n          produced = 0L;\n          produced(r);\n        }\n        p.subscribe(this);\n      }\n\n      index = ++i;\n\n      if (wip.decrementAndGet() == 0) {\n        break;\n      }\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "285", "src_id": "M470", "code": "\nvoid replay(CacheDisposable<T> consumer) {\n  // make sure there is only one replay going on at a time\n  if (consumer.getAndIncrement() != 0) {\n    return;\n  }\n\n  // see if there were more replay request in the meantime\n  int missed = 1;\n  // read out state into locals upfront to avoid being re-read due to volatile reads\n  long index = consumer.index;\n  int offset = consumer.offset;\n  Node<T> node = consumer.node;\n  Observer<? super T> downstream = consumer.downstream;\n  int capacity = capacityHint;\n\n  for (;;) {\n    // if the consumer got disposed, clear the node and quit\n    if (consumer.disposed) {\n      consumer.node = null;\n      return;\n    }\n\n    // first see if the source has terminated, read order matters!\n    boolean sourceDone = done;\n    // and if the number of items is the same as this consumer has received\n    boolean empty = size == index;\n\n    // if the source is done and we have all items so far, terminate the consumer\n    if (sourceDone && empty) {\n      // release the node object to avoid leaks through retained consumers\n      consumer.node = null;\n      // if error is not null then the source failed\n      Throwable ex = error;\n      if (ex != null) {\n        downstream.onError(ex);\n      } else {\n        downstream.onComplete();\n      }\n      return;\n    }\n\n    // there are still items not sent to the consumer\n    if (!empty) {\n      // if the offset in the current node has reached the node capacity\n      if (offset == capacity) {\n        // switch to the subsequent node\n        node = node.next;\n        // reset the in-node offset\n        offset = 0;\n      }\n\n      // emit the cached item\n      downstream.onNext(node.values[offset]);\n\n      // move the node offset forward\n      offset++;\n      // move the total consumed item count forward\n      index++;\n\n      // retry for the next item/terminal event if any\n      continue;\n    }\n\n    // commit the changed references back\n    consumer.index = index;\n    consumer.offset = offset;\n    consumer.node = node;\n    // release the changes and see if there were more replay request in the meantime\n    missed = consumer.addAndGet(-missed);\n    if (missed == 0) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "286", "src_id": "M913", "code": "\nvoid drainAsync() {\n  int missed = 1;\n\n  SimpleQueue<T> q = queue;\n  Subscriber<? super T>[] a = this.subscribers;\n  AtomicLongArray r = this.requests;\n  long[] e = this.emissions;\n  int n = e.length;\n  int idx = index;\n  int consumed = produced;\n\n  for (;;) {\n    int notReady = 0;\n\n    for (;;) {\n      if (cancelled) {\n        q.clear();\n        return;\n      }\n\n      boolean d = done;\n      if (d) {\n        Throwable ex = error;\n        if (ex != null) {\n          q.clear();\n          for (Subscriber<? super T> s : a) {\n            s.onError(ex);\n          }\n          return;\n        }\n      }\n\n      boolean empty = q.isEmpty();\n\n      if (d && empty) {\n        for (Subscriber<? super T> s : a) {\n          s.onComplete();\n        }\n        return;\n      }\n\n      if (empty) {\n        break;\n      }\n\n      long requestAtIndex = r.get(idx);\n      long emissionAtIndex = e[idx];\n      if (requestAtIndex != emissionAtIndex && r.get(n + idx) == 0) {\n        T v;\n\n        try {\n          v = q.poll();\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          upstream.cancel();\n          for (Subscriber<? super T> s : a) {\n            s.onError(ex);\n          }\n          return;\n        }\n\n        if (v == null) {\n          break;\n        }\n\n        a[idx].onNext(v);\n\n        e[idx] = emissionAtIndex + 1;\n\n        int c = ++consumed;\n        if (c == limit) {\n          consumed = 0;\n          upstream.request(c);\n        }\n        notReady = 0;\n      } else {\n        notReady++;\n      }\n\n      idx++;\n      if (idx == n) {\n        idx = 0;\n      }\n\n      if (notReady == n) {\n        break;\n      }\n    }\n\n    int w = get();\n    if (w == missed) {\n      index = idx;\n      produced = consumed;\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    } else {\n      missed = w;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "287", "src_id": "M902", "code": "\n@Override\npublic void run() {\n  int missed = 1;\n  int c = consumed;\n  SpscArrayQueue<T> q = queue;\n  Subscriber<? super T> a = downstream;\n  int lim = limit;\n\n  for (;;) {\n    long r = requested.get();\n    long e = 0L;\n\n    while (e != r) {\n      if (cancelled) {\n        q.clear();\n        return;\n      }\n\n      boolean d = done;\n\n      if (d) {\n        Throwable ex = error;\n        if (ex != null) {\n          q.clear();\n\n          a.onError(ex);\n\n          worker.dispose();\n          return;\n        }\n      }\n\n      T v = q.poll();\n\n      boolean empty = v == null;\n\n      if (d && empty) {\n        a.onComplete();\n\n        worker.dispose();\n        return;\n      }\n\n      if (empty) {\n        break;\n      }\n\n      a.onNext(v);\n\n      e++;\n\n      int p = ++c;\n      if (p == lim) {\n        c = 0;\n        upstream.request(p);\n      }\n    }\n\n    if (e == r) {\n      if (cancelled) {\n        q.clear();\n        return;\n      }\n\n      if (done) {\n        Throwable ex = error;\n        if (ex != null) {\n          q.clear();\n\n          a.onError(ex);\n\n          worker.dispose();\n          return;\n        }\n        if (q.isEmpty()) {\n          a.onComplete();\n\n          worker.dispose();\n          return;\n        }\n      }\n    }\n\n    if (e != 0L && r != Long.MAX_VALUE) {\n      requested.addAndGet(-e);\n    }\n\n    int w = get();\n    if (w == missed) {\n      consumed = c;\n      missed = addAndGet(-missed);\n      if (missed == 0) {\n        break;\n      }\n    } else {\n      missed = w;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "288", "src_id": "M1330", "code": "\n@Override\npublic void drain() {\n  if (getAndIncrement() != 0) {\n    return;\n  }\n\n  int missed = 1;\n\n  for (;;) {\n    SimpleQueue<T> q1 = first.queue;\n    SimpleQueue<T> q2 = second.queue;\n\n    if (q1 != null && q2 != null) {\n      for (;;) {\n        if (isDisposed()) {\n          first.clear();\n          second.clear();\n          return;\n        }\n\n        Throwable ex = errors.get();\n        if (ex != null) {\n          cancelAndClear();\n\n          errors.tryTerminateConsumer(downstream);\n          return;\n        }\n\n        boolean d1 = first.done;\n\n        T a = v1;\n        if (a == null) {\n          try {\n            a = q1.poll();\n          } catch (Throwable exc) {\n            Exceptions.throwIfFatal(exc);\n            cancelAndClear();\n            errors.tryAddThrowableOrReport(exc);\n            errors.tryTerminateConsumer(downstream);\n            return;\n          }\n          v1 = a;\n        }\n        boolean e1 = a == null;\n\n        boolean d2 = second.done;\n        T b = v2;\n        if (b == null) {\n          try {\n            b = q2.poll();\n          } catch (Throwable exc) {\n            Exceptions.throwIfFatal(exc);\n            cancelAndClear();\n            errors.tryAddThrowableOrReport(exc);\n            errors.tryTerminateConsumer(downstream);\n            return;\n          }\n          v2 = b;\n        }\n\n        boolean e2 = b == null;\n\n        if (d1 && d2 && e1 && e2) {\n          downstream.onSuccess(true);\n          return;\n        }\n        if ((d1 && d2) && (e1 != e2)) {\n          cancelAndClear();\n          downstream.onSuccess(false);\n          return;\n        }\n\n        if (e1 || e2) {\n          break;\n        }\n\n        boolean c;\n\n        try {\n          c = comparer.test(a, b);\n        } catch (Throwable exc) {\n          Exceptions.throwIfFatal(exc);\n          cancelAndClear();\n          errors.tryAddThrowableOrReport(exc);\n          errors.tryTerminateConsumer(downstream);\n          return;\n        }\n\n        if (!c) {\n          cancelAndClear();\n          downstream.onSuccess(false);\n          return;\n        }\n\n        v1 = null;\n        v2 = null;\n\n        first.request();\n        second.request();\n      }\n    } else {\n      if (isDisposed()) {\n        first.clear();\n        second.clear();\n        return;\n      }\n\n      Throwable ex = errors.get();\n      if (ex != null) {\n        cancelAndClear();\n\n        errors.tryTerminateConsumer(downstream);\n        return;\n      }\n    }\n\n    missed = addAndGet(-missed);\n    if (missed == 0) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "289", "src_id": "M1033", "code": "\nvoid drain() {\n  if (getAndIncrement() != 0) {\n    return;\n  }\n\n  final Subscriber<? super R> a = downstream;\n  final SimpleQueue<T> q = queue;\n  final boolean replenish = fusionMode != SYNC;\n\n  int missed = 1;\n\n  Iterator<? extends R> it = current;\n\n  for (;;) {\n    if (it == null) {\n      boolean d = done;\n\n      T t;\n\n      try {\n        t = q.poll();\n      } catch (Throwable ex) {\n        Exceptions.throwIfFatal(ex);\n        upstream.cancel();\n        ExceptionHelper.addThrowable(error, ex);\n        ex = ExceptionHelper.terminate(error);\n\n        current = null;\n        q.clear();\n\n        a.onError(ex);\n        return;\n      }\n\n      boolean empty = t == null;\n\n      if (checkTerminated(d, empty, a, q)) {\n        return;\n      }\n\n      if (t != null) {\n        Iterable<? extends R> iterable;\n\n        boolean b;\n\n        try {\n          iterable = mapper.apply(t);\n\n          it = iterable.iterator();\n\n          b = it.hasNext();\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          upstream.cancel();\n          ExceptionHelper.addThrowable(error, ex);\n          ex = ExceptionHelper.terminate(error);\n          a.onError(ex);\n          return;\n        }\n\n        if (!b) {\n          it = null;\n          consumedOne(replenish);\n          continue;\n        }\n\n        current = it;\n      }\n    }\n\n    if (it != null) {\n      long r = requested.get();\n      long e = 0L;\n\n      while (e != r) {\n        if (checkTerminated(done, false, a, q)) {\n          return;\n        }\n\n        R v;\n\n        try {\n          v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          current = null;\n          upstream.cancel();\n          ExceptionHelper.addThrowable(error, ex);\n          ex = ExceptionHelper.terminate(error);\n          a.onError(ex);\n          return;\n        }\n\n        a.onNext(v);\n\n        if (checkTerminated(done, false, a, q)) {\n          return;\n        }\n\n        e++;\n\n        boolean b;\n\n        try {\n          b = it.hasNext();\n        } catch (Throwable ex) {\n          Exceptions.throwIfFatal(ex);\n          current = null;\n          upstream.cancel();\n          ExceptionHelper.addThrowable(error, ex);\n          ex = ExceptionHelper.terminate(error);\n          a.onError(ex);\n          return;\n        }\n\n        if (!b) {\n          consumedOne(replenish);\n          it = null;\n          current = null;\n          break;\n        }\n      }\n\n      if (e == r) {\n        boolean d = done;\n        boolean empty = q.isEmpty() && it == null;\n\n        if (checkTerminated(d, empty, a, q)) {\n          return;\n        }\n      }\n\n      if (e != 0L) {\n        if (r != Long.MAX_VALUE) {\n          requested.addAndGet(-e);\n        }\n      }\n\n      if (it == null) {\n        continue;\n      }\n    }\n\n    missed = addAndGet(-missed);\n    if (missed == 0) {\n      break;\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "290", "src_id": "M807", "code": "\n@Override\npublic void subscribe(Subscriber<? super R>[] subscribers) {\n  subscribers = RxJavaPlugins.onSubscribe(this, subscribers);\n\n  if (!validate(subscribers)) {\n    return;\n  }\n\n  int n = subscribers.length;\n\n  @SuppressWarnings(\"unchecked\")\n  Subscriber<T>[] parents = new Subscriber[n];\n\n  for (int i = 0; i < n; i++) {\n    R initialValue;\n\n    try {\n      initialValue = Objects.requireNonNull(initialSupplier.get(), \"The initialSupplier returned a null value\");\n    } catch (Throwable ex) {\n      Exceptions.throwIfFatal(ex);\n      reportError(subscribers, ex);\n      return;\n    }\n\n    parents[i] = new ParallelReduceSubscriber<>(subscribers[i], initialValue, reducer);\n  }\n\n  source.subscribe(parents);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "291", "src_id": "M438", "code": "\n@Override\npublic void subscribeActual(Observer<? super T> observer) {\n  DeferredScalarDisposable<T> d = new DeferredScalarDisposable<>(observer);\n  observer.onSubscribe(d);\n\n  if (d.isDisposed()) {\n    return;\n  }\n\n  T value;\n  try {\n    value = ExceptionHelper.nullCheck(supplier.get(), \"Supplier returned a null value.\");\n  } catch (Throwable e) {\n    Exceptions.throwIfFatal(e);\n    if (!d.isDisposed()) {\n      observer.onError(e);\n    } else {\n      RxJavaPlugins.onError(e);\n    }\n    return;\n  }\n\n  d.complete(value);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "292", "src_id": "M597", "code": "\n  private List<Integer> duplicate(int totalPages, String pageOrder) {\n    final List<Integer> newPageOrder = new ArrayList<>();\n    int duplicateCount;\n    try {\n      duplicateCount = (pageOrder != null && !pageOrder.isEmpty()) ? Integer.parseInt(pageOrder.trim()) : 2;\n    } catch (NumberFormatException e) {\n      log.error(\"Invalid duplicate count specified\", e);\n      duplicateCount = 2;\n    }\n    if (duplicateCount < 1) {\n      duplicateCount = 2;\n    }\n    for (int pageNum = 0; pageNum < totalPages; pageNum++) {\n      for (int dupCount = 0; dupCount < duplicateCount; dupCount++) {\n        newPageOrder.add(pageNum);\n      }\n    }\n    return newPageOrder;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "293", "src_id": "M656", "code": "\n  private void runPipelineAgainstFiles(List<File> filesToProcess, PipelineConfig config, Path dir, Path processingDir)\n      throws IOException {\n    try {\n      final List<Resource> inputFiles = processor.generateInputFiles(filesToProcess.toArray(new File[0]));\n      if (inputFiles == null || inputFiles.isEmpty()) return;\n\n      final PipelineResult result = processor.runPipelineAgainstFiles(inputFiles, config);\n      if (result.isHasErrors()) {\n        log.error(\"Errors occurred during processing, retaining original files\");\n        moveToErrorDirectory(filesToProcess, dir);\n      } else {\n        moveAndRenameFiles(result.getOutputFiles(), config, dir);\n        deleteOriginalFiles(filesToProcess, processingDir);\n      }\n    } catch (Exception e) {\n      log.error(\"Error during processing\", e);\n      moveFilesBack(filesToProcess, processingDir);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "294", "src_id": "M32", "code": "\n  private boolean activateMachine(String licenseKey, String licenseId, String machineFingerprint, LicenseContext context)\n      throws Exception {\n    if (context.isFloatingLicense) {\n      log.info(\"Processing floating license activation. Max machines allowed: {}\", context.maxMachines);\n\n      JsonNode machinesResponse = fetchMachinesForLicense(licenseKey, licenseId);\n      if (machinesResponse != null) {\n        JsonNode machines = machinesResponse.path(\"data\");\n        int currentMachines = machines.size();\n\n        log.info(\"Current machine count: {}, Max allowed: {}\", currentMachines, context.maxMachines);\n\n        boolean isCurrentMachineActivated = false;\n        String currentMachineId = null;\n\n        for (JsonNode machine : machines) {\n          if (machineFingerprint.equals(machine.path(\"attributes\").path(\"fingerprint\").asText())) {\n            isCurrentMachineActivated = true;\n            currentMachineId = machine.path(\"id\").asText();\n            log.info(\"Current machine is already activated with ID: {}\", currentMachineId);\n            break;\n          }\n        }\n\n        if (isCurrentMachineActivated) {\n          log.info(\"Machine already activated. No action needed.\");\n          return true;\n        }\n\n        if (currentMachines >= context.maxMachines) {\n          log.info(\"Max machines reached. Deregistering oldest machine to make room for the new machine.\");\n          if (machines.size() > 0) {\n            String oldestMachineId = null;\n            java.time.Instant oldestTime = null;\n\n            for (JsonNode machine : machines) {\n              String createdStr = machine.path(\"attributes\").path(\"created\").asText(null);\n              if (createdStr != null && !createdStr.isEmpty()) {\n                try {\n                  java.time.Instant createdTime = java.time.Instant.parse(createdStr);\n                  if (oldestTime == null || createdTime.isBefore(oldestTime)) {\n                    oldestTime = createdTime;\n                    oldestMachineId = machine.path(\"id\").asText();\n                  }\n                } catch (Exception e) {\n                  log.warn(\"Could not parse creation time for machine: {}\", e.getMessage());\n                }\n              }\n            }\n\n            if (oldestMachineId == null) {\n              log.warn(\"Could not determine oldest machine by timestamp, using first machine in list\");\n              oldestMachineId = machines.path(0).path(\"id\").asText();\n            }\n\n            log.info(\"Deregistering machine with ID: {}\", oldestMachineId);\n            boolean deregistered = deregisterMachine(licenseKey, oldestMachineId);\n            if (!deregistered) {\n              log.error(\"Failed to deregister machine. Cannot proceed with activation.\");\n              return false;\n            }\n            log.info(\"Machine deregistered successfully. Proceeding with activation of new machine.\");\n          } else {\n            log.error(\"License has reached machine limit but no machines were found to deregister. This is unexpected.\");\n          }\n        }\n      }\n    }\n\n    String hostname;\n    try {\n      hostname = java.net.InetAddress.getLocalHost().getHostName();\n    } catch (Exception e) {\n      hostname = \"Unknown\";\n    }\n\n    JSONObject body = new JSONObject()\n        .put(\"data\",\n            new JSONObject()\n                .put(\"type\", \"machines\")\n                .put(\"attributes\",\n                    new JSONObject()\n                        .put(\"fingerprint\", machineFingerprint)\n                        .put(\"platform\", System.getProperty(\"os.name\"))\n                        .put(\"name\", hostname))\n                .put(\"relationships\",\n                    new JSONObject()\n                        .put(\"license\",\n                            new JSONObject()\n                                .put(\"data\",\n                                    new JSONObject()\n                                        .put(\"type\", \"licenses\")\n                                        .put(\"id\", licenseId)))));\n\n\n    HttpRequest request = HttpRequest.newBuilder()\n        .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/machines\"))\n        .header(\"Content-Type\", \"application/vnd.api+json\")\n        .header(\"Accept\", \"application/vnd.api+json\")\n        .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(body.toString()))\n        .build();\n\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.info(\"activateMachine Response body: \" + response.body());\n    if (response.statusCode() == 201) {\n      log.info(\"Machine activated successfully\");\n      return true;\n    } else {\n      log.error(\"Error activating machine. Status code: {}, error: {}\", response.statusCode(), response.body());\n      return false;\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "295", "src_id": "M625", "code": "\n  @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n  @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n  public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n    boolean readonly = true;\n    try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n      ObjectMapper objectMapper = new ObjectMapper();\n      ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n      PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n      ObjectNode metadata = objectMapper.createObjectNode();\n      ObjectNode basicInfo = objectMapper.createObjectNode();\n      ObjectNode docInfoNode = objectMapper.createObjectNode();\n      ObjectNode compliancy = objectMapper.createObjectNode();\n      ObjectNode encryption = objectMapper.createObjectNode();\n      ObjectNode other = objectMapper.createObjectNode();\n\n      metadata.put(\"Title\", info.getTitle());\n      metadata.put(\"Author\", info.getAuthor());\n      metadata.put(\"Subject\", info.getSubject());\n      metadata.put(\"Keywords\", info.getKeywords());\n      metadata.put(\"Producer\", info.getProducer());\n      metadata.put(\"Creator\", info.getCreator());\n      metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n      metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n      jsonOutput.set(\"Metadata\", metadata);\n\n      long fileSizeInBytes = inputFile.getSize();\n      basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n      String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n      String[] words = fullText.split(\"\\\\s+\");\n      int wordCount = words.length;\n      int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n      basicInfo.put(\"WordCount\", wordCount);\n      basicInfo.put(\"ParagraphCount\", paragraphCount);\n      int charCount = fullText.length();\n      basicInfo.put(\"CharacterCount\", charCount);\n\n      boolean hasCompression = false;\n      String compressionType = \"None\";\n      basicInfo.put(\"Compression\", hasCompression);\n      if (hasCompression) basicInfo.put(\"CompressionType\", compressionType);\n\n      String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n      basicInfo.put(\"Language\", language);\n      basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n      PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n      String pageMode = catalog.getPageMode().name();\n\n      docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n      docInfoNode.put(\"Trapped\", info.getTrapped());\n      docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n      PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n      ObjectNode formFieldsNode = objectMapper.createObjectNode();\n      if (acroForm != null) {\n        for (PDField field : acroForm.getFieldTree()) {\n          formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n        }\n      }\n      jsonOutput.set(\"FormFields\", formFieldsNode);\n\n      ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n      if (summaryData != null && summaryData.size() > 0) {\n        jsonOutput.set(\"SummaryData\", summaryData);\n      }\n\n      if (catalog.getNames() != null) {\n        PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n        ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n        if (efTree != null) {\n          Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n          if (efMap != null) {\n            for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n              ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n              embeddedFileNode.put(\"Name\", entry.getKey());\n              PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n              if (embeddedFile != null) {\n                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n              }\n              embeddedFilesArray.add(embeddedFileNode);\n            }\n          }\n        }\n        other.set(\"EmbeddedFiles\", embeddedFilesArray);\n      }\n\n      ArrayNode attachmentsArray = objectMapper.createArrayNode();\n      for (PDPage page : pdfBoxDoc.getPages()) {\n        for (PDAnnotation annotation : page.getAnnotations()) {\n          if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n            ObjectNode attachmentNode = objectMapper.createObjectNode();\n            attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n            attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n            attachmentsArray.add(attachmentNode);\n          }\n        }\n      }\n      other.set(\"Attachments\", attachmentsArray);\n\n      PDDocumentNameDictionary namesDict = catalog.getNames();\n      ArrayNode javascriptArray = objectMapper.createArrayNode();\n      if (namesDict != null) {\n        PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n        if (javascriptDict != null) {\n          try {\n            Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n            for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n              ObjectNode jsNode = objectMapper.createObjectNode();\n              jsNode.put(\"JS Name\", entry.getKey());\n              PDActionJavaScript jsAction = entry.getValue();\n              if (jsAction != null) {\n                String jsCodeStr = jsAction.getAction();\n                if (jsCodeStr != null) {\n                  jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                }\n              }\n              javascriptArray.add(jsNode);\n            }\n          } catch (IOException e) {\n            log.error(\"exception\", e);\n          }\n        }\n      }\n      other.set(\"JavaScript\", javascriptArray);\n\n      PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n      ArrayNode layersArray = objectMapper.createArrayNode();\n      if (ocProperties != null) {\n        for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n          ObjectNode layerNode = objectMapper.createObjectNode();\n          layerNode.put(\"Name\", ocg.getName());\n          layersArray.add(layerNode);\n        }\n      }\n      other.set(\"Layers\", layersArray);\n\n      PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n      ArrayNode structureTreeArray;\n      try {\n        if (structureTreeRoot != null) {\n          structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n          other.set(\"StructureTree\", structureTreeArray);\n        }\n      } catch (Exception e) {\n        log.error(\"exception\", e);\n      }\n\n      boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n      boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n      boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n      boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n      boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n      boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\");\n      boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\");\n\n      compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n      compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n      compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n      compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n      compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n      compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n      compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n      PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n      ArrayNode bookmarksArray = objectMapper.createArrayNode();\n      if (root != null) {\n        for (PDOutlineItem child : root.children()) {\n          addOutlinesToArray(child, bookmarksArray);\n        }\n      }\n      other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n      PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n      String xmpString = null;\n      if (pdMetadata != null) {\n        try {\n          try (COSInputStream is = pdMetadata.createInputStream()) {\n            DomXmpParser domXmpParser = new DomXmpParser();\n            XMPMetadata xmpMeta = domXmpParser.parse(is);\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            new XmpSerializer().serialize(xmpMeta, os, true);\n            xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n          }\n        } catch (XmpParsingException e) {\n          log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n          try (COSInputStream is = pdMetadata.createInputStream()) {\n            byte[] metadataBytes = is.readAllBytes();\n            xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n          }\n        } catch (IOException e) {\n          log.error(\"exception\", e);\n        }\n      }\n      other.put(\"XMPMetadata\", xmpString);\n\n      if (pdfBoxDoc.isEncrypted()) {\n        encryption.put(\"IsEncrypted\", true);\n        PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n        encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n        encryption.put(\"KeyLength\", pdfEncryption.getLength());\n      } else {\n        encryption.put(\"IsEncrypted\", false);\n      }\n\n      ObjectNode permissionsNode = objectMapper.createObjectNode();\n      setNodePermissions(pdfBoxDoc, permissionsNode);\n\n      ObjectNode pageInfoParent = objectMapper.createObjectNode();\n      for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n        ObjectNode pageInfo = objectMapper.createObjectNode();\n        PDPage page = pdfBoxDoc.getPage(pageNum);\n\n        PDRectangle mediaBox = page.getMediaBox();\n        float width = mediaBox.getWidth();\n        float height = mediaBox.getHeight();\n\n        ObjectNode sizeInfo = objectMapper.createObjectNode();\n        getDimensionInfo(sizeInfo, width, height);\n        sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n        pageInfo.set(\"Size\", sizeInfo);\n\n        pageInfo.put(\"Rotation\", page.getRotation());\n        pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n        pageInfo.put(\"MediaBox\", mediaBox.toString());\n\n        PDRectangle cropBox = page.getCropBox();\n        pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n\n        PDRectangle bleedBox = page.getBleedBox();\n        pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n\n        PDRectangle trimBox = page.getTrimBox();\n        pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n\n        PDRectangle artBox = page.getArtBox();\n        pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n\n        PDFTextStripper textStripper = new PDFTextStripper();\n        textStripper.setStartPage(pageNum + 1);\n        textStripper.setEndPage(pageNum + 1);\n        String pageText = textStripper.getText(pdfBoxDoc);\n        pageInfo.put(\"Text Characters Count\", pageText.length());\n\n        List<PDAnnotation> annotations = page.getAnnotations();\n        int subtypeCount = 0;\n        int contentsCount = 0;\n        for (PDAnnotation annotation : annotations) {\n          if (annotation.getSubtype() != null) subtypeCount++;\n          if (annotation.getContents() != null) contentsCount++;\n        }\n        ObjectNode annotationsObject = objectMapper.createObjectNode();\n        annotationsObject.put(\"AnnotationsCount\", annotations.size());\n        annotationsObject.put(\"SubtypeCount\", subtypeCount);\n        annotationsObject.put(\"ContentsCount\", contentsCount);\n        pageInfo.set(\"Annotations\", annotationsObject);\n\n        ArrayNode imagesArray = objectMapper.createArrayNode();\n        PDResources resources = page.getResources();\n        for (COSName name : resources.getXObjectNames()) {\n          PDXObject xObject = resources.getXObject(name);\n          if (xObject instanceof PDImageXObject image) {\n            ObjectNode imageNode = objectMapper.createObjectNode();\n            imageNode.put(\"Width\", image.getWidth());\n            imageNode.put(\"Height\", image.getHeight());\n            if (image.getMetadata() != null && image.getMetadata().getFile() != null\n                && image.getMetadata().getFile().getFile() != null) {\n              imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n            }\n            if (image.getColorSpace() != null) {\n              imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n            }\n            imagesArray.add(imageNode);\n          }\n        }\n        pageInfo.set(\"Images\", imagesArray);\n\n        ArrayNode linksArray = objectMapper.createArrayNode();\n        Set<String> uniqueURIs = new HashSet<>();\n        for (PDAnnotation annotation : annotations) {\n          if (annotation instanceof PDAnnotationLink linkAnnotation) {\n            if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n              String uri = uriAction.getURI();\n              uniqueURIs.add(uri);\n            }\n          }\n        }\n        for (String uri : uniqueURIs) {\n          ObjectNode linkNode = objectMapper.createObjectNode();\n          linkNode.put(\"URI\", uri);\n          linksArray.add(linkNode);\n        }\n        pageInfo.set(\"Links\", linksArray);\n\n        ArrayNode fontsArray = objectMapper.createArrayNode();\n        Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n        for (COSName fontName : resources.getFontNames()) {\n          PDFont font = resources.getFont(fontName);\n          ObjectNode fontNode = objectMapper.createObjectNode();\n\n          fontNode.put(\"IsEmbedded\", font.isEmbedded());\n          fontNode.put(\"Name\", font.getName());\n          fontNode.put(\"Subtype\", font.getType());\n\n          PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n          if (fontDescriptor != null) {\n            fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n            int flags = fontDescriptor.getFlags();\n            fontNode.put(\"IsItalic\", (flags & 1) != 0);\n            fontNode.put(\"IsBold\", (flags & 64) != 0);\n            fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n            fontNode.put(\"IsSerif\", (flags & 4) != 0);\n            fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n            fontNode.put(\"IsScript\", (flags & 16) != 0);\n            fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n            fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n            fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n          }\n\n          String uniqueKey = fontNode.toString();\n          if (uniqueFontsMap.containsKey(uniqueKey)) {\n            ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n            int count = existingFontNode.get(\"Count\").asInt() + 1;\n            existingFontNode.put(\"Count\", count);\n          } else {\n            fontNode.put(\"Count\", 1);\n            uniqueFontsMap.put(uniqueKey, fontNode);\n          }\n        }\n        for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n          fontsArray.add(uniqueFontNode);\n        }\n        pageInfo.set(\"Fonts\", fontsArray);\n\n        ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n        Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n        for (COSName name : colorSpaceNames) {\n          PDColorSpace colorSpace = resources.getColorSpace(name);\n          if (colorSpace instanceof PDICCBased iccBased) {\n            PDStream iccData = iccBased.getPDStream();\n            byte[] iccBytes = iccData.toByteArray();\n            ObjectNode iccProfileNode = objectMapper.createObjectNode();\n            iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n            colorSpacesArray.add(iccProfileNode);\n          }\n        }\n        pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n        Map<String, Integer> xObjectCountMap = new HashMap<>();\n        for (COSName name : resources.getXObjectNames()) {\n          PDXObject xObject = resources.getXObject(name);\n          String xObjectType;\n          if (xObject instanceof PDImageXObject) {\n            xObjectType = \"Image\";\n          } else if (xObject instanceof PDFormXObject) {\n            xObjectType = \"Form\";\n          } else {\n            xObjectType = \"Other\";\n          }\n          xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n        }\n        ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n        for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n          xObjectCountNode.put(entry.getKey(), entry.getValue());\n        }\n        pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n        ArrayNode multimediaArray = objectMapper.createArrayNode();\n        for (PDAnnotation annotation : annotations) {\n          if (\"RichMedia\".equals(annotation.getSubtype())) {\n            ObjectNode multimediaNode = objectMapper.createObjectNode();\n            multimediaArray.add(multimediaNode);\n          }\n        }\n        pageInfo.set(\"Multimedia\", multimediaArray);\n\n        pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n      }\n\n      jsonOutput.set(\"BasicInfo\", basicInfo);\n      jsonOutput.set(\"DocumentInfo\", docInfoNode);\n      jsonOutput.set(\"Compliancy\", compliancy);\n      jsonOutput.set(\"Encryption\", encryption);\n      jsonOutput.set(\"Permissions\", permissionsNode);\n      jsonOutput.set(\"Other\", other);\n      jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n      String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n      return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n\n    } catch (Exception e) {\n      log.error(\"exception\", e);\n    }\n    return null;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "296", "src_id": "M447", "code": "\n  private void configureCefSettings(CefAppBuilder builder) {\n    CefSettings settings = builder.getCefSettings();\n    String basePath = InstallationPathConfig.getClientWebUIPath();\n    log.info(\"basePath \" + basePath);\n\n    settings.cache_path = new File(basePath + \"cache\").getAbsolutePath();\n    settings.root_cache_path = new File(basePath + \"root_cache\").getAbsolutePath();\n    settings.log_file = new File(basePath, \"debug.log\").getAbsolutePath();\n    settings.persist_session_cookies = true;\n    settings.windowless_rendering_enabled = false;\n    settings.log_severity = CefSettings.LogSeverity.LOGSEVERITY_INFO;\n\n    builder.setAppHandler(new MavenCefAppHandlerAdapter() {\n      @Override\n      public void stateHasChanged(org.cef.CefApp.CefAppState state) {\n        log.info(\"CEF state changed: \" + state);\n        if (state == CefApp.CefAppState.TERMINATED) {\n          System.exit(0);\n        }\n      }\n    });\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "297", "src_id": "M310", "code": "\n  public static PDRectangle textToPageSize(String size) {\n    switch (size.toUpperCase()) {\n      case \"A0\":\n        return PDRectangle.A0;\n      case \"A1\":\n        return PDRectangle.A1;\n      case \"A2\":\n        return PDRectangle.A2;\n      case \"A3\":\n        return PDRectangle.A3;\n      case \"A4\":\n        return PDRectangle.A4;\n      case \"A5\":\n        return PDRectangle.A5;\n      case \"A6\":\n        return PDRectangle.A6;\n      case \"LETTER\":\n        return PDRectangle.LETTER;\n      case \"LEGAL\":\n        return PDRectangle.LEGAL;\n      default:\n        throw ExceptionUtils.createInvalidPageSizeException(size);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "298", "src_id": "M257", "code": "\n  private Object[] processArgsInPlace(Object[] originalArgs, boolean async) {\n    if (originalArgs == null || originalArgs.length == 0) return originalArgs;\n\n    for (int i = 0; i < originalArgs.length; i++) {\n      Object arg = originalArgs[i];\n      if (arg instanceof PDFFile pdfFile) {\n        if (pdfFile.getFileInput() == null && pdfFile.getFileId() != null) {\n          try {\n            log.debug(\"Using fileId {} to get file content\", pdfFile.getFileId());\n            MultipartFile file = fileStorage.retrieveFile(pdfFile.getFileId());\n            pdfFile.setFileInput(file);\n          } catch (Exception e) {\n            throw new RuntimeException(\"Failed to resolve file by ID: \" + pdfFile.getFileId(), e);\n          }\n        } else if (async && pdfFile.getFileInput() != null) {\n          try {\n            log.debug(\"Making persistent copy of uploaded file for async processing\");\n            MultipartFile originalFile = pdfFile.getFileInput();\n            String fileId = fileStorage.storeFile(originalFile);\n            pdfFile.setFileId(fileId);\n            MultipartFile persistentFile = fileStorage.retrieveFile(fileId);\n            pdfFile.setFileInput(persistentFile);\n            log.debug(\"Created persistent file copy with fileId: {}\", fileId);\n          } catch (IOException e) {\n            throw new RuntimeException(\"Failed to create persistent copy of uploaded file\", e);\n          }\n        }\n      }\n    }\n    return originalArgs;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "299", "src_id": "M184", "code": "\n  private Map<String, Object> getDockerMetrics() {\n    Map<String, Object> dockerMetrics = new HashMap<>();\n\n    dockerMetrics.put(\"docker_network_mode\", System.getenv(\"DOCKER_NETWORK_MODE\"));\n\n    String containerName = System.getenv(\"CONTAINER_NAME\");\n    if (containerName != null && !containerName.isEmpty()) {\n      dockerMetrics.put(\"container_name\", containerName);\n    }\n\n    String composeProject = System.getenv(\"COMPOSE_PROJECT_NAME\");\n    String composeService = System.getenv(\"COMPOSE_SERVICE_NAME\");\n    if (composeProject != null && composeService != null) {\n      dockerMetrics.put(\"compose_project\", composeProject);\n      dockerMetrics.put(\"compose_service\", composeService);\n    }\n\n    String k8sPodName = System.getenv(\"KUBERNETES_POD_NAME\");\n    if (k8sPodName != null) {\n      dockerMetrics.put(\"k8s_pod_name\", k8sPodName);\n      dockerMetrics.put(\"k8s_namespace\", System.getenv(\"KUBERNETES_NAMESPACE\"));\n      dockerMetrics.put(\"k8s_node_name\", System.getenv(\"KUBERNETES_NODE_NAME\"));\n    }\n\n    dockerMetrics.put(\"version_tag\", System.getenv(\"VERSION_TAG\"));\n    dockerMetrics.put(\"additional_features_off\", System.getenv(\"ADDITIONAL_FEATURES_OFF\"));\n    dockerMetrics.put(\"fat_docker\", System.getenv(\"FAT_DOCKER\"));\n\n    return dockerMetrics;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "300", "src_id": "M170", "code": "\n  private void shutdownSchedulers() {\n    log.info(\"Shutting down job queue\");\n    shuttingDown = true;\n\n    jobMap.forEach((id, job) -> {\n      if (!job.future.isDone()) {\n        job.future.completeExceptionally(new RuntimeException(\"Server shutting down, job cancelled\"));\n      }\n    });\n\n    try {\n      scheduler.shutdown();\n      if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {\n        scheduler.shutdownNow();\n      }\n\n      jobExecutor.shutdown();\n      if (!jobExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n        jobExecutor.shutdownNow();\n      }\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      scheduler.shutdownNow();\n      jobExecutor.shutdownNow();\n    }\n\n    log.info(\"Job queue shutdown complete. Stats: total={}, rejected={}\", totalQueuedJobs, rejectedJobs);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "301", "src_id": "M153", "code": "\n  private Path createTempFile(String prefix) throws IOException {\n    try {\n      TempFileManager tempFileManager = ApplicationContextProvider.getBean(TempFileManager.class);\n      if (tempFileManager != null) {\n        File file = tempFileManager.createTempFile(\".tmp\");\n        log.debug(\"Created and registered temp file via TempFileManager: {}\", file);\n        return file.toPath();\n      }\n    } catch (Exception e) {\n      log.debug(\"TempFileManager not available, falling back to standard temp file creation\");\n    }\n\n    Path file = Files.createTempFile(prefix + tempCounter.incrementAndGet() + \"-\", \".tmp\");\n    log.debug(\"Created temp file: {}\", file);\n\n    try {\n      TempFileRegistry registry = ApplicationContextProvider.getBean(TempFileRegistry.class);\n      if (registry != null) {\n        registry.register(file);\n        log.debug(\"Registered fallback temp file with registry: {}\", file);\n      }\n    } catch (Exception e) {\n      log.debug(\"Could not register fallback temp file with registry: {}\", file);\n    }\n\n    return file;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "302", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata)\n{\n    String title = pdfMetadata.getTitle();\n    pdf.getDocumentInformation().setTitle(title);\n    pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n    pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n    pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n    pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties\n                    .getPremium()\n                    .getProFeatures()\n                    .getCustomMetadata()\n                    .isAutoUpdateMetadata()\n            && runningProOrHigher)\n    {\n        author =\n                applicationProperties\n                        .getPremium()\n                        .getProFeatures()\n                        .getCustomMetadata()\n                        .getAuthor();\n\n        if (userService != null)\n        {\n            author = author.replace(\"username\", userService.getCurrentUsername());\n        }\n    }\n    pdf.getDocumentInformation().setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "303", "src_id": "M602", "code": "\n@PostMapping(value = \"/document-properties\", consumes = \"multipart/form-data\")\n@Operation(\n        summary = \"Get PDF document properties\",\n        description = \"Returns title, author, subject, etc. Input:PDF Output:JSON Type:SISO\")\npublic Map<String, String> getDocumentProperties(@ModelAttribute PDFFile file)\n        throws IOException\n{\n    // Load the document in read-only mode to prevent modifications and ensure the integrity of\n    // the original file.\n    try (PDDocument document = pdfDocumentFactory.load(file.getFileInput(), true))\n    {\n        PDDocumentInformation info = document.getDocumentInformation();\n\n        Map<String, String> properties = new HashMap<>();\n        properties.put(\"title\", info.getTitle());\n        properties.put(\"author\", info.getAuthor());\n        properties.put(\"subject\", info.getSubject());\n        properties.put(\"keywords\", info.getKeywords());\n        properties.put(\"creator\", info.getCreator());\n        properties.put(\"producer\", info.getProducer());\n        properties.put(\"creationDate\", info.getCreationDate().toString());\n        properties.put(\"modificationDate\", info.getModificationDate().toString());\n\n        return properties;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "304", "src_id": "M458", "code": "\nprivate void setupTrayIcon(Image icon)\n{\n    if (!SystemTray.isSupported())\n    {\n        log.warn(\"System tray is not supported\");\n        return;\n    }\n\n    try\n    {\n        systemTray = SystemTray.getSystemTray();\n\n        // Create popup menu\n        PopupMenu popup = new PopupMenu();\n\n        // Create menu items\n        MenuItem showItem = new MenuItem(\"Show\");\n        showItem.addActionListener(\n                e -> {\n                    frame.setVisible(true);\n                    frame.setState(Frame.NORMAL);\n                });\n\n        MenuItem exitItem = new MenuItem(\"Exit\");\n        exitItem.addActionListener(\n                e -> {\n                    cleanup();\n                    System.exit(0);\n                });\n\n        // Add menu items to popup menu\n        popup.add(showItem);\n        popup.addSeparator();\n        popup.add(exitItem);\n\n        // Create tray icon\n        trayIcon = new TrayIcon(icon, \"Stirling-PDF\", popup);\n        trayIcon.setImageAutoSize(true);\n\n        // Add double-click behavior\n        trayIcon.addActionListener(\n                e -> {\n                    frame.setVisible(true);\n                    frame.setState(Frame.NORMAL);\n                });\n\n        // Add tray icon to system tray\n        systemTray.add(trayIcon);\n\n        // Modify frame behavior to minimize to tray\n        frame.addWindowStateListener(\n                new WindowStateListener()\n                {\n                    public void windowStateChanged(WindowEvent e)\n                    {\n                        if (e.getNewState() == Frame.ICONIFIED)\n                        {\n                            frame.setVisible(false);\n                        }\n                    }\n                });\n\n    }\n    catch (AWTException e)\n    {\n        log.error(\"Error setting up system tray icon\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "305", "src_id": "M477", "code": "\nprivate void handleSplitByDocCount(\n        PDDocument sourceDocument,\n        int documentCount,\n        ZipOutputStream zipOut,\n        String baseFilename)\n        throws IOException\n{\n    log.debug(\"Starting handleSplitByDocCount with documentCount={}\", documentCount);\n\n    int totalPageCount = sourceDocument.getNumberOfPages();\n    log.debug(\"Total pages in source document: {}\", totalPageCount);\n\n    int pagesPerDocument = totalPageCount / documentCount;\n    int extraPages = totalPageCount % documentCount;\n    log.debug(\"Pages per document: {}, Extra pages: {}\", pagesPerDocument, extraPages);\n\n    int currentPageIndex = 0;\n    int fileIndex = 1;\n\n    for (int i = 0; i < documentCount; i++)\n    {\n        log.debug(\"Creating document {} of {}\", i + 1, documentCount);\n        PDDocument currentDoc = null;\n\n        try\n        {\n            currentDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(sourceDocument);\n            log.debug(\"Successfully created document {} of {}\", i + 1, documentCount);\n        }\n        catch (Exception e)\n        {\n            log.error(\"Error creating document {} of {}\", i + 1, documentCount, e);\n            throw ExceptionUtils.createFileProcessingException(\"split\", e);\n        }\n\n        int pagesToAdd = pagesPerDocument + (i < extraPages ? 1 : 0);\n        log.debug(\"Adding {} pages to document {}\", pagesToAdd, i + 1);\n\n        for (int j = 0; j < pagesToAdd; j++)\n        {\n            try\n            {\n                log.debug(\n                        \"Adding page {} (index {}) to document {}\",\n                        j + 1,\n                        currentPageIndex,\n                        i + 1);\n                currentDoc.addPage(sourceDocument.getPage(currentPageIndex));\n                log.debug(\"Successfully added page {} to document {}\", j + 1, i + 1);\n                currentPageIndex++;\n            }\n            catch (Exception e)\n            {\n                log.error(\"Error adding page {} to document {}\", j + 1, i + 1, e);\n                throw ExceptionUtils.createFileProcessingException(\"split\", e);\n            }\n        }\n\n        try\n        {\n            log.debug(\"Saving document {} with {} pages\", i + 1, pagesToAdd);\n            saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n            log.debug(\"Successfully saved document {}\", i + 1);\n        }\n        catch (Exception e)\n        {\n            log.error(\"Error saving document {}\", i + 1, e);\n            throw e;\n        }\n    }\n\n    log.debug(\"Completed handleSplitByDocCount with {} documents created\", documentCount);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "306", "src_id": "M577", "code": "\nprivate void processWithTesseract(\n        List<String> selectedLanguages, String ocrType, Path tempInputFile, Path tempOutputFile)\n        throws IOException, InterruptedException\n{\n    // Create temp directory for Tesseract processing\n    try (TempDirectory tempDir = new TempDirectory(tempFileManager))\n    {\n        File tempOutputDir = new File(tempDir.getPath().toFile(), \"output\");\n        File tempImagesDir = new File(tempDir.getPath().toFile(), \"images\");\n        File finalOutputFile = new File(tempDir.getPath().toFile(), \"final_output.pdf\");\n\n        // Create directories\n        tempOutputDir.mkdirs();\n        tempImagesDir.mkdirs();\n\n        PDFMergerUtility merger = new PDFMergerUtility();\n        merger.setDestinationFileName(finalOutputFile.toString());\n\n        try (PDDocument document = pdfDocumentFactory.load(tempInputFile.toFile()))\n        {\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            int pageCount = document.getNumberOfPages();\n\n            for (int pageNum = 0; pageNum < pageCount; pageNum++)\n            {\n                PDPage page = document.getPage(pageNum);\n                boolean hasText = false;\n\n                // Check for existing text\n                try (PDDocument tempDoc = new PDDocument())\n                {\n                    tempDoc.addPage(page);\n                    PDFTextStripper stripper = new PDFTextStripper();\n                    hasText = !stripper.getText(tempDoc).trim().isEmpty();\n                }\n\n                boolean shouldOcr =\n                        switch (ocrType)\n                        {\n                            case \"skip-text\" -> !hasText;\n                            case \"force-ocr\" -> true;\n                            default -> true;\n                        };\n\n                File pageOutputPath =\n                        new File(tempOutputDir, String.format(\"page_%d.pdf\", pageNum));\n\n                if (shouldOcr)\n                {\n                    // Convert page to image\n                    BufferedImage image = pdfRenderer.renderImageWithDPI(pageNum, 300);\n                    File imagePath =\n                            new File(tempImagesDir, String.format(\"page_%d.png\", pageNum));\n                    ImageIO.write(image, \"png\", imagePath);\n\n                    // Build OCR command\n                    List<String> command = new ArrayList<>();\n                    command.add(\"tesseract\");\n                    command.add(imagePath.toString());\n                    command.add(\n                            new File(tempOutputDir, String.format(\"page_%d\", pageNum))\n                                    .toString());\n                    command.add(\"-l\");\n                    command.add(String.join(\"+\", selectedLanguages));\n                    command.add(\"pdf\"); // Always output PDF\n\n                    ProcessExecutorResult result =\n                            ProcessExecutor.getInstance(ProcessExecutor.Processes.TESSERACT)\n                                    .runCommandWithOutputHandling(command);\n\n                    if (result.getRc() != 0)\n                    {\n                        throw ExceptionUtils.createRuntimeException(\n                                \"error.commandFailed\",\n                                \"{0} command failed with exit code: {1}\",\n                                null,\n                                \"Tesseract\",\n                                result.getRc());\n                    }\n\n                    // Add OCR'd PDF to merger\n                    merger.addSource(pageOutputPath);\n                }\n                else\n                {\n                    // Save original page without OCR\n                    try (PDDocument pageDoc = new PDDocument())\n                    {\n                        pageDoc.addPage(page);\n                        pageDoc.save(pageOutputPath);\n                        merger.addSource(pageOutputPath);\n                    }\n                }\n            }\n        }\n\n        // Merge all pages into final PDF\n        merger.mergeDocuments(null);\n\n        // Copy final output to the expected location\n        Files.copy(\n                finalOutputFile.toPath(),\n                tempOutputFile,\n                java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "307", "src_id": "M522", "code": "\n@PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\")\n@Operation(\n        summary = \"Auto split PDF pages into separate documents\",\n        description =\n                \"This endpoint accepts a PDF file, scans each page for a specific QR code, and\"\n                        + \" splits the document at the QR code boundaries. The output is a zip file\"\n                        + \" containing each separate PDF document. Input:PDF Output:ZIP-PDF\"\n                        + \" Type:SISO\")\npublic ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request)\n        throws IOException\n{\n    MultipartFile file = request.getFileInput();\n    boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n\n    PDDocument document = null;\n    List<PDDocument> splitDocuments = new ArrayList<>();\n    Path zipFile = null;\n    byte[] data = null;\n\n    try\n    {\n        document = pdfDocumentFactory.load(file.getInputStream());\n        PDFRenderer pdfRenderer = new PDFRenderer(document);\n        pdfRenderer.setSubsamplingAllowed(true);\n\n        for (int page = 0; page < document.getNumberOfPages(); ++page)\n        {\n            BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n            String result = decodeQRCode(bim);\n\n            boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n            log.debug(\"detected qr code {}, code is vale={}\", result, isValidQrCode);\n            if (isValidQrCode && page != 0)\n            {\n                splitDocuments.add(new PDDocument());\n            }\n\n            if (!splitDocuments.isEmpty() && !isValidQrCode)\n            {\n                splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n            }\n            else if (page == 0)\n            {\n                PDDocument firstDocument = new PDDocument();\n                firstDocument.addPage(document.getPage(page));\n                splitDocuments.add(firstDocument);\n            }\n\n            // If duplexMode is true and current page is a divider, then skip next page\n            if (duplexMode && isValidQrCode)\n            {\n                page++;\n            }\n        }\n\n        // Remove split documents that have no pages\n        splitDocuments.removeIf(pdDocument -> pdDocument.getNumberOfPages() == 0);\n\n        zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n        String filename =\n                Filenames.toSimpleFileName(file.getOriginalFilename())\n                        .replaceFirst(\"[.][^.]+$\", \"\");\n\n        try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile)))\n        {\n            for (int i = 0; i < splitDocuments.size(); i++)\n            {\n                String fileName = filename + \"_\" + (i + 1) + \".pdf\";\n                PDDocument splitDocument = splitDocuments.get(i);\n\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                splitDocument.save(baos);\n                byte[] pdf = baos.toByteArray();\n\n                ZipEntry pdfEntry = new ZipEntry(fileName);\n                zipOut.putNextEntry(pdfEntry);\n                zipOut.write(pdf);\n                zipOut.closeEntry();\n            }\n        }\n\n        data = Files.readAllBytes(zipFile);\n\n        return WebResponseUtils.bytesToWebResponse(\n                data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM);\n    }\n    catch (Exception e)\n    {\n        log.error(\"Error in auto split\", e);\n        throw e;\n    }\n    finally\n    {\n        // Clean up resources\n        if (document != null)\n        {\n            try\n            {\n                document.close();\n            }\n            catch (IOException e)\n            {\n                log.error(\"Error closing main PDDocument\", e);\n            }\n        }\n\n        for (PDDocument splitDoc : splitDocuments)\n        {\n            try\n            {\n                splitDoc.close();\n            }\n            catch (IOException e)\n            {\n                log.error(\"Error closing split PDDocument\", e);\n            }\n        }\n\n        if (zipFile != null)\n        {\n            try\n            {\n                Files.deleteIfExists(zipFile);\n            }\n            catch (IOException e)\n            {\n                log.error(\"Error deleting temporary zip file\", e);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "308", "src_id": "M443", "code": "\nprivate void checkAndRefreshExplorer()\n{\n    if (!IS_WINDOWS)\n    {\n        return;\n    }\n\n    if (timeAt90Percent == -1)\n    {\n        timeAt90Percent = System.currentTimeMillis();\n        stuckTimer =\n                new Timer(\n                        1000,\n                        e -> {\n                            long currentTime = System.currentTimeMillis();\n                            if (currentTime - timeAt90Percent > stuckThreshold)\n                            {\n                                try\n                                {\n                                    log.debug(\n                                            \"Attempting Windows explorer refresh due to 90% stuck state\");\n                                    String currentDir = System.getProperty(\"user.dir\");\n\n                                    // Store current explorer PIDs before we start new one\n                                    Set<String> existingPids = new HashSet<>();\n                                    ProcessBuilder listExplorer =\n                                            new ProcessBuilder(\n                                                    \"cmd\",\n                                                    \"/c\",\n                                                    \"wmic\",\n                                                    \"process\",\n                                                    \"where\",\n                                                    \"name='explorer.exe'\",\n                                                    \"get\",\n                                                    \"ProcessId\",\n                                                    \"/format:csv\");\n                                    Process process = listExplorer.start();\n                                    BufferedReader reader =\n                                            new BufferedReader(\n                                                    new InputStreamReader(\n                                                            process.getInputStream()));\n                                    String line;\n                                    while ((line =\n                                                    BoundedLineReader.readLine(\n                                                            reader, 5_000_000))\n                                            != null)\n                                    {\n                                        if (line.matches(\".*\\\\d+.*\"))\n                                        {\n                                            String[] parts = line.trim().split(\",\");\n                                            if (parts.length >= 2)\n                                            {\n                                                existingPids.add(\n                                                        parts[parts.length - 1].trim());\n                                            }\n                                        }\n                                    }\n                                    process.waitFor(2, TimeUnit.SECONDS);\n\n                                    // Start new explorer\n                                    ProcessBuilder pb =\n                                            new ProcessBuilder(\n                                                    \"cmd\",\n                                                    \"/c\",\n                                                    \"start\",\n                                                    \"/min\",\n                                                    \"/b\",\n                                                    \"explorer.exe\",\n                                                    currentDir);\n                                    pb.redirectErrorStream(true);\n                                    explorerProcess = pb.start();\n\n                                    // Schedule cleanup\n                                    Timer cleanupTimer =\n                                            new Timer(\n                                                    2000,\n                                                    cleanup -> {\n                                                        try\n                                                        {\n                                                            // Find new explorer processes\n                                                            ProcessBuilder findNewExplorer =\n                                                                    new ProcessBuilder(\n                                                                            \"cmd\",\n                                                                            \"/c\",\n                                                                            \"wmic\",\n                                                                            \"process\",\n                                                                            \"where\",\n                                                                            \"name='explorer.exe'\",\n                                                                            \"get\",\n                                                                            \"ProcessId\",\n                                                                            \"/format:csv\");\n                                                            Process newProcess =\n                                                                    findNewExplorer.start();\n                                                            BufferedReader newReader =\n                                                                    new BufferedReader(\n                                                                            new InputStreamReader(\n                                                                                    newProcess\n                                                                                            .getInputStream()));\n                                                            String newLine;\n                                                            while ((newLine =\n                                                                            BoundedLineReader\n                                                                                    .readLine(\n                                                                                            newReader,\n                                                                                            5_000_000))\n                                                                    != null)\n                                                            {\n                                                                if (newLine.matches(\n                                                                        \".*\\\\d+.*\"))\n                                                                {\n                                                                    String[] parts =\n                                                                            newLine.trim()\n                                                                                    .split(\",\");\n                                                                    if (parts.length >= 2)\n                                                                    {\n                                                                        String pid =\n                                                                                parts[\n                                                                                        parts.length\n                                                                                                - 1]\n                                                                                        .trim();\n                                                                        if (!existingPids\n                                                                                .contains(\n                                                                                        pid))\n                                                                        {\n                                                                            log.debug(\n                                                                                    \"Found new explorer.exe with PID: \"\n                                                                                            + pid);\n                                                                            ProcessBuilder\n                                                                                    killProcess =\n                                                                                            new ProcessBuilder(\n                                                                                                    \"taskkill\",\n                                                                                                    \"/PID\",\n                                                                                                    pid,\n                                                                                                    \"/F\");\n                                                                            killProcess\n                                                                                    .redirectErrorStream(\n                                                                                            true);\n                                                                            Process killResult =\n                                                                                    killProcess\n                                                                                            .start();\n                                                                            killResult.waitFor(\n                                                                                    2,\n                                                                                    TimeUnit\n                                                                                            .SECONDS);\n                                                                            log.debug(\n                                                                                    \"Explorer process terminated: \"\n                                                                                            + pid);\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                            newProcess.waitFor(\n                                                                    2, TimeUnit.SECONDS);\n                                                        }\n                                                        catch (Exception ex)\n                                                        {\n                                                            log.error(\n                                                                    \"Error cleaning up Windows explorer process\",\n                                                                    ex);\n                                                        }\n                                                    });\n                                    cleanupTimer.setRepeats(false);\n                                    cleanupTimer.start();\n                                    stuckTimer.stop();\n                                }\n                                catch (Exception ex)\n                                {\n                                    log.error(\"Error refreshing Windows explorer\", ex);\n                                }\n                            }\n                        });\n        stuckTimer.setRepeats(true);\n        stuckTimer.start();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "309", "src_id": "M408", "code": "\nprivate static Path unzipAndGetMainHtml(byte[] fileBytes) throws IOException\n{\n    Path tempDirectory = Files.createTempDirectory(\"unzipped_\");\n    try (ZipInputStream zipIn =\n            ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(fileBytes)))\n    {\n        ZipEntry entry = zipIn.getNextEntry();\n        while (entry != null)\n        {\n            Path filePath = tempDirectory.resolve(sanitizeZipFilename(entry.getName()));\n            if (entry.isDirectory())\n            {\n                Files.createDirectories(filePath); // Explicitly create the directory structure\n            }\n            else\n            {\n                Files.createDirectories(\n                        filePath.getParent()); // Create parent directories if they don't exist\n                Files.copy(zipIn, filePath);\n            }\n            zipIn.closeEntry();\n            entry = zipIn.getNextEntry();\n        }\n    }\n\n    // Search for the main HTML file.\n    try (Stream<Path> walk = Files.walk(tempDirectory))\n    {\n        List<Path> htmlFiles = walk.filter(file -> file.toString().endsWith(\".html\")).toList();\n\n        if (htmlFiles.isEmpty())\n        {\n            throw new IOException(\"No HTML files found in the unzipped directory.\");\n        }\n\n        // Prioritize 'index.html' if it exists, otherwise use the first .html file\n        for (Path htmlFile : htmlFiles)\n        {\n            if (\"index.html\".equals(htmlFile.getFileName().toString()))\n            {\n                return htmlFile;\n            }\n        }\n\n        return htmlFiles.get(0);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "310", "src_id": "M197", "code": "\n@Scheduled(\n        fixedDelayString =\n                \"#{applicationProperties.system.tempFileManagement.cleanupIntervalMinutes}\",\n        timeUnit = TimeUnit.MINUTES)\npublic void scheduledCleanup()\n{\n    log.info(\"Running scheduled temporary file cleanup\");\n    long maxAgeMillis = tempFileManager.getMaxAgeMillis();\n\n    // Clean up registered temp files (managed by TempFileRegistry)\n    int registeredDeletedCount = tempFileManager.cleanupOldTempFiles(maxAgeMillis);\n    log.info(\"Cleaned up {} registered temporary files\", registeredDeletedCount);\n\n    // Clean up registered temp directories\n    int directoriesDeletedCount = 0;\n    for (Path directory : registry.getTempDirectories())\n    {\n        try\n        {\n            if (Files.exists(directory))\n            {\n                GeneralUtils.deleteDirectory(directory);\n                directoriesDeletedCount++;\n                log.debug(\"Cleaned up temporary directory: {}\", directory);\n            }\n        }\n        catch (IOException e)\n        {\n            log.warn(\"Failed to clean up temporary directory: {}\", directory, e);\n        }\n    }\n\n    // Clean up PDFBox cache file\n    cleanupPDFBoxCache();\n\n    // Clean up unregistered temp files based on our cleanup strategy\n    boolean containerMode = isContainerMode();\n    int unregisteredDeletedCount = cleanupUnregisteredFiles(containerMode, true, maxAgeMillis);\n\n    if (registeredDeletedCount > 0\n            || unregisteredDeletedCount > 0\n            || directoriesDeletedCount > 0)\n    {\n        log.info(\n                \"Scheduled cleanup complete. Deleted {} registered files, {} unregistered files, {} directories\",\n                registeredDeletedCount,\n                unregisteredDeletedCount,\n                directoriesDeletedCount);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "311", "src_id": "M102", "code": "\n@Override\nprotected boolean shouldNotFilter(HttpServletRequest request) throws ServletException\n{\n    String uri = request.getRequestURI();\n    String contextPath = request.getContextPath();\n    String[] permitAllPatterns = {\n        contextPath + \"/login\",\n        contextPath + \"/register\",\n        contextPath + \"/error\",\n        contextPath + \"/images/\",\n        contextPath + \"/public/\",\n        contextPath + \"/css/\",\n        contextPath + \"/fonts/\",\n        contextPath + \"/js/\",\n        contextPath + \"/pdfjs/\",\n        contextPath + \"/pdfjs-legacy/\",\n        contextPath + \"/api/v1/info/status\",\n        contextPath + \"/site.webmanifest\"\n    };\n\n    for (String pattern : permitAllPatterns)\n    {\n        if (uri.startsWith(pattern)\n                || uri.endsWith(\".svg\")\n                || uri.endsWith(\".png\")\n                || uri.endsWith(\".ico\"))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "312", "src_id": "M542", "code": "\n  private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n      Map<String, Object> info = entry.getValue();\n\n      TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n      TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n      Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n      table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n          .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n          .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n              label(\"\" + info.get(LoggerHelper.classLoader)))\n          .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n              label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n          .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n              label(\"\" + info.get(LoggerHelper.level)));\n      if (info.get(LoggerHelper.effectiveLevel) != null) {\n        table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n            label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n      }\n\n      if (info.get(LoggerHelper.config) != null) {\n        table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n            label(\"\" + info.get(LoggerHelper.config)));\n      }\n\n      table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n          label(\"\" + info.get(LoggerHelper.additivity)))\n          .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n              label(\"\" + info.get(LoggerHelper.codeSource)));\n\n      @SuppressWarnings(\"unchecked\")\n      List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n      if (appenders != null && !appenders.isEmpty()) {\n\n        for (Map<String, Object> appenderInfo : appenders) {\n          Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n          appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n              label(\"\" + appenderInfo.get(LoggerHelper.name)));\n          appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n          appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n          appendersTable.row(label(LoggerHelper.classLoaderHash),\n              label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n          if (appenderInfo.get(LoggerHelper.file) != null) {\n            appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n          }\n          if (appenderInfo.get(LoggerHelper.target) != null) {\n            appendersTable.row(label(LoggerHelper.target),\n                label(\"\" + appenderInfo.get(LoggerHelper.target)));\n          }\n          if (appenderInfo.get(LoggerHelper.blocking) != null) {\n            appendersTable.row(label(LoggerHelper.blocking),\n                label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n          }\n          if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n            appendersTable.row(label(LoggerHelper.appenderRef),\n                label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n          }\n        }\n\n        table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n      }\n\n      sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "313", "src_id": "M1126", "code": "\n  private ApiResponse processInitSessionRequest(ApiRequest apiRequest) throws ApiException {\n    ApiResponse response = new ApiResponse();\n\n    // create session\n    Session session = sessionManager.createSession();\n    if (session != null) {\n\n      // Result Distributor\n      SharingResultDistributorImpl resultDistributor = new SharingResultDistributorImpl(session);\n      // create consumer\n      ResultConsumer resultConsumer = new ResultConsumerImpl();\n      resultDistributor.addConsumer(resultConsumer);\n      session.setResultDistributor(resultDistributor);\n\n      resultDistributor.appendResult(new MessageModel(\"Welcome to arthas!\"));\n\n      // welcome message\n      WelcomeModel welcomeModel = new WelcomeModel();\n      welcomeModel.setVersion(ArthasBanner.version());\n      welcomeModel.setWiki(ArthasBanner.wiki());\n      welcomeModel.setTutorials(ArthasBanner.tutorials());\n      welcomeModel.setMainClass(PidUtils.mainClass());\n      welcomeModel.setPid(PidUtils.currentPid());\n      welcomeModel.setTime(DateUtils.getCurrentDateTime());\n      resultDistributor.appendResult(welcomeModel);\n\n      // allow input\n      updateSessionInputStatus(session, InputStatus.ALLOW_INPUT);\n\n      response.setSessionId(session.getSessionId())\n          .setConsumerId(resultConsumer.getConsumerId())\n          .setState(ApiState.SUCCEEDED);\n    } else {\n      throw new ApiException(\"create api session failed\");\n    }\n    return response;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "314", "src_id": "M1157", "code": "\n  private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n    DefaultFullHttpResponse fullResp = null;\n    InputStream in = null;\n    try {\n      URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n      if (res != null) {\n        fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n        in = res.openStream();\n        byte[] tmp = new byte[256];\n        for (int l = 0; l != -1; l = in.read(tmp)) {\n          fullResp.content().writeBytes(tmp, 0, l);\n        }\n        int li = path.lastIndexOf('.');\n        if (li != -1 && li != path.length() - 1) {\n          String ext = path.substring(li + 1);\n          String contentType;\n          if (\"html\".equals(ext)) {\n            contentType = \"text/html\";\n          } else if (\"js\".equals(ext)) {\n            contentType = \"application/javascript\";\n          } else if (\"css\".equals(ext)) {\n            contentType = \"text/css\";\n          } else {\n            contentType = null;\n          }\n\n          if (contentType != null) {\n            fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n          }\n        }\n      }\n    } finally {\n      IOUtils.close(in);\n    }\n    return fullResp;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "315", "src_id": "M515", "code": "\n  @Override\n  public void draw(CommandProcess process, StackModel result) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(ThreadUtil.getThreadTitle(result)).append(\"\\n\");\n\n    StackTraceElement[] stackTraceElements = result.getStackTrace();\n    StackTraceElement locationStackTraceElement = stackTraceElements[0];\n    String locationString = String.format(\"    @%s.%s()\", locationStackTraceElement.getClassName(),\n        locationStackTraceElement.getMethodName());\n    sb.append(locationString).append(\"\\n\");\n\n    int skip = 1;\n    for (int index = skip; index < stackTraceElements.length; index++) {\n      StackTraceElement ste = stackTraceElements[index];\n      sb.append(\"        at \")\n          .append(ste.getClassName())\n          .append(\".\")\n          .append(ste.getMethodName())\n          .append(\"(\")\n          .append(ste.getFileName())\n          .append(\":\")\n          .append(ste.getLineNumber())\n          .append(\")\\n\");\n    }\n    process.write(\"ts=\" + DateUtils.formatDateTime(result.getTs()) + \";\" + sb.toString() + \"\\n\");\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "316", "src_id": "M1130", "code": "\n  private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n    boolean oneTimeAccess = false;\n    if (session.get(ONETIME_SESSION_KEY) != null) {\n      oneTimeAccess = true;\n    }\n\n    try {\n      String commandLine = apiRequest.getCommand();\n      Map<String, Object> body = new TreeMap<String, Object>();\n      body.put(\"command\", commandLine);\n\n      ApiResponse response = new ApiResponse();\n      response.setSessionId(session.getSessionId())\n          .setBody(body);\n\n      if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED)\n            .setMessage(\"Another command is executing.\");\n        return response;\n      }\n\n      int lock = session.getLock();\n      PackingResultDistributor packingResultDistributor = null;\n      Job job = null;\n      try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n          response.setState(ApiState.REFUSED)\n              .setMessage(\"Another job is running.\");\n          logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n          return response;\n        }\n\n        packingResultDistributor = new PackingResultDistributorImpl(session);\n        // distribute result message both to origin session channel and request channel by CompositeResultDistributor\n        // ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n        job = this.createJob(commandLine, session, packingResultDistributor);\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n        job.run();\n\n      } catch (Throwable e) {\n        logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n        return response;\n      } finally {\n        if (session.getLock() == lock) {\n          session.unLock();\n        }\n      }\n\n      // wait for job completed or timeout\n      Integer timeout = apiRequest.getExecTimeout();\n      if (timeout == null || timeout <= 0) {\n        timeout = DEFAULT_EXEC_TIMEOUT;\n      }\n      boolean timeExpired = !waitForJob(job, timeout);\n      if (timeExpired) {\n        logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n        job.interrupt();\n        response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n      } else {\n        response.setState(ApiState.SUCCEEDED);\n      }\n\n      // packing results\n      body.put(\"jobId\", job.id());\n      body.put(\"jobStatus\", job.status());\n      body.put(\"timeExpired\", timeExpired);\n      if (timeExpired) {\n        body.put(\"timeout\", timeout);\n      }\n      body.put(\"results\", packingResultDistributor.getResults());\n\n      response.setSessionId(session.getSessionId())\n          // .setConsumerId(consumerId)\n          .setBody(body);\n      return response;\n    } finally {\n      if (oneTimeAccess) {\n        sessionManager.removeSession(session.getSessionId());\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "317", "src_id": "M536", "code": "\n  public static String drawThreadInfo(List<ThreadVO> threads, int width, int height) {\n    TableElement table = new TableElement(1, 6, 3, 2, 2, 2, 2, 2, 2, 2)\n        .overflow(Overflow.HIDDEN)\n        .rightCellPadding(1);\n\n    // Header\n    table.add(\n        new RowElement()\n            .style(Decoration.bold.fg(Color.black).bg(Color.white))\n            .add(\n                \"ID\",\n                \"NAME\",\n                \"GROUP\",\n                \"PRIORITY\",\n                \"STATE\",\n                \"%CPU\",\n                \"DELTA_TIME\",\n                \"TIME\",\n                \"INTERRUPTED\",\n                \"DAEMON\"\n            )\n    );\n\n    int count = 0;\n    for (ThreadVO thread : threads) {\n      Color color = colorMapping.get(thread.getState());\n      String time = formatTimeMills(thread.getTime());\n      String deltaTime = formatTimeMillsToSeconds(thread.getDeltaTime());\n      double cpu = thread.getCpu();\n\n      LabelElement daemonLabel = new LabelElement(thread.isDaemon());\n      if (!thread.isDaemon()) {\n        daemonLabel.setStyle(Style.style(Color.magenta));\n      }\n      LabelElement stateElement;\n      if (thread.getState() != null) {\n        stateElement = new LabelElement(thread.getState()).style(color.fg());\n      } else {\n        stateElement = new LabelElement(\"-\");\n      }\n      table.row(\n          new LabelElement(thread.getId()),\n          new LabelElement(thread.getName()),\n          new LabelElement(thread.getGroup() != null ? thread.getGroup() : \"-\"),\n          new LabelElement(thread.getPriority()),\n          stateElement,\n          new LabelElement(cpu),\n          new LabelElement(deltaTime),\n          new LabelElement(time),\n          new LabelElement(thread.isInterrupted()),\n          daemonLabel\n      );\n      if (++count >= height) {\n        break;\n      }\n    }\n    return RenderUtil.render(table, width, height);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "318", "src_id": "M1125", "code": "\n  private ApiResponse dispatchRequest(ApiAction action, ApiRequest apiRequest, Session session) throws ApiException {\n    switch (action) {\n      case EXEC:\n        return processExecRequest(apiRequest, session);\n      case ASYNC_EXEC:\n        return processAsyncExecRequest(apiRequest, session);\n      case INTERRUPT_JOB:\n        return processInterruptJob(apiRequest, session);\n      case PULL_RESULTS:\n        return processPullResultsRequest(apiRequest, session);\n      case SESSION_INFO:\n        return processSessionInfoRequest(apiRequest, session);\n      case JOIN_SESSION:\n        return processJoinSessionRequest(apiRequest, session);\n      case CLOSE_SESSION:\n        return processCloseSessionRequest(apiRequest, session);\n      case INIT_SESSION:\n        break;\n    }\n    return null;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "319", "src_id": "M1470", "code": "\npublic static Pair<String, NavigableMap<Integer, Integer>> decompileWithMappings(String classFilePath,\n    String methodName, boolean hideUnicode, boolean printLineNumber) {\n\n  final StringBuilder sb = new StringBuilder(8192);\n  final NavigableMap<Integer, Integer> lineMapping = new TreeMap<>();\n\n  final OutputSinkFactory mySink = new OutputSinkFactory() {\n    @Override\n    public List<SinkClass> getSupportedSinks(SinkType sinkType, Collection<SinkClass> collection) {\n      return Arrays.asList(SinkClass.STRING, SinkClass.DECOMPILED, SinkClass.DECOMPILED_MULTIVER,\n          SinkClass.EXCEPTION_MESSAGE, SinkClass.LINE_NUMBER_MAPPING);\n    }\n\n    @Override\n    public <T> Sink<T> getSink(final SinkType sinkType, final SinkClass sinkClass) {\n      return new Sink<T>() {\n        @Override\n        public void write(T sinkable) {\n          // skip message like: Analysing type demo.MathGame\n          if (sinkType == SinkType.PROGRESS) return;\n\n          if (sinkType == SinkType.LINENUMBER) {\n            final LineNumberMapping mapping = (LineNumberMapping) sinkable;\n            final NavigableMap<Integer, Integer> classFileMappings = mapping.getClassFileMappings();\n            final NavigableMap<Integer, Integer> mappings = mapping.getMappings();\n            if (classFileMappings != null && mappings != null) {\n              for (Entry<Integer, Integer> entry : mappings.entrySet()) {\n                final Integer srcLineNumber = classFileMappings.get(entry.getKey());\n                lineMapping.put(entry.getValue(), srcLineNumber);\n              }\n            }\n            return;\n          }\n          sb.append(sinkable);\n        }\n      };\n    }\n  };\n\n  final HashMap<String, String> options = new HashMap<>();\n  /**\n   * @see org.benf.cfr.reader.util.MiscConstants.Version.getVersion() Currently,\n   *      the cfr version is wrong. so disable show cfr version.\n   */\n  options.put(\"showversion\", \"false\");\n  options.put(\"hideutf\", String.valueOf(hideUnicode));\n  options.put(\"trackbytecodeloc\", \"true\");\n  if (!StringUtils.isBlank(methodName)) {\n    options.put(\"methodname\", methodName);\n  }\n\n  final CfrDriver driver = new CfrDriver.Builder().withOptions(options).withOutputSink(mySink).build();\n  final List<String> toAnalyse = new ArrayList<>();\n  toAnalyse.add(classFilePath);\n  driver.analyse(toAnalyse);\n\n  String resultCode = sb.toString();\n  if (printLineNumber && !lineMapping.isEmpty()) {\n    resultCode = addLineNumber(resultCode, lineMapping);\n  }\n\n  return Pair.make(resultCode, lineMapping);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "320", "src_id": "M1355", "code": "\npublic static String nullSafeToString(char[] array) {\n  if (array == null) return \"null\";\n  final int length = array.length;\n  if (length == 0) return \"{}\";\n\n  final StringBuilder sb = new StringBuilder(\"{\");\n  for (int i = 0; i < length; ++i) {\n    if (i > 0) sb.append(\", \");\n    sb.append('\\'').append(array[i]).append('\\'');\n  }\n  sb.append('}');\n  return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "321", "src_id": "M454", "code": "\nprivate void renderObject(Object obj, int deep, int expand, final StringBuilder buf) throws ObjectTooLargeException {\n  if (obj == null) {\n    appendStringBuilder(buf, \"null\");\n  } else {\n    final Class<?> clazz = obj.getClass();\n    final String className = clazz.getSimpleName();\n\n    // 7种基础类型,直接输出@类型[值]\n    if (Integer.class.isInstance(obj)\n        || Long.class.isInstance(obj)\n        || Float.class.isInstance(obj)\n        || Double.class.isInstance(obj)\n        //                    || Character.class.isInstance(obj)\n        || Short.class.isInstance(obj)\n        || Byte.class.isInstance(obj)\n        || Boolean.class.isInstance(obj)) {\n      appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n    }\n\n    // Char要特殊处理,因为有不可见字符的因素\n    else if (Character.class.isInstance(obj)) {\n      final Character c = (Character) obj;\n\n      // ASCII的可见字符\n      if (c >= 32 && c <= 126) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n      }\n\n      // ASCII的控制字符\n      else if (ASCII_MAP.containsKey((byte) c.charValue())) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, ASCII_MAP.get((byte) c.charValue())));\n      }\n\n      // 超过ASCII的编码范围\n      else {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n      }\n    }\n\n    // 字符串类型单独处理\n    else if (String.class.isInstance(obj)) {\n      appendStringBuilder(buf, \"@\");\n      appendStringBuilder(buf, className);\n      appendStringBuilder(buf, \"[\");\n      for (Character c : ((String) obj).toCharArray()) {\n        switch (c) {\n          case '\\n':\n            appendStringBuilder(buf, \"\\\\n\");\n            break;\n          case '\\r':\n            appendStringBuilder(buf, \"\\\\r\");\n            break;\n          default:\n            appendStringBuilder(buf, c.toString());\n        }\n      }\n      appendStringBuilder(buf, \"]\");\n    }\n\n    // 集合类输出\n    else if (Collection.class.isInstance(obj)) {\n      @SuppressWarnings(\"unchecked\")\n      final Collection<Object> collection = (Collection<Object>) obj;\n\n      // 非根节点或空集合只展示摘要信息\n      if (!isExpand(deep, expand) || collection.isEmpty()) {\n        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, collection.isEmpty(), collection.size()));\n      } else {\n        // 展开展示\n        appendStringBuilder(buf, format(\"@%s[\", className));\n        for (Object e : collection) {\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n          renderObject(e, deep + 1, expand, buf);\n          appendStringBuilder(buf, \",\");\n        }\n        appendStringBuilder(buf, \"\\n\");\n        for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n        appendStringBuilder(buf, \"]\");\n      }\n    }\n\n    // Map类输出\n    else if (Map.class.isInstance(obj)) {\n      @SuppressWarnings(\"unchecked\")\n      final Map<Object, Object> map = (Map<Object, Object>) obj;\n\n      // 非根节点或空集合只展示摘要信息\n      if (!isExpand(deep, expand) || map.isEmpty()) {\n        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, map.isEmpty(), map.size()));\n      } else {\n        appendStringBuilder(buf, format(\"@%s[\", className));\n        for (Map.Entry<Object, Object> entry : map.entrySet()) {\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n          renderObject(entry.getKey(), deep + 1, expand, buf);\n          appendStringBuilder(buf, \":\");\n          renderObject(entry.getValue(), deep + 1, expand, buf);\n          appendStringBuilder(buf, \",\");\n        }\n        appendStringBuilder(buf, \"\\n\");\n        for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n        appendStringBuilder(buf, \"]\");\n      }\n    }\n\n    // 数组类输出\n    else if (obj.getClass().isArray()) {\n      final String typeName = obj.getClass().getSimpleName();\n\n      // int[]\n      if (typeName.equals(\"int[]\")) {\n        final int[] arrays = (int[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (int e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // long[]\n      else if (typeName.equals(\"long[]\")) {\n        final long[] arrays = (long[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (long e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // short[]\n      else if (typeName.equals(\"short[]\")) {\n        final short[] arrays = (short[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (short e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // float[]\n      else if (typeName.equals(\"float[]\")) {\n        final float[] arrays = (float[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (float e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // double[]\n      else if (typeName.equals(\"double[]\")) {\n        final double[] arrays = (double[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (double e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // boolean[]\n      else if (typeName.equals(\"boolean[]\")) {\n        final boolean[] arrays = (boolean[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (boolean e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // char[]\n      else if (typeName.equals(\"char[]\")) {\n        final char[] arrays = (char[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (char e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // byte[]\n      else if (typeName.equals(\"byte[]\")) {\n        final byte[] arrays = (byte[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (byte e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n      // Object[]\n      else {\n        final Object[] arrays = (Object[]) obj;\n        if (!isExpand(deep, expand) || arrays.length == 0) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          for (Object e : arrays) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n    }\n\n    // Throwable输出\n    else if (Throwable.class.isInstance(obj)) {\n      if (!isExpand(deep, expand)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n      } else {\n        final Throwable throwable = (Throwable) obj;\n        final StringWriter sw = new StringWriter();\n        final PrintWriter pw = new PrintWriter(sw);\n        throwable.printStackTrace(pw);\n        appendStringBuilder(buf, sw.toString());\n      }\n    }\n\n    // Date输出\n    else if (Date.class.isInstance(obj)) {\n      appendStringBuilder(buf, format(\"@%s[%s]\", className, new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\").format(obj)));\n    }\n\n    else if (object instanceof Enum<?>) {\n      appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n    }\n\n    // 普通Object输出\n    else {\n      if (!isExpand(deep, expand)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n      } else {\n        appendStringBuilder(buf, format(\"@%s[\", className));\n        final List<Field> fields;\n        Class<?> objClass = obj.getClass();\n        if (GlobalOptions.printParentFields) {\n          fields = new ArrayList<>();\n          // 当父类为null的时候说明到达了最上层的父类(Object类).\n          while (objClass != null) {\n            fields.addAll(Arrays.asList(objClass.getDeclaredFields()));\n            objClass = objClass.getSuperclass();\n          }\n        } else {\n          fields = new ArrayList<>(Arrays.asList(objClass.getDeclaredFields()));\n        }\n\n        for (Field field : fields) {\n          field.setAccessible(true);\n          try {\n            final Object value = field.get(obj);\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) appendStringBuilder(buf, TAB);\n            appendStringBuilder(buf, field.getName());\n            appendStringBuilder(buf, \"=\");\n            renderObject(value, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          } catch (ObjectTooLargeException t) {\n            buf.append(\"...\");\n            break;\n          } catch (Throwable t) {\n            // ignore\n          }\n        }\n        appendStringBuilder(buf, \"\\n\");\n        for (int i = 0; i < deep; i++) appendStringBuilder(buf, TAB);\n        appendStringBuilder(buf, \"]\");\n      }\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "322", "src_id": "M140", "code": "\nvoid _processDo(int option) throws IOException {\n  if (debugoptions) {\n    System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n  }\n\n  if (__notifhand != null) {\n    __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n  }\n\n  boolean acceptNewState = false;\n\n  /* open TelnetOptionHandler functionality (start)*/\n  if (optionHandlers[option] != null) {\n    acceptNewState = optionHandlers[option].getAcceptLocal();\n  } else {\n    /* open TelnetOptionHandler functionality (end)*/\n    /* TERMINAL-TYPE option (start)*/\n    if (option == TERMINAL_TYPE) {\n      if ((terminalType != null) && (terminalType.length() > 0)) {\n        acceptNewState = true;\n      }\n    }\n    /* TERMINAL-TYPE option (end)*/\n    /* open TelnetOptionHandler functionality (start)*/\n  }\n  /* open TelnetOptionHandler functionality (end)*/\n\n  if (_willResponse[option] > 0) {\n    --_willResponse[option];\n    if (_willResponse[option] > 0 && _stateIsWill(option)) {\n      --_willResponse[option];\n    }\n  }\n\n  if (_willResponse[option] == 0) {\n    if (_requestedWont(option)) {\n      switch (option) {\n        default:\n          break;\n      }\n\n      if (acceptNewState) {\n        _setWantWill(option);\n        _sendWill(option);\n      } else {\n        ++_willResponse[option];\n        _sendWont(option);\n      }\n    } else {\n      // Other end has acknowledged option.\n      switch (option) {\n        default:\n          break;\n      }\n    }\n  }\n\n  _setWill(option);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "323", "src_id": "M927", "code": "\npublic static Map<String, Map<String, Object>> getLoggers(String name, boolean includeNoAppender) {\n  final Map<String, Map<String, Object>> loggerInfoMap = new HashMap<>();\n  if (!Log4j) return loggerInfoMap;\n\n  if (name != null && !name.trim().isEmpty()) {\n    final Logger logger = LogManager.getLoggerRepository().exists(name);\n    if (logger != null) {\n      loggerInfoMap.put(name, doGetLoggerInfo(logger));\n    }\n  } else {\n    // 获取所有logger时，如果没有appender则忽略\n    @SuppressWarnings(\"unchecked\")\n    final Enumeration<Logger> loggers = LogManager.getLoggerRepository().getCurrentLoggers();\n\n    if (loggers != null) {\n      while (loggers.hasMoreElements()) {\n        final Logger logger = loggers.nextElement();\n        final Map<String, Object> info = doGetLoggerInfo(logger);\n        if (!includeNoAppender) {\n          final List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n          if (appenders != null && !appenders.isEmpty()) {\n            loggerInfoMap.put(logger.getName(), info);\n          }\n        } else {\n          loggerInfoMap.put(logger.getName(), info);\n        }\n      }\n    }\n\n    final Logger root = LogManager.getLoggerRepository().getRootLogger();\n    if (root != null) {\n      final Map<String, Object> info = doGetLoggerInfo(root);\n      if (!includeNoAppender) {\n        final List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n          loggerInfoMap.put(root.getName(), info);\n        }\n      } else {\n        loggerInfoMap.put(root.getName(), info);\n      }\n    }\n  }\n\n  return loggerInfoMap;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "324", "src_id": "M464", "code": "\nprivate void initCommands(List<String> disabledCommands) {\n  final List<Class<? extends AnnotatedCommand>> commandClassList = new ArrayList<>(33);\n  commandClassList.add(HelpCommand.class);\n  commandClassList.add(AuthCommand.class);\n  commandClassList.add(KeymapCommand.class);\n  commandClassList.add(SearchClassCommand.class);\n  commandClassList.add(SearchMethodCommand.class);\n  commandClassList.add(ClassLoaderCommand.class);\n  commandClassList.add(JadCommand.class);\n  commandClassList.add(GetStaticCommand.class);\n  commandClassList.add(MonitorCommand.class);\n  commandClassList.add(StackCommand.class);\n  commandClassList.add(ThreadCommand.class);\n  commandClassList.add(TraceCommand.class);\n  commandClassList.add(WatchCommand.class);\n  commandClassList.add(TimeTunnelCommand.class);\n  commandClassList.add(JvmCommand.class);\n  commandClassList.add(MemoryCommand.class);\n  commandClassList.add(PerfCounterCommand.class);\n  // commandClassList.add(GroovyScriptCommand.class);\n  commandClassList.add(OgnlCommand.class);\n  commandClassList.add(MemoryCompilerCommand.class);\n  commandClassList.add(RedefineCommand.class);\n  commandClassList.add(RetransformCommand.class);\n  commandClassList.add(DashboardCommand.class);\n  commandClassList.add(DumpClassCommand.class);\n  commandClassList.add(HeapDumpCommand.class);\n  commandClassList.add(JulyCommand.class);\n  commandClassList.add(ThanksCommand.class);\n  commandClassList.add(OptionsCommand.class);\n  commandClassList.add(ClsCommand.class);\n  commandClassList.add(ResetCommand.class);\n  commandClassList.add(VersionCommand.class);\n  commandClassList.add(SessionCommand.class);\n  commandClassList.add(SystemPropertyCommand.class);\n  commandClassList.add(SystemEnvCommand.class);\n  commandClassList.add(VMOptionCommand.class);\n  commandClassList.add(LoggerCommand.class);\n  commandClassList.add(HistoryCommand.class);\n  commandClassList.add(CatCommand.class);\n  commandClassList.add(Base64Command.class);\n  commandClassList.add(EchoCommand.class);\n  commandClassList.add(PwdCommand.class);\n  commandClassList.add(MBeanCommand.class);\n  commandClassList.add(GrepCommand.class);\n  commandClassList.add(TeeCommand.class);\n  commandClassList.add(ProfilerCommand.class);\n  commandClassList.add(VmToolCommand.class);\n  commandClassList.add(StopCommand.class);\n  try {\n    if (ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Recording.class\") != null) {\n      commandClassList.add(JFRCommand.class);\n    }\n  } catch (Throwable e) {\n    logger.error(\"This jdk version not support jfr command\");\n  }\n\n  for (final Class<? extends AnnotatedCommand> clazz : commandClassList) {\n    final Name name = clazz.getAnnotation(Name.class);\n    if (name != null && name.value() != null) {\n      if (disabledCommands.contains(name.value())) continue;\n    }\n    commands.add(Command.create(clazz));\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "325", "src_id": "M453", "code": "\n@Override\npublic String draw() {\n  final StringBuilder buf = new StringBuilder();\n  try {\n    if (GlobalOptions.isUsingJson) {\n      return JSON.toJSONString(object, JSONWriter.Feature.IgnoreErrorGetter);\n    }\n    renderObject(object, 0, deep, buf);\n    return buf.toString();\n  } catch (ObjectTooLargeException e) {\n    buf.append(\" Object size exceeds size limit: \")\n        .append(maxObjectLength)\n        .append(\", try to specify -M size_limit in your command, check the help command for more.\");\n    return buf.toString();\n  } catch (Throwable t) {\n    logger.error(\"ObjectView draw error, object class: {}\", object.getClass(), t);\n    return \"ERROR DATA!!! object class: \" + object.getClass() + \", exception class: \" + t.getClass()\n        + \", exception message: \" + t.getMessage();\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "326", "src_id": "M375", "code": "\npublic static Map<String, String> removeDashKey(Map<String, String> map) {\n  final Map<String, String> result = new HashMap<>(map.size());\n\n  for (Entry<String, String> entry : map.entrySet()) {\n    String key = entry.getKey();\n\n    if (key.contains(\"-\")) {\n      final StringBuilder sb = new StringBuilder(key.length());\n      for (int i = 0; i < key.length(); i++) {\n        if (key.charAt(i) == '-' && (i + 1 < key.length()) && Character.isAlphabetic(key.charAt(i + 1))) {\n          ++i;\n          final char upperChar = Character.toUpperCase(key.charAt(i));\n          sb.append(upperChar);\n        } else {\n          sb.append(key.charAt(i));\n        }\n      }\n      key = sb.toString();\n    }\n\n    result.put(key, entry.getValue());\n  }\n\n  return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "327", "src_id": "M306", "code": "\nfinal void advance() {\n  if (nextEntry != null && (nextEntry = nextEntry.next) != null) return;\n\n  while (nextTableIndex >= 0) {\n    if ((nextEntry = currentTable[nextTableIndex--]) != null) return;\n  }\n\n  while (nextSegmentIndex >= 0) {\n    final Segment<K, V> seg = segments[nextSegmentIndex--];\n    if (seg.count != 0) {\n      currentTable = seg.table;\n      for (int j = currentTable.length - 1; j >= 0; --j) {\n        if ((nextEntry = currentTable[j]) != null) {\n          nextTableIndex = j - 1;\n          return;\n        }\n      }\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "328", "src_id": "M1338", "code": "\npublic static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n  for (Enum<?> candidate : enumValues) {\n    if (caseSensitive) {\n      if (candidate.toString().equals(constant)) return true;\n    } else {\n      if (candidate.toString().equalsIgnoreCase(constant)) return true;\n    }\n  }\n  return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "329", "src_id": "M185", "code": "\npublic synchronized long size() throws IOException {\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"size() called\");\n    }\n\n    if (this.endtime >= src.getEndTime()) {\n        return src.size() - skippedAtStart;\n    }\n\n    long pos = in.getPosition();\n\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"saved pos () = \" + pos);\n    }\n\n    LogEntry e;\n\n    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);\n    in.seek(lastseg.getBytes());\n    buf = \"\"; // clear the buf so we don't get something we read before we sought\n    // number of entries skipped to get to the end of the iterator, less the number skipped to get to the start\n    long count = lastseg.getEntriesSkipped() - skippedAtStart;\n\n    while ((e = readNextEntry()) != null) {\n        if (LOG.isTraceEnabled()) {\n            // LOG.trace(e);\n        }\n        if (e.getTimestamp() > this.endtime) {\n            break;\n        }\n        count++;\n    }\n    in.seek(pos);\n    buf = \"\";\n\n    if (LOG.isTraceEnabled()) {\n        LOG.trace(\"size() = \" + count);\n    }\n\n    return count;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "330", "src_id": "M1043", "code": "\nvoid handleWrite(SelectionKey k) throws IOException {\n    if (outgoingBuffers.isEmpty()) {\n        return;\n    }\n\n    /*\n     * This is going to reset the buffer position to 0 and the\n     * limit to the size of the buffer, so that we can fill it\n     * with data from the non-direct buffers that we need to\n     * send.\n     */\n    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n    if (directBuffer == null) {\n        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n        // Use gathered write call. This updates the positions of the\n        // byte buffers to reflect the bytes that were written out.\n        sock.write(outgoingBuffers.toArray(bufferList));\n\n        // Remove the buffers that we have sent\n        ByteBuffer bb;\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (bb.remaining() > 0) {\n                break;\n            }\n            outgoingBuffers.remove();\n        }\n    } else {\n        directBuffer.clear();\n\n        for (ByteBuffer b : outgoingBuffers) {\n            if (directBuffer.remaining() < b.remaining()) {\n                /*\n                 * When we call put later, if the directBuffer is to\n                 * small to hold everything, nothing will be copied,\n                 * so we've got to slice the buffer if it's too big.\n                 */\n                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n            }\n            /*\n             * put() is going to modify the positions of both\n             * buffers, put we don't want to change the position of\n             * the source buffers (we'll do that after the send, if\n             * needed), so we save and reset the position after the\n             * copy\n             */\n            int p = b.position();\n            directBuffer.put(b);\n            b.position(p);\n            if (directBuffer.remaining() == 0) {\n                break;\n            }\n        }\n        /*\n         * Do the flip: limit becomes position, position gets set to\n         * 0. This sets us up for the write.\n         */\n        directBuffer.flip();\n\n        int sent = sock.write(directBuffer);\n\n        ByteBuffer bb;\n\n        // Remove the buffers that we have sent\n        while ((bb = outgoingBuffers.peek()) != null) {\n            if (bb == ServerCnxnFactory.closeConn) {\n                throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            }\n            if (bb == packetSentinel) {\n                packetSent();\n            }\n            if (sent < bb.remaining()) {\n                /*\n                 * We only partially sent this buffer, so we update\n                 * the position and exit the loop.\n                 */\n                bb.position(bb.position() + sent);\n                break;\n            }\n            /* We've sent the whole buffer, so drop the buffer */\n            sent -= bb.remaining();\n            outgoingBuffers.remove();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "331", "src_id": "M1150", "code": "\nprivate void select() {\n    try {\n        selector.select();\n\n        Set<SelectionKey> selected = selector.selectedKeys();\n        ArrayList<SelectionKey> selectedList = new ArrayList<>(selected);\n        Collections.shuffle(selectedList);\n        Iterator<SelectionKey> selectedKeys = selectedList.iterator();\n        while (!stopped && selectedKeys.hasNext()) {\n            SelectionKey key = selectedKeys.next();\n            selected.remove(key);\n\n            if (!key.isValid()) {\n                cleanupSelectionKey(key);\n                continue;\n            }\n            if (key.isReadable() || key.isWritable()) {\n                handleIO(key);\n            } else {\n                LOG.warn(\"Unexpected ops in select {}\", key.readyOps());\n            }\n        }\n    } catch (IOException e) {\n        LOG.warn(\"Ignoring IOException while selecting\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "332", "src_id": "M520", "code": "\n@Override\npublic void close() throws IOException {\n    boolean triedToClose = false;\n    boolean success = false;\n    try {\n        flush();\n        ((FileOutputStream) out).getFD().sync();\n\n        triedToClose = true;\n        super.close();\n        success = true;\n    } finally {\n        if (success) {\n            boolean renamed = tmpFile.renameTo(origFile);\n            if (!renamed) {\n                // On windows, renameTo does not replace.\n                if (!origFile.delete() || !tmpFile.renameTo(origFile)) {\n                    throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                }\n            }\n        } else {\n            if (!triedToClose) {\n                // If we failed when flushing, try to close it to not leak an FD\n                IOUtils.closeStream(out);\n            }\n            // close wasn't successful, try to delete the tmp file\n            if (!tmpFile.delete()) {\n                LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "333", "src_id": "M1154", "code": "\npublic void doWork() throws InterruptedException {\n    if (!key.isValid()) {\n        selectorThread.cleanupSelectionKey(key);\n        return;\n    }\n\n    if (key.isReadable() || key.isWritable()) {\n        cnxn.doIO(key);\n\n        // Check if we shutdown or doIO() closed this connection\n        if (stopped) {\n            cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            return;\n        }\n        if (!key.isValid()) {\n            selectorThread.cleanupSelectionKey(key);\n            return;\n        }\n        touchCnxn(cnxn);\n    }\n\n    // Mark this connection as once again ready for selection\n    cnxn.enableSelectable();\n    // Push an update request on the queue to resume selecting\n    // on the current set of interest ops, which may have changed\n    // as a result of the I/O operations we just performed.\n    if (!selectorThread.addInterestOpsUpdateRequest(key)) {\n        cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "334", "src_id": "M290", "code": "\npublic String getStatus(String name, long timeout) throws KeeperException, InterruptedException {\n    Stat stat = new Stat();\n    byte[] data = null;\n    long endTime = Time.currentElapsedTime() + timeout;\n    KeeperException lastException = null;\n    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n        try {\n            data = zk.getData(reportsNode + '/' + name, false, stat);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n            }\n            lastException = null;\n            break;\n        } catch (ConnectionLossException e) {\n            lastException = e;\n        } catch (NoNodeException e) {\n            final Object eventObj = new Object();\n            synchronized (eventObj) {\n                // wait for the node to appear\n                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {\n                    public void process(WatchedEvent event) {\n                        synchronized (eventObj) {\n                            eventObj.notifyAll();\n                        }\n                    }\n                });\n                if (eStat == null) {\n                    eventObj.wait(endTime - Time.currentElapsedTime());\n                }\n            }\n            lastException = e;\n        }\n    }\n    if (lastException != null) {\n        throw lastException;\n    }\n    return new String(data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "335", "src_id": "M196", "code": "\npublic static void main(String[] args) throws IOException {\n    MergedLogSource source = new MergedLogSource(args);\n\n    PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n    PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n    PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n    PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n    LogIterator iter;\n\n    System.out.println(source);\n    iter = source.iterator();\n    long currentms = 0;\n    long currentsec = 0;\n    long currentmin = 0;\n    long currenthour = 0;\n    Set<Long> zxids_ms = new HashSet<Long>();\n    long zxid_sec = 0;\n    long zxid_min = 0;\n    long zxid_hour = 0;\n\n    while (iter.hasNext()) {\n        LogEntry e = iter.next();\n        TransactionEntry cxn = (TransactionEntry) e;\n\n        long ms = cxn.getTimestamp();\n        long sec = ms / MS_PER_SEC;\n        long min = ms / MS_PER_MIN;\n        long hour = ms / MS_PER_HOUR;\n\n        if (currentms != ms && currentms != 0) {\n            ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n\n            zxid_sec += zxids_ms.size();\n            zxid_min += zxids_ms.size();\n            zxid_hour += zxids_ms.size();\n            zxids_ms.clear();\n        }\n\n        if (currentsec != sec && currentsec != 0) {\n            ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n\n            zxid_sec = 0;\n        }\n\n        if (currentmin != min && currentmin != 0) {\n            ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n\n            zxid_min = 0;\n        }\n\n        if (currenthour != hour && currenthour != 0) {\n            ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n\n            zxid_hour = 0;\n        }\n\n        currentms = ms;\n        currentsec = sec;\n        currentmin = min;\n        currenthour = hour;\n\n        zxids_ms.add(cxn.getZxid());\n    }\n\n    iter.close();\n    ps_ms.close();\n    ps_sec.close();\n    ps_min.close();\n    ps_hour.close();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "336", "src_id": "M1149", "code": "\npublic void run() {\n    try {\n        while (!stopped) {\n            try {\n                select();\n                processAcceptedConnections();\n                processInterestOpsUpdateRequests();\n            } catch (RuntimeException e) {\n                LOG.warn(\"Ignoring unexpected runtime exception\", e);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring unexpected exception\", e);\n            }\n        }\n\n        // Close connections still pending on the selector. Any others\n        // with in-flight work, let drain out of the work queue.\n        for (SelectionKey key : selector.keys()) {\n            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n            if (cnxn.isSelectable()) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            }\n            cleanupSelectionKey(key);\n        }\n        SocketChannel accepted;\n        while ((accepted = acceptedQueue.poll()) != null) {\n            fastCloseSock(accepted);\n        }\n        updateQueue.clear();\n    } finally {\n        closeSelector();\n        // This will wake up the accept thread and the other selector\n        // threads, and tell the worker thread pool to begin shutdown.\n        NIOServerCnxnFactory.this.stop();\n        LOG.info(\"selector thread exited run method\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "337", "src_id": "M219", "code": "\npublic static synchronized ZooKeeper getClient(String contextPath, String session, int expireTime)\n        throws IOException {\n    final String connectionId = concat(contextPath, session);\n\n    ZooKeeper zk = zkMap.get(connectionId);\n    if (zk == null) {\n        if (LOG.isInfoEnabled()) {\n            LOG.info(String.format(\"creating new connection for : '%s'\", connectionId));\n        }\n        Endpoint e = contextMap.get(contextPath);\n        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n            zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n        }\n\n        zkMap.put(connectionId, zk);\n\n        // a session should automatically expire after an amount of time\n        if (session != null) {\n            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n        }\n    }\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "338", "src_id": "M852", "code": "\npublic InputStream getView(final int size) {\n    if (view == null) {\n        view = new InputStream() {\n            @Override\n            public int read() throws IOException {\n                if (viewSize < 1) {\n                    return -1;\n                }\n                final int res = DataReader.this.read();\n                if (res > 0) {\n                    viewSize--;\n                }\n                return res;\n            }\n\n            @Override\n            public int read(final byte[] buffer) throws IOException {\n                return read(buffer, 0, buffer.length);\n            }\n\n            @Override\n            public int read(final byte[] buffer, final int offset, final int count)\n                    throws IOException {\n                if (viewSize < 1) {\n                    return -1;\n                }\n\n                final int res =\n                        DataReader.this.read(buffer, offset, Math.min(viewSize, count));\n                viewSize -= res;\n\n                return res;\n            }\n\n            @Override\n            public long skip(final long amount) throws IOException {\n                if (viewSize < 1) {\n                    return 0;\n                }\n                final int res = (int) DataReader.this.skipBytes(Math.min(amount, viewSize));\n                viewSize -= res;\n\n                return res;\n            }\n\n            @Override\n            public int available() {\n                return viewSize;\n            }\n\n            @Override\n            public void close() {\n                viewSize = 0;\n            }\n\n            @Override\n            public boolean markSupported() {\n                return false;\n            }\n        };\n    }\n    viewSize = size;\n\n    return view;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "339", "src_id": "M1086", "code": "\nprivate ArrayList<Object> getSpecialItems() {\n    synchronized (DownloadManager.this) {\n        ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n        ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n        List<Mission> remove = new ArrayList<>(hidden);\n\n        // hide missions (if required)\n        remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n        int fakeTotal = pending.size();\n        if (fakeTotal > 0) {\n            fakeTotal++;\n        }\n\n        fakeTotal += finished.size();\n        if (finished.size() > 0) {\n            fakeTotal++;\n        }\n\n        ArrayList<Object> list = new ArrayList<>(fakeTotal);\n        if (pending.size() > 0) {\n            list.add(PENDING);\n            list.addAll(pending);\n        }\n        if (finished.size() > 0) {\n            list.add(FINISHED);\n            list.addAll(finished);\n        }\n\n        hasFinished = finished.size() > 0;\n\n        return list;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "340", "src_id": "M1066", "code": "\nprivate void loadPendingMissions(Context ctx) {\n    File[] subs = mPendingMissionsDir.listFiles();\n\n    if (subs == null) {\n        Log.e(TAG, \"listFiles() returned null\");\n        return;\n    }\n    if (subs.length < 1) {\n        return;\n    }\n    if (DEBUG) {\n        Log.d(\n                TAG,\n                \"Loading pending downloads from directory: \"\n                        + mPendingMissionsDir.getAbsolutePath());\n    }\n\n    File tempDir = pickAvailableTemporalDir(ctx);\n    Log.i(TAG, \"using '\" + tempDir + \"' as temporal directory\");\n\n    for (File sub : subs) {\n        if (!sub.isFile()) {\n            continue;\n        }\n        if (sub.getName().equals(\".tmp\")) {\n            continue;\n        }\n\n        DownloadMission mis = Utility.readFromFile(sub);\n        if (mis == null || mis.isFinished() || mis.hasInvalidStorage()) {\n            //noinspection ResultOfMethodCallIgnored\n            sub.delete();\n            continue;\n        }\n\n        mis.threads = new Thread[0];\n\n        boolean exists;\n        try {\n            mis.storage = StoredFileHelper.deserialize(mis.storage, ctx);\n            exists = !mis.storage.isInvalid() && mis.storage.existsAsFile();\n        } catch (Exception ex) {\n            Log.e(TAG, \"Failed to load the file source of \" + mis.storage.toString(), ex);\n            mis.storage.invalidate();\n            exists = false;\n        }\n\n        if (mis.isPsRunning()) {\n            if (mis.psAlgorithm.worksOnSameFile) {\n                // Incomplete post-processing results in a corrupted download file\n                // because the selected algorithm works on the same file to save space.\n                // the file will be deleted if the storage API\n                // is Java IO (avoid showing the \"Save as...\" dialog)\n                if (exists && mis.storage.isDirect() && !mis.storage.delete()) {\n                    Log.w(TAG, \"Unable to delete incomplete download file: \" + sub.getPath());\n                }\n            }\n\n            mis.psState = 0;\n            mis.errCode = DownloadMission.ERROR_POSTPROCESSING_STOPPED;\n        } else if (!exists) {\n            tryRecover(mis);\n\n            // the progress is lost, reset mission state\n            if (mis.isInitialized()) {\n                mis.resetState(true, true, DownloadMission.ERROR_PROGRESS_LOST);\n            }\n        }\n\n        if (mis.psAlgorithm != null) {\n            mis.psAlgorithm.cleanupTemporalDir();\n            mis.psAlgorithm.setTemporalDir(tempDir);\n        }\n\n        mis.metadata = sub;\n        mis.maxRetry = mPrefMaxRetry;\n        mis.mHandler = mHandler;\n\n        mMissionsPending.add(mis);\n    }\n\n    if (mMissionsPending.size() > 1) {\n        Collections.sort(mMissionsPending, Comparator.comparingLong(Mission::getTimestamp));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "341", "src_id": "M1055", "code": "\npublic void updateMission(Mission mission) {\n    ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n    SQLiteDatabase database = getWritableDatabase();\n    String ts = String.valueOf(mission.timestamp);\n\n    int rowsAffected;\n\n    if (mission instanceof FinishedMission) {\n        if (mission.storage.isInvalid()) {\n            rowsAffected =\n                    database.update(\n                            FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new String[] {ts});\n        } else {\n            rowsAffected =\n                    database.update(\n                            FINISHED_TABLE_NAME,\n                            values,\n                            KEY_PATH + \" = ?\",\n                            new String[] {mission.storage.getUri().toString()});\n        }\n    } else {\n        throw new UnsupportedOperationException(\"DownloadMission\");\n    }\n\n    if (rowsAffected != 1) {\n        Log.e(\n                \"FinishedMissionStore\",\n                \"Expected 1 row to be affected by update but got \" + rowsAffected);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "342", "src_id": "M1058", "code": "\nprivate void startMission(Intent intent) {\n    String[] urls = intent.getStringArrayExtra(EXTRA_URLS);\n    Uri path = IntentCompat.getParcelableExtra(intent, EXTRA_PATH, Uri.class);\n    Uri parentPath = IntentCompat.getParcelableExtra(intent, EXTRA_PARENT_PATH, Uri.class);\n    int threads = intent.getIntExtra(EXTRA_THREADS, 1);\n    char kind = intent.getCharExtra(EXTRA_KIND, '?');\n    String psName = intent.getStringExtra(EXTRA_POSTPROCESSING_NAME);\n    String[] psArgs = intent.getStringArrayExtra(EXTRA_POSTPROCESSING_ARGS);\n    String source = intent.getStringExtra(EXTRA_SOURCE);\n    long nearLength = intent.getLongExtra(EXTRA_NEAR_LENGTH, 0);\n    String tag = intent.getStringExtra(EXTRA_STORAGE_TAG);\n    final var recovery =\n            IntentCompat.getParcelableArrayListExtra(\n                    intent, EXTRA_RECOVERY_INFO, MissionRecoveryInfo.class);\n    Objects.requireNonNull(recovery);\n\n    StoredFileHelper storage;\n    try {\n        storage = new StoredFileHelper(this, parentPath, path, tag);\n    } catch (IOException e) {\n        throw new RuntimeException(e); // this never should happen\n    }\n\n    Postprocessing ps;\n    if (psName == null) {\n        ps = null;\n    } else {\n        ps = Postprocessing.getAlgorithm(psName, psArgs);\n    }\n\n    final DownloadMission mission = new DownloadMission(urls, storage, kind, ps);\n    mission.threadCount = threads;\n    mission.source = source;\n    mission.nearLength = nearLength;\n    mission.recoveryInfo = recovery.toArray(new MissionRecoveryInfo[0]);\n\n    if (ps != null) {\n        ps.setTemporalDir(DownloadManager.pickAvailableTemporalDir(this));\n    }\n\n    // first check the actual network status\n    handleConnectivityState(true);\n\n    mManager.startMission(mission);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "343", "src_id": "M1024", "code": "\n@Override\npublic void run() {\n    if (mMission.current > 0) {\n        mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n    }\n\n    int retryCount = 0;\n    int httpCode = 204;\n\n    while (true) {\n        try {\n            if (mMission.blocks == null && mMission.current == 0) {\n                // calculate the whole size of the mission\n                long finalLength = 0;\n                long lowestSize = Long.MAX_VALUE;\n\n                for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                    mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (Thread.interrupted()) {\n                        return;\n                    }\n                    long length = Utility.getTotalContentLength(mConn);\n\n                    if (i == 0) {\n                        httpCode = mConn.getResponseCode();\n                        mMission.length = length;\n                    }\n\n                    if (length > 0) {\n                        finalLength += length;\n                    }\n                    if (length < lowestSize) {\n                        lowestSize = length;\n                    }\n                }\n\n                mMission.nearLength = finalLength;\n\n                // reserve space at the start of the file\n                if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                    if (lowestSize < 1) {\n                        // the length is unknown use the default size\n                        mMission.offsets[0] = RESERVE_SPACE_DEFAULT;\n                    } else {\n                        // use the smallest resource size to download, otherwise, use the maximum\n                        mMission.offsets[0] =\n                                lowestSize < RESERVE_SPACE_MAXIMUM\n                                        ? lowestSize\n                                        : RESERVE_SPACE_MAXIMUM;\n                    }\n                }\n            } else {\n                // ask for the current resource length\n                mConn = mMission.openConnection(true, 0, 0);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                httpCode = mConn.getResponseCode();\n                mMission.length = Utility.getTotalContentLength(mConn);\n            }\n\n            if (mMission.length == 0 || httpCode == 204) {\n                mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                return;\n            }\n\n            // check for dynamic generated content\n            if (mMission.length == -1 && mConn.getResponseCode() == 200) {\n                mMission.blocks = new int[0];\n                mMission.length = 0;\n                mMission.unknownLength = true;\n\n                if (DEBUG) {\n                    Log.d(TAG, \"falling back (unknown length)\");\n                }\n            } else {\n                // Open again\n                mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                mMission.establishConnection(mId, mConn);\n                dispose();\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                synchronized (mMission.LOCK) {\n                    if (mConn.getResponseCode() == 206) {\n\n                        if (mMission.threadCount > 1) {\n                            int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                            if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) {\n                                count++;\n                            }\n\n                            mMission.blocks = new int[count];\n                        } else {\n                            // if one thread is required don't calculate blocks, is useless\n                            mMission.blocks = new int[0];\n                            mMission.unknownLength = false;\n                        }\n\n                        if (DEBUG) {\n                            Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                        }\n                    } else {\n                        // Fallback to single thread\n                        mMission.blocks = new int[0];\n                        mMission.unknownLength = false;\n\n                        if (DEBUG) {\n                            Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                        }\n                    }\n                }\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n            }\n\n            try (SharpStream fs = mMission.storage.getStream()) {\n                fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                fs.seek(mMission.offsets[mMission.current]);\n            }\n\n            if (!mMission.running || Thread.interrupted()) {\n                return;\n            }\n\n            if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                String entityTag = mConn.getHeaderField(\"ETAG\");\n                String lastModified = mConn.getHeaderField(\"Last-Modified\");\n                MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n\n                if (!TextUtils.isEmpty(entityTag)) {\n                    recovery.setValidateCondition(entityTag);\n                } else if (!TextUtils.isEmpty(lastModified)) {\n                    // Note: this is less precise\n                    recovery.setValidateCondition(lastModified);\n                } else {\n                    recovery.setValidateCondition(null);\n                }\n            }\n\n            mMission.running = false;\n            break;\n        } catch (InterruptedIOException | ClosedByInterruptException e) {\n            return;\n        } catch (Exception e) {\n            if (!mMission.running || super.isInterrupted()) {\n                return;\n            }\n\n            if (e instanceof DownloadMission.HttpError\n                    && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired\n                interrupt();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                return;\n            }\n\n            if (retryCount++ > mMission.maxRetry) {\n                Log.e(TAG, \"initializer failed\", e);\n                mMission.notifyError(e);\n                return;\n            }\n\n            Log.e(TAG, \"initializer failed, retrying\", e);\n        }\n    }\n\n    mMission.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "344", "src_id": "M1037", "code": "\npublic void pause() {\n    if (!running) {\n        return;\n    }\n\n    if (isPsRunning()) {\n        if (DEBUG) {\n            Log.w(TAG, \"pause during post-processing is not applicable.\");\n        }\n        return;\n    }\n\n    running = false;\n    notify(DownloadManagerService.MESSAGE_PAUSED);\n\n    if (init != null && init.isAlive()) {\n        // NOTE: if start() method is running ¡will no have effect!\n        init.interrupt();\n        synchronized (LOCK) {\n            resetState(false, true, ERROR_NOTHING);\n        }\n        return;\n    }\n\n    if (DEBUG && unknownLength) {\n        Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n    }\n\n    init = null;\n    pauseThreads();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "345", "src_id": "M1079", "code": "\nboolean runMissions() {\n    synchronized (this) {\n        if (mMissionsPending.size() < 1) {\n            return false;\n        }\n        if (!canDownloadInCurrentNetwork()) {\n            return false;\n        }\n\n        if (mPrefQueueLimit) {\n            for (DownloadMission mission : mMissionsPending) {\n                if (!mission.isFinished() && mission.running) {\n                    return true;\n                }\n            }\n        }\n\n        boolean flag = false;\n        for (DownloadMission mission : mMissionsPending) {\n            if (mission.running || !mission.enqueued || mission.isFinished()) {\n                continue;\n            }\n\n            resumeMission(mission);\n            if (mission.errCode != DownloadMission.ERROR_NOTHING) {\n                continue;\n            }\n\n            if (mPrefQueueLimit) {\n                return true;\n            }\n            flag = true;\n        }\n\n        return flag;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "346", "src_id": "M1035", "code": "\nprivate void notifyPostProcessing(int state) {\n    String action;\n    switch (state) {\n        case 1:\n            action = \"Running\";\n            break;\n        case 2:\n            action = \"Completed\";\n            break;\n        default:\n            action = \"Failed\";\n    }\n\n    Log.d(TAG, action + \" postprocessing on \" + storage.getName());\n\n    if (state == 2) {\n        psState = state;\n        return;\n    }\n\n    synchronized (LOCK) {\n        // don't return without fully write the current state\n        psState = state;\n        writeThisToFile();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "347", "src_id": "M521", "code": "\nprivate static String decodeQRCode(BufferedImage bufferedImage) {\n    LuminanceSource source;\n    int width = bufferedImage.getWidth();\n    int height = bufferedImage.getHeight();\n\n    DataBuffer dataBuffer = bufferedImage.getRaster().getDataBuffer();\n    if (dataBuffer instanceof DataBufferByte) {\n        byte[] pixels = ((DataBufferByte) dataBuffer).getData();\n        source = new PlanarYUVLuminanceSource(\n                pixels, width, height, 0, 0, width, height, false);\n    } else if (dataBuffer instanceof DataBufferInt) {\n        int[] pixels = ((DataBufferInt) dataBuffer).getData();\n        byte[] newPixels = new byte[pixels.length];\n        for (int i = 0; i < pixels.length; i++) {\n            newPixels[i] = (byte) (pixels[i] & 0xff);\n        }\n        source = new PlanarYUVLuminanceSource(\n                newPixels, width, height, 0, 0, width, height, false);\n    } else {\n        throw new IllegalArgumentException(\"BufferedImage must have 8-bit gray scale, 24-bit RGB, 32-bit ARGB (packed int), byte gray, or 3-byte/4-byte RGB image data\");\n    }\n\n    BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));\n    try {\n        Result result = new MultiFormatReader().decode(bitmap);\n        return result.getText();\n    } catch (NotFoundException e) {\n        return null; // no QR code in the image\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "348", "src_id": "M177", "code": "\nprivate void executeJob(QueuedJob job) {\n    if (job.cancelled) {\n        log.debug(\"Job {} was cancelled, not executing\", job.jobId);\n        return;\n    }\n\n    Runnable task = new Runnable() {\n        @Override\n        public void run() {\n            log.debug(\"Executing queued job {} (queued at {})\", job.jobId, job.queuedAt);\n            try {\n                // execute with timeout\n                Object result = executeWithTimeout(job.work, job.timeoutMs);\n\n                // process result\n                if (result instanceof ResponseEntity) {\n                    job.future.complete((ResponseEntity<?>) result);\n                } else {\n                    job.future.complete(ResponseEntity.ok(result));\n                }\n            } catch (Exception e) {\n                log.error(\"Error executing queued job {}: {}\", job.jobId, e.getMessage(), e);\n                job.future.completeExceptionally(e);\n            }\n        }\n    };\n\n    jobExecutor.execute(task);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "349", "src_id": "M843", "code": "\n@DeleteMapping(\"/api/v1/general/job/{jobId}\")\npublic ResponseEntity<?> cancelJob(@PathVariable(\"jobId\") String jobId) {\n    log.debug(\"Request to cancel job: {}\", jobId);\n\n    // verify that this job belongs to the current user\n    Object sessionJobIds = request.getSession().getAttribute(\"userJobIds\");\n    if (!(sessionJobIds instanceof java.util.Set)) {\n        log.warn(\"Unauthorized attempt to cancel job: {}\", jobId);\n        return ResponseEntity.status(403).body(Map.of(\"message\", \"You are not authorized to cancel this job\"));\n    }\n    java.util.Set<?> userJobIds = (java.util.Set<?>) sessionJobIds;\n    if (!userJobIds.contains(jobId)) {\n        log.warn(\"Unauthorized attempt to cancel job: {}\", jobId);\n        return ResponseEntity.status(403).body(Map.of(\"message\", \"You are not authorized to cancel this job\"));\n    }\n\n    // first check if the job is in the queue\n    boolean cancelled = false;\n    int queuePosition = -1;\n\n    if (jobQueue.isJobQueued(jobId)) {\n        queuePosition = jobQueue.getJobPosition(jobId);\n        cancelled = jobQueue.cancelJob(jobId);\n        log.info(\"Cancelled queued job: {} (was at position {})\", jobId, queuePosition);\n    }\n\n    // if not in queue or couldn't cancel, try to cancel in TaskManager\n    if (!cancelled) {\n        JobResult result = taskManager.getJobResult(jobId);\n        if (result != null && !result.isComplete()) {\n            // mark as error with cancellation message\n            taskManager.setError(jobId, \"Job was cancelled by user\");\n            cancelled = true;\n            log.info(\"Marked job as cancelled in TaskManager: {}\", jobId);\n        }\n    }\n\n    if (cancelled) {\n        return ResponseEntity.ok(\n                Map.of(\n                        \"message\", \"Job cancelled successfully\",\n                        \"wasQueued\", queuePosition >= 0,\n                        \"queuePosition\", queuePosition >= 0 ? queuePosition : \"n/a\"));\n    } else {\n        // job not found or already complete\n        JobResult result = taskManager.getJobResult(jobId);\n        if (result == null) {\n            return ResponseEntity.notFound().build();\n        } else if (result.isComplete()) {\n            return ResponseEntity.badRequest().body(Map.of(\"message\", \"Cannot cancel job that is already complete\"));\n        } else {\n            return ResponseEntity.internalServerError().body(Map.of(\"message\", \"Failed to cancel job for unknown reason\"));\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "350", "src_id": "M516", "code": "\npublic ResponseEntity<String> printFile(@ModelAttribute PrintFileRequest request) throws IOException {\n    MultipartFile file = request.getFileInput();\n    String originalFilename = file.getOriginalFilename();\n    if (originalFilename != null && (originalFilename.contains(\"..\") || Paths.get(originalFilename).isAbsolute())) {\n        throw new IOException(\"Invalid file path detected: \" + originalFilename);\n    }\n    String printerName = request.getPrinterName();\n    String contentType = file.getContentType();\n    try {\n        // find matching printer\n        PrintService[] services = PrintServiceLookup.lookupPrintServices(null, null);\n        PrintService selectedService = Arrays.stream(services)\n                .filter(service -> service.getName().toLowerCase().contains(printerName))\n                .findFirst()\n                .orElseThrow(() -> new IllegalArgumentException(\"No matching printer found\"));\n\n        log.info(\"Selected Printer: \" + selectedService.getName());\n\n        if (\"application/pdf\".equals(contentType)) {\n            PDDocument document = Loader.loadPDF(file.getBytes());\n            PrinterJob job = PrinterJob.getPrinterJob();\n            job.setPrintService(selectedService);\n            job.setPageable(new PDFPageable(document));\n            job.print();\n            document.close();\n        } else if (contentType != null && contentType.startsWith(\"image/\")) {\n            BufferedImage image = ImageIO.read(file.getInputStream());\n            PrinterJob job = PrinterJob.getPrinterJob();\n            job.setPrintService(selectedService);\n            job.setPrintable(new Printable() {\n                @Override\n                public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n                    if (pageIndex != 0) {\n                        return NO_SUCH_PAGE;\n                    }\n                    Graphics2D g2d = (Graphics2D) graphics;\n                    g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n                    g2d.drawImage(\n                            image,\n                            0,\n                            0,\n                            (int) pageFormat.getImageableWidth(),\n                            (int) pageFormat.getImageableHeight(),\n                            null);\n                    return PAGE_EXISTS;\n                }\n            });\n            job.print();\n        }\n        return new ResponseEntity<>(\"File printed successfully to \" + selectedService.getName(), HttpStatus.OK);\n    } catch (Exception e) {\n        System.err.println(\"Failed to print: \" + e.getMessage());\n        return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "351", "src_id": "M522", "code": "\n@PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\")\n@Operation(\n        summary = \"Auto split PDF pages into separate documents\",\n        description = \"This endpoint accepts a PDF file, scans each page for a specific QR code, and splits the document at the QR code boundaries. The output is a zip file containing each separate PDF document. Input:PDF Output:ZIP-PDF Type:SISO\")\npublic ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request) throws IOException {\n    MultipartFile file = request.getFileInput();\n    boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n\n    PDDocument document = null;\n    List<PDDocument> splitDocuments = new ArrayList<PDDocument>();\n    Path zipFile = null;\n    byte[] data = null;\n\n    try {\n        document = pdfDocumentFactory.load(file.getInputStream());\n        PDFRenderer pdfRenderer = new PDFRenderer(document);\n        pdfRenderer.setSubsamplingAllowed(true);\n\n        for (int page = 0; page < document.getNumberOfPages(); ++page) {\n            BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n            String result = decodeQRCode(bim);\n\n            boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n            log.debug(\"detected qr code {}, code is vale={}\", result, isValidQrCode);\n            if (isValidQrCode && page != 0) {\n                splitDocuments.add(new PDDocument());\n            }\n\n            if (!splitDocuments.isEmpty() && !isValidQrCode) {\n                splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n            } else if (page == 0) {\n                PDDocument firstDocument = new PDDocument();\n                firstDocument.addPage(document.getPage(page));\n                splitDocuments.add(firstDocument);\n            }\n\n            // if duplex mode is true and current page is a divider, then skip next page\n            if (duplexMode && isValidQrCode) {\n                page++;\n            }\n        }\n\n        // remove split documents that have no pages\n        splitDocuments.removeIf(pdDocument -> pdDocument.getNumberOfPages() == 0);\n\n        zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n        String filename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\");\n\n        try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile))) {\n            for (int i = 0; i < splitDocuments.size(); i++) {\n                String fileName = filename + \"_\" + (i + 1) + \".pdf\";\n                PDDocument splitDocument = splitDocuments.get(i);\n\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                splitDocument.save(baos);\n                byte[] pdf = baos.toByteArray();\n\n                ZipEntry pdfEntry = new ZipEntry(fileName);\n                zipOut.putNextEntry(pdfEntry);\n                zipOut.write(pdf);\n                zipOut.closeEntry();\n            }\n        }\n\n        data = Files.readAllBytes(zipFile);\n        return WebResponseUtils.bytesToWebResponse(data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM);\n    } catch (Exception e) {\n        log.error(\"Error in auto split\", e);\n        throw e;\n    } finally {\n        // clean up resources\n        if (document != null) {\n            try {\n                document.close();\n            } catch (IOException e) {\n                log.error(\"Error closing main PDDocument\", e);\n            }\n        }\n\n        for (PDDocument splitDoc : splitDocuments) {\n            try {\n                splitDoc.close();\n            } catch (IOException e) {\n                log.error(\"Error closing split PDDocument\", e);\n            }\n        }\n\n        if (zipFile != null) {\n            try {\n                Files.deleteIfExists(zipFile);\n            } catch (IOException e) {\n                log.error(\"Error deleting temporary zip file\", e);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "352", "src_id": "M550", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/auto-rename\")\n@Operation(\n        summary = \"Extract header from PDF file\",\n        description = \"This endpoint accepts a PDF file and attempts to extract its title or header based on heuristics. Input:PDF Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> extractHeader(@ModelAttribute ExtractHeaderRequest request) throws Exception {\n    MultipartFile file = request.getFileInput();\n    boolean useFirstTextAsFallback = Boolean.TRUE.equals(request.getUseFirstTextAsFallback());\n\n    PDDocument document = pdfDocumentFactory.load(file);\n    PDFTextStripper reader = new PDFTextStripper() {\n        List<LineInfo> lineInfos = new ArrayList<LineInfo>();\n        StringBuilder lineBuilder = new StringBuilder();\n        float lastY = -1;\n        float maxFontSizeInLine = 0.0f;\n        int lineCount = 0;\n\n        @Override\n        protected void processTextPosition(TextPosition text) {\n            if (lastY != text.getY() && lineCount < LINE_LIMIT) {\n                processLine();\n                lineBuilder = new StringBuilder(text.getUnicode());\n                maxFontSizeInLine = text.getFontSizeInPt();\n                lastY = text.getY();\n                lineCount++;\n            } else if (lineCount < LINE_LIMIT) {\n                lineBuilder.append(text.getUnicode());\n                if (text.getFontSizeInPt() > maxFontSizeInLine) {\n                    maxFontSizeInLine = text.getFontSizeInPt();\n                }\n            }\n        }\n\n        private void processLine() {\n            if (lineBuilder.length() > 0 && lineCount < LINE_LIMIT) {\n                lineInfos.add(new LineInfo(lineBuilder.toString(), maxFontSizeInLine));\n            }\n        }\n\n        @Override\n        public String getText(PDDocument doc) throws IOException {\n            this.lineInfos.clear();\n            this.lineBuilder = new StringBuilder();\n            this.lastY = -1;\n            this.maxFontSizeInLine = 0.0f;\n            this.lineCount = 0;\n            super.getText(doc);\n            processLine(); // process the last line\n\n            // merge lines with same font size\n            List<LineInfo> mergedLineInfos = new ArrayList<LineInfo>();\n            for (int i = 0; i < lineInfos.size(); i++) {\n                String mergedText = lineInfos.get(i).text;\n                float fontSize = lineInfos.get(i).fontSize;\n                while (i + 1 < lineInfos.size() && lineInfos.get(i + 1).fontSize == fontSize) {\n                    mergedText += \" \" + lineInfos.get(i + 1).text;\n                    i++;\n                }\n                mergedLineInfos.add(new LineInfo(mergedText, fontSize));\n            }\n\n            // sort lines by font size in descending order and get the first one\n            Collections.sort(mergedLineInfos, new Comparator<LineInfo>() {\n                @Override\n                public int compare(LineInfo o1, LineInfo o2) {\n                    return Float.compare(o2.fontSize, o1.fontSize);\n                }\n            });\n            String title = mergedLineInfos.isEmpty() ? null : mergedLineInfos.get(0).text;\n\n            return title != null\n                    ? title\n                    : (useFirstTextAsFallback\n                    ? (mergedLineInfos.isEmpty() ? null : mergedLineInfos.get(mergedLineInfos.size() - 1).text)\n                    : null);\n        }\n\n        class LineInfo {\n            String text;\n            float fontSize;\n\n            LineInfo(String text, float fontSize) {\n                this.text = text;\n                this.fontSize = fontSize;\n            }\n        }\n    };\n\n    String header = reader.getText(document);\n\n    // sanitize the header string by removing characters not allowed in a filename\n    if (header != null && header.length() < 255) {\n        header = header.replaceAll(\"[/\\\\\\\\?%*:|\\\"<>]\", \"\").trim();\n        return WebResponseUtils.pdfDocToWebResponse(document, header + \".pdf\");\n    } else {\n        log.info(\"File has no good title to be found\");\n        return WebResponseUtils.pdfDocToWebResponse(document, Filenames.toSimpleFileName(file.getOriginalFilename()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "353", "src_id": "M618", "code": "\n@Operation(\n        summary = \"Validate PDF Digital Signature\",\n        description = \"Validates the digital signatures in a PDF file against default or custom certificates. Input:PDF Output:JSON Type:SISO\")\n@PostMapping(value = \"/validate-signature\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\npublic ResponseEntity<List<SignatureValidationResult>> validateSignature(@ModelAttribute SignatureValidationRequest request) throws IOException {\n    List<SignatureValidationResult> results = new ArrayList<SignatureValidationResult>();\n    MultipartFile file = request.getFileInput();\n    MultipartFile certFile = request.getCertFile();\n\n    // load custom certificate if provided\n    X509Certificate customCert = null;\n    if (certFile != null && !certFile.isEmpty()) {\n        try (ByteArrayInputStream certStream = new ByteArrayInputStream(certFile.getBytes())) {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            customCert = (X509Certificate) cf.generateCertificate(certStream);\n        } catch (CertificateException e) {\n            throw ExceptionUtils.createRuntimeException(\n                    \"error.invalidFormat\",\n                    \"Invalid {0} format: {1}\",\n                    e,\n                    \"certificate file\",\n                    e.getMessage());\n        }\n    }\n\n    try (PDDocument document = pdfDocumentFactory.load(file.getInputStream())) {\n        List<PDSignature> signatures = document.getSignatureDictionaries();\n\n        for (PDSignature sig : signatures) {\n            SignatureValidationResult result = new SignatureValidationResult();\n\n            try {\n                byte[] signedContent = sig.getSignedContent(file.getInputStream());\n                byte[] signatureBytes = sig.getContents(file.getInputStream());\n\n                CMSProcessable content = new CMSProcessableByteArray(signedContent);\n                CMSSignedData signedData = new CMSSignedData(content, signatureBytes);\n\n                Store<X509CertificateHolder> certStore = signedData.getCertificates();\n                SignerInformationStore signerStore = signedData.getSignerInfos();\n\n                for (SignerInformation signer : signerStore.getSigners()) {\n                    X509CertificateHolder certHolder = (X509CertificateHolder) certStore.getMatches(signer.getSID()).iterator().next();\n                    X509Certificate cert = new JcaX509CertificateConverter().getCertificate(certHolder);\n\n                    boolean isValid = signer.verify(new JcaSimpleSignerInfoVerifierBuilder().build(cert));\n                    result.setValid(isValid);\n\n                    // additional validations\n                    result.setChainValid(\n                            customCert != null\n                                    ? certValidationService.validateCertificateChainWithCustomCert(cert, customCert)\n                                    : certValidationService.validateCertificateChain(cert));\n\n                    result.setTrustValid(\n                            customCert != null\n                                    ? certValidationService.validateTrustWithCustomCert(cert, customCert)\n                                    : certValidationService.validateTrustStore(cert));\n\n                    result.setNotRevoked(!certValidationService.isRevoked(cert));\n                    result.setNotExpired(!cert.getNotAfter().before(new Date()));\n\n                    // basic signature info\n                    result.setSignerName(sig.getName());\n                    result.setSignatureDate(sig.getSignDate().getTime().toString());\n                    result.setReason(sig.getReason());\n                    result.setLocation(sig.getLocation());\n\n                    // certificate details\n                    result.setIssuerDN(cert.getIssuerX500Principal().getName());\n                    result.setSubjectDN(cert.getSubjectX500Principal().getName());\n                    result.setSerialNumber(cert.getSerialNumber().toString(16));\n                    result.setValidFrom(cert.getNotBefore().toString());\n                    result.setValidUntil(cert.getNotAfter().toString());\n                    result.setSignatureAlgorithm(cert.getSigAlgName());\n\n                    // key size (if possible)\n                    try {\n                        result.setKeySize(((RSAPublicKey) cert.getPublicKey()).getModulus().bitLength());\n                    } catch (Exception e) {\n                        result.setKeySize(0);\n                    }\n\n                    result.setVersion(String.valueOf(cert.getVersion()));\n\n                    // key usage\n                    List<String> keyUsages = new ArrayList<String>();\n                    boolean[] keyUsageFlags = cert.getKeyUsage();\n                    if (keyUsageFlags != null) {\n                        String[] keyUsageLabels = {\n                                \"Digital Signature\", \"Non-Repudiation\", \"Key Encipherment\",\n                                \"Data Encipherment\", \"Key Agreement\", \"Certificate Signing\",\n                                \"CRL Signing\", \"Encipher Only\", \"Decipher Only\"\n                        };\n                        for (int i = 0; i < keyUsageFlags.length; i++) {\n                            if (keyUsageFlags[i]) {\n                                keyUsages.add(keyUsageLabels[i]);\n                            }\n                        }\n                    }\n                    result.setKeyUsages(keyUsages);\n\n                    // self-signed check\n                    result.setSelfSigned(cert.getSubjectX500Principal().equals(cert.getIssuerX500Principal()));\n                }\n            } catch (Exception e) {\n                result.setValid(false);\n                result.setErrorMessage(\"Signature validation failed: \" + e.getMessage());\n            }\n\n            results.add(result);\n        }\n    }\n\n    return ResponseEntity.ok(results);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "354", "src_id": "M186", "code": "\npublic Map<String, Object> captureApplicationProperties() {\n    Map<String, Object> properties = new HashMap<String, Object>();\n\n    // legal properties\n    addIfNotEmpty(properties, \"legal_termsAndConditions\", applicationProperties.getLegal().getTermsAndConditions());\n    addIfNotEmpty(properties, \"legal_privacyPolicy\", applicationProperties.getLegal().getPrivacyPolicy());\n    addIfNotEmpty(properties, \"legal_accessibilityStatement\", applicationProperties.getLegal().getAccessibilityStatement());\n    addIfNotEmpty(properties, \"legal_cookiePolicy\", applicationProperties.getLegal().getCookiePolicy());\n    addIfNotEmpty(properties, \"legal_impressum\", applicationProperties.getLegal().getImpressum());\n\n    // security properties\n    addIfNotEmpty(properties, \"security_enableLogin\", applicationProperties.getSecurity().getEnableLogin());\n    addIfNotEmpty(properties, \"security_csrfDisabled\", applicationProperties.getSecurity().getCsrfDisabled());\n    addIfNotEmpty(properties, \"security_loginAttemptCount\", applicationProperties.getSecurity().getLoginAttemptCount());\n    addIfNotEmpty(properties, \"security_loginResetTimeMinutes\", applicationProperties.getSecurity().getLoginResetTimeMinutes());\n    addIfNotEmpty(properties, \"security_loginMethod\", applicationProperties.getSecurity().getLoginMethod());\n\n    // oauth2 properties (excluding sensitive information)\n    addIfNotEmpty(properties, \"security_oauth2_enabled\", applicationProperties.getSecurity().getOauth2().getEnabled());\n    if (applicationProperties.getSecurity().getOauth2().getEnabled()) {\n        addIfNotEmpty(properties, \"security_oauth2_autoCreateUser\", applicationProperties.getSecurity().getOauth2().getAutoCreateUser());\n        addIfNotEmpty(properties, \"security_oauth2_blockRegistration\", applicationProperties.getSecurity().getOauth2().getBlockRegistration());\n        addIfNotEmpty(properties, \"security_oauth2_useAsUsername\", applicationProperties.getSecurity().getOauth2().getUseAsUsername());\n        addIfNotEmpty(properties, \"security_oauth2_provider\", applicationProperties.getSecurity().getOauth2().getProvider());\n    }\n\n    // system properties\n    addIfNotEmpty(properties, \"system_defaultLocale\", applicationProperties.getSystem().getDefaultLocale());\n    addIfNotEmpty(properties, \"system_googlevisibility\", applicationProperties.getSystem().getGooglevisibility());\n    addIfNotEmpty(properties, \"system_showUpdate\", applicationProperties.getSystem().isShowUpdate());\n    addIfNotEmpty(properties, \"system_showUpdateOnlyAdmin\", applicationProperties.getSystem().getShowUpdateOnlyAdmin());\n    addIfNotEmpty(properties, \"system_customHTMLFiles\", applicationProperties.getSystem().isCustomHTMLFiles());\n    addIfNotEmpty(properties, \"system_tessdataDir\", applicationProperties.getSystem().getTessdataDir());\n    addIfNotEmpty(properties, \"system_enableAlphaFunctionality\", applicationProperties.getSystem().getEnableAlphaFunctionality());\n    addIfNotEmpty(properties, \"system_enableAnalytics\", applicationProperties.getSystem().isAnalyticsEnabled());\n\n    // ui properties\n    addIfNotEmpty(properties, \"ui_appName\", applicationProperties.getUi().getAppName());\n    addIfNotEmpty(properties, \"ui_homeDescription\", applicationProperties.getUi().getHomeDescription());\n    addIfNotEmpty(properties, \"ui_appNameNavbar\", applicationProperties.getUi().getAppNameNavbar());\n\n    // metrics properties\n    addIfNotEmpty(properties, \"metrics_enabled\", applicationProperties.getMetrics().getEnabled());\n\n    // enterprise edition properties\n    addIfNotEmpty(properties, \"enterpriseEdition_enabled\", applicationProperties.getPremium().isEnabled());\n    if (applicationProperties.getPremium().isEnabled()) {\n        addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_autoUpdateMetadata\",\n                applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata());\n        addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_author\",\n                applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor());\n        addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_creator\",\n                applicationProperties.getPremium().getProFeatures().getCustomMetadata().getCreator());\n        addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_producer\",\n                applicationProperties.getPremium().getProFeatures().getCustomMetadata().getProducer());\n    }\n\n    // auto pipeline properties\n    addIfNotEmpty(properties, \"autoPipeline_outputFolder\", applicationProperties.getAutoPipeline().getOutputFolder());\n\n    return properties;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "355", "src_id": "M173", "code": "\npublic CompletableFuture<ResponseEntity<?>> queueJob(String jobId, int resourceWeight, Supplier<Object> work, long timeoutMs) {\n    // create a CompletableFuture to track this job's completion\n    CompletableFuture<ResponseEntity<?>> future = new CompletableFuture<ResponseEntity<?>>();\n\n    // create the queued job\n    QueuedJob job = new QueuedJob(jobId, resourceWeight, work, timeoutMs, Instant.now(), future, false);\n\n    // store in our map for lookup\n    jobMap.put(jobId, job);\n\n    // update stats\n    totalQueuedJobs++;\n\n    // synchronize access to the queue\n    synchronized (queueLock) {\n        currentQueueSize = jobQueue.size();\n\n        // try to add to the queue\n        try {\n            boolean added = jobQueue.offer(job, 5, TimeUnit.SECONDS);\n            if (!added) {\n                log.warn(\"Queue full, rejecting job {}\", jobId);\n                rejectedJobs++;\n                future.completeExceptionally(new RuntimeException(\"Job queue full, please try again later\"));\n                jobMap.remove(jobId);\n                return future;\n            }\n\n            log.debug(\"Job {} queued for execution (weight: {}, queue size: {})\", jobId, resourceWeight, jobQueue.size());\n            return future;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            future.completeExceptionally(new RuntimeException(\"Job queue interrupted\"));\n            jobMap.remove(jobId);\n            return future;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "356", "src_id": "M544", "code": "\nprivate void applyQpdfCompression(OptimizePdfRequest request, int optimizeLevel, Path currentFile, List<Path> tempFiles) throws IOException {\n    long preQpdfSize = Files.size(currentFile);\n    log.info(\"Pre-QPDF file size: {}\", GeneralUtils.formatBytes(preQpdfSize));\n\n    // map optimization levels to QPDF compression levels\n    int qpdfCompressionLevel;\n    switch (optimizeLevel) {\n        case 1:\n            qpdfCompressionLevel = 5;\n            break;\n        case 2:\n            qpdfCompressionLevel = 9;\n            break;\n        default:\n            qpdfCompressionLevel = 9;\n            break;\n    }\n\n    // create output file for QPDF\n    Path qpdfOutputFile = Files.createTempFile(\"qpdf_output_\", \".pdf\");\n    tempFiles.add(qpdfOutputFile);\n\n    // build QPDF command\n    List<String> command = new ArrayList<String>();\n    command.add(\"qpdf\");\n    if (request.getNormalize()) {\n        command.add(\"--normalize-content=y\");\n    }\n    if (request.getLinearize()) {\n        command.add(\"--linearize\");\n    }\n    command.add(\"--recompress-flate\");\n    command.add(\"--compression-level=\" + qpdfCompressionLevel);\n    command.add(\"--compress-streams=y\");\n    command.add(\"--object-streams=generate\");\n    command.add(currentFile.toString());\n    command.add(qpdfOutputFile.toString());\n\n    ProcessExecutorResult returnCode = null;\n    try {\n        returnCode = ProcessExecutor.getInstance(ProcessExecutor.Processes.QPDF).runCommandWithOutputHandling(command);\n\n        // update current file to the QPDF output\n        Files.copy(qpdfOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n\n        long postQpdfSize = Files.size(currentFile);\n        double qpdfReduction = 100.0 - ((postQpdfSize * 100.0) / preQpdfSize);\n        log.info(\"Post-QPDF file size: {} (reduced by {}%)\", GeneralUtils.formatBytes(postQpdfSize), String.format(\"%.1f\", qpdfReduction));\n    } catch (Exception e) {\n        if (returnCode != null && returnCode.getRc() != 3) {\n            throw new IOException(\"QPDF command failed\", e);\n        }\n        // if QPDF fails, keep using the current file\n        log.warn(\"QPDF compression failed, continuing with current file\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "357", "src_id": "M16", "code": "\nprivate void handleCookiesFromUrl(@Nullable String url) {\n    if (MainActivity.DEBUG) {\n        Log.d(TAG, \"handleCookiesFromUrl: url=\" + (url == null ? \"null\" : url));\n    }\n    if (url == null) return;\n\n    String cookies = CookieManager.getInstance().getCookie(url);\n    handleCookies(cookies);\n\n    // Sometimes cookies are inside the URL\n    int abuseStart = url.indexOf(\"google_abuse=\");\n    if (abuseStart != -1) {\n        int abuseEnd = url.indexOf(\"+path\");\n        try {\n            String decoded = Utils.decodeUrlUtf8(url.substring(abuseStart + 13, abuseEnd));\n            handleCookies(decoded);\n        } catch (StringIndexOutOfBoundsException e) {\n            if (MainActivity.DEBUG) {\n                Log.e(TAG, \"handleCookiesFromUrl: invalid google abuse starting at \"\n                        + abuseStart + \" and ending at \" + abuseEnd + \" for url \" + url, e);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "358", "src_id": "M339", "code": "\n@Override\npublic void onUpdateProgress(int currentProgress, int duration, int bufferPercent) {\n    if (duration != binding.playbackSeekBar.getMax()) {\n        setVideoDurationToControls(duration);\n    }\n    if (player.getCurrentState() != STATE_PAUSED) {\n        updatePlayBackElementsCurrentDuration(currentProgress);\n    }\n    if (player.isLoading() || bufferPercent > 90) {\n        binding.playbackSeekBar.setSecondaryProgress(\n                (int) (binding.playbackSeekBar.getMax() * ((float) bufferPercent / 100)));\n    }\n    if (DEBUG && bufferPercent % 20 == 0) { // Limit log\n        Log.d(TAG, \"notifyProgressUpdateToListeners() called with: \"\n                + \"isVisible = \" + isControlsVisible() + \", \"\n                + \"currentProgress = [\" + currentProgress + \"], \"\n                + \"duration = [\" + duration + \"], bufferPercent = [\" + bufferPercent + \"]\");\n    }\n    binding.playbackLiveSync.setClickable(!player.isLiveEdge());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "359", "src_id": "M452", "code": "\nprivate void updateQueueTime(int currentTime) {\n    PlayQueue playQueue = player.getPlayQueue();\n    if (playQueue == null) return;\n\n    int currentStream = playQueue.getIndex();\n    int before = 0;\n    int after = 0;\n\n    List<PlayQueueItem> streams = playQueue.getStreams();\n    int nStreams = streams.size();\n\n    for (int i = 0; i < nStreams; i++) {\n        if (i < currentStream) {\n            before += streams.get(i).getDuration();\n        } else {\n            after += streams.get(i).getDuration();\n        }\n    }\n\n    before *= 1000;\n    after *= 1000;\n\n    binding.itemsListHeaderDuration.setText(\n            String.format(\n                    \"%s/%s\",\n                    getTimeString(currentTime + before),\n                    getTimeString(before + after)\n            ));\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "360", "src_id": "M900", "code": "\n@StyleRes\npublic static int getSettingsThemeStyle(Context context) {\n    Resources res = context.getResources();\n    String lightTheme = res.getString(R.string.light_theme_key);\n    String blackTheme = res.getString(R.string.black_theme_key);\n    String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n    String selectedTheme = getSelectedThemeKey(context);\n\n    if (selectedTheme.equals(lightTheme)) {\n        return R.style.LightSettingsTheme;\n    }\n    if (selectedTheme.equals(blackTheme)) {\n        return R.style.BlackSettingsTheme;\n    }\n    if (selectedTheme.equals(automaticDeviceTheme)) {\n        if (isDeviceDarkThemeEnabled(context)) {\n            // Use the dark theme variant preferred by the user\n            String selectedNightTheme = getSelectedNightThemeKey(context);\n            return selectedNightTheme.equals(blackTheme)\n                    ? R.style.BlackSettingsTheme\n                    : R.style.DarkSettingsTheme;\n        }\n        // There is only one day theme\n        return R.style.LightSettingsTheme;\n    }\n    // Default to dark theme\n    return R.style.DarkSettingsTheme;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "361", "src_id": "M383", "code": "\npublic boolean onKeyDown(int keyCode) {\n    switch (keyCode) {\n        case KeyEvent.KEYCODE_BACK:\n            if (DeviceUtils.isTv(context) && isControlsVisible()) {\n                hideControls(0, 0);\n                return true;\n            }\n            break;\n        case KeyEvent.KEYCODE_DPAD_UP:\n        case KeyEvent.KEYCODE_DPAD_LEFT:\n        case KeyEvent.KEYCODE_DPAD_DOWN:\n        case KeyEvent.KEYCODE_DPAD_RIGHT:\n        case KeyEvent.KEYCODE_DPAD_CENTER:\n            if ((binding.getRoot().hasFocus() && !binding.playbackControlRoot.hasFocus())\n                    || isAnyListViewOpen()) {\n                // Do not interfere with focus in playlist and play queue etc.\n                break;\n            }\n\n            if (player.getCurrentState() == org.schabi.newpipe.player.Player.STATE_BLOCKED) {\n                return true;\n            }\n\n            if (isControlsVisible()) {\n                hideControls(DEFAULT_CONTROLS_DURATION, DPAD_CONTROLS_HIDE_TIME);\n            } else {\n                binding.playPauseButton.requestFocus();\n                showControlsThenHide();\n                showSystemUIPartially();\n                return true;\n            }\n            break;\n        default:\n            break; // Ignore other keys\n    }\n\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "362", "src_id": "M553", "code": "\npublic static String getActionName(@NonNull Context context, @Action int action) {\n    switch (action) {\n        case PREVIOUS:\n            return context.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_previous_description);\n        case NEXT:\n            return context.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_next_description);\n        case REWIND:\n            return context.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_rewind_description);\n        case FORWARD:\n            return context.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_fastforward_description);\n        case SMART_REWIND_PREVIOUS:\n            return Localization.concatenateStrings(\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_rewind_description),\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_previous_description));\n        case SMART_FORWARD_NEXT:\n            return Localization.concatenateStrings(\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_fastforward_description),\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_next_description));\n        case PLAY_PAUSE:\n            return Localization.concatenateStrings(\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_play_description),\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_pause_description));\n        case PLAY_PAUSE_BUFFERING:\n            return Localization.concatenateStrings(\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_play_description),\n                    context.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_pause_description),\n                    context.getString(R.string.notification_action_buffering));\n        case REPEAT:\n            return context.getString(R.string.notification_action_repeat);\n        case SHUFFLE:\n            return context.getString(R.string.notification_action_shuffle);\n        case CLOSE:\n            return context.getString(R.string.close);\n        case NOTHING:\n        default:\n            return context.getString(R.string.notification_action_nothing);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "363", "src_id": "M343", "code": "\nprivate void adjustSeekbarPreviewContainer() {\n    try {\n        // Should only be required when an error occurred before\n        // and the layout was positioned in the center\n        binding.bottomSeekbarPreviewLayout.setGravity(Gravity.NO_GRAVITY);\n\n        // Calculate the current left position of seekbar progress in px\n        // More info: https://stackoverflow.com/q/20493577\n        int currentSeekbarLeft =\n                binding.playbackSeekBar.getLeft()\n                        + binding.playbackSeekBar.getPaddingLeft()\n                        + binding.playbackSeekBar.getThumb().getBounds().left;\n\n        // Calculate the (unchecked) left position of the container\n        int uncheckedContainerLeft =\n                currentSeekbarLeft - (binding.seekbarPreviewContainer.getWidth() / 2);\n\n        // Fix the position so it's within the boundaries\n        int checkedContainerLeft =\n                MathUtils.clamp(\n                        uncheckedContainerLeft,\n                        0,\n                        binding.playbackWindowRoot.getWidth()\n                                - binding.seekbarPreviewContainer.getWidth());\n\n        // See also: https://stackoverflow.com/a/23249734\n        LinearLayout.LayoutParams params =\n                new LinearLayout.LayoutParams(\n                        binding.seekbarPreviewContainer.getLayoutParams());\n        params.setMarginStart(checkedContainerLeft);\n        binding.seekbarPreviewContainer.setLayoutParams(params);\n    } catch (Exception e) {\n        Log.e(TAG, \"Failed to adjust seekbarPreviewContainer\", e);\n        // Fallback - position in the middle\n        binding.bottomSeekbarPreviewLayout.setGravity(Gravity.CENTER);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "364", "src_id": "M995", "code": "\npublic static void fetchStreamInfoAndSaveToDatabase(\n        @NonNull Context context,\n        int serviceId,\n        @NonNull String url,\n        Consumer<StreamInfo> callback) {\n\n    Toast.makeText(context, R.string.loading_stream_details, Toast.LENGTH_SHORT).show();\n\n    ExtractorHelper.getStreamInfo(serviceId, url, false)\n            .subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(result -> {\n                // Save to database in the background (not on main thread)\n                Completable.fromAction(() -> NewPipeDatabase.getInstance(context)\n                                .streamDAO()\n                                .upsert(new StreamEntity(result)))\n                        .subscribeOn(Schedulers.io())\n                        .observeOn(Schedulers.io())\n                        .doOnError(throwable ->\n                                ErrorUtil.createNotification(\n                                        context,\n                                        new ErrorInfo(\n                                                throwable,\n                                                UserAction.REQUESTED_STREAM,\n                                                \"Saving stream info to database\",\n                                                result)))\n                        .subscribe();\n\n                // Call callback on main thread with the obtained result\n                callback.accept(result);\n            }, throwable ->\n                    ErrorUtil.createNotification(\n                            context,\n                            new ErrorInfo(\n                                    throwable,\n                                    UserAction.REQUESTED_STREAM,\n                                    \"Loading stream info: \" + url,\n                                    serviceId)\n                    )));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "365", "src_id": "M741", "code": "\nprivate void onItemSelectedSetFileName() {\n    String fileName = FilenameUtils.createFilename(getContext(), currentInfo.getName());\n    String prevFileName = Optional.ofNullable(dialogBinding.fileName.getText())\n            .map(Object::toString)\n            .orElse(\"\");\n\n    if (prevFileName.isEmpty()\n            || prevFileName.equals(fileName)\n            || prevFileName.startsWith(getString(R.string.caption_file_name, fileName, \"\"))) {\n        // Only update the file name field if it was not edited by the user\n        switch (dialogBinding.videoAudioGroup.getCheckedRadioButtonId()) {\n            case R.id.audio_button:\n            case R.id.video_button:\n                if (!prevFileName.equals(fileName)) {\n                    // Since the user might have switched between audio and video, the correct\n                    // text might already be in place, so avoid resetting the cursor position\n                    dialogBinding.fileName.setText(fileName);\n                }\n                break;\n\n            case R.id.subtitle_button:\n                String setSubtitleLanguageCode =\n                        subtitleStreamsAdapter.getItem(selectedSubtitleIndex).getLanguageTag();\n                // This will reset the cursor position, which is bad UX, but it can't be avoided\n                dialogBinding.fileName.setText(\n                        getString(R.string.caption_file_name, fileName, setSubtitleLanguageCode));\n                break;\n            default:\n                break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "366", "src_id": "M338", "code": "\nprivate void updateEndScreenThumbnail(@Nullable Bitmap thumbnail) {\n    if (thumbnail == null) {\n        // Remove end screen thumbnail\n        binding.endScreen.setImageDrawable(null);\n        return;\n    }\n\n    float endScreenHeight = calculateMaxEndScreenThumbnailHeight(thumbnail);\n    Bitmap endScreenBitmap =\n            BitmapCompat.createScaledBitmap(\n                    thumbnail,\n                    (int) (thumbnail.getWidth() / (thumbnail.getHeight() / endScreenHeight)),\n                    (int) endScreenHeight,\n                    null,\n                    true);\n\n    if (DEBUG) {\n        Log.d(TAG, \"Thumbnail - onThumbnailLoaded() called with: \"\n                + \"currentThumbnail = [\" + thumbnail + \"], \"\n                + thumbnail.getWidth() + \"x\" + thumbnail.getHeight()\n                + \", scaled end screen height = \" + endScreenHeight\n                + \", scaled end screen width = \" + endScreenBitmap.getWidth());\n    }\n\n    binding.endScreen.setImageBitmap(endScreenBitmap);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "367", "src_id": "M1148", "code": "\n@Override\npublic void seek(long offset) throws IOException {\n    final long total = out.length + aux.length;\n\n    if (offset == total) {\n        // do not ignore the seek offset if an underflow exists\n        final long relativeOffset = out.getOffset() + aux.getOffset();\n        if (relativeOffset == total) {\n            return;\n        }\n    }\n\n    // flush everything, avoid any underflow\n    flush();\n\n    if (offset < 0 || offset > total) {\n        throw new IOException(\"desired offset is outside of range=0-\" + total + \" offset=\" + offset);\n    }\n\n    if (offset > out.length) {\n        out.seek(out.length);\n        aux.seek(offset - out.length);\n    } else {\n        out.seek(offset);\n        aux.seek(0);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "368", "src_id": "M1079", "code": "\nboolean runMissions() {\n    synchronized (this) {\n        if (mMissionsPending.isEmpty()) {\n            return false;\n        }\n        if (!canDownloadInCurrentNetwork()) {\n            return false;\n        }\n\n        if (mPrefQueueLimit) {\n            for (final DownloadMission mission : mMissionsPending) {\n                if (!mission.isFinished() && mission.running) {\n                    return true;\n                }\n            }\n        }\n\n        boolean startedAny = false;\n        for (final DownloadMission mission : mMissionsPending) {\n            if (mission.running || !mission.enqueued || mission.isFinished()) {\n                continue;\n            }\n\n            resumeMission(mission);\n            if (mission.errCode != DownloadMission.ERROR_NOTHING) {\n                continue;\n            }\n\n            if (mPrefQueueLimit) {\n                return true;\n            }\n            startedAny = true;\n        }\n\n        return startedAny;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "369", "src_id": "M883", "code": "\nprivate void makeMvhd(final long longestTrack) throws IOException {\n    auxWrite(new byte[]{\n            0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00\n    });\n\n    auxWrite(ByteBuffer.allocate(28)\n            .putLong(time)\n            .putLong(time)\n            .putInt(DEFAULT_TIMESCALE)\n            .putLong(longestTrack)\n            .array()\n    );\n\n    auxWrite(new byte[]{\n            0x00, 0x01, 0x00, 0x00, 0x01, 0x00, // default volume and rate\n            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved values\n            // default matrix\n            0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            0x00, 0x00, 0x00, 0x00,\n            0x40, 0x00, 0x00, 0x00\n    });\n\n    auxWrite(new byte[24]); // predefined\n\n    auxWrite(ByteBuffer.allocate(4)\n            .putInt(tracks.length + 1)\n            .array()\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "370", "src_id": "M1037", "code": "\npublic void pause() {\n    if (!running) {\n        return;\n    }\n\n    if (isPsRunning()) {\n        if (DEBUG) {\n            Log.w(TAG, \"pause during post-processing is not applicable.\");\n        }\n        return;\n    }\n\n    running = false;\n    notify(DownloadManagerService.MESSAGE_PAUSED);\n\n    if (init != null && init.isAlive()) {\n        // NOTE: if start() method is running ¡will no have effect!\n        init.interrupt();\n        synchronized (LOCK) {\n            resetState(false, true, ERROR_NOTHING);\n        }\n        return;\n    }\n\n    if (DEBUG && unknownLength) {\n        Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n    }\n\n    init = null;\n    pauseThreads();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "371", "src_id": "M1043", "code": "\nprivate void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    final Thread thread = Thread.currentThread();\n\n    notifyPostProcessing(1);\n\n    if (DEBUG) {\n        thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n\n    Exception caughtException = null;\n\n    try {\n        psAlgorithm.run(this);\n    } catch (final Exception err) {\n        Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n        if (err instanceof InterruptedIOException\n                || err instanceof ClosedByInterruptException\n                || thread.isInterrupted()) {\n            notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) {\n            errCode = ERROR_POSTPROCESSING;\n        }\n\n        caughtException = err;\n    } finally {\n        notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n        if (caughtException == null) {\n            caughtException = errObject;\n        }\n        notifyError(ERROR_POSTPROCESSING, caughtException);\n        return;\n    }\n\n    notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "372", "src_id": "M1056", "code": "\nprivate boolean handleMessage(@NonNull final Message msg) {\n    if (mHandler == null) {\n        return true;\n    }\n\n    final DownloadMission mission = (DownloadMission) msg.obj;\n\n    switch (msg.what) {\n        case MESSAGE_FINISHED:\n            notifyMediaScanner(mission.storage.getUri());\n            notifyFinishedDownload(mission.storage.getName());\n            mManager.setFinished(mission);\n            handleConnectivityState(false);\n            updateForegroundState(mManager.runMissions());\n            break;\n\n        case MESSAGE_RUNNING:\n            updateForegroundState(true);\n            break;\n\n        case MESSAGE_ERROR:\n            notifyFailedDownload(mission);\n            handleConnectivityState(false);\n            updateForegroundState(mManager.runMissions());\n            break;\n\n        case MESSAGE_PAUSED:\n            updateForegroundState(mManager.getRunningMissionsCount() > 0);\n            break;\n\n        default:\n            break;\n    }\n\n    if (msg.what != MESSAGE_ERROR) {\n        mFailedDownloads.remove(mFailedDownloads.indexOfValue(mission));\n    }\n\n    for (final Callback observer : mEchoObservers) {\n        observer.handleMessage(msg);\n    }\n\n    return true;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "373", "src_id": "M1105", "code": "\nprivate void showError(@NonNull final DownloadMission mission) {\n    @StringRes int msg = R.string.general_error;\n    String msgEx = null;\n\n    switch (mission.errCode) {\n        case 416:\n            msg = R.string.error_http_unsupported_range;\n            break;\n\n        case 404:\n            msg = R.string.error_http_not_found;\n            break;\n\n        case ERROR_NOTHING:\n            return; // this never should happen\n\n        case ERROR_FILE_CREATION:\n            msg = R.string.error_file_creation;\n            break;\n\n        case ERROR_HTTP_NO_CONTENT:\n            msg = R.string.error_http_no_content;\n            break;\n\n        case ERROR_PATH_CREATION:\n            msg = R.string.error_path_creation;\n            break;\n\n        case ERROR_PERMISSION_DENIED:\n            msg = R.string.permission_denied;\n            break;\n\n        case ERROR_SSL_EXCEPTION:\n            msg = R.string.error_ssl_exception;\n            break;\n\n        case ERROR_UNKNOWN_HOST:\n            msg = R.string.error_unknown_host;\n            break;\n\n        case ERROR_CONNECT_HOST:\n            msg = R.string.error_connect_host;\n            break;\n\n        case ERROR_POSTPROCESSING_STOPPED:\n            msg = R.string.error_postprocessing_stopped;\n            break;\n\n        case ERROR_POSTPROCESSING:\n        case ERROR_POSTPROCESSING_HOLD:\n            showError(mission, UserAction.DOWNLOAD_POSTPROCESSING, R.string.error_postprocessing_failed);\n            return;\n\n        case ERROR_INSUFFICIENT_STORAGE:\n            msg = R.string.error_insufficient_storage_left;\n            break;\n\n        case ERROR_UNKNOWN_EXCEPTION:\n            if (mission.errObject != null) {\n                showError(mission, UserAction.DOWNLOAD_FAILED, R.string.general_error);\n                return;\n            } else {\n                msg = R.string.msg_error;\n                break;\n            }\n\n        case ERROR_PROGRESS_LOST:\n            msg = R.string.error_progress_lost;\n            break;\n\n        case ERROR_TIMEOUT:\n            msg = R.string.error_timeout;\n            break;\n\n        case ERROR_RESOURCE_GONE:\n            msg = R.string.error_download_resource_gone;\n            break;\n\n        default:\n            if (mission.errCode >= 100 && mission.errCode < 600) {\n                msgEx = \"HTTP \" + mission.errCode;\n            } else if (mission.errObject == null) {\n                msgEx = \"(not_decelerated_error_code)\";\n            } else {\n                showError(mission, UserAction.DOWNLOAD_FAILED, msg);\n                return;\n            }\n            break;\n    }\n\n    final AlertDialog.Builder builder = new AlertDialog.Builder(mContext);\n\n    if (msgEx != null) {\n        builder.setMessage(msgEx);\n    } else {\n        builder.setMessage(msg);\n    }\n\n    // add report button for non-HTTP errors (range 100-599)\n    if (mission.errObject != null && (mission.errCode < 100 || mission.errCode >= 600)) {\n        @StringRes final int mMsg = msg;\n        builder.setPositiveButton(R.string.error_report_title, (dialog, which) ->\n                showError(mission, UserAction.DOWNLOAD_FAILED, mMsg)\n        );\n    }\n\n    builder.setNegativeButton(R.string.ok, (dialog, which) -> dialog.cancel())\n            .setTitle(mission.storage.getName())\n            .show();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "374", "src_id": "M828", "code": "\nprivate Minf parseMinf(final Box ref) throws IOException {\n    final Minf obj = new Minf();\n\n    Box b;\n    while ((b = untilAnyBox(ref)) != null) {\n        switch (b.type) {\n            case ATOM_DINF:\n                obj.dinf = readFullBox(b);\n                break;\n\n            case ATOM_STBL:\n                obj.stblStsd = parseStbl(b);\n                break;\n\n            case ATOM_VMHD:\n            case ATOM_SMHD:\n                obj.mhd = readFullBox(b);\n                break;\n\n            default:\n                break;\n        }\n        ensure(b);\n    }\n\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "375", "src_id": "M822", "code": "\nprivate Mdia parseMdia(final Box ref) throws IOException {\n    final Mdia obj = new Mdia();\n\n    Box b;\n    while ((b = untilBox(ref, ATOM_MDHD, ATOM_HDLR, ATOM_MINF)) != null) {\n        switch (b.type) {\n            case ATOM_MDHD:\n                obj.mdhd = readFullBox(b);\n\n                // read time scale\n                final ByteBuffer buffer = ByteBuffer.wrap(obj.mdhd);\n                final byte version = buffer.get(8);\n                buffer.position(12 + ((version == 0 ? 4 : 8) * 2));\n                obj.mdhdTimeScale = buffer.getInt();\n                break;\n\n            case ATOM_HDLR:\n                obj.hdlr = parseHdlr(b);\n                break;\n\n            case ATOM_MINF:\n                obj.minf = parseMinf(b);\n                break;\n\n            default:\n                break;\n        }\n        ensure(b);\n    }\n\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "376", "src_id": "M302", "code": "\n@Override\npublic void processResult(int rc, String path, Object ctx, List<String> children) {\n    if (rc != KeeperException.Code.OK.intValue()) {\n        // try it again\n        zk.getChildren(assignmentsNode, true, this, null);\n        return;\n    }\n\n    Map<String, Instance> newList = new HashMap<>();\n    // check for differences\n    Stat stat = new Stat();\n\n    for (String child : children) {\n        Instance i = instances.remove(child);\n        if (i == null) {\n            // Start up a new instance\n            byte[] data = null;\n            String myNode = assignmentsNode + '/' + child;\n\n            for (;;) {\n                try {\n                    data = zk.getData(myNode, true, stat);\n                    break;\n                } catch (NoNodeException e) {\n                    // The node doesn't exist anymore, so skip it\n                    break;\n                } catch (KeeperException e) {\n                    e.printStackTrace();\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n\n            if (data == null) {\n                continue;\n            }\n\n            String instanceSpec = new String(data);\n            int spaceIndex = instanceSpec.indexOf(' ');\n            String clazz;\n            String conf;\n\n            if (spaceIndex == -1) {\n                clazz = instanceSpec;\n                conf = null;\n            } else {\n                clazz = instanceSpec.substring(0, spaceIndex);\n                conf = instanceSpec.substring(spaceIndex + 1);\n            }\n\n            try {\n                Class<?> c = Class.forName(clazz);\n                i = (Instance) c.getConstructor().newInstance();\n                Reporter reporter = new MyReporter(child);\n                i.setReporter(reporter);\n                i.configure(conf);\n                i.start();\n                newList.put(child, i);\n\n                int ver = stat.getVersion();\n                Instance myInstance = i;\n                DataCallback dc = new MyDataCallback(myNode, myInstance, ver);\n                Watcher watcher = new MyWatcher(myNode, dc);\n                zk.getData(myNode, watcher, dc, watcher);\n            } catch (Exception e) {\n                LOG.warn(\"Skipping \" + child, e);\n                if (e.getCause() != null) {\n                    LOG.warn(\"Caused by\", e.getCause());\n                }\n            }\n        } else {\n            // just move it to the new list\n            newList.put(child, i);\n        }\n    }\n\n    // kill anything that was removed for the children\n    for (Map.Entry<String, Instance> e : instances.entrySet()) {\n        e.getValue().stop();\n        try {\n            rmnod(reportsNode + '/' + e.getKey());\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n        } catch (KeeperException ex) {\n            ex.printStackTrace();\n        }\n    }\n    instances = newList;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "377", "src_id": "M219", "code": "\npublic static synchronized ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n    final String connectionId = concat(contextPath, session);\n\n    ZooKeeper zk = zkMap.get(connectionId);\n    if (zk != null) {\n        return zk;\n    }\n\n    if (LOG.isInfoEnabled()) {\n        LOG.info(String.format(\"creating new connection for : '%s'\", connectionId));\n    }\n\n    Endpoint e = contextMap.get(contextPath);\n    zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n    for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n        zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n    }\n\n    zkMap.put(connectionId, zk);\n\n    // a session should automatically expire after an amount of time\n    if (session != null) {\n        zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n    }\n\n    return zk;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "378", "src_id": "M579", "code": "\npublic void dump(PrintWriter pwriter) {\n    pwriter.print(\"Sets (\");\n    pwriter.print(expiryMap.size());\n    pwriter.print(\")/(\");\n    pwriter.print(elemMap.size());\n    pwriter.println(\"):\");\n\n    ArrayList<Long> keys = new ArrayList<>(expiryMap.keySet());\n    Collections.sort(keys);\n\n    for (long time : keys) {\n        Set<E> set = expiryMap.get(time);\n        if (set == null) {\n            continue;\n        }\n\n        pwriter.print(set.size());\n        pwriter.print(\" expire at \");\n        pwriter.print(Time.elapsedTimeToDate(time));\n        pwriter.println(\":\");\n        for (E elem : set) {\n            pwriter.print(\"\\t\");\n            pwriter.println(elem.toString());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "379", "src_id": "M282", "code": "\n@Test\npublic void testSimpleCase() throws Exception {\n    configureServers(serverCount);\n    configureClients(clientCount, SimpleClient.class, getHostPort());\n    Stat stat = new Stat();\n    startServers();\n\n    LOG.debug(\"Connecting to \" + getHostPort());\n    ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n    waitForConnect(zk, 10000);\n    zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n    startClients();\n\n    // Check that all clients connect properly\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            try {\n                byte[] b = zk.getData(\"/simpleCase/\" + i, false, stat);\n                Assert.assertEquals(\"orig\", new String(b));\n            } catch (NoNodeException e) {\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"Max tries exceeded on client \" + i);\n                }\n                Thread.sleep(1000);\n            }\n        }\n    }\n\n    // Kill half the servers, make a change, restart the dead\n    // servers, and then bounce the other servers one by one\n    for (int i = 0; i < getServerCount(); i++) {\n        stopServer(i);\n        if (i + 1 > getServerCount() / 2) {\n            startServer(i);\n        } else if (i + 1 == getServerCount() / 2) {\n            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n            try {\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            } catch (ConnectionLossException e) {\n                Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n            }\n            for (int j = 0; j < i; j++) {\n                LOG.info(\"Starting server \" + j);\n                startServer(i);\n            }\n        }\n    }\n\n    Thread.sleep(100); // wait for things to stabilize\n    Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    try {\n        zk.getData(\"/simpleCase\", false, stat);\n    } catch (ConnectionLossException e) {\n        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n    }\n\n    // check that the change has propagated to everyone\n    for (int i = 0; i < getClientCount(); i++) {\n        for (int j = 0; j < maxTries; j++) {\n            byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n            if (\"new\".equals(new String(data))) {\n                break;\n            }\n            if (j + 1 == maxTries) {\n                Assert.fail(\"max tries exceeded for \" + i);\n            }\n            Thread.sleep(1000);\n        }\n    }\n\n    // send out the kill signal\n    zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n\n    // watch for everyone to die\n    for (int i = 0; i < getClientCount(); i++) {\n        try {\n            for (int j = 0; j < maxTries; j++) {\n                zk.getData(\"/simpleCase/\" + i, false, stat);\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                }\n                Thread.sleep(200);\n            }\n        } catch (NoNodeException e) {\n            // Great this is what we were hoping for!\n        }\n    }\n\n    stopClients();\n    stopServers();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "380", "src_id": "M243", "code": "\npublic void start() throws IOException {\n    System.out.println(\"Starting grizzly ...\");\n\n    boolean useSSL = cfg.useSSL();\n    String zkRestResourcesTempPath = Files.createTempDirectory(\"zkRestResourcesTempPath\")\n            .toFile()\n            .getCanonicalPath();\n    gws = new GrizzlyWebServer(cfg.getPort(), zkRestResourcesTempPath, useSSL);\n    // BUG: Grizzly needs a doc root if you are going to register multiple adapters\n\n    for (Endpoint e : cfg.getEndpoints()) {\n        ZooKeeperService.mapContext(e.getContext(), e);\n        gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });\n    }\n\n    if (useSSL) {\n        System.out.println(\"Starting SSL ...\");\n        String jks = cfg.getJKS(\"keys/rest.jks\");\n        String jksPassword = cfg.getJKSPassword();\n\n        SSLConfig sslConfig = new SSLConfig();\n        URL resource = getClass().getClassLoader().getResource(jks);\n        if (resource == null) {\n            LOG.error(\"Unable to find the keystore file: \" + jks);\n            System.exit(2);\n        }\n        try {\n            sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n        } catch (URISyntaxException e1) {\n            LOG.error(\"Unable to load keystore: \" + jks, e1);\n            System.exit(2);\n        }\n        sslConfig.setKeyStorePass(jksPassword);\n        gws.setSSLConfig(sslConfig);\n    }\n\n    gws.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "381", "src_id": "M186", "code": "\nsynchronized private LogEntry readNextEntry() {\n    try {\n        try {\n            for (;;) {\n                String line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n\n                Matcher m = src.timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (buf.length() > 0) {\n                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n                        buf = line;\n                        return e;\n                    }\n                    buf = line;\n                } else if (buf.length() > 0) {\n                    buf += line + \"\\n\";\n                }\n            }\n        } catch (EOFException eof) {\n            // ignore, we've simply come to the end of the file\n        }\n\n        if (buf.length() > 0) {\n            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n            buf = \"\";\n            return e;\n        }\n    } catch (Exception e) {\n        LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n        return null;\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "382", "src_id": "M286", "code": "\npublic void reconfigureInstance(String name, String params)\n        throws NoAssignmentException, InterruptedException, KeeperException {\n    if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n    }\n    Assigned assigned = instanceToAssignment.get(name);\n    if (assigned == null) {\n        throw new NoAssignmentException();\n    }\n    KeeperException lastException = null;\n    for (int i = 0; i < maxTries; i++) {\n        try {\n            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name,\n                    (\"update \" + params).getBytes(), -1);\n            break;\n        } catch (ConnectionLossException e) {\n            lastException = e;\n        }\n    }\n    if (lastException != null) {\n        throw lastException;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "383", "src_id": "M174", "code": "\nprivate LogEntry readNextEntry() {\n    LogEntry e = null;\n    try {\n        long crcValue;\n        byte[] bytes;\n        try {\n            crcValue = logStream.readLong(\"crcvalue\");\n            bytes = logStream.readBuffer(\"txnEntry\");\n        } catch (EOFException ex) {\n            return null;\n        }\n\n        if (bytes.length == 0) {\n            return null;\n        }\n\n        Checksum crc = new Adler32();\n        crc.update(bytes, 0, bytes.length);\n        if (crcValue != crc.getValue()) {\n            throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n        }\n\n        TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n        TxnHeader hdr = logEntry.getHeader();\n        Record r = logEntry.getTxn();\n\n        switch (hdr.getType()) {\n        case OpCode.createSession: {\n            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n        }\n            break;\n        case OpCode.closeSession: {\n            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n        }\n            break;\n        case OpCode.create:\n            if (r != null) {\n                CreateTxn create = (CreateTxn) r;\n                String path = create.getPath();\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n            }\n            break;\n        case OpCode.setData:\n            if (r != null) {\n                SetDataTxn set = (SetDataTxn) r;\n                String path = set.getPath();\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n            }\n            break;\n        case OpCode.setACL:\n            if (r != null) {\n                SetACLTxn setacl = (SetACLTxn) r;\n                String path = setacl.getPath();\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n            }\n            break;\n        case OpCode.error:\n            if (r != null) {\n                ErrorTxn error = (ErrorTxn) r;\n                e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(),\n                        \"error\", \"Error: \" + error.getErr());\n            }\n            break;\n        default:\n            LOG.info(\"Unknown op: \" + hdr.getType());\n            break;\n        }\n\n        if (logStream.readByte(\"EOR\") != 'B') {\n            throw new EOFException(\"Last transaction was partial.\");\n        }\n    } catch (Exception ex) {\n        LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n        return null;\n    }\n    return e;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "384", "src_id": "M1129", "code": "\npublic synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief) {\n    pwriter.print(\" \");\n    pwriter.print(getRemoteSocketAddress());\n    pwriter.print(\"[\");\n    int interestOps = getInterestOps();\n    pwriter.print(interestOps == 0 ? \"0\" : Integer.toHexString(interestOps));\n    pwriter.print(\"](queued=\");\n    pwriter.print(getOutstandingRequests());\n    pwriter.print(\",recved=\");\n    pwriter.print(getPacketsReceived());\n    pwriter.print(\",sent=\");\n    pwriter.print(getPacketsSent());\n\n    if (!brief) {\n        long sessionId = getSessionId();\n        if (sessionId != 0) {\n            pwriter.print(\",sid=0x\");\n            pwriter.print(Long.toHexString(sessionId));\n            pwriter.print(\",lop=\");\n            pwriter.print(getLastOperation());\n            pwriter.print(\",est=\");\n            pwriter.print(getEstablished().getTime());\n            pwriter.print(\",to=\");\n            pwriter.print(getSessionTimeout());\n            long lastCxid = getLastCxid();\n            if (lastCxid >= 0) {\n                pwriter.print(\",lcxid=0x\");\n                pwriter.print(Long.toHexString(lastCxid));\n            }\n            pwriter.print(\",lzxid=0x\");\n            pwriter.print(Long.toHexString(getLastZxid()));\n            pwriter.print(\",lresp=\");\n            pwriter.print(getLastResponseTime());\n            pwriter.print(\",llat=\");\n            pwriter.print(getLastLatency());\n            pwriter.print(\",minlat=\");\n            pwriter.print(getMinLatency());\n            pwriter.print(\",avglat=\");\n            pwriter.print(getAvgLatency());\n            pwriter.print(\",maxlat=\");\n            pwriter.print(getMaxLatency());\n        }\n    }\n    pwriter.print(\")\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "385", "src_id": "M267", "code": "\nvoid drainLoop() {\n    int missed = 1;\n    Observer<? super R> downstreamObserver = downstream;\n    AtomicInteger activeCount = active;\n    AtomicReference<SpscLinkedArrayQueue<R>> queueRef = queue;\n\n    for (;;) {\n        for (;;) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            if (!delayErrors) {\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    clear();\n                    errors.tryTerminateConsumer(downstreamObserver);\n                    return;\n                }\n            }\n\n            boolean allDone = activeCount.get() == 0;\n            SpscLinkedArrayQueue<R> currentQueue = queueRef.get();\n            R value = currentQueue != null ? currentQueue.poll() : null;\n            boolean isEmpty = value == null;\n\n            if (allDone && isEmpty) {\n                errors.tryTerminateConsumer(downstreamObserver);\n                return;\n            }\n\n            if (isEmpty) {\n                break;\n            }\n\n            downstreamObserver.onNext(value);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "386", "src_id": "M1358", "code": "\n@Override\npublic void onNext(T t) {\n    if (done) {\n        return;\n    }\n\n    boolean match;\n    try {\n        match = predicate.test(t);\n    } catch (Throwable ex) {\n        Exceptions.throwIfFatal(ex);\n        upstream.cancel();\n        upstream = SubscriptionHelper.CANCELLED;\n        onError(ex);\n        return;\n    }\n\n    if (match) {\n        done = true;\n        upstream.cancel();\n        upstream = SubscriptionHelper.CANCELLED;\n        downstream.onSuccess(true);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "387", "src_id": "M683", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    AtomicReference<Object> currentRef = current;\n    Subscriber<? super T> downstreamSubscriber = downstream;\n    Disposable cancelled = disposables;\n\n    for (;;) {\n        if (cancelled.isDisposed()) {\n            currentRef.lazySet(null);\n            return;\n        }\n\n        Object item = currentRef.get();\n\n        if (item != null) {\n            boolean goNextSource;\n            if (item != NotificationLite.COMPLETE) {\n                long p = produced;\n                if (p != requested.get()) {\n                    produced = p + 1;\n                    currentRef.lazySet(null);\n                    goNextSource = true;\n\n                    downstreamSubscriber.onNext((T) item);\n                } else {\n                    goNextSource = false;\n                }\n            } else {\n                goNextSource = true;\n                currentRef.lazySet(null);\n            }\n\n            if (goNextSource && !cancelled.isDisposed()) {\n                int i = index;\n                if (i == sources.length) {\n                    downstreamSubscriber.onComplete();\n                    return;\n                }\n                index = i + 1;\n\n                sources[i].subscribe(this);\n            }\n        }\n\n        if (decrementAndGet() == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "388", "src_id": "M1509", "code": "\n@Override\nvoid runAsync() {\n    int missed = 1;\n\n    Subscriber<? super T> downstreamSubscriber = downstream;\n    SimpleQueue<T> q = queue;\n\n    long e = produced;\n\n    for (;;) {\n\n        long r = requested.get();\n\n        while (e != r) {\n            boolean d = done;\n            T value;\n\n            try {\n                value = q.poll();\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n\n                cancelled = true;\n                upstream.cancel();\n                q.clear();\n\n                downstreamSubscriber.onError(ex);\n                worker.dispose();\n                return;\n            }\n\n            boolean empty = value == null;\n\n            if (checkTerminated(d, empty, downstreamSubscriber)) {\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            downstreamSubscriber.onNext(value);\n\n            e++;\n            if (e == limit) {\n                if (r != Long.MAX_VALUE) {\n                    r = requested.addAndGet(-e);\n                }\n                upstream.request(e);\n                e = 0L;\n            }\n        }\n\n        if (e == r && checkTerminated(done, q.isEmpty(), downstreamSubscriber)) {\n            return;\n        }\n\n        int wip = get();\n        if (missed == wip) {\n            produced = e;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        } else {\n            missed = wip;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "389", "src_id": "M889", "code": "\nvoid drainLoop() {\n    int missed = 1;\n\n    JoinInnerSubscriber<T>[] inners = subscribers;\n    int n = inners.length;\n    Subscriber<? super T> downstreamSubscriber = downstream;\n\n    for (;;) {\n\n        long r = requested.get();\n        long e = 0;\n\n        middle:\n        while (e != r) {\n            if (cancelled) {\n                cleanup();\n                return;\n            }\n\n            boolean allDone = done.get() == 0;\n\n            boolean empty = true;\n\n            for (int i = 0; i < n; i++) {\n                JoinInnerSubscriber<T> inner = inners[i];\n\n                SimplePlainQueue<T> q = inner.queue;\n                if (q != null) {\n                    T value = q.poll();\n\n                    if (value != null) {\n                        empty = false;\n                        downstreamSubscriber.onNext(value);\n                        inner.requestOne();\n                        if (++e == r) {\n                            break middle;\n                        }\n                    }\n                }\n            }\n\n            if (allDone && empty) {\n                errors.tryTerminateConsumer(downstreamSubscriber);\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                cleanup();\n                return;\n            }\n\n            boolean allDone = done.get() == 0;\n\n            boolean empty = true;\n\n            for (int i = 0; i < n; i++) {\n                JoinInnerSubscriber<T> inner = inners[i];\n\n                SimpleQueue<T> q = inner.queue;\n                if (q != null && !q.isEmpty()) {\n                    empty = false;\n                    break;\n                }\n            }\n\n            if (allDone && empty) {\n                errors.tryTerminateConsumer(downstreamSubscriber);\n                return;\n            }\n        }\n\n        if (e != 0) {\n            BackpressureHelper.produced(requested, e);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "390", "src_id": "M1127", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n\n    AtomicReference<T> latestRef = latest;\n    AtomicLong requestedRef = requested;\n    Subscriber<? super T> downstreamSubscriber = downstream;\n\n    for (;;) {\n\n        for (;;) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            boolean isDone = done;\n            Throwable error = this.error;\n\n            if (isDone && error != null) {\n                if (onDropped != null) {\n                    T v = latestRef.getAndSet(null);\n                    if (v != null) {\n                        try {\n                            onDropped.accept(v);\n                        } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            error = new CompositeException(error, ex);\n                        }\n                    }\n                } else {\n                    latestRef.lazySet(null);\n                }\n                downstreamSubscriber.onError(error);\n                worker.dispose();\n                return;\n            }\n\n            T v = latestRef.get();\n            boolean empty = v == null;\n\n            if (isDone) {\n                if (!empty) {\n                    v = latestRef.getAndSet(null);\n                    if (emitLast) {\n                        long emittedCount = emitted;\n                        if (emittedCount != requestedRef.get()) {\n                            emitted = emittedCount + 1;\n                            downstreamSubscriber.onNext(v);\n                            downstreamSubscriber.onComplete();\n                        } else {\n                            tryDropAndSignalMBE(v);\n                        }\n                    } else {\n                        if (onDropped != null) {\n                            try {\n                                onDropped.accept(v);\n                            } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                downstreamSubscriber.onError(ex);\n                                worker.dispose();\n                                return;\n                            }\n                        }\n                        downstreamSubscriber.onComplete();\n                    }\n                } else {\n                    downstreamSubscriber.onComplete();\n                }\n                worker.dispose();\n                return;\n            }\n\n            if (empty) {\n                if (timerFired) {\n                    timerRunning = false;\n                    timerFired = false;\n                }\n                break;\n            }\n\n            if (!timerRunning || timerFired) {\n                v = latestRef.getAndSet(null);\n                long emittedCount = emitted;\n                if (emittedCount != requestedRef.get()) {\n                    downstreamSubscriber.onNext(v);\n                    emitted = emittedCount + 1;\n                } else {\n                    upstream.cancel();\n                    tryDropAndSignalMBE(v);\n                    worker.dispose();\n                    return;\n                }\n\n                timerFired = false;\n                timerRunning = true;\n                worker.schedule(this, timeout, unit);\n            } else {\n                break;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "391", "src_id": "M1003", "code": "\nvoid drain() {\n    if (wip.getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n\n    SimpleQueue<T> q = queue;\n\n    int upstreamConsumed = consumed;\n    int localLimit = limit;\n    boolean canRequest = sourceMode != QueueSubscription.SYNC;\n    AtomicReference<MulticastSubscription<T>[]> subs = subscribers;\n\n    MulticastSubscription<T>[] array = subs.get();\n\n    outer:\n    for (;;) {\n\n        int n = array.length;\n\n        if (q != null && n != 0) {\n            long r = Long.MAX_VALUE;\n\n            for (MulticastSubscription<T> ms : array) {\n                long u = ms.get() - ms.emitted;\n                if (u != Long.MIN_VALUE) {\n                    if (r > u) {\n                        r = u;\n                    }\n                } else {\n                    n--;\n                }\n            }\n\n            if (n == 0) {\n                r = 0;\n            }\n\n            while (r != 0) {\n                if (isDisposed()) {\n                    q.clear();\n                    return;\n                }\n\n                boolean d = done;\n\n                if (d && !delayError) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                        return;\n                    }\n                }\n\n                T v;\n\n                try {\n                    v = q.poll();\n                } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    SubscriptionHelper.cancel(upstream);\n                    errorAll(ex);\n                    return;\n                }\n\n                boolean empty = v == null;\n\n                if (d && empty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                    } else {\n                        completeAll();\n                    }\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                boolean subscribersChange = false;\n\n                for (MulticastSubscription<T> ms : array) {\n                    long msr = ms.get();\n                    if (msr != Long.MIN_VALUE) {\n                        if (msr != Long.MAX_VALUE) {\n                            ms.emitted++;\n                        }\n                        ms.downstream.onNext(v);\n                    } else {\n                        subscribersChange = true;\n                    }\n                }\n\n                r--;\n\n                if (canRequest && ++upstreamConsumed == localLimit) {\n                    upstreamConsumed = 0;\n                    upstream.get().request(localLimit);\n                }\n\n                MulticastSubscription<T>[] freshArray = subs.get();\n                if (subscribersChange || freshArray != array) {\n                    array = freshArray;\n                    continue outer;\n                }\n            }\n\n            if (r == 0) {\n                if (isDisposed()) {\n                    q.clear();\n                    return;\n                }\n\n                boolean d = done;\n\n                if (d && !delayError) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                        return;\n                    }\n                }\n\n                if (d && q.isEmpty()) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        errorAll(ex);\n                    } else {\n                        completeAll();\n                    }\n                    return;\n                }\n            }\n        }\n\n        consumed = upstreamConsumed;\n        missed = wip.addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n        if (q == null) {\n            q = queue;\n        }\n        array = subs.get();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "392", "src_id": "M485", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid subscribeInner(ObservableSource<? extends U> p) {\n    for (;;) {\n        if (p instanceof Supplier) {\n            if (tryEmitScalar(((Supplier<? extends U>) p)) && maxConcurrency != Integer.MAX_VALUE) {\n                boolean empty = false;\n                synchronized (this) {\n                    p = sources.poll();\n                    if (p == null) {\n                        wip--;\n                        empty = true;\n                    }\n                }\n                if (empty) {\n                    drain();\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            InnerObserver<T, U> inner = new InnerObserver<>(this, uniqueId++);\n            if (addInner(inner)) {\n                p.subscribe(inner);\n            }\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "393", "src_id": "M2312", "code": "\n@BackpressureSupport(BackpressureKind.SPECIAL)\n@CheckReturnValue\n@SchedulerSupport(SchedulerSupport.NONE)\n@NonNull\npublic static <@NonNull T> Flowable<T> fromObservable(\n        @NonNull ObservableSource<T> source, @NonNull BackpressureStrategy strategy) {\n    Objects.requireNonNull(source, \"source is null\");\n    Objects.requireNonNull(strategy, \"strategy is null\");\n\n    Flowable<T> flowable = new FlowableFromObservable<>(source);\n    switch (strategy) {\n        case DROP:\n            return flowable.onBackpressureDrop();\n        case LATEST:\n            return flowable.onBackpressureLatest();\n        case MISSING:\n            return flowable;\n        case ERROR:\n            return RxJavaPlugins.onAssembly(new FlowableOnBackpressureError<>(flowable));\n        default:\n            return flowable.onBackpressureBuffer();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "394", "src_id": "M368", "code": "\npublic static <T> void subscribe(ObservableSource<? extends T> o, Observer<? super T> observer) {\n    BlockingQueue<Object> queue = new LinkedBlockingQueue<>();\n\n    BlockingObserver<T> blockingObserver = new BlockingObserver<>(queue);\n    observer.onSubscribe(blockingObserver);\n\n    o.subscribe(blockingObserver);\n    for (;;) {\n        if (blockingObserver.isDisposed()) {\n            break;\n        }\n        Object item = queue.poll();\n        if (item == null) {\n            try {\n                item = queue.take();\n            } catch (InterruptedException ex) {\n                blockingObserver.dispose();\n                observer.onError(ex);\n                return;\n            }\n        }\n        if (blockingObserver.isDisposed()\n                || item == BlockingObserver.TERMINATED\n                || NotificationLite.acceptFull(item, observer)) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "395", "src_id": "M379", "code": "\n@Override\npublic void onTextTracksChanged(@NonNull Tracks currentTracks) {\n    super.onTextTracksChanged(currentTracks);\n\n    boolean trackTypeTextSupported =\n            !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n                    || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n    if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n            || !trackTypeTextSupported) {\n        binding.captionTextView.setVisibility(View.GONE);\n        return;\n    }\n\n    // Extract all loaded languages\n    List<Tracks.Group> textTracks = currentTracks.getGroups()\n            .stream()\n            .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n            .collect(Collectors.toList());\n    List<String> availableLanguages = textTracks.stream()\n            .map(Tracks.Group::getMediaTrackGroup)\n            .filter(textTrack -> textTrack.length > 0)\n            .map(textTrack -> textTrack.getFormat(0).language)\n            .collect(Collectors.toList());\n\n    // Find selected text track\n    Optional<Format> selectedTracks = textTracks.stream()\n            .filter(Tracks.Group::isSelected)\n            .filter(info -> info.getMediaTrackGroup().length >= 1)\n            .map(info -> info.getMediaTrackGroup().getFormat(0))\n            .findFirst();\n\n    // Build UI\n    buildCaptionMenu(availableLanguages);\n    if (player.getTrackSelector().getParameters()\n            .getRendererDisabled(player.getCaptionRendererIndex())\n            || selectedTracks.isEmpty()) {\n        binding.captionTextView.setText(R.string.caption_none);\n    } else {\n        binding.captionTextView.setText(selectedTracks.get().language);\n    }\n    binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "396", "src_id": "M260", "code": "\npublic void play() {\n    if (DEBUG) {\n        Log.d(TAG, \"play() called\");\n    }\n    if (audioReactor == null || playQueue == null || exoPlayerIsNull()) {\n        return;\n    }\n\n    if (!isMuted()) {\n        audioReactor.requestAudioFocus();\n    }\n\n    if (currentState == STATE_COMPLETED) {\n        if (playQueue.getIndex() == 0) {\n            seekToDefault();\n        } else {\n            playQueue.setIndex(0);\n        }\n    }\n\n    simpleExoPlayer.play();\n    saveStreamProgressState();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "397", "src_id": "M887", "code": "\n@Nullable\nstatic String choosePreferredImage(@NonNull List<Image> images,\n                                   PreferredImageQuality nonNoneQuality) {\n    // Used to estimate the pixel count for images where only one of height or width is known\n    double widthOverHeight = images.stream()\n            .filter(image -> image.getHeight() != HEIGHT_UNKNOWN\n                    && image.getWidth() != WIDTH_UNKNOWN)\n            .mapToDouble(image -> ((double) image.getWidth()) / image.getHeight())\n            .findFirst()\n            .orElse(1.0);\n\n    Image.ResolutionLevel preferredLevel = nonNoneQuality.toResolutionLevel();\n    Comparator<Image> initialComparator = Comparator\n            // First, split images into groups of resolution levels\n            .<Image>comparingInt(i -> {\n                if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.UNKNOWN) {\n                    return 3; // avoid unknowns as much as possible\n                } else if (i.getEstimatedResolutionLevel() == preferredLevel) {\n                    return 0; // prefer a matching resolution level\n                } else if (i.getEstimatedResolutionLevel() == Image.ResolutionLevel.MEDIUM) {\n                    return 1; // the preferredLevel is only 1 \"step\" away (either HIGH or LOW)\n                } else {\n                    return 2; // the preferredLevel is the furthest away possible (2 \"steps\")\n                }\n            })\n            // Then, separate by known vs unknown size (prefer known sizes)\n            .thenComparing(image ->\n                    image.getHeight() == HEIGHT_UNKNOWN && image.getWidth() == WIDTH_UNKNOWN);\n\n    // For known sizes, pick the best in each subgroup based on distance to ideal sizes\n    Comparator<Image> finalComparator = switch (nonNoneQuality) {\n        case NONE -> initialComparator; // unreachable\n        case LOW -> initialComparator.thenComparingDouble(image -> {\n            double pixelCount = estimatePixelCount(image, widthOverHeight);\n            return Math.abs(pixelCount - BEST_LOW_H * BEST_LOW_H * widthOverHeight);\n        });\n        case MEDIUM -> initialComparator.thenComparingDouble(image -> {\n            double pixelCount = estimatePixelCount(image, widthOverHeight);\n            return Math.abs(pixelCount - BEST_MEDIUM_H * BEST_MEDIUM_H * widthOverHeight);\n        });\n        case HIGH -> initialComparator.thenComparingDouble(\n                // reversed with a - so that the highest resolution is chosen\n                i -> -estimatePixelCount(i, widthOverHeight));\n    };\n\n    return images.stream()\n            // using \"min\" basically means \"take the first group, then the first subgroup,\n            // then the best image, while ignoring the rest\"\n            .min(finalComparator)\n            .map(Image::getUrl)\n            .orElse(null);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "398", "src_id": "M527", "code": "\n@SuppressLint(\"PrivateResource\") // we currently use Exoplayer's internal strings and icons\n@Nullable\npublic static NotificationActionData fromNotificationActionEnum(\n        @NonNull Player player,\n        @NotificationConstants.Action int selectedAction) {\n\n    int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n    Context ctx = player.getContext();\n\n    switch (selectedAction) {\n        case NotificationConstants.PREVIOUS:\n            return new NotificationActionData(\n                    ACTION_PLAY_PREVIOUS,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_previous_description),\n                    baseActionIcon);\n\n        case NotificationConstants.NEXT:\n            return new NotificationActionData(\n                    ACTION_PLAY_NEXT,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_next_description),\n                    baseActionIcon);\n\n        case NotificationConstants.REWIND:\n            return new NotificationActionData(\n                    ACTION_FAST_REWIND,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_rewind_description),\n                    baseActionIcon);\n\n        case NotificationConstants.FORWARD:\n            return new NotificationActionData(\n                    ACTION_FAST_FORWARD,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                            .exo_controls_fastforward_description),\n                    baseActionIcon);\n\n        case NotificationConstants.SMART_REWIND_PREVIOUS:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PREVIOUS,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_previous_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_previous);\n            } else {\n                return new NotificationActionData(\n                        ACTION_FAST_REWIND,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_rewind_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_rewind);\n            }\n\n        case NotificationConstants.SMART_FORWARD_NEXT:\n            if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                return new NotificationActionData(\n                        ACTION_PLAY_NEXT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_next_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_next);\n            } else {\n                return new NotificationActionData(\n                        ACTION_FAST_FORWARD,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_fastforward_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_fastforward);\n            }\n\n        case NotificationConstants.PLAY_PAUSE_BUFFERING:\n            if (player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PAUSE,\n                        ctx.getString(R.string.notification_action_buffering),\n                        R.drawable.ic_hourglass_top);\n            }\n            // fallthrough\n        case NotificationConstants.PLAY_PAUSE:\n            if (player.getCurrentState() == Player.STATE_COMPLETED) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_pause_description),\n                        R.drawable.ic_replay);\n            } else if (player.isPlaying()\n                    || player.getCurrentState() == Player.STATE_PREFLIGHT\n                    || player.getCurrentState() == Player.STATE_BLOCKED\n                    || player.getCurrentState() == Player.STATE_BUFFERING) {\n                return new NotificationActionData(\n                        ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_pause_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_pause);\n            } else {\n                return new NotificationActionData(\n                        ACTION_PLAY_PAUSE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_play_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_notification_play);\n            }\n\n        case NotificationConstants.REPEAT:\n            if (player.getRepeatMode() == REPEAT_MODE_ALL) {\n                return new NotificationActionData(\n                        ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_repeat_all_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable\n                                .exo_media_action_repeat_all);\n            } else if (player.getRepeatMode() == REPEAT_MODE_ONE) {\n                return new NotificationActionData(\n                        ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_repeat_one_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable\n                                .exo_media_action_repeat_one);\n            } else {\n                return new NotificationActionData(\n                        ACTION_REPEAT,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_repeat_off_description),\n                        com.google.android.exoplayer2.ext.mediasession.R.drawable\n                                .exo_media_action_repeat_off);\n            }\n\n        case NotificationConstants.SHUFFLE:\n            if (player.getPlayQueue() != null && player.getPlayQueue().isShuffled()) {\n                return new NotificationActionData(\n                        ACTION_SHUFFLE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_shuffle_on_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_on);\n            } else {\n                return new NotificationActionData(\n                        ACTION_SHUFFLE,\n                        ctx.getString(com.google.android.exoplayer2.ui.R.string\n                                .exo_controls_shuffle_off_description),\n                        com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_off);\n            }\n\n        case NotificationConstants.CLOSE:\n            return new NotificationActionData(\n                    ACTION_CLOSE,\n                    ctx.getString(R.string.close),\n                    R.drawable.ic_close);\n\n        case NotificationConstants.NOTHING:\n        default:\n            // do nothing\n            return null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "399", "src_id": "M239", "code": "\nprivate void updatePlaybackState(boolean playWhenReady, int playbackState) {\n    if (DEBUG) {\n        Log.d(TAG, \"ExoPlayer - updatePlaybackState() called with: \"\n                + \"playWhenReady = [\" + playWhenReady + \"], \"\n                + \"playbackState = [\" + playbackState + \"]\");\n    }\n\n    if (currentState == STATE_PAUSED_SEEK) {\n        if (DEBUG) {\n            Log.d(TAG, \"updatePlaybackState() is currently blocked\");\n        }\n        return;\n    }\n\n    switch (playbackState) {\n        case com.google.android.exoplayer2.Player.STATE_IDLE: // 1\n            isPrepared = false;\n            break;\n        case com.google.android.exoplayer2.Player.STATE_BUFFERING: // 2\n            if (isPrepared) {\n                changeState(STATE_BUFFERING);\n            }\n            break;\n        case com.google.android.exoplayer2.Player.STATE_READY: // 3\n            if (!isPrepared) {\n                isPrepared = true;\n                onPrepared(playWhenReady);\n            }\n            changeState(playWhenReady ? STATE_PLAYING : STATE_PAUSED);\n            break;\n        case com.google.android.exoplayer2.Player.STATE_ENDED: // 4\n            changeState(STATE_COMPLETED);\n            saveStreamProgressStateCompleted();\n            isPrepared = false;\n            break;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "400", "src_id": "M460", "code": "\npublic MediaDescriptionCompat getQueueMetadata(int index) {\n    if (player.getPlayQueue() == null) {\n        return null;\n    }\n    PlayQueueItem item = player.getPlayQueue().getItem(index);\n    if (item == null) {\n        return null;\n    }\n\n    MediaDescriptionCompat.Builder descBuilder = new MediaDescriptionCompat.Builder()\n            .setMediaId(String.valueOf(index))\n            .setTitle(item.getTitle())\n            .setSubtitle(item.getUploader());\n\n    // Set additional metadata for A2DP/AVRCP (Audio/Video Bluetooth profiles)\n    Bundle additionalMetadata = new Bundle();\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_TITLE, item.getTitle());\n    additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_ARTIST, item.getUploader());\n    additionalMetadata.putLong(\n            MediaMetadataCompat.METADATA_KEY_DURATION, item.getDuration() * 1000);\n    additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, index + 1L);\n    additionalMetadata.putLong(\n            MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, player.getPlayQueue().size());\n    descBuilder.setExtras(additionalMetadata);\n\n    try {\n        descBuilder.setIconUri(\n                Uri.parse(ImageStrategy.choosePreferredImage(item.getThumbnails())));\n    } catch (Throwable e) {\n        // No thumbnail available, or user disabled image loading, or the obtained URL is invalid\n    }\n\n    return descBuilder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "401", "src_id": "M243", "code": "\npublic void changeState(int state) {\n    if (DEBUG) {\n        Log.d(TAG, \"changeState() called with: state = [\" + state + \"]\");\n    }\n    currentState = state;\n    switch (state) {\n        case STATE_BLOCKED:\n            onBlocked();\n            break;\n        case STATE_PLAYING:\n            onPlaying();\n            break;\n        case STATE_BUFFERING:\n            onBuffering();\n            break;\n        case STATE_PAUSED:\n            onPaused();\n            break;\n        case STATE_PAUSED_SEEK:\n            onPausedSeek();\n            break;\n        case STATE_COMPLETED:\n            onCompleted();\n            break;\n    }\n    notifyPlaybackUpdateToListeners();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "402", "src_id": "M543", "code": "\nprivate synchronized NotificationCompat.Builder createNotification() {\n    if (DEBUG) {\n        Log.d(TAG, \"createNotification()\");\n    }\n    notificationManager = NotificationManagerCompat.from(player.getContext());\n    NotificationCompat.Builder builder = new NotificationCompat.Builder(\n            player.getContext(),\n            player.getContext().getString(R.string.notification_channel_id));\n    MediaStyle mediaStyle = new MediaStyle();\n\n    // Setup media style (compact notification slots and media session)\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n        // Notification actions are ignored on Android 13+, replaced by code in MediaSessionPlayerUi\n        int[] compactSlots = initializeNotificationSlots();\n        mediaStyle.setShowActionsInCompactView(compactSlots);\n    }\n    player.UIs()\n            .get(MediaSessionPlayerUi.class)\n            .flatMap(MediaSessionPlayerUi::getSessionToken)\n            .ifPresent(mediaStyle::setMediaSession);\n\n    // Setup notification builder\n    builder.setStyle(mediaStyle)\n            .setPriority(NotificationCompat.PRIORITY_HIGH)\n            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n            .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n            .setShowWhen(false)\n            .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n            .setColor(ContextCompat.getColor(player.getContext(), R.color.dark_background_color))\n            .setColorized(player.getPrefs().getBoolean(\n                    player.getContext().getString(R.string.notification_colorize_key), true))\n            .setDeleteIntent(PendingIntentCompat.getBroadcast(\n                    player.getContext(),\n                    NOTIFICATION_ID,\n                    new Intent(ACTION_CLOSE),\n                    FLAG_UPDATE_CURRENT,\n                    false));\n\n    // Set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n    setLargeIcon(builder);\n\n    return builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "403", "src_id": "M491", "code": "\n@SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n@ResizeMode\npublic static int nextResizeModeAndSaveToPrefs(Player player, @ResizeMode int resizeMode) {\n    int newResizeMode;\n    switch (resizeMode) {\n        case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n        default:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n            break;\n    }\n\n    // Save the new resize mode so it can be restored in a future session\n    player.getPrefs().edit().putInt(\n            player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n    return newResizeMode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "404", "src_id": "M703", "code": "\n@Override\nprotected Supplier<View> getListHeaderSupplier() {\n    return () -> {\n        CommentRepliesHeaderBinding binding = CommentRepliesHeaderBinding\n                .inflate(activity.getLayoutInflater(), itemsList, false);\n        CommentsInfoItem item = commentsInfoItem;\n\n        // Load the author avatar\n        PicassoHelper.loadAvatar(item.getUploaderAvatars()).into(binding.authorAvatar);\n        binding.authorAvatar.setVisibility(\n                ImageStrategy.shouldLoadImages() ? View.VISIBLE : View.GONE);\n\n        // Setup author name and comment date\n        binding.authorName.setText(item.getUploaderName());\n        binding.uploadDate.setText(\n                Localization.relativeTimeOrTextual(\n                        getContext(), item.getUploadDate(), item.getTextualUploadDate()));\n        binding.authorTouchArea.setOnClickListener(\n                v -> NavigationHelper.openCommentAuthorIfPresent(requireActivity(), item));\n\n        // Setup like count, hearted and pinned\n        binding.thumbsUpCount.setText(\n                Localization.likeCount(requireContext(), item.getLikeCount()));\n        // For heartImage goneMarginEnd was used, but there is no way to tell ConstraintLayout\n        // not to use a different margin only when both the next two views are gone\n        ((ConstraintLayout.LayoutParams) binding.thumbsUpCount.getLayoutParams())\n                .setMarginEnd(DeviceUtils.dpToPx(\n                        (item.isHeartedByUploader() || item.isPinned() ? 8 : 16),\n                        requireContext()));\n        binding.heartImage.setVisibility(item.isHeartedByUploader() ? View.VISIBLE : View.GONE);\n        binding.pinnedImage.setVisibility(item.isPinned() ? View.VISIBLE : View.GONE);\n\n        // Setup comment content\n        TextLinkifier.fromDescription(\n                binding.commentContent,\n                item.getCommentText(),\n                HtmlCompat.FROM_HTML_MODE_LEGACY,\n                getServiceById(item.getServiceId()),\n                item.getUrl(),\n                disposables,\n                null);\n        binding.commentContent.setMovementMethod(LongPressLinkMovementMethod.getInstance());\n        return binding.getRoot();\n    };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "405", "src_id": "M2204", "code": "\n@Override\nprotected void subscribeActual(final MaybeObserver<? super T> observer) {\n    final MaybeDisposable<T> md = new MaybeDisposable<>(observer, this);\n    observer.onSubscribe(md);\n    if (add(md)) {\n        if (md.isDisposed()) {\n            remove(md);\n        }\n    } else {\n        final Throwable ex = error;\n        if (ex != null) {\n            observer.onError(ex);\n        } else {\n            final T v = value;\n            if (v == null) {\n                observer.onComplete();\n            } else {\n                observer.onSuccess(v);\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "406", "src_id": "M919", "code": "\n@Override\nprotected void subscribeActual(final CompletableObserver observer) {\n    final Disposable d = Disposable.empty();\n    observer.onSubscribe(d);\n    if (!d.isDisposed()) {\n        try {\n            run.run();\n        } catch (final Throwable e) {\n            Exceptions.throwIfFatal(e);\n            if (!d.isDisposed()) {\n                observer.onError(e);\n            } else {\n                RxJavaPlugins.onError(e);\n            }\n            return;\n        }\n        if (!d.isDisposed()) {\n            observer.onComplete();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "407", "src_id": "M352", "code": "\n@Override\npublic void onNext(final T value) {\n    if (upstream == DisposableHelper.DISPOSED) {\n        return;\n    }\n\n    final Iterator<? extends R> it;\n\n    try {\n        it = mapper.apply(value).iterator();\n    } catch (final Throwable ex) {\n        Exceptions.throwIfFatal(ex);\n        upstream.dispose();\n        onError(ex);\n        return;\n    }\n\n    final Observer<? super R> a = downstream;\n\n    for (;;) {\n        final boolean b;\n\n        try {\n            b = it.hasNext();\n        } catch (final Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            upstream.dispose();\n            onError(ex);\n            return;\n        }\n\n        if (b) {\n            final R v;\n\n            try {\n                v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n            } catch (final Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                upstream.dispose();\n                onError(ex);\n                return;\n            }\n\n            a.onNext(v);\n        } else {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "408", "src_id": "M874", "code": "\n@Override\npublic boolean tryOnNext(final T t) {\n    if (!done) {\n        long retries = 0L;\n\n        for (;;) {\n            final boolean b;\n\n            try {\n                b = predicate.test(t);\n            } catch (final Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n\n                final ParallelFailureHandling h;\n\n                try {\n                    h = Objects.requireNonNull(\n                            errorHandler.apply(++retries, ex),\n                            \"The errorHandler returned a null ParallelFailureHandling\"\n                    );\n                } catch (final Throwable exc) {\n                    Exceptions.throwIfFatal(exc);\n                    cancel();\n                    onError(new CompositeException(ex, exc));\n                    return false;\n                }\n\n                switch (h) {\n                    case RETRY:\n                        continue;\n                    case SKIP:\n                        return false;\n                    case STOP:\n                        cancel();\n                        onComplete();\n                        return false;\n                    default:\n                        cancel();\n                        onError(ex);\n                        return false;\n                }\n            }\n\n            return b && downstream.tryOnNext(t);\n        }\n    }\n    return false;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "409", "src_id": "M2235", "code": "\n@Override\n@NonNull\npublic synchronized Throwable getCause() { // NOPMD\n    if (cause == null) {\n        final String separator = System.getProperty(\"line.separator\");\n        if (exceptions.size() > 1) {\n            final Map<Throwable, Boolean> seenCauses = new IdentityHashMap<>();\n\n            final StringBuilder aggregateMessage = new StringBuilder();\n            aggregateMessage.append(\"Multiple exceptions (\")\n                    .append(exceptions.size())\n                    .append(\")\")\n                    .append(separator);\n\n            for (Throwable inner : exceptions) {\n                int depth = 0;\n                while (inner != null) {\n                    for (int i = 0; i < depth; i++) {\n                        aggregateMessage.append(\"  \");\n                    }\n                    aggregateMessage.append(\"|-- \");\n                    aggregateMessage.append(inner.getClass().getCanonicalName()).append(\": \");\n                    final String innerMessage = inner.getMessage();\n                    if (innerMessage != null && innerMessage.contains(separator)) {\n                        aggregateMessage.append(separator);\n                        for (final String line : innerMessage.split(separator)) {\n                            for (int i = 0; i < depth + 2; i++) {\n                                aggregateMessage.append(\"  \");\n                            }\n                            aggregateMessage.append(line).append(separator);\n                        }\n                    } else {\n                        aggregateMessage.append(innerMessage);\n                        aggregateMessage.append(separator);\n                    }\n\n                    for (int i = 0; i < depth + 2; i++) {\n                        aggregateMessage.append(\"  \");\n                    }\n                    final StackTraceElement[] st = inner.getStackTrace();\n                    if (st.length > 0) {\n                        aggregateMessage.append(\"at \").append(st[0]).append(separator);\n                    }\n\n                    if (!seenCauses.containsKey(inner)) {\n                        seenCauses.put(inner, true);\n\n                        inner = inner.getCause();\n                        depth++;\n                    } else {\n                        inner = inner.getCause();\n                        if (inner != null) {\n                            for (int i = 0; i < depth + 2; i++) {\n                                aggregateMessage.append(\"  \");\n                            }\n                            aggregateMessage.append(\"|-- \");\n                            aggregateMessage.append(\"(cause not expanded again) \");\n                            aggregateMessage.append(inner.getClass().getCanonicalName()).append(\": \");\n                            aggregateMessage.append(inner.getMessage());\n                            aggregateMessage.append(separator);\n                        }\n                        break;\n                    }\n                }\n            }\n\n            cause = new ExceptionOverview(aggregateMessage.toString().trim());\n        } else {\n            cause = exceptions.get(0);\n        }\n    }\n    return cause;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "410", "src_id": "M1389", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    final Deque<T> dq = deque;\n    final Subscriber<? super T> a = downstream;\n    for (;;) {\n        final long r = requested.get();\n        long e = 0L;\n        while (e != r) {\n            if (cancelled) {\n                clear(dq);\n                return;\n            }\n\n            final boolean d = done;\n\n            final T v;\n\n            synchronized (dq) {\n                v = dq.poll();\n            }\n\n            final boolean empty = v == null;\n\n            if (d) {\n                final Throwable ex = error;\n                if (ex != null) {\n                    clear(dq);\n                    a.onError(ex);\n                    return;\n                }\n                if (empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n\n            if (empty) {\n                break;\n            }\n\n            a.onNext(v);\n\n            e++;\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                clear(dq);\n                return;\n            }\n\n            final boolean d = done;\n\n            final boolean empty;\n\n            synchronized (dq) {\n                empty = dq.isEmpty();\n            }\n\n            if (d) {\n                final Throwable ex = error;\n                if (ex != null) {\n                    clear(dq);\n                    a.onError(ex);\n                    return;\n                }\n                if (empty) {\n                    a.onComplete();\n                    return;\n                }\n            }\n        }\n\n        if (e != 0L) {\n            BackpressureHelper.produced(requested, e);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "411", "src_id": "M243", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n\n    final AtomicReference<T> latest = this.latest;\n    final Observer<? super T> downstream = this.downstream;\n\n    for (;;) {\n\n        for (;;) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            final boolean d = done;\n            Throwable error = this.error;\n\n            if (d && error != null) {\n                if (onDropped != null) {\n                    final T v = latest.getAndSet(null);\n                    if (v != null) {\n                        try {\n                            onDropped.accept(v);\n                        } catch (final Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            error = new CompositeException(error, ex);\n                        }\n                    }\n                } else {\n                    latest.lazySet(null);\n                }\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n\n            T v = latest.get();\n            final boolean empty = v == null;\n\n            if (d) {\n                if (!empty) {\n                    v = latest.getAndSet(null);\n                    if (emitLast) {\n                        downstream.onNext(v);\n                    } else {\n                        if (onDropped != null) {\n                            try {\n                                onDropped.accept(v);\n                            } catch (final Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                downstream.onError(ex);\n                                worker.dispose();\n                                return;\n                            }\n                        }\n                    }\n                }\n                downstream.onComplete();\n                worker.dispose();\n                return;\n            }\n\n            if (empty) {\n                if (timerFired) {\n                    timerRunning = false;\n                    timerFired = false;\n                }\n                break;\n            }\n\n            if (!timerRunning || timerFired) {\n                v = latest.getAndSet(null);\n                downstream.onNext(v);\n\n                timerFired = false;\n                timerRunning = true;\n                worker.schedule(this, timeout, unit);\n            } else {\n                break;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "412", "src_id": "M1127", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n\n    final AtomicReference<T> latest = this.latest;\n    final AtomicLong requested = this.requested;\n    final Subscriber<? super T> downstream = this.downstream;\n\n    for (;;) {\n\n        for (;;) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            final boolean d = done;\n            Throwable error = this.error;\n\n            if (d && error != null) {\n                if (onDropped != null) {\n                    final T v = latest.getAndSet(null);\n                    if (v != null) {\n                        try {\n                            onDropped.accept(v);\n                        } catch (final Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            error = new CompositeException(error, ex);\n                        }\n                    }\n                } else {\n                    latest.lazySet(null);\n                }\n                downstream.onError(error);\n                worker.dispose();\n                return;\n            }\n\n            T v = latest.get();\n            final boolean empty = v == null;\n\n            if (d) {\n                if (!empty) {\n                    v = latest.getAndSet(null);\n                    if (emitLast) {\n                        final long e = emitted;\n                        if (e != requested.get()) {\n                            emitted = e + 1;\n                            downstream.onNext(v);\n                            downstream.onComplete();\n                        } else {\n                            tryDropAndSignalMBE(v);\n                        }\n                    } else {\n                        if (onDropped != null) {\n                            try {\n                                onDropped.accept(v);\n                            } catch (final Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                downstream.onError(ex);\n                                worker.dispose();\n                                return;\n                            }\n                        }\n                        downstream.onComplete();\n                    }\n                } else {\n                    downstream.onComplete();\n                }\n                worker.dispose();\n                return;\n            }\n\n            if (empty) {\n                if (timerFired) {\n                    timerRunning = false;\n                    timerFired = false;\n                }\n                break;\n            }\n\n            if (!timerRunning || timerFired) {\n                v = latest.getAndSet(null);\n                final long e = emitted;\n                if (e != requested.get()) {\n                    downstream.onNext(v);\n                    emitted = e + 1;\n                } else {\n                    upstream.cancel();\n                    tryDropAndSignalMBE(v);\n                    worker.dispose();\n                    return;\n                }\n\n                timerFired = false;\n                timerRunning = true;\n                worker.schedule(this, timeout, unit);\n            } else {\n                break;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "413", "src_id": "M1902", "code": "\n@Override\nprotected void subscribeActual(final Subscriber<? super R> s) {\n    if (source instanceof Supplier) {\n        Stream<? extends R> stream = null;\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T t = ((Supplier<T>) source).get();\n            if (t != null) {\n                stream = Objects.requireNonNull(\n                        mapper.apply(t),\n                        \"The mapper returned a null Stream\"\n                );\n            }\n        } catch (final Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            EmptySubscription.error(ex, s);\n            return;\n        }\n\n        if (stream != null) {\n            FlowableFromStream.subscribeStream(s, stream);\n        } else {\n            EmptySubscription.complete(s);\n        }\n    } else {\n        source.subscribe(subscribe(s, mapper, prefetch));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "414", "src_id": "M1455", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    long e = emitted;\n    final Subscriber<? super C> a = downstream;\n    final SpscLinkedArrayQueue<C> q = queue;\n\n    for (;;) {\n        final long r = requested.get();\n\n        while (e != r) {\n            if (cancelled) {\n                q.clear();\n                return;\n            }\n\n            final boolean d = done;\n            if (d && errors.get() != null) {\n                q.clear();\n                errors.tryTerminateConsumer(a);\n                return;\n            }\n\n            final C v = q.poll();\n            final boolean empty = v == null;\n\n            if (d && empty) {\n                a.onComplete();\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            a.onNext(v);\n            e++;\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                q.clear();\n                return;\n            }\n\n            if (done) {\n                if (errors.get() != null) {\n                    q.clear();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                } else if (q.isEmpty()) {\n                    a.onComplete();\n                    return;\n                }\n            }\n        }\n\n        emitted = e;\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "415", "src_id": "M676", "code": "\n@SuppressWarnings(\"unchecked\")\nvoid done() {\n    if (decrementAndGet() != 0) {\n        return;\n    }\n\n    final Object o1 = observer1.value;\n    final Object o2 = observer2.value;\n\n    if (o1 != null && o2 != null) {\n        boolean b;\n        try {\n            b = isEqual.test((T) o1, (T) o2);\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            downstream.onError(ex);\n            return;\n        }\n        downstream.onSuccess(b);\n        return;\n    }\n\n    downstream.onSuccess(o1 == null && o2 == null);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "416", "src_id": "M275", "code": "\n@Override\npublic void subscribe(Observer<? super T> observer) {\n    for (; ; ) {\n        final int s = once.get();\n        if ((s & HAS_SUBSCRIBER) != 0) {\n            break;\n        }\n        final int u = s | HAS_SUBSCRIBER;\n        if (once.compareAndSet(s, u)) {\n            observer.onSubscribe(this);\n            actual.lazySet(observer);\n            if (cancelled.get()) {\n                actual.lazySet(null);\n            } else {\n                drain();\n            }\n            return;\n        }\n    }\n    EmptyDisposable.error(new IllegalStateException(\"Only one Observer allowed!\"), observer);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "417", "src_id": "M1571", "code": "\n@Override\npublic void onSuccess(T value) {\n    final Observer<? super R> a = downstream;\n    Iterator<? extends R> iterator;\n    boolean has;\n    try {\n        iterator = mapper.apply(value).iterator();\n        has = iterator.hasNext();\n    } catch (Throwable ex) {\n        Exceptions.throwIfFatal(ex);\n        downstream.onError(ex);\n        return;\n    }\n\n    if (!has) {\n        a.onComplete();\n        return;\n    }\n\n    if (outputFused) {\n        it = iterator;\n        a.onNext(null);\n        a.onComplete();\n        return;\n    }\n\n    for (; ; ) {\n        if (cancelled) {\n            return;\n        }\n\n        R v;\n        try {\n            v = iterator.next();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            a.onError(ex);\n            return;\n        }\n\n        a.onNext(v);\n\n        if (cancelled) {\n            return;\n        }\n\n        boolean b;\n        try {\n            b = iterator.hasNext();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            a.onError(ex);\n            return;\n        }\n\n        if (!b) {\n            a.onComplete();\n            return;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "418", "src_id": "M1183", "code": "\n@Override\nvoid fastPath() {\n    final Iterator<? extends T> it = this.iterator;\n    final ConditionalSubscriber<? super T> a = downstream;\n\n    for (; ; ) {\n        if (cancelled) {\n            return;\n        }\n\n        T t;\n        try {\n            t = it.next();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            a.onError(ex);\n            return;\n        }\n\n        if (cancelled) {\n            return;\n        }\n\n        if (t == null) {\n            a.onError(new NullPointerException(\"Iterator.next() returned a null value\"));\n            return;\n        }\n\n        a.tryOnNext(t);\n\n        if (cancelled) {\n            return;\n        }\n\n        boolean b;\n        try {\n            b = it.hasNext();\n        } catch (Throwable ex) {\n            Exceptions.throwIfFatal(ex);\n            a.onError(ex);\n            return;\n        }\n\n        if (!b) {\n            if (!cancelled) {\n                a.onComplete();\n            }\n            return;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "419", "src_id": "M1995", "code": "\nstatic <T> boolean postCompleteDrain(\n        long n,\n        Subscriber<? super T> actual,\n        Queue<T> queue,\n        AtomicLong state,\n        BooleanSupplier isCancelled) {\n\n// TODO enable fast-path\n//        if (n == -1 || n == Long.MAX_VALUE) {\n//            for (; ; ) {\n//                if (isCancelled.getAsBoolean()) {\n//                    break;\n//                }\n//\n//                T v = queue.poll();\n//\n//                if (v == null) {\n//                    actual.onComplete();\n//                    break;\n//                }\n//\n//                actual.onNext(v);\n//            }\n//\n//            return true;\n//        }\n\n    long e = n & COMPLETED_MASK;\n\n    for (; ; ) {\n\n        while (e != n) {\n            if (isCancelled(isCancelled)) {\n                return true;\n            }\n\n            T t = queue.poll();\n\n            if (t == null) {\n                actual.onComplete();\n                return true;\n            }\n\n            actual.onNext(t);\n            e++;\n        }\n\n        if (isCancelled(isCancelled)) {\n            return true;\n        }\n\n        if (queue.isEmpty()) {\n            actual.onComplete();\n            return true;\n        }\n\n        n = state.get();\n\n        if (n == e) {\n            n = state.addAndGet(-(e & REQUESTED_MASK));\n            if ((n & REQUESTED_MASK) == 0L) {\n                return false;\n            }\n            e = n & COMPLETED_MASK;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "420", "src_id": "M1315", "code": "\nvoid drainLoop() {\n    int missed = 1;\n    final Subscriber<? super R> a = downstream;\n    final AtomicInteger n = active;\n    final AtomicReference<SpscLinkedArrayQueue<R>> qr = queue;\n\n    for (; ; ) {\n        long r = requested.get();\n        long e = 0L;\n\n        while (e != r) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            if (!delayErrors) {\n                final Throwable ex = errors.get();\n                if (ex != null) {\n                    clear();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n            }\n\n            final boolean d = n.get() == 0;\n            final SpscLinkedArrayQueue<R> q = qr.get();\n            final R v = q != null ? q.poll() : null;\n            final boolean empty = v == null;\n\n            if (d && empty) {\n                errors.tryTerminateConsumer(a);\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            a.onNext(v);\n\n            e++;\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                clear();\n                return;\n            }\n\n            if (!delayErrors) {\n                final Throwable ex = errors.get();\n                if (ex != null) {\n                    clear();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n            }\n\n            final boolean d = n.get() == 0;\n            final SpscLinkedArrayQueue<R> q = qr.get();\n            final boolean empty = q == null || q.isEmpty();\n\n            if (d && empty) {\n                errors.tryTerminateConsumer(a);\n                return;\n            }\n        }\n\n        if (e != 0L) {\n            BackpressureHelper.produced(requested, e);\n            if (maxConcurrency != Integer.MAX_VALUE) {\n                upstream.request(e);\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "421", "src_id": "M856", "code": "\nvoid drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n\n    int missed = 1;\n    final Subscriber<? super T> a = downstream;\n    final List<T>[] lists = this.lists;\n    final int[] indexes = this.indexes;\n    final int n = indexes.length;\n\n    for (; ; ) {\n        long r = requested.get();\n        long e = 0L;\n\n        while (e != r) {\n            if (cancelled) {\n                Arrays.fill(lists, null);\n                return;\n            }\n\n            final Throwable ex = error.get();\n            if (ex != null) {\n                cancelAll();\n                Arrays.fill(lists, null);\n                a.onError(ex);\n                return;\n            }\n\n            T min = null;\n            int minIndex = -1;\n\n            for (int i = 0; i < n; i++) {\n                final List<T> list = lists[i];\n                final int index = indexes[i];\n\n                if (list.size() != index) {\n                    if (min == null) {\n                        min = list.get(index);\n                        minIndex = i;\n                    } else {\n                        final T b;\n                        try {\n                            b = list.get(index);\n                            final boolean smaller = comparator.compare(min, b) > 0;\n                            if (smaller) {\n                                min = b;\n                                minIndex = i;\n                            }\n                        } catch (Throwable exc) {\n                            Exceptions.throwIfFatal(exc);\n                            cancelAll();\n                            Arrays.fill(lists, null);\n                            if (!error.compareAndSet(null, exc)) {\n                                RxJavaPlugins.onError(exc);\n                            }\n                            a.onError(error.get());\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if (min == null) {\n                Arrays.fill(lists, null);\n                a.onComplete();\n                return;\n            }\n\n            a.onNext(min);\n            indexes[minIndex]++;\n\n            e++;\n        }\n\n        if (cancelled) {\n            Arrays.fill(lists, null);\n            return;\n        }\n\n        final Throwable ex = error.get();\n        if (ex != null) {\n            cancelAll();\n            Arrays.fill(lists, null);\n            a.onError(ex);\n            return;\n        }\n\n        boolean empty = true;\n        for (int i = 0; i < n; i++) {\n            if (indexes[i] != lists[i].size()) {\n                empty = false;\n                break;\n            }\n        }\n\n        if (empty) {\n            Arrays.fill(lists, null);\n            a.onComplete();\n            return;\n        }\n\n        if (e != 0L) {\n            BackpressureHelper.produced(requested, e);\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "422", "src_id": "M1224", "code": "\nvoid drainLoop() {\n    final Subscriber<? super T> actual = this.downstream;\n    int missed = 1;\n    long e = emitted;\n    int c = consumed;\n    final int lim = limit;\n\n    for (; ; ) {\n        final long r = requested.get();\n\n        while (e != r) {\n            if (cancelled) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            int os = otherState;\n            if (os == OTHER_STATE_HAS_VALUE) {\n                T v = singleItem;\n                singleItem = null;\n                otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                actual.onNext(v);\n\n                e++;\n                continue;\n            }\n\n            final boolean d = mainDone;\n            final SimplePlainQueue<T> q = queue;\n            final T v = q != null ? q.poll() : null;\n            final boolean empty = v == null;\n\n            if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                queue = null;\n                actual.onComplete();\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n\n            actual.onNext(v);\n\n            e++;\n\n            if (++c == lim) {\n                c = 0;\n                mainSubscription.get().request(lim);\n            }\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                singleItem = null;\n                queue = null;\n                return;\n            }\n\n            if (errors.get() != null) {\n                singleItem = null;\n                queue = null;\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            final boolean d = mainDone;\n            final SimplePlainQueue<T> q = queue;\n            final boolean empty = q == null || q.isEmpty();\n\n            if (d && empty && otherState == 2) {\n                queue = null;\n                actual.onComplete();\n                return;\n            }\n        }\n\n        emitted = e;\n        consumed = c;\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "423", "src_id": "M2134", "code": "\n@SuppressWarnings(\"unchecked\")\n@NonNull\npublic final U assertValueAt(int index, @NonNull Predicate<T> valuePredicate) {\n    final int s = values.size();\n    if (s == 0) {\n        throw fail(\"No values\");\n    }\n\n    if (index < 0 || index >= s) {\n        throw fail(\"Index \" + index + \" is out of range [0, \" + s + \")\");\n    }\n\n    boolean found = false;\n\n    final T v = values.get(index);\n    try {\n        if (valuePredicate.test(v)) {\n            found = true;\n        }\n    } catch (Throwable ex) {\n        throw ExceptionHelper.wrapOrThrow(ex);\n    }\n\n    if (!found) {\n        throw fail(\"Value \" + valueAndClass(v) + \" at position \" + index + \" did not pass the predicate\");\n    }\n    return (U) this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "424", "src_id": "M2722", "code": "\n@Override\npublic void onSubscribe(@NonNull Subscription s) {\n    if (SubscriptionHelper.validate(this.upstream, s)) {\n        this.upstream = s;\n        try {\n            downstream.onSubscribe(this);\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            done = true;\n            // can't call onError because the actual's state may be corrupt at this point\n            try {\n                s.cancel();\n            } catch (Throwable e1) {\n                Exceptions.throwIfFatal(e1);\n                RxJavaPlugins.onError(new CompositeException(e, e1));\n                return;\n            }\n            RxJavaPlugins.onError(e);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}

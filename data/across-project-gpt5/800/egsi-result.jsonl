{"project_name": "across-project", "pair_id": "367", "src_id": "M1148", "code": "    @Override\n    public void seek(long offset) throws IOException {\n\n        long total = out.length + aux.length;\n        if (offset == total) {\n\n            // do not ignore the seek offset if a underflow exists\n            long relativeOffset = out.getOffset() + aux.getOffset();\n            if (relativeOffset == total) {\n                return;\n            }\n        }\n        // flush everything, avoid any underflow\n        flush();\n        if (offset < 0 || offset > total) {\n            throw new IOException(\"desired offset is outside of range=0-\" + total + \" offset=\" + offset);\n        }\n\n        if (offset > out.length) {\n            out.seek(out.length);\n            aux.seek(offset - out.length);\n        } else {\n            out.seek(offset);\n            aux.seek(0);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "368", "src_id": "M1079", "code": "    boolean runMissions() {\n        synchronized (this) {\n            if (mMissionsPending.size() < 1) {\n                return false;\n            }\n            if (!canDownloadInCurrentNetwork()) {\n                return false;\n            }\n            if (mPrefQueueLimit) {\n                for (DownloadMission mission:mMissionsPending) {\n\n                    if (!mission.isFinished() && mission.running) {\n                        return true;\n                    }\n                }\n            }\n\n            boolean flag = false;\n\n            for (DownloadMission mission:mMissionsPending) {\n                if (!(mission.running || !mission.enqueued || mission.isFinished())) { \n                    resumeMission(mission);\n                    if (mission.errCode != DownloadMission.ERROR_NOTHING) continue;\n                    if (mPrefQueueLimit) return true;\n                    flag = true;\n                } \n            }\n\n            return flag;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "369", "src_id": "M883", "code": "    private void makeMvhd(final long longestTrack) throws IOException {\n        auxWrite(new byte[]{0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00});\n        auxWrite(ByteBuffer.allocate(28).putLong(time)\n                .putLong(time)\n                .putInt(DEFAULT_TIMESCALE)\n                .putLong(longestTrack)\n                .array());\n        auxWrite(new byte[]{0x00, 0x01, 0x00, 0x00, 0x01, 0x00, // default volume and rate\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved values\n        // default matrix\n        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00});\n        auxWrite(new byte[24]); // predefined\n\n        auxWrite(ByteBuffer.allocate(4).putInt(tracks.length + 1).array());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "370", "src_id": "M1037", "code": "    public void pause() {\n        if (!running) {\n            return;\n        }\n        if (isPsRunning()) {\n            if (DEBUG) {\n                Log.w(TAG, \"pause during post-processing is not applicable.\");\n            }\n            return;\n        }\n        running = false;\n        notify(DownloadManagerService.MESSAGE_PAUSED);\n        if (init != null && init.isAlive()) {\n            // NOTE: if start() method is running Â¡will no have effect!\n            init.interrupt();\n            synchronized (LOCK) {\n                resetState(false, true, ERROR_NOTHING);\n            }\n            return;\n        }\n\n        if (DEBUG && unknownLength) {\n            Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n        }\n        init = null;\n        pauseThreads();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "371", "src_id": "M1043", "code": "    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n                Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n                if (err instanceof InterruptedIOException \n                             || err instanceof ClosedByInterruptException \n                             || thread.isInterrupted()) {\n                    notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                    return;\n                }\n\n                if (errCode == ERROR_NOTHING) {\n                    errCode = ERROR_POSTPROCESSING;\n                }\n                exception = err;\n            } finally {\n                notifyPostProcessing(errCode == ERROR_NOTHING ? 2:0);\n            }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "372", "src_id": "M1056", "code": "    private boolean handleMessage(@NonNull Message msg) {\n        if (mHandler == null) {\n            return true;\n        }\n\n        DownloadMission mission = (DownloadMission) msg.obj;\n\n        switch (msg.what) {\n            case MESSAGE_FINISHED:\n                notifyMediaScanner(mission.storage.getUri());\n                notifyFinishedDownload(mission.storage.getName());\n                mManager.setFinished(mission);\n                handleConnectivityState(false);\n                updateForegroundState(mManager.runMissions());\n                break;\n            case MESSAGE_RUNNING:\n                updateForegroundState(true);\n                break;\n            case MESSAGE_ERROR:\n                notifyFailedDownload(mission);\n                handleConnectivityState(false);\n                updateForegroundState(mManager.runMissions());\n                break;\n            case MESSAGE_PAUSED:\n                updateForegroundState(mManager.getRunningMissionsCount() > 0);\n                break;\n        }\n\n        if (msg.what != MESSAGE_ERROR) {\n\n            mFailedDownloads.remove(mFailedDownloads.indexOfValue(mission));\n        }\n\n        for (Callback observer:mEchoObservers) {\n\n            observer.handleMessage(msg);\n        }\n\n        return true;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "373", "src_id": "M1105", "code": "    private void showError(@NonNull DownloadMission mission) {\n\n        @StringRes int msg = R.string.general_error;\n        String msgEx = null;\n\n        switch (mission.errCode) {\n            case 416:\n                msg = R.string.error_http_unsupported_range;\n                break;\n            case 404:\n                msg = R.string.error_http_not_found;\n                break;\n            case ERROR_NOTHING:\n                return; // this never should happen\n\n            case ERROR_FILE_CREATION:\n                msg = R.string.error_file_creation;\n                break;\n            case ERROR_HTTP_NO_CONTENT:\n                msg = R.string.error_http_no_content;\n                break;\n            case ERROR_PATH_CREATION:\n                msg = R.string.error_path_creation;\n                break;\n            case ERROR_PERMISSION_DENIED:\n                msg = R.string.permission_denied;\n                break;\n            case ERROR_SSL_EXCEPTION:\n                msg = R.string.error_ssl_exception;\n                break;\n            case ERROR_UNKNOWN_HOST:\n                msg = R.string.error_unknown_host;\n                break;\n            case ERROR_CONNECT_HOST:\n                msg = R.string.error_connect_host;\n                break;\n            case ERROR_POSTPROCESSING_STOPPED:\n                msg = R.string.error_postprocessing_stopped;\n                break;\n            case ERROR_POSTPROCESSING:\n            case ERROR_POSTPROCESSING_HOLD:\n                showError(mission, UserAction.DOWNLOAD_POSTPROCESSING, R.string.error_postprocessing_failed);\n                return;\n            case ERROR_INSUFFICIENT_STORAGE:\n                msg = R.string.error_insufficient_storage_left;\n                break;\n            case ERROR_UNKNOWN_EXCEPTION:\n                if (mission.errObject != null) {\n                    showError(mission, UserAction.DOWNLOAD_FAILED, R.string.general_error);\n                    return;\n                } else {\n                    msg = R.string.msg_error;\n                    break;\n                }\n\n            case ERROR_PROGRESS_LOST:\n                msg = R.string.error_progress_lost;\n                break;\n            case ERROR_TIMEOUT:\n                msg = R.string.error_timeout;\n                break;\n            case ERROR_RESOURCE_GONE:\n                msg = R.string.error_download_resource_gone;\n                break;\n            default:\n                if (mission.errCode >= 100 && mission.errCode < 600) {\n                    msgEx = \"HTTP \" + mission.errCode;\n                } else if (mission.errObject == null) {\n                    msgEx = \"(not_decelerated_error_code)\";\n                } else {\n                    showError(mission, UserAction.DOWNLOAD_FAILED, msg);\n                    return;\n                }\n                break;\n        }\n\n        AlertDialog.Builder builder = new AlertDialog.Builder(mContext);\n        if (msgEx != null) {\n\n            builder.setMessage(msgEx);\n        } else {\n\n            builder.setMessage(msg);\n        }\n\n        // add report button for non-HTTP errors (range 100-599)\n        if (mission.errObject != null && (mission.errCode < 100 || mission.errCode >= 600)) {\n\n            @StringRes final int mMsg = msg;\n            builder.setPositiveButton(R.string.error_report_title, \n                    (dialog, which) -> showError(mission, UserAction\n                    .DOWNLOAD_FAILED, \n                    mMsg));\n        }\n\n        builder.setNegativeButton(R.string.ok, \n                (dialog, which) -> dialog.cancel())\n                .setTitle(mission.storage.getName())\n                .show();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "374", "src_id": "M828", "code": "    private Minf parseMinf(final Box ref) throws IOException {\n\n        final Minf obj = new Minf();\n        Box b;\n\n        while ((b = untilAnyBox(ref)) != null) {\n            switch (b.type) {\n                case ATOM_DINF:\n                    obj.dinf = readFullBox(b);\n                    break;\n                case ATOM_STBL:\n                    obj.stblStsd = parseStbl(b);\n                    break;\n                case ATOM_VMHD:case ATOM_SMHD:\n                    obj.mhd = readFullBox(b);\n                    break;\n            }\n            ensure(b);\n        }\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "375", "src_id": "M822", "code": "    private Mdia parseMdia(final Box ref) throws IOException {\n\n        final Mdia obj = new Mdia();\n        Box b;\n\n        while ((b = untilBox(ref, ATOM_MDHD, ATOM_HDLR, ATOM_MINF)) != null) {\n            switch (b.type) {\n                case ATOM_MDHD:\n                    obj.mdhd = readFullBox(b);\n                    // read time scale\n                    final ByteBuffer buffer = ByteBuffer.wrap(obj.mdhd);\n                    final byte version = buffer.get(8);\n                    buffer.position(12 + ((version == 0 ? 4:8) * 2));\n                    obj.mdhdTimeScale = buffer.getInt();\n                    break;\n                case ATOM_HDLR:\n                    obj.hdlr = parseHdlr(b);\n                    break;\n                case ATOM_MINF:\n                    obj.minf = parseMinf(b);\n                    break;\n            }\n\n            ensure(b);\n        }\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "105", "src_id": "M902", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "106", "src_id": "M1277", "code": "    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n            if (obj instanceof byte[]) {\n                str = SafeEncoder.encode((byte[]) obj);\n            } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                str = geo.getLongitude() + \",\" + geo.getLatitude();\n            } else if (obj instanceof String) {\n                str = stringEscape ? escape((String) obj) : (String) obj;\n            } else {\n                str = String.valueOf(obj);\n            }\n\n\n            output.put(key, str);\n        }\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "107", "src_id": "M1197", "code": "    public final B nextBatch() {\n        if (roundRobinCompleted) {\n            throw new NoSuchElementException();\n        }\n        CommandArguments args;\n        if (iterationCompleted) {\n            connection = connections.poll();\n            args = initCommandArguments();\n        } else {\n            args = nextCommandArguments(lastReply);\n        }\n        Object rawReply;\n        if (connection.getValue() instanceof Connection) {\n            rawReply = ((Connection) connection.getValue()).executeCommand(args);\n        } else if (connection.getValue() instanceof Pool) {\n            try (Connection c = ((Pool<Connection>) connection.getValue())\n                .getResource()) {\n                rawReply = c.executeCommand(args);\n            }\n        } else {\n            throw new IllegalArgumentException(connection.getValue().getClass() + \"is not supported.\");\n        }\n\n\n        lastReply = builder.build(rawReply);\n        iterationCompleted = isNodeCompleted(lastReply);\n        if (iterationCompleted && connections.isEmpty()) {\n            roundRobinCompleted = true;\n        }\n        return lastReply;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "108", "src_id": "M1251", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        args.addParams(fieldName);\n        args.add(TEXT);\n        if (indexMissing) {\n            args.add(INDEXMISSING);\n        }\n        if (indexEmpty) {\n            args.add(INDEXEMPTY);\n        }\n        if (weight != null) {\n            args.add(WEIGHT).add(weight);\n        }\n        if (noStem) {\n            args.add(NOSTEM);\n        }\n        if (phoneticMatcher != null) {\n            args.add(PHONETIC).add(phoneticMatcher);\n        }\n        if (withSuffixTrie) {\n            args.add(WITHSUFFIXTRIE);\n        }\n        if (sortableUNF) {\n            args.add(SORTABLE).add(UNF);\n        } else if (sortable) {\n            args.add(SORTABLE);\n        }\n\n        if (noIndex) {\n            args.add(NOINDEX);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "109", "src_id": "M873", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (fromTimestamp == null) {\n            args.add(MINUS);\n        } else {\n            args.add(toByteArray(fromTimestamp));\n        }\n        if (toTimestamp == null) {\n            args.add(PLUS);\n        } else {\n            args.add(toByteArray(toTimestamp));\n        }\n        if (latest) {\n            args.add(LATEST);\n        }\n        if (filterByTimestamps != null) {\n            args.add(FILTER_BY_TS);\n            for (long ts : filterByTimestamps) {\n                args.add(toByteArray(ts));\n            }\n        }\n        if (filterByValues != null) {\n            args.add(FILTER_BY_VALUE);\n            for (double value : filterByValues) {\n                args.add(toByteArray(value));\n            }\n        }\n        if (count != null) {\n            args.add(COUNT).add(toByteArray(count));\n        }\n\n        if (aggregationType != null) {\n            if (align != null) {\n                args.add(ALIGN).add(align);\n            }\n            args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n            if (bucketTimestamp != null) {\n                args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n            }\n            if (empty) {\n                args.add(EMPTY);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "110", "src_id": "M1349", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (dataType != null) {\n            args.add(ON).add(dataType);\n        }\n        if (prefix != null) {\n            args.add(PREFIX).add(prefix.size()).addObjects(prefix);\n        }\n        if (filter != null) {\n            args.add(FILTER).add(filter);\n        }\n        if (language != null) {\n            args.add(LANGUAGE).add(language);\n        }\n        if (languageField != null) {\n            args.add(LANGUAGE_FIELD).add(languageField);\n        }\n        if (score != null) {\n            args.add(SCORE).add(score);\n        }\n        if (scoreField != null) {\n            args.add(SCORE_FIELD).add(scoreField);\n        }\n        if (maxTextFields) {\n            args.add(MAXTEXTFIELDS);\n        }\n        if (noOffsets) {\n            args.add(NOOFFSETS);\n        }\n        if (temporary != null) {\n            args.add(TEMPORARY).add(temporary);\n        }\n        if (noHL) {\n            args.add(NOHL);\n        }\n        if (noFields) {\n            args.add(NOFIELDS);\n        }\n        if (noFreqs) {\n            args.add(NOFREQS);\n        }\n        if (stopwords != null) {\n            args.add(STOPWORDS).add(stopwords.size());\n            stopwords.forEach(w -> args.add(w));\n        }\n        if (skipInitialScan) {\n            args.add(SKIPINITIALSCAN);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "111", "src_id": "M55", "code": "    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, Long> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n            }\n            return map;\n        } else {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n            }\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "112", "src_id": "M1351", "code": "    @Override\n    public SearchResult build(Object data) {\n        List<Object> resp = (List<Object>) data;\n        int step = 1;\n        int scoreOffset = 0;\n        int contentOffset = 1;\n        if (hasScores) {\n            step += 1;\n            scoreOffset = 1;\n            contentOffset += 1;\n        }\n        if (hasContent) {\n            step += 1;\n        }\n        // the first element is always the number of results\n        long totalResults = (Long) resp.get(0);\n        List<Document> documents = new ArrayList<>(resp.size() - 1);\n        for (int i = 1; i < resp.size(); i += step) {\n            String id = BuilderFactory.STRING.build(resp.get(i));\n            double score = hasScores ? BuilderFactory.DOUBLE.build(resp.get(i + scoreOffset)) : 1.0;\n            List<byte[]> fields = hasContent ? (List<byte[]>) resp.get(i + contentOffset) : null;\n            documents.add(Document.load(id, score, fields, decode, isFieldDecode));\n        }\n        return new SearchResult(totalResults, documents);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "113", "src_id": "M1298", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (type != null) {\n            args.add(SearchKeyword.ON.name());\n            args.add(type.name());\n        }\n        if (prefixes != null && prefixes.length > 0) {\n            args.add(SearchKeyword.PREFIX.name());\n            args.add(Integer.toString(prefixes.length));\n            args.addObjects((Object[]) prefixes);\n        }\n        if (filter != null) {\n            args.add(SearchKeyword.FILTER.name());\n            args.add(filter);\n        }\n        if (languageField != null) {\n            args.add(SearchKeyword.LANGUAGE_FIELD.name());\n            args.add(languageField);\n        }\n        if (language != null) {\n            args.add(SearchKeyword.LANGUAGE.name());\n            args.add(language);\n        }\n        if (scoreFiled != null) {\n            args.add(SearchKeyword.SCORE_FIELD.name());\n            args.add(scoreFiled);\n        }\n        if (score != 1.0) {\n            args.add(SearchKeyword.SCORE.name());\n            args.add(Double.toString(score));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1105", "code": "    @Override\n    public Class<?> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "150", "src_id": "M894", "code": "    public static RequestCreator loadScaledDownThumbnail(final Context context,@NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {@Override public Bitmap transform(final Bitmap source) {if (DEBUG\n                    ) {Log.d(TAG, \"Thumbnail - transform() called\");} final float notificationThumbnailWidth = Math\n                .min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                source.getWidth());final Bitmap result = BitmapCompat\n                .createScaledBitmap(source, (int) notificationThumbnailWidth,\n                (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth\n                )\n                ),\n                null, true);if (result == source || !result.isMutable()\n                    ) {// create a new mutable bitmap to prevent strange crashes on some\n                    // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source,\n                    (int) notificationThumbnailWidth - 1, (int) (source\n                    .getHeight() \n                     / (source.getWidth() / (notificationThumbnailWidth \n                    -1\n                    )\n                    )\n                    ),\n                    null, true); source.recycle();return copied;} else {source\n                    .recycle()\n                    ;return result;}}@Override public String key() {return PLAYER_THUMBNAIL_TRANSFORMATION_KEY\n                ;}});\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "151", "src_id": "M369", "code": "    private void buildQualityMenu() {\n        if (qualityPopupMenu == null) {\n            return;\n        }\n        qualityPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_QUALITY);\n\n        final List<VideoStream> availableStreams = Optional\n        .ofNullable(player.getCurrentMetadata())\n        .flatMap(MediaItemTag::getMaybeQuality)\n        .map(MediaItemTag.Quality::getSortedVideoStreams)\n        .orElse(null);\n\n        if (availableStreams == null) {\n            return;\n        }\n\n\n        for (int i = 0; i < availableStreams.size(); i++) {\n            final VideoStream videoStream = availableStreams.get(i);\n\n            qualityPopupMenu.getMenu().add(POPUP_MENU_ID_QUALITY, \n            i, Menu.NONE, MediaFormat.getNameById(videoStream\n            .getFormatId()) \n             + \" \" \n             + videoStream.getResolution());\n        }\n\n        qualityPopupMenu.setOnMenuItemClickListener(this);\n        qualityPopupMenu.setOnDismissListener(this);\n        player.getSelectedVideoStream().ifPresent(s -> binding.qualityTextView.setText(s.getResolution()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "152", "src_id": "M372", "code": "    private void buildCaptionMenu(@NonNull final List<String> availableLanguages) {\n        if (captionPopupMenu == null) {\n            return;\n        }\n        captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n        captionPopupMenu.setOnDismissListener(this);\n\n        // Add option for turning off caption\n        final MenuItem captionOffItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, 0, Menu.NONE, R.string.caption_none);\n\n        captionOffItem.setOnMenuItemClickListener(menuItem -> {final int textRendererIndex = player\n            .getCaptionRendererIndex();if (textRendererIndex != RENDERER_UNAVAILABLE\n                ) {player.getTrackSelector().setParameters(player\n                .getTrackSelector()\n                .buildUponParameters()\n                .setRendererDisabled(textRendererIndex, true))\n                ;}player.getPrefs().edit().remove(context.getString(R\n            .string\n            .caption_user_set_key))\n            .apply()\n            ;return true;});\n\n        // Add all available captions\n        for (int i = 0; i < availableLanguages.size(); i++) {\n            final String captionLanguage = availableLanguages.get(i);\n            final MenuItem captionItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, i + 1, Menu.NONE, captionLanguage);\n\n            captionItem.setOnMenuItemClickListener(menuItem -> {final int textRendererIndex = player\n                .getCaptionRendererIndex();if (textRendererIndex != RENDERER_UNAVAILABLE\n                    ) {// DefaultTrackSelector will select for text tracks in the following order.\n                    // When multiple tracks share the same rank, a random track will be chosen.\n                    // 1. ANY track exactly matching preferred language name\n                    // 2. ANY track exactly matching preferred language stem\n                    // 3. ROLE_FLAG_CAPTION track matching preferred language stem\n                    // 4. ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND track matching preferred language stem\n                    // This means if a caption track of preferred language is not available,\n                    // then an auto-generated track of that language will be chosen automatically.\n                    player.getTrackSelector().setParameters(player.getTrackSelector()\n                    .buildUponParameters()\n                    .setPreferredTextLanguages(captionLanguage, PlayerHelper\n                    .captionLanguageStemOf(captionLanguage))\n                    .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                    .setRendererDisabled(textRendererIndex, false))\n                    ; player.getPrefs().edit().putString(context.getString(R\n                    .string\n                    .caption_user_set_key), \n                    captionLanguage)\n                    .apply()\n                    ;} return true;});\n        }\n        captionPopupMenu.setOnDismissListener(this);\n\n        // apply caption language from previous user preference\n        final int textRendererIndex = player.getCaptionRendererIndex();\n\n        if (textRendererIndex == RENDERER_UNAVAILABLE) {\n            return;\n        }\n\n        // If user prefers to show no caption, then disable the renderer.\n        // Otherwise, DefaultTrackSelector may automatically find an available caption\n        // and display that.\n        final String userPreferredLanguage = player.getPrefs().getString(context.getString(R.string.caption_user_set_key), null);\n\n        if (userPreferredLanguage == null) {\n            player.getTrackSelector().setParameters(player.getTrackSelector()\n            .buildUponParameters()\n            .setRendererDisabled(textRendererIndex, true));\n            return;\n        }\n\n        // Only set preferred language if it does not match the user preference,\n        // otherwise there might be an infinite cycle at onTextTracksChanged.\n        final List<String> selectedPreferredLanguages = player.getTrackSelector().getParameters().preferredTextLanguages;\n\n        if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n            player.getTrackSelector().setParameters(player.getTrackSelector()\n            .buildUponParameters()\n            .setPreferredTextLanguages(userPreferredLanguage, PlayerHelper\n            .captionLanguageStemOf(userPreferredLanguage))\n            .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n            .setRendererDisabled(textRendererIndex, false));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "153", "src_id": "M527", "code": "    @Nullable\n    @SuppressLint(\"PrivateResource\") // we currently use Exoplayer's internal strings and icons\n\n    public static NotificationActionData fromNotificationActionEnum(@NonNull final Player player,\n    @NotificationConstants.Action final int selectedAction) {\n        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n        final Context ctx = player.getContext();\n\n        switch (selectedAction) {\n            case NotificationConstants.PREVIOUS:\n                return new NotificationActionData(ACTION_PLAY_PREVIOUS,\n                ctx.getString(com.google.android.exoplayer2.ui.R.string\n                .exo_controls_previous_description), \n                baseActionIcon);\n            case NotificationConstants.NEXT:\n                return new NotificationActionData(ACTION_PLAY_NEXT,\n                ctx.getString(com.google.android.exoplayer2.ui.R.string\n                .exo_controls_next_description), \n                baseActionIcon);\n            case NotificationConstants.REWIND:\n                return new NotificationActionData(ACTION_FAST_REWIND,\n                ctx.getString(com.google.android.exoplayer2.ui.R.string\n                .exo_controls_rewind_description), \n                baseActionIcon);\n            case NotificationConstants.FORWARD:\n                return new NotificationActionData(ACTION_FAST_FORWARD,\n                ctx.getString(com.google.android.exoplayer2.ui.R.string\n                .exo_controls_fastforward_description), \n                baseActionIcon);\n            case NotificationConstants.SMART_REWIND_PREVIOUS:\n                if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                    return new NotificationActionData(ACTION_PLAY_PREVIOUS,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_previous_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_notification_previous);\n                } else {\n                    return new NotificationActionData(ACTION_FAST_REWIND,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_rewind_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_controls_rewind);\n                }\n\n            case NotificationConstants.SMART_FORWARD_NEXT:\n                if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                    return new NotificationActionData(ACTION_PLAY_NEXT,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_next_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_notification_next);\n                } else {\n                    return new NotificationActionData(ACTION_FAST_FORWARD,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_fastforward_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_controls_fastforward);\n                }\n\n            case NotificationConstants.PLAY_PAUSE_BUFFERING:\n                if (player.getCurrentState() == Player.STATE_PREFLIGHT\n                     || player.getCurrentState() == Player.STATE_BLOCKED\n                     || player.getCurrentState() == Player.STATE_BUFFERING) {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE,\n                    ctx.getString(R.string.notification_action_buffering),\n                    R.drawable.ic_hourglass_top);\n                }\n\n            // fallthrough\n            case NotificationConstants.PLAY_PAUSE:\n                if (player.getCurrentState() == Player.STATE_COMPLETED) {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_pause_description),\n                    R.drawable.ic_replay);\n                } else if (player.isPlaying() || player.getCurrentState() \n                     == Player.STATE_PREFLIGHT\n                     || player.getCurrentState() == Player.STATE_BLOCKED\n                     || player.getCurrentState() == Player.STATE_BUFFERING) {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_pause_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_notification_pause);\n                } else {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE,\n                    ctx.getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_play_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_notification_play);\n                }\n\n            case NotificationConstants.REPEAT:\n                if (player.getRepeatMode() == REPEAT_MODE_ALL) {\n                    return new NotificationActionData(ACTION_REPEAT, ctx\n                    .getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_repeat_all_description),\n                    com.google.android.exoplayer2.ext.mediasession.R.drawable\n                    .exo_media_action_repeat_all);\n                } else if (player.getRepeatMode() == REPEAT_MODE_ONE) {\n                    return new NotificationActionData(ACTION_REPEAT, ctx\n                    .getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_repeat_one_description),\n                    com.google.android.exoplayer2.ext.mediasession.R.drawable\n                    .exo_media_action_repeat_one);\n                } else /* player.getRepeatMode() == REPEAT_MODE_OFF */ {\n                    return new NotificationActionData(ACTION_REPEAT, ctx\n                    .getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_repeat_off_description),\n                    com.google.android.exoplayer2.ext.mediasession.R.drawable\n                    .exo_media_action_repeat_off);\n                }\n\n            case NotificationConstants.SHUFFLE:\n                if (player.getPlayQueue() != null && player.getPlayQueue().isShuffled()) {\n                    return new NotificationActionData(ACTION_SHUFFLE, ctx\n                    .getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_shuffle_on_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_on);\n                } else {\n                    return new NotificationActionData(ACTION_SHUFFLE, ctx\n                    .getString(com.google.android.exoplayer2.ui.R.string\n                    .exo_controls_shuffle_off_description),\n                    com.google.android.exoplayer2.ui.R.drawable.exo_controls_shuffle_off);\n                }\n\n            case NotificationConstants.CLOSE:\n                return new NotificationActionData(ACTION_CLOSE, ctx.getString(R.string.close), R.drawable.ic_close);\n            case NotificationConstants.NOTHING:\n            default:\n                // do nothing\n                return null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "154", "src_id": "M16", "code": "    private void handleCookiesFromUrl(@Nullable final String url) {\n        if (MainActivity.DEBUG) {\n            Log.d(TAG, \"handleCookiesFromUrl: url=\" + (url == null ? \"null\":url));\n        }\n        if (url == null) {\n            return;\n        }\n\n        final String cookies = CookieManager.getInstance().getCookie(url);\n\n        handleCookies(cookies);\n\n        // sometimes cookies are inside the url\n        final int abuseStart = url.indexOf(\"google_abuse=\");\n\n        if (abuseStart != -1) {\n            final int abuseEnd = url.indexOf(\"+path\");\n            try {\n                handleCookies(Utils.decodeUrlUtf8(url.substring(abuseStart + 13, abuseEnd)));\n            } catch (final StringIndexOutOfBoundsException e) {\n                    if (MainActivity.DEBUG) {\n                        Log.e(TAG, \"handleCookiesFromUrl: invalid google abuse starting at \" + abuseStart + \" and ending at \" + abuseEnd + \" for url \" + url, e);\n                    }\n                }\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "155", "src_id": "M456", "code": "    public void toggleFullscreen() {\n        if (DEBUG) {\n            Log.d(TAG, \"toggleFullscreen() called\");\n        }\n\n        final PlayerServiceEventListener fragmentListener = player.getFragmentListener().orElse(null);\n\n        if (fragmentListener == null || player.exoPlayerIsNull()) {\n            return;\n        }\n        isFullscreen = !isFullscreen;\n\n        if (isFullscreen) {\n            // Android needs tens milliseconds to send new insets but a user is able to see\n            // how controls changes it's position from `0` to `nav bar height` padding.\n            // So just hide the controls to hide this visual inconsistency\n            hideControls(0, 0);\n        } else {\n            // Apply window insets because Android will not do it when orientation changes\n            // from landscape to portrait (open vertical video to reproduce)\n            binding.playbackControlRoot.setPadding(0, 0, 0, 0);\n        }\n        fragmentListener.onFullscreenStateChanged(isFullscreen);\n        binding.titleTextView.setVisibility(isFullscreen ? View.VISIBLE:View.GONE);\n        binding.channelTextView.setVisibility(isFullscreen ? View.VISIBLE:View.GONE);\n        binding.playerCloseButton.setVisibility(isFullscreen ? View.GONE:View.VISIBLE);\n        setupScreenRotationButton();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "156", "src_id": "M217", "code": "    private void initPlayer(final boolean playOnReady) {\n        if (DEBUG) {\n            Log.d(TAG, \"initPlayer() called with: playOnReady = [\" + playOnReady + \"]\");\n        }\n        simpleExoPlayer = new ExoPlayer.Builder(context, renderFactory)\n        .setTrackSelector(trackSelector)\n        .setLoadControl(loadController)\n        .setUsePlatformDiagnostics(false)\n        .build();\n        simpleExoPlayer.addListener(this);\n        simpleExoPlayer.setPlayWhenReady(playOnReady);\n        simpleExoPlayer.setSeekParameters(PlayerHelper.getSeekParameters(context));\n        simpleExoPlayer.setWakeMode(C.WAKE_MODE_NETWORK);\n        simpleExoPlayer.setHandleAudioBecomingNoisy(true);\n        audioReactor = new AudioReactor(context, simpleExoPlayer);\n        registerBroadcastReceiver();\n        // Setup UIs\n        UIs.call(PlayerUi::initPlayer);\n\n        // Disable media tunneling if requested by the user from ExoPlayer settings\n        if (!PreferenceManager.getDefaultSharedPreferences(context)\n            .getBoolean(context.getString(R.string.disable_media_tunneling_key), \n            false)) {\n            trackSelector.setParameters(trackSelector.buildUponParameters().setTunnelingEnabled(true));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "157", "src_id": "M467", "code": "    private MediaMetadataCompat buildMediaMetadata() {\n        if (DEBUG) {\n            Log.d(TAG, \"buildMediaMetadata called\");\n        }\n\n        // set title and artist\n        final MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder()\n        .putString(MediaMetadataCompat.METADATA_KEY_TITLE, \n        player.getVideoTitle())\n        .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, \n        player.getUploaderName());\n        // set duration (-1 for livestreams or if unknown, see the METADATA_KEY_DURATION docs)\n        final long duration = player.getCurrentStreamInfo()\n        .filter(info -> !StreamTypeUtil.isLiveStream(info\n        .getStreamType()))\n        .map(info -> info.getDuration() * 1000L)\n        .orElse(-1L);\n\n        builder.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration);\n\n        // set album art, unless the user asked not to, or there is no thumbnail available\n        final boolean showThumbnail = player.getPrefs().getBoolean(context.getString(R.string.show_thumbnail_key), true);\n\n        Optional.ofNullable(player.getThumbnail()).filter(bitmap -> showThumbnail)\n        .ifPresent(bitmap -> {builder.putBitmap(MediaMetadataCompat\n            .METADATA_KEY_ALBUM_ART, \n            bitmap)\n            ; builder.putBitmap(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON, \n            bitmap)\n            ;});\n        return builder.build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "158", "src_id": "M460", "code": "    public MediaDescriptionCompat getQueueMetadata(final int index) {\n        if (player.getPlayQueue() == null) {\n            return null;\n        }\n\n        final PlayQueueItem item = player.getPlayQueue().getItem(index);\n\n        if (item == null) {\n            return null;\n        }\n\n        final MediaDescriptionCompat.Builder descBuilder = new MediaDescriptionCompat.Builder()\n        .setMediaId(String.valueOf(index))\n        .setTitle(item.getTitle())\n        .setSubtitle(item.getUploader());\n        // set additional metadata for A2DP/AVRCP (Audio/Video Bluetooth profiles)\n        final Bundle additionalMetadata = new Bundle();\n\n        additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_TITLE, item.getTitle());\n        additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_ARTIST, item.getUploader());\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, item.getDuration() * 1000);\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, index + 1L);\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, player.getPlayQueue().size());\n        descBuilder.setExtras(additionalMetadata);\n\n        try {\n            descBuilder.setIconUri(Uri.parse(ImageStrategy.choosePreferredImage(item.getThumbnails())));\n        } catch (final Throwable e) {\n            // no thumbnail available at all, or the user disabled image loading,\n            // or the obtained url is not a valid `Uri`\n            }\n\n\n        return descBuilder.build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "159", "src_id": "M543", "code": "    private synchronized NotificationCompat.Builder createNotification() {\n        if (DEBUG) {\n            Log.d(TAG, \"createNotification()\");\n        }\n        notificationManager = NotificationManagerCompat.from(player.getContext());\n\n        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player\n        .getContext(),\n        player.getContext().getString(R.string.notification_channel_id));\n        final MediaStyle mediaStyle = new MediaStyle();\n\n        // setup media style (compact notification slots and media session)\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n            // notification actions are ignored on Android 13+, and are replaced by code in\n            // MediaSessionPlayerUi\n            final int[] compactSlots = initializeNotificationSlots();\n\n            mediaStyle.setShowActionsInCompactView(compactSlots);\n        }\n        player.UIs().get(MediaSessionPlayerUi.class).flatMap(MediaSessionPlayerUi::getSessionToken).ifPresent(mediaStyle::setMediaSession);\n        // setup notification builder\n        builder.setStyle(mediaStyle).setPriority(NotificationCompat\n        .PRIORITY_HIGH)\n        .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n        .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n        .setShowWhen(false)\n        .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n        .setColor(ContextCompat.getColor(player.getContext(),\n        R.color.dark_background_color))\n        .setColorized(player.getPrefs().getBoolean(player\n        .getContext()\n        .getString(R.string.notification_colorize_key), \n        true))\n        .setDeleteIntent(PendingIntentCompat.getBroadcast(player\n        .getContext(),\n        NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, \n        false));\n        // set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n        setLargeIcon(builder);\n        return builder;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "312", "src_id": "M542", "code": "private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name)\n            .style(Decoration.bold.bold()), \n            label(\"\" + info.get(LoggerHelper.name)))\n            .row(label(LoggerHelper.clazz).style(Decoration.bold\n            .bold()), \n            label(\"\" + clazz.getName()))\n            .row(label(LoggerHelper.classLoader)\n            .style(Decoration.bold.bold()),\n            label(\"\" + info.get(LoggerHelper.classLoader)))\n            .row(label(LoggerHelper.classLoaderHash)\n            .style(Decoration.bold.bold()),\n            label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n            .row(label(LoggerHelper.level).style(Decoration.bold\n            .bold()),\n            label(\"\" + info.get(LoggerHelper.level)));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity)\n            .style(Decoration.bold.bold()),\n            label(\"\" + info.get(LoggerHelper.additivity)))\n            .row(label(LoggerHelper.codeSource)\n            .style(Decoration.bold.bold()),\n            label(\"\" + info.get(LoggerHelper.codeSource)));\n        @SuppressWarnings(\"unchecked\") List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n\n        if (appenders != null && !appenders.isEmpty()) {\n\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "313", "src_id": "M1126", "code": "private ApiResponse processInitSessionRequest(ApiRequest apiRequest) throws ApiException {\n    ApiResponse response = new ApiResponse();\n    //create session\n    Session session = sessionManager.createSession();\n\n    if (session != null) {\n        //Result Distributor\n        SharingResultDistributorImpl resultDistributor = new SharingResultDistributorImpl(session);\n        //create consumer\n        ResultConsumer resultConsumer = new ResultConsumerImpl();\n        resultDistributor.addConsumer(resultConsumer);\n        session.setResultDistributor(resultDistributor);\n        resultDistributor.appendResult(new MessageModel(\"Welcome to arthas!\"));\n        //welcome message\n        WelcomeModel welcomeModel = new WelcomeModel();\n        welcomeModel.setVersion(ArthasBanner.version());\n        welcomeModel.setWiki(ArthasBanner.wiki());\n        welcomeModel.setTutorials(ArthasBanner.tutorials());\n        welcomeModel.setMainClass(PidUtils.mainClass());\n        welcomeModel.setPid(PidUtils.currentPid());\n        welcomeModel.setTime(DateUtils.getCurrentDateTime());\n        resultDistributor.appendResult(welcomeModel);\n        //allow input\n        updateSessionInputStatus(session, InputStatus.ALLOW_INPUT);\n        response.setSessionId(session.getSessionId()).setConsumerId(resultConsumer.getConsumerId()).setState(ApiState.SUCCEEDED);\n    } else {\n        throw new ApiException(\"create api session failed\");\n    }\n\n    return response;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "314", "src_id": "M1157", "code": "private HttpResponse readFileFromResource(FullHttpRequest request, String path) throws IOException {\n    DefaultFullHttpResponse fullResp = null;\n    InputStream in = null;\n    try {\n        URL res = HttpTtyConnection.class.getResource(\"/com/taobao/arthas/core/http\" + path);\n\n        if (res != null) {\n            fullResp = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK);\n            in = res.openStream();\n            byte[] tmp = new byte[256];\n            for (int l = 0; l != -1; l = in.read(tmp)) {\n                fullResp.content().writeBytes(tmp, 0, l);\n            }\n\n            int li = path.lastIndexOf('.');\n            if (li != -1 && li != path.length() - 1) {\n                String ext = path.substring(li + 1);\n                String contentType;\n                contentType = \"html\".equals(ext) ? \"text/html\": \"js\".equals(ext) ? \"application/javascript\": \"css\".equals(ext) ? \"text/css\": null; \n                if (contentType != null) {\n                    fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, contentType);\n                }\n            }\n        }\n    } finally {\n            IOUtils.close(in);\n        }\n    return fullResp;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "315", "src_id": "M515", "code": "@Override\npublic void draw(CommandProcess process, StackModel result) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(ThreadUtil.getThreadTitle(result)).append(\"\\n\");\n    StackTraceElement[] stackTraceElements = result.getStackTrace();\n    StackTraceElement locationStackTraceElement = stackTraceElements[0];\n    String locationString = String.format(\"    @%s.%s()\", locationStackTraceElement.getClassName(), locationStackTraceElement.getMethodName());\n    sb.append(locationString).append(\"\\n\");\n    int skip = 1;\n    for (int index = skip; index < stackTraceElements.length; index++) {\n        StackTraceElement ste = stackTraceElements[index];\n        sb.append(\"        at \").append(ste.getClassName())\n            .append(\".\")\n            .append(ste.getMethodName())\n            .append(\"(\")\n            .append(ste.getFileName())\n            .append(\":\")\n            .append(ste.getLineNumber())\n            .append(\")\\n\");\n    }\n\n    process.write(\"ts=\" + DateUtils.formatDateTime(result.getTs()) + \";\" + sb.toString() + \"\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "316", "src_id": "M1130", "code": "private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n    boolean oneTimeAccess = session.get(ONETIME_SESSION_KEY) != null? true: false; \n    try {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<String, Object>();\n        body.put(\"command\", commandLine);\n        ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n\n        int lock = session.getLock();\n        PackingResultDistributor packingResultDistributor = null;\n        Job job = null;\n        try {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n\n            packingResultDistributor = new PackingResultDistributorImpl(session);\n            //distribute result message both to origin session channel and request channel by CompositeResultDistributor\n            //ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n            job = this.createJob(commandLine, session, packingResultDistributor);\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n            job.run();\n        } catch (Throwable e) {\n                logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n                response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                return response;\n            } finally {\n                if (session.getLock() == lock) {\n                    session.unLock();\n                }\n            }\n\n        //wait for job completed or timeout\n        Integer timeout = apiRequest.getExecTimeout();\n        if (timeout == null || timeout <= 0) {\n            timeout = DEFAULT_EXEC_TIMEOUT;\n        }\n        boolean timeExpired = !waitForJob(job, timeout);\n        if (timeExpired) {\n            logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n            job.interrupt();\n            response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n        } else {\n            response.setState(ApiState.SUCCEEDED);\n        }\n\n        //packing results\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        body.put(\"timeExpired\", timeExpired);\n        if (timeExpired) {\n            body.put(\"timeout\", timeout);\n        }\n        body.put(\"results\", packingResultDistributor.getResults());\n        response.setSessionId(session.getSessionId())//.setConsumerId(consumerId)\n        .setBody(body);\n        return response;\n    } finally {\n            if (oneTimeAccess) {\n                sessionManager.removeSession(session.getSessionId());\n            }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "317", "src_id": "M536", "code": "public static String drawThreadInfo(List<ThreadVO> threads, int width, int height) {\n    TableElement table = new TableElement(1, 6, 3, 2, 2, 2, 2, 2, 2, 2).overflow(Overflow.HIDDEN).rightCellPadding(1);\n    // Header\n    table.add(new RowElement().style(Decoration.bold\n        .fg(Color.black)\n        .bg(Color.white))\n        .add(\"ID\", \"NAME\", \"GROUP\", \"PRIORITY\",\n        \"STATE\", \"%CPU\", \"DELTA_TIME\", \"TIME\",\n        \"INTERRUPTED\", \"DAEMON\"));\n    int count = 0;\n\n    for (ThreadVO thread : threads) {\n        Color color = colorMapping.get(thread.getState());\n        String time = formatTimeMills(thread.getTime());\n        String deltaTime = formatTimeMillsToSeconds(thread.getDeltaTime());\n        double cpu = thread.getCpu();\n        LabelElement daemonLabel = new LabelElement(thread.isDaemon());\n        if (!thread.isDaemon()) {\n            daemonLabel.setStyle(Style.style(Color.magenta));\n        }\n\n        LabelElement stateElement = thread.getState() != null? new LabelElement(thread.getState()).style(color.fg()): new LabelElement(\"-\"); \n        table.row(new LabelElement(thread.getId()),\n            new LabelElement(thread.getName()),\n            new LabelElement(thread.getGroup() != null \n            ? thread.getGroup() : \"-\"),\n            new LabelElement(thread.getPriority()),\n            stateElement, new LabelElement(cpu),\n            new LabelElement(deltaTime), new LabelElement(time),\n            new LabelElement(thread.isInterrupted()),\n            daemonLabel);\n        if (++count >= height) {\n            break;\n        }\n    }\n\n    return RenderUtil.render(table, width, height);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "318", "src_id": "M1125", "code": "private ApiResponse dispatchRequest(ApiAction action, ApiRequest apiRequest, Session session) throws ApiException {\n    switch (action) {\n        case EXEC:\n            return processExecRequest(apiRequest, session);\n        case ASYNC_EXEC:\n            return processAsyncExecRequest(apiRequest, session);\n        case INTERRUPT_JOB:\n            return processInterruptJob(apiRequest, session);\n        case PULL_RESULTS:\n            return processPullResultsRequest(apiRequest, session);\n        case SESSION_INFO:\n            return processSessionInfoRequest(apiRequest, session);\n        case JOIN_SESSION:\n            return processJoinSessionRequest(apiRequest, session);\n        case CLOSE_SESSION:\n            return processCloseSessionRequest(apiRequest, session);\n        case INIT_SESSION:\n            break;\n    }\n\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "254", "src_id": "M1281", "code": "    @Override\n    protected void subscribeActual(Subscriber<? super T> s) {\n\n        PublishConnection<T> conn;\n\n        while (true) {\n            conn = current.get();\n            // don't create a fresh connection if the current is disposed\n            if (conn == null) {\n                PublishConnection<T> fresh = new PublishConnection<>(current, bufferSize);\n\n                if (!current.compareAndSet(conn, fresh)) {\n                    continue;\n                }\n\n                conn = fresh;\n            }\n\n            break;\n        }\n        InnerSubscription<T> inner = new InnerSubscription<>(s, conn);\n        s.onSubscribe(inner);\n        if (conn.add(inner)) {\n            if (inner.isCancelled()) {\n                conn.remove(inner);\n            } else {\n                conn.drain();\n            }\n\n            return;\n        }\n\n        Throwable ex = conn.error;\n\n        if (ex != null) {\n            inner.downstream.onError(ex);\n        } else {\n            inner.downstream.onComplete();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "255", "src_id": "M1061", "code": "    @Override Node getHead() {\n\n        long timeLimit = scheduler.now(unit) - maxAge;\n        Node prev = get();\n        Node next = prev.get();\n\n        while (true) {\n            if (next == null) {\n                break;\n            }\n\n            Timed<?> v = (Timed<?>) next.value;\n\n            if (NotificationLite.isComplete(v.value())) {\n                break;\n            }\n\n            if (NotificationLite.isError(v.value())) {\n            break;\n                }\n\n            if (v.time() <= timeLimit) {\n                prev = next;\n                next = next.get();\n            } else {\n                break;\n            }\n        }\n        return prev;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "256", "src_id": "M125", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Subscriber<? super R> downstream = this.downstream;\n        AtomicThrowable errors = this.errors;\n        AtomicReference<SwitchMapMaybeObserver<R>> inner = this.inner;\n        AtomicLong requested = this.requested;\n        long emitted = this.emitted;\n        while (true) {\n            while (true) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (errors.get() != null && !delayErrors) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                boolean d = done;\n                SwitchMapMaybeObserver<R> current = inner.get();\n                boolean empty = current == null;\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                if (empty || current.item == null) {\n                    break;\n                }\n\n                if (emitted == requested.get()) {\n                break;\n                    }\n\n                inner.compareAndSet(current, null);\n                downstream.onNext(current.item);\n                emitted++;\n            }\n            this.emitted = emitted;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "257", "src_id": "M341", "code": "    @Override\n    public void run() {\n\n        while (true) {\n            if (disposed) {\n                queue.clear();\n                return;\n            }\n\n            if (!active) {\n\n                boolean d = done;\n                T t;\n                try {\n                    t = queue.poll();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        dispose();\n                        queue.clear();\n                        downstream.onError(ex);\n                        worker.dispose();\n                        return;\n                    }\n\n\n                boolean empty = t == null;\n\n                if (d && empty) {\n                    disposed = true;\n                    downstream.onComplete();\n                    worker.dispose();\n                    return;\n                }\n\n                if (!empty) {\n\n                    ObservableSource<? extends U> o;\n                    try {\n                        o = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            dispose();\n                            queue.clear();\n                            downstream.onError(ex);\n                            worker.dispose();\n                            return;\n                        }\n\n                    active = true;\n                    o.subscribe(inner);\n                }\n            }\n\n            if (decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "258", "src_id": "M55", "code": "    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Observer<? super R> downstream = this.downstream;\n        ErrorMode errorMode = this.errorMode;\n        SimpleQueue<T> queue = this.queue;\n        AtomicThrowable errors = this.errors;\n        while (true) {\n\n            while (true) {\n                if (disposed) {\n                    queue.clear();\n                    item = null;\n                    break;\n                }\n\n                int s = state;\n\n                if (errors.get() != null) {\n                    if (errorMode == ErrorMode.IMMEDIATE) {\n                        queue.clear();\n                        item = null;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if ((errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) {\n                    queue.clear();\n                        item = null;\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                        }\n                    }\n\n                if (s == STATE_INACTIVE) {\n\n                    boolean d = done;\n                    T v;\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            disposed = true;\n                            upstream.dispose();\n                            errors.tryAddThrowableOrReport(ex);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    MaybeSource<? extends R> ms;\n                    try {\n                        ms = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            upstream.dispose();\n                            queue.clear();\n                            errors.tryAddThrowableOrReport(ex);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                    state = STATE_ACTIVE;\n                    ms.subscribe(inner);\n                    break;\n                } else if (s == STATE_RESULT_VALUE) {\n\n                    R w = item;\n                    item = null;\n                    downstream.onNext(w);\n                    state = STATE_INACTIVE;\n                } else {\n                    break;\n                }\n\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "259", "src_id": "M1425", "code": "    @Override\n    public void run() {\n\n        while (true) {\n            if (cancelled) {\n                return;\n            }\n\n            if (!active) {\n\n                boolean d = done;\n\n                if (d && !veryEnd) {\n\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n                }\n\n                T v;\n                try {\n                    v = queue.poll();\n                } catch (Throwable e) {\n                        Exceptions.throwIfFatal(e);\n                        upstream.cancel();\n                        errors.tryAddThrowableOrReport(e);\n                        errors.tryTerminateConsumer(downstream);\n                        worker.dispose();\n                        return;\n                    }\n\n\n                boolean empty = v == null;\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(downstream);\n                    worker.dispose();\n                    return;\n                }\n\n                if (!empty) {\n\n                    Publisher<? extends R> p;\n                    try {\n                        p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");\n                    } catch (Throwable e) {\n                            Exceptions.throwIfFatal(e);\n                            upstream.cancel();\n                            errors.tryAddThrowableOrReport(e);\n                            errors.tryTerminateConsumer(downstream);\n                            worker.dispose();\n                            return;\n                        }\n\n\n                    if (sourceMode != QueueSubscription.SYNC) {\n\n                        int c = consumed + 1;\n\n                        if (c == limit) {\n                            consumed = 0;\n                            upstream.request(c);\n                        } else {\n                            consumed = c;\n                        }\n                    }\n\n                    if (p instanceof Supplier) {\n                        @SuppressWarnings(\"unchecked\") Supplier<R> supplier = (Supplier<R>) p;\n                        R vr;\n                        try {\n                            vr = supplier.get();\n                        } catch (Throwable e) {\n                                Exceptions.throwIfFatal(e);\n                                errors.tryAddThrowableOrReport(e);\n                                if (!veryEnd) {\n                                    upstream.cancel();\n                                    errors.tryTerminateConsumer(downstream);\n                                    worker.dispose();\n                                    return;\n                                }\n\n                                vr = null;\n                            }\n\n\n                        if (vr == null) {\n                            continue;\n                        }\n\n                        if (cancelled) {\n                        continue;\n                            }\n\n                        if (inner.isUnbounded()) {\n                            downstream.onNext(vr);\n                            continue;\n                        } else {\n                            active = true;\n                            inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));\n                        }\n                    } else {\n                        active = true;\n                        p.subscribe(inner);\n                    }\n                }\n            }\n\n            if (decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "260", "src_id": "M1003", "code": "    void drain() {\n        if (wip.getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        SimpleQueue<T> q = queue;\n        int upstreamConsumed = consumed;\n        int localLimit = limit;\n        boolean canRequest = sourceMode != QueueSubscription.SYNC;\n        AtomicReference<MulticastSubscription<T>[]> subs = subscribers;\n        MulticastSubscription<T>[] array = subs.get();\n        outer:\n        while (true) {\n\n            int n = array.length;\n\n            if (q != null && n != 0) {\n\n                long r = Long.MAX_VALUE;\n\n                for (MulticastSubscription<T> ms : array) {\n\n                    long u = ms.get() - ms.emitted;\n\n                    if (u != Long.MIN_VALUE) {\n                        if (r > u) {\n                            r = u;\n                        }\n                    } else {\n                        --n; \n                    }\n                }\n                if (n == 0) {\n                    r = 0;\n                }\n\n                while (r != 0) {\n                    if (isDisposed()) {\n                        q.clear();\n                        return;\n                    }\n\n                    boolean d = done;\n\n                    if (d && !delayError) {\n\n                        Throwable ex = error;\n\n                        if (ex != null) {\n                            errorAll(ex);\n                            return;\n                        }\n                    }\n\n                    T v;\n                    try {\n                        v = q.poll();\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            SubscriptionHelper.cancel(upstream);\n                            errorAll(ex);\n                            return;\n                        }\n\n\n                    boolean empty = v == null;\n\n                    if (d && empty) {\n\n                        Throwable ex = error;\n\n                        if (ex != null) {\n                            errorAll(ex);\n                        } else {\n                            completeAll();\n                        }\n\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    boolean subscribersChange = false;\n\n                    for (MulticastSubscription<T> ms : array) {\n\n                        long msr = ms.get();\n\n                        if (msr != Long.MIN_VALUE) {\n                            if (msr != Long.MAX_VALUE) {\n                                ms.emitted++;\n                            }\n\n                            ms.downstream.onNext(v);\n                        } else {\n                            subscribersChange = true;\n                        }\n                    }\n                    --r; \n                    if (canRequest && ++upstreamConsumed == localLimit) {\n                        upstreamConsumed = 0;\n                        upstream.get().request(localLimit);\n                    }\n\n                    MulticastSubscription<T>[] freshArray = subs.get();\n\n                    if (subscribersChange) {\n                        array = freshArray;\n                        continue outer;\n                    }\n\n                    if (freshArray != array) {\n                    array = freshArray;\n                        continue outer;\n                        }\n                    }\n\n                if (r == 0) {\n                    if (isDisposed()) {\n                        q.clear();\n                        return;\n                    }\n\n                    boolean d = done;\n\n                    if (d && !delayError) {\n\n                        Throwable ex = error;\n\n                        if (ex != null) {\n                            errorAll(ex);\n                            return;\n                        }\n                    }\n\n                    if (d && q.isEmpty()) {\n\n                        Throwable ex = error;\n\n                        if (ex != null) {\n                            errorAll(ex);\n                        } else {\n                            completeAll();\n                        }\n\n                        return;\n                    }\n                }\n            }\n\n            consumed = upstreamConsumed;\n            missed = wip.addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n\n            if (q == null) {\n                q = queue;\n            }\n\n            array = subs.get();\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "261", "src_id": "M1237", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        final Subscriber<? super R> a = downstream;\n        final ZipSubscriber<T, R>[] qs = subscribers;\n        final int n = qs.length;\n        Object[] values = current;\n        int missed = 1;\n        while (true) {\n\n            long r = requested.get();\n            long e = 0L;\n            while (r != e) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                boolean empty = false;\n                for (int j = 0; j < n; j++) {\n\n                    ZipSubscriber<T, R> inner = qs[j];\n\n                    if (values[j] == null) {\n\n                        boolean d = inner.done;\n                        SimpleQueue<T> q = inner.queue;\n                        T v = null;\n                        try {\n                            v = q != null ? q.poll() : null;\n                        } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n\n                                d = true;\n                            }\n\n\n                        boolean sourceEmpty = v == null;\n\n                        if (d && sourceEmpty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n\n                        if (!sourceEmpty) {\n                            values[j] = v;\n                        } else {\n                            empty = true;\n                        }\n                    }\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                R v;\n                try {\n                    v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelAll();\n                        errors.tryAddThrowableOrReport(ex);\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n\n                a.onNext(v);\n                e++;\n                Arrays.fill(values, null);\n            }\n\n            if (r == e) {\n                if (cancelled) {\n                    return;\n                }\n\n                if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                for (int j = 0; j < n; j++) {\n\n                    ZipSubscriber<T, R> inner = qs[j];\n\n                    if (values[j] == null) {\n\n                        boolean d = inner.done;\n                        SimpleQueue<T> q = inner.queue;\n                        T v = null;\n                        try {\n                            v = q != null ? q.poll() : null;\n                        } catch (Throwable ex) {\n                                Exceptions.throwIfFatal(ex);\n                                errors.tryAddThrowableOrReport(ex);\n                                if (!delayErrors) {\n                                    cancelAll();\n                                    errors.tryTerminateConsumer(a);\n                                    return;\n                                }\n\n                                d = true;\n                            }\n\n                        boolean empty = v == null;\n\n                        if (d && empty) {\n                            cancelAll();\n                            errors.tryTerminateConsumer(a);\n                            return;\n                        }\n\n                        if (!empty) {\n                            values[j] = v;\n                        }\n                    }\n                }\n            }\n\n            if (e != 0L) {\n                for (ZipSubscriber<T, R> inner : qs) {\n                    inner.request(e);\n                }\n                if (r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n                }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "262", "src_id": "M558", "code": "    void innerSuccess(InnerObserver inner, R value) {\n        set.delete(inner);\n        if (get() == 0 && compareAndSet(0, 1)) {\n            downstream.onNext(value);\n            boolean d = active.decrementAndGet() == 0;\n            SpscLinkedArrayQueue<R> q = queue.get();\n\n            if (d && (q == null || q.isEmpty())) {\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n\n            if (decrementAndGet() == 0) {\n                return;\n            }\n        } else {\n\n            SpscLinkedArrayQueue<R> q = getOrCreateQueue();\n            synchronized (q) {\n                q.offer(value);\n            }\n            active.decrementAndGet();\n            if (getAndIncrement() != 0) {\n                return;\n            }\n        }\n\n        drainLoop();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "263", "src_id": "M2273", "code": "    @Override\n    public void onSubscribe(Subscription s) {\n\n        boolean cancel;\n\n        if (!done) {\n            synchronized (this) \n            {\n                if (done) {\n                    cancel = true;\n                } else {\n                    if (emitting) {\n\n                        AppendOnlyLinkedArrayList<Object> q = queue;\n\n                        if (q == null) {\n                            q = new AppendOnlyLinkedArrayList<>(4);\n                            queue = q;\n                        }\n\n                        q.add(NotificationLite.subscription(s));\n                        return;\n                    }\n\n                    emitting = true;\n                    cancel = false;\n                }\n            }\n        } else {\n            cancel = true;\n        }\n\n        if (cancel) {\n            s.cancel();\n        } else {\n            actual.onSubscribe(s);\n            emitLoop();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "1", "src_id": "M662", "code": "    private void finishing(Advice advice) {\n        // æ¬æ¬¡è°ç¨çèæ¶\n        try {\n            double cost = threadLocalWatch.costInMillis();\n            boolean conditionResult = isConditionMet(command.getConditionExpress(), advice, cost);\n            if (this.isVerbose()) {\n                process.write(\"Condition express: \" + command.getConditionExpress() + \" , result: \" + conditionResult + \"\\n\");\n            }\n\n            if (conditionResult) {\n                // TODO: concurrency issues for process.write\n                StackModel stackModel = ThreadUtil.getThreadStackModel(advice.getLoader(), Thread.currentThread());\n                stackModel.setTs(LocalDateTime.now());\n\n                process.appendResult(stackModel);\n\n                process.times().incrementAndGet();\n                if (isLimitExceeded(command.getNumberOfLimit(), process.times().get())) {\n                    abortProcess(process, command.getNumberOfLimit());\n                }\n            }\n        } catch (Throwable e) {\n                logger.warn(\"stack failed.\", e);\n\n                process.end(- 1, \"stack failed, condition is: \" + command.getConditionExpress() + \", \" + e.getMessage() + \", visit \" + LogUtil.loggingFile() + \" for more details.\");\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "2", "src_id": "M1051", "code": "    private Process createProcess(Session session, List<CliToken> line, InternalCommandManager commandManager, int jobId, Term term, ResultDistributor resultDistributor) {\n        try {\n            ListIterator<CliToken> tokens = line.listIterator();\n            while (tokens.hasNext()) {\n                CliToken token = tokens.next();\n                if (!(token.isText())) { \n                    continue; \n                }  \n                checkPermission(session, token);\n\n                Command command = commandManager.getCommand(token.value());\n                if (command != null) {\n                    return createCommandProcess(command, tokens, jobId, term, resultDistributor);\n                } else {\n                    throw new IllegalArgumentException(token.value() + \": command not found\");\n                }\n            }\n            throw new IllegalArgumentException();\n        } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "3", "src_id": "M464", "code": "    private void initCommands(List<String> disabledCommands) {\n        List<Class<? extends AnnotatedCommand>> commandClassList = new ArrayList<Class<? extends AnnotatedCommand>>(33);\n        commandClassList.add(HelpCommand.class);\n\n        commandClassList.add(AuthCommand.class);\n\n        commandClassList.add(KeymapCommand.class);\n\n        commandClassList.add(SearchClassCommand.class);\n\n        commandClassList.add(SearchMethodCommand.class);\n\n        commandClassList.add(ClassLoaderCommand.class);\n\n        commandClassList.add(JadCommand.class);\n\n        commandClassList.add(GetStaticCommand.class);\n\n        commandClassList.add(MonitorCommand.class);\n\n        commandClassList.add(StackCommand.class);\n\n        commandClassList.add(ThreadCommand.class);\n\n        commandClassList.add(TraceCommand.class);\n\n        commandClassList.add(WatchCommand.class);\n\n        commandClassList.add(TimeTunnelCommand.class);\n\n        commandClassList.add(JvmCommand.class);\n\n        commandClassList.add(MemoryCommand.class);\n\n        commandClassList.add(PerfCounterCommand.class);\n\n        // commandClassList.add(GroovyScriptCommand.class);\n        commandClassList.add(OgnlCommand.class);\n\n        commandClassList.add(MemoryCompilerCommand.class);\n\n        commandClassList.add(RedefineCommand.class);\n\n        commandClassList.add(RetransformCommand.class);\n\n        commandClassList.add(DashboardCommand.class);\n\n        commandClassList.add(DumpClassCommand.class);\n\n        commandClassList.add(HeapDumpCommand.class);\n\n        commandClassList.add(JulyCommand.class);\n\n        commandClassList.add(ThanksCommand.class);\n\n        commandClassList.add(OptionsCommand.class);\n\n        commandClassList.add(ClsCommand.class);\n\n        commandClassList.add(ResetCommand.class);\n\n        commandClassList.add(VersionCommand.class);\n\n        commandClassList.add(SessionCommand.class);\n\n        commandClassList.add(SystemPropertyCommand.class);\n\n        commandClassList.add(SystemEnvCommand.class);\n\n        commandClassList.add(VMOptionCommand.class);\n\n        commandClassList.add(LoggerCommand.class);\n\n        commandClassList.add(HistoryCommand.class);\n\n        commandClassList.add(CatCommand.class);\n\n        commandClassList.add(Base64Command.class);\n\n        commandClassList.add(EchoCommand.class);\n\n        commandClassList.add(PwdCommand.class);\n\n        commandClassList.add(MBeanCommand.class);\n\n        commandClassList.add(GrepCommand.class);\n\n        commandClassList.add(TeeCommand.class);\n\n        commandClassList.add(ProfilerCommand.class);\n\n        commandClassList.add(VmToolCommand.class);\n\n        commandClassList.add(StopCommand.class);\n        try {\n            if (ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Recording.class\") != null) {\n                commandClassList.add(JFRCommand.class);\n            }\n        } catch (Throwable e) {\n                logger.error(\"This jdk version not support jfr command\");\n            }\n\n\n        for (Class<? extends AnnotatedCommand> clazz : commandClassList) {\n            Name name = clazz.getAnnotation(Name.class);\n            if ((name != null && name.value() != null) && disabledCommands.contains(name.value())) {\n                continue;\n            }\n            commands.add(Command.create(clazz));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "4", "src_id": "M1305", "code": "    public synchronized EnhancerAffect enhance(final Instrumentation inst, int maxNumOfMatchedClass) throws UnmodifiableClassException {\n        // è·åéè¦å¢å¼ºçç±»éå\n        this.matchingClasses \n                 = GlobalOptions.isDisableSubClass\n                ? SearchUtils.searchClass(inst, \n                classNameMatcher)\n                 : SearchUtils.searchSubClass(inst, \n                SearchUtils.searchClass(inst, \n                classNameMatcher));\n        if (matchingClasses.size() > maxNumOfMatchedClass) {\n            affect.setOverLimitMsg(\"The number of matched classes is \" \n                     + matchingClasses.size()\n                     + \", greater than the limit value \" \n                     + maxNumOfMatchedClass \n                     + \". Try to change the limit with option '-m <arg>'.\");\n\n            return affect;\n        }\n\n        // è¿æ»¤ææ æ³è¢«å¢å¼ºçç±»\n        List<Pair<Class<?>, String>> filtedList = filter(matchingClasses);\n        if (!filtedList.isEmpty()) {\n            for (Pair<Class<?>, String> filted : filtedList) {\n                logger.info(\"ignore class: {}, reason: {}\", filted.getFirst().getName(), filted.getSecond());\n            }\n        }\n        logger.info(\"enhance matched classes: {}\", matchingClasses);\n\n        affect.setTransformer(this);\n\n        try {\n            ArthasBootstrap.getInstance().getTransformerManager().addTransformer(this, isTracing);\n\n            // æ¹éå¢å¼º\n            if (GlobalOptions.isBatchReTransform) {\n                final int size = matchingClasses.size();\n                final Class<?>[] classArray = new Class<?>[size];\n                arraycopy(matchingClasses.toArray(), 0, classArray, 0, size);\n                if (classArray.length > 0) {\n                    inst.retransformClasses(classArray);\n\n                    logger.info(\"Success to batch transform classes: \" + Arrays.toString(classArray));\n                }\n            } else {\n                // for each å¢å¼º\n                for (Class<?> clazz : matchingClasses) {\n                    try {\n                        inst.retransformClasses(clazz);\n\n                        logger.info(\"Success to transform class: \" + clazz);\n                    } catch (Throwable t) {\n                            logger.warn(\"retransform {} failed.\", clazz, t);\n                            if (t instanceof UnmodifiableClassException) {\n                                throw (UnmodifiableClassException) t;\n                            } else if (t instanceof RuntimeException) {\n                                throw (RuntimeException) t;\n                            } else {\n                                throw new RuntimeException(t);\n                            }\n\n                        }\n\n                }\n            }\n        } catch (Throwable e) {\n                logger.error(\"Enhancer error, matchingClasses: {}\", matchingClasses, e);\n\n                affect.setThrowable(e);\n            }\n\n\n        return affect;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "5", "src_id": "M1163", "code": "    public static DefaultFullHttpResponse directView(File dir, String path, FullHttpRequest request, ChannelHandlerContext ctx) throws IOException {\n        if (path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n\n        // path maybe: arthas-output/20201225-203454.svg \n        // éè¦å dirçparentæ¥å»æåç¼\n        File file = new File(dir.getParent(), path);\n        HttpVersion version = request.protocolVersion();\n\n        if (isSubFile(dir, file)) {\n            DefaultFullHttpResponse fullResp = new DefaultFullHttpResponse(version, HttpResponseStatus.OK);\n\n            if (file.isDirectory()) {\n                if (!path.endsWith(\"/\")) {\n                    fullResp.setStatus(HttpResponseStatus.FOUND).headers().set(HttpHeaderNames.LOCATION, \"/\" + path + \"/\");\n                }\n\n                String renderResult = renderDir(file, !isSameFile(dir, file));\n                fullResp.content().writeBytes(renderResult.getBytes(\"utf-8\"));\n\n                fullResp.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=utf-8\");\n\n                ctx.write(fullResp);\n\n                ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n                future.addListener(ChannelFutureListener.CLOSE);\n\n                return fullResp;\n            } else {\n                logger.info(\"get file now. file:\" + file.getPath());\n                if (file.isHidden() || !file.exists() || file.isDirectory() || !file.isFile()) {\n                    return null;\n                }\n\n                long fileLength = file.length();\n\n                if (fileLength < MIN_NETTY_DIRECT_SEND_SIZE) {\n                    FileInputStream fileInputStream = new FileInputStream(file);\n\n                    try {\n                        byte[] content = IOUtils.getBytes(fileInputStream);\n                        fullResp.content().writeBytes(content);\n\n                        HttpUtil.setContentLength(fullResp, fullResp.content().readableBytes());\n                    } finally {\n                            IOUtils.close(fileInputStream);\n                        }\n                    ChannelFuture channelFuture = ctx.writeAndFlush(fullResp);\n\n                    channelFuture.addListener((ChannelFutureListener) future -> {if (future\n                                    .isSuccess()\n                                    ) {ChannelFuture lastContentFuture = ctx\n                                    .writeAndFlush(LastHttpContent\n                                    .EMPTY_LAST_CONTENT); lastContentFuture\n                                    .addListener(ChannelFutureListener\n                                    .CLOSE)\n                                    ;} else {future.channel()\n                                    .close()\n                                    ;}});\n\n                    return fullResp;\n                }\n\n                logger.info(\"file {} size bigger than {}, send by future.\", file.getName(), MIN_NETTY_DIRECT_SEND_SIZE);\n\n                HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);\n                HttpUtil.setContentLength(response, fileLength);\n\n                setContentTypeHeader(response, file);\n\n                setDateAndCacheHeaders(response, file);\n                if (HttpUtil.isKeepAlive(request)) {\n                    response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n                }\n                // Write the initial line and the header.\n                ctx.write(response);\n\n                // Write the content.\n                ChannelFuture sendFileFuture;\n                ChannelFuture lastContentFuture;\n                RandomAccessFile raf = new RandomAccessFile(file, \"r\"); // will closed by netty\n\n\n                if (ctx.pipeline().get(SslHandler.class) == null) {\n                    sendFileFuture = ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());\n\n                    // Write the end marker.\n                    lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);\n                } else {\n                    sendFileFuture = ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)), ctx.newProgressivePromise());\n\n                    // HttpChunkedInput will write the end marker (LastHttpContent) for us.\n                    lastContentFuture = sendFileFuture;\n                }\n\n                sendFileFuture.addListener(new ChannelProgressiveFutureListener() {@Override public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {if (total \n                                    < 0\n                                    ) { // total unknown\n                                logger.info(future.channel() \n                                     + \" Transfer progress: \" \n                                     + progress)\n                                    ;} else {logger.info(future\n                                    .channel() \n                                     + \" Transfer progress: \" \n                                     + progress \n                                     + \" / \" \n                                     + total)\n                                    ;}}@Override public void operationComplete(ChannelProgressiveFuture future) {logger\n                                .info(future.channel() \n                                 + \" Transfer complete.\")\n                                ;}});\n\n                // Decide whether to close the connection or not.\n                if (!HttpUtil.isKeepAlive(request)) {\n                    // Close the connection when the whole content is written out.\n                    lastContentFuture.addListener(ChannelFutureListener.CLOSE);\n                }\n                return fullResp;\n            }\n\n        }\n\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "6", "src_id": "M1300", "code": "    @Override\n    public byte[] transform(final ClassLoader inClassLoader, \n            String className, Class<?> classBeingRedefined,\n            ProtectionDomain protectionDomain, \n            byte[] classfileBuffer) throws IllegalClassFormatException {\n        try {\n            // æ£æ¥classloaderè½å¦å è½½å° SpyAPIï¼å¦æä¸è½ï¼åæ¾å¼å¢å¼º\n            try {\n                if (inClassLoader != null) {\n                    inClassLoader.loadClass(SpyAPI.class.getName());\n                }\n            } catch (Throwable e) {\n                    logger.error(\"the classloader can not load SpyAPI, ignore it. classloader: {}, className: {}\", inClassLoader.getClass().getName(), className, e);\n\n                    return null;\n                }\n\n\n            // è¿éè¦åæ¬¡è¿æ»¤ä¸æ¬¡ï¼ä¸ºå¥ï¼å ä¸ºå¨transformçè¿ç¨ä¸­ï¼æå¯è½è¿ä¼åè¯çæ°çç±»\n            // æä»¥éè¦å°ä¹åéè¦è½¬æ¢çç±»éåä¼ éä¸æ¥ï¼åæ¬¡è¿è¡å¤æ­\n            if (matchingClasses != null && !matchingClasses.contains(classBeingRedefined)) {\n                return null;\n            }\n\n            //keep origin class reader for bytecode optimizations, avoiding JVM metaspace OOM.\n            ClassNode classNode = new ClassNode(Opcodes.ASM9);\n            ClassReader classReader = AsmUtils.toClassNode(classfileBuffer, classNode);\n            // remove JSR https://github.com/alibaba/arthas/issues/1304\n            classNode = AsmUtils.removeJSRInstructions(classNode);\n\n            // çæå¢å¼ºå­èç \n            DefaultInterceptorClassParser defaultInterceptorClassParser = new DefaultInterceptorClassParser();\n            final List<InterceptorProcessor> interceptorProcessors = new ArrayList<InterceptorProcessor>();\n            interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyInterceptor1.class));\n\n            interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyInterceptor2.class));\n\n            interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyInterceptor3.class));\n\n            if (this.isTracing) {\n                if (!this.skipJDKTrace) {\n                    interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceInterceptor1.class));\n\n                    interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceInterceptor2.class));\n\n                    interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceInterceptor3.class));\n                } else {\n                    interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceExcludeJDKInterceptor1.class));\n\n                    interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceExcludeJDKInterceptor2.class));\n\n                    interceptorProcessors.addAll(defaultInterceptorClassParser.parse(SpyTraceExcludeJDKInterceptor3.class));\n                }\n            }\n\n            List<MethodNode> matchedMethods = new ArrayList<MethodNode>();\n            for (MethodNode methodNode : classNode.methods) {\n                if (!isIgnore(methodNode, methodNameMatcher)) {\n                    matchedMethods.add(methodNode);\n                }\n            }\n\n            // https://github.com/alibaba/arthas/issues/1690\n            if (AsmUtils.isEnhancerByCGLIB(className)) {\n                for (MethodNode methodNode : matchedMethods) {\n                    if (AsmUtils.isConstructor(methodNode)) {\n                        AsmUtils.fixConstructorExceptionTable(methodNode);\n                    }\n                }\n            }\n\n            // ç¨äºæ£æ¥æ¯å¦å·²æå¥äº spyå½æ°ï¼å¦æå·²æåä¸éå¤å¤ç\n            GroupLocationFilter groupLocationFilter = new GroupLocationFilter();\n            LocationFilter enterFilter = new InvokeContainLocationFilter(Type.getInternalName(SpyAPI.class), \"atEnter\", LocationType.ENTER);\n            LocationFilter existFilter = new InvokeContainLocationFilter(Type.getInternalName(SpyAPI.class), \"atExit\", LocationType.EXIT);\n            LocationFilter exceptionFilter = new InvokeContainLocationFilter(Type.getInternalName(SpyAPI.class), \"atExceptionExit\", LocationType.EXCEPTION_EXIT);\n\n            groupLocationFilter.addFilter(enterFilter);\n\n            groupLocationFilter.addFilter(existFilter);\n\n            groupLocationFilter.addFilter(exceptionFilter);\n\n            LocationFilter invokeBeforeFilter = new InvokeCheckLocationFilter(Type.getInternalName(SpyAPI.class), \"atBeforeInvoke\", LocationType.INVOKE);\n            LocationFilter invokeAfterFilter = new InvokeCheckLocationFilter(Type.getInternalName(SpyAPI.class), \"atInvokeException\", LocationType.INVOKE_COMPLETED);\n            LocationFilter invokeExceptionFilter = new InvokeCheckLocationFilter(Type.getInternalName(SpyAPI.class), \"atInvokeException\", LocationType.INVOKE_EXCEPTION_EXIT);\n\n            groupLocationFilter.addFilter(invokeBeforeFilter);\n\n            groupLocationFilter.addFilter(invokeAfterFilter);\n\n            groupLocationFilter.addFilter(invokeExceptionFilter);\n\n            for (MethodNode methodNode : matchedMethods) {\n                if (AsmUtils.isNative(methodNode)) { \n                    logger.info(\"ignore native method: {}\", AsmUtils.methodDeclaration(Type.getObjectType(classNode.name), methodNode));\n                } else { \n                    if (AsmUtils.containsMethodInsnNode(methodNode, Type.getInternalName(SpyAPI.class), \"atBeforeInvoke\")) {\n                        for (AbstractInsnNode insnNode = methodNode.instructions.getFirst(); insnNode != null; insnNode = insnNode.getNext()) {\n                            if (insnNode instanceof MethodInsnNode) {\n                                final MethodInsnNode methodInsnNode = (MethodInsnNode) insnNode;\n                                if (this.skipJDKTrace) {\n                                    if (methodInsnNode.owner.startsWith(\"java/\")) {\n                                        continue;\n                                    }\n                                }\n\n                                // åå§ç±»åçboxç±»åç¸å³çé½è·³è¿\n                                if (AsmOpUtils.isBoxType(Type.getObjectType(methodInsnNode.owner))) {\n                                    continue;\n                                }\n                                AdviceListenerManager.registerTraceAdviceListener(inClassLoader, className, methodInsnNode.owner, methodInsnNode.name, methodInsnNode.desc, listener);\n                            }\n                        }\n                    } else {\n                        MethodProcessor methodProcessor = new MethodProcessor(classNode, methodNode, groupLocationFilter);\n\n                        for (InterceptorProcessor interceptor : interceptorProcessors) {\n                            try {\n                                List<Location> locations = interceptor.process(methodProcessor);\n                                for (Location location : locations) {\n                                    if (location instanceof MethodInsnNodeWare) {\n                                        MethodInsnNodeWare methodInsnNodeWare = (MethodInsnNodeWare) location;\n                                        MethodInsnNode methodInsnNode = methodInsnNodeWare.methodInsnNode();\n\n                                        AdviceListenerManager.registerTraceAdviceListener(inClassLoader, className, methodInsnNode.owner, methodInsnNode.name, methodInsnNode.desc, listener);\n                                    }\n                                }\n                            } catch (Throwable e) {\n                                    logger.error(\"enhancer error, class: {}, method: {}, interceptor: {}\", classNode.name, methodNode.name, interceptor.getClass().getName(), e);\n                                }\n\n                        }\n                    }\n\n                    // enter/exist æ»æ¯è¦æå¥ listener\n                    AdviceListenerManager.registerAdviceListener(inClassLoader, className, methodNode.name, methodNode.desc, listener);\n\n                    affect.addMethodAndCount(inClassLoader, className, methodNode.name, methodNode.desc);\n                } \n\n            }\n\n            // https://github.com/alibaba/arthas/issues/1223 , V1_5 çmajor versionæ¯49\n            if (AsmUtils.getMajorVersion(classNode.version) < 49) {\n                classNode.version = AsmUtils.setMajorVersion(classNode.version, 49);\n            }\n\n            byte[] enhanceClassByteArray = AsmUtils.toBytes(classNode, inClassLoader, classReader);\n            // å¢å¼ºæåï¼è®°å½ç±»\n            classBytesCache.put(classBeingRedefined, new Object());\n\n            // dump the class\n            dumpClassIfNecessary(className, enhanceClassByteArray, affect);\n\n            // æåè®¡æ°\n            affect.cCnt(1);\n\n            return enhanceClassByteArray;\n        } catch (Throwable t) {\n                logger.warn(\"transform loader[{}]:class[{}] failed.\", inClassLoader, className, t);\n\n                affect.setThrowable(t);\n            }\n\n\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "7", "src_id": "M982", "code": "    public static boolean completeMethodName(Completion completion) {\n        List<CliToken> tokens = completion.lineTokens();\n        String lastToken = completion.lineTokens().get(tokens.size() - 1).value();\n        if (StringUtils.isBlank(lastToken)) {\n            lastToken = \"\";\n        }\n\n        // retrieve the class name\n        String className;\n        if (StringUtils.isBlank(lastToken)) {\n            // tokens = { \" \", \"CLASS_NAME\", \" \"}\n            className = tokens.get(tokens.size() - 2).value();\n        } else {\n            // tokens = { \" \", \"CLASS_NAME\", \" \", \"PARTIAL_METHOD_NAME\"}\n            className = tokens.get(tokens.size() - 3).value();\n        }\n\n        Set<Class<?>> results = SearchUtils.searchClassOnly(completion.session().getInstrumentation(), className, 2);\n        if (results.size() != 1) {\n            // no class found or multiple class found\n            completion.complete(Collections.<String> emptyList());\n\n            return true;\n        }\n\n        Class<?> clazz = results.iterator().next();\n        List<String> res = new ArrayList<String>();\n        for (Method method : clazz.getDeclaredMethods()) {\n            if (StringUtils.isBlank(lastToken)) {\n                res.add(method.getName());\n            } else if (method.getName().startsWith(lastToken)) {\n                res.add(method.getName());\n            }\n\n        }\n        res.add(\"<init>\");\n        if (res.size() == 1) {\n            completion.complete(res.get(0).substring(lastToken.length()), true);\n\n            return true;\n        } else {\n            CompletionUtils.complete(completion, res);\n\n            return true;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "8", "src_id": "M249", "code": "    private void agentRegister(ChannelHandlerContext ctx, HandshakeComplete handshake, String requestUri) throws URISyntaxException {\n        QueryStringDecoder queryDecoder = new QueryStringDecoder(requestUri);\n        Map<String, List<String>> parameters = queryDecoder.parameters();\n        String appName = null;\n        List<String> appNameList = parameters.get(URIConstans.APP_NAME);\n        if (appNameList != null && !appNameList.isEmpty()) {\n            appName = appNameList.get(0);\n        }\n\n        // generate a random agent id\n        String id = null;\n        if (appName != null) {\n            // å¦ææä¼  app nameï¼åçæå¸¦ app nameåç¼çidï¼æ¹ä¾¿ç®¡ç\n            id = appName + \"_\" + RandomStringUtils.random(20, true, true).toUpperCase();\n        } else {\n            id = RandomStringUtils.random(20, true, true).toUpperCase();\n        }\n\n        // agentä¼ è¿æ¥ï¼åä¼åç¨ agentç\n        List<String> idList = parameters.get(URIConstans.ID);\n        if (idList != null && !idList.isEmpty()) {\n            id = idList.get(0);\n        }\n\n        String arthasVersion = null;\n        List<String> arthasVersionList = parameters.get(URIConstans.ARTHAS_VERSION);\n        if (arthasVersionList != null && !arthasVersionList.isEmpty()) {\n            arthasVersion = arthasVersionList.get(0);\n        }\n\n        final String finalId = id;\n        // URI responseUri = new URI(\"response\", null, \"/\", \"method=\" + MethodConstants.AGENT_REGISTER + \"&id=\" + id, null);\n        URI responseUri = UriComponentsBuilder\n                .newInstance()\n                .scheme(URIConstans.RESPONSE)\n                .path(\"/\")\n                .queryParam(URIConstans\n                .METHOD, \n                MethodConstants.AGENT_REGISTER)\n                .queryParam(URIConstans\n                .ID, \n                id)\n                .build()\n                .encode()\n                .toUri();\n        AgentInfo info = new AgentInfo();\n        // åé¢å¯è½ænginxä»£ç\n        HttpHeaders headers = handshake.requestHeaders();\n        String host = HttpUtils.findClientIP(headers);\n\n        if (host == null) {\n            SocketAddress remoteAddress = ctx.channel().remoteAddress();\n            if (remoteAddress instanceof InetSocketAddress) {\n                InetSocketAddress inetSocketAddress = (InetSocketAddress) remoteAddress;\n                info.setHost(inetSocketAddress.getHostString());\n\n                info.setPort(inetSocketAddress.getPort());\n            }\n        } else {\n            info.setHost(host);\n\n            Integer port = HttpUtils.findClientPort(headers);\n            if (port != null) {\n                info.setPort(port);\n            }\n        }\n\n        info.setChannelHandlerContext(ctx);\n        if (arthasVersion != null) {\n            info.setArthasVersion(arthasVersion);\n        }\n        tunnelServer.addAgent(id, info);\n\n        ctx.channel().closeFuture()\n                .addListener(new GenericFutureListener<Future<? super Void>>() {@Override public void operationComplete(Future<? super Void> future) throws Exception {tunnelServer\n                        .removeAgent(finalId)\n                        ;}});\n\n        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseUri.toString()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "9", "src_id": "M173", "code": "    @Override\n    public int[] startSubnegotiationLocal() {\n        int nCompoundWindowSize = m_nWidth * 0x10000 + m_nHeight;\n        int nResponseSize = 5;\n        int nIndex;\n        int nShift;\n        int nTurnedOnBits;\n        if ((m_nWidth % 0x100) == 0xFF) {\n            nResponseSize += 1;\n        }\n\n        if ((m_nWidth / 0x100) == 0xFF) {\n            nResponseSize += 1;\n        }\n\n        if ((m_nHeight % 0x100) == 0xFF) {\n            nResponseSize += 1;\n        }\n\n        if ((m_nHeight / 0x100) == 0xFF) {\n            nResponseSize += 1;\n        }\n\n        //\n        // allocate response array\n        //\n        int response[] = new int[nResponseSize]; //\n        // Build response array.\n        // ---------------------\n        // 1. put option name.\n        // 2. loop through Window size and fill the values,\n        // 3.    duplicate 'ff' if needed.\n        //\n\n        response[0] = WINDOW_SIZE;                          // 1 //\n\n\n        for (                                               // 2 //\n            nIndex = 1, nShift = 24;\n            nIndex < nResponseSize;\n            nIndex++, nShift -= 8) {\n            nTurnedOnBits = 0xFF;\n\n            nTurnedOnBits <<= nShift;\n\n            response[nIndex] = (nCompoundWindowSize & nTurnedOnBits) >>> nShift;\n            if (response[nIndex] != 0xff) { \n                continue; \n            }  \n            nIndex++;\n\n            response[nIndex] = 0xff;\n        }\n        return response;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "10", "src_id": "M1370", "code": "    @SuppressWarnings({ \"unchecked\", \"restriction\" })\n    public static URL[] getUrls(ClassLoader classLoader) {\n        if (classLoader instanceof URLClassLoader) {\n            try {\n                return ((URLClassLoader) classLoader).getURLs();\n            } catch (Throwable e) {\n                    logger.error(\"classLoader: {} getUrls error\", classLoader, e);\n                }\n\n        }\n\n        // jdk9\n        if (classLoader.getClass().getName().startsWith(\"jdk.internal.loader.ClassLoaders$\")) {\n            try {\n                Field field = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n                field.setAccessible(true);\n\n                sun.misc.Unsafe unsafe = (sun.misc.Unsafe) field.get(null);\n                Class<?> ucpOwner = classLoader.getClass();\n                Field ucpField = null;\n                // jdk 9~15: jdk.internal.loader.ClassLoaders$AppClassLoader.ucp\n                // jdk 16~17: jdk.internal.loader.BuiltinClassLoader.ucp\n                while (ucpField == null && !ucpOwner.getName().equals(\"java.lang.Object\")) {\n                    try {\n                        ucpField = ucpOwner.getDeclaredField(\"ucp\");\n                    } catch (NoSuchFieldException ex) {\n                            ucpOwner = ucpOwner.getSuperclass();\n                        }\n\n                }\n\n                if (ucpField == null) {\n                    return null;\n                }\n\n                long ucpFieldOffset = unsafe.objectFieldOffset(ucpField);\n                Object ucpObject = unsafe.getObject(classLoader, ucpFieldOffset);\n                if (ucpObject == null) {\n                    return null;\n                }\n\n                // jdk.internal.loader.URLClassPath.path\n                Field pathField = ucpField.getType().getDeclaredField(\"path\");\n                if (pathField == null) {\n                    return null;\n                }\n\n                long pathFieldOffset = unsafe.objectFieldOffset(pathField);\n                ArrayList<URL> path = (ArrayList<URL>) unsafe.getObject(ucpObject, pathFieldOffset);\n                return path.toArray(new URL[path.size()]);\n            } catch (Throwable e) {\n                    // ignore\n                    return null;\n                }\n\n        }\n\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "209", "src_id": "M361", "code": "    private static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n        try {\n            if (!isValidJakartaMailPart(part)) {\n                log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n                return;\n            }\n\n            Class<?> partClass = part.getClass();\n            Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n            Method getContent = partClass.getMethod(\"getContent\");\n            Method getDisposition = partClass.getMethod(\"getDisposition\");\n            Method getFileName = partClass.getMethod(\"getFileName\");\n            Method getContentType = partClass.getMethod(\"getContentType\");\n            Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n            Object disposition = getDisposition.invoke(part);\n            String filename = (String) getFileName.invoke(part);\n            String contentType = (String) getContentType.invoke(part);\n\n            if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n                content.setTextBody((String) getContent.invoke(part));\n            } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n                content.setHtmlBody((String) getContent.invoke(part));\n            } else if (\"attachment\".equalsIgnoreCase((String) disposition) || (filename != null && !filename.trim().isEmpty())) {\n                content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n\n                // Always extract basic attachment metadata for display\n                if (filename != null && !filename.trim().isEmpty()) {\n\n                    // Create attachment with metadata only\n                    EmailAttachment attachment = new EmailAttachment();\n                    // Apply MIME decoding to filename to handle encoded attachment names\n                    attachment.setFilename(safeMimeDecode(filename));\n                    attachment.setContentType(contentType);\n\n                    // Check if it's an embedded image\n                    String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n\n                    if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                        attachment.setEmbedded(true);\n                        // Store the Content-ID, removing angle brackets if present\n                        String contentId = contentIdHeaders[0];\n\n                        if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                            contentId = contentId.substring(1, contentId.length() - 1);\n                        }\n\n                        attachment.setContentId(contentId);\n                    }\n\n                    // Extract attachment data if attachments should be included OR if it's an\n                    // embedded image (needed for inline display)\n                    if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) \n                    {\n                        try {\n\n                            Object attachmentContent = getContent.invoke(part);\n                            byte[] attachmentData = null;\n\n                            if (attachmentContent instanceof java.io.InputStream inputStream) {\n                                try {\n                                    attachmentData = inputStream.readAllBytes();\n                                } catch (IOException e) {\n                                        log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n                                    }\n\n                            } else if (attachmentContent instanceof byte[] byteArray) {\n                                attachmentData = byteArray;\n                            } else if (attachmentContent instanceof String stringContent) {\n                                attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n                            }\n\n\n                            if (attachmentData != null) {\n                                // Check size limit (use default 10MB if request is null)\n                                long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                                long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                                if (attachmentData.length <= maxSizeBytes) {\n                                    attachment.setData(attachmentData);\n                                    attachment.setSizeBytes(attachmentData.length);\n                                } else {\n                                    // For embedded images, always include data regardless of size\n                                    // to ensure inline display works\n                                    if (attachment.isEmbedded()) { \n                                        attachment.setData(attachmentData);\n                                    }  \n\n                                    attachment.setSizeBytes(attachmentData.length);\n                                }\n                            }\n                        } catch (Exception e) {\n                                log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n                            }\n\n                    }\n\n                    // Add attachment to the list for display (with or without data)\n                    content.getAttachments().add(attachment);\n                }\n            } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) \n            {\n                // Handle nested multipart content\n                try {\n\n                    Object multipartContent = getContent.invoke(part);\n                    Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n\n                    if (multipartClass.isInstance(multipartContent)) {\n                        processMultipartAdvanced(multipartContent, content, request);\n                    }\n                } catch (Exception e) {\n                        log.warn(\"Error processing multipart content: {}\", e.getMessage());\n                    }\n\n            }\n        } catch (Exception e) {\n                log.warn(\"Error processing multipart part: {}\", e.getMessage());\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "210", "src_id": "M347", "code": "    private static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n        // Create attachment info with paperclip emoji before filename\n        attachmentInfo.append(\"<div class=\\\"attachment-item\\\">\")\n                .append(\"<span class=\\\"attachment-icon\\\">\")\n                .append(MimeConstants.ATTACHMENT_MARKER)\n                .append(\"</span> \")\n                .append(\"<span class=\\\"attachment-name\\\">\")\n                .append(escapeHtml(filename))\n                .append(\"</span>\");\n        // Add content type and encoding info\n        if (!contentType.isEmpty() || !encoding.isEmpty()) {\n            attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n            if (!contentType.isEmpty()) {\n                attachmentInfo.append(escapeHtml(contentType));\n            }\n\n            if (!encoding.isEmpty()) {\n                if (!contentType.isEmpty()) {\n                    attachmentInfo.append(\", \");\n                }\n\n                attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n            }\n\n            attachmentInfo.append(\")</span>\");\n        }\n\n        attachmentInfo.append(\"</div>\\n\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "211", "src_id": "M567", "code": "    @PostMapping(value = \"/scanner-effect\", consumes = \"multipart/form-data\")\n    @Operation(\n    summary = \"Apply scanner effect to PDF\",\n    description = \n    \"Applies various effects to simulate a scanned document, including rotation, noise, and edge softening. Input:PDF Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> scannerEffect(@ModelAttribute @Valid ScannerEffectRequest request) throws IOException {\n\n        MultipartFile file = request.getFileInput();\n\n        // Apply preset first if needed\n        if (!request.isAdvancedEnabled()) \n        {\n            switch (request.getQuality()) \n            {\n                case high -> request.applyHighQualityPreset();\n                case medium -> request.applyMediumQualityPreset();\n                case low -> request.applyLowQualityPreset();\n            }\n        }\n\n        // Extract values after preset application\n        int baseRotation = request.getRotationValue() + request.getRotate();\n        int rotateVariance = request.getRotateVariance();\n        int borderPx = request.getBorder();\n        float brightness = request.getBrightness();\n        float contrast = request.getContrast();\n        float blur = request.getBlur();\n        float noise = request.getNoise();\n        boolean yellowish = request.isYellowish();\n        int resolution = request.getResolution();\n        ScannerEffectRequest.Colorspace colorspace = request.getColorspace();\n\n        try (PDDocument document = pdfDocumentFactory.load(file)) {\n\n            PDDocument outputDocument = new PDDocument();\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            for (int i = 0; i < document.getNumberOfPages(); i++) {\n                // Get page dimensions to calculate safe resolution\n                PDRectangle pageSize = document.getPage(i).getMediaBox();\n                float pageWidthPts = pageSize.getWidth();\n                float pageHeightPts = pageSize.getHeight();\n                // Calculate what the image dimensions would be at the requested resolution\n                int projectedWidth = (int) Math.ceil(pageWidthPts * resolution / 72.0);\n                int projectedHeight = (int) Math.ceil(pageHeightPts * resolution / 72.0);\n                long projectedPixels = (long) projectedWidth * projectedHeight;\n                // Calculate safe resolution that stays within limits\n                int safeResolution = resolution;\n\n                if (projectedWidth > MAX_IMAGE_WIDTH || projectedHeight > MAX_IMAGE_HEIGHT || projectedPixels > MAX_IMAGE_PIXELS) {\n                    double widthScale = (double) MAX_IMAGE_WIDTH / projectedWidth;\n                    double heightScale = (double) MAX_IMAGE_HEIGHT / projectedHeight;\n                    double pixelScale = Math.sqrt((double) MAX_IMAGE_PIXELS / projectedPixels);\n                    double minScale = Math.min(Math.min(widthScale, heightScale), pixelScale);\n                    safeResolution = (int) Math.max(72, resolution * minScale);\n                    log.warn(\"Page {} would be too large at {}dpi ({}x{} pixels). Reducing to {}dpi\", i + 1, resolution, projectedWidth, projectedHeight, safeResolution);\n                }\n\n                // Render page to image with safe resolution\n                BufferedImage image = pdfRenderer.renderImageWithDPI(i, safeResolution);\n                log.debug(\"Processing page {} with dimensions {}x{} ({} pixels) at {}dpi\", i + 1, image.getWidth(), image.getHeight(),(long) image.getWidth() * image.getHeight(), safeResolution);\n\n                // 1. Convert to grayscale or keep color\n                BufferedImage processed;\n\n                if (colorspace == ScannerEffectRequest.Colorspace.grayscale) {\n                    processed = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);\n\n                    Graphics2D gGray = processed.createGraphics();\n                    gGray.setColor(Color.BLACK);\n                    gGray.fillRect(0, 0, image.getWidth(), image.getHeight());\n                    gGray.drawImage(image, 0, 0, null);\n                    gGray.dispose();\n                    // Convert to grayscale manually\n                    for (int y = 0; y < processed.getHeight(); y++) {\n                        for (int x = 0; x < processed.getWidth(); x++) {\n\n                            int rgb = processed.getRGB(x, y);\n                            int r = (rgb >> 16) & 0xFF;\n                            int g = (rgb >> 8) & 0xFF;\n                            int b = rgb & 0xFF;\n                            int gray = (r + g + b) / 3;\n                            int grayRGB = (gray << 16) | (gray << 8) | gray;\n                            processed.setRGB(x, y, grayRGB);\n                        }\n                    }\n                } else {\n                    processed = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_RGB);\n\n                    Graphics2D gCol = processed.createGraphics();\n                    gCol.drawImage(image, 0, 0, null);\n                    gCol.dispose();\n                }\n\n                // 2. Add border with randomized grey gradient\n                int baseW = processed.getWidth() + 2 * borderPx;\n                int baseH = processed.getHeight() + 2 * borderPx;\n                boolean vertical = RANDOM.nextBoolean();\n                float startGrey = 0.6f + 0.3f * RANDOM.nextFloat();\n                float endGrey = 0.6f + 0.3f * RANDOM.nextFloat();\n                Color startColor = new Color(Math.round(startGrey * 255), Math.round(startGrey * 255), Math.round(startGrey * 255));\n                Color endColor = new Color(Math.round(endGrey * 255), Math.round(endGrey * 255), Math.round(endGrey * 255));\n                BufferedImage composed = new BufferedImage(baseW, baseH, processed.getType());\n                Graphics2D gBg = composed.createGraphics();\n                for (int y = 0; y < baseH; y++) {\n                    for (int x = 0; x < baseW; x++) {\n                        float frac = vertical ? (float) y / (baseH - 1) : (float) x / (baseW - 1);\n                        int r = Math.round(startColor.getRed() + (endColor.getRed() - startColor.getRed()) * frac);\n                        int g = Math.round(startColor.getGreen() + (endColor.getGreen() - startColor.getGreen()) * frac);\n                        int b = Math.round(startColor.getBlue() + (endColor.getBlue() - startColor.getBlue()) * frac);\n                        composed.setRGB(x, y, new Color(r, g, b).getRGB());\n                    }\n                }\n                gBg.drawImage(processed, borderPx, borderPx, null);\n                gBg.dispose();\n                // 3. Rotate the entire composed image\n                double pageRotation = baseRotation;\n\n                if (baseRotation != 0 || rotateVariance != 0) {\n                    pageRotation += (RANDOM.nextDouble() * 2 -1) * rotateVariance;\n                }\n\n                BufferedImage rotated;\n                int w = composed.getWidth();\n                int h = composed.getHeight();\n                int rotW = w;\n                int rotH = h;\n\n                // Skip rotation entirely if no rotation is needed\n                if (pageRotation == 0) {\n                    rotated = composed;\n                } else {\n\n                    double radians = Math.toRadians(pageRotation);\n                    double sin = Math.abs(Math.sin(radians));\n                    double cos = Math.abs(Math.cos(radians));\n                    rotW = (int) Math.floor(w * cos + h * sin);\n                    rotH = (int) Math.floor(h * cos + w * sin);\n\n                    BufferedImage rotatedBg = new BufferedImage(rotW, rotH, composed.getType());\n                    Graphics2D gBgRot = rotatedBg.createGraphics();\n                    for (int y = 0; y < rotH; y++) {\n                        for (int x = 0; x < rotW; x++) {\n                            float frac = vertical ? (float) y / (rotH - 1) : (float) x / (rotW - 1);\n                            int r = Math.round(startColor.getRed() + (endColor.getRed() - startColor.getRed()) * frac);\n                            int g = Math.round(startColor.getGreen() + (endColor.getGreen() - startColor.getGreen()) * frac);\n                            int b = Math.round(startColor.getBlue() + (endColor.getBlue() - startColor.getBlue()) * frac);\n                            rotatedBg.setRGB(x, y, new Color(r, g, b).getRGB());\n                        }\n                    }\n                    gBgRot.dispose();\n                    rotated = new BufferedImage(rotW, rotH, composed.getType());\n                    Graphics2D g2d = rotated.createGraphics();\n                    g2d.drawImage(rotatedBg, 0, 0, null);\n                    AffineTransform at = new AffineTransform();\n                    at.translate((rotW - w) / 2.0, (rotH - h) / 2.0);\n                    at.rotate(radians, w / 2.0, h / 2.0);\n                    g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n                    g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n                    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n                    g2d.drawImage(composed, at, null);\n                    g2d.dispose();\n                }\n\n                // 4. Scale and center the rotated image to cover the original page size\n                PDRectangle origPageSize = document.getPage(i).getMediaBox();\n                float origW = origPageSize.getWidth();\n                float origH = origPageSize.getHeight();\n                float scale = Math.max(origW / rotW, origH / rotH);\n                float drawW = rotW * scale;\n                float drawH = rotH * scale;\n                float offsetX = (origW - drawW) / 2f;\n                float offsetY = (origH - drawH) / 2f;\n                // 5. Apply adaptive blur and edge softening\n                BufferedImage softened = softenEdges(rotated, Math.max(10, Math.round(Math.min(rotW, rotH) * 0.02f)), startColor, endColor, vertical);\n                BufferedImage blurred = applyGaussianBlur(softened, blur);\n                // 6. Adjust brightness and contrast\n                BufferedImage adjusted = adjustBrightnessContrast(blurred, brightness, contrast);\n\n                // 7. Add noise and yellowish effect to the content\n                if (yellowish) {\n                    applyYellowishEffect(adjusted);\n                }\n\n                addGaussianNoise(adjusted, noise);\n                // 8. Write to PDF\n                PDPage newPage = new PDPage(new PDRectangle(origW, origH));\n                outputDocument.addPage(newPage);\n                try (PDPageContentStream contentStream = \n                    new PDPageContentStream(outputDocument, newPage)) {\n                    PDImageXObject pdImage = LosslessFactory.createFromImage(outputDocument, adjusted);\n                    contentStream.drawImage(pdImage, offsetX, offsetY, drawW, drawH);\n                }\n            }\n\n            // Save to byte array\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            outputDocument.save(outputStream);\n            outputDocument.close();\n\n            String outputFilename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_scanner_effect.pdf\";\n            return WebResponseUtils.bytesToWebResponse(outputStream.toByteArray(), outputFilename, MediaType.APPLICATION_PDF);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "212", "src_id": "M509", "code": "    @Operation(\n    summary = \"Convert EML to PDF\",\n    description = \n    \"This endpoint converts EML (email) files to PDF format with extensive\"\n    + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n    + \" and HTML debug output. Input: EML file, Output: PDF\"\n    + \" or HTML file. Type: SISO\")\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n    public ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n\n        MultipartFile inputFile = request.getFileInput();\n        String originalFilename = inputFile.getOriginalFilename();\n\n        // Validate input\n        if (inputFile.isEmpty()) {\n            log.error(\"No file provided for EML to PDF conversion.\");\n            return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        if (originalFilename == null) {\n            log.error(\"Filename is null or empty.\");\n            return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        // Validate file type - support EML\n        if (originalFilename.trim().isEmpty()) {\n        log.error(\"Filename is null or empty.\");\n            return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n            }\n\n        // Validate file type - support EML\n        String lowerFilename = originalFilename.toLowerCase();\n\n        if (!lowerFilename.endsWith(\".eml\")) {\n            log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n            return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n\n        try {\n\n            byte[] fileBytes = inputFile.getBytes();\n\n            if (request.isDownloadHtml()) \n            {\n                try {\n                    String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                    log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                    return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8), baseFilename + \".html\", MediaType.TEXT_HTML);\n                } catch (IOException | IllegalArgumentException e) {\n                        log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n                    }\n\n            }\n\n            // Convert EML to PDF with enhanced options\n            try {\n                byte[] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig.getWeasyPrintPath(), // Use configured WeasyPrint path\n                request, fileBytes, originalFilename, false, pdfDocumentFactory, tempFileManager);\n\n                if (pdfBytes == null) {\n                    log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n                }\n\n                if (pdfBytes.length == 0) {\n                log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n                    }\n\n                log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n            } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n                } catch (IllegalArgumentException e) {\n                    String errorMessage = buildErrorMessage(e, originalFilename);\n                    log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n                } catch (RuntimeException e) {\n                    String errorMessage = buildErrorMessage(e, originalFilename);\n                    log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n                }\n\n        } catch (IOException e) {\n                log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "48", "src_id": "M8", "code": "        private static String formatFileSize(long size) {\n            String hrSize;\n            double b = size;\n            double k = size / 1024.0;\n            double m = ((size / 1024.0) / 1024.0);\n            double g = (((size / 1024.0) / 1024.0) / 1024.0);\n            double t = ((((size / 1024.0) / 1024.0) / 1024.0) / 1024.0);\n            DecimalFormat dec = new DecimalFormat(\"0.00\");\n\n            if (t > 1) {\n                hrSize = dec.format(t).concat(\" TB\");\n            } else if (g > 1) {\n                hrSize = dec.format(g).concat(\" GB\");\n            } else if (m > 1) {\n                hrSize = dec.format(m).concat(\" MB\");\n            } else if (k > 1) {\n                hrSize = dec.format(k).concat(\" KB\");\n            } else {\n                hrSize = dec.format(b).concat(\" Bytes\");\n            }\n\n\n            return hrSize;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "49", "src_id": "M357", "code": "        private static Class[] parseTypes(String desc, ClassLoader loader)throws ClassNotFoundException {\n            int lparen = desc.indexOf('(');\n            int rparen = desc.indexOf(')', lparen);\n            List params = new ArrayList();\n            int start = lparen + 1;\n            for (;;) {\n                int comma = desc.indexOf(',', start);\n                if (comma < 0) {\n                    break;\n                }\n\n                params.add(desc.substring(start, comma).trim());\n                start = comma + 1;\n            }\n\n            if (start < rparen) {\n                params.add(desc.substring(start, rparen).trim());\n            }\n\n            Class[] types = new Class[params.size()];\n            for (int i = 0; i < types.length; i++) {\n                types[i] = getClass((String) params.get(i), loader);\n            }\n            return types;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "50", "src_id": "M566", "code": "        @Override\n        public void process(final CommandProcess process) {\n            Session session = process.session();\n\n            timer = new Timer(\"Timer-for-arthas-dashboard-\" + session.getSessionId(), true);\n            // ctrl-C support\n            process.interruptHandler(new DashboardInterruptHandler(process, timer));\n            /*\n         * éè¿handleåè°ï¼å¨suspendåendæ¶åæ­¢timerï¼resumeæ¶éå¯timer\n         */\n\n            Handler<Void> stopHandler = new Handler<Void>() {@Override public void handle(Void event) {stop();}};\n            Handler<Void> restartHandler = new Handler<Void>() {@Override public void handle(Void event) {restart(process);}};\n\n            process.suspendHandler(stopHandler);\n            process.resumeHandler(restartHandler);\n            process.endHandler(stopHandler);\n            // q exit support\n            process.stdinHandler(new QExitHandler(process));\n            // start the timer\n            timer.scheduleAtFixedRate(new DashboardTimerTask(process), 0, getInterval());\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "51", "src_id": "M114", "code": "        public boolean isAvailable() {\n            if (isConnected()) {\n                try {\n                    if (_socket_.getInetAddress() == null || _socket_.getPort() == 0) {\n                        return false;\n                    }\n                    if (_socket_.getRemoteSocketAddress() == null || _socket_.isClosed()) {\n                        return false;\n                    }\n                    if (_socket_.isInputShutdown() || _socket_.isOutputShutdown()) {\n                        return false;\n                    }\n\n                    _socket_.getInputStream();\n                    _socket_.getOutputStream();\n                } catch (IOException ioex) {\n                        return false;\n                    }\n\n                return true;\n            } else {\n                return false;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "52", "src_id": "M232", "code": "        public void start()throws Exception {\n            // Configure SSL.\n            final SslContext sslCtx;\n\n            if (ssl) {\n                SelfSignedCertificate ssc = new SelfSignedCertificate();\n\n                sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n            } else {\n                sslCtx = null;\n            }\n\n            ServerBootstrap b = new ServerBootstrap();\n\n            b.group(bossGroup, workerGroup)\n            .channel(NioServerSocketChannel.class)\n            .handler(new LoggingHandler(LogLevel\n            .INFO))\n            .childHandler(new TunnelSocketServerInitializer(this, \n            sslCtx));\n\n            if (StringUtils.isBlank(host)) {\n                channel = b.bind(port).sync().channel();\n            } else {\n                channel = b.bind(host, port).sync().channel();\n            }\n\n            logger.info(\"Tunnel server listen at {}:{}\", host, port);\n            workerGroup.scheduleWithFixedDelay(new Runnable() {@Override public void run() {agentInfoMap\n                    .entrySet()\n                    .removeIf(e -> !e.getValue().getChannelHandlerContext()\n                    .channel()\n                    .isActive())\n                    ; clientConnectionInfoMap.entrySet()\n                    .removeIf(e -> !e.getValue().getChannelHandlerContext()\n                    .channel()\n                    .isActive())\n                    ;// æ´æ°éç¾¤keyä¿¡æ¯\n                    if (tunnelClusterStore != null && clientConnectHost \n                         != null\n                        ) {try {for (Entry<String, AgentInfo> entry : agentInfoMap\n                                .entrySet()) {tunnelClusterStore\n                                .addAgent(entry.getKey(), new AgentClusterInfo(entry\n                                .getValue(), \n                                clientConnectHost, port), \n                                60 * 60, TimeUnit.SECONDS)\n                                ;}} catch (Throwable t) {logger\n                                .error(\"update tunnel info error\", \n                                t)\n                                ;}}}}, \n            60, 60, TimeUnit.SECONDS);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "53", "src_id": "M65", "code": "        public Map<String, Class<?>> build() {\n            errors.clear();\n            warnings.clear();\n\n            JavaFileManager fileManager = new DynamicJavaFileManager(standardFileManager, dynamicClassLoader);\n            DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<JavaFileObject>();\n            JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, collector, options, null, compilationUnits);\n\n            try {\n                if (!compilationUnits.isEmpty()) {\n                    boolean result = task.call();\n\n                    if (!result || collector.getDiagnostics().size() > 0) {\n                        for (Diagnostic<? extends JavaFileObject> diagnostic : collector.getDiagnostics()) {\n                            switch (diagnostic.getKind()) {\n                                case NOTE:\n                                case MANDATORY_WARNING:\n                                case WARNING:\n                                    warnings.add(diagnostic);\n                                    break;\n                                case OTHER:\n                                case ERROR:\n                                default:\n                                    errors.add(diagnostic);\n                                    break;\n                            }\n                        }\n\n                        if (!errors.isEmpty()) {\n                            throw new DynamicCompilerException(\"Compilation Error\", errors);\n                        }\n                    }\n                }\n\n                return dynamicClassLoader.getClasses();\n            } catch (Throwable e) {\n                    throw new DynamicCompilerException(e, errors);\n                } finally {\n                    compilationUnits.clear();\n                }\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "54", "src_id": "M183", "code": "        public SimpleHttpResponse query(String targetUrl)throws InterruptedException {\n            final Promise<SimpleHttpResponse> httpResponsePromise = GlobalEventExecutor.INSTANCE.newPromise();\n            final EventLoopGroup group = new NioEventLoopGroup(1, new DefaultThreadFactory(\"arthas-ProxyClient\", true));\n            ChannelFuture closeFuture = null;\n\n            try {\n                Bootstrap b = new Bootstrap();\n\n                b.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n                b.group(group).channel(LocalChannel.class)\n                .handler(new ChannelInitializer<LocalChannel>() {@Override protected void initChannel(LocalChannel ch) {ChannelPipeline p = ch\n                        .pipeline(); p.addLast(new HttpClientCodec(), \n                        new HttpObjectAggregator(ArthasConstants\n                        .MAX_HTTP_CONTENT_LENGTH),\n                                                    new HttpProxyClientHandler(httpResponsePromise))\n                        ;}});\n\n                LocalAddress localAddress = new LocalAddress(ArthasConstants.NETTY_LOCAL_ADDRESS);\n                Channel localChannel = b.connect(localAddress).sync().channel();\n                // Prepare the HTTP request.\n                HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, targetUrl, Unpooled.EMPTY_BUFFER);\n\n                request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n                localChannel.writeAndFlush(request);\n                closeFuture = localChannel.closeFuture();\n                logger.info(\"proxy client connect to server success, targetUrl: \" + targetUrl);\n                return httpResponsePromise.get(5000, TimeUnit.MILLISECONDS);\n            } catch (Throwable e) {\n                    logger.error(\"ProxyClient error, targetUrl: {}\", targetUrl, e);\n                } finally {\n                    if (closeFuture != null) {\n                        closeFuture.addListener(new ChannelFutureListener() {@Override public void operationComplete(ChannelFuture channelFuture)throws Exception {group\n                                .shutdownGracefully()\n                                ;}});\n                    } else {\n                        group.shutdownGracefully();\n                    }\n                }\n\n            SimpleHttpResponse httpResponse = new SimpleHttpResponse();\n\n            try {\n                httpResponse.setContent(\"error\".getBytes(\"utf-8\"));\n            } catch (UnsupportedEncodingException e) {\n                // ignore\n                }\n\n\n            return httpResponse;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "55", "src_id": "M131", "code": "        @Override\n        public void write(int ch)throws IOException{\n            synchronized (__client) {\n                ch &= 0xff;\n\n                if (__client._requestedWont(TelnetOption.BINARY)) // i.e. ASCII\n                {\n                    if (__lastWasCR) {\n                        if (__convertCRtoCRLF) {\n                            __client._sendByte('\\n');\n                            if (ch == '\\n') // i.e. was CRLF anyway\n                            {\n                                __lastWasCR = false;\n                                return;\n                            }\n                        } // __convertCRtoCRLF\n                        else if (ch != '\\n') {\n                            __client._sendByte('\\0'); // RFC854 requires CR NUL for bare CR\n\n                        }\n\n                    }\n\n                    switch (ch) {\n                        case '\\r':\n                            __client._sendByte('\\r');\n                            __lastWasCR = true;\n                            break;\n                        case '\\n':\n                            if (!__lastWasCR) { // convert LF to CRLF\n\n                                __client._sendByte('\\r');\n                            }\n                            __client._sendByte(ch);\n                            __lastWasCR = false;\n                            break;\n                        case TelnetCommand.IAC:\n                            __client._sendByte(TelnetCommand.IAC);\n                            __client._sendByte(TelnetCommand.IAC);\n                            __lastWasCR = false;\n                            break;\n                        default:\n                            __client._sendByte(ch);\n                            __lastWasCR = false;\n                            break;\n                    }\n                } // end ASCII\n                else if (ch == TelnetCommand.IAC) {\n                    __client._sendByte(ch);\n                    __client._sendByte(TelnetCommand.IAC);\n                } else {\n                    __client._sendByte(ch);\n                }\n\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "56", "src_id": "M443", "code": "        private String drawField() {\n            final StringBuilder fieldSB = new StringBuilder();\n            final Field[] fields = clazz.getDeclaredFields();\n\n            if (fields.length > 0) {\n\n                for (Field field : fields) {\n                    final KVView kvView = new KVView(new TableView.ColumnDefine(TableView\n                    .Align\n                    .RIGHT), \n                    new TableView.ColumnDefine(50, false, \n                    TableView.Align.LEFT))\n                    .add(\"modifier\", StringUtils.modifier(field\n                    .getModifiers(), \n                    ','))\n                    .add(\"type\", StringUtils.classname(field\n                    .getType()))\n                    .add(\"name\", field.getName());\n                    final StringBuilder annotationSB = new StringBuilder();\n                    final Annotation[] annotationArray = field.getAnnotations();\n\n                    if (null != annotationArray && annotationArray.length > 0) {\n                        for (Annotation annotation : annotationArray) {\n                            annotationSB.append(StringUtils.classname(annotation.annotationType())).append(\",\");\n                        }\n\n                        if (annotationSB.length() > 0) {\n                            annotationSB.deleteCharAt(annotationSB.length() - 1);\n                        }\n\n                        kvView.add(\"annotation\", annotationSB);\n                    }\n\n                    if (Modifier.isStatic(field.getModifiers())) {\n                        final boolean isAccessible = field.isAccessible();\n\n                        try {\n                            field.setAccessible(true);\n                            kvView.add(\"value\", StringUtils.objectToString(field.get(null)));\n                        } catch (IllegalAccessException e) {\n                            //\n                            } finally {\n                                field.setAccessible(isAccessible);\n                            }\n\n                    }//if\n\n\n                    fieldSB.append(kvView.draw()).append(\"\\n\");\n                }//for\n\n            }\n\n            return fieldSB.toString();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "57", "src_id": "M1439", "code": "        public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter, String charsToDelete) {\n            if (ObjectUtils.isEmpty(array)) {\n                return null;\n            } else {\n                Properties result = new Properties();\n                String[] var4 = array;\n                int var5 = array.length;\n                for (int var6 = 0; var6 < var5; ++var6) {\n                    String element = var4[var6];\n                    if (charsToDelete != null) {\n                        element = deleteAny(element, charsToDelete);\n                    }\n\n                    String[] splittedElement = split(element, delimiter);\n\n                    if (splittedElement != null) {\n                        result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());\n                    }\n                }\n                return result;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "319", "src_id": "M1470", "code": "  public static Pair<String, NavigableMap<Integer, Integer>> decompileWithMappings(String classFilePath,\n      String methodName, boolean hideUnicode, \n      boolean printLineNumber) {\n    final StringBuilder sb = new StringBuilder(8192);\n    final NavigableMap<Integer, Integer> lineMapping = new TreeMap<Integer, Integer>();\n    OutputSinkFactory mySink = new OutputSinkFactory() {@Override public List<SinkClass> getSupportedSinks(SinkType sinkType, Collection<SinkClass> collection) {return Arrays\n            .asList(SinkClass.STRING, SinkClass.DECOMPILED, \n            SinkClass.DECOMPILED_MULTIVER, SinkClass.EXCEPTION_MESSAGE, \n            SinkClass.LINE_NUMBER_MAPPING)\n            ;}@Override public <T> Sink<T> getSink(final SinkType sinkType, final SinkClass sinkClass) {return new Sink<T>() {@Override public void write(T sinkable) { // skip message like: Analysing type demo.MathGame\n            if (sinkType == SinkType.PROGRESS) {return;} if (sinkType \n                   == SinkType.LINENUMBER\n                  ) {LineNumberMapping mapping = (LineNumberMapping) sinkable; NavigableMap<Integer, Integer> classFileMappings = mapping\n              .getClassFileMappings(); NavigableMap<Integer, Integer> mappings = mapping.getMappings();if (classFileMappings != null && mappings != null) {for (Entry<Integer, Integer> entry : mappings.entrySet()) {Integer srcLineNumber = classFileMappings.get(entry.getKey()); lineMapping.put(entry.getValue(), srcLineNumber);}} return;}sb.append(sinkable);}}\n        ;}};\n    HashMap<String, String> options = new HashMap<String, String>(); /**\n         * @see org.benf.cfr.reader.util.MiscConstants.Version.getVersion() Currently,\n         *      the cfr version is wrong. so disable show cfr version.\n         */\n    options.put(\"showversion\", \"false\");\n    options.put(\"hideutf\", String.valueOf(hideUnicode));\n    options.put(\"trackbytecodeloc\", \"true\");\n    if (!StringUtils.isBlank(methodName)) {\n      options.put(\"methodname\", methodName);\n    }\n\n    CfrDriver driver = new CfrDriver.Builder().withOptions(options).withOutputSink(mySink).build();\n    List<String> toAnalyse = new ArrayList<String>();\n    toAnalyse.add(classFilePath);\n    driver.analyse(toAnalyse);\n    String resultCode = sb.toString();\n    if (printLineNumber && !lineMapping.isEmpty()) {\n      resultCode = addLineNumber(resultCode, lineMapping);\n    }\n    return Pair.make(resultCode, lineMapping);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "320", "src_id": "M1355", "code": "  public static String nullSafeToString(char[] array) {\n    if (array == null) {\n      return \"null\";\n    } else {\n      int length = array.length;\n      if (length == 0) {\n        return \"{}\";\n      } else {\n        StringBuilder sb = new StringBuilder(\"{\");\n        for (int i = 0; i < length; ++i) {\n          if (i > 0) {\n            sb.append(\", \");\n          }\n          sb.append(\"\\'\").append(array[i]).append(\"\\'\");\n        }\n\n        sb.append(\"}\");\n        return sb.toString();\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "321", "src_id": "M454", "code": "  private void renderObject(Object obj, int deep, int expand, final StringBuilder buf) throws ObjectTooLargeException {\n    if (obj == null) {\n      appendStringBuilder(buf, \"null\");\n    } else {\n      final Class<?> clazz = obj.getClass();\n      final String className = clazz.getSimpleName();\n\n      // 7ç§åºç¡ç±»å,ç´æ¥è¾åº@ç±»å[å¼]\n      if (Integer.class.isInstance(obj)\n             || Long.class.isInstance(obj)\n             || Float.class.isInstance(obj)\n             || Double.class.isInstance(obj)\n        //                    || Character.class.isInstance(obj)\n            || Short.class.isInstance(obj)\n             || Byte.class.isInstance(obj)\n             || Boolean.class.isInstance(obj)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n      }// Charè¦ç¹æ®å¤ç,å ä¸ºæä¸å¯è§å­ç¬¦çå ç´ \n      else if (Character.class.isInstance(obj)) {\n        final Character c = (Character) obj;\n        // ASCIIçå¯è§å­ç¬¦\n        if (c >= 32 && c <= 126) {\n          appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n        }// ASCIIçæ§å¶å­ç¬¦\n        else if (ASCII_MAP.containsKey((byte) c.charValue())) {\n          appendStringBuilder(buf, format(\"@%s[%s]\", className, ASCII_MAP.get((byte) c.charValue())));\n        }// è¶è¿ASCIIçç¼ç èå´\n        else {\n          appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n        }\n\n      }// å­ç¬¦ä¸²ç±»ååç¬å¤ç\n      else if (String.class.isInstance(obj)) {\n        appendStringBuilder(buf, \"@\");\n        appendStringBuilder(buf, className);\n        appendStringBuilder(buf, \"[\");\n\n        for (Character c : ((String) obj).toCharArray()) {\n          switch (c) {\n            case '\\n':\n              appendStringBuilder(buf, \"\\\\n\");\n              break;\n            case '\\r':\n              appendStringBuilder(buf, \"\\\\r\");\n              break;\n            default:\n              appendStringBuilder(buf, c.toString());\n          }//switch\n\n        }//for\n\n\n        appendStringBuilder(buf, \"]\");\n      }// éåç±»è¾åº\n      else if (Collection.class.isInstance(obj)) {\n        @SuppressWarnings(\"unchecked\") final Collection<Object> collection = (Collection<Object>) obj;\n\n        // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n        if (!isExpand(deep, expand) || collection.isEmpty()) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, collection.isEmpty(), collection.size()));\n        }// å±å¼å±ç¤º\n        else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n\n          for (Object e : collection) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            renderObject(e, deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) {\n            appendStringBuilder(buf, TAB);\n          }\n\n          appendStringBuilder(buf, \"]\");\n        }\n      }// Mapç±»è¾åº\n      else if (Map.class.isInstance(obj)) {\n        @SuppressWarnings(\"unchecked\") final Map<Object, Object> map = (Map<Object, Object>) obj;\n\n        // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n        if (!isExpand(deep, expand) || map.isEmpty()) {\n          appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, map.isEmpty(), map.size()));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n\n          for (Map.Entry<Object, Object> entry : map.entrySet()) {\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep + 1; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            renderObject(entry.getKey(), deep + 1, expand, buf);\n            appendStringBuilder(buf, \":\");\n            renderObject(entry.getValue(), deep + 1, expand, buf);\n            appendStringBuilder(buf, \",\");\n          }\n\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) {\n            appendStringBuilder(buf, TAB);\n          }\n\n          appendStringBuilder(buf, \"]\");\n        }\n      }// æ°ç»ç±»è¾åº\n      else if (obj.getClass().isArray()) {\n        final String typeName = obj.getClass().getSimpleName();\n\n        // int[]\n        if (typeName.equals(\"int[]\")) {\n          final int[] arrays = (int[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (int e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// long[]\n        else if (typeName.equals(\"long[]\")) {\n          final long[] arrays = (long[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (long e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// short[]\n        else if (typeName.equals(\"short[]\")) {\n          final short[] arrays = (short[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (short e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// float[]\n        else if (typeName.equals(\"float[]\")) {\n          final float[] arrays = (float[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (float e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// double[]\n        else if (typeName.equals(\"double[]\")) {\n          final double[] arrays = (double[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (double e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// boolean[]\n        else if (typeName.equals(\"boolean[]\")) {\n          final boolean[] arrays = (boolean[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (boolean e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// char[]\n        else if (typeName.equals(\"char[]\")) {\n          final char[] arrays = (char[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (char e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// byte[]\n        else if (typeName.equals(\"byte[]\")) {\n          final byte[] arrays = (byte[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (byte e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }// Object[]\n        else {\n          final Object[] arrays = (Object[]) obj;\n\n          // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n          if (!isExpand(deep, expand) || arrays.length == 0) {\n            appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n          }// å±å¼å±ç¤º\n          else {\n            appendStringBuilder(buf, format(\"@%s[\", className));\n\n            for (Object e : arrays) {\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              renderObject(e, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            }\n\n            appendStringBuilder(buf, \"\\n\");\n            for (int i = 0; i < deep; i++) {\n              appendStringBuilder(buf, TAB);\n            }\n\n            appendStringBuilder(buf, \"]\");\n          }\n        }\n\n      }// Throwableè¾åº\n      else if (Throwable.class.isInstance(obj)) {\n        if (!isExpand(deep, expand)) {\n          appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n        } else {\n          final Throwable throwable = (Throwable) obj;\n          final StringWriter sw = new StringWriter();\n          final PrintWriter pw = new PrintWriter(sw);\n          throwable.printStackTrace(pw);\n          appendStringBuilder(buf, sw.toString());\n        }\n      }// Dateè¾åº\n      else if (Date.class.isInstance(obj)) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\").format(obj)));\n      } else if (object instanceof Enum<?>) {\n        appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n      }// æ®éObjectè¾åº\n      else {\n        if (!isExpand(deep, expand)) {\n          appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n        } else {\n          appendStringBuilder(buf, format(\"@%s[\", className));\n          final List<Field> fields;\n          Class<?> objClass = obj.getClass();\n          if (GlobalOptions.printParentFields) {\n            fields = new ArrayList<Field>();\n            // å½ç¶ç±»ä¸ºnullçæ¶åè¯´æå°è¾¾äºæä¸å±çç¶ç±»(Objectç±»).\n            while (objClass != null) {\n              fields.addAll(Arrays.asList(objClass.getDeclaredFields()));\n              objClass = objClass.getSuperclass();\n            }\n          } else {\n            fields = new ArrayList<Field>(Arrays.asList(objClass.getDeclaredFields()));\n          }\n\n          for (Field field : fields) {\n            field.setAccessible(true);\n\n            try {\n              final Object value = field.get(obj);\n              appendStringBuilder(buf, \"\\n\");\n              for (int i = 0; i < deep + 1; i++) {\n                appendStringBuilder(buf, TAB);\n              }\n\n              appendStringBuilder(buf, field.getName());\n              appendStringBuilder(buf, \"=\");\n              renderObject(value, deep + 1, expand, buf);\n              appendStringBuilder(buf, \",\");\n            } catch (ObjectTooLargeException t) {\n                buf.append(\"...\");\n                break;\n              } catch (Throwable t) {\n              // ignore\n              }\n          }//for\n\n\n          appendStringBuilder(buf, \"\\n\");\n          for (int i = 0; i < deep; i++) {\n            appendStringBuilder(buf, TAB);\n          }\n\n          appendStringBuilder(buf, \"]\");\n        }\n      }\n\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "322", "src_id": "M140", "code": "  void _processDo(int option) throws IOException {\n    if (debugoptions) {\n      System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n    }\n\n    if (__notifhand != null) {\n      __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n    }\n\n    boolean acceptNewState = false; /* open TelnetOptionHandler functionality (start)*/\n    if (optionHandlers[option] != null) {\n      acceptNewState = optionHandlers[option].getAcceptLocal();\n    } else { /* open TelnetOptionHandler functionality (end)*//* TERMINAL-TYPE option (start)*/\n      if (option == TERMINAL_TYPE && ((terminalType != null) && (terminalType.length() > 0))) {\n        acceptNewState = true;\n      }\n    }/* open TelnetOptionHandler functionality (end)*/\n\n    if (_willResponse[option] > 0) {\n      --_willResponse[option];\n      if (_willResponse[option] > 0 && _stateIsWill(option)) {\n        --_willResponse[option];\n      }\n    }\n\n    if (_willResponse[option] == 0) {\n      if (_requestedWont(option)) {\n        switch (option) {\n          default:\n            break;\n        }\n\n        if (acceptNewState) {\n          _setWantWill(option);\n          _sendWill(option);\n        } else {\n          ++_willResponse[option];\n          _sendWont(option);\n        }\n      } else { // Other end has acknowledged option.\n\n        switch (option) {\n          default:\n            break;\n        }\n      }\n    }\n\n    _setWill(option);\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "323", "src_id": "M927", "code": "  public static Map<String, Map<String, Object>> getLoggers(String name, boolean includeNoAppender) {\n    Map<String, Map<String, Object>> loggerInfoMap = new HashMap<String, Map<String, Object>>();\n    if (!Log4j) {\n      return loggerInfoMap;\n    }\n\n    if (name != null && !name.trim().isEmpty()) {\n      Logger logger = LogManager.getLoggerRepository().exists(name);\n      if (logger != null) {\n        loggerInfoMap.put(name, doGetLoggerInfo(logger));\n      }\n    } else {\n      // è·åææloggeræ¶ï¼å¦ææ²¡æappenderåå¿½ç¥\n      @SuppressWarnings(\"unchecked\") Enumeration<Logger> loggers = LogManager.getLoggerRepository().getCurrentLoggers();\n\n      if (loggers != null) {\n        while (loggers.hasMoreElements()) {\n          Logger logger = loggers.nextElement();\n          Map<String, Object> info = doGetLoggerInfo(logger);\n          if (!includeNoAppender) {\n            List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n              loggerInfoMap.put(logger.getName(), info);\n            }\n          } else {\n            loggerInfoMap.put(logger.getName(), info);\n          }\n        }\n      }\n\n      Logger root = LogManager.getLoggerRepository().getRootLogger();\n      if (root != null) {\n        Map<String, Object> info = doGetLoggerInfo(root);\n        if (!includeNoAppender) {\n          List<?> appenders = (List<?>) info.get(LoggerHelper.appenders);\n          if (appenders != null && !appenders.isEmpty()) {\n            loggerInfoMap.put(root.getName(), info);\n          }\n        } else {\n          loggerInfoMap.put(root.getName(), info);\n        }\n      }\n    }\n\n    return loggerInfoMap;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "324", "src_id": "M464", "code": "  private void initCommands(List<String> disabledCommands) {\n    List<Class<? extends AnnotatedCommand>> commandClassList = new ArrayList<Class<? extends AnnotatedCommand>>(33);\n    commandClassList.add(HelpCommand.class);\n    commandClassList.add(AuthCommand.class);\n    commandClassList.add(KeymapCommand.class);\n    commandClassList.add(SearchClassCommand.class);\n    commandClassList.add(SearchMethodCommand.class);\n    commandClassList.add(ClassLoaderCommand.class);\n    commandClassList.add(JadCommand.class);\n    commandClassList.add(GetStaticCommand.class);\n    commandClassList.add(MonitorCommand.class);\n    commandClassList.add(StackCommand.class);\n    commandClassList.add(ThreadCommand.class);\n    commandClassList.add(TraceCommand.class);\n    commandClassList.add(WatchCommand.class);\n    commandClassList.add(TimeTunnelCommand.class);\n    commandClassList.add(JvmCommand.class);\n    commandClassList.add(MemoryCommand.class);\n    commandClassList.add(PerfCounterCommand.class);\n    // commandClassList.add(GroovyScriptCommand.class);\n    commandClassList.add(OgnlCommand.class);\n    commandClassList.add(MemoryCompilerCommand.class);\n    commandClassList.add(RedefineCommand.class);\n    commandClassList.add(RetransformCommand.class);\n    commandClassList.add(DashboardCommand.class);\n    commandClassList.add(DumpClassCommand.class);\n    commandClassList.add(HeapDumpCommand.class);\n    commandClassList.add(JulyCommand.class);\n    commandClassList.add(ThanksCommand.class);\n    commandClassList.add(OptionsCommand.class);\n    commandClassList.add(ClsCommand.class);\n    commandClassList.add(ResetCommand.class);\n    commandClassList.add(VersionCommand.class);\n    commandClassList.add(SessionCommand.class);\n    commandClassList.add(SystemPropertyCommand.class);\n    commandClassList.add(SystemEnvCommand.class);\n    commandClassList.add(VMOptionCommand.class);\n    commandClassList.add(LoggerCommand.class);\n    commandClassList.add(HistoryCommand.class);\n    commandClassList.add(CatCommand.class);\n    commandClassList.add(Base64Command.class);\n    commandClassList.add(EchoCommand.class);\n    commandClassList.add(PwdCommand.class);\n    commandClassList.add(MBeanCommand.class);\n    commandClassList.add(GrepCommand.class);\n    commandClassList.add(TeeCommand.class);\n    commandClassList.add(ProfilerCommand.class);\n    commandClassList.add(VmToolCommand.class);\n    commandClassList.add(StopCommand.class);\n    try {\n      if (ClassLoader.getSystemClassLoader().getResource(\"jdk/jfr/Recording.class\") != null) {\n        commandClassList.add(JFRCommand.class);\n      }\n    } catch (Throwable e) {\n        logger.error(\"This jdk version not support jfr command\");\n      }\n\n\n    for (Class<? extends AnnotatedCommand> clazz : commandClassList) {\n      Name name = clazz.getAnnotation(Name.class);\n      if ((name != null && name.value() != null) && disabledCommands.contains(name.value())) {\n        continue;\n      }\n      commands.add(Command.create(clazz));\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "325", "src_id": "M453", "code": "  @Override\n  public String draw() {\n    StringBuilder buf = new StringBuilder();\n    try {\n      if (GlobalOptions.isUsingJson) {\n        return JSON.toJSONString(object, JSONWriter.Feature.IgnoreErrorGetter);\n      }\n      renderObject(object, 0, deep, buf);\n      return buf.toString();\n    } catch (ObjectTooLargeException e) {\n        buf.append(\" Object size exceeds size limit: \")\n            .append(maxObjectLength)\n            .append(\", try to specify -M size_limit in your command, check the help command for more.\");\n        return buf.toString();\n      } catch (Throwable t) {\n        logger.error(\"ObjectView draw error, object class: {}\", object.getClass(), t);\n        return \"ERROR DATA!!! object class: \" + object.getClass() + \", exception class: \" + t.getClass() + \", exception message: \" + t.getMessage();\n      }\n\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "326", "src_id": "M375", "code": "  public static Map<String, String> removeDashKey(Map<String, String> map) {\n    Map<String, String> result = new HashMap<String, String>(map.size());\n    for (Entry<String, String> entry : map.entrySet()) {\n      String key = entry.getKey();\n      if (key.contains(\"-\")) {\n        StringBuilder sb = new StringBuilder(key.length());\n        for (int i = 0; i < key.length(); i++) {\n          if (key.charAt(i) == '-' && (i + 1 < key.length()) && Character.isAlphabetic(key.charAt(i + 1))) {\n            ++i;\n            char upperChar = Character.toUpperCase(key.charAt(i));\n            sb.append(upperChar);\n          } else {\n            sb.append(key.charAt(i));\n          }\n        }\n\n        key = sb.toString();\n      }\n\n      result.put(key, entry.getValue());\n    }\n\n    return result;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "327", "src_id": "M306", "code": "  final void advance() {\n    if (nextEntry != null && (nextEntry = nextEntry.next) != null) {\n      return;\n    }\n\n    while (nextTableIndex >= 0) {\n      if ((nextEntry = currentTable[nextTableIndex--]) != null) {\n        return;\n      }\n    }\n\n    while (nextSegmentIndex >= 0) {\n      Segment<K, V> seg = segments[nextSegmentIndex--];\n      if (seg.count != 0) {\n        currentTable = seg.table;\n        for (int j = currentTable.length - 1; j >= 0; --j) {\n          if ((nextEntry = currentTable[j]) != null) {\n            nextTableIndex = j - 1;\n            return;\n          }\n        }\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "328", "src_id": "M1338", "code": "  public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {\n    Enum[] var3 = enumValues;\n    int var4 = enumValues.length;\n    for (int var5 = 0; \n      true; \n      ++var5) { \n      if (var5 >= var4) {\n        return false;\n      }\n      Enum candidate = var3[var5];\n      if (caseSensitive) {\n        if (candidate.toString().equals(constant)) {\n          break;\n        }\n      } else if (candidate.toString().equalsIgnoreCase(constant)) {\n        break;\n      }\n\n    } \n\n    return true;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "115", "src_id": "M9", "code": "    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n\n                if (redisKeysToCacheKeys.containsKey(mapKey)) \n                {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n\n            stats.load();\n            return entry;\n        } finally {\n                lock.unlock();\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "116", "src_id": "M55", "code": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Map<String, Long> build(Object data) {\n\n        final List<Object> list = (List<Object>) data;\n\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (!(list.get(0) instanceof KeyValue)) {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n            }\n            return map;\n        } else {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n\n            while (iterator.hasNext()) {\n\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n            }\n\n            return map;\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1145", "code": "    @Override\n    public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n        Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n        boolean isErrored = false;\n        T reply = null;\n        JedisBroadcastException bcastError = new JedisBroadcastException();\n        for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n            HostAndPort node = HostAndPort.from(entry.getKey());\n            ConnectionPool pool = entry.getValue();\n            try (Connection connection = pool.getResource()) {\n\n                T aReply = execute(connection, commandObject);\n                bcastError.addReply(node, aReply);\n                if (isErrored) { // already errored\n\n                } else if (reply == null) \n                {\n                    reply = aReply; // ok\n\n                } else if (reply.equals(aReply)) {\n                // ok\n                } else {\n                    isErrored = true;\n                    reply = null;\n                }\n\n            } catch (Exception anError) {\n                    bcastError.addReply(node, anError);\n                    isErrored = true;\n                }\n\n        }\n\n        if (isErrored) {\n            throw bcastError;\n        }\n\n        return reply;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1141", "code": "    @Override\n    public final <T> T executeCommand(CommandObject<T> commandObject) {\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n        int consecutiveConnectionFailures = 0;\n        JedisException lastException = null;\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n\n            Connection connection = null;\n            try {\n                connection = provider.getConnection(commandObject.getArguments());\n                return execute(connection, commandObject);\n            } catch (JedisConnectionException jce) {\n                    lastException = jce;\n                    ++consecutiveConnectionFailures;\n                    log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n\n                    // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                    boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n\n                    if (reset) {\n                        consecutiveConnectionFailures = 0;\n                    }\n                } finally {\n                    if (connection != null) {\n                        connection.close();\n                    }\n                }\n\n            if (Instant.now().isAfter(deadline)) {\n                throw new JedisException(\"Retry deadline exceeded.\");\n            }\n        }\n\n        JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n        maxAttemptsException.addSuppressed(lastException);\n        throw maxAttemptsException;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1346", "code": "    @Override\n    public Map<String, Map<String, Double>> build(Object data) {\n\n        List rawDataList = (List) data;\n\n        if (rawDataList.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (rawDataList.get(0) instanceof KeyValue) {\n            KeyValue rawData = (KeyValue) rawDataList.get(0);\n            String header = STRING.build(rawData.getKey());\n\n            if (!RESULTS.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n\n            return ((List<KeyValue>) rawData\n                    .getValue()\n                    )\n                    .stream()\n                    .collect(Collectors.toMap(rawTerm -> STRING\n                    .build(rawTerm.getKey()),\n                    rawTerm -> ((List<List<KeyValue>>) rawTerm\n                    .getValue()\n                    )\n                    .stream()\n                    .collect(Collectors.toMap(entry -> STRING\n                    .build(entry.get(0).getKey()),\n                    entry -> BuilderFactory.DOUBLE\n                    .build(entry.get(0).getValue()))),\n                    (x, y) -> x, LinkedHashMap::new));\n        }\n\n        Map<String, Map<String, Double>> returnTerms = new LinkedHashMap<>(rawDataList.size());\n        for (Object rawData : rawDataList) {\n            List<Object> rawElements = (List<Object>) rawData;\n            String header = STRING.build(rawElements.get(0));\n\n            if (!TERM.equals(header)) {\n                throw new IllegalStateException(\"Unrecognized header: \" + header);\n            }\n\n            String term = STRING.build(rawElements.get(1));\n            List<List<Object>> list = (List<List<Object>>) rawElements.get(2);\n            Map<String, Double> entries = new LinkedHashMap<>(list.size());\n            list.forEach(entry -> entries.put(STRING.build(entry.get(1)), BuilderFactory.DOUBLE.build(entry.get(0))));\n            returnTerms.put(term, entries);\n        }\n\n        return returnTerms;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "120", "src_id": "M1102", "code": "    @Override\n    public final List<Object> exec() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"EXEC without MULTI\");\n        }\n\n        try (Connection connection = failoverProvider.getConnection()) {\n            commands.forEach((command) -> connection.sendCommand(command.getKey())); // following connection.getMany(int) flushes anyway, so no flush here.\n\n            // ignore QUEUED (or ERROR)\n            connection.getMany(commands.size());\n            // remove extra response builders\n            for (int idx = 0; idx < extraCommandCount.get(); ++idx) {\n                commands.poll();\n            }\n            connection.sendCommand(EXEC);\n            List<Object> unformatted = connection.getObjectMultiBulkReply();\n\n            if (unformatted == null) {\n                commands.clear();\n                return null;\n            }\n\n            List<Object> formatted = new ArrayList<>(unformatted.size() - extraCommandCount.get());\n\n            for (Object rawReply: unformatted) {\n                try {\n                    Response<?> response = commands.poll().getValue();\n                    response.set(rawReply);\n                    formatted.add(response.get());\n                } catch (JedisDataException e) {\n                        formatted.add(e);\n                    }\n\n            }\n\n            return formatted;\n        } finally {\n                inMulti = false;\n                inWatch = false;\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "121", "src_id": "M925", "code": "    private void process() {\n\n        do {\n            Object reply = authenticator.client.getUnflushedObject();\n\n            if (!(reply instanceof List)) {\n                if (!(reply instanceof byte[])) \n                {\n                    throw new JedisException(\"Unknown message type: \" + reply);\n                } else {\n                    Consumer<Object> resultHandler = authenticator.resultHandler.poll();\n\n                    if (resultHandler == null) {\n                        throw new JedisException(\"Unexpected message : \" + SafeEncoder.encode((byte[]) reply));\n                    }\n\n                    resultHandler.accept(reply);\n                }\n            } else {\n\n                List<Object> listReply = (List<Object>) reply;\n                final Object firstObj = listReply.get(0);\n\n                if (!(firstObj instanceof byte[])) {\n                    throw new JedisException(\"Unknown message type: \" + firstObj);\n                }\n\n                final byte[] resp = (byte[]) firstObj;\n\n                if (Arrays.equals(SSUBSCRIBE.getRaw(), resp)) {\n                    subscribedChannels = ((Long) listReply.get(2)).intValue();\n\n                    final byte[] bchannel = (byte[]) listReply.get(1);\n                    final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                    onSSubscribe(enchannel, subscribedChannels);\n                } else if (Arrays.equals(SUNSUBSCRIBE.getRaw(), resp)) {\n                    subscribedChannels = ((Long) listReply.get(2)).intValue();\n\n                    final byte[] bchannel = (byte[]) listReply.get(1);\n                    final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                    onSUnsubscribe(enchannel, subscribedChannels);\n                } else if (!(Arrays.equals(SMESSAGE.getRaw(), resp))) {\n                    throw new JedisException(\"Unknown message type: \" + firstObj);\n                } else {\n                    final byte[] bchannel = (byte[]) listReply.get(1);\n                    final byte[] bmesg = (byte[]) listReply.get(2);\n                    final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                    final T enmesg = (bmesg == null) ? null : encode(bmesg);\n                    onSMessage(enchannel, enmesg);\n                } \n\n            } \n        } while (!Thread.currentThread().isInterrupted() && isSubscribed());\n    //    /* Invalidate instance since this thread is no longer listening */\n    //    this.client = null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "122", "src_id": "M126", "code": "    @Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof CommandObject)) {\n            return false;\n        }\n\n        Iterator<Rawable> e1 = arguments.iterator();\n        Iterator<Rawable> e2 = ((CommandObject) o).arguments.iterator();\n\n        while (e1.hasNext() && e2.hasNext()) {\n\n            Rawable o1 = e1.next();\n            Rawable o2 = e2.next();\n\n            if (!(o1 == null ? o2 == null : o1.equals(o2))) {\n                return false;\n            }\n        }\n        if (e1.hasNext()) {\n            return false;\n        }\n\n        if (e2.hasNext()) {\n        return false;\n            }\n\n        return builder == ((CommandObject) o).builder;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "123", "src_id": "M918", "code": "    public CommandArguments add(Object arg) {\n\n        if (arg == null) \n        {\n            throw new IllegalArgumentException(\"null is not a valid argument.\");\n        } else if (arg instanceof Rawable) \n        {\n            args.add((Rawable) arg);\n        } else if (arg instanceof byte[]) \n        {\n            args.add(RawableFactory.from((byte[]) arg));\n        } else if (arg instanceof Boolean) \n        {\n            args.add(RawableFactory.from((Boolean) arg));\n        } else if (arg instanceof Integer) \n        {\n            args.add(RawableFactory.from((Integer) arg));\n        } else if (arg instanceof Long) \n        {\n            args.add(RawableFactory.from((Long) arg));\n        } else if (arg instanceof Double) \n        {\n            args.add(RawableFactory.from((Double) arg));\n        } else if (arg instanceof float[]) \n        {\n            args.add(RawableFactory.from(RediSearchUtil.toByteArray((float[]) arg)));\n        } else if (arg instanceof String) \n        {\n            args.add(RawableFactory.from((String) arg));\n        } else if (!(arg instanceof GeoCoordinate)) \n        {\n            args.add(RawableFactory.from(String.valueOf(arg)));\n        } else {\n\n            GeoCoordinate geo = (GeoCoordinate) arg;\n            args.add(RawableFactory.from(geo.getLongitude() + \",\" + geo.getLatitude()));\n        } \n\n\n        return this;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "124", "src_id": "M1216", "code": "    private void initMaster(HostAndPort master) {\n        initPoolLock.lock();\n\n        try {\n\n            if (!master.equals(currentMaster)) {\n                currentMaster = master;\n                ConnectionPool newPool = createNodePool(currentMaster);\n                ConnectionPool existingPool = pool;\n                pool = newPool;\n                LOG.info(\"Created connection pool to master at {}.\", master);\n                if (clientSideCache != null) {\n                    clientSideCache.flush();\n                }\n\n                if (existingPool != null) {\n                    // although we clear the pool, we still have to check the returned object in getResource,\n                    // this call only clears idle instances, not borrowed instances\n                    // existingPool.clear(); // necessary??\n                    existingPool.close();\n                }\n            }\n        } finally {\n                initPoolLock.unlock();\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "58", "src_id": "M47", "code": "private static long findProcessByTelnetClient(String arthasHomeDir, int telnetPort) {\n     // start java telnet client\n     List<String> telnetArgs = new ArrayList<String>();\n     \n     telnetArgs.add(\"-c\");\n     telnetArgs.add(\"session\");\n     telnetArgs.add(\"--execution-timeout\");\n     telnetArgs.add(\"2000\");\n     // telnet port ,ip\n     telnetArgs.add(\"127.0.0.1\");\n     telnetArgs.add(\"\" + telnetPort);\n     try {\n          ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n          String error = null;\n          int status = ProcessUtils.startArthasClient(arthasHomeDir, telnetArgs, out);\n          \n          if (status == STATUS_EXEC_TIMEOUT) {\n               error = \"detection timeout\";\n          } else if (status == STATUS_EXEC_ERROR) {\n               error = \"detection error\";\n               AnsiLog.error(\"process status: {}\", status);\n               AnsiLog.error(\"process output: {}\", out.toString());\n          } else {\n          // ignore connect error\n          }\n          \n          if (error != null) {\n               AnsiLog.error(\"The telnet port {} is used, but process {}, you will connect to an unexpected process.\", telnetPort, error);\n               AnsiLog.error(\"Try to use a different telnet port, for example: java -jar arthas-boot.jar --telnet-port 9998 --http-port -1\");\n               System.exit(1);\n          }\n\n          //parse output, find java pid\n          String output = out.toString(\"UTF-8\");\n          String javaPidLine = null;\n          Scanner scanner = new Scanner(output);\n          while (scanner.hasNextLine()) {\n               String line = scanner.nextLine();\n               if (line.contains(\"JAVA_PID\")) {\n                    javaPidLine = line;\n                    break;\n               }\n          }\n          if (javaPidLine != null) {\n               // JAVA_PID    10473\n               try {\n                    String[] strs = javaPidLine.split(\"JAVA_PID\");\n                    if (strs.length > 1) {\n                         return Long.parseLong(strs[strs.length - 1].trim());\n                    }\n               } catch (NumberFormatException e) {\n                    // ignore\n                    }\n          }\n     } catch (Throwable ex) {\n               AnsiLog.error(\"Detection telnet port error\");\n               AnsiLog.error(ex);\n          }\n          \n     return -1;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "59", "src_id": "M475", "code": "@Override\npublic void draw(CommandProcess process, JvmModel result) {\n     TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n     for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n          String group = entry.getKey();\n          List<JvmItemVO> items = entry.getValue();\n          table.row(true, label(group).style(Decoration.bold.bold()));\n          \n          for (JvmItemVO item : items) {\n               String valueStr;\n               \n               if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                    valueStr = renderMemoryUsage((Map<String, Object>) item.getValue());\n               } else {\n                    valueStr = renderItemValue(item.getValue());\n               }\n               \n               if (item.getDesc() != null) {\n                    table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n               } else {\n                    table.row(item.getName(), valueStr);\n               }\n          }\n          \n          table.row(\"\", \"\");\n     }\n\n     process.write(RenderUtil.render(table, process.width()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "60", "src_id": "M1131", "code": "private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n     String commandLine = apiRequest.getCommand();\n     Map<String, Object> body = new TreeMap<String, Object>();\n     \n     body.put(\"command\", commandLine);\n     ApiResponse response = new ApiResponse();\n     response.setSessionId(session.getSessionId()).setBody(body);\n     if (!session.tryLock()) {\n          response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n          return response;\n     }\n     \n     int lock = session.getLock();\n     try {\n          Job foregroundJob = session.getForegroundJob();\n          \n          if (foregroundJob != null) {\n               response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n               logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n               return response;\n          }\n\n          //create job\n          Job job = this.createJob(commandLine, session, session.getResultDistributor());\n          body.put(\"jobId\", job.id());\n          body.put(\"jobStatus\", job.status());\n          response.setState(ApiState.SCHEDULED);\n          //add command before exec job\n          CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n          commandRequestModel.setJobId(job.id());\n          SharingResultDistributor resultDistributor = session.getResultDistributor();\n          if (resultDistributor != null) {\n               resultDistributor.appendResult(commandRequestModel);\n          }\n          session.setForegroundJob(job);\n          updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n          //run job\n          job.run();\n          return response;\n     } catch (Throwable e) {\n               logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n               response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n               CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n               session.getResultDistributor().appendResult(commandRequestModel);\n               return response;\n          } finally {\n               if (session.getLock() == lock) {\n                    session.unLock();\n               }\n          }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "61", "src_id": "M493", "code": "private void renderNode(StringBuilder sb, TraceNode node, Ansi highlighted) {\n     //render cost: [0.366865ms]\n     if (isPrintCost && node instanceof MethodNode) {\n          MethodNode methodNode = (MethodNode) node;\n          String costStr = renderCost(methodNode);\n          if (node == maxCostNode) {\n               // the node with max cost will be highlighted\n               sb.append(highlighted.a(costStr).reset().toString());\n          } else {\n               sb.append(costStr);\n          }\n     }\n\n     //render method name\n     if (node instanceof MethodNode) {\n          MethodNode methodNode = (MethodNode) node;\n          //clazz.getName() + \":\" + method.getName() + \"()\"\n          sb.append(methodNode.getClassName()).append(\":\").append(methodNode.getMethodName()).append(\"()\");\n          // #lineNumber\n          if (methodNode.getLineNumber() != -1) {\n               sb.append(\" #\").append(methodNode.getLineNumber());\n          }\n     } else if (node instanceof ThreadNode) {\n          //render thread info\n          ThreadNode threadNode = (ThreadNode) node;\n          //ts=2020-04-29 10:34:00;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@18b4aac2\n          sb.append(format(\"ts=%s;thread_name=%s;id=%d;is_daemon=%s;priority=%d;TCCL=%s\",\n                  DateUtils.formatDateTime(threadNode.getTimestamp()),\n                  threadNode.getThreadName(), threadNode.getThreadId(),\n                  threadNode.isDaemon(), threadNode.getPriority(),\n                  threadNode.getClassloader()));\n          //trace_id\n          if (threadNode.getTraceId() != null) {\n               sb.append(\";trace_id=\").append(threadNode.getTraceId());\n          }\n          if (threadNode.getRpcId() != null) {\n               sb.append(\";rpc_id=\").append(threadNode.getRpcId());\n          }\n     } else if (node instanceof ThrowNode) {\n          ThrowNode throwNode = (ThrowNode) node;\n          sb.append(\"throw:\").append(throwNode.getException())\n                  .append(\" #\")\n                  .append(throwNode.getLineNumber())\n                  .append(\" [\")\n                  .append(throwNode.getMessage())\n                  .append(\"]\");\n     } else {\n          throw new UnsupportedOperationException(\"unknown trace node: \" + node.getClass());\n     }\n     \n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "62", "src_id": "M542", "code": "private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n     StringBuilder sb = new StringBuilder(8192);\n     for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n          Map<String, Object> info = entry.getValue();\n          TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n          TableElement appendersTable = new TableElement().rightCellPadding(1);\n          Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n          table.row(label(LoggerHelper.name).style(Decoration\n                  .bold\n                  .bold()), \n                  label(\"\" + info.get(LoggerHelper.name)))\n                  .row(label(LoggerHelper.clazz).style(Decoration\n                  .bold\n                  .bold()), \n                  label(\"\" + clazz.getName()))\n                  .row(label(LoggerHelper.classLoader).style(Decoration\n                  .bold\n                  .bold()),\n                  label(\"\" + info.get(LoggerHelper.classLoader)))\n                  .row(label(LoggerHelper.classLoaderHash)\n                  .style(Decoration.bold.bold()),\n                  label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                  .row(label(LoggerHelper.level).style(Decoration\n                  .bold\n                  .bold()),\n                  label(\"\" + info.get(LoggerHelper.level)));\n          if (info.get(LoggerHelper.effectiveLevel) != null) {\n               table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n          }\n\n          if (info.get(LoggerHelper.config) != null) {\n               table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n          }\n          table.row(label(LoggerHelper.additivity)\n                  .style(Decoration.bold.bold()),\n                  label(\"\" + info.get(LoggerHelper.additivity)))\n                  .row(label(LoggerHelper.codeSource).style(Decoration\n                  .bold\n                  .bold()),\n                  label(\"\" + info.get(LoggerHelper.codeSource)));\n          @SuppressWarnings(\"unchecked\")List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n          \n          if (appenders != null && !appenders.isEmpty()) {\n               for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                         appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    \n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                         appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    \n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                         appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    \n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                         appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n               }\n\n               table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n          }\n          sb.append(RenderUtil.render(table, width)).append('\\n');\n     }\n     \n     return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "63", "src_id": "M529", "code": "@Override\npublic void draw(CommandProcess process, MonitorModel result) {\n     TableElement table = new TableElement(2, 3, 3, 1, 1, 1, 1, 1).leftCellPadding(1).rightCellPadding(1);\n     table.row(true, label(\"timestamp\").style(Decoration\n             .bold\n             .bold()),\n             label(\"class\").style(Decoration.bold.bold()),\n             label(\"method\").style(Decoration.bold.bold()),\n             label(\"total\").style(Decoration.bold.bold()),\n             label(\"success\").style(Decoration.bold.bold()),\n             label(\"fail\").style(Decoration.bold.bold()),\n             label(\"avg-rt(ms)\").style(Decoration.bold\n             .bold()),\n             label(\"fail-rate\").style(Decoration.bold\n             .bold()));\n     final DecimalFormat df = new DecimalFormat(\"0.00\");\n     for (MonitorData data : result.getMonitorDataList()) {\n          table.row(DateUtils.formatDateTime(data\n                  .getTimestamp()),\n                  data.getClassName(), data.getMethodName(),\n                  \"\" + data.getTotal(), \"\" + data.getSuccess(),\n                  \"\" + data.getFailed(), df.format(div(data\n                  .getCost(), \n                  data.getTotal())),\n                  df.format(100.0d * div(data.getFailed(), \n                  data.getTotal())) \n                   + \"%\");\n     }\n\n     process.write(RenderUtil.render(table, process.width()) + \"\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "64", "src_id": "M381", "code": "@Override\npublic List<ResultModel> pollResults() {\n     try {\n          lastAccessTime = System.currentTimeMillis();\n          long accessTime = lastAccessTime;\n          \n          if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n               polling = true;\n               sendingItemCount = 0;\n               long firstResultTime = 0;\n               // sending delay: time elapsed after firstResultTime\n               long sendingDelay = 0;\n               // waiting time: time elapsed after access\n               long waitingTime = 0;\n               List<ResultModel> sendingResults = new ArrayList<ResultModel>(resultBatchSizeLimit);\n               while (!closed && sendingResults.size() < resultBatchSizeLimit && sendingDelay < 100 && waitingTime < pollTimeLimit) {\n                    ResultModel aResult = resultQueue.poll(100, TimeUnit.MILLISECONDS);\n                    \n                    if (aResult != null) {\n                         sendingResults.add(aResult);\n                         \n                         //æ¯å¦ä¸ºç¬¬ä¸æ¬¡è·åå°æ°æ®\n                         if (firstResultTime == 0) {\n                              firstResultTime = System.currentTimeMillis();\n                         }\n                         //å¤æ­æ¯å¦éè¦ç«å³åéåºå»\n                         if (shouldFlush(sendingResults, aResult)) {\n                              break;\n                         }\n                    } else {\n                         if (firstResultTime > 0) {\n                              //è·åå°é¨åæ°æ®åï¼éåå·²ç»åå®ï¼è®¡ç®åéå»¶æ¶æ¶é´\n                              sendingDelay = System.currentTimeMillis() - firstResultTime;\n                         }\n                         //è®¡ç®æ»å±ç­å¾æ¶é´ï¼é¿è½®è¯¢æå¤§ç­å¾æ¶é´\n                         waitingTime = System.currentTimeMillis() - accessTime;\n                    }\n               }\n               //resultQueue.drainTo(sendingResults, resultSizeLimit-sendingResults.size());\n               if (logger.isDebugEnabled()) {\n                    logger.debug(\"pollResults: {}, results: {}\", sendingResults.size(), JSON.toJSONString(sendingResults));\n               }\n               return sendingResults;\n          }\n     } catch (InterruptedException e) {\n          //e.printStackTrace();\n          } finally {\n               if (lock.isHeldByCurrentThread()) {\n                    lastAccessTime = System.currentTimeMillis();\n                    polling = false;\n                    lock.unlock();\n               }\n          }\n     return Collections.emptyList();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "376", "src_id": "M302", "code": "        @Override\n        public void processResult(int rc, String path, Object ctx, List<String> children) {\n            if (rc != KeeperException.Code.OK.intValue()) {\n                // try it again\n                zk.getChildren(assignmentsNode, true, this, null);\n                return;\n            }\n\n            Map<String, Instance> newList = new HashMap<String, Instance>();\n            // check for differences\n            Stat stat = new Stat();\n\n            for (String child: children) {\n                Instance i = instances.remove(child);\n\n                if (i == null) {\n                    // Start up a new instance\n                    byte[] data = null;\n                    String myNode = assignmentsNode + '/' + child;\n                    for (; \n                        ;) {\n                        try {\n                            data = zk.getData(myNode, true, stat);\n                            break;\n                        } catch (NoNodeException e) {\n                                // The node doesn't exist anymore, so skip it\n                                break;\n                            } catch (KeeperException e) {\n                                e.printStackTrace();\n                            } catch (InterruptedException e) {\n                                return;\n                            }\n\n\n                    }\n\n                    if (data != null) {\n                        String instanceSpec = new String(data);\n                        int spaceIndex = instanceSpec.indexOf(' ');\n                        String clazz;\n                        String conf;\n\n                        if (spaceIndex == -1) {\n                            clazz = instanceSpec;\n                            conf = null;\n                        } else {\n                            clazz = instanceSpec.substring(0, spaceIndex);\n                            conf = instanceSpec.substring(spaceIndex + 1);\n                        }\n\n                        try {\n                            Class<?> c = Class.forName(clazz);\n\n                            i = (Instance) c.getConstructor().newInstance();\n\n                            Reporter reporter = new MyReporter(child);\n                            i.setReporter(reporter);\n                            i.configure(conf);\n                            i.start();\n                            newList.put(child, i);\n\n                            int ver = stat.getVersion();\n                            Instance myInstance = i;\n                            DataCallback dc = new MyDataCallback(myNode, myInstance, ver);\n                            Watcher watcher = new MyWatcher(myNode, dc);\n\n                            zk.getData(myNode, watcher, dc, watcher);\n                        } catch (Exception e) {\n                                LOG.warn(\"Skipping \" + child, e);\n\n                                if (e.getCause() != null) {\n                                    LOG.warn(\"Caused by\", e.getCause());\n                                }\n                            }\n\n\n                    }\n                } else {\n                    // just move it to the new list\n                    newList.put(child, i);\n                }\n            }\n\n            // kill anything that was removed for the children\n            for (Map.Entry<String, Instance> i: instances.entrySet()) {\n                i.getValue().stop();\n\n                try {\n                    rmnod(reportsNode + '/' + i.getKey());\n                } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    } catch (KeeperException e) {\n                        e.printStackTrace();\n                    }\n\n            }\n            instances = newList;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "377", "src_id": "M219", "code": "        synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime)throws IOException {\n            final String connectionId = concat(contextPath, session);\n            ZooKeeper zk = zkMap.get(connectionId);\n\n            if (zk == null) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n                }\n\n                Endpoint e = contextMap.get(contextPath);\n\n                zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n                for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                    zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n                }\n                zkMap.put(connectionId, zk);\n\n                // a session should automatically expire after an amount of time\n                if (session != null) {\n                    zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n                }\n            }\n\n            return zk;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "378", "src_id": "M579", "code": "        public void dump(PrintWriter pwriter) {\n            pwriter.print(\"Sets (\");\n            pwriter.print(expiryMap.size());\n            pwriter.print(\")/(\");\n            pwriter.print(elemMap.size());\n            pwriter.println(\"):\");\n\n            ArrayList<Long> keys = new ArrayList<>(expiryMap.keySet());\n\n            Collections.sort(keys);\n\n            for (long time : keys) {\n                Set<E> set = expiryMap.get(time);\n\n                if (set != null) {\n                    pwriter.print(set.size());\n                    pwriter.print(\" expire at \");\n                    pwriter.print(Time.elapsedTimeToDate(time));\n                    pwriter.println(\":\");\n                    for (E elem : set) {\n                        pwriter.print(\"\\t\");\n                        pwriter.println(elem.toString());\n                    }\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "379", "src_id": "M282", "code": "        @Test\n        public void testSimpleCase()throws Exception {\n            configureServers(serverCount);\n            configureClients(clientCount, SimpleClient.class, getHostPort());\n\n            Stat stat = new Stat();\n            startServers();\n            LOG.debug(\"Connecting to \" + getHostPort());\n\n            ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n\n            waitForConnect(zk, 10000);\n            zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            startClients();\n\n            // Check that all clients connect properly\n            for (int i = 0; i < getClientCount(); i++) {\n                for (int j = 0; j < maxTries; j++) {\n                    try {\n                        byte b[] = zk.getData(\"/simpleCase/\" + i, false, stat);\n\n                        Assert.assertEquals(\"orig\", new String(b));\n                    } catch (NoNodeException e) {\n                            if (j + 1 == maxTries) {\n                                Assert.fail(\"Max tries exceeded on client \" + i);\n                            }\n\n                            Thread.sleep(1000);\n                        }\n\n\n                }\n            }\n\n            // Kill half the servers, make a change, restart the dead\n            // servers, and then bounce the other servers one by one\n            for (int i = 0; i < getServerCount(); i++) {\n                stopServer(i);\n\n                if (i + 1 > getServerCount() / 2) {\n                    startServer(i);\n                } else if (i + 1 == getServerCount() / 2) {\n                    Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n\n                    try {\n                        zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                    } catch (ConnectionLossException e) {\n                            Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                            zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                        }\n\n                    for (int j = 0; j < i; j++) {\n                        LOG.info(\"Starting server \" + j);\n                        startServer(i);\n                    }\n                }\n\n            }\n\n            Thread.sleep(100); // wait for things to stabilize\n\n            Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n\n            try {\n                zk.getData(\"/simpleCase\", false, stat);\n            } catch (ConnectionLossException e) {\n                    Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n                }\n\n\n            // check that the change has propagated to everyone\n            for (int i = 0; i < getClientCount(); i++) {\n                for (int j = 0; j < maxTries; j++) {\n                    byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n                    if (new String(data).equals(\"new\")) {\n                        break;\n                    }\n                    if (j + 1 == maxTries) {\n                        Assert.fail(\"max tries exceeded for \" + i);\n                    }\n\n                    Thread.sleep(1000);\n                }\n            }\n            // send out the kill signal\n            zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n\n            // watch for everyone to die\n            for (int i = 0; i < getClientCount(); i++) {\n                try {\n                    for (int j = 0; j < maxTries; j++) {\n                        zk.getData(\"/simpleCase/\" + i, false, stat);\n\n                        if (j + 1 == maxTries) {\n                            Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                        }\n\n                        Thread.sleep(200);\n                    }\n                } catch (NoNodeException e) {\n                    // Great this is what we were hoping for!\n                    }\n\n\n            }\n            stopClients();\n            stopServers();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "380", "src_id": "M243", "code": "        public void start()throws IOException {\n            System.out.println(\"Starting grizzly ...\");\n\n            boolean useSSL = cfg.useSSL();\n            String zkRestResourcesTempPath = Files.createTempDirectory(\"zkRestResourcesTempPath\").toFile().getCanonicalPath();\n\n            gws = new GrizzlyWebServer(cfg.getPort(), zkRestResourcesTempPath, useSSL);\n            // BUG: Grizzly needs a doc root if you are going to register multiple adapters\n\n            for (Endpoint e : cfg.getEndpoints()) {\n                ZooKeeperService.mapContext(e.getContext(), e);\n                gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });\n            }\n\n            if (useSSL) {\n                System.out.println(\"Starting SSL ...\");\n\n                String jks = cfg.getJKS(\"keys/rest.jks\");\n                String jksPassword = cfg.getJKSPassword();\n                SSLConfig sslConfig = new SSLConfig();\n                URL resource = getClass().getClassLoader().getResource(jks);\n\n                if (resource == null) {\n                    LOG.error(\"Unable to find the keystore file: \" + jks);\n                    System.exit(2);\n                }\n\n                try {\n                    sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());\n                } catch (URISyntaxException e1) {\n                        LOG.error(\"Unable to load keystore: \" + jks, e1);\n                        System.exit(2);\n                    }\n\n\n                sslConfig.setKeyStorePass(jksPassword);\n                gws.setSSLConfig(sslConfig);\n            }\n\n            gws.start();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "381", "src_id": "M186", "code": "        synchronized private LogEntry readNextEntry() {\n            try {\n                try {\n                    for (; \n                        ;) {\n                        String line = in.readLine();\n                        if (line == null) {\n                            break;\n                        }\n\n                        Matcher m = src.timep.matcher(line);\n\n                        if (m.lookingAt()) {\n                            if (buf.length() > 0) {\n                                LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n\n                                buf = line;\n                                return e;\n                            }\n\n                            buf = line;\n                        } else if (buf.length() > 0) {\n                            buf += line + \"\\n\";\n                        }\n\n                    }\n                } catch (EOFException eof) {\n                    // ignore, we've simply come to the end of the file\n                    }\n\n\n                if (buf.length() > 0) {\n                    LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);\n\n                    buf = \"\";\n                    return e;\n                }\n            } catch (Exception e) {\n                    LOG.error(\"Error reading next entry in file (\" + src.file + \"): \" + e);\n                    return null;\n                }\n\n            return null;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "382", "src_id": "M286", "code": "        public void reconfigureInstance(String name, String params)throws NoAssignmentException, InterruptedException, KeeperException {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n            }\n\n            Assigned assigned = instanceToAssignment.get(name);\n            if (assigned == null) {\n                throw new NoAssignmentException();\n            }\n\n            KeeperException lastException = null;\n            for (int i = 0; i < maxTries; i++) {\n                try {\n                    zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, (\"update \" + params).getBytes(), -1);\n                    break;\n                } catch (ConnectionLossException e) {\n                        lastException = e;\n                    }\n\n\n            }\n\n            if (lastException != null) {\n                throw lastException;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "383", "src_id": "M174", "code": "        private LogEntry readNextEntry() {\n            LogEntry e = null;\n\n            try {\n                long crcValue;\n                byte[] bytes;\n\n                try {\n                    crcValue = logStream.readLong(\"crcvalue\");\n                    bytes = logStream.readBuffer(\"txnEntry\");\n                } catch (EOFException ex) {\n                        return null;\n                    }\n\n\n                if (bytes.length == 0) {\n                    return null;\n                }\n\n                Checksum crc = new Adler32();\n                crc.update(bytes, 0, bytes.length);\n\n                if (crcValue != crc.getValue()) {\n                    throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n                }\n\n                TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n                TxnHeader hdr = logEntry.getHeader();\n                Record r = logEntry.getTxn();\n\n                switch (hdr.getType()) {\n                    case OpCode.createSession: {\n                            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n                        }\n                        break;\n                    case OpCode.closeSession: {\n                            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n                        }\n                        break;\n                    case OpCode.create:\n                        if (r != null) {\n                            CreateTxn create = (CreateTxn)r;\n                            String path = create.getPath();\n\n                            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n                        }\n                        break;\n                    case OpCode.setData:\n                        if (r != null) {\n                            SetDataTxn set = (SetDataTxn)r;\n                            String path = set.getPath();\n\n                            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n                        }\n                        break;\n                    case OpCode.setACL:\n                        if (r != null) {\n                            SetACLTxn setacl = (SetACLTxn)r;\n                            String path = setacl.getPath();\n\n                            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n                        }\n                        break;\n                    case OpCode.error:\n                        if (r != null)  {\n                            ErrorTxn error = (ErrorTxn)r;\n\n                            e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"error\", \"Error: \" + error.getErr());\n                        }\n                        break;\n                    default:\n                        LOG.info(\"Unknown op: \" + hdr.getType());\n                        break;\n                }\n\n                if (logStream.readByte(\"EOR\") != 'B') {\n                    throw new EOFException(\"Last transaction was partial.\");\n                }\n            } catch (Exception ex) {\n                    LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n                    return null;\n                }\n\n            return e;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "384", "src_id": "M1129", "code": "        public synchronized void dumpConnectionInfo(PrintWriter pwriter, boolean brief) {\n            pwriter.print(\" \");\n            pwriter.print(getRemoteSocketAddress());\n            pwriter.print(\"[\");\n\n            int interestOps = getInterestOps();\n\n            pwriter.print(interestOps == 0 ? \"0\" : Integer.toHexString(interestOps));\n            pwriter.print(\"](queued=\");\n            pwriter.print(getOutstandingRequests());\n            pwriter.print(\",recved=\");\n            pwriter.print(getPacketsReceived());\n            pwriter.print(\",sent=\");\n            pwriter.print(getPacketsSent());\n\n            if (!brief) {\n                long sessionId = getSessionId();\n\n                if (sessionId != 0) {\n                    pwriter.print(\",sid=0x\");\n                    pwriter.print(Long.toHexString(sessionId));\n                    pwriter.print(\",lop=\");\n                    pwriter.print(getLastOperation());\n                    pwriter.print(\",est=\");\n                    pwriter.print(getEstablished().getTime());\n                    pwriter.print(\",to=\");\n                    pwriter.print(getSessionTimeout());\n\n                    long lastCxid = getLastCxid();\n\n                    if (lastCxid >= 0) {\n                        pwriter.print(\",lcxid=0x\");\n                        pwriter.print(Long.toHexString(lastCxid));\n                    }\n\n                    pwriter.print(\",lzxid=0x\");\n                    pwriter.print(Long.toHexString(getLastZxid()));\n                    pwriter.print(\",lresp=\");\n                    pwriter.print(getLastResponseTime());\n                    pwriter.print(\",llat=\");\n                    pwriter.print(getLastLatency());\n                    pwriter.print(\",minlat=\");\n                    pwriter.print(getMinLatency());\n                    pwriter.print(\",avglat=\");\n                    pwriter.print(getAvgLatency());\n                    pwriter.print(\",maxlat=\");\n                    pwriter.print(getMaxLatency());\n                }\n            }\n\n            pwriter.print(\")\");\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "160", "src_id": "M1620", "code": "void fastPath(Subscriber<? super R> a, Iterator<? extends R> iterator) {\n     while (true) {\n          if (cancelled) {\n               return;\n          }\n\n          R v;\n          try {\n               v = iterator.next();\n          } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n               }\n               \n          a.onNext(v);\n\n          if (cancelled) {\n               return;\n          }\n\n          boolean b;\n          try {\n               b = iterator.hasNext();\n          } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n               }\n\n               \n          if (!b) {\n               a.onComplete();\n               return;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "161", "src_id": "M1380", "code": "@Override\npublic void onComplete() {\n     if (done) {\n          return;\n     }\n     \n     try {\n          onComplete.run();\n     } catch (Throwable e) {\n               fail(e);\n               return;\n          }\n          \n     done = true;\n     downstream.onComplete();\n     try {\n          onAfterTerminate.run();\n     } catch (Throwable e) {\n               Exceptions.throwIfFatal(e);\n               RxJavaPlugins.onError(e);\n          }\n          \n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "162", "src_id": "M1939", "code": "@Override\npublic void run(long n) {\n     long emitted = 0L;\n     Iterator<T> iterator = this.iterator;\n     ConditionalSubscriber<? super T> downstream = this.downstream;\n     while (true) {\n          if (cancelled) {\n               clear();\n               break;\n          } else {\n               T next;\n               try {\n                    next = Objects.requireNonNull(iterator.next(), \"The Stream's Iterator returned a null value\");\n               } catch (Throwable ex) {\n                         Exceptions.throwIfFatal(ex);\n                         downstream.onError(ex);\n                         cancelled = true;\n                         continue;\n                    }\n\n                    \n               if (downstream.tryOnNext(next)) {\n                    emitted++;\n               }\n               if (cancelled) {\n                    continue;\n               }\n\n               try {\n                    if (!iterator.hasNext()) {\n                         downstream.onComplete();\n                         cancelled = true;\n                         continue;\n                    }\n               } catch (Throwable ex) {\n                         Exceptions.throwIfFatal(ex);\n                         downstream.onError(ex);\n                         cancelled = true;\n                         continue;\n                    }\n\n                    \n               if (emitted != n) {\n                    continue;\n               }\n          }\n          n = get();\n          \n          if (emitted == n) {\n               if (compareAndSet(n, 0L)) {\n                    break;\n               }\n               n = get();\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "163", "src_id": "M1099", "code": "void replay(CacheSubscription<T> consumer) {\n     // make sure there is only one replay going on at a time\n     if (consumer.getAndIncrement() != 0) {\n          return;\n     }\n\n     // see if there were more replay request in the meantime\n     int missed = 1;\n     // read out state into locals upfront to avoid being re-read due to volatile reads\n     long index = consumer.index;\n     int offset = consumer.offset;\n     Node<T> node = consumer.node;\n     AtomicLong requested = consumer.requested;\n     Subscriber<? super T> downstream = consumer.downstream;\n     int capacity = capacityHint;\n     while (true) {\n          // first see if the source has terminated, read order matters!\n          boolean sourceDone = done;\n          // and if the number of items is the same as this consumer has received\n          boolean empty = size == index;\n          // if the source is done and we have all items so far, terminate the consumer\n          if (sourceDone && empty) {\n               // release the node object to avoid leaks through retained consumers\n               consumer.node = null;\n               // if error is not null then the source failed\n               Throwable ex = error;\n               if (ex != null) {\n                    downstream.onError(ex);\n               } else {\n                    downstream.onComplete();\n               }\n               return;\n          }\n\n          // there are still items not sent to the consumer\n          if (!empty) {\n               // see how many items the consumer has requested in total so far\n               long consumerRequested = requested.get();\n               // MIN_VALUE indicates a cancelled consumer, we stop replaying\n               if (consumerRequested == Long.MIN_VALUE) {\n                    // release the node object to avoid leaks through retained consumers\n                    consumer.node = null;\n                    return;\n               }\n               \n               // if the consumer has requested more and there is more, we will emit an item\n               if (consumerRequested != index) {\n                    // if the offset in the current node has reached the node capacity\n                    if (offset == capacity) {\n                         // switch to the subsequent node\n                         node = node.next;\n                         // reset the in-node offset\n                         offset = 0;\n                    }\n                    // emit the cached item\n                    downstream.onNext(node.values[offset]);\n                    // move the node offset forward\n                    offset++;\n                    // move the total consumed item count forward\n                    index++;\n                    // retry for the next item/terminal event if any\n                    continue;\n               }\n          }\n          // commit the changed references back\n          consumer.index = index;\n          consumer.offset = offset;\n          consumer.node = node;\n          // release the changes and see if there were more replay request in the meantime\n          missed = consumer.addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "164", "src_id": "M284", "code": "@SuppressWarnings(\"unchecked\") void drain() {\n     if (getAndIncrement() != 0) {\n          return;\n     }\n\n     Observer<? super R> downstream = this.downstream;\n     SimpleQueue<T> queue = this.queue;\n     AtomicThrowable errors = this.errors;\n     while (true) {\n          if (!active) {\n               if (cancelled) {\n                    queue.clear();\n                    return;\n               }\n               if (!tillTheEnd) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                         queue.clear();\n                         cancelled = true;\n                         errors.tryTerminateConsumer(downstream);\n                         return;\n                    }\n               }\n\n               boolean d = done;\n               T v;\n               try {\n                    v = queue.poll();\n               } catch (Throwable ex) {\n                         Exceptions.throwIfFatal(ex);\n                         cancelled = true;\n                         this.upstream.dispose();\n                         errors.tryAddThrowableOrReport(ex);\n                         errors.tryTerminateConsumer(downstream);\n                         return;\n                    }\n\n                    \n               boolean empty = v == null;\n               if (d && empty) {\n                    cancelled = true;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n               }\n\n               if (!empty) {\n                    ObservableSource<? extends R> o;\n                    try {\n                         o = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null ObservableSource\");\n                    } catch (Throwable ex) {\n                              Exceptions.throwIfFatal(ex);\n                              cancelled = true;\n                              this.upstream.dispose();\n                              queue.clear();\n                              errors.tryAddThrowableOrReport(ex);\n                              errors.tryTerminateConsumer(downstream);\n                              return;\n                         }\n                         \n                    if (o instanceof Supplier) {\n                         R w;\n                         try {\n                              w = ((Supplier<R>)o).get();\n                         } catch (Throwable ex) {\n                                   Exceptions.throwIfFatal(ex);\n                                   errors.tryAddThrowableOrReport(ex);\n                                   continue;\n                              }\n\n                              \n                         if (w != null && !cancelled) {\n                              downstream.onNext(w);\n                         }\n                         continue;\n                    } else {\n                         active = true;\n                         o.subscribe(observer);\n                    }\n               }\n          }\n\n          if (decrementAndGet() == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "165", "src_id": "M1908", "code": "void drain() {\n     if (getAndIncrement() != 0) {\n          return;\n     }\n\n     int missed = 1;\n     final Subscriber<? super R> downstream = this.downstream;\n     final SimpleQueue<T> queue = this.queue;\n     final AtomicThrowable error = this.error;\n     Iterator<? extends R> iterator = this.currentIterator;\n     long requested = this.requested.get();\n     long emitted = this.emitted;\n     final int limit = prefetch - (prefetch >> 2);\n     boolean canRequest = sourceMode != QueueFuseable.SYNC;\n     while (true) {\n          if (cancelled) {\n               queue.clear();\n               clearCurrentSuppressCloseError();\n          } else {\n               boolean isDone = upstreamDone;\n               if (error.get() != null) {\n                    downstream.onError(error.get());\n                    cancelled = true;\n                    continue;\n               }\n\n               if (iterator == null) {\n                    T t;\n                    try {\n                         t = queue.poll();\n                    } catch (Throwable ex) {\n                              Exceptions.throwIfFatal(ex);\n                              trySignalError(downstream, ex);\n                              continue;\n                         }\n\n                         \n                    boolean isEmpty = t == null;\n\n                    if (isDone && isEmpty) {\n                         downstream.onComplete();\n                         cancelled = true;\n                    } else if (!isEmpty) {\n                         if (canRequest && ++consumed == limit) {\n                              consumed = 0;\n                              upstream.request(limit);\n                         }\n\n                         Stream<? extends R> stream;\n                         try {\n                              stream = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null Stream\");\n                              iterator = stream.iterator();\n\n                              if (iterator.hasNext()) {\n                                   currentIterator = iterator;\n                                   currentCloseable = stream;\n                              } else {\n                                   iterator = null;\n                              }\n                         } catch (Throwable ex) {\n                                   Exceptions.throwIfFatal(ex);\n                                   trySignalError(downstream, ex);\n                              }\n                              \n                         continue;\n                    }\n                    \n               }\n               \n               if (iterator != null && emitted != requested) {\n                    R item;\n                    try {\n                         item = Objects.requireNonNull(iterator.next(), \"The Stream.Iterator returned a null value\");\n                    } catch (Throwable ex) {\n                              Exceptions.throwIfFatal(ex);\n                              trySignalError(downstream, ex);\n                              continue;\n                         }\n                         \n                    if (!cancelled) {\n                         downstream.onNext(item);\n                         emitted++;\n                         if (!cancelled) {\n                              try {\n                                   if (!iterator.hasNext()) {\n                                        iterator = null;\n                                        clearCurrentRethrowCloseError();\n                                   }\n                              } catch (Throwable ex) {\n                                        Exceptions.throwIfFatal(ex);\n                                        trySignalError(downstream, ex);\n                                   }\n                                   \n                         }\n                    }\n                    continue;\n               }\n          }\n          this.emitted = emitted;\n          missed = addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n          requested = this.requested.get();\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1237", "code": "void drain() {\n     if (getAndIncrement() != 0) {\n          return;\n     }\n\n     final Subscriber<? super R> a = downstream;\n     final ZipSubscriber<T, R>[] qs = subscribers;\n     final int n = qs.length;\n     Object[] values = current;\n     int missed = 1;\n     while (true) {\n          long r = requested.get();\n          long e = 0L;\n          while (r != e) {\n               if (cancelled) {\n                    return;\n               }\n               if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n               }\n\n               boolean empty = false;\n               for (int j = 0; j < n; j++) {\n                    ZipSubscriber<T, R> inner = qs[j];\n                    \n                    if (values[j] == null) {\n                         boolean d = inner.done;\n                         SimpleQueue<T> q = inner.queue;\n                         T v = null;\n                         try {\n                              v = q != null ? q.poll() : null;\n                         } catch (Throwable ex) {\n                                   Exceptions.throwIfFatal(ex);\n                                   errors.tryAddThrowableOrReport(ex);\n                                   \n                                   if (!delayErrors) {\n                                        cancelAll();\n                                        errors.tryTerminateConsumer(a);\n                                        return;\n                                   }\n                                   d = true;\n                              }\n\n                              \n                         boolean sourceEmpty = v == null;\n                         if (d && sourceEmpty) {\n                              cancelAll();\n                              errors.tryTerminateConsumer(a);\n                              return;\n                         }\n                         if (!sourceEmpty) {\n                              values[j] = v;\n                         } else {\n                              empty = true;\n                         }\n                    }\n               }\n               if (empty) {\n                    break;\n               }\n\n               R v;\n               try {\n                    v = Objects.requireNonNull(zipper.apply(values.clone()), \"The zipper returned a null value\");\n               } catch (Throwable ex) {\n                         Exceptions.throwIfFatal(ex);\n                         cancelAll();\n                         errors.tryAddThrowableOrReport(ex);\n                         errors.tryTerminateConsumer(a);\n                         return;\n                    }\n                    \n               a.onNext(v);\n               e++;\n               Arrays.fill(values, null);\n          }\n          if (r == e) {\n               if (cancelled) {\n                    return;\n               }\n               if (!delayErrors && errors.get() != null) {\n                    cancelAll();\n                    errors.tryTerminateConsumer(a);\n                    return;\n               }\n\n               for (int j = 0; j < n; j++) {\n                    ZipSubscriber<T, R> inner = qs[j];\n                    \n                    if (values[j] == null) {\n                         boolean d = inner.done;\n                         SimpleQueue<T> q = inner.queue;\n                         T v = null;\n                         try {\n                              v = q != null ? q.poll() : null;\n                         } catch (Throwable ex) {\n                                   Exceptions.throwIfFatal(ex);\n                                   errors.tryAddThrowableOrReport(ex);\n                                   \n                                   if (!delayErrors) {\n                                        cancelAll();\n                                        errors.tryTerminateConsumer(a);\n                                        return;\n                                   }\n                                   d = true;\n                              }\n                              \n                              \n                         boolean empty = v == null;\n                         if (d && empty) {\n                              cancelAll();\n                              errors.tryTerminateConsumer(a);\n                              return;\n                         }\n                         if (!empty) {\n                              values[j] = v;\n                         }\n                    }\n               }\n          }\n\n          if (e != 0L) {\n               for (ZipSubscriber<T, R> inner : qs) {\n                    inner.request(e);\n               }\n               if (r != Long.MAX_VALUE) {\n                    requested.addAndGet(-e);\n               }\n          }\n          missed = addAndGet(-missed);\n          \n          if (missed == 0) {\n               break;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "167", "src_id": "M409", "code": "@Override Node getHead() {\n     long timeLimit = scheduler.now(unit) - maxAge;\n     Node prev = get();\n     Node next = prev.get();\n     while (true) {\n          if (next == null) {\n               break;\n          }\n          \n          Timed<?> v = (Timed<?>)next.value;\n          if (NotificationLite.isComplete(v.value()) || NotificationLite.isError(v.value())) {\n               break;\n          }\n          if (v.time() <= timeLimit) {\n               prev = next;\n               next = next.get();\n          } else {\n               break;\n          }\n     }\n     return prev;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "168", "src_id": "M2271", "code": "@SuppressWarnings(\"unchecked\") void remove(AsyncSubscription<T> ps) {\n     while (true) {\n          AsyncSubscription<T>[] a = subscribers.get();\n          int n = a.length;\n          if (n == 0) {\n               return;\n          }\n\n          int j = -1;\n          for (int i = 0; i < n; i++) {\n               if (a[i] == ps) {\n                    j = i;\n                    break;\n               }\n          }\n          if (j < 0) {\n               return;\n          }\n\n          AsyncSubscription<T>[] b;\n          if (n == 1) {\n               b = EMPTY;\n          } else {\n               b = new AsyncSubscription[n - 1];\n               System.arraycopy(a, 0, b, 0, j);\n               System.arraycopy(a, j + 1, b, j, n - j - 1);\n          }\n          if (subscribers.compareAndSet(a, b)) {\n               return;\n          }\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "169", "src_id": "M335", "code": "@Override\npublic void onSubscribe(Disposable d) {\n     if (DisposableHelper.validate(this.upstream, d)) {\n          this.upstream = d;\n          if (d instanceof QueueDisposable) {\n               @SuppressWarnings(\"unchecked\")QueueDisposable<T> qd = (QueueDisposable<T>) d;\n               int m = qd.requestFusion(QueueDisposable.ANY);\n               if (m == QueueDisposable.SYNC) {\n                    fusionMode = m;\n                    queue = qd;\n                    done = true;\n                    downstream.onSubscribe(this);\n                    drain();\n                    return;\n               }\n\n               if (m == QueueDisposable.ASYNC) {\n                    fusionMode = m;\n                    queue = qd;\n                    downstream.onSubscribe(this);\n                    return;\n               }\n          }\n          queue = new SpscLinkedArrayQueue<>(bufferSize);\n          downstream.onSubscribe(this);\n     }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "264", "src_id": "M520", "code": "    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false;\n        boolean success = false;\n        try {\n            flush();\n            ((FileOutputStream) out).getFD().sync();\n            triedToClose = true;\n            super.close();\n            success = true;\n        } finally {\n                if (success) {\n                    boolean renamed = tmpFile.renameTo(origFile);\n                    if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                        throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                    }\n                } else {\n                    if (!triedToClose) {\n                        // If we failed when flushing, try to close it to not leak\n                        // an FD\n                        IOUtils.closeStream(out);\n                    }\n                    // close wasn't successful, try to delete the tmp file\n                    if (!tmpFile.delete()) {\n                        LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                    }\n                }\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "265", "src_id": "M1043", "code": "    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }/*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (bb.remaining() > 0) {\n                    break;\n                }\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {/*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }/*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n                int p = b.position();\n                directBuffer.put(b);\n                b.position(p);\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }/*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n            directBuffer.flip();\n            int sent = sock.write(directBuffer);\n            ByteBuffer bb;\n            // Remove the buffers that we have sent\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (sent < bb.remaining()) {/*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }/* We've sent the whole buffer, so drop the buffer */\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "266", "src_id": "M196", "code": "    public static void main(String[] args) throws IOException {\t\n        MergedLogSource source = new MergedLogSource(args);\n        PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n        PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n        PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n        PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n        LogIterator iter;\n        System.out.println(source);\n        iter = source.iterator();\n        long currentms = 0;\n        long currentsec = 0;\n        long currentmin = 0;\n        long currenthour = 0;\n        Set<Long> zxids_ms = new HashSet<Long>();\n        long zxid_sec = 0;\n        long zxid_min = 0;\n        long zxid_hour = 0;\n        while (iter.hasNext()) {\n            LogEntry e = iter.next();\n            TransactionEntry cxn = (TransactionEntry) e;\n            long ms = cxn.getTimestamp();\n            long sec = ms / MS_PER_SEC;\n            long min = ms / MS_PER_MIN;\n            long hour = ms / MS_PER_HOUR;\n            if (currentms != ms && currentms != 0) {\n                ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n                zxid_sec += zxids_ms.size();\n                zxid_min += zxids_ms.size();\n                zxid_hour += zxids_ms.size();\n                zxids_ms.clear();\n            }\n            if (currentsec != sec && currentsec != 0) {\n                ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n                zxid_sec = 0;\n            }\n            if (currentmin != min && currentmin != 0) {\n                ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n                zxid_min = 0;\n            }\n            if (currenthour != hour && currenthour != 0) {\n                ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n                zxid_hour = 0;\n            }\n            currentms = ms;\n            currentsec = sec;\n            currentmin = min;\n            currenthour = hour;\n            zxids_ms.add(cxn.getZxid());\n        }\n        iter.close();\n        ps_ms.close();\n        ps_sec.close();\n        ps_min.close();\n        ps_hour.close();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "267", "src_id": "M1149", "code": "    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                        LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                    } catch (Exception e) {\n                        LOG.warn(\"Ignoring unexpected exception\", e);\n                    }\n\n            }\n            // Close connections still pending on the selector. Any others\n            // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n            updateQueue.clear();\n        } finally {\n                closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n                NIOServerCnxnFactory.this.stop();\n                LOG.info(\"selector thread exited run method\");\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "268", "src_id": "M290", "code": "    public String getStatus(String name, long timeout) throws KeeperException, InterruptedException {\n        Stat stat = new Stat();\n        byte[] data = null;\n        long endTime = Time.currentElapsedTime() + timeout;\n        KeeperException lastException = null;\n        for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n            try {\n                data = zk.getData(reportsNode + '/' + name, false, stat);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n                }\n                lastException = null;\n                break;\n            } catch (ConnectionLossException e) {\n                    lastException = e;\n                } catch (NoNodeException e) {\n                    final Object eventObj = new Object();\n                    synchronized (eventObj) {\n                        // wait for the node to appear\n                        Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {public void process(WatchedEvent event) {synchronized (eventObj) {eventObj.notifyAll();}}});\n                        if (eStat == null) {\n                            eventObj.wait(endTime - Time.currentElapsedTime());\n                        }\n                    }\n                    lastException = e;\n                }\n\n        }\n        if (lastException != null) {\n            throw lastException;\n        }\n        return new String(data);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "269", "src_id": "M192", "code": "    private void init() throws IOException {\n        File f = new File(file);\n        RandomAccessFileReader in = new RandomAccessFileReader(f);\n        SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);\n        Pattern idp = Pattern.compile(\"\\\\[myid:(\\\\d+)\\\\]\");\n        long lastFp = in.getPosition();\n        String line = in.readLine();\n        Matcher m = null;\n        // if we have read data from the file, and it matches the timep pattern\n        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {\n            starttime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. First line doesn't start with time\");\n        }\n        /*\n\t  Count number of log entries. Any line starting with a timestamp counts as an entry\n\t*/\n\n        String lastentry = line;\n        try {\n            while (line != null) {\n                m = timep.matcher(line);\n                if (m.lookingAt()) {\n                    if (size % skipN == 0) {\n                        long time = timestampFromText(dateformat, m.group(1));\n                        skiplist.addMark(time, lastFp, size);\n                    }\n                    size += 1; \n                    lastentry = line;\n                } \n                if (serverid == 0 && (m = idp.matcher(line)).find()) {\n                    serverid = Integer.valueOf(m.group(1));\n                }\n                lastFp = in.getPosition();\n                line = in.readLine();\n            }\n        } catch (EOFException eof) {\n            // ignore, simply end of file, though really (line!=null) should have caught this\n            } finally {\n                in.close();\n            }\n        m = timep.matcher(lastentry);\n        if (m.lookingAt()) {\n            endtime = timestampFromText(dateformat, m.group(1));\n        } else {\n            throw new IOException(\"Invalid log format. Last line doesn't start with time\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "270", "src_id": "M254", "code": "    private void distributedConfigureServers(int count) throws IOException {\n        StringBuilder sbClient = new StringBuilder();\n        StringBuilder sbServer = new StringBuilder();\n        try {\n            for (int i = 0; i < count; i++) {\n                String r[] = QuorumPeerInstance.createServer(im, i);\n                if (i > 0) {\n                    sbClient.append(',');\n                    sbServer.append(',');\n                }\n                sbClient.append(r[0]); // r[0] == \"host:clientPort\"\n\n                sbServer.append(r[1]); // r[1] == \"host:leaderPort:leaderElectionPort\"\n\n                sbServer.append(\";\" + (r[0].split(\":\"))[1]); // Appending \";clientPort\"\n\n            }\n            serverHostPort = sbClient.toString();\n            quorumHostPort = sbServer.toString();\n        } catch (Exception e) {\n                IOException ioe = new IOException(e.getMessage());\n                ioe.setStackTrace(e.getStackTrace());\n                throw ioe;\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "271", "src_id": "M40", "code": "    protected void animateVertically(int posx, int fromY, int toY) throws InterruptedException {\n        toaster.setLocation(posx, fromY);\n        if (toY < fromY) {\n            for (int i = fromY; i > toY; i -= step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        } else {\n            for (int i = fromY; i < toY; i += step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        }\n        toaster.setLocation(posx, toY);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "272", "src_id": "M1130", "code": "    public synchronized Map<String, Object> getConnectionInfo(boolean brief) {\n        Map<String, Object> info = new LinkedHashMap<>();\n        info.put(\"remote_socket_address\", getRemoteSocketAddress());\n        info.put(\"interest_ops\", getInterestOps());\n        info.put(\"outstanding_requests\", getOutstandingRequests());\n        info.put(\"packets_received\", getPacketsReceived());\n        info.put(\"packets_sent\", getPacketsSent());\n        if (!brief) {\n            info.put(\"session_id\", getSessionId());\n            info.put(\"last_operation\", getLastOperation());\n            info.put(\"established\", getEstablished());\n            info.put(\"session_timeout\", getSessionTimeout());\n            info.put(\"last_cxid\", getLastCxid());\n            info.put(\"last_zxid\", getLastZxid());\n            info.put(\"last_response_time\", getLastResponseTime());\n            info.put(\"last_latency\", getLastLatency());\n            info.put(\"min_latency\", getMinLatency());\n            info.put(\"avg_latency\", getAvgLatency());\n            info.put(\"max_latency\", getMaxLatency());\n        }\n\n        return info;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "125", "src_id": "M361", "code": "private static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n        try {\n                if (!isValidJakartaMailPart(part)) {\n                        log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n                        return;\n                }\n\n                Class<?> partClass = part.getClass();\n                Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n                Method getContent = partClass.getMethod(\"getContent\");\n                Method getDisposition = partClass.getMethod(\"getDisposition\");\n                Method getFileName = partClass.getMethod(\"getFileName\");\n                Method getContentType = partClass.getMethod(\"getContentType\");\n                Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n                Object disposition = getDisposition.invoke(part);\n                String filename = (String) getFileName.invoke(part);\n                String contentType = (String) getContentType.invoke(part);\n\n                if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n                        content.setTextBody((String) getContent.invoke(part));\n                } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n                        content.setHtmlBody((String) getContent.invoke(part));\n                } else if (\"attachment\".equalsIgnoreCase((String) disposition) || (filename != null && !filename.trim().isEmpty())) {\n                        content.setAttachmentCount(content.getAttachmentCount() + 1);\n                        // Always extract basic attachment metadata for display\n                        if (filename != null && !filename.trim().isEmpty()) {\n                                // Create attachment with metadata only\n                                EmailAttachment attachment = new EmailAttachment();\n                                // Apply MIME decoding to filename to handle encoded attachment names\n                                attachment.setFilename(safeMimeDecode(filename));\n                                attachment.setContentType(contentType);\n                                // Check if it's an embedded image\n                                String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n                                \n                                if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                                        attachment.setEmbedded(true);\n                                        // Store the Content-ID, removing angle brackets if present\n                                        String contentId = contentIdHeaders[0];\n                                        if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                                                contentId = contentId.substring(1, contentId.length() - 1);\n                                        }\n                                        attachment.setContentId(contentId);\n                                }\n\n                                // Extract attachment data if attachments should be included OR if it's an\n                                // embedded image (needed for inline display)\n                                if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n                                        try {\n                                                Object attachmentContent = getContent.invoke(part);\n                                                byte[] attachmentData = null;\n\n                                                if (attachmentContent instanceof java.io.InputStream inputStream) {\n                                                        try {\n                                                                attachmentData = inputStream.readAllBytes();\n                                                        } catch (IOException e) {\n                                                                        log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n                                                                }\n                                                                \n                                                } else if (attachmentContent instanceof byte[] byteArray) {\n                                                        attachmentData = byteArray;\n                                                } else if (attachmentContent instanceof String stringContent) {\n                                                        attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n                                                }\n\n                                                \n                                                if (attachmentData != null) {\n                                                        // Check size limit (use default 10MB if request is null)\n                                                        long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                                                        long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                                                        if (attachmentData.length <= maxSizeBytes) {\n                                                                attachment.setData(attachmentData);\n                                                                attachment.setSizeBytes(attachmentData.length);\n                                                        } else {\n                                                                // For embedded images, always include data regardless of size\n                                                                // to ensure inline display works\n                                                                if (attachment.isEmbedded()) { \n                                                                        attachment.setData(attachmentData);\n                                                                }  \n                                                                attachment.setSizeBytes(attachmentData.length);\n                                                        }\n                                                }\n                                        } catch (Exception e) {\n                                                        log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n                                                }\n                                                \n                                }\n                                // Add attachment to the list for display (with or without data)\n                                content.getAttachments().add(attachment);\n                        }\n                } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n                        // Handle nested multipart content\n                        try {\n                                Object multipartContent = getContent.invoke(part);\n                                Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                                \n                                if (multipartClass.isInstance(multipartContent)) {\n                                        processMultipartAdvanced(multipartContent, content, request);\n                                }\n                        } catch (Exception e) {\n                                        log.warn(\"Error processing multipart content: {}\", e.getMessage());\n                                }\n                                \n                }\n                \n        } catch (Exception e) {\n                        log.warn(\"Error processing multipart part: {}\", e.getMessage());\n                }\n                \n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "126", "src_id": "M343", "code": "private static EmailContent extractEmailContentAdvanced(byte[] emlBytes, EmlToPdfRequest request) {\n        try {\n                // Use Jakarta Mail for processing\n                Class<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n                Class<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n                Method getDefaultInstance = sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n                Object session = getDefaultInstance.invoke(null, new Properties());\n                // Cast the session object to the proper type for the constructor\n                Class<?>[] constructorArgs = new Class<?>[] { sessionClass, InputStream.class};\n                Constructor<?> mimeMessageConstructor = mimeMessageClass.getConstructor(constructorArgs);\n                Object message = mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n                return extractEmailContentAdvanced(message, request);\n        } catch (ReflectiveOperationException e) {\n                        // Create basic EmailContent from basic processing\n                        EmailContent content = new EmailContent();\n                        content.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n                        return content;\n                }\n                \n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "127", "src_id": "M356", "code": "private static void appendEnhancedStyles(StringBuilder html) {\n        int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n        String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n        String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n        String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n        html.append(\"body {\\n\");\n        html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n        html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n        html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n        html.append(\"  color: \").append(textColor).append(\";\\n\");\n        html.append(\"  margin: 0;\\n\");\n        html.append(\"  padding: 16px;\\n\");\n        html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-container {\\n\");\n        html.append(\"  width: 100%;\\n\");\n        html.append(\"  max-width: 100%;\\n\");\n        html.append(\"  margin: 0 auto;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header {\\n\");\n        html.append(\"  padding-bottom: 10px;\\n\");\n        html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n        html.append(\"  margin-bottom: 10px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header h1 {\\n\");\n        html.append(\"  margin: 0 0 10px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n        html.append(\"  font-weight: bold;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-meta div {\\n\");\n        html.append(\"  margin-bottom: 2px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-body {\\n\");\n        html.append(\"  word-wrap: break-word;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section {\\n\");\n        html.append(\"  margin-top: 15px;\\n\");\n        html.append(\"  padding: 10px;\\n\");\n        html.append(\"  background-color: \").append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\");\n        html.append(\"  border: 1px solid \").append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section h3 {\\n\");\n        html.append(\"  margin: 0 0 8px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-item {\\n\");\n        html.append(\"  padding: 5px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-icon {\\n\");\n        html.append(\"  margin-right: 5px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-details, .attachment-type {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  color: #555555;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n        html.append(\"  margin-top: 8px;\\n\");\n        html.append(\"  padding: 6px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note {\\n\");\n        html.append(\"  background-color: #e6ffed;\\n\");\n        html.append(\"  border: 1px solid #d4f7dc;\\n\");\n        html.append(\"  color: #006420;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-info-note {\\n\");\n        html.append(\"  background-color: #fff9e6;\\n\");\n        html.append(\"  border: 1px solid #fff0c2;\\n\");\n        html.append(\"  color: #664d00;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container {\\n\");\n        html.append(\"  display: flex;\\n\");\n        html.append(\"  align-items: center;\\n\");\n        html.append(\"  padding: 8px;\\n\");\n        html.append(\"  background-color: #f8f9fa;\\n\");\n        html.append(\"  border: 1px solid #dee2e6;\\n\");\n        html.append(\"  border-radius: 4px;\\n\");\n        html.append(\"  margin: 4px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container:hover {\\n\");\n        html.append(\"  background-color: #e9ecef;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-note {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n        html.append(\"  color: #6c757d;\\n\");\n        html.append(\"  font-style: italic;\\n\");\n        html.append(\"  margin-left: 8px;\\n\");\n        html.append(\"}\\n\\n\");\n        // Basic image styling: ensure images are responsive but not overly constrained.\n        html.append(\"img {\\n\");\n        html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n        \n        html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n        \n        html.append(\"  display: block;\\n\"); // Avoid extra space below images\n        \n        html.append(\"}\\n\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "128", "src_id": "M348", "code": "private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n                String[] lines = emlContent.split(\"\\r?\\n\");\n                for (int i = 0; i < lines.length; i++) {\n                        String line = lines[i];\n                        \n                        if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                                StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                                // Handle multi-line headers\n                                for (int j = i + 1; j < lines.length; j++) {\n                                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                                                value.append(\" \").append(lines[j].trim());\n                                        } else {\n                                                break;\n                                        }\n                                }\n                                // Apply MIME header decoding\n                                return safeMimeDecode(value.toString());\n                        }\n                        \n                        if (line.trim().isEmpty()) {\n                                break;\n                        }\n                }\n        } catch (RuntimeException e) {\n                        log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n                }\n                \n        return \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "329", "src_id": "M185", "code": "    synchronized public long size() throws IOException {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"size() called\");\n        }\n\n        if (this.endtime >= src.getEndTime()) {\n            return src.size() - skippedAtStart;\n        }\n\n        long pos = in.getPosition();\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"saved pos () = \" + pos);\n        }\n\n        LogEntry e;\n        LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);\n        in.seek(lastseg.getBytes());\n\n        buf = \"\";  // clear the buf so we don't get something we read before we sought\n\n\n        // number of entries skipped to get to the end of the iterator, less the number skipped to get to the start\n        long count = lastseg.getEntriesSkipped() - skippedAtStart; \n        while ((e = readNextEntry()) != null) {\n            if (LOG.isTraceEnabled()) {\n            //LOG.trace(e);\n            }\n\n            if (e.getTimestamp() > this.endtime) {\n                break;\n            }\n            count++;\n        }\n        in.seek(pos);\n\n        buf = \"\";\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"size() = \" + count);\n        }\n        return count;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "330", "src_id": "M1043", "code": "    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n\n                if (bb.remaining() > 0) {\n                    break;\n                }\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {/*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n                int p = b.position();\n                directBuffer.put(b);\n\n                b.position(p);\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }/*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n            directBuffer.flip();\n\n            int sent = sock.write(directBuffer);\n            ByteBuffer bb;\n            // Remove the buffers that we have sent\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n\n                if (sent < bb.remaining()) {/*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n\n                    break;\n                }/* We've sent the whole buffer, so drop the buffer */\n                sent -= bb.remaining();\n\n                outgoingBuffers.remove();\n            }\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "331", "src_id": "M1150", "code": "    private void select() {\n        try {\n            selector.select();\n\n            Set<SelectionKey> selected = selector.selectedKeys();\n            ArrayList<SelectionKey> selectedList = new ArrayList<>(selected);\n            Collections.shuffle(selectedList);\n\n            Iterator<SelectionKey> selectedKeys = selectedList.iterator();\n            while (!stopped && selectedKeys.hasNext()) {\n                SelectionKey key = selectedKeys.next();\n                selected.remove(key);\n                if (!key.isValid()) {\n                    cleanupSelectionKey(key);\n\n                    continue;\n                }\n\n                if (key.isReadable() || key.isWritable()) {\n                    handleIO(key);\n                } else {\n                    LOG.warn(\"Unexpected ops in select {}\", key.readyOps());\n                }\n            }\n        } catch (IOException e) {\n                LOG.warn(\"Ignoring IOException while selecting\", e);\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "332", "src_id": "M520", "code": "    @Override\n    public void close() throws IOException {\n        boolean triedToClose = false;\n        boolean success = false;\n\n        try {\n            flush();\n\n            ((FileOutputStream) out).getFD().sync();\n\n            triedToClose = true;\n\n            super.close();\n\n            success = true;\n        } finally {\n                if (success) {\n                    boolean renamed = tmpFile.renameTo(origFile);\n                    if (!renamed && (!origFile.delete() || !tmpFile.renameTo(origFile))) {\n                        throw new IOException(\"Could not rename temporary file \" + tmpFile + \" to \" + origFile);\n                    }\n                } else {\n                    if (!triedToClose) {\n                        // If we failed when flushing, try to close it to not leak\n                        // an FD\n                        IOUtils.closeStream(out);\n                    }\n\n                    // close wasn't successful, try to delete the tmp file\n                    if (!tmpFile.delete()) {\n                        LOG.warn(\"Unable to delete tmp file {}\", tmpFile);\n                    }\n                }\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "333", "src_id": "M1154", "code": "    public void doWork() throws InterruptedException {\n        if (!key.isValid()) {\n            selectorThread.cleanupSelectionKey(key);\n\n            return;\n        }\n\n        if (key.isReadable() || key.isWritable()) {\n            cnxn.doIO(key);\n            // Check if we shutdown or doIO() closed this connection\n            if (stopped) {\n                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n\n                return;\n            }\n\n            if (!key.isValid()) {\n                selectorThread.cleanupSelectionKey(key);\n\n                return;\n            }\n            touchCnxn(cnxn);\n        }\n        // Mark this connection as once again ready for selection\n        cnxn.enableSelectable();\n        // Push an update request on the queue to resume selecting\n        // on the current set of interest ops, which may have changed\n        // as a result of the I/O operations we just performed.\n        if (!selectorThread.addInterestOpsUpdateRequest(key)) {\n            cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "334", "src_id": "M290", "code": "    public String getStatus(String name, long timeout) throws KeeperException, InterruptedException {\n        Stat stat = new Stat();\n        byte[] data = null;\n        long endTime = Time.currentElapsedTime() + timeout;\n        KeeperException lastException = null;\n\n        for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {\n            try {\n                data = zk.getData(reportsNode + '/' + name, false, stat);\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Got Data: \" + ((data == null) ? \"null\" : new String(data)));\n                }\n                lastException = null;\n\n                break;\n            } catch (ConnectionLossException e) {\n                    lastException = e;\n                } catch (NoNodeException e) {\n                    final Object eventObj = new Object();\n\n                    synchronized (eventObj) {\n                        // wait for the node to appear\n                        Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {public void process(WatchedEvent event) {synchronized (eventObj) {eventObj.notifyAll();}}});\n                        if (eStat == null) {\n                            eventObj.wait(endTime - Time.currentElapsedTime());\n                        }\n                    }\n                    lastException = e;\n                }\n\n        }\n\n        if (lastException != null) {\n            throw lastException;\n        }\n        return new String(data);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "335", "src_id": "M196", "code": "    public static void main(String[] args) throws IOException {\t\n        MergedLogSource source = new MergedLogSource(args);\n        PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n        PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n        PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n        PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n        LogIterator iter;\n        System.out.println(source);\n\n        iter = source.iterator();\n\n        long currentms = 0;\n        long currentsec = 0;\n        long currentmin = 0;\n        long currenthour = 0;\n        Set<Long> zxids_ms = new HashSet<Long>();\n        long zxid_sec = 0;\n        long zxid_min = 0;\n        long zxid_hour = 0;\n\n        while (iter.hasNext()) {\n            LogEntry e = iter.next();\n            TransactionEntry cxn = (TransactionEntry) e;\n            long ms = cxn.getTimestamp();\n            long sec = ms / MS_PER_SEC;\n            long min = ms / MS_PER_MIN;\n            long hour = ms / MS_PER_HOUR;\n            if (currentms != ms && currentms != 0) {\n                ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n\n                zxid_sec += zxids_ms.size();\n\n                zxid_min += zxids_ms.size();\n\n                zxid_hour += zxids_ms.size();\n\n                zxids_ms.clear();\n            }\n\n            if (currentsec != sec && currentsec != 0) {\n                ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n\n                zxid_sec = 0;\n            }\n\n            if (currentmin != min && currentmin != 0) {\n                ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n\n                zxid_min = 0;\n            }\n\n            if (currenthour != hour && currenthour != 0) {\n                ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n\n                zxid_hour = 0;\n            }\n            currentms = ms;\n\n            currentsec = sec;\n\n            currentmin = min;\n\n            currenthour = hour;\n\n            zxids_ms.add(cxn.getZxid());\n        }\n        iter.close();\n\n        ps_ms.close();\n\n        ps_sec.close();\n\n        ps_min.close();\n\n        ps_hour.close();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "336", "src_id": "M1149", "code": "    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n\n                    processAcceptedConnections();\n\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                        LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                    } catch (Exception e) {\n                        LOG.warn(\"Ignoring unexpected exception\", e);\n                    }\n            }\n\n            // Close connections still pending on the selector. Any others\n            // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key : selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n            updateQueue.clear();\n        } finally {\n                closeSelector();\n\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n                NIOServerCnxnFactory.this.stop();\n\n                LOG.info(\"selector thread exited run method\");\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "337", "src_id": "M219", "code": "    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n\n            Endpoint e = contextMap.get(contextPath);\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n            for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n            zkMap.put(connectionId, zk);\n            // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n\n        return zk;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "11", "src_id": "M828", "code": "private Minf parseMinf(final Box ref) throws IOException {\n        final Minf obj = new Minf();\n        Box b;\n        while ((b = untilAnyBox(ref)) != null) {\n                switch (b.type) {\n                        case ATOM_DINF:\n                                obj.dinf = readFullBox(b);\n                                break;\n                        case ATOM_STBL:\n                                obj.stblStsd = parseStbl(b);\n                                break;\n                        case ATOM_VMHD:\n                        case ATOM_SMHD:\n                                obj.mhd = readFullBox(b);\n                                break;\n                }\n                ensure(b);\n        }\n        return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "12", "src_id": "M824", "code": "private Moov parseMoov(final Box ref) throws IOException {\n        Box b = readBox(ATOM_MVHD);\n        final Moov moov = new Moov();\n        \n        moov.mvhd = parseMvhd();\n        ensure(b);\n        final ArrayList<Trak> tmp = new ArrayList<>((int) moov.mvhd.nextTrackId);\n        while ((b = untilBox(ref, ATOM_TRAK, ATOM_MVEX)) != null) {\n                switch (b.type) {\n                        case ATOM_TRAK:\n                                tmp.add(parseTrak(b));\n                                break;\n                        case ATOM_MVEX:\n                                moov.mvexTrex = parseMvex(b, (int) moov.mvhd.nextTrackId);\n                                break;\n                }\n                ensure(b);\n        }\n        moov.trak = tmp.toArray(new Trak[0]);\n        return moov;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "13", "src_id": "M1086", "code": "private ArrayList<Object> getSpecialItems() {\n        synchronized (DownloadManager.this) {\n                ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n                ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n                List<Mission> remove = new ArrayList<>(hidden);\n                // hide missions (if required)\n                remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n                int fakeTotal = pending.size();\n                if (fakeTotal > 0) {\n                        fakeTotal++;\n                }\n                fakeTotal += finished.size();\n                \n                if (finished.size() > 0) {\n                        fakeTotal++;\n                }\n\n                ArrayList<Object> list = new ArrayList<>(fakeTotal);\n                if (pending.size() > 0) {\n                        list.add(PENDING);\n                        list.addAll(pending);\n                }\n                if (finished.size() > 0) {\n                        list.add(FINISHED);\n                        list.addAll(finished);\n                }\n                hasFinished = finished.size() > 0;\n                return list;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "14", "src_id": "M1024", "code": "@Override\npublic void run() {\n        if (mMission.current > 0) {\n                mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n        }\n\n        int retryCount = 0;\n        int httpCode = 204;\n        while (true) {\n                try {\n                        if (mMission.blocks == null && mMission.current == 0) {\n                                // calculate the whole size of the mission\n                                long finalLength = 0;\n                                long lowestSize = Long.MAX_VALUE;\n                                for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                                        mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                                        mMission.establishConnection(mId, mConn);\n                                        dispose();\n\n                                        if (Thread.interrupted()) {\n                                                return;\n                                        }\n                                        \n                                        long length = Utility.getTotalContentLength(mConn);\n                                        if (i == 0) {\n                                                httpCode = mConn.getResponseCode();\n                                                mMission.length = length;\n                                        }\n                                        if (length > 0) {\n                                                finalLength += length;\n                                        }\n                                        if (length < lowestSize) {\n                                                lowestSize = length;\n                                        }\n                                }\n\n                                mMission.nearLength = finalLength;\n                                // reserve space at the start of the file\n                                if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                                        if (lowestSize < 1) {\n                                                // the length is unknown use the default size\n                                                mMission.offsets[0] = RESERVE_SPACE_DEFAULT;\n                                        } else {\n                                                // use the smallest resource size to download, otherwise, use the maximum\n                                                mMission.offsets[0] = lowestSize < RESERVE_SPACE_MAXIMUM ? lowestSize : RESERVE_SPACE_MAXIMUM;\n                                        }\n                                }\n                        } else {\n                                // ask for the current resource length\n                                mConn = mMission.openConnection(true, 0, 0);\n                                mMission.establishConnection(mId, mConn);\n                                dispose();\n\n                                if (!mMission.running || Thread.interrupted()) {\n                                        return;\n                                }\n                                httpCode = mConn.getResponseCode();\n                                mMission.length = Utility.getTotalContentLength(mConn);\n                        }\n\n                        if (mMission.length == 0 || httpCode == 204) {\n                                mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                                return;\n                        }\n\n                        // check for dynamic generated content\n                        if (mMission.length == -1 && mConn.getResponseCode() == 200) {\n                                mMission.blocks = new int[0];\n                                mMission.length = 0;\n                                mMission.unknownLength = true;\n\n                                if (DEBUG) {\n                                        Log.d(TAG, \"falling back (unknown length)\");\n                                }\n                        } else {\n                                // Open again\n                                mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                                mMission.establishConnection(mId, mConn);\n                                dispose();\n\n                                if (!mMission.running || Thread.interrupted()) {\n                                        return;\n                                }\n                                synchronized (mMission.LOCK) {\n                                        if (mConn.getResponseCode() == 206) {\n                                                if (mMission.threadCount > 1) {\n                                                        int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                                                        if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) {\n                                                                count++;\n                                                        }\n                                                        mMission.blocks = new int[count];\n                                                } else {\n                                                        // if one thread is required don't calculate blocks, is useless\n                                                        mMission.blocks = new int[0];\n                                                        mMission.unknownLength = false;\n                                                }\n\n                                                if (DEBUG) {\n                                                        Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                                                }\n                                        } else {\n                                                // Fallback to single thread\n                                                mMission.blocks = new int[0];\n                                                mMission.unknownLength = false;\n\n                                                if (DEBUG) {\n                                                        Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                                                }\n                                        }\n                                }\n                                if (!mMission.running || Thread.interrupted()) {\n                                        return;\n                                }\n                        }\n\n                        try (SharpStream fs = mMission.storage.getStream()) {\n                                fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                                fs.seek(mMission.offsets[mMission.current]);\n                        }\n\n                        if (!mMission.running || Thread.interrupted()) {\n                                return;\n                        }\n\n                        if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                                String entityTag = mConn.getHeaderField(\"ETAG\");\n                                String lastModified = mConn.getHeaderField(\"Last-Modified\");\n                                MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n\n                                if (!TextUtils.isEmpty(entityTag)) {\n                                        recovery.setValidateCondition(entityTag);\n                                } else if (!TextUtils.isEmpty(lastModified)) {\n                                        recovery.setValidateCondition(lastModified); // Note: this is less precise\n                                        \n                                } else {\n                                        recovery.setValidateCondition(null);\n                                }\n                                \n                        }\n                        mMission.running = false;\n                        break;\n                } catch (InterruptedIOException | ClosedByInterruptException e) {\n                                return;\n                        } catch (Exception e) {\n                                if (!mMission.running || super.isInterrupted()) {\n                                        return;\n                                }\n\n                                if (e instanceof DownloadMission.HttpError && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                                        // for youtube streams. The url has expired\n                                        interrupt();\n                                        mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                                        return;\n                                }\n\n                                if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                                        mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                                        return;\n                                }\n\n                                if (retryCount++ > mMission.maxRetry) {\n                                        Log.e(TAG, \"initializer failed\", e);\n                                        mMission.notifyError(e);\n                                        return;\n                                }\n                                Log.e(TAG, \"initializer failed, retrying\", e);\n                        }\n                        \n        }\n\n        mMission.start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "15", "src_id": "M1099", "code": "@SuppressLint(\"DefaultLocale\")\nprivate void updateProgress(ViewHolderItem h) {\n        if (h == null || h.item == null || h.item.mission instanceof FinishedMission) {\n                return;\n        }\n\n        DownloadMission mission = (DownloadMission) h.item.mission;\n        double done = mission.done;\n        long length = mission.getLength();\n        long now = System.currentTimeMillis();\n        boolean hasError = mission.errCode != ERROR_NOTHING;\n        // hide on error\n        // show if current resource length is not fetched\n        // show if length is unknown\n        h.progress.setMarquee(mission.isRecovering() || !hasError && (!mission.isInitialized() || mission.unknownLength));\n        double progress;\n        if (mission.unknownLength) {\n                progress = Double.NaN;\n                h.progress.setProgress(0.0f);\n        } else {\n                progress = done / length;\n        }\n\n        if (hasError) {\n                h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n                h.status.setText(R.string.msg_error);\n        } else if (isNotFinite(progress)) {\n                h.status.setText(UNDEFINED_PROGRESS);\n        } else {\n                h.status.setText(String.format(\"%.2f%%\", progress * 100));\n                h.progress.setProgress(progress);\n        }\n\n        \n        @StringRes int state;\n        String sizeStr = Utility.formatBytes(length).concat(\"  \");\n\n        if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n                h.size.setText(sizeStr);\n                return;\n        } else if (!mission.running) {\n                state = mission.enqueued ? R.string.queued : R.string.paused;\n        } else if (mission.isPsRunning()) {\n                state = R.string.post_processing;\n        } else if (mission.isRecovering()) {\n                state = R.string.recovering;\n        } else {\n                state = 0;\n        }\n\n        \n        if (state != 0) {\n                // update state without download speed\n                h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n                h.resetSpeedMeasure();\n                return;\n        }\n\n        if (h.lastTimestamp < 0) {\n                h.size.setText(sizeStr);\n                h.lastTimestamp = now;\n                h.lastDone = done;\n                return;\n        }\n\n        long deltaTime = now - h.lastTimestamp;\n        double deltaDone = done - h.lastDone;\n        if (h.lastDone > done) {\n                h.lastDone = done;\n                h.size.setText(sizeStr);\n                return;\n        }\n\n        if (deltaDone > 0 && deltaTime > 0) {\n                float speed = (float) ((deltaDone * 1000d) / deltaTime);\n                float averageSpeed = speed;\n\n                if (h.lastSpeedIdx < 0) {\n                        Arrays.fill(h.lastSpeed, speed);\n                        h.lastSpeedIdx = 0;\n                } else {\n                        for (int i = 0; i < h.lastSpeed.length; i++) {\n                                averageSpeed += h.lastSpeed[i];\n                        }\n                        averageSpeed /= h.lastSpeed.length + 1.0f;\n                }\n\n                String speedStr = Utility.formatSpeed(averageSpeed);\n                String etaStr;\n\n                if (mission.unknownLength) {\n                        etaStr = \"\";\n                } else {\n                        long eta = (long) Math.ceil((length - done) / averageSpeed);\n                        etaStr = Utility.formatBytes((long) done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n                }\n                h.size.setText(sizeStr.concat(etaStr).concat(speedStr));\n                h.lastTimestamp = now;\n                h.lastDone = done;\n                h.lastSpeed[h.lastSpeedIdx++] = speed;\n\n                if (h.lastSpeedIdx >= h.lastSpeed.length) {\n                        h.lastSpeedIdx = 0;\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "16", "src_id": "M817", "code": "private Trun parseTrun() throws IOException {\n        final Trun obj = new Trun();\n        \n        obj.bFlags = stream.readInt();\n        obj.entryCount = stream.readInt(); // unsigned int\n        \n        obj.entriesRowSize = 0;\n        \n        if (hasFlag(obj.bFlags, 0x0100)) {\n                obj.entriesRowSize += 4;\n        }\n        if (hasFlag(obj.bFlags, 0x0200)) {\n                obj.entriesRowSize += 4;\n        }\n        if (hasFlag(obj.bFlags, 0x0400)) {\n                obj.entriesRowSize += 4;\n        }\n        if (hasFlag(obj.bFlags, 0x0800)) {\n                obj.entriesRowSize += 4;\n        }\n        obj.bEntries = new byte[obj.entriesRowSize * obj.entryCount];\n\n        if (hasFlag(obj.bFlags, 0x0001)) {\n                obj.dataOffset = stream.readInt();\n        }\n        if (hasFlag(obj.bFlags, 0x0004)) {\n                obj.bFirstSampleFlags = stream.readInt();\n        }\n        stream.read(obj.bEntries);\n\n        for (int i = 0; i < obj.entryCount; i++) {\n                final TrunEntry entry = obj.getEntry(i);\n                if (hasFlag(obj.bFlags, 0x0100)) {\n                        obj.chunkDuration += entry.sampleDuration;\n                }\n                if (hasFlag(obj.bFlags, 0x0200)) {\n                        obj.chunkSize += entry.sampleSize;\n                }\n                \n                if (hasFlag(obj.bFlags, 0x0800)) {\n                        if (!hasFlag(obj.bFlags, 0x0100)) {\n                                obj.chunkDuration += entry.sampleCompositionTimeOffset;\n                        }\n                }\n        }\n\n        return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "17", "src_id": "M883", "code": "private void makeMvhd(final long longestTrack) throws IOException {\n        auxWrite(new byte[] {0x00, 0x00, 0x00, 0x78, 0x6D, 0x76, 0x68, 0x64, 0x01, 0x00, 0x00, 0x00});\n        auxWrite(ByteBuffer.allocate(28).putLong(time).putLong(time).putInt(DEFAULT_TIMESCALE).putLong(longestTrack).array());\n        auxWrite(new byte[] {0x00, 0x01, 0x00, 0x00, 0x01, 0x00, // default volume and rate\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved values\n        // default matrix\n        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00});\n        auxWrite(new byte[24]); // predefined\n        \n        auxWrite(ByteBuffer.allocate(4).putInt(tracks.length + 1).array());\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "18", "src_id": "M806", "code": "public Mp4DashChunk getNextChunk(final boolean infoOnly) throws IOException {\n        final Mp4Track track = tracks[selectedTrack];\n        while (stream.available()) {\n                if (chunkZero) {\n                        ensure(box);\n                        \n                        if (!stream.available()) {\n                                break;\n                        }\n                        box = readBox();\n                } else {\n                        chunkZero = true;\n                }\n\n                switch (box.type) {\n                        case ATOM_MOOF:\n                                if (moof != null) {\n                                        throw new IOException(\"moof found without mdat\");\n                                }\n                                moof = parseMoof(box, track.trak.tkhd.trackId);\n                                if (moof.traf != null) {\n                                        if (hasFlag(moof.traf.trun.bFlags, 0x0001)) {\n                                                moof.traf.trun.dataOffset -= box.size + 8;\n                                                if (moof.traf.trun.dataOffset < 0) {\n                                                        throw new IOException(\"trun box has wrong data offset, \" + \"points outside of concurrent mdat box\");\n                                                }\n                                        }\n\n                                        if (moof.traf.trun.chunkSize < 1) {\n                                                if (hasFlag(moof.traf.tfhd.bFlags, 0x10)) {\n                                                        moof.traf.trun.chunkSize = moof.traf.tfhd.defaultSampleSize * moof.traf.trun.entryCount;\n                                                } else {\n                                                        moof.traf.trun.chunkSize = (int) (box.size - 8);\n                                                }\n                                        }\n                                        \n                                        if (!hasFlag(moof.traf.trun.bFlags, 0x900) && moof.traf.trun.chunkDuration == 0) {\n                                                if (hasFlag(moof.traf.tfhd.bFlags, 0x20)) {\n                                                        moof.traf.trun.chunkDuration = moof.traf.tfhd.defaultSampleDuration * moof.traf.trun.entryCount;\n                                                }\n                                        }\n                                }\n                                break;\n                        case ATOM_MDAT:\n                                if (moof == null) {\n                                        throw new IOException(\"mdat found without moof\");\n                                }\n                                if (moof.traf == null) {\n                                        moof = null;\n                                        continue; // find another chunk\n                                        \n                                }\n                                final Mp4DashChunk chunk = new Mp4DashChunk();\n                                chunk.moof = moof;\n                                if (!infoOnly) {\n                                        chunk.data = stream.getView(moof.traf.trun.chunkSize);\n                                }\n                                moof = null;\n                                stream.skipBytes(chunk.moof.traf.trun.dataOffset);\n                                return chunk;\n                        default:\n                }\n        }\n\n        return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "19", "src_id": "M1055", "code": "public void updateMission(Mission mission) {\n        ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n        SQLiteDatabase database = getWritableDatabase();\n        String ts = String.valueOf(mission.timestamp);\n        int rowsAffected;\n\n        if (mission instanceof FinishedMission) {\n                if (mission.storage.isInvalid()) {\n                        rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new String[] { ts });\n                } else {\n                        rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_PATH + \" = ?\", new String[] { mission.storage.getUri().toString() });\n                }\n        } else {\n                throw new UnsupportedOperationException(\"DownloadMission\");\n        }\n\n        if (rowsAffected != 1) {\n                Log.e(\"FinishedMissionStore\", \"Expected 1 row to be affected by update but got \" + rowsAffected);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "213", "src_id": "M254", "code": "    private void distributedConfigureServers(int count) throws IOException {\n        StringBuilder sbClient = new StringBuilder();\n        StringBuilder sbServer = new StringBuilder();\n        try {\n            for (int i = 0; i < count; i++) {\n                String r[] = QuorumPeerInstance.createServer(im, i);\n\n                if (i > 0) {\n                    sbClient.append(',');\n                    sbServer.append(',');\n                }\n                sbClient.append(r[0]); // r[0] == \"host:clientPort\"\n\n                sbServer.append(r[1]); // r[1] == \"host:leaderPort:leaderElectionPort\"\n\n                sbServer.append(\";\" + (r[0].split(\":\"))[1]); // Appending \";clientPort\"\n\n            }\n\n            serverHostPort = sbClient.toString();\n            quorumHostPort = sbServer.toString();\n        } catch (Exception e) {\n                IOException ioe = new IOException(e.getMessage());\n\n                ioe.setStackTrace(e.getStackTrace());\n                throw ioe;\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "214", "src_id": "M39", "code": "    private void initComponents() {\n        setSize(toasterWidth, toasterHeight);\n        message.setFont(getToasterMessageFont());\n\n        JPanel externalPanel = new JPanel(new BorderLayout(1, 1));\n\n        externalPanel.setBackground(getBorderColor());\n\n        JPanel innerPanel = new JPanel(new BorderLayout(getMargin(), getMargin()));\n\n        innerPanel.setBackground(getToasterColor());\n        message.setBackground(getToasterColor());\n        message.setMargin(new Insets(2, 2, 2, 2));\n        message.setLineWrap(true);\n        message.setWrapStyleWord(true);\n\n        EtchedBorder etchedBorder = (EtchedBorder) BorderFactory.createEtchedBorder();\n\n        externalPanel.setBorder(etchedBorder);\n        externalPanel.add(innerPanel);\n        message.setForeground(getMessageColor());\n        innerPanel.add(iconLabel, BorderLayout.WEST);\n        innerPanel.add(message, BorderLayout.CENTER);\n        getContentPane().add(externalPanel);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "215", "src_id": "M1130", "code": "    public synchronized Map<String, Object> getConnectionInfo(boolean brief) {\n        Map<String, Object> info = new LinkedHashMap<>();\n\n        info.put(\"remote_socket_address\", getRemoteSocketAddress());\n        info.put(\"interest_ops\", getInterestOps());\n        info.put(\"outstanding_requests\", getOutstandingRequests());\n        info.put(\"packets_received\", getPacketsReceived());\n        info.put(\"packets_sent\", getPacketsSent());\n\n        if (!brief) {\n            info.put(\"session_id\", getSessionId());\n            info.put(\"last_operation\", getLastOperation());\n            info.put(\"established\", getEstablished());\n            info.put(\"session_timeout\", getSessionTimeout());\n            info.put(\"last_cxid\", getLastCxid());\n            info.put(\"last_zxid\", getLastZxid());\n            info.put(\"last_response_time\", getLastResponseTime());\n            info.put(\"last_latency\", getLastLatency());\n            info.put(\"min_latency\", getMinLatency());\n            info.put(\"avg_latency\", getAvgLatency());\n            info.put(\"max_latency\", getMaxLatency());\n        }\n        return info;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "216", "src_id": "M1149", "code": "    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                        LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                    } catch (Exception e) {\n                        LOG.warn(\"Ignoring unexpected exception\", e);\n                    }\n\n            }\n\n            // Close connections still pending on the selector. Any others\n            // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key:selector.keys()) {\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n\n            SocketChannel accepted;\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n\n            updateQueue.clear();\n        } finally {\n                closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n                NIOServerCnxnFactory.this.stop();\n                LOG.info(\"selector thread exited run method\");\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "217", "src_id": "M1043", "code": "    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (bb.remaining() > 0) {\n                    break;\n                }\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n\n            for (ByteBuffer b:outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {/*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n                int p = b.position();\n\n                directBuffer.put(b);\n                b.position(p);\n\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }\n            /*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n            directBuffer.flip();\n            int sent = sock.write(directBuffer);\n            ByteBuffer bb;\n            // Remove the buffers that we have sent\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (sent < bb.remaining()) {/*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }/* We've sent the whole buffer, so drop the buffer */\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "218", "src_id": "M577", "code": "    public Long update(E elem, int timeout) {\n        Long prevExpiryTime = elemMap.get(elem);\n        long now = Time.currentElapsedTime();\n        Long newExpiryTime = roundToNextInterval(now + timeout);\n\n        if (newExpiryTime.equals(prevExpiryTime)) {\n            // No change, so nothing to update\n            return null;\n        }\n\n        // First add the elem to the new expiry time bucket in expiryMap.\n        Set<E> set = expiryMap.get(newExpiryTime);\n\n        if (set == null) {\n            // Construct a ConcurrentHashSet using a ConcurrentHashMap\n            set = Collections.newSetFromMap(new ConcurrentHashMap<>());\n\n            // Put the new set in the map, but only if another thread\n            // hasn't beaten us to it\n            Set<E> existingSet = expiryMap.putIfAbsent(newExpiryTime, set);\n\n            if (existingSet != null) {\n                set = existingSet;\n            }\n        }\n        set.add(elem);\n        // Map the elem to the new expiry time. If a different previous\n        // mapping was present, clean up the previous expiry bucket.\n        prevExpiryTime = elemMap.put(elem, newExpiryTime);\n\n        if (prevExpiryTime != null && !newExpiryTime.equals(prevExpiryTime)) {\n            Set<E> prevSet = expiryMap.get(prevExpiryTime);\n\n            if (prevSet != null) {\n                prevSet.remove(elem);\n            }\n        }\n        return newExpiryTime;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "219", "src_id": "M219", "code": "    synchronized public static ZooKeeper getClient(String contextPath, String session, int expireTime) throws IOException {\n        final String connectionId = concat(contextPath, session);\n        ZooKeeper zk = zkMap.get(connectionId);\n\n        if (zk == null) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(String.format(\"creating new \" + \"connection for : '%s'\", connectionId));\n            }\n\n            Endpoint e = contextMap.get(contextPath);\n\n            zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));\n\n            for (Map.Entry<String, String> p:e.getZooKeeperAuthInfo().entrySet()) {\n                zk.addAuthInfo(\"digest\", String.format(\"%s:%s\", p.getKey(), p.getValue()).getBytes());\n            }\n\n            zkMap.put(connectionId, zk);\n\n            // a session should automatically expire after an amount of time\n            if (session != null) {\n                zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));\n            }\n        }\n        return zk;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "220", "src_id": "M282", "code": "    @Test\n    public void testSimpleCase() throws Exception {\n        configureServers(serverCount);\n        configureClients(clientCount, SimpleClient.class, getHostPort());\n\n        Stat stat = new Stat();\n\n        startServers();\n        LOG.debug(\"Connecting to \" + getHostPort());\n\n        ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);\n\n        waitForConnect(zk, 10000);\n        zk.create(\"/simpleCase\", \"orig\".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        startClients();\n\n        // Check that all clients connect properly\n        for (int i = 0; i < getClientCount(); i++) {\n            for (int j = 0; j < maxTries; j++) {\n                try {\n                    byte b[] = zk.getData(\"/simpleCase/\" + i, false, stat);\n\n                    Assert.assertEquals(\"orig\", new String(b));\n                } catch (NoNodeException e) {\n                        if (j + 1 == maxTries) {\n                            Assert.fail(\"Max tries exceeded on client \" + i);\n                        }\n                        Thread.sleep(1000);\n                    }\n\n            }\n        }\n\n        // Kill half the servers, make a change, restart the dead\n        // servers, and then bounce the other servers one by one\n        for (int i = 0; i < getServerCount(); i++) {\n            stopServer(i);\n\n            if (i + 1 > getServerCount() / 2) {\n                startServer(i);\n            } else if (i + 1 == getServerCount() / 2) {\n                Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                try {\n                    zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                } catch (ConnectionLossException e) {\n                        Assert.assertTrue(\"Connection didn't recover\", waitForConnect(zk, 10000));\n                        zk.setData(\"/simpleCase\", \"new\".getBytes(), -1);\n                    }\n\n                for (int j = 0; j < i; j++) {\n                    LOG.info(\"Starting server \" + j);\n                    startServer(i);\n                }\n            }\n\n        }\n        Thread.sleep(100); // wait for things to stabilize\n\n        Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n        try {\n            zk.getData(\"/simpleCase\", false, stat);\n        } catch (ConnectionLossException e) {\n                Assert.assertTrue(\"Servers didn't bounce\", waitForConnect(zk, 15000));\n            }\n\n\n        // check that the change has propagated to everyone\n        for (int i = 0; i < getClientCount(); i++) {\n            for (int j = 0; j < maxTries; j++) {\n                byte[] data = zk.getData(\"/simpleCase/\" + i, false, stat);\n\n                if (new String(data).equals(\"new\")) {\n                    break;\n                }\n                if (j + 1 == maxTries) {\n                    Assert.fail(\"max tries exceeded for \" + i);\n                }\n                Thread.sleep(1000);\n            }\n        }\n\n        // send out the kill signal\n        zk.setData(\"/simpleCase\", \"die\".getBytes(), -1);\n\n        // watch for everyone to die\n        for (int i = 0; i < getClientCount(); i++) {\n            try {\n                for (int j = 0; j < maxTries; j++) {\n                    zk.getData(\"/simpleCase/\" + i, false, stat);\n\n                    if (j + 1 == maxTries) {\n                        Assert.fail(\"max tries exceeded waiting for child \" + i + \" to die\");\n                    }\n                    Thread.sleep(200);\n                }\n            } catch (NoNodeException e) {\n                // Great this is what we were hoping for!\n                }\n\n        }\n\n        stopClients();\n        stopServers();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "221", "src_id": "M211", "code": "    public static void main(String[] args) throws IOException {\n        RandomAccessFileReader f = new RandomAccessFileReader(new File(args[0]));\n        long pos0 = f.getPosition();\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        System.out.println(\"=============\");\n        long pos1 = f.getPosition();\n\n        System.out.println(\"pos: \" + pos1);\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        System.out.println(\"=============\");\n        f.seek(pos1);\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        System.out.println(\"=============\");\n        f.seek(pos0);\n\n        for (int i = 0; i < 5; i++) {\n            System.out.println(f.readLine());\n        }\n\n        long pos2 = f.getPosition();\n\n        System.out.println(\"=============\");\n        System.out.println(f.readLine());\n        f.seek(pos2);\n        System.out.println(f.readLine());\n        f.close();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "65", "src_id": "M1199", "code": "    private void initializeSlotsCache(Set<HostAndPort> startNodes, JedisClientConfig clientConfig) {\n        if (startNodes.isEmpty()) {\n            throw new JedisClusterOperationException(\"No nodes to initialize cluster slots cache.\");\n        }\n\n        ArrayList<HostAndPort> startNodeList = new ArrayList<>(startNodes);\n\n        Collections.shuffle(startNodeList);\n\n        JedisException firstException = null;\n        for (HostAndPort hostAndPort:startNodeList) {\n            try (Connection jedis = new Connection(hostAndPort, clientConfig)) {\n                cache.discoverClusterNodesAndSlots(jedis);\n                return;\n            } catch (JedisException e) {\n                    if (firstException == null) {\n                        firstException = e;\n                    }\n                // try next nodes\n                }\n\n        }\n\n        if (System.getProperty(INIT_NO_ERROR_PROPERTY) != null) {\n            return;\n        }\n\n        JedisClusterOperationException uninitializedException = new JedisClusterOperationException(\"Could not initialize cluster slots cache.\");\n\n        uninitializedException.addSuppressed(firstException);\n        throw uninitializedException;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "66", "src_id": "M1275", "code": "    @Override\n    public Document build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        String id = null;\n        Double score = null;\n        Map<String, Object> fields = null;\n        for (KeyValue kv:list) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n\n            switch (key) {\n                case ID_STR:\n                    id = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case SCORE_STR:\n                    score = BuilderFactory.DOUBLE.build(kv.getValue());\n                    break;\n                case FIELDS_STR:\n                    fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                    break;\n            }\n        }\n\n        return new Document(id, score, fields);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "67", "src_id": "M933", "code": "    @Deprecated\n    public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n        Builder builder = builder();\n\n        builder.protocol(copy.getRedisProtocol());\n        builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n        builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n        builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n        Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n\n        if (credentialsProvider != null) {\n            builder.credentialsProvider(credentialsProvider);\n        } else {\n            builder.user(copy.getUser());\n            builder.password(copy.getPassword());\n        }\n        builder.database(copy.getDatabase());\n        builder.clientName(copy.getClientName());\n        builder.ssl(copy.isSsl());\n        builder.sslSocketFactory(copy.getSslSocketFactory());\n        builder.sslParameters(copy.getSslParameters());\n        builder.hostnameVerifier(copy.getHostnameVerifier());\n        builder.sslOptions(copy.getSslOptions());\n        builder.hostAndPortMapper(copy.getHostAndPortMapper());\n        builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n\n        if (copy.isReadOnlyForRedisClusterReplicas()) {\n            builder.readOnlyForRedisClusterReplicas();\n        }\n        builder.authXManager(copy.getAuthXManager());\n        return builder.build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "68", "src_id": "M1159", "code": "    @Override\n    public LibraryInfo build(Object data) {\n        if (data == null) return null;\n\n        List list = (List) data;\n\n        if (list.isEmpty()) return null;\n\n        if (list.get(0) instanceof KeyValue) {\n            String libname = null;\n            String enginename = null;\n            String librarycode = null;\n            List<Map<String, Object>> functions = null;\n\n            for (KeyValue kv:(List<KeyValue>) list) {\n                switch (BuilderFactory.STRING.build(kv.getKey())) {\n                    case \"library_name\":\n                        libname = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"engine\":\n                        enginename = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"functions\":\n                        functions = ((List<Object>) kv.getValue()).stream().map(o -> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n                        break;\n                    case \"library_code\":\n                        librarycode = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                }\n            }\n            return new LibraryInfo(libname, enginename, functions, librarycode);\n        }\n\n        String libname = STRING.build(list.get(1));\n        String engine = STRING.build(list.get(3));\n        List<Object> rawFunctions = (List<Object>) list.get(5);\n        List<Map<String, Object>> functions = rawFunctions.stream().map(o -> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n\n        if (list.size() <= 6) {\n            return new LibraryInfo(libname, engine, functions);\n        }\n\n        String code = STRING.build(list.get(7));\n\n        return new LibraryInfo(libname, engine, functions, code);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1219", "code": "    @Override\n    public void run() {\n        running.set(true);\n\n        while (running.get()) {\n            try {\n                // double check that it is not being shutdown\n                if (!running.get()) {\n                    break;\n                }\n                sentinelJedis = new Jedis(node, sentinelClientConfig);\n\n                // code for active refresh\n                List<String> masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n\n                if (masterAddr == null || masterAddr.size() != 2) {\n                    LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n                } else {\n                    initMaster(toHostAndPort(masterAddr));\n                }\n                sentinelJedis.subscribe(new JedisPubSub() {@Override public void onMessage(String channel, String message) {LOG\n                        .debug(\"Sentinel {} published: {}.\", node, message)\n                        ; String[] switchMasterMsg = message.split(\" \");if (switchMasterMsg\n                            .length \n                            > 3\n                            ) {if (masterName.equals(switchMasterMsg[0])) {initMaster(toHostAndPort(switchMasterMsg\n                                [3], \n                                switchMasterMsg[4]))\n                                ;} else {LOG.debug(\"Ignoring message on +switch-master for master {}. Our master is {}.\",\n                                switchMasterMsg[0], masterName)\n                                ;}} else {LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\",\n                            node, message)\n                            ;}}}, \n                \"+switch-master\");\n            } catch (JedisException e) {\n                    if (running.get()) {\n                        LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node, subscribeRetryWaitTimeMillis, e);\n                        try {\n                            Thread.sleep(subscribeRetryWaitTimeMillis);\n                        } catch (InterruptedException se) {\n                                LOG.error(\"Sleep interrupted.\", se);\n                            }\n\n                    } else {\n                        LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n                    }\n                } finally {\n                    IOUtils.closeQuietly(sentinelJedis);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "70", "src_id": "M126", "code": "    @Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        }\n        if (!(o instanceof CommandObject)) {\n            return false;\n        }\n\n        Iterator<Rawable> e1 = arguments.iterator();\n        Iterator<Rawable> e2 = ((CommandObject) o).arguments.iterator();\n        while (e1.hasNext() && e2.hasNext()) {\n            Rawable o1 = e1.next();\n            Rawable o2 = e2.next();\n\n            if (!(o1 == null ? o2 == null:o1.equals(o2))) {\n                return false;\n            }\n        }\n\n        if (e1.hasNext() || e2.hasNext()) {\n            return false;\n        }\n        return builder == ((CommandObject) o).builder;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "71", "src_id": "M44", "code": "    @Override\n    public String discard() {\n        if (!inMulti) {\n            throw new IllegalStateException(\"DISCARD without MULTI\");\n        }\n\n        try {\n            // processPipelinedResponses(pipelinedResponses.size());\n            // do nothing\n            connection.sendCommand(DISCARD);\n\n            String status = connection.getStatusCodeReply();\n\n            if (!\"OK\".equals(status)) {\n                throw new JedisException(\"DISCARD command failed. Received response: \" + status);\n            }\n            return status;\n        } catch (JedisConnectionException jce) {\n                broken = true;\n                throw jce;\n            } finally {\n                inMulti = false;\n                inWatch = false;\n                pipelinedResponses.clear();\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool:pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n\n                if (jedis == null) {\n                    continue;\n                }\n                jedis.ping();\n                return jedis;\n            } catch (JedisException ex) {\n                    if (suppressed == null) { // remembering first suppressed exception\n\n                        suppressed = ex;\n                    }\n                    if (jedis != null) {\n                        jedis.close();\n                    }\n                }\n\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "73", "src_id": "M934", "code": "    private Socket createSslSocket(HostAndPort _hostAndPort, Socket socket) throws IOException, GeneralSecurityException {\n        Socket plainSocket = socket;\n        SSLSocketFactory _sslSocketFactory;\n        SSLParameters _sslParameters;\n\n        if (sslOptions != null) {\n            SSLContext _sslContext = sslOptions.createSslContext();\n\n            _sslSocketFactory = _sslContext.getSocketFactory();\n            _sslParameters = sslOptions.getSslParameters();\n        } else {\n            _sslSocketFactory = this.sslSocketFactory;\n            _sslParameters = this.sslParameters;\n        }\n\n        if (_sslSocketFactory == null) {\n            _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n\n        SSLSocket sslSocket = (SSLSocket) _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n\n        if (_sslParameters != null) {\n            sslSocket.setSSLParameters(_sslParameters);\n        }\n\n        // allowing HostnameVerifier for both SslOptions and legacy ssl config\n        if (hostnameVerifier != null && !hostnameVerifier.verify(_hostAndPort.getHost(), sslSocket.getSession())) {\n            String message = String.format(\"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n\n            throw new JedisConnectionException(message);\n        }\n        return new SSLSocketWrapper(sslSocket, plainSocket);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "74", "src_id": "M1216", "code": "    private void initMaster(HostAndPort master) {\n        initPoolLock.lock();\n\n        try {\n            if (!master.equals(currentMaster)) {\n                currentMaster = master;\n\n                ConnectionPool newPool = createNodePool(currentMaster);\n                ConnectionPool existingPool = pool;\n\n                pool = newPool;\n                LOG.info(\"Created connection pool to master at {}.\", master);\n\n                if (clientSideCache != null) {\n                    clientSideCache.flush();\n                }\n                if (existingPool != null) {\n                    // although we clear the pool, we still have to check the returned object in getResource,\n                    // this call only clears idle instances, not borrowed instances\n                    // existingPool.clear(); // necessary??\n                    existingPool.close();\n                }\n            }\n        } finally {\n                initPoolLock.unlock();\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "273", "src_id": "M1036", "code": "  public void start() {\n    if (running || isFinished()) {\n      return;\n    }\n\n    // ensure that the previous state is completely paused.\n    if (urls.length < 1) {\n    return;\n    }\n    // ensure that the previous state is completely paused.\n    joinForThreads(10000);\n    running = true;\n    errCode = ERROR_NOTHING;\n    if (hasInvalidStorage()) {\n      notifyError(ERROR_FILE_CREATION, null);\n      return;\n    }\n\n    if (current >= urls.length) {\n      notifyFinished();\n      return;\n    }\n    notify(DownloadManagerService.MESSAGE_RUNNING);\n    if (urls[current] == null) {\n      doRecover(ERROR_RESOURCE_GONE);\n      return;\n    }\n\n    if (blocks == null) {\n      initializer();\n      return;\n    }\n    init = null;\n    finishCount = 0;\n    blockAcquired = new boolean[blocks.length];\n    if (blocks.length < 1) {\n      threads = new Thread[]{runAsync(1, new DownloadRunnableFallback(this))};\n\n    } else {\n      int remainingBlocks = 0;\n      for (int block : blocks) {\n        if (block >= 0) {\n          remainingBlocks++;\n        }\n      }\n\n      if (remainingBlocks < 1) {\n        notifyFinished();\n        return;\n      }\n      threads = new Thread[Math.min(threadCount, remainingBlocks)];\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = runAsync(i + 1, new DownloadRunnable(this, i));\n\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "274", "src_id": "M803", "code": "  public void parse() throws IOException, NoSuchElementException {\n    if (selectedTrack > -1) {\n      return;\n    }\n    box = readBox(ATOM_FTYP);\n    brands = parseFtyp(box);\n    switch (brands[0]) {\n      case BRAND_DASH:\n      case BRAND_ISO5:// Â¿why not?\n\n        break;\n      default:\n        throw new NoSuchElementException(\"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \" + boxName(brands[0]));\n    }\n\n    Moov moov = null;\n    int i;\n    while (box.type != ATOM_MOOF) {\n      ensure(box);\n      box = readBox();\n      switch (box.type) {\n        case ATOM_MOOV:\n          moov = parseMoov(box);\n          break;\n        case ATOM_SIDX:\n        case ATOM_MFRA:\n          break;\n      }\n    }\n\n    if (moov == null) {\n      throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n\n    }\n    tracks = new Mp4Track[moov.trak.length];\n\n    for (i = 0; i < tracks.length; i++) {\n      tracks[i] = new Mp4Track();\n      tracks[i].trak = moov.trak[i];\n      if (moov.mvexTrex != null) {\n        for (final Trex mvexTrex : moov.mvexTrex) {\n          if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n            tracks[i].trex = mvexTrex;\n          }\n        }\n      }\n\n      switch (moov.trak[i].mdia.hdlr.subType) {\n        case HANDLER_VIDE:\n          tracks[i].kind = TrackKind.Video;\n          break;\n        case HANDLER_SOUN:\n          tracks[i].kind = TrackKind.Audio;\n          break;\n        case HANDLER_SUBT:\n          tracks[i].kind = TrackKind.Subtitles;\n          break;\n        default:\n          tracks[i].kind = TrackKind.Other;\n          break;\n      }\n    }\n\n    backupBox = box;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "275", "src_id": "M1031", "code": "  void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n    int statusCode = conn.getResponseCode();\n\n    if (DEBUG) {\n      Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n      Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n      Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n      Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n\n    }\n\n    switch (statusCode) {\n      case 204:\n      case 205:\n      case 207:\n        throw new HttpError(statusCode);\n      case 416:\n        return; // let the download thread handle this error\n\n      default:\n        if (statusCode < 200) {\n          throw new HttpError(statusCode);\n        }\n\n        if (statusCode > 299) {\n        throw new HttpError(statusCode);\n          }\n\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "276", "src_id": "M827", "code": "  private Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n    if (b == null) {\n      return null;\n    }\n    final Elst obj = new Elst();\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n      obj.bMediaRate = 0x00010000; // default media rate (1.0)\n\n      return obj;\n    }\n\n    if (v1) {\n      stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n\n      obj.mediaTime = stream.readLong();\n      // ignore all remain entries\n      stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n\n    } else {\n      stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n\n      obj.mediaTime = stream.readInt();\n    }\n\n    obj.bMediaRate = stream.readInt();\n    return obj;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "277", "src_id": "M1144", "code": "  @Override\n  public void write(byte[] b, int off, int len) throws IOException {\n    if (len == 0) {\n      return;\n    }\n    long available;\n    long offsetOut = out.getOffset();\n    long offsetAux = aux.getOffset();\n    long end = callback.check();\n    if (end == -1) {\n      available = Integer.MAX_VALUE;\n    } else if (end < offsetOut) {\n      throw new IOException(\"The reported offset is invalid: \" + end + \"<\" + offsetOut);\n\n    } else {\n      available = end - offsetOut;\n    }\n\n\n    boolean usingAux = aux.length > 0 && offsetOut >= out.length;\n    boolean underflow = offsetAux < aux.length || offsetOut < out.length;\n\n    if (usingAux) {\n      // before continue calculate the final length of aux\n      long length = offsetAux + len;\n      if (underflow) {\n        if (aux.length > length) {\n          length = aux.length; // the length is not changed\n\n        }\n      } else {\n        length = aux.length + len;\n      }\n      aux.write(b, off, len);\n      if (length >= THRESHOLD_AUX_LENGTH && length <= available) {\n        flushAuxiliar(available);\n      }\n    } else {\n      if (underflow) {\n        available = out.length - offsetOut;\n      }\n      int length = Math.min(len, (int) Math.min(Integer.MAX_VALUE, available));\n      out.write(b, off, length);\n      len -= length;\n      off += length;\n      if (len > 0) {\n        aux.write(b, off, len);\n      }\n    }\n\n    if (onProgress != null) {\n      long absoluteOffset = out.getOffset() + aux.getOffset();\n      if (absoluteOffset > reportPosition) {\n        reportPosition = absoluteOffset + NOTIFY_BYTES_INTERVAL;\n        onProgress.report(absoluteOffset);\n      }\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "278", "src_id": "M1048", "code": "  @Override\n  public void run() {\n    boolean done;\n    long start = mMission.fallbackResumeOffset;\n    if (DEBUG && !mMission.unknownLength && start > 0) {\n      Log.i(TAG, \"Resuming a single-thread download at \" + start);\n\n    }\n\n    try {\n      long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n      int mId = 1;\n      mConn = mMission.openConnection(false, rangeStart, -1);\n      if (mRetryCount == 0 && rangeStart == -1) {\n        // workaround: bypass android connection pool\n        mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n\n      }\n      mMission.establishConnection(mId, mConn);\n      // check if the download can be resumed\n      if (mConn.getResponseCode() == 416 && start > 0) {\n        mMission.notifyProgress(-start);\n        start = 0;\n        mRetryCount--;\n        throw new DownloadMission.HttpError(416);\n\n      }\n\n      // secondary check for the file length\n      if (!mMission.unknownLength) {\n\n        mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n      }\n\n      if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n        // restart amount of bytes downloaded\n        mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n\n      }\n      mF = mMission.storage.getStream();\n      mF.seek(mMission.offsets[mMission.current] + start);\n      mIs = mConn.getInputStream();\n      byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n      int len = 0;\n      while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n        mF.write(buf, 0, len);\n        start += len;\n        mMission.notifyProgress(len);\n      }\n\n      dispose();\n      // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n      done = len == -1;\n    } catch (Exception e) {\n        dispose();\n        mMission.fallbackResumeOffset = start;\n        if (!mMission.running) {\n          return;\n        }\n\n        if (e instanceof ClosedByInterruptException) {\n        return;\n        }\n\n        if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n          // for youtube streams. The url has expired, recover\n          dispose();\n          mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n          return;\n        }\n\n        if (mRetryCount++ >= mMission.maxRetry) {\n          mMission.notifyError(e);\n          return;\n        }\n\n        if (DEBUG) {\n          Log.e(TAG, \"got exception, retrying...\", e);\n\n        }\n        run(); // try again\n\n        return;\n      }\n\n    if (done) {\n      mMission.notifyFinished();\n    } else {\n      mMission.fallbackResumeOffset = start;\n\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "279", "src_id": "M1086", "code": "  private ArrayList<Object> getSpecialItems() {\n    synchronized (DownloadManager.this) {\n      ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n      ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n      List<Mission> remove = new ArrayList<>(hidden);\n      // hide missions (if required)\n      remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n      int fakeTotal = pending.size();\n      if (fakeTotal > 0) {\n        fakeTotal++;\n      }\n      fakeTotal += finished.size();\n      if (finished.size() > 0) {\n        fakeTotal++;\n      }\n      ArrayList<Object> list = new ArrayList<>(fakeTotal);\n      if (pending.size() > 0) {\n        list.add(PENDING);\n        list.addAll(pending);\n      }\n\n      if (finished.size() > 0) {\n        list.add(FINISHED);\n        list.addAll(finished);\n      }\n      hasFinished = finished.size() > 0;\n      return list;\n    }\n\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "280", "src_id": "M1067", "code": "  void startMission(DownloadMission mission) {\n    synchronized (this) {\n      mission.timestamp = System.currentTimeMillis();\n      mission.mHandler = mHandler;\n      mission.maxRetry = mPrefMaxRetry;\n\n      // create metadata file\n      while (true) {\n        mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n        if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n          try {\n            if (!mission.metadata.createNewFile()) {\n\n              throw new RuntimeException(\"Cant create download metadata file\");\n            }\n          } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n\n          break;\n        }\n\n        mission.timestamp = System.currentTimeMillis();\n\n      }\n\n      mSelfMissionsControl = true;\n      mMissionsPending.add(mission);\n      // Before continue, save the metadata in case the internet connection is not available\n      Utility.writeToFile(mission.metadata, mission);\n      if (mission.storage == null) {\n        // noting to do here\n        mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n        if (mission.errObject != null) {\n\n          mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n        }\n        return;\n      }\n\n      boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n      if (canDownloadInCurrentNetwork() && start) {\n        mission.start();\n      }\n    }\n\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "281", "src_id": "M1117", "code": "  private void showPopupMenu() {\n    retry.setVisible(false);\n    cancel.setVisible(false);\n    start.setVisible(false);\n    pause.setVisible(false);\n    open.setVisible(false);\n    queue.setVisible(false);\n    showError.setVisible(false);\n    delete.setVisible(false);\n    source.setVisible(false);\n    checksum.setVisible(false);\n    DownloadMission mission = item.mission instanceof DownloadMission ? (DownloadMission) item.mission : null;\n\n    if (mission != null) {\n      if (mission.hasInvalidStorage()) {\n        retry.setVisible(true);\n        delete.setVisible(true);\n        showError.setVisible(true);\n      } else if (mission.isPsRunning()) {\n        switch (mission.errCode) {\n          case ERROR_INSUFFICIENT_STORAGE:\n          case ERROR_POSTPROCESSING_HOLD:\n            retry.setVisible(true);\n            cancel.setVisible(true);\n            showError.setVisible(true);\n            break;\n        }\n      } else {\n        if (mission.running) {\n          pause.setVisible(true);\n        } else {\n          if (mission.errCode != ERROR_NOTHING) {\n            showError.setVisible(true);\n          }\n          queue.setChecked(mission.enqueued);\n          delete.setVisible(true);\n          boolean flag = !mission.isPsFailed() && mission.urls.length > 0;\n          start.setVisible(flag);\n          queue.setVisible(flag);\n        }\n      }\n\n    } else {\n      open.setVisible(true);\n      delete.setVisible(true);\n      checksum.setVisible(true);\n    }\n\n    if (item.mission.source != null && !item.mission.source.isEmpty()) {\n      source.setVisible(true);\n    }\n    popupMenu.show();\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "385", "src_id": "M267", "code": "    void drainLoop() {\n        int missed = 1;\n        Observer<? super R> a = downstream;\n        AtomicInteger n = active;\n        AtomicReference<SpscLinkedArrayQueue<R>> qr = queue;\n        for (;; ) {\n            for (;; ) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n                if (!delayErrors) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                }\n                boolean d = n.get() == 0;\n                SpscLinkedArrayQueue<R> q = qr.get();\n                R v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n            }\n\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "386", "src_id": "M1358", "code": "    @Override\n    public void onNext(T t) {\n        if (done) {\n            return;\n        }\n        boolean b;\n        try {\n            b = predicate.test(t);\n        } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                upstream.cancel();\n                upstream = SubscriptionHelper.CANCELLED;\n                onError(e);\n                return;\n            }\n\n        if (b) {\n            done = true;\n            upstream.cancel();\n            upstream = SubscriptionHelper.CANCELLED;\n            downstream.onSuccess(true);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "387", "src_id": "M683", "code": "    @SuppressWarnings(\"unchecked\") void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        AtomicReference<Object> c = current;\n        Subscriber<? super T> a = downstream;\n        Disposable cancelled = disposables;\n        for (;; ) {\n            if (cancelled.isDisposed()) {\n                c.lazySet(null);\n                return;\n            }\n            Object o = c.get();\n            if (o != null) {\n                boolean goNextSource;\n                if (o != NotificationLite.COMPLETE) {\n                    long p = produced;\n                    if (p != requested.get()) {\n                        produced = p + 1;\n                        c.lazySet(null);\n                        goNextSource = true;\n                        a.onNext((T) o);\n                    } else {\n                        goNextSource = false;\n                    }\n                } else {\n                    goNextSource = true;\n                    c.lazySet(null);\n                }\n\n                if (goNextSource && !cancelled.isDisposed()) {\n                    int i = index;\n                    if (i == sources.length) {\n                        a.onComplete();\n                        return;\n                    }\n                    index = i + 1;\n                    sources[i].subscribe(this);\n                }\n            }\n\n            if (decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "388", "src_id": "M1509", "code": "    @Override void runAsync() {\n        int missed = 1;\n        final Subscriber<? super T> a = downstream;\n        final SimpleQueue<T> q = queue;\n        long e = produced;\n        for (;; ) {\n            long r = requested.get();\n            while (e != r) {\n                boolean d = done;\n                T v;\n                try {\n                    v = q.poll();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        cancelled = true;\n                        upstream.cancel();\n                        q.clear();\n                        a.onError(ex);\n                        worker.dispose();\n                        return;\n                    }\n\n\n                boolean empty = v == null;\n                if (checkTerminated(d, empty, a)) {\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n                e++;\n\n                if (e == limit) {\n                    if (r != Long.MAX_VALUE) {\n                        r = requested.addAndGet(-e);\n                    }\n                    upstream.request(e);\n                    e = 0L;\n                }\n            }\n\n            if (e == r && checkTerminated(done, q.isEmpty(), a)) {\n                return;\n            }\n            int w = get();\n            if (missed == w) {\n                produced = e;\n                missed = addAndGet(-missed);\n\n                if (missed == 0) {\n                    break;\n                }\n            } else {\n                missed = w;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "389", "src_id": "M889", "code": "    void drainLoop() {\n        int missed = 1;\n        JoinInnerSubscriber<T>[] s = this.subscribers;\n        int n = s.length;\n        Subscriber<? super T> a = this.downstream;\n        for (;; ) {\n            long r = requested.get();\n            long e = 0;\n\n            middle:\n            while (e != r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimplePlainQueue<T> q = inner.queue;\n                    if (q != null) {\n                        T v = q.poll();\n                        if (v != null) {\n                            empty = false;\n                            a.onNext(v);\n                            inner.requestOne();\n\n                            if (++e == r) {\n                                break middle;\n                            }\n                        }\n                    }\n                }\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n            }\n\n\n            if (e == r) {\n                if (cancelled) {\n                    cleanup();\n                    return;\n                }\n                boolean d = done.get() == 0;\n                boolean empty = true;\n                for (int i = 0; i < n; i++) {\n                    JoinInnerSubscriber<T> inner = s[i];\n                    SimpleQueue<T> q = inner.queue;\n                    if (q != null && !q.isEmpty()) {\n                        empty = false;\n                        break;\n                    }\n                }\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n            }\n\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "390", "src_id": "M1127", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        AtomicReference<T> latest = this.latest;\n        AtomicLong requested = this.requested;\n        Subscriber<? super T> downstream = this.downstream;\n        for (;; ) {\n            for (;; ) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n                boolean d = done;\n                Throwable error = this.error;\n                if (d && error != null) {\n                    if (onDropped != null) {\n                        T v = latest.getAndSet(null);\n                        if (v != null) {\n                            try {\n                                onDropped.accept(v);\n                            } catch (Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    error = new CompositeException(error, ex);\n                                }\n\n                        }\n                    } else {\n                        latest.lazySet(null);\n                    }\n\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                T v = latest.get();\n                boolean empty = v == null;\n                if (d) {\n                    if (!empty) {\n                        v = latest.getAndSet(null);\n\n                        if (emitLast) {\n                            long e = emitted;\n                            if (e != requested.get()) {\n                                emitted = e + 1;\n                                downstream.onNext(v);\n                                downstream.onComplete();\n                            } else {\n                                tryDropAndSignalMBE(v);\n                            }\n                        } else {\n                            if (onDropped != null) {\n                                try {\n                                    onDropped.accept(v);\n                                } catch (Throwable ex) {\n                                        Exceptions.throwIfFatal(ex);\n                                        downstream.onError(ex);\n                                        worker.dispose();\n                                        return;\n                                    }\n\n                            }\n                            downstream.onComplete();\n                        }\n                    } else {\n                        downstream.onComplete();\n                    }\n\n                    worker.dispose();\n                    return;\n                }\n\n                if (empty) {\n                    if (timerFired) {\n                        timerRunning = false;\n                        timerFired = false;\n                    }\n                    break;\n                }\n\n                if (!timerRunning || timerFired) {\n                    v = latest.getAndSet(null);\n                    long e = emitted;\n                    if (e != requested.get()) {\n                        downstream.onNext(v);\n                        emitted = e + 1;\n                    } else {\n                        upstream.cancel();\n                        tryDropAndSignalMBE(v);\n                        worker.dispose();\n                        return;\n                    }\n                    timerFired = false;\n                    timerRunning = true;\n                    worker.schedule(this, timeout, unit);\n                } else {\n                    break;\n                }\n            }\n\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "391", "src_id": "M1003", "code": "    void drain() {\n        if (wip.getAndIncrement() != 0) {\n            return;\n        }\n        int missed = 1;\n        SimpleQueue<T> q = queue;\n        int upstreamConsumed = consumed;\n        int localLimit = limit;\n        boolean canRequest = sourceMode != QueueSubscription.SYNC;\n\n        AtomicReference<MulticastSubscription<T>[]> subs = subscribers;\n\n        MulticastSubscription<T>[] array = subs.get();\n\n        outer:\n        for (;; ) {\n            int n = array.length;\n            if (q != null && n != 0) {\n                long r = Long.MAX_VALUE;\n                for (MulticastSubscription<T> ms : array) {\n                    long u = ms.get() - ms.emitted;\n                    if (u != Long.MIN_VALUE) {\n                        if (r > u) {\n                            r = u;\n                        }\n                    } else {\n                        n--;\n                    }\n                }\n\n                if (n == 0) {\n                    r = 0;\n                }\n\n                while (r != 0) {\n                    if (isDisposed()) {\n                        q.clear();\n                        return;\n                    }\n                    boolean d = done;\n                    if (d && !delayError) {\n                        Throwable ex = error;\n                        if (ex != null) {\n                            errorAll(ex);\n                            return;\n                        }\n                    }\n                    T v;\n                    try {\n                        v = q.poll();\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n                            SubscriptionHelper.cancel(upstream);\n                            errorAll(ex);\n                            return;\n                        }\n\n\n                    boolean empty = v == null;\n                    if (d && empty) {\n                        Throwable ex = error;\n                        if (ex != null) {\n                            errorAll(ex);\n                        } else {\n                            completeAll();\n                        }\n                        return;\n                    }\n                    if (empty) {\n                        break;\n                    }\n                    boolean subscribersChange = false;\n                    for (MulticastSubscription<T> ms : array) {\n                        long msr = ms.get();\n                        if (msr != Long.MIN_VALUE) {\n                            if (msr != Long.MAX_VALUE) {\n                                ms.emitted++;\n                            }\n                            ms.downstream.onNext(v);\n                        } else {\n                            subscribersChange = true;\n                        }\n                    }\n\n                    r--;\n\n                    if (canRequest && ++upstreamConsumed == localLimit) {\n                        upstreamConsumed = 0;\n                        upstream.get().request(localLimit);\n                    }\n                    MulticastSubscription<T>[] freshArray = subs.get();\n                    if (subscribersChange || freshArray != array) {\n                        array = freshArray;\n                        continue outer;\n                    }\n                }\n\n                if (r == 0) {\n                    if (isDisposed()) {\n                        q.clear();\n                        return;\n                    }\n                    boolean d = done;\n                    if (d && !delayError) {\n                        Throwable ex = error;\n                        if (ex != null) {\n                            errorAll(ex);\n                            return;\n                        }\n                    }\n                    if (d && q.isEmpty()) {\n                        Throwable ex = error;\n                        if (ex != null) {\n                            errorAll(ex);\n                        } else {\n                            completeAll();\n                        }\n                        return;\n                    }\n                }\n            }\n\n            consumed = upstreamConsumed;\n            missed = wip.addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n            if (q == null) {\n                q = queue;\n            }\n            array = subs.get();\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "392", "src_id": "M485", "code": "    @SuppressWarnings(\"unchecked\") void subscribeInner(ObservableSource<? extends U> p) {\n        for (;; ) {\n            if (p instanceof Supplier) {\n                if (tryEmitScalar(((Supplier<? extends U>) p)) && maxConcurrency != Integer.MAX_VALUE) {\n                    boolean empty = false;\n                    synchronized (this) {\n                        p = sources.poll();\n\n                        if (p == null) {\n                            wip--;\n                            empty = true;\n                        }\n                    }\n\n                    if (empty) {\n                        drain();\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            } else {\n                InnerObserver<T, U> inner = new InnerObserver<>(this, uniqueId++);\n                if (addInner(inner)) {\n                    p.subscribe(inner);\n                }\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "393", "src_id": "M2312", "code": "    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    @BackpressureSupport(BackpressureKind.SPECIAL)\n    @CheckReturnValue\n    public static <@NonNull T> Flowable<T> fromObservable(@NonNull ObservableSource<T> source, @NonNull BackpressureStrategy strategy) {\n        Objects.requireNonNull(source, \"source is null\");\n        Objects.requireNonNull(strategy, \"strategy is null\");\n\n        Flowable<T> f = new FlowableFromObservable<>(source);\n        switch (strategy) {\n            case DROP:\n                return f.onBackpressureDrop();\n            case LATEST:\n                return f.onBackpressureLatest();\n            case MISSING:\n                return f;\n            case ERROR:\n                return RxJavaPlugins.onAssembly(new FlowableOnBackpressureError<>(f));\n            default:\n                return f.onBackpressureBuffer();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "394", "src_id": "M368", "code": "    public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? super T> observer) {\n        final BlockingQueue<Object> queue = new LinkedBlockingQueue<>();\n\n        BlockingObserver<T> bs = new BlockingObserver<>(queue);\n        observer.onSubscribe(bs);\n        o.subscribe(bs);\n        for (;; ) {\n            if (bs.isDisposed()) {\n                break;\n            }\n            Object v = queue.poll();\n            if (v == null) {\n                try {\n                    v = queue.take();\n                } catch (InterruptedException ex) {\n                        bs.dispose();\n                        observer.onError(ex);\n                        return;\n                    }\n\n            }\n            if (bs.isDisposed() || v == BlockingObserver.TERMINATED || NotificationLite.acceptFull(v, observer)) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "170", "src_id": "M478", "code": "        private void saveDocumentToZip(PDDocument document, ZipOutputStream zipOut, String baseFilename, int index)throws IOException {\n            log.debug(\"Starting saveDocumentToZip for document part {}\", index);\n\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n\n            try {\n                log.debug(\"Saving document part {} to byte array\", index);\n                document.save(outStream);\n                log.debug(\"Successfully saved document part {} ({} bytes)\", index, outStream.size());\n            } catch (Exception e) {\n                    log.error(\"Error saving document part {} to byte array\", index, e);\n                    throw ExceptionUtils.createFileProcessingException(\"split\", e);\n                }\n\n\n            try {\n                log.debug(\"Closing document part {}\", index);\n                document.close();\n                log.debug(\"Successfully closed document part {}\", index);\n            } catch (Exception e) {\n                    log.error(\"Error closing document part {}\", index, e);\n                // Continue despite close error\n                }\n\n\n            try {\n                // Create a new zip entry\n                String entryName = baseFilename + \"_\" + index + \".pdf\";\n\n                log.debug(\"Creating ZIP entry: {}\", entryName);\n\n                ZipEntry zipEntry = new ZipEntry(entryName);\n\n                zipOut.putNextEntry(zipEntry);\n\n                byte[] bytes = outStream.toByteArray();\n\n                log.debug(\"Writing {} bytes to ZIP entry\", bytes.length);\n                zipOut.write(bytes);\n                log.debug(\"Closing ZIP entry\");\n                zipOut.closeEntry();\n                log.debug(\"Successfully added document part {} to ZIP\", index);\n            } catch (Exception e) {\n                    log.error(\"Error adding document part {} to ZIP\", index, e);\n                    throw ExceptionUtils.createFileProcessingException(\"split\", e);\n                }\n\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "171", "src_id": "M101", "code": "        private void processRequest(int limitPerDay,\n        String identifier, Map<String, Bucket> buckets,\n        HttpServletRequest request, HttpServletResponse response,\n        FilterChain filterChain)throws IOException, ServletException {\n            Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n            ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n\n            if (probe.isConsumed()) {\n                response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n                filterChain.doFilter(request, response);\n            } else {\n                long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n\n                response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n                response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n                response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "172", "src_id": "M38", "code": "        @SuppressWarnings(\"deprecation\")\n        public void migrateEnterpriseSettingsToPremium(ApplicationProperties applicationProperties) {\n            EnterpriseEdition enterpriseEdition = applicationProperties.getEnterpriseEdition();\n            Premium premium = applicationProperties.getPremium();\n            // Only proceed if both objects exist\n            if (enterpriseEdition == null || premium == null) {\n                return;\n            }\n\n            // Copy the license key if it's set in enterprise but not in premium\n            if ((premium.getKey() == null || \"00000000-0000-0000-0000-000000000000\"\n                .equals(premium.getKey())\n                )\n                 && (enterpriseEdition.getKey() \n                 != null\n                 && !\"00000000-0000-0000-0000-000000000000\"\n                .equals(enterpriseEdition.getKey())\n                )) {\n                premium.setKey(enterpriseEdition.getKey());\n            }\n\n            if (!premium.isEnabled() && enterpriseEdition.isEnabled()) {\n                premium.setEnabled(true);\n            }\n\n            // Copy SSO auto login setting\n            if (!premium.getProFeatures().isSsoAutoLogin() && enterpriseEdition.isSsoAutoLogin()) {\n                premium.getProFeatures().setSsoAutoLogin(true);\n            }\n\n            // Copy CustomMetadata settings\n            Premium.ProFeatures.CustomMetadata premiumMetadata = premium.getProFeatures().getCustomMetadata();\n            EnterpriseEdition.CustomMetadata enterpriseMetadata = enterpriseEdition.getCustomMetadata();\n\n            if (enterpriseMetadata != null && premiumMetadata != null) {\n                // Copy autoUpdateMetadata setting\n                if (!premiumMetadata.isAutoUpdateMetadata() && enterpriseMetadata.isAutoUpdateMetadata()) {\n                    premiumMetadata.setAutoUpdateMetadata(true);\n                }\n\n                // Copy author if not set in premium but set in enterprise\n                if ((premiumMetadata.getAuthor() \n                     == null\n                     || premiumMetadata.getAuthor()\n                    .trim()\n                    .isEmpty()\n                     || \"username\".equals(premiumMetadata\n                    .getAuthor())\n                    )\n                     && enterpriseMetadata.getAuthor() \n                     != null\n                     && !enterpriseMetadata.getAuthor()\n                    .trim()\n                    .isEmpty()) {\n                    premiumMetadata.setAuthor(enterpriseMetadata.getAuthor());\n                }\n\n                // Copy creator if not set in premium but set in enterprise and different from default\n                if ((premiumMetadata.getCreator() \n                     == null\n                     || \"Stirling-PDF\".equals(premiumMetadata\n                    .getCreator())\n                    )\n                     && enterpriseMetadata.getCreator() \n                     != null\n                     && !\"Stirling-PDF\".equals(enterpriseMetadata\n                    .getCreator())) {\n                    premiumMetadata.setCreator(enterpriseMetadata.getCreator());\n                }\n\n                // Copy producer if not set in premium but set in enterprise and different from default\n                if ((premiumMetadata.getProducer() \n                     == null\n                     || \"Stirling-PDF\".equals(premiumMetadata\n                    .getProducer())\n                    )\n                     && enterpriseMetadata.getProducer() \n                     != null\n                     && !\"Stirling-PDF\".equals(enterpriseMetadata\n                    .getProducer())) {\n                    premiumMetadata.setProducer(enterpriseMetadata.getProducer());\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "173", "src_id": "M543", "code": "        private void applyGhostscriptCompression(OptimizePdfRequest request, int optimizeLevel, Path currentFile, List<Path> tempFiles)throws IOException {\n            long preGsSize = Files.size(currentFile);\n\n            log.info(\"Pre-Ghostscript file size: {}\", GeneralUtils.formatBytes(preGsSize));\n\n            // Create output file for Ghostscript\n            Path gsOutputFile = Files.createTempFile(\"gs_output_\", \".pdf\");\n\n            tempFiles.add(gsOutputFile);\n\n            // Build Ghostscript command based on optimization level\n            List<String> command = new ArrayList<>();\n            command.add(\"gs\");\n            command.add(\"-sDEVICE=pdfwrite\");\n            command.add(\"-dCompatibilityLevel=1.5\");\n            command.add(\"-dNOPAUSE\");\n            command.add(\"-dQUIET\");\n            command.add(\"-dBATCH\");\n\n            // Map optimization levels to Ghostscript settings\n            switch (optimizeLevel) {\n                case 1:\n                    command.add(\"-dPDFSETTINGS=/prepress\");\n                    break;\n                case 2:\n                    command.add(\"-dPDFSETTINGS=/printer\");\n                    break;\n                case 3:\n                    command.add(\"-dPDFSETTINGS=/ebook\");\n                    break;\n                case 4:\n                case 5:\n                    command.add(\"-dPDFSETTINGS=/screen\");\n                    break;\n                case 6:\n                case 7:\n                    command.add(\"-dPDFSETTINGS=/screen\");\n                    command.add(\"-dColorImageResolution=150\");\n                    command.add(\"-dGrayImageResolution=150\");\n                    command.add(\"-dMonoImageResolution=300\");\n                    break;\n                case 8:\n                case 9:\n                    command.add(\"-dPDFSETTINGS=/screen\");\n                    command.add(\"-dColorImageResolution=100\");\n                    command.add(\"-dGrayImageResolution=100\");\n                    command.add(\"-dMonoImageResolution=200\");\n                    break;\n                case 10:\n                    command.add(\"-dPDFSETTINGS=/screen\");\n                    command.add(\"-dColorImageResolution=72\");\n                    command.add(\"-dGrayImageResolution=72\");\n                    command.add(\"-dMonoImageResolution=150\");\n                    break;\n                default:\n                    command.add(\"-dPDFSETTINGS=/screen\");\n                    break;\n            }\n\n            command.add(\"-sOutputFile=\" + gsOutputFile.toString());\n            command.add(currentFile.toString());\n\n            ProcessExecutorResult returnCode = null;\n\n            try {\n                returnCode = ProcessExecutor.getInstance(ProcessExecutor.Processes.GHOSTSCRIPT).runCommandWithOutputHandling(command);\n\n                if (returnCode.getRc() == 0) {\n                    // Update current file to the Ghostscript output\n                    Files.copy(gsOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n\n                    long postGsSize = Files.size(currentFile);\n                    double gsReduction = 100.0 -((postGsSize * 100.0) / preGsSize);\n\n                    log.info(\"Post-Ghostscript file size: {} (reduced by {}%)\", GeneralUtils.formatBytes(postGsSize), String.format(\"%.1f\", gsReduction));\n                } else {\n                    log.warn(\"Ghostscript compression failed with return code: {}\", returnCode.getRc());\n                    throw new IOException(\"Ghostscript compression failed\");\n                }\n            } catch (Exception e) {\n                    log.warn(\"Ghostscript compression failed, will fallback to other methods\", e);\n                    throw new IOException(\"Ghostscript compression failed\", e);\n                }\n\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "174", "src_id": "M256", "code": "        private Object executeWithRetries(ProceedingJoinPoint joinPoint,\n        Object[] args, boolean async, long timeout,\n        int maxRetries, boolean trackProgress,\n        boolean queueable, int resourceWeight) {\n            // Keep jobId reference for progress tracking in TaskManager\n            AtomicReference<String> jobIdRef = new AtomicReference<>();\n\n            return jobExecutorService.runJobGeneric(async,\n            () -> {// Use iterative approach instead of recursion to avoid stack overflow\n                Throwable lastException = null;// Attempt counter starts at 1 for first try\n                for (int currentAttempt = 1; currentAttempt \n                     <= maxRetries\n                    ; currentAttempt++) {try {if (trackProgress \n                             && async\n                            ) {// Get jobId for progress tracking in TaskManager\n                            // This enables REST API progress queries, not WebSocket\n                            if (jobIdRef.get() == null) {jobIdRef\n                                .set(getJobIdFromContext())\n                                ;}String jobId = jobIdRef.get();if (jobId \n                                 != null\n                                ) {log.debug(\"Tracking progress for job {} (attempt {}/{})\",\n                                jobId, currentAttempt, maxRetries)\n                                ;// Progress is tracked in TaskManager for REST API access\n                            // No WebSocket notifications sent here\n                            }}// Attempt to execute the operation\n                        return joinPoint.proceed(args);} catch (Throwable ex) {lastException \n                             = ex\n                            ; log.error(\"AutoJobAspect caught exception during job execution (attempt {}/{}): {}\",\n                            currentAttempt, maxRetries, ex.getMessage(),\n                            ex)\n                            ;// Check if we should retry\n                            if (currentAttempt < maxRetries) {log\n                                .info(\"Retrying operation, attempt {}/{}\",\n                                currentAttempt + 1, maxRetries)\n                                ;if (trackProgress && async) {String jobId = jobIdRef\n                                    .get();if (jobId != null) {log\n                                        .debug(\"Recording retry attempt for job {} in TaskManager\", jobId)\n                                        ;// Retry info is tracked in TaskManager for REST API access\n                                    }}// Use non-blocking delay for all retry attempts to avoid blocking\n                                // threads\n                                // For sync jobs this avoids starving the tomcat thread pool under\n                                // load\n                                long delayMs = RETRY_BASE_DELAY.toMillis() * currentAttempt;// Execute the retry after a delay through the JobExecutorService\n                                // rather than blocking the current thread with sleep\n                                CompletableFuture<Object> delayedRetry = new CompletableFuture<>();// Use a delayed executor for non-blocking delay\n                                CompletableFuture.delayedExecutor(delayMs, TimeUnit.MILLISECONDS).execute(() -> {// Continue the retry loop in the next iteration\n                                    // We can't return from here directly since\n                                    // we're in a Runnable\n                                    delayedRetry.complete(null);});// Wait for the delay to complete before continuing\n                                try {delayedRetry.join();} catch (Exception e) {Thread.currentThread().interrupt();break;}} else {// No more retries, we'll throw the exception after the loop\n                                break;}}}// If we get here, all retries failed\n                if (lastException != null) {throw new RuntimeException(\"Job failed after \" + maxRetries + \" attempts: \" + lastException.getMessage(), lastException);}// This should never happen if lastException is properly tracked\n                throw new RuntimeException(\"Job failed but no exception was recorded\");},\n            timeout, queueable, resourceWeight);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "175", "src_id": "M813", "code": "        public void init() {\n            // Adding endpoints to \"PageOps\" group\n            addEndpointToGroup(\"PageOps\", \"remove-pages\");\n            addEndpointToGroup(\"PageOps\", \"merge-pdfs\");\n            addEndpointToGroup(\"PageOps\", \"split-pdfs\");\n            addEndpointToGroup(\"PageOps\", \"pdf-organizer\");\n            addEndpointToGroup(\"PageOps\", \"rotate-pdf\");\n            addEndpointToGroup(\"PageOps\", \"multi-page-layout\");\n            addEndpointToGroup(\"PageOps\", \"scale-pages\");\n            addEndpointToGroup(\"PageOps\", \"adjust-contrast\");\n            addEndpointToGroup(\"PageOps\", \"crop\");\n            addEndpointToGroup(\"PageOps\", \"auto-split-pdf\");\n            addEndpointToGroup(\"PageOps\", \"extract-page\");\n            addEndpointToGroup(\"PageOps\", \"pdf-to-single-page\");\n            addEndpointToGroup(\"PageOps\", \"split-by-size-or-count\");\n            addEndpointToGroup(\"PageOps\", \"overlay-pdf\");\n            addEndpointToGroup(\"PageOps\", \"split-pdf-by-sections\");\n            // Adding endpoints to \"Convert\" group\n            addEndpointToGroup(\"Convert\", \"pdf-to-img\");\n            addEndpointToGroup(\"Convert\", \"img-to-pdf\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-pdfa\");\n            addEndpointToGroup(\"Convert\", \"file-to-pdf\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-word\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-presentation\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-text\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-html\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-xml\");\n            addEndpointToGroup(\"Convert\", \"html-to-pdf\");\n            addEndpointToGroup(\"Convert\", \"url-to-pdf\");\n            addEndpointToGroup(\"Convert\", \"markdown-to-pdf\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-csv\");\n            addEndpointToGroup(\"Convert\", \"pdf-to-markdown\");\n            addEndpointToGroup(\"Convert\", \"eml-to-pdf\");\n            // Adding endpoints to \"Security\" group\n            addEndpointToGroup(\"Security\", \"add-password\");\n            addEndpointToGroup(\"Security\", \"remove-password\");\n            addEndpointToGroup(\"Security\", \"change-permissions\");\n            addEndpointToGroup(\"Security\", \"add-watermark\");\n            addEndpointToGroup(\"Security\", \"cert-sign\");\n            addEndpointToGroup(\"Security\", \"remove-cert-sign\");\n            addEndpointToGroup(\"Security\", \"sanitize-pdf\");\n            addEndpointToGroup(\"Security\", \"auto-redact\");\n            addEndpointToGroup(\"Security\", \"redact\");\n            // Adding endpoints to \"Other\" group\n            addEndpointToGroup(\"Other\", \"ocr-pdf\");\n            addEndpointToGroup(\"Other\", \"add-image\");\n            addEndpointToGroup(\"Other\", \"compress-pdf\");\n            addEndpointToGroup(\"Other\", \"extract-images\");\n            addEndpointToGroup(\"Other\", \"change-metadata\");\n            addEndpointToGroup(\"Other\", \"extract-image-scans\");\n            addEndpointToGroup(\"Other\", \"sign\");\n            addEndpointToGroup(\"Other\", \"flatten\");\n            addEndpointToGroup(\"Other\", \"repair\");\n            addEndpointToGroup(\"Other\", \"unlock-pdf-forms\");\n            addEndpointToGroup(\"Other\", REMOVE_BLANKS);\n            addEndpointToGroup(\"Other\", \"remove-annotations\");\n            addEndpointToGroup(\"Other\", \"compare\");\n            addEndpointToGroup(\"Other\", \"add-page-numbers\");\n            addEndpointToGroup(\"Other\", \"auto-rename\");\n            addEndpointToGroup(\"Other\", \"get-info-on-pdf\");\n            addEndpointToGroup(\"Other\", \"show-javascript\");\n            addEndpointToGroup(\"Other\", \"remove-image-pdf\");\n            addEndpointToGroup(\"Other\", \"add-attachments\");\n            // CLI\n            addEndpointToGroup(\"CLI\", \"compress-pdf\");\n            addEndpointToGroup(\"CLI\", \"extract-image-scans\");\n            addEndpointToGroup(\"CLI\", \"repair\");\n            addEndpointToGroup(\"CLI\", \"pdf-to-pdfa\");\n            addEndpointToGroup(\"CLI\", \"file-to-pdf\");\n            addEndpointToGroup(\"CLI\", \"pdf-to-word\");\n            addEndpointToGroup(\"CLI\", \"pdf-to-presentation\");\n            addEndpointToGroup(\"CLI\", \"pdf-to-html\");\n            addEndpointToGroup(\"CLI\", \"pdf-to-xml\");\n            addEndpointToGroup(\"CLI\", \"ocr-pdf\");\n            addEndpointToGroup(\"CLI\", \"html-to-pdf\");\n            addEndpointToGroup(\"CLI\", \"url-to-pdf\");\n            addEndpointToGroup(\"CLI\", \"pdf-to-rtf\");\n            // python\n            addEndpointToGroup(\"Python\", \"extract-image-scans\");\n            addEndpointToGroup(\"Python\", \"html-to-pdf\");\n            addEndpointToGroup(\"Python\", \"url-to-pdf\");\n            addEndpointToGroup(\"Python\", \"file-to-pdf\");\n            // openCV\n            addEndpointToGroup(\"OpenCV\", \"extract-image-scans\");\n            // LibreOffice\n            addEndpointToGroup(\"LibreOffice\", \"file-to-pdf\");\n            addEndpointToGroup(\"LibreOffice\", \"pdf-to-word\");\n            addEndpointToGroup(\"LibreOffice\", \"pdf-to-presentation\");\n            addEndpointToGroup(\"LibreOffice\", \"pdf-to-rtf\");\n            addEndpointToGroup(\"LibreOffice\", \"pdf-to-html\");\n            addEndpointToGroup(\"LibreOffice\", \"pdf-to-xml\");\n            addEndpointToGroup(\"LibreOffice\", \"pdf-to-pdfa\");\n            // Unoconvert\n            addEndpointToGroup(\"Unoconvert\", \"file-to-pdf\");\n            // Java\n            addEndpointToGroup(\"Java\", \"merge-pdfs\");\n            addEndpointToGroup(\"Java\", \"remove-pages\");\n            addEndpointToGroup(\"Java\", \"split-pdfs\");\n            addEndpointToGroup(\"Java\", \"pdf-organizer\");\n            addEndpointToGroup(\"Java\", \"rotate-pdf\");\n            addEndpointToGroup(\"Java\", \"pdf-to-img\");\n            addEndpointToGroup(\"Java\", \"img-to-pdf\");\n            addEndpointToGroup(\"Java\", \"add-password\");\n            addEndpointToGroup(\"Java\", \"remove-password\");\n            addEndpointToGroup(\"Java\", \"change-permissions\");\n            addEndpointToGroup(\"Java\", \"add-watermark\");\n            addEndpointToGroup(\"Java\", \"add-image\");\n            addEndpointToGroup(\"Java\", \"extract-images\");\n            addEndpointToGroup(\"Java\", \"change-metadata\");\n            addEndpointToGroup(\"Java\", \"cert-sign\");\n            addEndpointToGroup(\"Java\", \"remove-cert-sign\");\n            addEndpointToGroup(\"Java\", \"multi-page-layout\");\n            addEndpointToGroup(\"Java\", \"scale-pages\");\n            addEndpointToGroup(\"Java\", \"add-page-numbers\");\n            addEndpointToGroup(\"Java\", \"auto-rename\");\n            addEndpointToGroup(\"Java\", \"auto-split-pdf\");\n            addEndpointToGroup(\"Java\", \"sanitize-pdf\");\n            addEndpointToGroup(\"Java\", \"crop\");\n            addEndpointToGroup(\"Java\", \"get-info-on-pdf\");\n            addEndpointToGroup(\"Java\", \"extract-page\");\n            addEndpointToGroup(\"Java\", \"pdf-to-single-page\");\n            addEndpointToGroup(\"Java\", \"markdown-to-pdf\");\n            addEndpointToGroup(\"Java\", \"show-javascript\");\n            addEndpointToGroup(\"Java\", \"auto-redact\");\n            addEndpointToGroup(\"Java\", \"redact\");\n            addEndpointToGroup(\"Java\", \"pdf-to-csv\");\n            addEndpointToGroup(\"Java\", \"split-by-size-or-count\");\n            addEndpointToGroup(\"Java\", \"overlay-pdf\");\n            addEndpointToGroup(\"Java\", \"split-pdf-by-sections\");\n            addEndpointToGroup(\"Java\", REMOVE_BLANKS);\n            addEndpointToGroup(\"Java\", \"pdf-to-text\");\n            addEndpointToGroup(\"Java\", \"remove-image-pdf\");\n            addEndpointToGroup(\"Java\", \"pdf-to-markdown\");\n            addEndpointToGroup(\"Java\", \"add-attachments\");\n            addEndpointToGroup(\"Java\", \"compress-pdf\");\n            // Javascript\n            addEndpointToGroup(\"Javascript\", \"pdf-organizer\");\n            addEndpointToGroup(\"Javascript\", \"sign\");\n            addEndpointToGroup(\"Javascript\", \"compare\");\n            addEndpointToGroup(\"Javascript\", \"adjust-contrast\");/* qpdf */\n            addEndpointToGroup(\"qpdf\", \"repair\");\n            addEndpointToGroup(\"qpdf\", \"compress-pdf\");/* Ghostscript */\n            addEndpointToGroup(\"Ghostscript\", \"repair\");\n            addEndpointToGroup(\"Ghostscript\", \"compress-pdf\");/* tesseract */\n            addEndpointToGroup(\"tesseract\", \"ocr-pdf\");/* OCRmyPDF */\n            addEndpointToGroup(\"OCRmyPDF\", \"ocr-pdf\");\n            // Multi-tool endpoints - endpoints that can be handled by multiple tools\n            addEndpointAlternative(\"repair\", \"qpdf\");\n            addEndpointAlternative(\"repair\", \"Ghostscript\");\n            addEndpointAlternative(\"compress-pdf\", \"qpdf\");\n            addEndpointAlternative(\"compress-pdf\", \"Ghostscript\");\n            addEndpointAlternative(\"compress-pdf\", \"Java\");\n            addEndpointAlternative(\"ocr-pdf\", \"tesseract\");\n            addEndpointAlternative(\"ocr-pdf\", \"OCRmyPDF\");\n            // file-to-pdf has multiple implementations\n            addEndpointAlternative(\"file-to-pdf\", \"LibreOffice\");\n            addEndpointAlternative(\"file-to-pdf\", \"Python\");\n            addEndpointAlternative(\"file-to-pdf\", \"Unoconvert\");\n            // pdf-to-html and pdf-to-markdown can use either LibreOffice or Pdftohtml\n            addEndpointAlternative(\"pdf-to-html\", \"LibreOffice\");\n            addEndpointAlternative(\"pdf-to-html\", \"Pdftohtml\");\n            addEndpointAlternative(\"pdf-to-markdown\", \"Pdftohtml\");\n            // markdown-to-pdf can use either Weasyprint or Java\n            addEndpointAlternative(\"markdown-to-pdf\", \"Weasyprint\");\n            addEndpointAlternative(\"markdown-to-pdf\", \"Java\");\n            // Weasyprint dependent endpoints\n            addEndpointToGroup(\"Weasyprint\", \"html-to-pdf\");\n            addEndpointToGroup(\"Weasyprint\", \"url-to-pdf\");\n            addEndpointToGroup(\"Weasyprint\", \"markdown-to-pdf\");\n            addEndpointToGroup(\"Weasyprint\", \"eml-to-pdf\");\n            // Pdftohtml dependent endpoints\n            addEndpointToGroup(\"Pdftohtml\", \"pdf-to-html\");\n            addEndpointToGroup(\"Pdftohtml\", \"pdf-to-markdown\");\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "176", "src_id": "M318", "code": "        public static byte[] overlayImage(CustomPDFDocumentFactory pdfDocumentFactory,\n        byte[] pdfBytes, byte[] imageBytes,\n        float x, float y, boolean everyPage)throws IOException {\n            PDDocument document = pdfDocumentFactory.load(pdfBytes);\n            // Get the first page of the PDF\n            int pages = document.getNumberOfPages();\n            for (int i = 0; i < pages; i++) {\n                PDPage page = document.getPage(i);\n                try (PDPageContentStream contentStream = \n                    new PDPageContentStream(\n                    document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {\n                    // Create an image object from the image bytes\n                    PDImageXObject image = PDImageXObject.createFromByteArray(document, imageBytes, \"\");\n\n                    // Draw the image onto the page at the specified x and y coordinates\n                    contentStream.drawImage(image, x, y);\n                    log.info(\"Image successfully overlayed onto PDF\");\n\n                    if (!everyPage && i == 0) {\n                        break;\n                    }\n                } catch (IOException e) {\n                        // Log an error message if there is an issue overlaying the image onto the PDF\n                        log.error(\"Error overlaying image onto PDF\", e);\n                        throw e;\n                    }\n\n            }\n\n            // Create a ByteArrayOutputStream to save the PDF to\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n            document.save(baos);\n            log.info(\"PDF successfully saved to byte array\");\n            return baos.toByteArray();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "177", "src_id": "M310", "code": "        public static PDRectangle textToPageSize(String size) {\n            switch (size.toUpperCase()) {\n                case \"A0\" -> {\n                        return PDRectangle.A0;\n                    }\n                case \"A1\" -> {\n                        return PDRectangle.A1;\n                    }\n                case \"A2\" -> {\n                        return PDRectangle.A2;\n                    }\n                case \"A3\" -> {\n                        return PDRectangle.A3;\n                    }\n                case \"A4\" -> {\n                        return PDRectangle.A4;\n                    }\n                case \"A5\" -> {\n                        return PDRectangle.A5;\n                    }\n                case \"A6\" -> {\n                        return PDRectangle.A6;\n                    }\n                case \"LETTER\" -> {\n                        return PDRectangle.LETTER;\n                    }\n                case \"LEGAL\" -> {\n                        return PDRectangle.LEGAL;\n                    }\n                default -> throw ExceptionUtils.createInvalidPageSizeException(size);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "178", "src_id": "M208", "code": "        private long parseSessionTimeout(String timeout) {\n            if (timeout == null || timeout.isEmpty()) {\n                return 30 * 60 * 1000; // Default: 30 minutes\n\n            }\n\n            try {\n                String value = timeout.replaceAll(\"[^\\\\d.]\", \"\");\n                String unit = timeout.replaceAll(\"[\\\\d.]\", \"\");\n                double numericValue = Double.parseDouble(value);\n\n                return switch (unit.toLowerCase()\n                ) {case \"s\" -> (long) (numericValue \n                         * 1000\n                        )\n                        ;case \"m\" -> (long) (numericValue \n                         * 60 \n                         * 1000\n                        )\n                        ;case \"h\" -> (long) (numericValue \n                         * 60 \n                         * 60 \n                         * 1000\n                        )\n                        ;case \"d\" -> (long) (numericValue \n                         * 24 \n                         * 60 \n                         * 60 \n                         * 1000\n                        )\n                        ;default -> (long) (numericValue \n                         * 60 \n                         * 1000\n                        )\n                        ; // Default to minutes\n                };\n            } catch (Exception e) {\n                    log.warn(\"Could not parse session timeout '{}', using default\", timeout);\n                    return 30 * 60 * 1000; // Default: 30 minutes\n\n                }\n\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "179", "src_id": "M183", "code": "        public Map<String, Object> captureServerMetrics() {\n            Map<String, Object> metrics = new HashMap<>();\n\n            try {\n                // Application version\n                metrics.put(\"app_version\", appVersion);\n\n                String deploymentType = \"JAR\"; // default\n\n\n                if (\"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"))) {\n                    deploymentType = \"EXE\";\n                } else if (isRunningInDocker()) {\n                    deploymentType = \"DOCKER\";\n                }\n\n\n                metrics.put(\"deployment_type\", deploymentType);\n                metrics.put(\"mounted_config_dir\", configDirMounted);\n                // System info\n                metrics.put(\"os_name\", System.getProperty(\"os.name\"));\n                metrics.put(\"os_version\", System.getProperty(\"os.version\"));\n                metrics.put(\"java_version\", System.getProperty(\"java.version\"));\n                metrics.put(\"user_name\", System.getProperty(\"user.name\"));\n                metrics.put(\"user_home\", System.getProperty(\"user.home\"));\n                metrics.put(\"user_dir\", System.getProperty(\"user.dir\"));\n                // CPU and Memory\n                metrics.put(\"cpu_cores\", Runtime.getRuntime().availableProcessors());\n                metrics.put(\"total_memory\", Runtime.getRuntime().totalMemory());\n                metrics.put(\"free_memory\", Runtime.getRuntime().freeMemory());\n\n                // Network and Server Identity\n                InetAddress localHost = InetAddress.getLocalHost();\n\n                metrics.put(\"ip_address\", localHost.getHostAddress());\n                metrics.put(\"hostname\", localHost.getHostName());\n                metrics.put(\"mac_address\", getMacAddress());\n                // JVM info\n                metrics.put(\"jvm_vendor\", System.getProperty(\"java.vendor\"));\n                metrics.put(\"jvm_version\", System.getProperty(\"java.vm.version\"));\n                // Locale and Timezone\n                metrics.put(\"system_language\", System.getProperty(\"user.language\"));\n                metrics.put(\"system_country\", System.getProperty(\"user.country\"));\n                metrics.put(\"timezone\", TimeZone.getDefault().getID());\n                metrics.put(\"locale\", Locale.getDefault().toString());\n\n                // Disk info\n                File root = new File(\".\");\n\n                metrics.put(\"total_disk_space\", root.getTotalSpace());\n                metrics.put(\"free_disk_space\", root.getFreeSpace());\n                // Process info\n                metrics.put(\"process_id\", ProcessHandle.current().pid());\n\n                // JVM metrics\n                RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n\n                metrics.put(\"jvm_uptime_ms\", runtimeMXBean.getUptime());\n                metrics.put(\"jvm_start_time\", runtimeMXBean.getStartTime());\n\n                // Memory metrics\n                MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();\n\n                metrics.put(\"heap_memory_usage\", memoryMXBean.getHeapMemoryUsage().getUsed());\n                metrics.put(\"non_heap_memory_usage\", memoryMXBean.getNonHeapMemoryUsage().getUsed());\n\n                // CPU metrics\n                OperatingSystemMXBean osMXBean = ManagementFactory.getOperatingSystemMXBean();\n\n                metrics.put(\"system_load_average\", osMXBean.getSystemLoadAverage());\n\n                // Thread metrics\n                ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\n                metrics.put(\"thread_count\", threadMXBean.getThreadCount());\n                metrics.put(\"daemon_thread_count\", threadMXBean.getDaemonThreadCount());\n                metrics.put(\"peak_thread_count\", threadMXBean.getPeakThreadCount());\n\n                // Garbage collection metrics\n                for (GarbageCollectorMXBean gcBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n                    metrics.put(\"gc_\" + gcBean.getName() + \"_count\", gcBean.getCollectionCount());\n                    metrics.put(\"gc_\" + gcBean.getName() + \"_time\", gcBean.getCollectionTime());\n                }\n                // Network interfaces\n                metrics.put(\"network_interfaces\", getNetworkInterfacesInfo());\n\n                // Docker detection and stats\n                boolean isDocker = isRunningInDocker();\n                if (isDocker) {\n                    metrics.put(\"docker_metrics\", getDockerMetrics());\n                }\n\n                metrics.put(\"application_properties\", captureApplicationProperties());\n\n                if (userService != null) {\n                    metrics.put(\"total_users_created\", userService.getTotalUsersCount());\n                }\n            } catch (Exception e) {\n                    metrics.put(\"error\", e.getMessage());\n                }\n\n            return metrics;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "222", "src_id": "M168", "code": "    private StringArg readStringArg() throws IOException, FilterException {\n\n        int c = reader.read();\n        int last = 0;\n        if (c != '\"') {\n            throw new FilterException(\"Check the parser, trying to read a string that doesn't begin with quotes\");\n        }\n\n        StringBuffer buffer = new StringBuffer();\n\n        while (reader.ready()) {\n            last = c;\n            c = reader.read();\n            if (c == -1) {\n                break;\n            }\n            if (c == '\"' && last != '\\\\') {\n                return new StringArg(buffer.toString());\n            } else {\n                buffer.append((char) c);\n            }\n        }\n\n        throw new FilterException(\"Unterminated string\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "223", "src_id": "M196", "code": "    public static void main(String[] args) throws IOException {\t\n\n        MergedLogSource source = new MergedLogSource(args);\n        PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-ms.out\")));\n\n        PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-sec.out\")));\n\n        PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-min.out\")));\n\n        PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"throughput-hour.out\")));\n        LogIterator iter;\n        System.out.println(source);\n        iter = source.iterator();\n\n        long currentms = 0;\n        long currentsec = 0;\n        long currentmin = 0;\n        long currenthour = 0;\n        Set<Long> zxids_ms = new HashSet<Long>();\n        long zxid_sec = 0;\n        long zxid_min = 0;\n        long zxid_hour = 0;\n\n        while (iter.hasNext()) {\n\n            LogEntry e = iter.next();\n            TransactionEntry cxn = (TransactionEntry) e;\n            long ms = cxn.getTimestamp();\n            long sec = ms / MS_PER_SEC;\n            long min = ms / MS_PER_MIN;\n            long hour = ms / MS_PER_HOUR;\n            if (currentms != ms && currentms != 0) {\n                ps_ms.println(\"\" + currentms + \" \" + zxids_ms.size());\n                zxid_sec += zxids_ms.size();\n                zxid_min += zxids_ms.size();\n                zxid_hour += zxids_ms.size();\n                zxids_ms.clear();\n            }\n\n            if (currentsec != sec && currentsec != 0) {\n                ps_sec.println(\"\" + currentsec * MS_PER_SEC + \" \" + zxid_sec);\n                zxid_sec = 0;\n            }\n\n            if (currentmin != min && currentmin != 0) {\n                ps_min.println(\"\" + currentmin * MS_PER_MIN + \" \" + zxid_min);\n                zxid_min = 0;\n            }\n\n            if (currenthour != hour && currenthour != 0) {\n                ps_hour.println(\"\" + currenthour * MS_PER_HOUR + \" \" + zxid_hour);\n                zxid_hour = 0;\n            }\n            currentms = ms;\n            currentsec = sec;\n            currentmin = min;\n            currenthour = hour;\n            zxids_ms.add(cxn.getZxid());\n        }\n\n        iter.close();\n        ps_ms.close();\n        ps_sec.close();\n        ps_min.close();\n        ps_hour.close();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "224", "src_id": "M174", "code": "    private LogEntry readNextEntry() {\n\n        LogEntry e = null;\n        try {\n\n            long crcValue;\n            byte[] bytes;\n            try {\n                crcValue = logStream.readLong(\"crcvalue\");\n                bytes = logStream.readBuffer(\"txnEntry\");\n            } catch (EOFException ex) {\n                    return null;\n                }\n\n\n            if (bytes.length == 0) {\n                return null;\n            }\n\n            Checksum crc = new Adler32();\n            crc.update(bytes, 0, bytes.length);\n            if (crcValue != crc.getValue()) {\n                throw new IOException(\"CRC doesn't match \" + crcValue + \" vs \" + crc.getValue());\n            }\n\n            TxnLogEntry logEntry = SerializeUtils.deserializeTxn(bytes);\n            TxnHeader hdr = logEntry.getHeader();\n            Record r = logEntry.getTxn();\n\n            switch (hdr.getType()) {\n                case OpCode.createSession:{\n                        e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"createSession\");\n                    }\n                    break;\n                case OpCode.closeSession:{\n                        e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"closeSession\");\n                    }\n                    break;\n                case OpCode.create:\n                    if (r != null) {\n\n                        CreateTxn create = (CreateTxn) r;\n                        String path = create.getPath();\n                        e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"create\", path);\n                    }\n                    break;\n                case OpCode.setData:\n                    if (r != null) {\n\n                        SetDataTxn set = (SetDataTxn) r;\n                        String path = set.getPath();\n                        e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setData\", path);\n                    }\n                    break;\n                case OpCode.setACL:\n                    if (r != null) {\n\n                        SetACLTxn setacl = (SetACLTxn) r;\n                        String path = setacl.getPath();\n                        e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \"setACL\", path);\n                    }\n                    break;\n                case OpCode.error:\n                    if (r != null)  {\n\n                        ErrorTxn error = (ErrorTxn) r;\n                        e = new TransactionEntry(hdr.getTime(), \n                                hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), \n                                \"error\", \"Error: \" + error.getErr());\n                    }\n                    break;\n                default:\n                    LOG.info(\"Unknown op: \" + hdr.getType());\n                    break;\n            }\n\n            if (logStream.readByte(\"EOR\") != 'B') {\n                throw new EOFException(\"Last transaction was partial.\");\n            }\n        } catch (Exception ex) {\n                LOG.error(\"Error reading transaction from (\" + src.file + \") :\" + e);\n                return null;\n            }\n\n\n        return e;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "225", "src_id": "M1149", "code": "    public void run() {\n        try {\n            while (!stopped) {\n                try {\n                    select();\n                    processAcceptedConnections();\n                    processInterestOpsUpdateRequests();\n                } catch (RuntimeException e) {\n                        LOG.warn(\"Ignoring unexpected runtime exception\", e);\n                    } catch (Exception e) {\n                        LOG.warn(\"Ignoring unexpected exception\", e);\n                    }\n\n            }\n\n            // Close connections still pending on the selector. Any others\n            // with in-flight work, let drain out of the work queue.\n            for (SelectionKey key:selector.keys()) {\n\n                NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();\n                if (cnxn.isSelectable()) {\n                    cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n                }\n                cleanupSelectionKey(key);\n            }\n            SocketChannel accepted;\n\n            while ((accepted = acceptedQueue.poll()) != null) {\n                fastCloseSock(accepted);\n            }\n\n            updateQueue.clear();\n        } finally {\n                closeSelector();\n                // This will wake up the accept thread and the other selector\n                // threads, and tell the worker thread pool to begin shutdown.\n                NIOServerCnxnFactory.this.stop();\n                LOG.info(\"selector thread exited run method\");\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "226", "src_id": "M286", "code": "    public void reconfigureInstance(String name, \n            String params) throws NoAssignmentException, InterruptedException, KeeperException {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Reconfiguring \" + name + \" with \" + params);\n        }\n\n        Assigned assigned = instanceToAssignment.get(name);\n        if (assigned == null) {\n            throw new NoAssignmentException();\n        }\n\n        KeeperException lastException = null;\n\n        for (int i = 0; i < maxTries; i++) {\n            try {\n                zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, (\"update \" + params).getBytes(), -1);\n                break;\n            } catch (ConnectionLossException e) {\n                    lastException = e;\n                }\n\n        }\n        if (lastException != null) {\n            throw lastException;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "227", "src_id": "M1046", "code": "    public static void closeSock(SocketChannel sock) {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        try { /*\n             * The following sequence of code is stupid! You would think that\n             * only sock.close() is needed, but alas, it doesn't work that way.\n             * If you just do sock.close() there are cases where the socket\n             * doesn't actually close...\n             */\n            sock.socket().shutdownOutput();\n        } catch (IOException e) {\n                // This is a relatively common exception that we can't avoid\n                LOG.debug(\"ignoring exception during output shutdown\", e);\n            }\n\n        try {\n            sock.socket().shutdownInput();\n        } catch (IOException e) {\n                // This is a relatively common exception that we can't avoid\n                LOG.debug(\"ignoring exception during input shutdown\", e);\n            }\n\n        try {\n            sock.socket().close();\n        } catch (IOException e) {\n                LOG.debug(\"ignoring exception during socket close\", e);\n            }\n\n        try {\n            sock.close();\n        } catch (IOException e) {\n                LOG.debug(\"ignoring exception during socketchannel close\", e);\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "228", "src_id": "M149", "code": "    String handleRequest(JsonRequest request) throws Exception {\n\n        long starttime = 0;\n        long endtime = 0;\n        long period = 0;\n        FilterOp fo = null;\n        starttime = request.getNumber(\"start\", 0);\n        endtime = request.getNumber(\"end\", 0);\n        period = request.getNumber(\"period\", 0);\n\n        String filterstr = request.getString(\"filter\", \"\");\n        if (filterstr.length() > 0) {\n            fo = new FilterParser(filterstr).parse();\n        }\n        if (starttime == 0) { \n            starttime = source.getStartTime(); \n        }\n        if (endtime == 0) { \n            if (period > 0) {\n                endtime = starttime + period;\n            } else {\n                endtime = starttime + DEFAULT_PERIOD; \n            }\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"handle(start= \" + starttime + \", end=\" + endtime + \", period=\" + period + \")\");\n        }\n\n        LogIterator iterator = (fo != null) ? source\n                .iterator(starttime, endtime, fo) \n                :source.iterator(starttime, endtime);\n        return new JsonGenerator(iterator).toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "229", "src_id": "M370", "code": "    @Override void cleanup() {\n        if (sockKey != null) {\n\n            SocketChannel sock = (SocketChannel) sockKey.channel();\n            sockKey.cancel();\n\n            try {\n                sock.socket().shutdownInput();\n            } catch (IOException e) {\n                    LOG.debug(\"Ignoring exception during shutdown input\", e);\n                }\n\n            try {\n                sock.socket().shutdownOutput();\n            } catch (IOException e) {\n                    LOG.debug(\"Ignoring exception during shutdown output\", e);\n                }\n\n            try {\n                sock.socket().close();\n            } catch (IOException e) {\n                    LOG.debug(\"Ignoring exception during socket close\", e);\n                }\n\n            try {\n                sock.close();\n            } catch (IOException e) {\n                    LOG.debug(\"Ignoring exception during channel close\", e);\n                }\n\n        }\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n                LOG.debug(\"SendThread interrupted during sleep, ignoring\");\n            }\n\n\n        sockKey = null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "230", "src_id": "M40", "code": "    protected void animateVertically(int posx, int fromY, int toY) throws InterruptedException{\n        toaster.setLocation(posx, fromY);\n        if (toY < fromY) {\n            for (int i = fromY; i > toY; i -= step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        } else {\n            for (int i = fromY; i < toY; i += step) {\n                toaster.setLocation(posx, i);\n                Thread.sleep(stepTime);\n            }\n        }\n        toaster.setLocation(posx, toY);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "20", "src_id": "M403", "code": "private void animatePopupOverlayAndFinishService() {\n        final int targetTranslationY = (int) (closeOverlayBinding.closeButton.getRootView().getHeight() - closeOverlayBinding.closeButton.getY());\n        closeOverlayBinding.closeButton.animate().setListener(null).cancel();\n        closeOverlayBinding.closeButton.animate()\n                .setInterpolator(new AnticipateInterpolator())\n                .translationY(targetTranslationY)\n                .setDuration(400)\n                .setListener(new AnimatorListenerAdapter() {@Override public void onAnimationCancel(final Animator animation) { end()\n                                ; }@Override public void onAnimationEnd(final Animator animation) { end()\n                                ; } private void end() { windowManager.removeView(closeOverlayBinding\n                                .getRoot())\n                        ; closeOverlayBinding = null; player.getService().destroyPlayerAndStopService(); }})\n        .start();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "21", "src_id": "M260", "code": "public void play() {\n        if (DEBUG) {\n                Log.d(TAG, \"play() called\");\n        }\n        if (audioReactor == null || playQueue == null || exoPlayerIsNull()) {\n                return;\n        }\n        if (!isMuted()) {\n                audioReactor.requestAudioFocus();\n        }\n        if (currentState == STATE_COMPLETED) {\n                if (playQueue.getIndex() == 0) {\n                        seekToDefault();\n                } else {\n                        playQueue.setIndex(0);\n                }\n        }\n        simpleExoPlayer.play();\n        saveStreamProgressState();\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "22", "src_id": "M543", "code": "private synchronized NotificationCompat.Builder createNotification() {\n        if (DEBUG) {\n                Log.d(TAG, \"createNotification()\");\n        }\n        notificationManager = NotificationManagerCompat.from(player.getContext());\n        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player\n                .getContext(),\n                player.getContext().getString(R.string.notification_channel_id));\n        final MediaStyle mediaStyle = new MediaStyle();\n\n        // setup media style (compact notification slots and media session)\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n                // notification actions are ignored on Android 13+, and are replaced by code in\n                // MediaSessionPlayerUi\n                final int[] compactSlots = initializeNotificationSlots();\n                mediaStyle.setShowActionsInCompactView(compactSlots);\n        }\n        player.UIs().get(MediaSessionPlayerUi.class).flatMap(MediaSessionPlayerUi::getSessionToken).ifPresent(mediaStyle::setMediaSession);\n        // setup notification builder\n        builder.setStyle(mediaStyle).setPriority(NotificationCompat\n                .PRIORITY_HIGH)\n                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)\n                .setCategory(NotificationCompat.CATEGORY_TRANSPORT)\n                .setShowWhen(false)\n                .setSmallIcon(R.drawable.ic_newpipe_triangle_white)\n                .setColor(ContextCompat.getColor(player.getContext(),\n                R.color.dark_background_color))\n                .setColorized(player.getPrefs().getBoolean(player\n                .getContext()\n                .getString(R.string.notification_colorize_key), \n                true))\n                .setDeleteIntent(PendingIntentCompat.getBroadcast(player\n                .getContext(),\n                NOTIFICATION_ID, new Intent(ACTION_CLOSE), FLAG_UPDATE_CURRENT, \n                false));\n        // set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n        setLargeIcon(builder);\n        return builder;\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "23", "src_id": "M225", "code": "private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n                return;\n        }\n        if (DEBUG) {\n                Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n\n        switch (intent.getAction()) {\n                case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                        pause();\n                        break;\n                case ACTION_CLOSE:\n                        service.destroyPlayerAndStopService();\n                        break;\n                case ACTION_PLAY_PAUSE:\n                        playPause();\n                        break;\n                case ACTION_PLAY_PREVIOUS:\n                        playPrevious();\n                        break;\n                case ACTION_PLAY_NEXT:\n                        playNext();\n                        break;\n                case ACTION_FAST_REWIND:\n                        fastRewind();\n                        break;\n                case ACTION_FAST_FORWARD:\n                        fastForward();\n                        break;\n                case ACTION_REPEAT:\n                        cycleNextRepeatMode();\n                        break;\n                case ACTION_SHUFFLE:\n                        toggleShuffleModeEnabled();\n                        break;\n                case Intent.ACTION_CONFIGURATION_CHANGED:\n                        if (DEBUG) {\n                                Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                        }\n                        break;\n        }\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "24", "src_id": "M631", "code": "protected void addImagesMetadataItem(final LayoutInflater inflater,\n        final LinearLayout layout,@StringRes final int type,\n        final List<Image> images) {\n        final String preferredImageUrl = ImageStrategy.choosePreferredImage(images);\n        if (preferredImageUrl == null) {\n                return; // null will be returned in case there is no image\n                \n        }\n\n        final ItemMetadataBinding itemBinding = ItemMetadataBinding.inflate(inflater, layout, false);\n        itemBinding.metadataTypeView.setText(type);\n        final SpannableStringBuilder urls = new SpannableStringBuilder();\n        for (final Image image : images) {\n                if (urls.length() != 0) {\n                        urls.append(\", \");\n                }\n                \n                final int entryBegin = urls.length();\n\n                if (image.getHeight() != Image.HEIGHT_UNKNOWN\n                                 || image.getWidth() != Image.WIDTH_UNKNOWN\n                        // if even the resolution level is unknown, ?x? will be shown\n                                || image.getEstimatedResolutionLevel() == Image\n                                .ResolutionLevel\n                                .UNKNOWN) {\n                        urls.append(imageSizeToText(image.getHeight()));\n                        urls.append('x');\n                        urls.append(imageSizeToText(image.getWidth()));\n                } else {\n                        switch (image.getEstimatedResolutionLevel()) {\n                                case LOW -> urls.append(getString(R.string.image_quality_low));\n                                case MEDIUM -> urls.append(getString(R.string.image_quality_medium));\n                                case HIGH -> urls.append(getString(R.string.image_quality_high));\n                                default -> {\n                                        // unreachable, Image.ResolutionLevel.UNKNOWN is already filtered out\n                                        }\n                        }\n                }\n                urls.setSpan(new ClickableSpan() {@Override public void onClick(@NonNull final View widget) { ShareUtils\n                                        .openUrlInBrowser(requireContext(), image\n                                        .getUrl())\n                                        ; }}, \n                        entryBegin, urls.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n                if (preferredImageUrl.equals(image.getUrl())) {\n                        urls.setSpan(new StyleSpan(Typeface.BOLD), entryBegin, urls.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n                }\n        }\n\n        itemBinding.metadataContentView.setText(urls);\n        itemBinding.metadataContentView.setMovementMethod(LinkMovementMethod.getInstance());\n        layout.addView(itemBinding.getRoot());\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "25", "src_id": "M12", "code": "private void openDetailFragmentFromCommentReplies(@NonNull final FragmentManager fm, final boolean popBackStack) {\n        // obtain the name of the fragment under the replies fragment that's going to be popped\n        @Nullable final String fragmentUnderEntryName;\n        \n        if (fm.getBackStackEntryCount() < 2) {\n                fragmentUnderEntryName = null;\n        } else {\n                fragmentUnderEntryName = fm.getBackStackEntryAt(fm.getBackStackEntryCount() - 2).getName();\n        }\n\n        // the root comment is the comment for which the user opened the replies page\n        @Nullable final CommentRepliesFragment repliesFragment = (CommentRepliesFragment) fm.findFragmentByTag(CommentRepliesFragment.TAG);\n        @Nullable final CommentsInfoItem rootComment = repliesFragment == null ? null : repliesFragment.getCommentsInfoItem();\n        // sometimes this function pops the backstack, other times it's handled by the system\n        if (popBackStack) {\n                fm.popBackStackImmediate();\n        }\n        // only expand the bottom sheet back if there are no more nested comment replies fragments\n        // stacked under the one that is currently being popped\n        if (CommentRepliesFragment.TAG.equals(fragmentUnderEntryName)) {\n                return;\n        }\n\n        final BottomSheetBehavior<FragmentContainerView> behavior = BottomSheetBehavior.from(mainBinding.fragmentPlayerHolder);\n        \n        // do not return to the comment if the details fragment was closed\n        if (behavior.getState() == BottomSheetBehavior.STATE_HIDDEN) {\n                return;\n        }\n        // scroll to the root comment once the bottom sheet expansion animation is finished\n        behavior.addBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() {@Override public void onStateChanged(@NonNull final View bottomSheet, final int newState) {if (newState \n                                         == BottomSheetBehavior.STATE_EXPANDED\n                                        ) {final Fragment detailFragment = fm.findFragmentById(R\n                                        .id\n                                        .fragment_player_holder);if (detailFragment \n                                                 instanceof VideoDetailFragment \n                                                 && rootComment != null\n                                                ) { // should always be the case\n                                        ((VideoDetailFragment) detailFragment).scrollToComment(rootComment)\n                                                ; }behavior.removeBottomSheetCallback(this)\n                                        ; }}@Override public void onSlide(@NonNull final View bottomSheet, final float slideOffset) { // not needed, listener is removed once the sheet is expanded\n                }});\n        behavior.setState(BottomSheetBehavior.STATE_EXPANDED);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "26", "src_id": "M372", "code": "private void buildCaptionMenu(@NonNull final List<String> availableLanguages) {\n        if (captionPopupMenu == null) {\n                return;\n        }\n        captionPopupMenu.getMenu().removeGroup(POPUP_MENU_ID_CAPTION);\n        captionPopupMenu.setOnDismissListener(this);\n        // Add option for turning off caption\n        final MenuItem captionOffItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, 0, Menu.NONE, R.string.caption_none);\n        captionOffItem.setOnMenuItemClickListener(menuItem -> {final int textRendererIndex = player\n                        .getCaptionRendererIndex();if (textRendererIndex \n                                 != RENDERER_UNAVAILABLE\n                                ) { player.getTrackSelector().setParameters(player\n                                .getTrackSelector()\n                                .buildUponParameters()\n                                .setRendererDisabled(textRendererIndex, true))\n                                ; }player.getPrefs().edit().remove(context\n                        .getString(R.string.caption_user_set_key))\n                        .apply()\n                        ;return true; });\n\n        // Add all available captions\n        for (int i = 0; i < availableLanguages.size(); i++) {\n                final String captionLanguage = availableLanguages.get(i);\n                final MenuItem captionItem = captionPopupMenu.getMenu().add(POPUP_MENU_ID_CAPTION, i + 1, Menu.NONE, captionLanguage);\n                captionItem.setOnMenuItemClickListener(menuItem -> {final int textRendererIndex = player\n                                .getCaptionRendererIndex();if (textRendererIndex \n                                         != RENDERER_UNAVAILABLE\n                                        ) { // DefaultTrackSelector will select for text tracks in the following order.\n                                // When multiple tracks share the same rank, a random track will be chosen.\n                                // 1. ANY track exactly matching preferred language name\n                                // 2. ANY track exactly matching preferred language stem\n                                // 3. ROLE_FLAG_CAPTION track matching preferred language stem\n                                // 4. ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND track matching preferred language stem\n                                // This means if a caption track of preferred language is not available,\n                                // then an auto-generated track of that language will be chosen automatically.\n                                player.getTrackSelector().setParameters(player\n                                        .getTrackSelector()\n                                        .buildUponParameters()\n                                        .setPreferredTextLanguages(captionLanguage,\n                                        PlayerHelper.captionLanguageStemOf(captionLanguage))\n                                        .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                                        .setRendererDisabled(textRendererIndex, false))\n                                        ; player.getPrefs().edit().putString(context\n                                        .getString(R.string.caption_user_set_key), \n                                        captionLanguage)\n                                        .apply()\n                                        ; } return true; });\n        }\n        \n        captionPopupMenu.setOnDismissListener(this);\n        // apply caption language from previous user preference\n        final int textRendererIndex = player.getCaptionRendererIndex();\n        if (textRendererIndex == RENDERER_UNAVAILABLE) {\n                return;\n        }\n\n        // If user prefers to show no caption, then disable the renderer.\n        // Otherwise, DefaultTrackSelector may automatically find an available caption\n        // and display that.\n        final String userPreferredLanguage = player.getPrefs().getString(context.getString(R.string.caption_user_set_key), null);\n        \n        if (userPreferredLanguage == null) {\n                player.getTrackSelector().setParameters(player.getTrackSelector().buildUponParameters().setRendererDisabled(textRendererIndex, true));\n                return;\n        }\n\n        // Only set preferred language if it does not match the user preference,\n        // otherwise there might be an infinite cycle at onTextTracksChanged.\n        final List<String> selectedPreferredLanguages = player.getTrackSelector().getParameters().preferredTextLanguages;\n        \n        if (!selectedPreferredLanguages.contains(userPreferredLanguage)) {\n                player.getTrackSelector().setParameters(player\n                        .getTrackSelector()\n                        .buildUponParameters()\n                        .setPreferredTextLanguages(userPreferredLanguage,\n                        PlayerHelper.captionLanguageStemOf(userPreferredLanguage))\n                        .setPreferredTextRoleFlags(C.ROLE_FLAG_CAPTION)\n                        .setRendererDisabled(textRendererIndex, false));\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "27", "src_id": "M741", "code": "private void onItemSelectedSetFileName() {\n        final String fileName = FilenameUtils.createFilename(getContext(), currentInfo.getName());\n        final String prevFileName = Optional.ofNullable(dialogBinding.fileName.getText()).map(Object::toString).orElse(\"\");\n\n        if (prevFileName.isEmpty() || prevFileName.equals(fileName) || prevFileName.startsWith(getString(R.string.caption_file_name, fileName, \"\"))) { // only update the file name field if it was not edited by the user\n                \n                switch (dialogBinding.videoAudioGroup.getCheckedRadioButtonId()) {\n                        case R.id.audio_button:\n                        case R.id.video_button:\n                                if (!prevFileName.equals(fileName)) {\n                                        // since the user might have switched between audio and video, the correct\n                                        // text might already be in place, so avoid resetting the cursor position\n                                        dialogBinding.fileName.setText(fileName);\n                                }\n                                break;\n                        case R.id.subtitle_button:\n                                final String setSubtitleLanguageCode = subtitleStreamsAdapter.getItem(selectedSubtitleIndex).getLanguageTag();\n                                // this will reset the cursor position, which is bad UX, but it can't be avoided\n                                dialogBinding.fileName.setText(getString(R.string.caption_file_name, fileName, setSubtitleLanguageCode));\n                                break;\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "28", "src_id": "M327", "code": "protected void deinitListeners() {\n        binding.qualityTextView.setOnClickListener(null);\n        binding.audioTrackTextView.setOnClickListener(null);\n        binding.playbackSpeed.setOnClickListener(null);\n        binding.playbackSeekBar.setOnSeekBarChangeListener(null);\n        binding.captionTextView.setOnClickListener(null);\n        binding.resizeTextView.setOnClickListener(null);\n        binding.playbackLiveSync.setOnClickListener(null);\n        binding.getRoot().setOnTouchListener(null);\n        playerGestureListener = null;\n        gestureDetector = null;\n        binding.repeatButton.setOnClickListener(null);\n        binding.shuffleButton.setOnClickListener(null);\n        binding.playPauseButton.setOnClickListener(null);\n        binding.playPreviousButton.setOnClickListener(null);\n        binding.playNextButton.setOnClickListener(null);\n        binding.moreOptionsButton.setOnClickListener(null);\n        binding.moreOptionsButton.setOnLongClickListener(null);\n        binding.share.setOnClickListener(null);\n        binding.share.setOnLongClickListener(null);\n        binding.fullScreenButton.setOnClickListener(null);\n        binding.screenRotationButton.setOnClickListener(null);\n        binding.playWithKodi.setOnClickListener(null);\n        binding.openInBrowser.setOnClickListener(null);\n        binding.playerCloseButton.setOnClickListener(null);\n        binding.switchMute.setOnClickListener(null);\n        ViewCompat.setOnApplyWindowInsetsListener(binding.itemsListPanel, null);\n        binding.playbackControlRoot.removeOnLayoutChangeListener(onLayoutChangeListener);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "29", "src_id": "M239", "code": "private void updatePlaybackState(final boolean playWhenReady, final int playbackState) {\n        if (DEBUG) {\n                Log.d(TAG, \"ExoPlayer - updatePlaybackState() called with: \"\n                         + \"playWhenReady = [\" \n                         + playWhenReady \n                         + \"], \"\n                         + \"playbackState = [\" \n                         + playbackState \n                         + \"]\");\n        }\n\n        if (currentState == STATE_PAUSED_SEEK) {\n                if (DEBUG) {\n                        Log.d(TAG, \"updatePlaybackState() is currently blocked\");\n                }\n                return;\n        }\n\n        switch (playbackState) {\n                case com.google.android.exoplayer2.Player.STATE_IDLE: // 1\n                \n                        isPrepared = false;\n                        break;\n                case com.google.android.exoplayer2.Player.STATE_BUFFERING: // 2\n                \n                        if (isPrepared) {\n                                changeState(STATE_BUFFERING);\n                        }\n                        break;\n                case com.google.android.exoplayer2.Player.STATE_READY: //3\n                \n                        if (!isPrepared) {\n                                isPrepared = true;\n                                onPrepared(playWhenReady);\n                        }\n                        changeState(playWhenReady ? STATE_PLAYING : STATE_PAUSED);\n                        break;\n                case com.google.android.exoplayer2.Player.STATE_ENDED: // 4\n                \n                        changeState(STATE_COMPLETED);\n                        saveStreamProgressStateCompleted();\n                        isPrepared = false;\n                        break;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "129", "src_id": "M454", "code": "    private void setupMainFrame() {\n        frame = new JFrame(\"Stirling-PDF\");\n        frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n        frame.setUndecorated(true);\n        frame.setOpacity(0.0f);\n\n        JPanel contentPane = new JPanel(new BorderLayout());\n\n        contentPane.setDoubleBuffered(true);\n        contentPane.add(browser.getUIComponent(), BorderLayout.CENTER);\n        frame.setContentPane(contentPane);\n        frame.addWindowListener(new java.awt.event.WindowAdapter() {@Override public void windowClosing(java.awt.event.WindowEvent windowEvent) {cleanup()\n                ; System.exit(0);}});\n        frame.setSize(UIScaling.scaleWidth(1280), UIScaling.scaleHeight(800));\n        frame.setLocationRelativeTo(null);\n        loadIcon();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "130", "src_id": "M604", "code": "    @Operation(\n    summary = \"Get form field information\",\n    description = \n    \"Returns count and details of form fields. Input:PDF Output:JSON Type:SISO\")\n    @PostMapping(value = \"/form-fields\", consumes = \"multipart/form-data\")\n    public Map<String, Object> getFormFields(@ModelAttribute PDFFile file) throws IOException {\n        try (PDDocument document = pdfDocumentFactory.load(file.getFileInput())) {\n            Map<String, Object> formInfo = new HashMap<>();\n            PDAcroForm form = document.getDocumentCatalog().getAcroForm();\n\n            if (form != null) {\n                formInfo.put(\"fieldCount\", form.getFields().size());\n                formInfo.put(\"hasXFA\", form.hasXFA());\n                formInfo.put(\"isSignaturesExist\", form.isSignaturesExist());\n            } else {\n                formInfo.put(\"fieldCount\", 0);\n                formInfo.put(\"hasXFA\", false);\n                formInfo.put(\"isSignaturesExist\", false);\n            }\n            return formInfo;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "131", "src_id": "M443", "code": "    private void checkAndRefreshExplorer() {\n        if (!IS_WINDOWS) {\n            return;\n        }\n\n        if (timeAt90Percent == -1) {\n            timeAt90Percent = System.currentTimeMillis();\n            stuckTimer = new Timer(1000, e -> {long currentTime = System\n                .currentTimeMillis();if (currentTime - timeAt90Percent \n                    > stuckThreshold\n                    ) {try {log.debug(\"Attempting Windows explorer refresh due to 90% stuck state\")\n                        ; String currentDir = System.getProperty(\"user.dir\");// Store current explorer PIDs before we start new one\n                        Set<String> existingPids = new HashSet<>(); ProcessBuilder listExplorer = new ProcessBuilder(\"cmd\",\n                        \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\",\n                        \"get\", \"ProcessId\", \"/format:csv\"); Process process = listExplorer\n                        .start(); BufferedReader reader = new BufferedReader(new InputStreamReader(process\n                        .getInputStream())); String line;while ((line = BoundedLineReader\n                            .readLine(reader, 5_000_000)\n                            )\n                             != null\n                            ) {if (!(line.matches(\".*\\\\d+.*\"))) { continue; }  String[] parts = line\n                            .trim()\n                            .split(\",\");if (parts.length >= 2) {existingPids.add(parts[parts.length - 1].trim());}}process.waitFor(2, TimeUnit.SECONDS);// Start new explorer\n                        ProcessBuilder pb = new ProcessBuilder(\"cmd\", \"/c\", \"start\", \"/min\", \"/b\", \"explorer.exe\", currentDir); pb.redirectErrorStream(true); explorerProcess = pb.start();// Schedule cleanup\n                        Timer cleanupTimer = new Timer(2000, cleanup -> {try {// Find new explorer processes\n                                ProcessBuilder findNewExplorer = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\", \"get\", \"ProcessId\", \"/format:csv\"); Process newProcess = findNewExplorer.start(); BufferedReader newReader = new BufferedReader(new InputStreamReader(newProcess.getInputStream())); String newLine;while ((newLine = BoundedLineReader.readLine(newReader, 5_000_000)) != null) {if (!(newLine.matches(\".*\\\\d+.*\"))) { continue; }  String[] parts = newLine.trim().split(\",\");if (parts.length < 2) { continue; }  String pid = parts[parts.length - 1].trim();if (existingPids.contains(pid)) { continue; }  log.debug(\"Found new explorer.exe with PID: \" + pid); ProcessBuilder killProcess = new ProcessBuilder(\"taskkill\", \"/PID\", pid, \"/F\"); killProcess.redirectErrorStream(true); Process killResult = killProcess.start(); killResult.waitFor(2, TimeUnit.SECONDS); log.debug(\"Explorer process terminated: \" + pid);}newProcess.waitFor(2, TimeUnit.SECONDS);} catch (Exception ex) {log.error(\"Error cleaning up Windows explorer process\", ex);}}); cleanupTimer.setRepeats(false); cleanupTimer.start(); stuckTimer.stop();} catch (Exception ex) {log.error(\"Error refreshing Windows explorer\", ex);}}});\n            stuckTimer.setRepeats(true);\n            stuckTimer.start();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "132", "src_id": "M542", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/compress-pdf\")\n    @Operation(\n    summary = \"Optimize PDF file\",\n    description = \n    \"This endpoint accepts a PDF file and optimizes it based on the provided\"\n    + \" parameters. Input:PDF Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> optimizePdf(@ModelAttribute OptimizePdfRequest request) throws Exception {\n        MultipartFile inputFile = request.getFileInput();\n        Integer optimizeLevel = request.getOptimizeLevel();\n        String expectedOutputSizeString = request.getExpectedOutputSize();\n        Boolean convertToGrayscale = request.getGrayscale();\n\n        if (expectedOutputSizeString == null && optimizeLevel == null) {\n            throw new Exception(\"Both expected output size and optimize level are not specified\");\n        }\n\n        Long expectedOutputSize = 0L;\n        boolean autoMode = false;\n\n        if (expectedOutputSizeString != null && expectedOutputSizeString.length() > 1) {\n            expectedOutputSize = GeneralUtils.convertSizeToBytes(expectedOutputSizeString);\n            autoMode = true;\n        }\n\n        // Create initial input file\n        Path originalFile = Files.createTempFile(\"original_\", \".pdf\");\n\n        inputFile.transferTo(originalFile.toFile());\n\n        long inputFileSize = Files.size(originalFile);\n        Path currentFile = Files.createTempFile(\"working_\", \".pdf\");\n\n        Files.copy(originalFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n\n        // Keep track of all temporary files for cleanup\n        List<Path> tempFiles = new ArrayList<>();\n\n        tempFiles.add(originalFile);\n        tempFiles.add(currentFile);\n        try {\n            if (autoMode) {\n                double sizeReductionRatio = expectedOutputSize / (double) inputFileSize;\n\n                optimizeLevel = determineOptimizeLevel(sizeReductionRatio);\n            }\n\n            boolean sizeMet = false;\n            boolean imageCompressionApplied = false;\n            boolean externalCompressionApplied = false;\n\n            while (!sizeMet && optimizeLevel <= 9) {\n                // Apply external compression first\n                if (!externalCompressionApplied) {\n                    boolean ghostscriptSuccess = false;\n\n                    // Try Ghostscript first if available - for ANY compression level\n                    if (isGhostscriptEnabled()) {\n                        try {\n                            applyGhostscriptCompression(request, optimizeLevel, currentFile, tempFiles);\n                            log.info(\"Ghostscript compression applied successfully\");\n                            ghostscriptSuccess = true;\n                        } catch (IOException e) {\n                                log.warn(\"Ghostscript compression failed, trying fallback methods\");\n                            }\n\n                    }\n\n                    // Fallback to QPDF if Ghostscript failed or not available (levels 1-3 only)\n                    if (!ghostscriptSuccess && isQpdfEnabled() && optimizeLevel <= 3) {\n                        try {\n                            applyQpdfCompression(request, optimizeLevel, currentFile, tempFiles);\n                            log.info(\"QPDF compression applied successfully\");\n                        } catch (IOException e) {\n                                log.warn(\"QPDF compression also failed\");\n                            }\n\n                    }\n\n                    if (!ghostscriptSuccess && !isQpdfEnabled()) {\n                        log.info(\"No external compression tools available, using image compression only\");\n                    }\n                    externalCompressionApplied = true;\n\n                    // Skip image compression if Ghostscript succeeded\n                    if (ghostscriptSuccess) {\n                        imageCompressionApplied = true;\n                    }\n                }\n\n                // Apply image compression for levels 4+ only if Ghostscript didn't run\n                if ((optimizeLevel >= 4 || Boolean.TRUE.equals(convertToGrayscale)) && !imageCompressionApplied) {\n                    // Use different scale factors based on level\n                    double scaleFactor = switch (optimizeLevel) {case 4 -> 0.95; // 95% of original size\n                        case 5 -> 0.9; // 90% of original size\n                        case 6 -> 0.8; // 80% of original size\n                        case 7 -> 0.7; // 70% of original size\n                        case 8 -> 0.65; // 65% of original size\n                        case 9 -> 0.5; // 50% of original size\n                        default -> 1.0;};\n\n                    log.info(\"Applying image compression with scale factor: {}\", scaleFactor);\n\n                    Path compressedImageFile = compressImagesInPDF(currentFile, scaleFactor, 0.7f, // Default JPEG quality\n                    Boolean.TRUE.equals(convertToGrayscale));\n\n                    tempFiles.add(compressedImageFile);\n                    currentFile = compressedImageFile;\n                    imageCompressionApplied = true;\n                }\n\n                // Check if target size reached or not in auto mode\n                long outputFileSize = Files.size(currentFile);\n\n                if (outputFileSize <= expectedOutputSize || !autoMode) {\n                    sizeMet = true;\n                } else {\n                    int newOptimizeLevel = incrementOptimizeLevel(optimizeLevel, outputFileSize, expectedOutputSize);\n\n                    // Check if we can't increase the level further\n                    if (newOptimizeLevel == optimizeLevel) {\n                        if (autoMode) {\n                            log.info(\"Maximum optimization level reached without meeting target size.\");\n                            sizeMet = true;\n                        }\n                    } else {\n                        // Reset flags for next iteration with higher optimization level\n                        imageCompressionApplied = false;\n                        externalCompressionApplied = false;\n                        optimizeLevel = newOptimizeLevel;\n                    }\n                }\n            }\n\n\n            // Use original if optimized file is somehow larger\n            long finalFileSize = Files.size(currentFile);\n\n            if (finalFileSize >= inputFileSize) {\n                log.warn(\"Optimized file is larger than the original. Using the original file instead.\");\n                currentFile = originalFile;\n            }\n\n            String outputFilename = Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_Optimized.pdf\";\n\n            return WebResponseUtils.pdfDocToWebResponse(pdfDocumentFactory.load(currentFile.toFile()), outputFilename);\n        } finally {\n                // Clean up all temporary files\n                for (Path tempFile:tempFiles) {\n                    try {\n                        Files.deleteIfExists(tempFile);\n                    } catch (IOException e) {\n                            log.warn(\"Failed to delete temporary file: \" + tempFile, e);\n                        }\n\n                }\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "133", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            // Metadata using PDFBox\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode();\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            ObjectNode encryption = objectMapper.createObjectNode();\n            ObjectNode other = objectMapper.createObjectNode();\n\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n\n            // Total file size of the PDF\n            long fileSizeInBytes = inputFile.getSize();\n\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n            // Number of words, paragraphs, and images in the entire document\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n            int wordCount = words.length;\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n\n            // Number of characters in the entire document (including spaces and special characters)\n            int charCount = fullText.length();\n\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            // Initialize the flags and types\n            boolean hasCompression = false;\n            String compressionType = \"None\";\n\n            basicInfo.put(\"Compression\", hasCompression);\n\n            if (hasCompression) basicInfo.put(\"CompressionType\", compressionType);\n\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            String pageMode = catalog.getPageMode().name();\n\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n            ;\n\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n\n            if (acroForm != null) {\n                for (PDField field:acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n\n            // Generate structured summary data about PDF characteristics\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n\n            // embeed files TODO size\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry:\n                            efMap.entrySet()) {\n                            ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n\n            // attachments TODO size\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n\n            for (PDPage page:pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation:page.getAnnotations()) {\n                    if (!(annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation)) { \n                        continue; \n                    }  \n\n                    ObjectNode attachmentNode = objectMapper.createObjectNode();\n\n                    attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                    attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                    attachmentsArray.add(attachmentNode);\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n\n            // Javascript\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n\n                if (javascriptDict != null) {\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n\n                        for (Map.Entry<String, PDActionJavaScript> entry:jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n\n                            jsNode.put(\"JS Name\", entry.getKey());\n\n                            PDActionJavaScript jsAction = entry.getValue();\n\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                            log.error(\"exception\", e);\n                        }\n\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n\n            // TODO size\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg:ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n\n                    layerNode.put(\"Name\", ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n            other.set(\"Layers\", layersArray);\n            // TODO Security\n\n\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            ArrayNode structureTreeArray;\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                }\n            } catch (Exception e) {\n                    // TODO Auto-generated catch block\n                    log.error(\"exception\", e);\n                }\n\n\n            boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n            boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n            boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n            boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n            boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n            boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n\n            // an official ISO standard.\n            boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n\n            // development in 2021.\n\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n\n            if (root != null) {\n                for (PDOutlineItem child:root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            String xmpString = null;\n\n            if (pdMetadata != null) {\n                try {\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        DomXmpParser domXmpParser = new DomXmpParser();\n                        XMPMetadata xmpMeta = domXmpParser.parse(is);\n                        ByteArrayOutputStream os = new ByteArrayOutputStream();\n\n                        new XmpSerializer().serialize(xmpMeta, os, true);\n                        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                    }\n                } catch (XmpParsingException e) {\n                        // XMP parsing failed, try to read raw metadata instead\n                        log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                        try (COSInputStream is = pdMetadata.createInputStream()) {\n                            byte[] metadataBytes = is.readAllBytes();\n\n                            xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n\n            }\n            other.put(\"XMPMetadata\", xmpString);\n\n            if (pdfBoxDoc.isEncrypted()) {\n                encryption.put(\"IsEncrypted\", true);\n\n                // Retrieve encryption details using getEncryption()\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n            // Add other encryption-related properties as needed\n            } else {\n                encryption.put(\"IsEncrypted\", false);\n            }\n\n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                // Retrieve the page\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n                // Page-level Information\n                PDRectangle mediaBox = page.getMediaBox();\n                float width = mediaBox.getWidth();\n                float height = mediaBox.getHeight();\n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n\n                // Assuming the following boxes are defined for your document; if not, you may get\n                // null values.\n                PDRectangle cropBox = page.getCropBox();\n\n                pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\":cropBox.toString());\n\n                PDRectangle bleedBox = page.getBleedBox();\n\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\":bleedBox.toString());\n\n                PDRectangle trimBox = page.getTrimBox();\n\n                pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\":trimBox.toString());\n\n                PDRectangle artBox = page.getArtBox();\n\n                pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\":artBox.toString());\n\n                // Content Extraction\n                PDFTextStripper textStripper = new PDFTextStripper();\n\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n\n                String pageText = textStripper.getText(pdfBoxDoc);\n\n                pageInfo.put(\"Text Characters Count\", pageText.length()); //\n\n                // Annotations\n\n                List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation annotation:annotations) {\n                    if (annotation.getSubtype() != null) {\n                        subtypeCount++; // Increase subtype count\n\n                    }\n                    if (annotation.getContents() != null) {\n                        contentsCount++; // Increase contents count\n\n                    }\n                }\n\n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n\n                // Images (simplified)\n                // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                // Here is a basic structure to recognize image XObjects on a page.\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                PDResources resources = page.getResources();\n\n                for (COSName name:resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n\n                    if (!(xObject instanceof PDImageXObject image)) { \n                        continue; \n                    }  \n\n                    ObjectNode imageNode = objectMapper.createObjectNode();\n\n                    imageNode.put(\"Width\", image.getWidth());\n                    imageNode.put(\"Height\", image.getHeight());\n\n                    if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                        imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                    }\n\n                    if (image.getColorSpace() != null) {\n                        imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                    }\n                    imagesArray.add(imageNode);\n                }\n                pageInfo.set(\"Images\", imagesArray);\n\n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n                Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n                for (PDAnnotation annotation:annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n\n                        uniqueURIs.add(uri); // Add to set to ensure uniqueness\n\n                    }\n                }\n\n                // Add unique URIs to linksArray\n                for (String uri:uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n\n                pageInfo.set(\"Links\", linksArray);\n\n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n\n                for (COSName fontName:resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n\n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n\n                        int flags = fontDescriptor.getFlags();\n\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        // Font stretch and BBox are not directly available in PDFBox's API, so\n                        // these are omitted for simplicity\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n\n                    // Create a unique key for this font node based on its attributes\n                    String uniqueKey = fontNode.toString();\n\n                    // Increment count if this font exists, or initialize it if new\n                    if (uniqueFontsMap.containsKey(uniqueKey)) {\n                        ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        int count = existingFontNode.get(\"Count\").asInt() + 1;\n\n                        existingFontNode.put(\"Count\", count);\n                    } else {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    }\n                }\n\n                // Add unique font entries to fontsArray\n                for (ObjectNode uniqueFontNode:uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n\n                pageInfo.set(\"Fonts\", fontsArray);\n\n                // Access resources dictionary\n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n\n                for (COSName name:colorSpaceNames) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n\n                    if (!(colorSpace instanceof PDICCBased iccBased)) { \n                        continue; \n                    }  \n\n                    PDStream iccData = iccBased.getPDStream();\n                    byte[] iccBytes = iccData.toByteArray();\n                    // TODO: Further decode and analyze the ICC data if needed\n                    ObjectNode iccProfileNode = objectMapper.createObjectNode();\n\n                    iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                    colorSpacesArray.add(iccProfileNode);\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n                // Other XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n\n\n                for (COSName name:resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType;\n\n                    if (xObject instanceof PDImageXObject) {\n                        xObjectType = \"Image\";\n                    } else if (xObject instanceof PDFormXObject) {\n                        xObjectType = \"Form\";\n                    } else {\n                        xObjectType = \"Other\";\n                    }\n\n                    // Increment the count for this type in the map\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n\n                // Add the count map to pageInfo (or wherever you want to store it)\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry:xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n                ArrayNode multimediaArray = objectMapper.createArrayNode();\n                for (PDAnnotation annotation:annotations) {\n                    if (!(\"RichMedia\".equals(annotation.getSubtype()))) { \n                        continue; \n                    }  \n\n                    ObjectNode multimediaNode = objectMapper.createObjectNode();\n\n                    // Extract details from the annotation as needed\n                    multimediaArray.add(multimediaNode);\n                }\n\n                pageInfo.set(\"Multimedia\", multimediaArray);\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Encryption\", encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n\n            jsonOutput.set(\"Other\", other);\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n            // Save JSON to file\n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n\n            return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n                log.error(\"exception\", e);\n            }\n\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "134", "src_id": "M518", "code": "    public static boolean isBlankImage(BufferedImage image, int threshold, double whitePercent, int blurSize) {\n        if (image == null) {\n            log.info(\"Error: Image is null\");\n            return false;\n        }\n\n        // Convert to binary image based on the threshold\n        int whitePixels = 0;\n        int totalPixels = image.getWidth() * image.getHeight();\n        for (int i = 0; i < image.getHeight(); i++) {\n            for (int j = 0; j < image.getWidth(); j++) {\n                int color = image.getRGB(j, i) & 0xFF;\n\n                if (color >= 255 -threshold) {\n                    whitePixels++;\n                }\n            }\n        }\n\n        double whitePixelPercentage = (whitePixels / (double) totalPixels) * 100;\n\n        log.info(String.format(\"Page has white pixel percent of %.2f%%\", whitePixelPercentage));\n        return whitePixelPercentage >= whitePercent;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "135", "src_id": "M483", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/filter-page-count\")\n    @Operation(\n    summary = \"Checks if a PDF is greater, less or equal to a setPageCount\",\n    description = \"Input:PDF Output:Boolean Type:SISO\")\n    public ResponseEntity<byte[]> pageCount(@ModelAttribute PDFComparisonAndCount request) throws IOException, InterruptedException {\n        MultipartFile inputFile = request.getFileInput();\n        int pageCount = request.getPageCount();\n        String comparator = request.getComparator();\n        // Load the PDF\n        PDDocument document = pdfDocumentFactory.load(inputFile);\n        int actualPageCount = document.getNumberOfPages();\n        boolean valid = false;\n\n        // Perform the comparison\n        switch (comparator) {\n            case \"Greater\":\n                valid = actualPageCount > pageCount;\n                break;\n            case \"Equal\":\n                valid = actualPageCount == pageCount;\n                break;\n            case \"Less\":\n                valid = actualPageCount < pageCount;\n                break;\n            default:\n                throw ExceptionUtils.createInvalidArgumentException(\"comparator\", comparator);\n        }\n\n        if (valid) return WebResponseUtils.multiPartFileToWebResponse(inputFile);\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "136", "src_id": "M475", "code": "    private void handleSplitBySize(PDDocument sourceDocument, long maxBytes, ZipOutputStream zipOut, String baseFilename) throws IOException {\n        log.debug(\"Starting handleSplitBySize with maxBytes={}\", maxBytes);\n\n        PDDocument currentDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(sourceDocument);\n        int fileIndex = 1;\n        int totalPages = sourceDocument.getNumberOfPages();\n        int pageAdded = 0;\n        // Smart size check frequency - check more often with larger documents\n        int baseCheckFrequency = 5;\n\n        for (int pageIndex = 0; pageIndex < totalPages; pageIndex++) {\n            PDPage page = sourceDocument.getPage(pageIndex);\n\n            log.debug(\"Processing page {} of {}\", pageIndex + 1, totalPages);\n\n            // Add the page to current document\n            PDPage newPage = new PDPage(page.getCOSObject());\n\n            currentDoc.addPage(newPage);\n            pageAdded++;\n\n            // Dynamic size checking based on document size and page count\n            boolean shouldCheckSize = (pageAdded % baseCheckFrequency == 0) || (pageIndex == totalPages - 1) || (pageAdded >= 20); // Always check after 20 pages\n\n\n            if (!shouldCheckSize) { \n                continue; \n            }  \n            log.debug(\"Performing size check after {} pages\", pageAdded);\n\n            ByteArrayOutputStream checkSizeStream = new ByteArrayOutputStream();\n\n            currentDoc.save(checkSizeStream);\n\n            long actualSize = checkSizeStream.size();\n\n            log.debug(\"Current document size: {} bytes (max: {} bytes)\", actualSize, maxBytes);\n\n            if (actualSize > maxBytes) {\n                // We exceeded the limit - remove the last page and save\n                if (currentDoc.getNumberOfPages() > 1) {\n                    currentDoc.removePage(currentDoc.getNumberOfPages() - 1);\n                    pageIndex--; // Process this page again in the next document\n\n                    log.debug(\"Size limit exceeded - removed last page\");\n                }\n                log.debug(\"Saving document with {} pages as part {}\", currentDoc.getNumberOfPages(), fileIndex);\n                saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n                currentDoc = new PDDocument();\n                pageAdded = 0;\n            } else if (pageIndex < totalPages - 1 && (actualSize < maxBytes * 0.75 && pageAdded > 0)) {\n                // Rather than using a ratio, look ahead to test actual upcoming pages\n                int pagesToLookAhead = Math.min(5, totalPages - pageIndex - 1);\n\n                if (pagesToLookAhead > 0) {\n                    log.debug(\"Testing {} upcoming pages for potential addition\", pagesToLookAhead);\n\n                    // Create a temp document with current pages + look-ahead pages\n                    PDDocument testDoc = new PDDocument();\n                    // First copy existing pages\n                    for (int i = 0; i < currentDoc.getNumberOfPages(); i++) {\n                        testDoc.addPage(new PDPage(currentDoc.getPage(i).getCOSObject()));\n                    }\n\n                    // Try adding look-ahead pages one by one\n                    int extraPagesAdded = 0;\n\n                    for (int i = 0; i < pagesToLookAhead; i++) {\n                        int testPageIndex = pageIndex + 1 + i;\n                        PDPage testPage = sourceDocument.getPage(testPageIndex);\n\n                        testDoc.addPage(new PDPage(testPage.getCOSObject()));\n\n                        // Check if we're still under size\n                        ByteArrayOutputStream testStream = new ByteArrayOutputStream();\n\n                        testDoc.save(testStream);\n                        long testSize = testStream.size();\n\n                        if (testSize <= maxBytes) {\n                            extraPagesAdded++;\n                            log.debug(\"Test: Can add page {} (size would be {})\", testPageIndex + 1, testSize);\n                        } else {\n                            log.debug(\"Test: Cannot add page {} (size would be {})\", testPageIndex + 1, testSize);\n                            break;\n                        }\n                    }\n                    testDoc.close();\n\n                    // Add the pages we verified would fit\n                    if (extraPagesAdded > 0) {\n                        log.debug(\"Adding {} verified pages ahead\", extraPagesAdded);\n\n                        for (int i = 0; i < extraPagesAdded; i++) {\n                            int extraPageIndex = pageIndex + 1 + i;\n                            PDPage extraPage = sourceDocument.getPage(extraPageIndex);\n\n                            currentDoc.addPage(new PDPage(extraPage.getCOSObject()));\n                        }\n\n                        pageIndex += extraPagesAdded;\n                        pageAdded += extraPagesAdded;\n                    }\n                }\n            }\n\n        }\n\n        // Save final document if it has any pages\n        if (currentDoc.getNumberOfPages() > 0) {\n            log.debug(\"Saving final document with {} pages as part {}\", currentDoc.getNumberOfPages(), fileIndex);\n            saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n        }\n        log.debug(\"Completed handleSplitBySize with {} document parts created\", fileIndex - 1);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "137", "src_id": "M291", "code": "    public static File convertMultipartFileToFile(MultipartFile multipartFile) throws IOException {\n        String customTempDir = System.getenv(\"STIRLING_TEMPFILES_DIRECTORY\");\n\n        if (customTempDir == null || customTempDir.isEmpty()) {\n            customTempDir = System.getProperty(\"stirling.tempfiles.directory\");\n        }\n\n        File tempFile;\n\n        if (customTempDir != null && !customTempDir.isEmpty()) {\n            Path tempDir = Path.of(customTempDir);\n\n            if (!Files.exists(tempDir)) {\n                Files.createDirectories(tempDir);\n            }\n            tempFile = Files.createTempFile(tempDir, \"stirling-pdf-\", null).toFile();\n        } else {\n            Path tempDir = Path.of(System.getProperty(\"java.io.tmpdir\"), \"stirling-pdf\");\n\n            if (!Files.exists(tempDir)) {\n                Files.createDirectories(tempDir);\n            }\n            tempFile = Files.createTempFile(tempDir, \"stirling-pdf-\", null).toFile();\n        }\n\n        try (InputStream inputStream = multipartFile.getInputStream();\n            FileOutputStream outputStream = new FileOutputStream(tempFile)) {\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = inputStream.read(buffer)) != -1) {\n                outputStream.write(buffer, 0, bytesRead);\n            }\n        }\n        return tempFile;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "138", "src_id": "M254", "code": "    private void cleanupTempFiles() {\n        try {\n            // Clean up all registered files\n            Set<Path> files = registry.getAllRegisteredFiles();\n            int deletedCount = 0;\n            for (Path file:files) {\n                try {\n                    if (Files.exists(file)) {\n                        Files.deleteIfExists(file);\n                        deletedCount++;\n                    }\n                } catch (IOException e) {\n                        log.warn(\"Failed to delete temp file during shutdown: {}\", file, e);\n                    }\n\n            }\n\n            // Clean up all registered directories\n            Set<Path> directories = registry.getTempDirectories();\n            for (Path dir:directories) {\n                try {\n                    if (Files.exists(dir)) {\n                        GeneralUtils.deleteDirectory(dir);\n                        deletedCount++;\n                    }\n                } catch (IOException e) {\n                        log.warn(\"Failed to delete temp directory during shutdown: {}\", dir, e);\n                    }\n\n            }\n\n            log.info(\"Shutdown cleanup complete. Deleted {} temporary files/directories\", deletedCount);\n            // Clear the registry\n            registry.clear();\n        } catch (Exception e) {\n                log.error(\"Error during shutdown cleanup\", e);\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "338", "src_id": "M852", "code": "    public InputStream getView(final int size) {\n        if (view == null) {\n            view = new InputStream() {@Override public int read() throws IOException {if (viewSize \n                                < 1\n                                ) {return -1;} final int res = DataReader\n                            .this\n                            .read();if (res > 0) {viewSize\n                                --\n                                ;} return res;}@Override public int read(final byte[] buffer) throws IOException {return read(buffer, \n                            0, buffer.length)\n                            ;}@Override public int read(final byte[] buffer, final int offset, final int count) throws IOException {if (viewSize \n                        < 1\n                        ) {return -1;} final int res = DataReader.this.read(buffer, offset, Math.min(viewSize, count)); viewSize -= res;return res;}@Override public long skip(final long amount) throws IOException {if (viewSize < 1) {return 0;} final int res = (int) DataReader.this.skipBytes(Math.min(amount, viewSize)); viewSize -= res;return res;}@Override public int available() {return viewSize;}@Override public void close() {viewSize = 0;}@Override public boolean markSupported() {return false;}};\n        }\n\n        viewSize = size;\n        return view;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "339", "src_id": "M1086", "code": "    private ArrayList<Object> getSpecialItems() {\n        synchronized (DownloadManager.this) {\n            ArrayList<Mission> pending = new ArrayList<>(mMissionsPending);\n\n            ArrayList<Mission> finished = new ArrayList<>(mMissionsFinished);\n\n            List<Mission> remove = new ArrayList<>(hidden);\n            // hide missions (if required)\n            remove.removeIf(mission -> pending.remove(mission) || finished.remove(mission));\n\n            int fakeTotal = pending.size();\n            if (fakeTotal > 0) {\n                fakeTotal++;\n            }\n            fakeTotal += finished.size();\n\n            if (finished.size() > 0) {\n                fakeTotal++;\n            }\n            ArrayList<Object> list = new ArrayList<>(fakeTotal);\n            if (pending.size() > 0) {\n                list.add(PENDING);\n                list.addAll(pending);\n            }\n            if (finished.size() > 0) {\n                list.add(FINISHED);\n                list.addAll(finished);\n            }\n            hasFinished = finished.size() > 0;\n            return list;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "340", "src_id": "M1066", "code": "    private void loadPendingMissions(Context ctx) {\n        File[] subs = mPendingMissionsDir.listFiles();\n        if (subs == null) {\n            Log.e(TAG, \"listFiles() returned null\");\n            return;\n        }\n        if (subs.length < 1) {\n            return;\n        }\n        if (DEBUG) {\n            Log.d(TAG, \"Loading pending downloads from directory: \" + mPendingMissionsDir.getAbsolutePath());\n        }\n        File tempDir = pickAvailableTemporalDir(ctx);\n        Log.i(TAG, \"using '\" + tempDir + \"' as temporal directory\");\n\n        for (File sub : subs) {\n            if (sub.isFile()) { \n                if (sub.getName().equals(\".tmp\")) continue;\n                DownloadMission mis = Utility.readFromFile(sub);\n                if (mis == null || mis.isFinished() || mis.hasInvalidStorage()) {\n                    //noinspection ResultOfMethodCallIgnored\n                    sub.delete();\n                    continue;\n                }\n                mis.threads = new Thread[0];\n                boolean exists;\n                try {\n                    mis.storage = StoredFileHelper.deserialize(mis.storage, ctx);\n                    exists = !mis.storage.isInvalid() && mis.storage.existsAsFile();\n                } catch (Exception ex) {\n                        Log.e(TAG, \"Failed to load the file source of \" + mis.storage.toString(), ex);\n                        mis.storage.invalidate();\n                        exists = false;\n                    }\n\n\n                if (mis.isPsRunning()) {\n                    if (mis.psAlgorithm.worksOnSameFile) {\n                        // Incomplete post-processing results in a corrupted download file\n                        // because the selected algorithm works on the same file to save space.\n                        // the file will be deleted if the storage API\n                        // is Java IO (avoid showing the \"Save as...\" dialog)\n                        if (exists && mis.storage.isDirect() && !mis.storage.delete()) Log.w(TAG, \"Unable to delete incomplete download file: \" + sub.getPath());\n                    }\n                    mis.psState = 0;\n                    mis.errCode = DownloadMission.ERROR_POSTPROCESSING_STOPPED;\n                } else if (!exists) {\n                    tryRecover(mis);\n\n                    // the progress is lost, reset mission state\n                    if (mis.isInitialized()) mis.resetState(true, true, DownloadMission.ERROR_PROGRESS_LOST);\n                }\n\n\n                if (mis.psAlgorithm != null) {\n                    mis.psAlgorithm.cleanupTemporalDir();\n                    mis.psAlgorithm.setTemporalDir(tempDir);\n                }\n                mis.metadata = sub;\n                mis.maxRetry = mPrefMaxRetry;\n                mis.mHandler = mHandler;\n                mMissionsPending.add(mis);\n            } \n        }\n\n        if (mMissionsPending.size() > 1) {\n\n            Collections.sort(mMissionsPending, Comparator.comparingLong(Mission::getTimestamp));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "341", "src_id": "M1055", "code": "    public void updateMission(Mission mission) {\n        ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n\n        SQLiteDatabase database = getWritableDatabase();\n        String ts = String.valueOf(mission.timestamp);\n        int rowsAffected;\n        if (mission instanceof FinishedMission) {\n            if (mission.storage.isInvalid()) {\n                rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_TIMESTAMP + \" = ?\", new String[]{ts});\n            } else {\n                rowsAffected = database.update(FINISHED_TABLE_NAME, values, KEY_PATH + \" = ?\", new String[]{mission.storage.getUri().toString()});\n            }\n        } else {\n            throw new UnsupportedOperationException(\"DownloadMission\");\n        }\n\n        if (rowsAffected != 1) {\n            Log.e(\"FinishedMissionStore\", \"Expected 1 row to be affected by update but got \" + rowsAffected);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "342", "src_id": "M1058", "code": "    private void startMission(Intent intent) {\n        String[] urls = intent.getStringArrayExtra(EXTRA_URLS);\n\n        Uri path = IntentCompat.getParcelableExtra(intent, EXTRA_PATH, Uri.class);\n\n        Uri parentPath = IntentCompat.getParcelableExtra(intent, EXTRA_PARENT_PATH, Uri.class);\n\n        int threads = intent.getIntExtra(EXTRA_THREADS, 1);\n        char kind = intent.getCharExtra(EXTRA_KIND, '?');\n\n        String psName = intent.getStringExtra(EXTRA_POSTPROCESSING_NAME);\n\n        String[] psArgs = intent.getStringArrayExtra(EXTRA_POSTPROCESSING_ARGS);\n\n        String source = intent.getStringExtra(EXTRA_SOURCE);\n\n        long nearLength = intent.getLongExtra(EXTRA_NEAR_LENGTH, 0);\n\n        String tag = intent.getStringExtra(EXTRA_STORAGE_TAG);\n\n        final var recovery = IntentCompat.getParcelableArrayListExtra(intent, EXTRA_RECOVERY_INFO, MissionRecoveryInfo.class);\n\n        Objects.requireNonNull(recovery);\n        StoredFileHelper storage;\n        try {\n            storage = new StoredFileHelper(this, parentPath, path, tag);\n        } catch (IOException e) {\n                throw new RuntimeException(e); // this never should happen\n\n            }\n\n\n        Postprocessing ps;\n        if (psName == null) {\n\n            ps = null;\n        } else {\n\n            ps = Postprocessing.getAlgorithm(psName, psArgs);\n        }\n        final DownloadMission mission = new DownloadMission(urls, storage, kind, ps);\n        mission.threadCount = threads;\n        mission.source = source;\n        mission.nearLength = nearLength;\n        mission.recoveryInfo = recovery.toArray(new MissionRecoveryInfo[0]);\n\n        if (ps != null) {\n\n            ps.setTemporalDir(DownloadManager.pickAvailableTemporalDir(this));\n        }\n        handleConnectivityState(true); // first check the actual network status\n\n        mManager.startMission(mission);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "343", "src_id": "M1024", "code": "    @Override\n    public void run() {\n        if (mMission.current > 0) {\n            mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n        }\n        int retryCount = 0;\n        int httpCode = 204;\n        while (true) {\n            try {\n                if (mMission.blocks == null && mMission.current == 0) {\n                    // calculate the whole size of the mission\n                    long finalLength = 0;\n                    long lowestSize = Long.MAX_VALUE;\n                    for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                        mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                        mMission.establishConnection(mId, mConn);\n                        dispose();\n\n                        if (Thread.interrupted()) {\n                            return;\n                        }\n                        long length = Utility.getTotalContentLength(mConn);\n                        if (i == 0) {\n                            httpCode = mConn.getResponseCode();\n                            mMission.length = length;\n                        }\n                        if (length > 0) {\n                            finalLength += length;\n                        }\n                        if (length < lowestSize) {\n                            lowestSize = length;\n                        }\n                    }\n\n                    mMission.nearLength = finalLength;\n\n                    // reserve space at the start of the file\n                    if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                        if (lowestSize < 1) {\n                            // the length is unknown use the default size\n                            mMission.offsets[0] = RESERVE_SPACE_DEFAULT;\n                        } else {\n                            // use the smallest resource size to download, otherwise, use the maximum\n                            mMission.offsets[0] = lowestSize < RESERVE_SPACE_MAXIMUM ? lowestSize : RESERVE_SPACE_MAXIMUM;\n                        }\n                    }\n                } else {\n                    // ask for the current resource length\n                    mConn = mMission.openConnection(true, 0, 0);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (!mMission.running || Thread.interrupted()) {\n                        return;\n                    }\n                    httpCode = mConn.getResponseCode();\n                    mMission.length = Utility.getTotalContentLength(mConn);\n                }\n\n                if (mMission.length == 0 || httpCode == 204) {\n                    mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n                    return;\n                }\n\n                // check for dynamic generated content\n                if (mMission.length == -1 && mConn.getResponseCode() == 200) {\n                    mMission.blocks = new int[0];\n                    mMission.length = 0;\n                    mMission.unknownLength = true;\n\n                    if (DEBUG) {\n                        Log.d(TAG, \"falling back (unknown length)\");\n                    }\n                } else {\n                    // Open again\n                    mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                    mMission.establishConnection(mId, mConn);\n                    dispose();\n\n                    if (!mMission.running || Thread.interrupted()) {\n                        return;\n                    }\n\n                    synchronized (mMission.LOCK) {\n                        if (mConn.getResponseCode() == 206) {\n                            if (mMission.threadCount > 1) {\n                                int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                                if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) {\n                                    count++;\n                                }\n                                mMission.blocks = new int[count];\n                            } else {\n                                // if one thread is required don't calculate blocks, is useless\n                                mMission.blocks = new int[0];\n                                mMission.unknownLength = false;\n                            }\n\n                            if (DEBUG) {\n                                Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                            }\n                        } else {\n                            // Fallback to single thread\n                            mMission.blocks = new int[0];\n                            mMission.unknownLength = false;\n\n                            if (DEBUG) {\n                                Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                            }\n                        }\n                    }\n\n                    if (!mMission.running || Thread.interrupted()) {\n                        return;\n                    }\n                }\n\n                try (SharpStream fs = mMission.storage.getStream()) {\n                    fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                    fs.seek(mMission.offsets[mMission.current]);\n                }\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                    String entityTag = mConn.getHeaderField(\"ETAG\");\n\n                    String lastModified = mConn.getHeaderField(\"Last-Modified\");\n\n                    MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n                    if (!TextUtils.isEmpty(entityTag)) {\n                        recovery.setValidateCondition(entityTag);\n                    } else if (!TextUtils.isEmpty(lastModified)) {\n                        recovery.setValidateCondition(lastModified); // Note: this is less precise\n\n                    } else {\n                        recovery.setValidateCondition(null);\n                    }\n\n                }\n\n                mMission.running = false;\n                break;\n            } catch (InterruptedIOException | ClosedByInterruptException e) {\n                    return;\n                } catch (Exception e) {\n                    if (!mMission.running || super.isInterrupted()) {\n                        return;\n                    }\n                    if (e instanceof DownloadMission.HttpError && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                        // for youtube streams. The url has expired\n                        interrupt();\n                        mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                        return;\n                    }\n\n                    if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                        mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n                        return;\n                    }\n                    if (retryCount++ > mMission.maxRetry) {\n                        Log.e(TAG, \"initializer failed\", e);\n                        mMission.notifyError(e);\n                        return;\n                    }\n                    Log.e(TAG, \"initializer failed, retrying\", e);\n                }\n\n        }\n\n        mMission.start();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "344", "src_id": "M1037", "code": "    public void pause() {\n        if (!running) {\n            return;\n        }\n        if (isPsRunning()) {\n            if (DEBUG) {\n                Log.w(TAG, \"pause during post-processing is not applicable.\");\n            }\n            return;\n        }\n        running = false;\n        notify(DownloadManagerService.MESSAGE_PAUSED);\n\n        if (init != null && init.isAlive()) {\n            // NOTE: if start() method is running Â¡will no have effect!\n            init.interrupt();\n            synchronized (LOCK) {\n                resetState(false, true, ERROR_NOTHING);\n            }\n            return;\n        }\n        if (DEBUG && unknownLength) {\n            Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n        }\n        init = null;\n        pauseThreads();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "345", "src_id": "M1079", "code": "    boolean runMissions() {\n        synchronized (this) {\n            if (mMissionsPending.size() < 1) {\n                return false;\n            }\n            if (!canDownloadInCurrentNetwork()) {\n                return false;\n            }\n            if (mPrefQueueLimit) {\n                for (DownloadMission mission : mMissionsPending) {\n\n                    if (!mission.isFinished() && mission.running) {\n                        return true;\n                    }\n                }\n            }\n            boolean flag = false;\n            for (DownloadMission mission : mMissionsPending) {\n                if (! (mission.running || !mission.enqueued || mission.isFinished())) { \n                    resumeMission(mission);\n\n                    if (mission.errCode != DownloadMission.ERROR_NOTHING) continue;\n                    if (mPrefQueueLimit) return true;\n                    flag = true;\n                } \n            }\n\n            return flag;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "346", "src_id": "M1035", "code": "    private void notifyPostProcessing(int state) {\n        String action;\n        switch (state) {\n            case 1:\n                action = \"Running\";\n                break;\n            case 2:\n                action = \"Completed\";\n                break;\n            default:\n                action = \"Failed\";\n        }\n        Log.d(TAG, action + \" postprocessing on \" + storage.getName());\n\n        if (state == 2) {\n            psState = state;\n            return;\n        }\n        synchronized (LOCK) {\n            // don't return without fully write the current state\n            psState = state;\n            writeThisToFile();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1275", "code": "        @Override\n        public Document build(Object data) {\n            List<KeyValue> list = (List<KeyValue>) data;\n            String id = null;\n            Double score = null;\n            Map<String, Object> fields = null;\n            for (KeyValue kv : list) {\n                String key = BuilderFactory.STRING.build(kv.getKey());\n\n                switch (key) {\n                    case ID_STR:\n                        id = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case SCORE_STR:\n                        score = BuilderFactory.DOUBLE.build(kv.getValue());\n                        break;\n                    case FIELDS_STR:\n                        fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                        break;\n                }\n            }\n            return new Document(id, score, fields);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "76", "src_id": "M889", "code": "        @Override\n        public void addParams(CommandArguments args) {\n            if (timestamp != null) {\n                args.add(TIMESTAMP).add(timestamp);\n            }\n            if (retentionPeriod != null) {\n                args.add(RETENTION).add(toByteArray(retentionPeriod));\n            }\n            if (encoding != null) {\n                args.add(ENCODING).add(encoding);\n            }\n            if (chunkSize != null) {\n                args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n            }\n            if (duplicatePolicy != null) {\n                args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n            }\n            if (ignore) {\n                args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n            }\n\n            if (labels != null) {\n                args.add(LABELS);\n                labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1141", "code": "        @Override\n        public final <T> T executeCommand(CommandObject<T> commandObject) {\n            Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n            int consecutiveConnectionFailures = 0;\n            JedisException lastException = null;\n\n            for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n                Connection connection = null;\n\n                try {\n                    connection = provider.getConnection(commandObject.getArguments());\n                    return execute(connection, commandObject);\n                } catch (JedisConnectionException jce) {\n                        lastException = jce;\n                        consecutiveConnectionFailures++; \n                        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n\n                        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n\n                        if (reset) {\n                            consecutiveConnectionFailures = 0;\n                        }\n                    } finally {\n                        if (connection != null) {\n                            connection.close();\n                        }\n                    }\n\n                if (Instant.now().isAfter(deadline)) {\n                    throw new JedisException(\"Retry deadline exceeded.\");\n                }\n            }\n\n            JedisException maxAttemptsException = new JedisException(\"No more attempts left.\");\n\n            maxAttemptsException.addSuppressed(lastException);\n            throw maxAttemptsException;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "78", "src_id": "M1057", "code": "        @Override\n        public Map.Entry<T, ProfilingInfo> build(Object data) {\n            List list = (List) data;\n            if (list == null || list.isEmpty()) {\n                return null;\n            }\n\n            if (list.get(0) instanceof KeyValue) { // RESP3\n\n                Object resultsData = null;\n                Object profileData = null;\n                for (KeyValue keyValue : (List<KeyValue>) data) {\n                    String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n\n                    switch (keyStr) {\n                        case PROFILE_STR_REDIS7:\n                        case PROFILE_STR_REDIS8:\n                            profileData = keyValue.getValue();\n                            break;\n                        case RESULTS_STR_REDIS7:\n                            resultsData = data;\n                            break;\n                        case RESULTS_STR_REDIS8:\n                            resultsData = keyValue.getValue();\n                            break;\n                    }\n                }\n\n                assert resultsData != null : \"Could not detect Results data.\";\n                assert profileData != null : \"Could not detect Profile data.\";\n                return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n            }\n\n            return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "79", "src_id": "M1102", "code": "        @Override\n        public final List<Object> exec() {\n            if (!inMulti) {\n                throw new IllegalStateException(\"EXEC without MULTI\");\n            }\n\n            try (Connection connection = failoverProvider.getConnection()) {\n                commands.forEach((command) -> connection.sendCommand(command.getKey()));// following connection.getMany(int) flushes anyway, so no flush here.\n\n                // ignore QUEUED (or ERROR)\n                connection.getMany(commands.size());\n                // remove extra response builders\n                for (int idx = 0; idx < extraCommandCount.get(); ++idx) {\n                    commands.poll();\n                }\n                connection.sendCommand(EXEC);\n\n                List<Object> unformatted = connection.getObjectMultiBulkReply();\n\n                if (unformatted == null) {\n                    commands.clear();\n                    return null;\n                }\n\n                List<Object> formatted = new ArrayList<>(unformatted.size() - extraCommandCount.get());\n                for (Object rawReply: unformatted) {\n                    try {\n                        Response<?> response = commands.poll().getValue();\n\n                        response.set(rawReply);\n                        formatted.add(response.get());\n                    } catch (JedisDataException e) {\n                            formatted.add(e);\n                        }\n\n                }\n                return formatted;\n            } finally {\n                    inMulti = false;\n                    inWatch = false;\n                }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "80", "src_id": "M1304", "code": "        @Override\n        public AggregationResult build(Object data) {\n            // return new AggregationResult(data);\n            List list = (List) data;\n\n            if (list.get(0) instanceof KeyValue) {\n                List<KeyValue> kvList = (List<KeyValue>) data;\n                long totalResults = -1;\n                List<Map<String, Object>> results = null;\n                List<String> warnings = null;\n\n                for (KeyValue kv : kvList) {\n                    String key = BuilderFactory.STRING.build(kv.getKey());\n                    Object rawVal = kv.getValue();\n\n                    switch (key) {\n                        case TOTAL_RESULTS_STR:\n                            totalResults = BuilderFactory.LONG.build(rawVal);\n                            break;\n                        case RESULTS_STR:\n                            List<List<KeyValue>> resList = (List<List<KeyValue>>) rawVal;\n                            results = new ArrayList<>(resList.size());\n\n                            for (List<KeyValue> rikv : resList) {\n                                for (KeyValue ikv : rikv) {\n                                    if (FIELDS_STR.equals(BuilderFactory.STRING.build(ikv.getKey()))) {\n                                        results.add(BuilderFactory.ENCODED_OBJECT_MAP.build(ikv.getValue()));\n                                        break;\n                                    }\n                                }\n                            }\n                            break;\n                        case WARNINGS_STR:\n                            warnings = BuilderFactory.STRING_LIST.build(rawVal);\n                            break;\n                    }\n                }\n\n                return new AggregationResult(totalResults, results, warnings);\n            }\n\n            list = (List<Object>) SafeEncoder.encodeObject(data);\n\n            // the first element is always the number of results\n            long totalResults = (Long) list.get(0);\n            List<Map<String, Object>> results = new ArrayList<>(list.size() - 1);\n            for (int i = 1; i < list.size(); i++) {\n                List<Object> mapList = (List<Object>) list.get(i);\n                Map<String, Object> map = new HashMap<>(mapList.size() / 2, 1f);\n                for (int j = 0; j < mapList.size(); j += 2) {\n                    Object r = mapList.get(j);\n                    if (r instanceof JedisDataException) {\n                        throw (JedisDataException) r;\n                    }\n\n                    map.put((String) r, mapList.get(j + 1));\n                }\n                results.add(map);\n            }\n            return new AggregationResult(totalResults, results);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "81", "src_id": "M1219", "code": "        @Override\n        public void run() {\n            running.set(true);\n\n            while (running.get()) {\n                try {\n                    // double check that it is not being shutdown\n                    if (!running.get()) {\n                        break;\n                    }\n\n                    sentinelJedis = new Jedis(node, sentinelClientConfig);\n\n                    // code for active refresh\n                    List<String> masterAddr = sentinelJedis.sentinelGetMasterAddrByName(masterName);\n\n                    if (masterAddr == null || masterAddr.size() != 2) {\n                        LOG.warn(\"Can not get master {} address. Sentinel: {}.\", masterName, node);\n                    } else {\n                        initMaster(toHostAndPort(masterAddr));\n                    }\n\n                    sentinelJedis.subscribe(new JedisPubSub() {@Override public void onMessage(String channel, String message) {LOG\n                            .debug(\"Sentinel {} published: {}.\", \n                            node, message)\n                            ; String[] switchMasterMsg = message\n                            .split(\" \");if (switchMasterMsg\n                                .length \n                                > 3\n                                ) {if (masterName.equals(switchMasterMsg\n                                    [0])\n                                    ) {initMaster(toHostAndPort(switchMasterMsg\n                                    [3], \n                                    switchMasterMsg[4]))\n                                    ;} else {LOG.debug(\"Ignoring message on +switch-master for master {}. Our master is {}.\",\n                                    switchMasterMsg[0], masterName)\n                                    ;}} else {LOG.error(\"Invalid message received on sentinel {} on channel +switch-master: {}.\",\n                                node, message)\n                                ;}}}, \n                    \"+switch-master\");\n                } catch (JedisException e) {\n                        if (running.get()) {\n                            LOG.error(\"Lost connection to sentinel {}. Sleeping {}ms and retrying.\", node, subscribeRetryWaitTimeMillis, e);\n\n                            try {\n                                Thread.sleep(subscribeRetryWaitTimeMillis);\n                            } catch (InterruptedException se) {\n                                    LOG.error(\"Sleep interrupted.\", se);\n                                }\n\n                        } else {\n                            LOG.debug(\"Unsubscribing from sentinel {}.\", node);\n                        }\n                    } finally {\n                        IOUtils.closeQuietly(sentinelJedis);\n                    }\n\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "82", "src_id": "M50", "code": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Map<byte[], byte[]> build(Object data) {\n            final List<Object> list = (List<Object>) data;\n            if (list.isEmpty()) {\n                return Collections.emptyMap();\n            }\n\n            if (list.get(0) instanceof KeyValue) {\n                final Map<byte[], byte[]> map = new JedisByteHashMap();\n                final Iterator iterator = list.iterator();\n                while (iterator.hasNext()) {\n                    KeyValue kv = (KeyValue) iterator.next();\n\n                    map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n                }\n                return map;\n            } else {\n                final Map<byte[], byte[]> map = new JedisByteHashMap();\n                final Iterator iterator = list.iterator();\n                while (iterator.hasNext()) {\n                    map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n                }\n                return map;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "83", "src_id": "M1346", "code": "        @Override\n        public Map<String, Map<String, Double>> build(Object data) {\n            List rawDataList = (List) data;\n            if (rawDataList.isEmpty()) {\n                return Collections.emptyMap();\n            }\n\n            if (rawDataList.get(0) instanceof KeyValue) {\n                KeyValue rawData = (KeyValue) rawDataList.get(0);\n                String header = STRING.build(rawData.getKey());\n\n                if (!RESULTS.equals(header)) {\n                    throw new IllegalStateException(\"Unrecognized header: \" + header);\n                }\n\n                return ((List<KeyValue>) rawData\n                .getValue()\n                )\n                .stream()\n                .collect(Collectors.toMap(rawTerm -> STRING\n                .build(rawTerm.getKey()),\n                rawTerm -> ((List<List<KeyValue>>) rawTerm\n                .getValue()\n                )\n                .stream()\n                .collect(Collectors.toMap(entry -> STRING\n                .build(entry.get(0).getKey()),\n                entry -> BuilderFactory.DOUBLE\n                .build(entry.get(0).getValue()))),\n                (x, y) -> x, LinkedHashMap::new));\n            }\n\n            Map<String, Map<String, Double>> returnTerms = new LinkedHashMap<>(rawDataList.size());\n\n            for (Object rawData : rawDataList) {\n                List<Object> rawElements = (List<Object>) rawData;\n                String header = STRING.build(rawElements.get(0));\n\n                if (!TERM.equals(header)) {\n                    throw new IllegalStateException(\"Unrecognized header: \" + header);\n                }\n\n                String term = STRING.build(rawElements.get(1));\n                List<List<Object>> list = (List<List<Object>>) rawElements.get(2);\n                Map<String, Double> entries = new LinkedHashMap<>(list.size());\n\n                list.forEach(entry -> entries.put(STRING.build(entry.get(1)), BuilderFactory.DOUBLE.build(entry.get(0))));\n                returnTerms.put(term, entries);\n            }\n\n            return returnTerms;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "84", "src_id": "M51", "code": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Map<String, String> build(Object data) {\n            final List<Object> list = (List<Object>) data;\n            if (list.isEmpty()) {\n                return Collections.emptyMap();\n            }\n\n            if (list.get(0) instanceof KeyValue) {\n                final Map<String, String> map = new HashMap<>(list.size(), 1f);\n                final Iterator iterator = list.iterator();\n                while (iterator.hasNext()) {\n                    KeyValue kv = (KeyValue) iterator.next();\n\n                    map.put(STRING.build(kv.getKey()), STRING.build(kv.getValue()));\n                }\n                return map;\n            } else {\n                final Map<String, String> map = new HashMap<>(list.size() / 2, 1f);\n                final Iterator iterator = list.iterator();\n                while (iterator.hasNext()) {\n                    map.put(STRING.build(iterator.next()), STRING.build(iterator.next()));\n                }\n                return map;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "282", "src_id": "M362", "code": "void drainFused() {\n    int missed = 1;\n    for (;;) {\n        if (disposed) {\n            return;\n        }\n        boolean d = done;\n        Throwable ex = error;\n        if (!delayError && d && ex != null) {\n            disposed = true;\n            downstream.onError(error);\n            worker.dispose();\n            return;\n        }\n        downstream.onNext(null);\n        if (d) {\n            disposed = true;\n            ex = error;\n            if (ex != null) {\n                downstream.onError(ex);\n            } else {\n                downstream.onComplete();\n            }\n            worker.dispose();\n            return;\n        }\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "283", "src_id": "M1685", "code": "void dispose(List<Disposable> set) {\n    if (set == null) {\n        return;\n    }\n    List<Throwable> errors = null;\n    for (Disposable o : set) {\n        try {\n            o.dispose();\n        } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                if (errors == null) {\n                    errors = new ArrayList<>();\n                }\n                errors.add(ex);\n            }\n\n    }\n\n    if (errors != null) {\n        if (errors.size() == 1) {\n            throw ExceptionHelper.wrapOrThrow(errors.get(0));\n\n        }\n        throw new CompositeException(errors);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "284", "src_id": "M1503", "code": "@Override\npublic void onComplete() {\n    if (wip.getAndIncrement() == 0) {\n        Publisher<? extends T>[] sources = this.sources;\n        int n = sources.length;\n        int i = index;\n\n        for (;;) {\n            if (i == n) {\n                List<Throwable> list = errors;\n                if (list != null) {\n                    if (list.size() == 1) {\n                        downstream.onError(list.get(0));\n                    } else {\n                        downstream.onError(new CompositeException(list));\n\n                    }\n                } else {\n                    downstream.onComplete();\n                }\n                return;\n            }\n\n            Publisher<? extends T> p = sources[i];\n\n            if (p == null) {\n                Throwable ex = new NullPointerException(\"A Publisher entry is null\");\n                if (delayError) {\n                    List<Throwable> list = errors;\n                    if (list == null) {\n                        list = new ArrayList<>(n - i + 1);\n                        errors = list;\n                    }\n                    list.add(ex);\n                    i++;\n                    continue;\n                } else {\n                    downstream.onError(ex);\n                    return;\n                }\n            } else {\n                long r = produced;\n                if (r != 0L) {\n                    produced = 0L;\n                    produced(r);\n                }\n                p.subscribe(this);\n            }\n\n            index = ++i;\n            if (wip.decrementAndGet() == 0) {\n                break;\n            }\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "285", "src_id": "M470", "code": "void replay(CacheDisposable<T> consumer) {\n    // make sure there is only one replay going on at a time\n    if (consumer.getAndIncrement() != 0) {\n        return;\n    }\n    // see if there were more replay request in the meantime\n    int missed = 1;\n    // read out state into locals upfront to avoid being re-read due to volatile reads\n    long index = consumer.index;\n    int offset = consumer.offset;\n    Node<T> node = consumer.node;\n    Observer<? super T> downstream = consumer.downstream;\n    int capacity = capacityHint;\n\n    for (;;) {\n        // if the consumer got disposed, clear the node and quit\n        if (consumer.disposed) {\n            consumer.node = null;\n            return;\n        }\n        // first see if the source has terminated, read order matters!\n        boolean sourceDone = done;\n        // and if the number of items is the same as this consumer has received\n        boolean empty = size == index;\n        // if the source is done and we have all items so far, terminate the consumer\n        if (sourceDone && empty) {\n            // release the node object to avoid leaks through retained consumers\n            consumer.node = null; // if error is not null then the source failed\n            Throwable ex = error;\n            if (ex != null) {\n                downstream.onError(ex);\n            } else {\n                downstream.onComplete();\n            }\n            return;\n        }\n\n        // there are still items not sent to the consumer\n        if (!empty) {\n            // if the offset in the current node has reached the node capacity\n            if (offset == capacity) {\n                // switch to the subsequent node\n                node = node.next;\n                // reset the in-node offset\n                offset = 0;\n            }\n            // emit the cached item\n            downstream.onNext(node.values[offset]);\n            // move the node offset forward\n            offset++;\n            // move the total consumed item count forward\n            index++;\n            // retry for the next item/terminal event if any\n            continue;\n        }\n        // commit the changed references back\n        consumer.index = index;\n        consumer.offset = offset;\n        consumer.node = node;\n        // release the changes and see if there were more replay request in the meantime\n        missed = consumer.addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "286", "src_id": "M913", "code": "void drainAsync() {\n    int missed = 1;\n    SimpleQueue<T> q = queue;\n    Subscriber<? super T>[] a = this.subscribers;\n    AtomicLongArray r = this.requests;\n    long[] e = this.emissions;\n    int n = e.length;\n    int idx = index;\n    int consumed = produced;\n\n    for (;;) {\n        int notReady = 0;\n\n        for (;;) {\n            if (cancelled) {\n                q.clear();\n                return;\n            }\n            boolean d = done;\n            if (d) {\n                Throwable ex = error;\n                if (ex != null) {\n                    q.clear();\n                    for (Subscriber<? super T> s : a) {\n                        s.onError(ex);\n                    }\n\n                    return;\n                }\n            }\n\n            boolean empty = q.isEmpty();\n            if (d && empty) {\n                for (Subscriber<? super T> s : a) {\n                    s.onComplete();\n                }\n\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n            long requestAtIndex = r.get(idx);\n            long emissionAtIndex = e[idx];\n\n            if (requestAtIndex != emissionAtIndex && r.get(n + idx) == 0) {\n                T v;\n                try {\n                    v = q.poll();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        upstream.cancel();\n                        for (Subscriber<? super T> s : a) {\n                            s.onError(ex);\n                        }\n\n                        return;\n                    }\n\n                if (v == null) {\n                    break;\n                }\n                a[idx].onNext(v);\n                e[idx] = emissionAtIndex + 1;\n                int c = ++consumed;\n                if (c == limit) {\n                    consumed = 0;\n                    upstream.request(c);\n                }\n                notReady = 0;\n            } else {\n                notReady++;\n            }\n\n            idx++;\n            if (idx == n) {\n                idx = 0;\n            }\n\n            if (notReady == n) {\n                break;\n            }\n        }\n\n        int w = get();\n        if (w == missed) {\n            index = idx;\n            produced = consumed;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        } else {\n            missed = w;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "287", "src_id": "M902", "code": "@Override\npublic void run() {\n    int missed = 1;\n    int c = consumed;\n    SpscArrayQueue<T> q = queue;\n    Subscriber<? super T> a = downstream;\n    int lim = limit;\n\n    for (;;) {\n        long r = requested.get();\n        long e = 0L;\n        while (e != r) {\n            if (cancelled) {\n                q.clear();\n                return;\n            }\n            boolean d = done;\n            if (d) {\n                Throwable ex = error;\n                if (ex != null) {\n                    q.clear();\n                    a.onError(ex);\n                    worker.dispose();\n                    return;\n                }\n            }\n            T v = q.poll();\n            boolean empty = v == null;\n            if (d && empty) {\n                a.onComplete();\n                worker.dispose();\n                return;\n            }\n\n            if (empty) {\n                break;\n            }\n            a.onNext(v);\n            e++;\n            int p = ++c;\n            if (p == lim) {\n                c = 0;\n                upstream.request(p);\n            }\n        }\n\n        if (e == r) {\n            if (cancelled) {\n                q.clear();\n                return;\n            }\n\n            if (done) {\n                Throwable ex = error;\n                if (ex != null) {\n                    q.clear();\n                    a.onError(ex);\n                    worker.dispose();\n                    return;\n                }\n\n                if (q.isEmpty()) {\n                    a.onComplete();\n                    worker.dispose();\n                    return;\n                }\n            }\n        }\n\n        if (e != 0L && r != Long.MAX_VALUE) {\n            requested.addAndGet(-e);\n        }\n        int w = get();\n        if (w == missed) {\n            consumed = c;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        } else {\n            missed = w;\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "288", "src_id": "M1330", "code": "@Override\npublic void drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n    int missed = 1;\n\n    for (;;) {\n        SimpleQueue<T> q1 = first.queue;\n        SimpleQueue<T> q2 = second.queue;\n\n        if (q1 != null && q2 != null) {\n            for (;;) {\n                if (isDisposed()) {\n                    first.clear();\n                    second.clear();\n                    return;\n                }\n                Throwable ex = errors.get();\n                if (ex != null) {\n                    cancelAndClear();\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n                boolean d1 = first.done;\n                T a = v1;\n                if (a == null) {\n                    try {\n                        a = q1.poll();\n                    } catch (Throwable exc) {\n                            Exceptions.throwIfFatal(exc);\n                            cancelAndClear();\n                            errors.tryAddThrowableOrReport(exc);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                    v1 = a;\n                }\n\n                boolean e1 = a == null;\n                boolean d2 = second.done;\n                T b = v2;\n                if (b == null) {\n                    try {\n                        b = q2.poll();\n                    } catch (Throwable exc) {\n                            Exceptions.throwIfFatal(exc);\n                            cancelAndClear();\n                            errors.tryAddThrowableOrReport(exc);\n                            errors.tryTerminateConsumer(downstream);\n                            return;\n                        }\n\n                    v2 = b;\n                }\n\n                boolean e2 = b == null;\n                if (d1 && d2 && e1 && e2) {\n                    downstream.onSuccess(true);\n                    return;\n                }\n\n                if ((d1 && d2) && (e1 != e2)) {\n                    cancelAndClear();\n                    downstream.onSuccess(false);\n                    return;\n                }\n\n                if (e1) {\n                    break;\n                }\n\n                if (e2) {\n                break;\n                    }\n                boolean c;\n                try {\n                    c = comparer.test(a, b);\n                } catch (Throwable exc) {\n                        Exceptions.throwIfFatal(exc);\n                        cancelAndClear();\n                        errors.tryAddThrowableOrReport(exc);\n                        errors.tryTerminateConsumer(downstream);\n                        return;\n                    }\n\n                if (!c) {\n                    cancelAndClear();\n                    downstream.onSuccess(false);\n                    return;\n                }\n                v1 = null;\n                v2 = null;\n                first.request();\n                second.request();\n            }\n\n        } else {\n            if (isDisposed()) {\n                first.clear();\n                second.clear();\n                return;\n            }\n            Throwable ex = errors.get();\n            if (ex != null) {\n                cancelAndClear();\n                errors.tryTerminateConsumer(downstream);\n                return;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "289", "src_id": "M1033", "code": "void drain() {\n    if (getAndIncrement() != 0) {\n        return;\n    }\n    final Subscriber<? super R> a = downstream;\n    final SimpleQueue<T> q = queue;\n    final boolean replenish = fusionMode != SYNC;\n    int missed = 1;\n    Iterator<? extends R> it = current;\n\n    for (;;) {\n        if (it == null) {\n            boolean d = done;\n            T t;\n            try {\n                t = q.poll();\n            } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.cancel();\n                    ExceptionHelper.addThrowable(error, ex);\n                    ex = ExceptionHelper.terminate(error);\n                    current = null;\n                    q.clear();\n                    a.onError(ex);\n                    return;\n                }\n\n\n            boolean empty = t == null;\n            if (checkTerminated(d, empty, a, q)) {\n                return;\n            }\n\n            if (t != null) {\n                Iterable<? extends R> iterable;\n                boolean b;\n                try {\n                    iterable = mapper.apply(t);\n                    it = iterable.iterator();\n                    b = it.hasNext();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        upstream.cancel();\n                        ExceptionHelper.addThrowable(error, ex);\n                        ex = ExceptionHelper.terminate(error);\n                        a.onError(ex);\n                        return;\n                    }\n\n                if (!b) {\n                    it = null;\n                    consumedOne(replenish);\n                    continue;\n                }\n                current = it;\n            }\n        }\n\n        if (it != null) {\n            long r = requested.get();\n            long e = 0L;\n\n            while (e != r) {\n                if (checkTerminated(done, false, a, q)) {\n                    return;\n                }\n                R v;\n                try {\n                    v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        current = null;\n                        upstream.cancel();\n                        ExceptionHelper.addThrowable(error, ex);\n                        ex = ExceptionHelper.terminate(error);\n                        a.onError(ex);\n                        return;\n                    }\n\n\n                a.onNext(v);\n                if (checkTerminated(done, false, a, q)) {\n                    return;\n                }\n                e++;\n                boolean b;\n                try {\n                    b = it.hasNext();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        current = null;\n                        upstream.cancel();\n                        ExceptionHelper.addThrowable(error, ex);\n                        ex = ExceptionHelper.terminate(error);\n                        a.onError(ex);\n                        return;\n                    }\n\n                if (!b) {\n                    consumedOne(replenish);\n                    it = null;\n                    current = null;\n                    break;\n                }\n            }\n\n            if (e == r) {\n                boolean d = done;\n                boolean empty = q.isEmpty() && it == null;\n                if (checkTerminated(d, empty, a, q)) {\n                    return;\n                }\n            }\n\n            if (e != 0L && r != Long.MAX_VALUE) {\n                requested.addAndGet(-e);\n            }\n\n            if (it == null) {\n                continue;\n            }\n        }\n\n        missed = addAndGet(-missed);\n        if (missed == 0) {\n            break;\n        }\n    }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "290", "src_id": "M807", "code": "@Override\npublic void subscribe(Subscriber<? super R>[] subscribers) {\n    subscribers = RxJavaPlugins.onSubscribe(this, subscribers);\n    if (!validate(subscribers)) {\n        return;\n    }\n    int n = subscribers.length;\n    @SuppressWarnings(\"unchecked\") Subscriber<T>[] parents = new Subscriber[n];\n    for (int i = 0; i < n; i++) {\n        R initialValue;\n        try {\n            initialValue = Objects.requireNonNull(initialSupplier.get(), \"The initialSupplier returned a null value\");\n\n        } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                reportError(subscribers, ex);\n                return;\n            }\n\n\n        parents[i] = new ParallelReduceSubscriber<>(subscribers[i], initialValue, reducer);\n\n    }\n\n    source.subscribe(parents);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "291", "src_id": "M438", "code": "@Override\npublic void subscribeActual(Observer<? super T> observer) {\n    DeferredScalarDisposable<T> d = new DeferredScalarDisposable<>(observer);\n    observer.onSubscribe(d);\n    if (d.isDisposed()) {\n        return;\n    }\n    T value;\n    try {\n        value = ExceptionHelper.nullCheck(supplier.get(), \"Supplier returned a null value.\");\n\n    } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            if (!d.isDisposed()) {\n                observer.onError(e);\n            } else {\n                RxJavaPlugins.onError(e);\n            }\n            return;\n        }\n\n    d.complete(value);\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "30", "src_id": "M355", "code": "    private static String processInlineImages(String htmlContent, EmailContent emailContent) {\n        if (htmlContent == null || emailContent == null) return htmlContent;\n\n        // Create a map of Content-ID to attachment data\n        Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n        for (EmailAttachment attachment:emailContent.getAttachments()) {\n            if (attachment.isEmbedded() && attachment.getContentId() != null && attachment.getData() != null) {\n                contentIdMap.put(attachment.getContentId(), attachment);\n            }\n        }\n\n        if (contentIdMap.isEmpty()) return htmlContent;\n\n        // Pattern to match cid: references in img src attributes\n        Pattern cidPattern = Pattern.compile(\"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\", Pattern.CASE_INSENSITIVE);\n        Matcher matcher = cidPattern.matcher(htmlContent);\n        StringBuffer result = new StringBuffer();\n\n        while (matcher.find()) {\n            String contentId = matcher.group(1);\n            EmailAttachment attachment = contentIdMap.get(contentId);\n\n            if (attachment != null && attachment.getData() != null) {\n                // Convert to data URI\n                String mimeType = attachment.getContentType();\n\n                if (mimeType == null || mimeType.isEmpty()) {\n                    // Try to determine MIME type from filename\n                    String filename = attachment.getFilename();\n\n                    if (filename != null) {\n                        if (filename.toLowerCase().endsWith(\".png\")) {\n                            mimeType = \"image/png\";\n                        } else if (filename.toLowerCase().endsWith(\".jpg\") || filename.toLowerCase().endsWith(\".jpeg\")) {\n                            mimeType = \"image/jpeg\";\n                        } else if (filename.toLowerCase().endsWith(\".gif\")) {\n                            mimeType = \"image/gif\";\n                        } else if (filename.toLowerCase().endsWith(\".bmp\")) {\n                            mimeType = \"image/bmp\";\n                        } else {\n                            mimeType = \"image/png\"; // fallback\n\n                        }\n\n                    } else {\n                        mimeType = \"image/png\"; // fallback\n\n                    }\n                }\n\n                String base64Data = Base64.getEncoder().encodeToString(attachment.getData());\n                String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n                // Replace the cid: reference with the data URI\n                String replacement = matcher.group(0).replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n\n                matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n            } else {\n                // Keep original if attachment not found\n                matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n            }\n        }\n        matcher.appendTail(result);\n        return result.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "31", "src_id": "M347", "code": "    private static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n        // Create attachment info with paperclip emoji before filename\n        attachmentInfo.append(\"<div class=\\\"attachment-item\\\">\")\n        .append(\"<span class=\\\"attachment-icon\\\">\")\n        .append(MimeConstants.ATTACHMENT_MARKER)\n        .append(\"</span> \")\n        .append(\"<span class=\\\"attachment-name\\\">\")\n        .append(escapeHtml(filename))\n        .append(\"</span>\");\n\n        // Add content type and encoding info\n        if (!contentType.isEmpty() || !encoding.isEmpty()) {\n            attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n\n            if (!contentType.isEmpty()) {\n                attachmentInfo.append(escapeHtml(contentType));\n            }\n\n            if (!encoding.isEmpty()) {\n                if (!contentType.isEmpty()) attachmentInfo.append(\", \");\n                attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n            }\n            attachmentInfo.append(\")</span>\");\n        }\n        attachmentInfo.append(\"</div>\\n\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "32", "src_id": "M356", "code": "    private static void appendEnhancedStyles(StringBuilder html) {\n        int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n        String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n        String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n        String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n\n        html.append(\"body {\\n\");\n        html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n        html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n        html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n        html.append(\"  color: \").append(textColor).append(\";\\n\");\n        html.append(\"  margin: 0;\\n\");\n        html.append(\"  padding: 16px;\\n\");\n        html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-container {\\n\");\n        html.append(\"  width: 100%;\\n\");\n        html.append(\"  max-width: 100%;\\n\");\n        html.append(\"  margin: 0 auto;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header {\\n\");\n        html.append(\"  padding-bottom: 10px;\\n\");\n        html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n        html.append(\"  margin-bottom: 10px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header h1 {\\n\");\n        html.append(\"  margin: 0 0 10px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n        html.append(\"  font-weight: bold;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-meta div {\\n\");\n        html.append(\"  margin-bottom: 2px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-body {\\n\");\n        html.append(\"  word-wrap: break-word;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section {\\n\");\n        html.append(\"  margin-top: 15px;\\n\");\n        html.append(\"  padding: 10px;\\n\");\n        html.append(\"  background-color: \").append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\");\n        html.append(\"  border: 1px solid \").append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section h3 {\\n\");\n        html.append(\"  margin: 0 0 8px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-item {\\n\");\n        html.append(\"  padding: 5px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-icon {\\n\");\n        html.append(\"  margin-right: 5px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-details, .attachment-type {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  color: #555555;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n        html.append(\"  margin-top: 8px;\\n\");\n        html.append(\"  padding: 6px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note {\\n\");\n        html.append(\"  background-color: #e6ffed;\\n\");\n        html.append(\"  border: 1px solid #d4f7dc;\\n\");\n        html.append(\"  color: #006420;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-info-note {\\n\");\n        html.append(\"  background-color: #fff9e6;\\n\");\n        html.append(\"  border: 1px solid #fff0c2;\\n\");\n        html.append(\"  color: #664d00;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container {\\n\");\n        html.append(\"  display: flex;\\n\");\n        html.append(\"  align-items: center;\\n\");\n        html.append(\"  padding: 8px;\\n\");\n        html.append(\"  background-color: #f8f9fa;\\n\");\n        html.append(\"  border: 1px solid #dee2e6;\\n\");\n        html.append(\"  border-radius: 4px;\\n\");\n        html.append(\"  margin: 4px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container:hover {\\n\");\n        html.append(\"  background-color: #e9ecef;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-note {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n        html.append(\"  color: #6c757d;\\n\");\n        html.append(\"  font-style: italic;\\n\");\n        html.append(\"  margin-left: 8px;\\n\");\n        html.append(\"}\\n\\n\");\n        // Basic image styling: ensure images are responsive but not overly constrained.\n        html.append(\"img {\\n\");\n        html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n\n        html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n\n        html.append(\"  display: block;\\n\"); // Avoid extra space below images\n\n        html.append(\"}\\n\\n\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "33", "src_id": "M342", "code": "    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n\n            htmlBody = convertTextToHtml(textBody != null ? textBody:\"Email content could not be parsed\");\n        }\n\n        // Generate HTML with custom styling based on request\n        StringBuilder html = new StringBuilder();\n\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n            html.append(\"</div>\\n\");\n        }\n        // Show advanced features status if requested\n        assert request != null;\n\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "231", "src_id": "M1043", "code": "    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n\n        errObject = null;\n\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n                Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n                if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                    notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n\n                    return;\n                }\n\n                if (errCode == ERROR_NOTHING) {\n                    errCode = ERROR_POSTPROCESSING;\n                }\n                exception = err;\n            } finally {\n                notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n            }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n\n            return;\n        }\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "232", "src_id": "M1050", "code": "    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        if (oldVersion == 2) {\n            db.execSQL(\"ALTER TABLE \" + MISSIONS_TABLE_NAME_v2 + \" ADD COLUMN \" + KEY_KIND + \" TEXT;\");\n            oldVersion++;\n        }\n\n        if (oldVersion == 3) {\n            final String KEY_LOCATION = \"location\";\n            final String KEY_NAME = \"name\";\n            db.execSQL(MISSIONS_CREATE_TABLE);\n\n            Cursor cursor = db.query(MISSIONS_TABLE_NAME_v2, null, null, null, null, null, KEY_TIMESTAMP);\n            int count = cursor.getCount();\n\n            if (count > 0) {\n                db.beginTransaction();\n\n                while (cursor.moveToNext()) {\n                    ContentValues values = new ContentValues();\n                    values.put(KEY_SOURCE, cursor.getString(cursor.getColumnIndex(KEY_SOURCE)));\n                    values.put(KEY_DONE, cursor.getString(cursor.getColumnIndex(KEY_DONE)));\n                    values.put(KEY_TIMESTAMP, cursor.getLong(cursor.getColumnIndex(KEY_TIMESTAMP)));\n                    values.put(KEY_KIND, cursor.getString(cursor.getColumnIndex(KEY_KIND)));\n                    values.put(KEY_PATH, Uri.fromFile(new File(cursor.getString(cursor.getColumnIndex(KEY_LOCATION)), cursor.getString(cursor.getColumnIndex(KEY_NAME)))).toString());\n                    db.insert(FINISHED_TABLE_NAME, null, values);\n                }\n                db.setTransactionSuccessful();\n\n                db.endTransaction();\n            }\n\n            cursor.close();\n\n            db.execSQL(\"DROP TABLE \" + MISSIONS_TABLE_NAME_v2);\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "233", "src_id": "M870", "code": "    @SuppressWarnings(\"MethodLength\")\n    public void build(final SharpStream output) throws IOException {\n        if (done) {\n            throw new RuntimeException(\"already done\");\n        }\n\n        if (!output.canWrite()) {\n            throw new IOException(\"the provided output is not writable\");\n        }\n        //\n        // WARNING: the muxer requires at least 8 samples of every track\n        //          not allowed for very short tracks (less than 0.5 seconds)\n        //\n        outStream = output;\n\n        long read = 8; // mdat box header size\n\n        long totalSampleSize = 0;\n        final int[] sampleExtra = new int[readers.length];\n        final int[] defaultMediaTime = new int[readers.length];\n        final int[] defaultSampleDuration = new int[readers.length];\n        final int[] sampleCount = new int[readers.length];\n        final TablesInfo[] tablesInfo = new TablesInfo[tracks.length];\n        for (int i = 0; i < tablesInfo.length; i++) {\n            tablesInfo[i] = new TablesInfo();\n        }\n\n        final int singleSampleBuffer = tracks.length == 1 && tracks[0].kind == TrackKind.Audio ? tracks[0].trak.mdia.mdhdTimeScale / 1000 : - 1; \n\n        for (int i = 0; i < readers.length; i++) {\n            int samplesSize = 0;\n            int sampleSizeChanges = 0;\n            int compositionOffsetLast = - 1;\n            Mp4DashChunk chunk;\n\n            while ((chunk = readers[i].getNextChunk(true)) != null) {\n                if (defaultMediaTime[i] < 1 && chunk.moof.traf.tfhd.defaultSampleDuration > 0) {\n                    defaultMediaTime[i] = chunk.moof.traf.tfhd.defaultSampleDuration;\n                }\n                read += chunk.moof.traf.trun.chunkSize;\n                sampleExtra[i] += chunk.moof.traf.trun.chunkDuration; // calculate track duration\n\n\n                TrunEntry info;\n                while ((info = chunk.getNextSampleInfo()) != null) {\n                    if (info.isKeyframe) {\n                        tablesInfo[i].stss++;\n                    }\n\n                    if (info.sampleDuration > defaultSampleDuration[i]) {\n                        defaultSampleDuration[i] = info.sampleDuration;\n                    }\n                    tablesInfo[i].stsz++;\n                    if (samplesSize != info.sampleSize) {\n                        samplesSize = info.sampleSize;\n\n                        sampleSizeChanges++;\n                    }\n\n                    if (info.hasCompositionTimeOffset && info.sampleCompositionTimeOffset != compositionOffsetLast) {\n                        tablesInfo[i].ctts++;\n\n                        compositionOffsetLast = info.sampleCompositionTimeOffset;\n                    }\n                    totalSampleSize += info.sampleSize;\n                }\n            }\n\n            if (defaultMediaTime[i] < 1) {\n                defaultMediaTime[i] = defaultSampleDuration[i];\n            }\n            readers[i].rewind();\n            if (singleSampleBuffer > 0) {\n                initChunkTables(tablesInfo[i], singleSampleBuffer, singleSampleBuffer);\n            } else {\n                initChunkTables(tablesInfo[i], SAMPLES_PER_CHUNK_INIT, SAMPLES_PER_CHUNK);\n            }\n            sampleCount[i] = tablesInfo[i].stsz;\n            if (sampleSizeChanges != 1) {\n                tablesInfo[i].stszDefault = 0;\n            } else {\n                tablesInfo[i].stsz = 0;\n\n                tablesInfo[i].stszDefault = samplesSize;\n            } \n\n            if (tablesInfo[i].stss == tablesInfo[i].stsz) {\n                tablesInfo[i].stss = - 1; // for audio tracks (all samples are keyframes)\n\n            }\n\n            // ensure track duration\n            if (tracks[i].trak.tkhd.duration < 1) {\n                tracks[i].trak.tkhd.duration = sampleExtra[i]; // this never should happen\n\n            }\n        }\n\n        final boolean is64 = read > THRESHOLD_FOR_CO64;\n        // calculate the moov size\n        final int auxSize = makeMoov(defaultMediaTime, tablesInfo, is64);\n        if (auxSize < THRESHOLD_MOOV_LENGTH) {\n            auxBuffer = ByteBuffer.allocate(auxSize); // cache moov in the memory\n\n        }\n        moovSimulation = false;\n\n        writeOffset = 0;\n\n        final int ftypSize = makeFtyp();\n        // reserve moov space in the output stream\n        if (auxSize > 0) {\n            int length = auxSize;\n            final byte[] buffer = new byte[64 * 1024]; // 64 KiB\n\n            while (length > 0) {\n                final int count = Math.min(length, buffer.length);\n                outWrite(buffer, count);\n\n                length -= count;\n            }\n        }\n\n        if (auxBuffer == null) {\n            outSeek(ftypSize);\n        }\n        // tablesInfo contains row counts\n        // and after returning from makeMoov() will contain those table offsets\n        makeMoov(defaultMediaTime, tablesInfo, is64);\n\n        // write tables: stts stsc sbgp\n        // reset for ctts table: sampleCount sampleExtra\n        for (int i = 0; i < readers.length; i++) {\n            writeEntryArray(tablesInfo[i].stts, 2, sampleCount[i], defaultSampleDuration[i]);\n            writeEntryArray(tablesInfo[i].stsc, tablesInfo[i].stscBEntries.length, tablesInfo[i].stscBEntries);\n            tablesInfo[i].stscBEntries = null;\n            if (tablesInfo[i].ctts > 0) {\n                sampleCount[i] = 1; // the index is not base zero\n\n\n                sampleExtra[i] = - 1;\n            }\n\n            if (tablesInfo[i].sbgp > 0) {\n                writeEntryArray(tablesInfo[i].sbgp, 1, sampleCount[i]);\n            }\n        }\n\n        if (auxBuffer == null) {\n            outRestore();\n        }\n        outWrite(makeMdat(totalSampleSize, is64));\n\n        final int[] sampleIndex = new int[readers.length];\n        final int[] sizes = new int[singleSampleBuffer > 0 ? singleSampleBuffer : SAMPLES_PER_CHUNK];\n        final int[] sync = new int[singleSampleBuffer > 0 ? singleSampleBuffer : SAMPLES_PER_CHUNK];\n        int written = readers.length;\n\n        while (written > 0) {\n            written = 0;\n\n            for (int i = 0; i < readers.length; i++) {\n                if (sampleIndex[i] < 0) {\n                    continue; // track is done\n\n                }\n\n                final long chunkOffset = writeOffset;\n                int syncCount = 0;\n                final int limit = singleSampleBuffer > 0 ? singleSampleBuffer : sampleIndex[i] == 0 ? SAMPLES_PER_CHUNK_INIT : SAMPLES_PER_CHUNK; \n                int j = 0;\n\n                for (; j < limit; j++) {\n                    final Mp4DashSample sample = getNextSample(i);\n                    if (sample == null) {\n                        if (tablesInfo[i].ctts > 0 && sampleExtra[i] >= 0) {\n                            writeEntryArray(tablesInfo[i].ctts, 1, sampleCount[i], sampleExtra[i]); // flush last entries\n\n\n                            outRestore();\n                        }\n                        sampleIndex[i] = - 1;\n\n                        break;\n                    }\n                    sampleIndex[i]++;\n                    if (tablesInfo[i].ctts > 0) {\n                        if (sample.info.sampleCompositionTimeOffset == sampleExtra[i]) {\n                            sampleCount[i]++;\n                        } else {\n                            if (sampleExtra[i] >= 0) {\n                                tablesInfo[i].ctts = writeEntryArray(tablesInfo[i].ctts, 2, sampleCount[i], sampleExtra[i]);\n                                outRestore();\n                            }\n                            sampleCount[i] = 1;\n\n                            sampleExtra[i] = sample.info.sampleCompositionTimeOffset;\n                        }\n                    }\n\n                    if (tablesInfo[i].stss > 0 && sample.info.isKeyframe) {\n                        sync[syncCount++] = sampleIndex[i];\n                    }\n\n                    if (tablesInfo[i].stsz > 0) {\n                        sizes[j] = sample.data.length;\n                    }\n                    outWrite(sample.data, sample.data.length);\n                }\n\n                if (j <= 0) { \n                    continue; \n                }  \n                written++;\n                if (tablesInfo[i].stsz > 0) {\n                    tablesInfo[i].stsz = writeEntryArray(tablesInfo[i].stsz, j, sizes);\n                }\n\n                if (syncCount > 0) {\n                    tablesInfo[i].stss = writeEntryArray(tablesInfo[i].stss, syncCount, sync);\n                }\n\n                if (tablesInfo[i].stco > 0) {\n                    tablesInfo[i].stco = is64 ? writeEntry64(tablesInfo[i].stco, chunkOffset) : writeEntryArray(tablesInfo[i].stco, 1, (int) chunkOffset); \n                }\n                outRestore();\n            }\n        }\n\n        if (auxBuffer != null) {\n            // dump moov\n            outSeek(ftypSize);\n\n            outStream.write(auxBuffer.array(), 0, auxBuffer.capacity());\n\n            auxBuffer = null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "234", "src_id": "M1024", "code": "    @Override\n    public void run() {\n        if (mMission.current > 0) {\n            mMission.resetState(false, true, DownloadMission.ERROR_NOTHING);\n        }\n\n        int retryCount = 0;\n        int httpCode = 204;\n\n        while (true) {\n            try {\n                if (!(mMission.blocks == null && mMission.current == 0)) {\n                    // ask for the current resource length\n                    mConn = mMission.openConnection(true, 0, 0);\n\n                    mMission.establishConnection(mId, mConn);\n\n                    dispose();\n                    if (!mMission.running || Thread.interrupted()) {\n                        return;\n                    }\n                    httpCode = mConn.getResponseCode();\n                    mMission.length = Utility.getTotalContentLength(mConn);\n                } else {\n                    // calculate the whole size of the mission\n                    long finalLength = 0;\n                    long lowestSize = Long.MAX_VALUE;\n                    for (int i = 0; i < mMission.urls.length && mMission.running; i++) {\n                        mConn = mMission.openConnection(mMission.urls[i], true, 0, 0);\n                        mMission.establishConnection(mId, mConn);\n\n                        dispose();\n                        if (Thread.interrupted()) {\n                            return;\n                        }\n\n                        long length = Utility.getTotalContentLength(mConn);\n                        if (i == 0) {\n                            httpCode = mConn.getResponseCode();\n\n                            mMission.length = length;\n                        }\n\n                        if (length > 0) {\n                            finalLength += length;\n                        }\n\n                        if (length < lowestSize) {\n                            lowestSize = length;\n                        }\n                    }\n                    mMission.nearLength = finalLength;\n                    // reserve space at the start of the file\n                    if (mMission.psAlgorithm != null && mMission.psAlgorithm.reserveSpace) {\n                        mMission.offsets[0] = lowestSize < 1 ? RESERVE_SPACE_DEFAULT : lowestSize < RESERVE_SPACE_MAXIMUM ? lowestSize : RESERVE_SPACE_MAXIMUM; \n                    }\n                } \n\n                if (mMission.length == 0 || httpCode == 204) {\n                    mMission.notifyError(DownloadMission.ERROR_HTTP_NO_CONTENT, null);\n\n                    return;\n                }\n\n                // check for dynamic generated content\n                if (mMission.length == - 1 && mConn.getResponseCode() == 200) {\n                    mMission.blocks = new int[0];\n\n                    mMission.length = 0;\n\n                    mMission.unknownLength = true;\n                    if (DEBUG) {\n                        Log.d(TAG, \"falling back (unknown length)\");\n                    }\n                } else {\n                    // Open again\n                    mConn = mMission.openConnection(true, mMission.length - 10, mMission.length);\n                    mMission.establishConnection(mId, mConn);\n\n                    dispose();\n                    if (!mMission.running || Thread.interrupted()) {\n                        return;\n                    }\n\n                    synchronized (mMission.LOCK) {\n                        if (mConn.getResponseCode() != 206) {\n                            // Fallback to single thread\n                            mMission.blocks = new int[0];\n\n                            mMission.unknownLength = false;\n                            if (DEBUG) {\n                                Log.d(TAG, \"falling back due http response code = \" + mConn.getResponseCode());\n                            }\n                        } else {\n                            if (mMission.threadCount <= 1) {\n                                // if one thread is required don't calculate blocks, is useless\n                                mMission.blocks = new int[0];\n\n                                mMission.unknownLength = false;\n                            } else {\n                                int count = (int) (mMission.length / DownloadMission.BLOCK_SIZE);\n                                if ((count * DownloadMission.BLOCK_SIZE) < mMission.length) {\n                                    count++;\n                                }\n                                mMission.blocks = new int[count];\n                            } \n\n                            if (DEBUG) {\n                                Log.d(TAG, \"http response code = \" + mConn.getResponseCode());\n                            }\n                        } \n\n                    }\n\n                    if (!mMission.running || Thread.interrupted()) {\n                        return;\n                    }\n                }\n\n                try (SharpStream fs = mMission.storage.getStream()) {\n                    fs.setLength(mMission.offsets[mMission.current] + mMission.length);\n                    fs.seek(mMission.offsets[mMission.current]);\n                }\n\n                if (!mMission.running || Thread.interrupted()) {\n                    return;\n                }\n\n                if (!mMission.unknownLength && mMission.recoveryInfo != null) {\n                    String entityTag = mConn.getHeaderField(\"ETAG\");\n                    String lastModified = mConn.getHeaderField(\"Last-Modified\");\n                    MissionRecoveryInfo recovery = mMission.recoveryInfo[mMission.current];\n                    if (!TextUtils.isEmpty(entityTag)) {\n                        recovery.setValidateCondition(entityTag);\n                    } else if (!TextUtils.isEmpty(lastModified)) {\n                        recovery.setValidateCondition(lastModified); // Note: this is less precise\n\n                    } else {\n                        recovery.setValidateCondition(null);\n                    }\n                }\n\n                mMission.running = false;\n\n                break;\n            } catch (InterruptedIOException | ClosedByInterruptException e) {\n                    return;\n                } catch (Exception e) {\n                    if (!mMission.running || super.isInterrupted()) {\n                        return;\n                    }\n\n                    if (e instanceof DownloadMission.HttpError && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                        // for youtube streams. The url has expired\n                        interrupt();\n\n                        mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n\n                        return;\n                    }\n\n                    if (e instanceof IOException && e.getMessage().contains(\"Permission denied\")) {\n                        mMission.notifyError(DownloadMission.ERROR_PERMISSION_DENIED, e);\n\n                        return;\n                    }\n\n                    if (retryCount++ > mMission.maxRetry) {\n                        Log.e(TAG, \"initializer failed\", e);\n\n                        mMission.notifyError(e);\n\n                        return;\n                    }\n                    Log.e(TAG, \"initializer failed, retrying\", e);\n                }\n\n        }\n        mMission.start();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "235", "src_id": "M1106", "code": "    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n\n        request.append(\" [\");\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n\n                request.append(' ').append(recovery.toString()).append(' ');\n            }\n        }\n        request.append(\"]\");\n\n        String service;\n\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n                service = ErrorInfo.SERVICE_NONE;\n            }\n\n        ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "236", "src_id": "M1055", "code": "    public void updateMission(Mission mission) {\n        ContentValues values = getValuesOfMission(Objects.requireNonNull(mission));\n        SQLiteDatabase database = getWritableDatabase();\n        String ts = String.valueOf(mission.timestamp);\n        int rowsAffected;\n\n        if (!(mission instanceof FinishedMission)) {\n            throw new UnsupportedOperationException(\"DownloadMission\");\n        } else {\n            rowsAffected = mission\n                    .storage\n                    .isInvalid()\n                    ? database.update(FINISHED_TABLE_NAME, \n                    values, KEY_TIMESTAMP \n                     + \" = ?\", \n                    new String[]{ts})\n                     : database.update(FINISHED_TABLE_NAME, \n                    values, KEY_PATH + \" = ?\", \n                    new String[]{mission\n                    .storage\n                    .getUri()\n                    .toString()}); \n        } \n\n        if (rowsAffected != 1) {\n            Log.e(\"FinishedMissionStore\", \"Expected 1 row to be affected by update but got \" + rowsAffected);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "237", "src_id": "M877", "code": "    private int make(final int type, final int extra, final int columns, final int rows) throws IOException {\n        final byte base = 16;\n        final int size = columns * rows * 4;\n        int total = size + base;\n        int offset = auxOffset();\n        if (extra >= 0) {\n            total += 4;\n        }\n        auxWrite(ByteBuffer.allocate(12).putInt(total).putInt(type).putInt(0x00)// default version & flags\n        .array());\n        if (extra >= 0) {\n            offset += 4;\n\n            auxWrite(extra);\n        }\n        auxWrite(rows);\n\n        auxSkip(size);\n\n        return offset + base;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "238", "src_id": "M1079", "code": "    boolean runMissions() {\n        synchronized (this) {\n            if (mMissionsPending.size() < 1) {\n                return false;\n            }\n\n            if (!canDownloadInCurrentNetwork()) {\n                return false;\n            }\n\n            if (mPrefQueueLimit) {\n                for (DownloadMission mission : mMissionsPending) {\n\n                    if (!mission.isFinished() && mission.running) {\n                        return true;\n                    }}\n            }\n\n            boolean flag = false;\n            for (DownloadMission mission : mMissionsPending) {\n                if (mission.running || !mission.enqueued || mission.isFinished()) {\n\n                    continue;\n                }\n                resumeMission(mission);\n                if (mission.errCode != DownloadMission.ERROR_NOTHING) {\n                    continue;\n                }\n\n                if (mPrefQueueLimit) {\n                    return true;\n                }\n                flag = true;\n            }\n            return flag;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "239", "src_id": "M1036", "code": "    public void start() {\n        if (running || isFinished() || urls.length < 1) {\n            return;\n        }\n        // ensure that the previous state is completely paused.\n        joinForThreads(10000);\n\n        running = true;\n\n        errCode = ERROR_NOTHING;\n        if (hasInvalidStorage()) {\n            notifyError(ERROR_FILE_CREATION, null);\n\n            return;\n        }\n\n        if (current >= urls.length) {\n            notifyFinished();\n\n            return;\n        }\n        notify(DownloadManagerService.MESSAGE_RUNNING);\n        if (urls[current] == null) {\n            doRecover(ERROR_RESOURCE_GONE);\n\n            return;\n        }\n\n        if (blocks == null) {\n            initializer();\n\n            return;\n        }\n        init = null;\n\n        finishCount = 0;\n\n        blockAcquired = new boolean[blocks.length];\n\n        if (blocks.length < 1) {\n            threads = new Thread[]{runAsync(1, new DownloadRunnableFallback(this))};\n        } else {\n            int remainingBlocks = 0;\n            for (int block : blocks) {\n                if (block >= 0) {\n                    remainingBlocks++;\n                }}\n\n            if (remainingBlocks < 1) {\n                notifyFinished();\n\n                return;\n            }\n            threads = new Thread[Math.min(threadCount, remainingBlocks)];\n\n            for (int i = 0; i < threads.length; i++) {\n                threads[i] = runAsync(i + 1, new DownloadRunnable(this, i));\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "395", "src_id": "M379", "code": "    @Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n        final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType()).collect(Collectors.toList());\n\n        final List<String> availableLanguages = textTracks\n                .stream()\n                .map(Tracks.Group::getMediaTrackGroup)\n                .filter(textTrack -> textTrack\n                .length \n                > 0)\n                .map(textTrack -> textTrack\n                .getFormat(0)\n                .language)\n                .collect(Collectors.toList());\n\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks\n                .stream()\n                .filter(Tracks.Group\n                ::isSelected)\n                .filter(info -> info\n                .getMediaTrackGroup()\n                .length \n                 >= 1)\n                .map(info -> info.getMediaTrackGroup()\n                .getFormat(0))\n                .findFirst();\n\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n\n        if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "396", "src_id": "M260", "code": "    public void play() {\n        if (DEBUG) {\n            Log.d(TAG, \"play() called\");\n        }\n        if (audioReactor == null || playQueue == null || exoPlayerIsNull()) {\n            return;\n        }\n        if (!isMuted()) {\n            audioReactor.requestAudioFocus();\n        }\n        if (currentState == STATE_COMPLETED) {\n            if (playQueue.getIndex() == 0) {\n                seekToDefault();\n            } else {\n                playQueue.setIndex(0);\n            }\n        }\n\n        simpleExoPlayer.play();\n        saveStreamProgressState();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "397", "src_id": "M887", "code": "    @Nullable\n    static String choosePreferredImage(@NonNull final List<Image> images, final PreferredImageQuality nonNoneQuality) {\n        // this will be used to estimate the pixel count for images where only one of height or\n        // width are known\n        final double widthOverHeight = images\n                .stream()\n                .filter(image -> image\n                .getHeight() \n                 != HEIGHT_UNKNOWN\n                 && image.getWidth() != WIDTH_UNKNOWN)\n                .mapToDouble(image -> ((double) image\n                .getWidth()\n                ) \n                 / image.getHeight())\n                .findFirst()\n                .orElse(1.0);\n\n        final Image.ResolutionLevel preferredLevel = nonNoneQuality.toResolutionLevel();\n\n        final Comparator<Image> initialComparator = Comparator\n        // the first step splits the images into groups of resolution levels\n                .<Image> comparingInt(i -> {if (i\n                        .getEstimatedResolutionLevel() \n                         == Image.ResolutionLevel\n                        .UNKNOWN\n                        ) {return 3; // avoid unknowns as much as possible\n                                } else if (i.getEstimatedResolutionLevel() \n                         == preferredLevel\n                        ) {return 0; // prefer a matching resolution level\n                                } else if (i.getEstimatedResolutionLevel() \n                         == Image.ResolutionLevel\n                        .MEDIUM\n                        ) {return 1; // the preferredLevel is only 1 \"step\" away (either HIGH or LOW)\n                                } else {return 2; // the preferredLevel is the furthest away possible (2 \"steps\")\n                                }})\n        // then each level's group is further split into two subgroups, one with known image\n        // size (which is also the preferred subgroup) and the other without\n                .thenComparing(image -> image\n                .getHeight() \n                 == HEIGHT_UNKNOWN \n                 && image.getWidth() == WIDTH_UNKNOWN);\n\n        // The third step chooses, within each subgroup with known image size, the best image based\n        // on how close its size is to BEST_LOW_H or BEST_MEDIUM_H (with proper units). Subgroups\n        // without known image size will be left untouched since estimatePixelCount always returns\n        // the same number for those.\n        final Comparator<Image> finalComparator = switch (nonNoneQuality\n                ) {case NONE -> initialComparator\n                        ; // unreachable\n            case LOW -> initialComparator\n                        .thenComparingDouble(image -> {final double pixelCount = estimatePixelCount(image, \n                            widthOverHeight);return Math\n                            .abs(pixelCount - BEST_LOW_H \n                             * BEST_LOW_H \n                             * widthOverHeight)\n                            ;})\n                        ;case MEDIUM -> initialComparator\n                        .thenComparingDouble(image -> {final double pixelCount = estimatePixelCount(image, \n                            widthOverHeight);return Math\n                            .abs(pixelCount - BEST_MEDIUM_H \n                             * BEST_MEDIUM_H \n                             * widthOverHeight)\n                    ;})\n                ;case HIGH -> initialComparator.thenComparingDouble(// this is reversed with a - so that the highest resolution is chosen\n                i -> -estimatePixelCount(i, widthOverHeight));};\n\n        return images.stream() // using \"min\" basically means \"take the first group, then take the first subgroup,\n        // then choose the best image, while ignoring all other groups and subgroups\"\n        .min(finalComparator).map(Image::getUrl).orElse(null);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "398", "src_id": "M527", "code": "    @SuppressLint(\"PrivateResource\") // we currently use Exoplayer's internal strings and icons\n\n    @Nullable\n    public static NotificationActionData fromNotificationActionEnum(@NonNull final Player player,@NotificationConstants.Action final int selectedAction) {\n        final int baseActionIcon = NotificationConstants.ACTION_ICONS[selectedAction];\n\n        final Context ctx = player.getContext();\n        switch (selectedAction) {\n            case NotificationConstants.PREVIOUS:\n                return new NotificationActionData(ACTION_PLAY_PREVIOUS, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description), baseActionIcon);\n            case NotificationConstants.NEXT:\n                return new NotificationActionData(ACTION_PLAY_NEXT, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description), baseActionIcon);\n            case NotificationConstants.REWIND:\n                return new NotificationActionData(ACTION_FAST_REWIND, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description), baseActionIcon);\n            case NotificationConstants.FORWARD:\n                return new NotificationActionData(ACTION_FAST_FORWARD, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description), baseActionIcon);\n            case NotificationConstants.SMART_REWIND_PREVIOUS:\n                if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                    return new NotificationActionData(ACTION_PLAY_PREVIOUS,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_previous_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_notification_previous);\n                } else {\n                    return new NotificationActionData(ACTION_FAST_REWIND,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_rewind_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_controls_rewind);\n                }\n            case NotificationConstants.SMART_FORWARD_NEXT:\n                if (player.getPlayQueue() != null && player.getPlayQueue().size() > 1) {\n                    return new NotificationActionData(ACTION_PLAY_NEXT,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_next_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_notification_next);\n                } else {\n                    return new NotificationActionData(ACTION_FAST_FORWARD,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_fastforward_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_controls_fastforward);\n                }\n            case NotificationConstants.PLAY_PAUSE_BUFFERING:\n                if (player.getCurrentState() == Player.STATE_PREFLIGHT || player.getCurrentState() == Player.STATE_BLOCKED || player.getCurrentState() == Player.STATE_BUFFERING) {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE, ctx.getString(R.string.notification_action_buffering), R.drawable.ic_hourglass_top);\n                }\n            // fallthrough\n            case NotificationConstants.PLAY_PAUSE:\n                if (player.getCurrentState() == Player.STATE_COMPLETED) {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE, ctx.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_pause_description), R.drawable.ic_replay);\n                } else if (player.isPlaying()\n                             || player.getCurrentState() \n                             == Player.STATE_PREFLIGHT\n                             || player.getCurrentState() \n                             == Player.STATE_BLOCKED\n                             || player.getCurrentState() \n                             == Player.STATE_BUFFERING) {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_pause_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_notification_pause);\n                } else {\n                    return new NotificationActionData(ACTION_PLAY_PAUSE,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_play_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_notification_play);\n                }\n            case NotificationConstants.REPEAT:\n                if (player.getRepeatMode() == REPEAT_MODE_ALL) {\n                    return new NotificationActionData(ACTION_REPEAT,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_repeat_all_description),\n                            com.google.android.exoplayer2\n                            .ext\n                            .mediasession\n                            .R\n                            .drawable\n                            .exo_media_action_repeat_all);\n                } else if (player.getRepeatMode() == REPEAT_MODE_ONE) {\n                    return new NotificationActionData(ACTION_REPEAT,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_repeat_one_description),\n                            com.google.android.exoplayer2\n                            .ext\n                            .mediasession\n                            .R\n                            .drawable\n                            .exo_media_action_repeat_one);\n                } else /* player.getRepeatMode() == REPEAT_MODE_OFF */ {\n                    return new NotificationActionData(ACTION_REPEAT,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_repeat_off_description),\n                            com.google.android.exoplayer2\n                            .ext\n                            .mediasession\n                            .R\n                            .drawable\n                            .exo_media_action_repeat_off);\n                }\n            case NotificationConstants.SHUFFLE:\n                if (player.getPlayQueue() != null && player.getPlayQueue().isShuffled()) {\n                    return new NotificationActionData(ACTION_SHUFFLE,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_shuffle_on_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_controls_shuffle_on);\n                } else {\n                    return new NotificationActionData(ACTION_SHUFFLE,\n                            ctx.getString(com.google\n                            .android\n                            .exoplayer2\n                            .ui\n                            .R\n                            .string\n                            .exo_controls_shuffle_off_description),\n                            com.google.android.exoplayer2\n                            .ui\n                            .R\n                            .drawable\n                            .exo_controls_shuffle_off);\n                }\n            case NotificationConstants.CLOSE:\n                return new NotificationActionData(ACTION_CLOSE, ctx.getString(R.string.close), R.drawable.ic_close);\n            case NotificationConstants.NOTHING:\n            default:\n                // do nothing\n                return null;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "399", "src_id": "M239", "code": "    private void updatePlaybackState(final boolean playWhenReady, final int playbackState) {\n        if (DEBUG) {\n            Log.d(TAG, \"ExoPlayer - updatePlaybackState() called with: \" + \"playWhenReady = [\" + playWhenReady + \"], \" + \"playbackState = [\" + playbackState + \"]\");\n        }\n        if (currentState == STATE_PAUSED_SEEK) {\n            if (DEBUG) {\n                Log.d(TAG, \"updatePlaybackState() is currently blocked\");\n            }\n\n            return;\n        }\n\n        switch (playbackState) {\n            case com.google.android.exoplayer2.Player\n            .STATE_IDLE: // 1\n\n                isPrepared = false;\n                break;\n            case com.google.android.exoplayer2.Player\n            .STATE_BUFFERING: // 2\n                if (isPrepared) {\n                    changeState(STATE_BUFFERING);\n                }\n                break;\n            case com.google.android.exoplayer2.Player\n            .STATE_READY: //3\n                if (!isPrepared) {\n                    isPrepared = true;\n                    onPrepared(playWhenReady);\n                }\n                changeState(playWhenReady ? STATE_PLAYING : STATE_PAUSED);\n                break;\n            case com.google.android.exoplayer2.Player\n            .STATE_ENDED: // 4\n\n                changeState(STATE_COMPLETED);\n                saveStreamProgressStateCompleted();\n                isPrepared = false;\n                break;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "400", "src_id": "M460", "code": "    public MediaDescriptionCompat getQueueMetadata(final int index) {\n        if (player.getPlayQueue() == null) {\n            return null;\n        }\n        final PlayQueueItem item = player.getPlayQueue().getItem(index);\n        if (item == null) {\n            return null;\n        }\n\n        final MediaDescriptionCompat.Builder descBuilder = new MediaDescriptionCompat.Builder()\n                .setMediaId(String.valueOf(index))\n                .setTitle(item.getTitle())\n                .setSubtitle(item.getUploader());\n\n        // set additional metadata for A2DP/AVRCP (Audio/Video Bluetooth profiles)\n        final Bundle additionalMetadata = new Bundle();\n\n        additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_TITLE, item.getTitle());\n        additionalMetadata.putString(MediaMetadataCompat.METADATA_KEY_ARTIST, item.getUploader());\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_DURATION, item.getDuration() * 1000);\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, index + 1L);\n        additionalMetadata.putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, player.getPlayQueue().size());\n        descBuilder.setExtras(additionalMetadata);\n\n        try {\n            descBuilder.setIconUri(Uri.parse(ImageStrategy.choosePreferredImage(item.getThumbnails())));\n        } catch (final Throwable e) {\n            // no thumbnail available at all, or the user disabled image loading,\n            // or the obtained url is not a valid `Uri`\n            }\n\n\n        return descBuilder.build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "401", "src_id": "M243", "code": "    public void changeState(final int state) {\n        if (DEBUG) {\n            Log.d(TAG, \"changeState() called with: state = [\" + state + \"]\");\n        }\n\n        currentState = state;\n\n        switch (state) {\n            case STATE_BLOCKED:\n                onBlocked();\n                break;\n            case STATE_PLAYING:\n                onPlaying();\n                break;\n            case STATE_BUFFERING:\n                onBuffering();\n                break;\n            case STATE_PAUSED:\n                onPaused();\n                break;\n            case STATE_PAUSED_SEEK:\n                onPausedSeek();\n                break;\n            case STATE_COMPLETED:\n                onCompleted();\n                break;\n        }\n\n        notifyPlaybackUpdateToListeners();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "402", "src_id": "M543", "code": "    private synchronized NotificationCompat.Builder createNotification() {\n        if (DEBUG) {\n            Log.d(TAG, \"createNotification()\");\n        }\n\n        notificationManager = NotificationManagerCompat.from(player.getContext());\n\n        final NotificationCompat.Builder builder = new NotificationCompat.Builder(player.getContext(), player.getContext().getString(R.string.notification_channel_id));\n\n        final MediaStyle mediaStyle = new MediaStyle();\n        // setup media style (compact notification slots and media session)\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n            // notification actions are ignored on Android 13+, and are replaced by code in\n            // MediaSessionPlayerUi\n            final int[] compactSlots = initializeNotificationSlots();\n            mediaStyle.setShowActionsInCompactView(compactSlots);\n        }\n\n        player.UIs().get(MediaSessionPlayerUi.class).flatMap(MediaSessionPlayerUi::getSessionToken).ifPresent(mediaStyle::setMediaSession);\n        // setup notification builder\n        builder.setStyle(mediaStyle)\n                .setPriority(NotificationCompat\n                .PRIORITY_HIGH)\n                .setVisibility(NotificationCompat\n                .VISIBILITY_PUBLIC)\n                .setCategory(NotificationCompat\n                .CATEGORY_TRANSPORT)\n                .setShowWhen(false)\n                .setSmallIcon(R.drawable\n                .ic_newpipe_triangle_white)\n                .setColor(ContextCompat\n                .getColor(player.getContext(),\n                R.color.dark_background_color))\n                .setColorized(player\n                .getPrefs()\n                .getBoolean(player.getContext()\n                .getString(R.string.notification_colorize_key), \n                true))\n                .setDeleteIntent(PendingIntentCompat\n                .getBroadcast(player\n                .getContext(),\n                NOTIFICATION_ID, new Intent(ACTION_CLOSE), \n        FLAG_UPDATE_CURRENT, false));\n        // set the initial value for the video thumbnail, updatable with updateNotificationThumbnail\n        setLargeIcon(builder);\n        return builder;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "403", "src_id": "M491", "code": "    @ResizeMode\n    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n\n    public static int nextResizeModeAndSaveToPrefs(final Player player,@ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n\n        // save the new resize mode so it can be restored in a future session\n        player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "404", "src_id": "M703", "code": "    @Override\n    protected Supplier<View> getListHeaderSupplier() {\n        return () -> {final CommentRepliesHeaderBinding binding = CommentRepliesHeaderBinding\n                    .inflate(activity.getLayoutInflater(), \n                    itemsList, false);final CommentsInfoItem item = commentsInfoItem; // load the author avatar\n            PicassoHelper.loadAvatar(item\n                    .getUploaderAvatars())\n                    .into(binding.authorAvatar)\n                    ; binding.authorAvatar\n                    .setVisibility(ImageStrategy\n                    .shouldLoadImages()\n                    ? View.VISIBLE : View\n                    .GONE)\n                    ; // setup author name and comment date\n            binding.authorName.setText(item\n                    .getUploaderName())\n                    ; binding.uploadDate.setText(Localization\n                    .relativeTimeOrTextual(getContext(), \n            item.getUploadDate(), \n            item.getTextualUploadDate()))\n            ; binding.authorTouchArea.setOnClickListener(v -> NavigationHelper.openCommentAuthorIfPresent(requireActivity(), item)); // setup like count, hearted and pinned\n            binding.thumbsUpCount.setText(Localization.likeCount(requireContext(), item.getLikeCount())); // for heartImage goneMarginEnd was used, but there is no way to tell ConstraintLayout\n            // not to use a different margin only when both the next two views are gone\n            ((ConstraintLayout.LayoutParams) binding.thumbsUpCount.getLayoutParams()).setMarginEnd(DeviceUtils.dpToPx((item.isHeartedByUploader() || item.isPinned() ? 8 : 16), requireContext())); binding.heartImage.setVisibility(item.isHeartedByUploader() ? View.VISIBLE : View.GONE); binding.pinnedImage.setVisibility(item.isPinned() ? View.VISIBLE : View.GONE); // setup comment content\n            TextLinkifier.fromDescription(binding.commentContent, item.getCommentText(), HtmlCompat.FROM_HTML_MODE_LEGACY, getServiceById(item.getServiceId()), item.getUrl(), disposables, null); binding.commentContent.setMovementMethod(LongPressLinkMovementMethod.getInstance());return binding.getRoot();};\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "180", "src_id": "M483", "code": "    @Operation(\n    summary = \"Checks if a PDF is greater, less or equal to a setPageCount\",\n    description = \"Input:PDF Output:Boolean Type:SISO\")@PostMapping(consumes = \"multipart/form-data\", value = \"/filter-page-count\")\n    public ResponseEntity<byte[]> pageCount(@ModelAttribute PDFComparisonAndCount request)throws IOException, InterruptedException {\n\n        MultipartFile inputFile = request.getFileInput();\n        int pageCount = request.getPageCount();\n        String comparator = request.getComparator();\n        // Load the PDF\n        PDDocument document = pdfDocumentFactory.load(inputFile);\n        int actualPageCount = document.getNumberOfPages();\n        boolean valid = false;\n        // Perform the comparison\n        switch (comparator) {\n            case \"Greater\":\n                valid = actualPageCount > pageCount;\n                break;\n            case \"Equal\":\n                valid = actualPageCount == pageCount;\n                break;\n            case \"Less\":\n                valid = actualPageCount < pageCount;\n                break;\n            default:\n                throw ExceptionUtils.createInvalidArgumentException(\"comparator\", comparator);\n        }\n\n        if (valid) {\n            return WebResponseUtils.multiPartFileToWebResponse(inputFile);\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "181", "src_id": "M602", "code": "    @PostMapping(value = \"/document-properties\", consumes = \"multipart/form-data\")@Operation(\n    summary = \"Get PDF document properties\",\n    description = \"Returns title, author, subject, etc. Input:PDF Output:JSON Type:SISO\")\n    public Map<String, String> getDocumentProperties(@ModelAttribute PDFFile file)throws IOException {\n        // Load the document in read-only mode to prevent modifications and ensure the integrity of\n        // the original file.\n        try (PDDocument document = pdfDocumentFactory.load(file.getFileInput(), true)) {\n            PDDocumentInformation info = document.getDocumentInformation();\n            Map<String, String> properties = new HashMap<>();\n            properties.put(\"title\", info.getTitle());\n            properties.put(\"author\", info.getAuthor());\n            properties.put(\"subject\", info.getSubject());\n            properties.put(\"keywords\", info.getKeywords());\n            properties.put(\"creator\", info.getCreator());\n            properties.put(\"producer\", info.getProducer());\n            properties.put(\"creationDate\", info.getCreationDate().toString());\n            properties.put(\"modificationDate\", info.getModificationDate().toString());\n            return properties;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "182", "src_id": "M581", "code": "    public List<PDDocument> splitPdfPages(PDDocument document, \n            int horizontalDivisions, int verticalDivisions)throws IOException {\n\n        List<PDDocument> splitDocuments = new ArrayList<>();\n\n        for (PDPage originalPage:document.getPages()) {\n            PDRectangle originalMediaBox = originalPage.getMediaBox();\n            float width = originalMediaBox.getWidth();\n            float height = originalMediaBox.getHeight();\n            float subPageWidth = width / horizontalDivisions;\n            float subPageHeight = height / verticalDivisions;\n            LayerUtility layerUtility = new LayerUtility(document);\n\n            for (int i = 0; i < horizontalDivisions; i++) {\n                for (int j = 0; j < verticalDivisions; j++) {\n\n                    PDDocument subDoc = new PDDocument();\n                    PDPage subPage = new PDPage(new PDRectangle(subPageWidth, subPageHeight));\n                    subDoc.addPage(subPage);\n\n                    PDFormXObject form = layerUtility.importPageAsForm(document, document.getPages().indexOf(originalPage));\n\n                    try (PDPageContentStream contentStream = \n                        new PDPageContentStream(\n                        subDoc, subPage, AppendMode.APPEND, true, true)) {\n\n                        // Set clipping area and position\n                        float translateX = -subPageWidth * i;\n                        // float translateY = height - subPageHeight * (verticalDivisions - j);\n                        float translateY = -subPageHeight * (verticalDivisions - 1 -j);\n                        contentStream.saveGraphicsState();\n                        contentStream.addRect(0, 0, subPageWidth, subPageHeight);\n                        contentStream.clip();\n                        contentStream.transform(new Matrix(1, 0, 0, 1, translateX, translateY));\n                        // Draw the form\n                        contentStream.drawForm(form);\n                        contentStream.restoreGraphicsState();\n                    }\n\n                    splitDocuments.add(subDoc);\n                }\n            }\n        }\n\n        return splitDocuments;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "183", "src_id": "M808", "code": "    public boolean isEndpointEnabled(String endpoint) {\n\n        String original = endpoint;\n        if (endpoint.startsWith(\"/\")) {\n            endpoint = endpoint.substring(1);\n        }\n\n        // Rule 1: Explicit flag wins - if disabled via disableEndpoint(), stay disabled\n        Boolean explicitStatus = endpointStatuses.get(endpoint);\n        if (Boolean.FALSE.equals(explicitStatus)) {\n            log.debug(\"isEndpointEnabled('{}') -> false (explicitly disabled)\", original);\n            return false;\n        }\n\n        // Rule 2: Functional-group override - check if endpoint belongs to any disabled functional\n        // group\n        for (String group:endpointGroups.keySet()) {\n            if ((disabledGroups.contains(group) \n                         && endpointGroups.get(group).contains(endpoint)\n                        )\n                         && !isToolGroup(group)) {\n                log.debug(\"isEndpointEnabled('{}') -> false (functional group '{}' disabled)\", original, group);\n                return false;\n            }\n        }\n\n        // Rule 3: Tool-group fallback - check if at least one alternative tool group is enabled\n        Set<String> alternatives = endpointAlternatives.get(endpoint);\n        if (alternatives != null && !alternatives.isEmpty()) {\n            boolean hasEnabledToolGroup = alternatives\n                    .stream()\n                    .anyMatch(toolGroup -> !disabledGroups\n                    .contains(toolGroup));\n            log.debug(\"isEndpointEnabled('{}') -> {} (tool groups check)\", original, hasEnabledToolGroup);\n            return hasEnabledToolGroup;\n        }\n\n        // Rule 4: Single-dependency check - if no alternatives defined, check if endpoint belongs\n        // to any disabled tool groups\n        for (String group:endpointGroups.keySet()) {\n            if (isToolGroup(group) && disabledGroups.contains(group) && endpointGroups.get(group).contains(endpoint)) {\n                log.debug(\"isEndpointEnabled('{}') -> false (single tool group '{}' disabled, no alternatives)\",\n                        original, group);\n                return false;\n            }\n        }\n\n        // Default: enabled if not explicitly disabled\n        boolean enabled = !Boolean.FALSE.equals(explicitStatus);\n        log.debug(\"isEndpointEnabled('{}') -> {} (default)\", original, enabled);\n        return enabled;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "184", "src_id": "M456", "code": "    private void setupLoadHandler() {\n\n        final long initStartTime = System.currentTimeMillis();\n        log.info(\"Setting up load handler at: {}\", initStartTime);\n        client.addLoadHandler(new CefLoadHandlerAdapter() {@Override public void onLoadingStateChange(CefBrowser browser, boolean isLoading, boolean canGoBack, boolean canGoForward) {log\n                        .debug(\"Loading state change - isLoading: {}, canGoBack: {}, canGoForward:\"\n                         + \" {}, browserInitialized: {}, Time elapsed: {}ms\",\n                        isLoading, canGoBack, canGoForward, browserInitialized,\n                        System.currentTimeMillis() - initStartTime)\n                        ;if (!isLoading && !browserInitialized) {log\n                            .info(\"Browser finished loading, preparing to initialize UI\"\n                             + \" components\")\n                            ; browserInitialized = true; SwingUtilities\n                            .invokeLater(() -> {try {if (loadingWindow \n                                         != null\n                                        ) {log.info(\"Starting UI initialization sequence\")\n                                        ; // Close loading window first\n                                loadingWindow.setVisible(false); loadingWindow\n                                        .dispose()\n                                        ; loadingWindow = null; log.info(\"Loading window disposed\")\n                                        ; // Then setup the main frame\n                                frame.setVisible(false); frame.dispose(); frame\n                                        .setOpacity(1.0f)\n                                        ; frame.setUndecorated(false); frame.pack(); frame\n                                        .setSize(UIScaling.scaleWidth(1280),\n                                        UIScaling.scaleHeight(800))\n                                        ; frame.setLocationRelativeTo(null); log\n                                        .debug(\"Frame reconfigured\")\n                                        ; // Show the main frame\n                                frame.setVisible(true); frame.requestFocus(); frame\n                                        .toFront()\n                                        ; log.info(\"Main frame displayed and focused\"); // Focus the browser component\n                                Timer focusTimer = new Timer(100, e -> {try {browser\n                                                .getUIComponent()\n                                                .requestFocus()\n                                                ; log.info(\"Browser component\" + \" focused\");} catch (Exception ex) {log\n                                                    .error(\"Error focusing\" + \" browser\", ex)\n                                                    ;}}); focusTimer.setRepeats(false); focusTimer\n                                        .start()\n                                ;}} catch (Exception e) {log.error(\"Error during UI initialization\", e); // Attempt cleanup on error\n                                if (loadingWindow != null) {loadingWindow.dispose(); loadingWindow = null;} if (frame != null) {frame.setVisible(true); frame.requestFocus();}}})\n                    ;}}});\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "185", "src_id": "M577", "code": "    private void processWithTesseract(List<String> selectedLanguages, \n            String ocrType, Path tempInputFile, Path tempOutputFile)throws IOException, InterruptedException {\n\n        // Create temp directory for Tesseract processing\n        try (TempDirectory tempDir = new TempDirectory(tempFileManager)) {\n            File tempOutputDir = new File(tempDir.getPath().toFile(), \"output\");\n            File tempImagesDir = new File(tempDir.getPath().toFile(), \"images\");\n            File finalOutputFile = new File(tempDir.getPath().toFile(), \"final_output.pdf\");\n            // Create directories\n            tempOutputDir.mkdirs();\n            tempImagesDir.mkdirs();\n\n            PDFMergerUtility merger = new PDFMergerUtility();\n            merger.setDestinationFileName(finalOutputFile.toString());\n\n            try (PDDocument document = pdfDocumentFactory.load(tempInputFile.toFile())) {\n\n                PDFRenderer pdfRenderer = new PDFRenderer(document);\n                int pageCount = document.getNumberOfPages();\n\n                for (int pageNum = 0; pageNum < pageCount; pageNum++) {\n\n                    PDPage page = document.getPage(pageNum);\n                    boolean hasText = false;\n\n                    // Check for existing text\n                    try (PDDocument tempDoc = new PDDocument()) {\n                        tempDoc.addPage(page);\n\n                        PDFTextStripper stripper = new PDFTextStripper();\n                        hasText = !stripper.getText(tempDoc).trim().isEmpty();\n                    }\n\n                    boolean shouldOcr = switch (ocrType) {case \"skip-text\" -> !hasText;case \"force-ocr\" -> true;default -> true;};\n                    File pageOutputPath = new File(tempOutputDir, String.format(\"page_%d.pdf\", pageNum));\n\n                    if (!shouldOcr) {\n                        // Save original page without OCR\n                        try (PDDocument pageDoc = new PDDocument()) {\n                            pageDoc.addPage(page);\n                            pageDoc.save(pageOutputPath);\n                            merger.addSource(pageOutputPath);\n                        }\n                    } else {\n                        // Convert page to image\n                        BufferedImage image = pdfRenderer.renderImageWithDPI(pageNum, 300);\n                        File imagePath = new File(tempImagesDir, String.format(\"page_%d.png\", pageNum));\n                        ImageIO.write(image, \"png\", imagePath);\n\n                        // Build OCR command\n                        List<String> command = new ArrayList<>();\n                        command.add(\"tesseract\");\n                        command.add(imagePath.toString());\n                        command.add(new File(tempOutputDir, String.format(\"page_%d\", pageNum)).toString());\n                        command.add(\"-l\");\n                        command.add(String.join(\"+\", selectedLanguages));\n                        command.add(\"pdf\"); // Always output PDF\n\n\n                        ProcessExecutorResult result = ProcessExecutor\n                                .getInstance(ProcessExecutor.Processes\n                                .TESSERACT)\n                                .runCommandWithOutputHandling(command);\n                        if (result.getRc() != 0) {\n                            throw ExceptionUtils.createRuntimeException(\"error.commandFailed\",\n                                    \"{0} command failed with exit code: {1}\",\n                                    null, \"Tesseract\", result.getRc());\n                        }\n                        // Add OCR'd PDF to merger\n                        merger.addSource(pageOutputPath);\n                    } \n                }\n            }\n\n            // Merge all pages into final PDF\n            merger.mergeDocuments(null);\n            // Copy final output to the expected location\n            Files.copy(finalOutputFile.toPath(),\n                    tempOutputFile, java.nio.file.StandardCopyOption\n                    .REPLACE_EXISTING);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "186", "src_id": "M29", "code": "    private boolean processJWTLicensePayload(String payload, LicenseContext context) {\n        try {\n            log.info(\"Processing license payload: {}\", payload);\n\n            JSONObject licenseData = new JSONObject(payload);\n            JSONObject licenseObj = licenseData.optJSONObject(\"license\");\n            if (licenseObj == null) {\n\n                String id = licenseData.optString(\"id\", null);\n                if (id != null) {\n                    log.info(\"Found license ID: {}\", id);\n                    licenseObj = licenseData; // Use the root object as the license object\n\n                } else {\n                    log.error(\"License data not found in payload\");\n                    return false;\n                }\n            }\n\n            String licenseId = licenseObj.optString(\"id\", \"unknown\");\n            log.info(\"Processing license with ID: {}\", licenseId);\n            // Check for floating license in license object\n            context.isFloatingLicense = licenseObj.optBoolean(\"floating\", false);\n            context.maxMachines = licenseObj.optInt(\"maxMachines\", 1);\n            if (context.isFloatingLicense) {\n                log.info(\"Detected floating license with max machines: {}\", context.maxMachines);\n            }\n\n            // Check expiry date\n            String expiryStr = licenseObj.optString(\"expiry\", null);\n            if (!(expiryStr != null && !\"null\".equals(expiryStr))) {\n                log.info(\"License has no expiration date\");\n            }// Extract account, product, policy info\n            else {\n                java.time.Instant expiry = java.time.Instant.parse(expiryStr);\n                java.time.Instant now = java.time.Instant.now();\n                if (now.isAfter(expiry)) {\n                    log.error(\"License has expired on {}\", expiryStr);\n                    return false;\n                }\n                log.info(\"License valid until {}\", expiryStr);\n            } \n\n            JSONObject accountObj = licenseData.optJSONObject(\"account\");\n            if (accountObj != null) {\n                String accountId = accountObj.optString(\"id\", \"unknown\");\n                log.info(\"License belongs to account: {}\", accountId);\n                // Verify this matches your expected account ID\n                if (!ACCOUNT_ID.equals(accountId)) {\n                    log.warn(\"License account ID does not match expected account ID\");\n                // You might want to fail verification here depending on your requirements\n                }\n            }\n\n            // Extract policy information if available\n            JSONObject policyObj = licenseData.optJSONObject(\"policy\");\n\n            if (policyObj != null) {\n\n                String policyId = policyObj.optString(\"id\", \"unknown\");\n                log.info(\"License uses policy: {}\", policyId);\n\n                // Check for floating license in policy\n                boolean policyFloating = policyObj.optBoolean(\"floating\", false);\n                int policyMaxMachines = policyObj.optInt(\"maxMachines\", 1);\n                // Policy settings take precedence\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                    log.info(\"Policy defines floating license with max machines: {}\", context.maxMachines);\n                }\n\n                // Extract max users and isEnterprise from policy or metadata\n                int users = policyObj.optInt(\"users\", 1);\n                context.isEnterpriseLicense = policyObj.optBoolean(\"isEnterprise\", false);\n\n                if (users > 0) {\n                    applicationProperties.getPremium().setMaxUsers(users);\n                    log.info(\"License allows for {} users\", users);\n                } else {\n\n                    // Try to get users from metadata if present\n                    Object metadataObj = policyObj.opt(\"metadata\");\n\n                    if (!(metadataObj instanceof JSONObject metadata)) {\n                        // Default value\n                        applicationProperties.getPremium().setMaxUsers(1);\n                        log.info(\"Using default of 1 user for license\");\n                    } else {\n                        users = metadata.optInt(\"users\", 1);\n                        applicationProperties.getPremium().setMaxUsers(users);\n                        log.info(\"License allows for {} users (from metadata)\", users);\n                        // Check for isEnterprise flag in metadata\n                        context.isEnterpriseLicense = metadata.optBoolean(\"isEnterprise\", false);\n                    } \n                }\n            }\n\n            return true;\n        } catch (Exception e) {\n                log.error(\"Error processing license payload: {}\", e.getMessage(), e);\n                return false;\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "187", "src_id": "M557", "code": "    @PostMapping(value = \"/add-page-numbers\", consumes = \"multipart/form-data\")@Operation(\n    summary = \"Add page numbers to a PDF document\",\n    description = \n    \"This operation takes an input PDF file and adds page numbers to it. Input:PDF\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> addPageNumbers(@ModelAttribute AddPageNumbersRequest request)throws IOException {\n\n        MultipartFile file = request.getFileInput();\n        String customMargin = request.getCustomMargin();\n        int position = request.getPosition();\n        int pageNumber = request.getStartingNumber();\n        String pagesToNumber = request.getPagesToNumber();\n        String customText = request.getCustomText();\n        float fontSize = request.getFontSize();\n        String fontType = request.getFontType();\n        PDDocument document = pdfDocumentFactory.load(file);\n        float marginFactor;\n        switch (customMargin.toLowerCase()) {\n            case \"small\":\n                marginFactor = 0.02f;\n                break;\n            case \"large\":\n                marginFactor = 0.05f;\n                break;\n            case \"x-large\":\n                marginFactor = 0.075f;\n                break;\n            case \"medium\":default:\n                marginFactor = 0.035f;\n                break;\n        }\n\n        if (pagesToNumber == null || pagesToNumber.isEmpty()) {\n            pagesToNumber = \"all\";\n        }\n        if (customText == null || customText.isEmpty()) {\n            customText = \"{n}\";\n        }\n\n        List<Integer> pagesToNumberList = GeneralUtils\n                .parsePageList(pagesToNumber.split(\",\"), \n                document.getNumberOfPages());\n\n        for (int i:pagesToNumberList) {\n\n            PDPage page = document.getPage(i);\n            PDRectangle pageSize = page.getMediaBox();\n\n            String text = customText.replace(\"{n}\", \n                    String.valueOf(pageNumber))\n                    .replace(\"{total}\", String.valueOf(document\n                    .getNumberOfPages()))\n                    .replace(\"{filename}\", Filenames.toSimpleFileName(file\n                    .getOriginalFilename())\n                    .replaceFirst(\"[.][^.]+$\", \"\"));\n\n            PDType1Font currentFont = switch (fontType\n                    .toLowerCase()\n                    ) {case \"courier\" -> new PDType1Font(Standard14Fonts\n                            .FontName\n                            .COURIER)\n                            ;case \"times\" -> new PDType1Font(Standard14Fonts\n                            .FontName\n                            .TIMES_ROMAN)\n                            ;default -> new PDType1Font(Standard14Fonts\n                            .FontName\n                            .HELVETICA)\n                            ;};\n\n            float x;\n            float y;\n\n            if (position == 5) {\n                // Calculate text width and font metrics\n                float textWidth = currentFont.getStringWidth(text) / 1000 * fontSize;\n                float ascent = currentFont.getFontDescriptor().getAscent() / 1000 * fontSize;\n                float descent = currentFont.getFontDescriptor().getDescent() / 1000 * fontSize;\n                float centerX = pageSize.getLowerLeftX() + (pageSize.getWidth() / 2);\n                float centerY = pageSize.getLowerLeftY() + (pageSize.getHeight() / 2);\n                x = centerX - (textWidth / 2);\n                y = centerY - (ascent + descent) / 2;\n            } else {\n\n                int xGroup = (position - 1) % 3;\n                int yGroup = 2 - (position - 1) / 3;\n                x = switch (xGroup) {case 0 -> pageSize\n                                .getLowerLeftX()\n                                 + marginFactor * pageSize.getWidth()\n                                ; // left\n                                                case 1 -> pageSize.getLowerLeftX() + (pageSize\n                                .getWidth() \n                                 / 2\n                                )\n                                ; // center\n                                                default -> pageSize.getUpperRightX()\n                                -marginFactor * pageSize.getWidth()\n                                ; // right\n                                        };\n                y = switch (yGroup) {case 0 -> pageSize\n                                .getLowerLeftY()\n                                 + marginFactor * pageSize.getHeight()\n                                ; // bottom\n                                                case 1 -> pageSize.getLowerLeftY() + (pageSize\n                                .getHeight() \n                                 / 2\n                                )\n                                ; // middle\n                                                default -> pageSize.getUpperRightY()\n                                -marginFactor * pageSize.getHeight()\n                                ; // top\n                                        };\n            }\n\n            PDPageContentStream contentStream = new PDPageContentStream(document, \n                    page, PDPageContentStream.AppendMode.APPEND, \n                    true, true);\n            contentStream.beginText();\n            contentStream.setFont(currentFont, fontSize);\n            contentStream.newLineAtOffset(x, y);\n            contentStream.showText(text);\n            contentStream.endText();\n            contentStream.close();\n            pageNumber++;\n        }\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        document.save(baos);\n        document.close();\n        return WebResponseUtils.bytesToWebResponse(baos\n                .toByteArray(),\n                Filenames.toSimpleFileName(file.getOriginalFilename())\n                .replaceFirst(\"[.][^.]+$\", \"\")\n                 + \"_numbersAdded.pdf\",\n                MediaType.APPLICATION_PDF);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "188", "src_id": "M193", "code": "    public int calculateDynamicQueueCapacity(int baseCapacity, int minCapacity) {\n\n        ResourceMetrics metrics = latestMetrics.get();\n        ResourceStatus status = currentStatus.get();\n        // Simple linear reduction based on memory and CPU load\n        double capacityFactor = switch (status) {case OK -> 1.0;case WARNING -> 0.6;case CRITICAL -> 0.3;};\n        // Apply additional reduction based on specific memory pressure\n        if (metrics.memoryUsage > 0.8) {\n            capacityFactor *= 0.5; // Further reduce capacity under memory pressure\n\n        }\n\n        // Calculate capacity with minimum safeguard\n        int capacity = (int) Math.max(minCapacity, Math.ceil(baseCapacity * capacityFactor));\n        log.debug(\"Dynamic queue capacity: {} (base: {}, factor: {:.2f}, status: {})\",\n                capacity, baseCapacity, capacityFactor,\n                status);\n        return capacity;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "189", "src_id": "M141", "code": "    public StreamCacheCreateFunction getStreamCacheFunction(long contentSize) {\n\n        long maxMemory = Runtime.getRuntime().maxMemory();\n        long freeMemory = Runtime.getRuntime().freeMemory();\n        long totalMemory = Runtime.getRuntime().totalMemory();\n        long usedMemory = totalMemory - freeMemory;\n        // Calculate percentage of free memory\n        double freeMemoryPercent = (double) (maxMemory - usedMemory) / maxMemory * 100;\n        long actualFreeMemory = maxMemory - usedMemory;\n        // Log memory status\n        log.debug(\"Memory status - Free: {}MB ({}%), Used: {}MB, Max: {}MB\",\n                actualFreeMemory / (1024 * 1024), String\n                .format(\"%.2f\", freeMemoryPercent),\n                usedMemory / (1024 * 1024), maxMemory \n                 / (1024 * 1024));\n\n        // If free memory is critically low, always use file-based caching\n        if (freeMemoryPercent < MIN_FREE_MEMORY_PERCENTAGE || actualFreeMemory < MIN_FREE_MEMORY_BYTES) {\n            log.debug(\"Low memory detected ({}%), forcing file-based cache\",\n                    String.format(\"%.2f\", freeMemoryPercent));\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupTempFileOnly());\n        } else if (contentSize < SMALL_FILE_THRESHOLD) {\n            log.debug(\"Using memory-only cache for small document ({}KB)\", contentSize / 1024);\n            return IOUtils.createMemoryOnlyStreamCache();\n        } else if (contentSize >= LARGE_FILE_THRESHOLD) {\n            log.debug(\"Using file-based cache for large document\");\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupTempFileOnly());\n        } else {\n            // For medium files (10-50MB), use a mixed approach\n            log.debug(\"Using mixed memory/file cache for medium document ({}MB)\", contentSize / (1024 * 1024));\n            return createScratchFileCacheFunction(MemoryUsageSetting.setupMixed(LARGE_FILE_USAGE));\n        } \n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "139", "src_id": "M749", "code": "    private Object convertAttrValue(String attributeName, Object originAttrValue) {\n        Object attrValue = originAttrValue;\n        try {\n            if (originAttrValue instanceof ObjectName) {\n                attrValue = String.valueOf(originAttrValue);\n            } else if (attrValue instanceof CompositeData) {\n                //mbean java.lang:type=MemoryPool,name=*\n                CompositeData compositeData = (CompositeData) attrValue;\n                attrValue = convertCompositeData(attributeName, compositeData);\n            } else if (attrValue instanceof CompositeData[]) {\n                //mbean com.sun.management:type=HotSpotDiagnostic\n                CompositeData[] compositeDataArray = (CompositeData[]) attrValue;\n\n                List<Map<String, Object>> dataList = new ArrayList<Map<String, Object>>(compositeDataArray.length);\n                for (CompositeData compositeData : compositeDataArray) {\n                    dataList.add(convertCompositeData(attributeName, compositeData));\n                }\n\n                attrValue = dataList;\n            } else if (attrValue instanceof TabularData) {\n                //mbean java.lang:type=GarbageCollector,name=*\n                TabularData tabularData = (TabularData) attrValue;\n\n                Collection<CompositeData> compositeDataList = (Collection<CompositeData>) tabularData.values();\n\n                List<Map<String, Object>> dataList = new ArrayList<Map<String, Object>>(compositeDataList.size());\n                for (CompositeData compositeData : compositeDataList) {\n                    dataList.add(convertCompositeData(attributeName, compositeData));\n                }\n\n                attrValue = dataList;\n            }\n\n        } catch (Throwable e) {\n                logger.error(\"convert mbean attribute error, attribute: {}={}\", attributeName, originAttrValue, e);\n                attrValue = String.valueOf(originAttrValue);\n            }\n\n\n        return attrValue;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "140", "src_id": "M397", "code": "    public static int getItemCount(ResultModel model) {\n        //å¦æå®ç°Countableæ¥å£ï¼åè®¤ä¸ºmodelèªå·±ç»è®¡åç´ æ°é\n        if (model instanceof Countable) {\n            return ((Countable) model).size();\n        }\n        //å¯¹äºæ®éçModelï¼éè¿ç±»åå°ç»è®¡å®¹å¨ç±»å­æ®µç»è®¡åç´ æ°é\n        //ç¼å­Fieldå¯¹è±¡ï¼é¿åäº§çåå­ç¢ç\n        Class modelClass = model.getClass();\n        List<Field> fields = modelFieldMap.get(modelClass.getName());\n        if (fields == null) {\n            fields = new ArrayList<Field>();\n            Field[] declaredFields = modelClass.getDeclaredFields();\n            for (int i = 0; i < declaredFields.length; i++) {\n                Field field = declaredFields[i];\n                Class<?> fieldClass = field.getType();\n                //å¦ææ¯List/Map/Array/Countableç±»åçå­æ®µï¼åç¼å­èµ·æ¥åé¢ç»è®¡æ°é\n                if (Collection.class.isAssignableFrom(fieldClass) || Map.class.isAssignableFrom(fieldClass) || Countable.class.isAssignableFrom(fieldClass) || fieldClass.isArray()) {\n                    field.setAccessible(true);\n                    fields.add(field);\n                }\n            }\n\n            List<Field> old_fields = modelFieldMap.putIfAbsent(modelClass.getName(), fields);\n            if (old_fields != null) {\n                fields = old_fields;\n            }\n        }\n\n        //ç»è®¡Modelå¯¹è±¡çitemæ°é\n        int count = 0;\n        try {\n            for (int i = 0; i < fields.size(); i++) {\n                Field field = fields.get(i);\n                if (!field.isAccessible()) {\n                    field.setAccessible(true);\n                }\n                Object value = field.get(model);\n                if (value != null) {\n                    if (value instanceof Collection) {\n                        count += ((Collection) value).size();\n                    } else if (value.getClass().isArray()) {\n                        count += Array.getLength(value);\n                    } else if (value instanceof Map) {\n                        count += ((Map) value).size();\n                    } else if (value instanceof Countable) {\n                        count += ((Countable) value).size();\n                    }\n                }\n            }\n        } catch (Exception e) {\n                logger.error(\"get item count of result model failed, model: {}\", JSON.toJSONString(model), e);\n            }\n\n        if (count > 0) { \n            return count; \n        } else { \n            return 1; \n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "141", "src_id": "M1118", "code": "    public void evictSessions() {\n        long now = System.currentTimeMillis();\n        List<Session> toClose = new ArrayList<Session>();\n        for (Session session : sessions.values()) {\n            // do not close if there is still job running,\n            // e.g. trace command might wait for a long time before condition is met\n            //TODO check background job size\n            if (now - session.getLastAccessTime() > sessionTimeoutMillis && session.getForegroundJob() == null) {\n                toClose.add(session);\n            }\n\n            evictConsumers(session);\n        }\n        for (Session session : toClose) {\n            //interrupt foreground job\n            Job job = session.getForegroundJob();\n            if (job != null) {\n                job.interrupt();\n            }\n            long timeOutInMinutes = sessionTimeoutMillis / 1000 / 60;\n\n            String reason = \"session is inactive for \" + timeOutInMinutes + \" min(s).\";\n\n            SharingResultDistributor resultDistributor = session.getResultDistributor();\n            if (resultDistributor != null) {\n                resultDistributor.appendResult(new MessageModel(reason));\n            }\n\n            this.removeSession(session.getSessionId());\n            logger.info(\"Removing inactive session: {}, last access time: {}\", session.getSessionId(), session.getLastAccessTime());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "142", "src_id": "M526", "code": "    private TableElement drawTomcatInfo(TomcatInfoVO tomcatInfo) {\n        if (tomcatInfo == null) {\n            return null;\n        }\n        //header\n        TableElement table = new TableElement(1, 1).rightCellPadding(1);\n\n        table.add(new RowElement().style(Decoration.bold.fg(Color.black).bg(Color.white)).add(\"Tomcat\", \"\"));\n\n        if (tomcatInfo.getConnectorStats() != null) {\n            for (TomcatInfoVO.ConnectorStats connectorStat : tomcatInfo.getConnectorStats()) {\n                table.add(new RowElement().style(Decoration.bold.bold()).add(\"connector\", connectorStat.getName()));\n                table.row(\"QPS\", String.format(\"%.2f\", connectorStat.getQps()));\n                table.row(\"RT(ms)\", String.format(\"%.2f\", connectorStat.getRt()));\n                table.row(\"error/s\", String.format(\"%.2f\", connectorStat.getError()));\n                table.row(\"received/s\", formatBytes(connectorStat.getReceived()));\n                table.row(\"sent/s\", formatBytes(connectorStat.getSent()));\n            }\n        }\n\n        if (tomcatInfo.getThreadPools() != null) {\n            for (TomcatInfoVO.ThreadPool threadPool : tomcatInfo.getThreadPools()) {\n                table.add(new RowElement().style(Decoration.bold.bold()).add(\"threadpool\", threadPool.getName()));\n                table.row(\"busy\", \"\" + threadPool.getBusy());\n                table.row(\"total\", \"\" + threadPool.getTotal());\n            }\n        }\n\n        return table;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "143", "src_id": "M1130", "code": "    private ApiResponse processExecRequest(ApiRequest apiRequest, Session session) {\n        boolean oneTimeAccess = false;\n        if (session.get(ONETIME_SESSION_KEY) != null) {\n            oneTimeAccess = true;\n        }\n\n        try {\n            String commandLine = apiRequest.getCommand();\n            Map<String, Object> body = new TreeMap<String, Object>();\n            body.put(\"command\", commandLine);\n            ApiResponse response = new ApiResponse();\n            response.setSessionId(session.getSessionId()).setBody(body);\n\n            if (!session.tryLock()) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n                return response;\n            }\n            int lock = session.getLock();\n            PackingResultDistributor packingResultDistributor = null;\n            Job job = null;\n            try {\n                Job foregroundJob = session.getForegroundJob();\n                if (foregroundJob != null) {\n                    response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                    logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                    return response;\n                }\n\n                packingResultDistributor = new PackingResultDistributorImpl(session);\n                //distribute result message both to origin session channel and request channel by CompositeResultDistributor\n                //ResultDistributor resultDistributor = new CompositeResultDistributorImpl(packingResultDistributor, session.getResultDistributor());\n                job = this.createJob(commandLine, session, packingResultDistributor);\n                session.setForegroundJob(job);\n                updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n                job.run();\n            } catch (Throwable e) {\n                    logger.error(\"Exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n                    response.setState(ApiState.FAILED).setMessage(\"Exec command failed:\" + e.getMessage());\n                    return response;\n                } finally {\n                    if (session.getLock() == lock) {\n                        session.unLock();\n                    }\n                }\n\n            //wait for job completed or timeout\n            Integer timeout = apiRequest.getExecTimeout();\n            if (timeout == null || timeout <= 0) {\n                timeout = DEFAULT_EXEC_TIMEOUT;\n            }\n            boolean timeExpired = !waitForJob(job, timeout);\n            if (timeExpired) {\n                logger.warn(\"Job is exceeded time limit, force interrupt it, jobId: {}\", job.id());\n                job.interrupt();\n                response.setState(ApiState.INTERRUPTED).setMessage(\"The job is exceeded time limit, force interrupt\");\n            } else {\n                response.setState(ApiState.SUCCEEDED);\n            }\n\n            //packing results\n            body.put(\"jobId\", job.id());\n            body.put(\"jobStatus\", job.status());\n            body.put(\"timeExpired\", timeExpired);\n\n            if (timeExpired) {\n                body.put(\"timeout\", timeout);\n            }\n\n            body.put(\"results\", packingResultDistributor.getResults());\n            response.setSessionId(session.getSessionId()) //.setConsumerId(consumerId)\n            .setBody(body);\n            return response;\n        } finally {\n                if (oneTimeAccess) {\n                    sessionManager.removeSession(session.getSessionId());\n                }\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "144", "src_id": "M542", "code": "    private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n\n            table.row(label(LoggerHelper\n                    .name)\n                    .style(Decoration.bold\n                    .bold()), \n                    label(\"\" + info.get(LoggerHelper\n                    .name)))\n                    .row(label(LoggerHelper\n                    .clazz)\n                    .style(Decoration.bold\n                    .bold()), \n                    label(\"\" + clazz.getName()))\n                    .row(label(LoggerHelper\n                    .classLoader)\n                    .style(Decoration.bold\n                    .bold()),\n                    label(\"\" + info.get(LoggerHelper\n                    .classLoader)))\n                    .row(label(LoggerHelper\n                    .classLoaderHash)\n                    .style(Decoration.bold\n            .bold()),\n                    label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                                .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper\n                    .additivity)\n                    .style(Decoration.bold\n                    .bold()),\n                    label(\"\" + info.get(LoggerHelper\n                    .additivity)))\n                    .row(label(LoggerHelper\n                    .codeSource)\n                    .style(Decoration.bold\n                    .bold()),\n                    label(\"\" + info.get(LoggerHelper\n                    .codeSource)));\n\n            @SuppressWarnings(\"unchecked\") List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n\n                    if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                        appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                    }\n                }\n\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "145", "src_id": "M493", "code": "    private void renderNode(StringBuilder sb, TraceNode node, Ansi highlighted) {\n        //render cost: [0.366865ms]\n        if (isPrintCost && node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode) node;\n            String costStr = renderCost(methodNode);\n            if (node == maxCostNode) {\n                // the node with max cost will be highlighted\n                sb.append(highlighted.a(costStr).reset().toString());\n            } else {\n                sb.append(costStr);\n            }\n        }\n\n        //render method name\n        if (node instanceof MethodNode) {\n            MethodNode methodNode = (MethodNode) node;\n\n            //clazz.getName() + \":\" + method.getName() + \"()\"\n            sb.append(methodNode.getClassName()).append(\":\").append(methodNode.getMethodName()).append(\"()\");\n\n            // #lineNumber\n            if (methodNode.getLineNumber() != -1) {\n                sb.append(\" #\").append(methodNode.getLineNumber());\n            }\n        } else if (node instanceof ThreadNode) {\n            //render thread info\n            ThreadNode threadNode = (ThreadNode) node;\n\n            //ts=2020-04-29 10:34:00;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@18b4aac2\n            sb.append(format(\"ts=%s;thread_name=%s;id=%d;is_daemon=%s;priority=%d;TCCL=%s\",\n                    DateUtils.formatDateTime(threadNode\n                    .getTimestamp()),\n                    threadNode.getThreadName(),\n                    threadNode.getThreadId(),\n                    threadNode.isDaemon(),\n                    threadNode.getPriority(),\n                    threadNode.getClassloader()));\n\n            //trace_id\n            if (threadNode.getTraceId() != null) {\n                sb.append(\";trace_id=\").append(threadNode.getTraceId());\n            }\n            if (threadNode.getRpcId() != null) {\n                sb.append(\";rpc_id=\").append(threadNode.getRpcId());\n            }\n        } else if (node instanceof ThrowNode) {\n            ThrowNode throwNode = (ThrowNode) node;\n\n            sb.append(\"throw:\").append(throwNode.getException()).append(\" #\").append(throwNode.getLineNumber()).append(\" [\").append(throwNode.getMessage()).append(\"]\");\n        } else {\n            throw new UnsupportedOperationException(\"unknown trace node: \" + node.getClass());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "347", "src_id": "M521", "code": "    private static String decodeQRCode(BufferedImage bufferedImage) {\n        LuminanceSource source;\n        if (bufferedImage.getRaster().getDataBuffer() instanceof DataBufferByte dataBufferByte) {\n            byte[] pixels = dataBufferByte.getData();\n            source = new PlanarYUVLuminanceSource(pixels,\n            bufferedImage.getWidth(), bufferedImage\n            .getHeight(),\n            0, 0, bufferedImage.getWidth(), bufferedImage\n            .getHeight(),\n            false);\n        } else if (bufferedImage.getRaster().getDataBuffer() instanceof DataBufferInt dataBufferInt) {\n            int[] pixels = dataBufferInt.getData();\n            byte[] newPixels = new byte[pixels.length];\n            for (int i = 0; i < pixels.length; i++) {\n                newPixels[i] = (byte) (pixels[i] & 0xff);\n            }\n            source = new PlanarYUVLuminanceSource(newPixels,\n            bufferedImage.getWidth(), bufferedImage\n            .getHeight(),\n            0, 0, bufferedImage.getWidth(), bufferedImage\n            .getHeight(),\n            false);\n        } else {\n            throw new IllegalArgumentException(\"BufferedImage must have 8-bit gray scale, 24-bit RGB, 32-bit ARGB (packed\"\n             + \" int), byte gray, or 3-byte/4-byte RGB image data\");\n        }\n\n\n        BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));\n        try {\n            Result result = new MultiFormatReader().decode(bitmap);\n            return result.getText();\n        } catch (NotFoundException e) {\n                return null; // there is no QR code in the image\n\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "348", "src_id": "M177", "code": "    private void executeJob(QueuedJob job) {\n        if (job.cancelled) {\n            log.debug(\"Job {} was cancelled, not executing\", job.jobId);\n            return;\n        }\n\n        jobExecutor.execute(() -> {log.debug(\"Executing queued job {} (queued at {})\", \n            job.jobId, job.queuedAt)\n            ;try {// Execute with timeout\n                Object result = executeWithTimeout(job\n                .work, \n                job.timeoutMs);// Process the result\n                if (result instanceof ResponseEntity) {job\n                    .future\n                    .complete((ResponseEntity<?>) result)\n                    ;} else {job.future.complete(ResponseEntity\n                    .ok(result))\n                    ;}} catch (Exception e) {log.error(\"Error executing queued job {}: {}\", \n                    job.jobId, e.getMessage(), e)\n                    ; job.future.completeExceptionally(e);}});\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "349", "src_id": "M843", "code": "    @DeleteMapping(\"/api/v1/general/job/{jobId}\")\n    public ResponseEntity<?> cancelJob(@PathVariable(\"jobId\") String jobId) {\n        log.debug(\"Request to cancel job: {}\", jobId);\n\n        // Verify that this job belongs to the current user\n        // We can use the current request's session to validate ownership\n        Object sessionJobIds = request.getSession().getAttribute(\"userJobIds\");\n        if (sessionJobIds == null || !(sessionJobIds instanceof java.util.Set) || !((java.util.Set<?>) sessionJobIds).contains(jobId)) {\n            // Either no jobs in session or jobId doesn't match user's jobs\n            log.warn(\"Unauthorized attempt to cancel job: {}\", jobId);\n            return ResponseEntity.status(403).body(Map.of(\"message\", \"You are not authorized to cancel this job\"));\n        }\n\n        // First check if the job is in the queue\n        boolean cancelled = false;\n        int queuePosition = -1;\n        if (jobQueue.isJobQueued(jobId)) {\n            queuePosition = jobQueue.getJobPosition(jobId);\n            cancelled = jobQueue.cancelJob(jobId);\n            log.info(\"Cancelled queued job: {} (was at position {})\", jobId, queuePosition);\n        }\n\n        // If not in queue or couldn't cancel, try to cancel in TaskManager\n        if (!cancelled) {\n            JobResult result = taskManager.getJobResult(jobId);\n            if (result != null && !result.isComplete()) {\n                // Mark as error with cancellation message\n                taskManager.setError(jobId, \"Job was cancelled by user\");\n                cancelled = true;\n                log.info(\"Marked job as cancelled in TaskManager: {}\", jobId);\n            }\n        }\n\n        if (cancelled) {\n            return ResponseEntity.ok(Map.of(\"message\",\n            \"Job cancelled successfully\", \"wasQueued\",\n            queuePosition >= 0, \"queuePosition\", queuePosition \n             >= 0 \n            ? queuePosition : \"n/a\"));\n        } else {\n            // Job not found or already complete\n            JobResult result = taskManager.getJobResult(jobId);\n            if (result == null) {\n                return ResponseEntity.notFound().build();\n            } else if (result.isComplete()) {\n                return ResponseEntity.badRequest().body(Map.of(\"message\", \"Cannot cancel job that is already complete\"));\n            } else {\n                return ResponseEntity.internalServerError().body(Map.of(\"message\", \"Failed to cancel job for unknown reason\"));\n            }\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "350", "src_id": "M516", "code": "    public ResponseEntity<String> printFile(@ModelAttribute PrintFileRequest request) throws IOException {\n        MultipartFile file = request.getFileInput();\n        String originalFilename = file.getOriginalFilename();\n        if (originalFilename != null && (originalFilename.contains(\"..\") || Paths.get(originalFilename).isAbsolute())) {\n            throw new IOException(\"Invalid file path detected: \" + originalFilename);\n        }\n\n        String printerName = request.getPrinterName();\n        String contentType = file.getContentType();\n        try {\n            // Find matching printer\n            PrintService[] services = PrintServiceLookup.lookupPrintServices(null, null);\n            PrintService selectedService = Arrays.stream(services)\n            .filter(service -> service.getName().toLowerCase()\n            .contains(printerName))\n            .findFirst()\n            .orElseThrow(() -> new IllegalArgumentException(\"No matching printer found\"));\n            log.info(\"Selected Printer: \" + selectedService.getName());\n            if (\"application/pdf\".equals(contentType)) {\n                PDDocument document = Loader.loadPDF(file.getBytes());\n                PrinterJob job = PrinterJob.getPrinterJob();\n                job.setPrintService(selectedService);\n                job.setPageable(new PDFPageable(document));\n                job.print();\n                document.close();\n            } else if (contentType.startsWith(\"image/\")) {\n                BufferedImage image = ImageIO.read(file.getInputStream());\n                PrinterJob job = PrinterJob.getPrinterJob();\n                job.setPrintService(selectedService);\n                job.setPrintable(new Printable() {public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {if (pageIndex \n                             != 0\n                            ) {return NO_SUCH_PAGE;}Graphics2D g2d = (Graphics2D) graphics; g2d\n                        .translate(pageFormat.getImageableX(), \n                        pageFormat.getImageableY())\n                        ; g2d.drawImage(image, 0, 0,(int) pageFormat\n                        .getImageableWidth(),\n                        (int) pageFormat.getImageableHeight(), null)\n                        ;return PAGE_EXISTS;}});\n                job.print();\n            }\n\n\n            return new ResponseEntity<>(\"File printed successfully to \" + selectedService.getName(), HttpStatus.OK);\n        } catch (Exception e) {\n                System.err.println(\"Failed to print: \" + e.getMessage());\n                return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "351", "src_id": "M522", "code": "    @PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\")\n    @Operation(\n    summary = \"Auto split PDF pages into separate documents\",\n    description = \n    \"This endpoint accepts a PDF file, scans each page for a specific QR code, and\"\n    + \" splits the document at the QR code boundaries. The output is a zip file\"\n    + \" containing each separate PDF document. Input:PDF Output:ZIP-PDF\"\n    + \" Type:SISO\")\n    public ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request) throws IOException {\n        MultipartFile file = request.getFileInput();\n        boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n        PDDocument document = null;\n        List<PDDocument> splitDocuments = new ArrayList<>();\n        Path zipFile = null;\n        byte[] data = null;\n        try {\n            document = pdfDocumentFactory.load(file.getInputStream());\n\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pdfRenderer.setSubsamplingAllowed(true);\n\n            for (int page = 0; page < document.getNumberOfPages(); ++page) {\n                BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n                String result = decodeQRCode(bim);\n                boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n                log.debug(\"detected qr code {}, code is vale={}\", result, isValidQrCode);\n                if (isValidQrCode && page != 0) {\n                    splitDocuments.add(new PDDocument());\n                }\n\n                if (!splitDocuments.isEmpty() && !isValidQrCode) {\n                    splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n                } else if (page == 0) {\n                    PDDocument firstDocument = new PDDocument();\n                    firstDocument.addPage(document.getPage(page));\n                    splitDocuments.add(firstDocument);\n                }\n\n                // If duplexMode is true and current page is a divider, then skip next page\n                if (duplexMode && isValidQrCode) {\n                    page += 1; \n                }\n            }\n            // Remove split documents that have no pages\n            splitDocuments.removeIf(pdDocument -> pdDocument.getNumberOfPages() == 0);\n            zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n\n            String filename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\");\n\n            try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile))) {\n                for (int i = 0; i < splitDocuments.size(); i++) {\n                    String fileName = filename + \"_\" + (i + 1) + \".pdf\";\n                    PDDocument splitDocument = splitDocuments.get(i);\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    splitDocument.save(baos);\n                    byte[] pdf = baos.toByteArray();\n                    ZipEntry pdfEntry = new ZipEntry(fileName);\n                    zipOut.putNextEntry(pdfEntry);\n                    zipOut.write(pdf);\n                    zipOut.closeEntry();\n                }\n            }\n\n            data = Files.readAllBytes(zipFile);\n            return WebResponseUtils.bytesToWebResponse(data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM);\n        } catch (Exception e) {\n                log.error(\"Error in auto split\", e);\n                throw e;\n            } finally {\n                // Clean up resources\n                if (document != null) {\n                    try {\n                        document.close();\n                    } catch (IOException e) {\n                            log.error(\"Error closing main PDDocument\", e);\n                        }\n\n                }\n\n                for (PDDocument splitDoc : splitDocuments) {\n                    try {\n                        splitDoc.close();\n                    } catch (IOException e) {\n                            log.error(\"Error closing split PDDocument\", e);\n                        }\n\n                }\n                if (zipFile != null) {\n                    try {\n                        Files.deleteIfExists(zipFile);\n                    } catch (IOException e) {\n                            log.error(\"Error deleting temporary zip file\", e);\n                        }\n\n                }\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "352", "src_id": "M550", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/auto-rename\")\n    @Operation(\n    summary = \"Extract header from PDF file\",\n    description = \n    \"This endpoint accepts a PDF file and attempts to extract its title or header\"\n    + \" based on heuristics. Input:PDF Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> extractHeader(@ModelAttribute ExtractHeaderRequest request) throws Exception {\n        MultipartFile file = request.getFileInput();\n        boolean useFirstTextAsFallback = Boolean.TRUE.equals(request.getUseFirstTextAsFallback());\n        PDDocument document = pdfDocumentFactory.load(file);\n        PDFTextStripper reader = new PDFTextStripper() {List<LineInfo> lineInfos = new ArrayList<>(); StringBuilder lineBuilder = new StringBuilder();float lastY = -1;float maxFontSizeInLine = 0.0f;int lineCount = 0;@Override protected void processTextPosition(TextPosition text) {if (lastY \n                     != text.getY() \n                     && lineCount < LINE_LIMIT\n                    ) {processLine(); lineBuilder = new StringBuilder(text\n                    .getUnicode())\n                    ; maxFontSizeInLine = text.getFontSizeInPt()\n                    ; lastY = text.getY(); lineCount += 1; } else if (lineCount \n                    < LINE_LIMIT\n                    ) {lineBuilder.append(text.getUnicode())\n                    ;if (text.getFontSizeInPt() > maxFontSizeInLine\n                        ) {maxFontSizeInLine = text.getFontSizeInPt()\n                        ;}}} private void processLine() {if (lineBuilder\n                    .length() \n                    > 0 \n                     && lineCount < LINE_LIMIT\n                    ) {lineInfos.add(new LineInfo(lineBuilder\n                    .toString(), \n                    maxFontSizeInLine))\n                    ;}}@Override public String getText(PDDocument doc) throws IOException {this\n                .lineInfos\n                .clear()\n                ;this.lineBuilder = new StringBuilder();this.lastY = -1;this.maxFontSizeInLine = 0.0f;this.lineCount = 0;super.getText(doc); processLine(); // Process the last line\n                // Merge lines with same font size\n                List<LineInfo> mergedLineInfos = new ArrayList<>();for (int i = 0; i < lineInfos.size(); i++) {String mergedText = lineInfos.get(i).text;float fontSize = lineInfos.get(i).fontSize;while (i + 1 < lineInfos.size() && lineInfos.get(i + 1).fontSize == fontSize) {mergedText += \" \" + lineInfos.get(i + 1).text; i += 1; }mergedLineInfos.add(new LineInfo(mergedText, fontSize));}// Sort lines by font size in descending order and get the first one\n                mergedLineInfos.sort(Comparator.comparing((LineInfo li) -> li.fontSize).reversed()); String title = mergedLineInfos.isEmpty() ? null : mergedLineInfos.get(0).text;return title != null ? title : (useFirstTextAsFallback ? (mergedLineInfos.isEmpty()? null : mergedLineInfos.get(mergedLineInfos.size() - 1).text) : null);} class LineInfo {String text;float fontSize; LineInfo(String text, float fontSize) {this.text = text;this.fontSize = fontSize;}}};\n        String header = reader.getText(document);\n        // Sanitize the header string by removing characters not allowed in a filename.\n        if (header != null && header.length() < 255) {\n            header = header.replaceAll(\"[/\\\\\\\\?%*:|\\\"<>]\", \"\").trim();\n            return WebResponseUtils.pdfDocToWebResponse(document, header + \".pdf\");\n        } else {\n            log.info(\"File has no good title to be found\");\n            return WebResponseUtils.pdfDocToWebResponse(document, Filenames.toSimpleFileName(file.getOriginalFilename()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "353", "src_id": "M618", "code": "    @Operation(\n    summary = \"Validate PDF Digital Signature\",\n    description = \n    \"Validates the digital signatures in a PDF file against default or custom\"\n    + \" certificates. Input:PDF Output:JSON Type:SISO\")\n    @PostMapping(value = \"/validate-signature\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)\n    public ResponseEntity<List<SignatureValidationResult>> validateSignature(@ModelAttribute SignatureValidationRequest request) throws IOException {\n        List<SignatureValidationResult> results = new ArrayList<>();\n        MultipartFile file = request.getFileInput();\n        MultipartFile certFile = request.getCertFile();\n        // Load custom certificate if provided\n        X509Certificate customCert = null;\n        if (certFile != null && !certFile.isEmpty()) {\n            try (ByteArrayInputStream certStream = new ByteArrayInputStream(certFile.getBytes())) {\n                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                customCert = (X509Certificate) cf.generateCertificate(certStream);\n            } catch (CertificateException e) {\n                    throw ExceptionUtils.createRuntimeException(\"error.invalidFormat\", \"Invalid {0} format: {1}\", e, \"certificate file\", e.getMessage());\n                }\n\n        }\n\n        try (PDDocument document = pdfDocumentFactory.load(file.getInputStream())) {\n            List<PDSignature> signatures = document.getSignatureDictionaries();\n\n            for (PDSignature sig : signatures) {\n                SignatureValidationResult result = new SignatureValidationResult();\n                try {\n                    byte[] signedContent = sig.getSignedContent(file.getInputStream());\n                    byte[] signatureBytes = sig.getContents(file.getInputStream());\n                    CMSProcessable content = new CMSProcessableByteArray(signedContent);\n                    CMSSignedData signedData = new CMSSignedData(content, signatureBytes);\n                    Store<X509CertificateHolder> certStore = signedData.getCertificates();\n                    SignerInformationStore signerStore = signedData.getSignerInfos();\n\n                    for (SignerInformation signer : signerStore.getSigners()) {\n                        X509CertificateHolder certHolder = (X509CertificateHolder) certStore.getMatches(signer.getSID()).iterator().next();\n                        X509Certificate cert = new JcaX509CertificateConverter().getCertificate(certHolder);\n                        boolean isValid = signer.verify(new JcaSimpleSignerInfoVerifierBuilder().build(cert));\n                        result.setValid(isValid);\n                        // Additional validations\n                        result.setChainValid(customCert != null\n                        ? certValidationService.validateCertificateChainWithCustomCert(cert, \n                        customCert)\n                         : certValidationService.validateCertificateChain(cert));\n                        result.setTrustValid(customCert != null\n                        ? certValidationService.validateTrustWithCustomCert(cert, \n                        customCert)\n                         : certValidationService.validateTrustStore(cert));\n                        result.setNotRevoked(!certValidationService.isRevoked(cert));\n                        result.setNotExpired(!cert.getNotAfter().before(new Date()));\n                        // Set basic signature info\n                        result.setSignerName(sig.getName());\n                        result.setSignatureDate(sig.getSignDate().getTime().toString());\n                        result.setReason(sig.getReason());\n                        result.setLocation(sig.getLocation());\n                        // Set new certificate details\n                        result.setIssuerDN(cert.getIssuerX500Principal().getName());\n                        result.setSubjectDN(cert.getSubjectX500Principal().getName());\n                        result.setSerialNumber(cert.getSerialNumber().toString(16)); // Hex format\n\n                        result.setValidFrom(cert.getNotBefore().toString());\n                        result.setValidUntil(cert.getNotAfter().toString());\n                        result.setSignatureAlgorithm(cert.getSigAlgName());\n\n                        // Get key size (if possible)\n                        try {\n                            result.setKeySize(((RSAPublicKey) cert.getPublicKey()).getModulus().bitLength());\n                        } catch (Exception e) {\n                                // If not RSA or error, set to 0\n                                result.setKeySize(0);\n                            }\n\n\n                        result.setVersion(String.valueOf(cert.getVersion()));\n                        // Set key usage\n                        List<String> keyUsages = new ArrayList<>();\n                        boolean[] keyUsageFlags = cert.getKeyUsage();\n                        if (keyUsageFlags != null) {\n                            String[] keyUsageLabels = {\"Digital Signature\", \"Non-Repudiation\", \"Key Encipherment\", \"Data Encipherment\", \"Key Agreement\", \"Certificate Signing\", \"CRL Signing\", \"Encipher Only\", \"Decipher Only\"};\n                            for (int i = 0; i < keyUsageFlags.length; i++) {\n                                if (keyUsageFlags[i]) {\n                                    keyUsages.add(keyUsageLabels[i]);\n                                }\n                            }\n                        }\n\n                        result.setKeyUsages(keyUsages);\n                        // Check if self-signed\n                        result.setSelfSigned(cert.getSubjectX500Principal().equals(cert.getIssuerX500Principal()));\n                    }\n                } catch (Exception e) {\n                        result.setValid(false);\n                        result.setErrorMessage(\"Signature validation failed: \" + e.getMessage());\n                    }\n\n                results.add(result);\n            }\n        }\n\n        return ResponseEntity.ok(results);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "354", "src_id": "M186", "code": "    public Map<String, Object> captureApplicationProperties() {\n        Map<String, Object> properties = new HashMap<>();\n        // Capture Legal properties\n        addIfNotEmpty(properties, \"legal_termsAndConditions\", applicationProperties.getLegal().getTermsAndConditions());\n        addIfNotEmpty(properties, \"legal_privacyPolicy\", applicationProperties.getLegal().getPrivacyPolicy());\n        addIfNotEmpty(properties, \"legal_accessibilityStatement\", applicationProperties.getLegal().getAccessibilityStatement());\n        addIfNotEmpty(properties, \"legal_cookiePolicy\", applicationProperties.getLegal().getCookiePolicy());\n        addIfNotEmpty(properties, \"legal_impressum\", applicationProperties.getLegal().getImpressum());\n        // Capture Security properties\n        addIfNotEmpty(properties, \"security_enableLogin\", applicationProperties.getSecurity().getEnableLogin());\n        addIfNotEmpty(properties, \"security_csrfDisabled\", applicationProperties.getSecurity().getCsrfDisabled());\n        addIfNotEmpty(properties, \"security_loginAttemptCount\", applicationProperties.getSecurity().getLoginAttemptCount());\n        addIfNotEmpty(properties, \"security_loginResetTimeMinutes\", applicationProperties.getSecurity().getLoginResetTimeMinutes());\n        addIfNotEmpty(properties, \"security_loginMethod\", applicationProperties.getSecurity().getLoginMethod());\n        // Capture OAuth2 properties (excluding sensitive information)\n        addIfNotEmpty(properties, \"security_oauth2_enabled\", applicationProperties.getSecurity().getOauth2().getEnabled());\n        if (applicationProperties.getSecurity().getOauth2().getEnabled()) {\n            addIfNotEmpty(properties, \"security_oauth2_autoCreateUser\", applicationProperties.getSecurity().getOauth2().getAutoCreateUser());\n            addIfNotEmpty(properties, \"security_oauth2_blockRegistration\", applicationProperties.getSecurity().getOauth2().getBlockRegistration());\n            addIfNotEmpty(properties, \"security_oauth2_useAsUsername\", applicationProperties.getSecurity().getOauth2().getUseAsUsername());\n            addIfNotEmpty(properties, \"security_oauth2_provider\", applicationProperties.getSecurity().getOauth2().getProvider());\n        }\n\n        // Capture System properties\n        addIfNotEmpty(properties, \"system_defaultLocale\", applicationProperties.getSystem().getDefaultLocale());\n        addIfNotEmpty(properties, \"system_googlevisibility\", applicationProperties.getSystem().getGooglevisibility());\n        addIfNotEmpty(properties, \"system_showUpdate\", applicationProperties.getSystem().isShowUpdate());\n        addIfNotEmpty(properties, \"system_showUpdateOnlyAdmin\", applicationProperties.getSystem().getShowUpdateOnlyAdmin());\n        addIfNotEmpty(properties, \"system_customHTMLFiles\", applicationProperties.getSystem().isCustomHTMLFiles());\n        addIfNotEmpty(properties, \"system_tessdataDir\", applicationProperties.getSystem().getTessdataDir());\n        addIfNotEmpty(properties, \"system_enableAlphaFunctionality\", applicationProperties.getSystem().getEnableAlphaFunctionality());\n        addIfNotEmpty(properties, \"system_enableAnalytics\", applicationProperties.getSystem().isAnalyticsEnabled());\n        // Capture UI properties\n        addIfNotEmpty(properties, \"ui_appName\", applicationProperties.getUi().getAppName());\n        addIfNotEmpty(properties, \"ui_homeDescription\", applicationProperties.getUi().getHomeDescription());\n        addIfNotEmpty(properties, \"ui_appNameNavbar\", applicationProperties.getUi().getAppNameNavbar());\n        // Capture Metrics properties\n        addIfNotEmpty(properties, \"metrics_enabled\", applicationProperties.getMetrics().getEnabled());\n        // Capture EnterpriseEdition properties\n        addIfNotEmpty(properties, \"enterpriseEdition_enabled\", applicationProperties.getPremium().isEnabled());\n        if (applicationProperties.getPremium().isEnabled()) {\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_autoUpdateMetadata\",\n            applicationProperties.getPremium().getProFeatures()\n            .getCustomMetadata()\n            .isAutoUpdateMetadata());\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_author\",\n            applicationProperties.getPremium().getProFeatures()\n            .getCustomMetadata()\n            .getAuthor());\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_creator\",\n            applicationProperties.getPremium().getProFeatures()\n            .getCustomMetadata()\n            .getCreator());\n            addIfNotEmpty(properties, \"enterpriseEdition_customMetadata_producer\",\n            applicationProperties.getPremium().getProFeatures()\n            .getCustomMetadata()\n            .getProducer());\n        }\n\n        // Capture AutoPipeline properties\n        addIfNotEmpty(properties, \"autoPipeline_outputFolder\", applicationProperties.getAutoPipeline().getOutputFolder());\n        return properties;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "355", "src_id": "M173", "code": "    public CompletableFuture<ResponseEntity<?>> queueJob(String jobId, int resourceWeight, Supplier<Object> work, long timeoutMs) {\n        // Create a CompletableFuture to track this job's completion\n        CompletableFuture<ResponseEntity<?>> future = new CompletableFuture<>();\n        // Create the queued job\n        QueuedJob job = new QueuedJob(jobId, resourceWeight, work, timeoutMs, Instant.now(), future, false);\n        // Store in our map for lookup\n        jobMap.put(jobId, job);\n        // Update stats\n        totalQueuedJobs += 1; \n        synchronized (queueLock) {\n            currentQueueSize = jobQueue.size();\n\n            // Try to add to the queue\n            try {\n                boolean added = jobQueue.offer(job, 5, TimeUnit.SECONDS);\n                if (!added) {\n                    log.warn(\"Queue full, rejecting job {}\", jobId);\n                    rejectedJobs += 1; \n                    future.completeExceptionally(new RuntimeException(\"Job queue full, please try again later\"));\n                    jobMap.remove(jobId);\n                    return future;\n                }\n\n                log.debug(\"Job {} queued for execution (weight: {}, queue size: {})\", jobId, resourceWeight, jobQueue.size());\n                return future;\n            } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    future.completeExceptionally(new RuntimeException(\"Job queue interrupted\"));\n                    jobMap.remove(jobId);\n                    return future;\n                }\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "356", "src_id": "M544", "code": "    private void applyQpdfCompression(OptimizePdfRequest request, int optimizeLevel, Path currentFile, List<Path> tempFiles) throws IOException {\n        long preQpdfSize = Files.size(currentFile);\n        log.info(\"Pre-QPDF file size: {}\", GeneralUtils.formatBytes(preQpdfSize));\n        // Map optimization levels to QPDF compression levels\n        int qpdfCompressionLevel;\n        if (optimizeLevel == 1) {\n            qpdfCompressionLevel = 5;\n        } else if (optimizeLevel == 2) { \n            }{\n\n            qpdfCompressionLevel = 9;\n        }\n        Path qpdfOutputFile = Files.createTempFile(\"qpdf_output_\", \".pdf\");\n        tempFiles.add(qpdfOutputFile);\n        // Build QPDF command\n        List<String> command = new ArrayList<>();\n        command.add(\"qpdf\");\n        if (request.getNormalize()) {\n            command.add(\"--normalize-content=y\");\n        }\n        if (request.getLinearize()) {\n            command.add(\"--linearize\");\n        }\n        command.add(\"--recompress-flate\");\n        command.add(\"--compression-level=\" + qpdfCompressionLevel);\n        command.add(\"--compress-streams=y\");\n        command.add(\"--object-streams=generate\");\n        command.add(currentFile.toString());\n        command.add(qpdfOutputFile.toString());\n        ProcessExecutorResult returnCode = null;\n        try {\n            returnCode = ProcessExecutor.getInstance(ProcessExecutor.Processes.QPDF).runCommandWithOutputHandling(command);\n            // Update current file to the QPDF output\n            Files.copy(qpdfOutputFile, currentFile, StandardCopyOption.REPLACE_EXISTING);\n\n            long postQpdfSize = Files.size(currentFile);\n            double qpdfReduction = 100.0 - ((postQpdfSize * 100.0) / preQpdfSize);\n            log.info(\"Post-QPDF file size: {} (reduced by {}%)\", GeneralUtils.formatBytes(postQpdfSize), String.format(\"%.1f\", qpdfReduction));\n        } catch (Exception e) {\n                if (returnCode != null && returnCode.getRc() != 3) {\n                    throw new IOException(\"QPDF command failed\", e);\n                }\n                // If QPDF fails, keep using the current file\n                log.warn(\"QPDF compression failed, continuing with current file\", e);\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "85", "src_id": "M1108", "code": "    @Override\n    public Object build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        if (! (data instanceof byte[])) {\n            return data;\n        }\n        String str = STRING.build(data);\n        if (str.charAt(0) == '{') {\n            try {\n                return new JSONObject(str);\n            } catch (Exception ex) {\n                }\n\n        } else if (str.charAt(0) == '[') {\n            try {\n                return new JSONArray(str);\n            } catch (Exception ex) {\n                }\n\n        }\n\n\n        return str;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "86", "src_id": "M1275", "code": "    @Override\n    public Document build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        String id = null;\n        Double score = null;\n        Map<String, Object> fields = null;\n        for (KeyValue kv : list) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            switch (key) {\n                case ID_STR:\n                    id = BuilderFactory.STRING.build(kv.getValue());\n                    break;\n                case SCORE_STR:\n                    score = BuilderFactory.DOUBLE.build(kv.getValue());\n                    break;\n                case FIELDS_STR:\n                    fields = makeFieldsMap(isFieldDecode, kv.getValue());\n                    break;\n            }\n        }\n\n        return new Document(id, score, fields);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "87", "src_id": "M1159", "code": "    @Override\n    public LibraryInfo build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        List list = (List) data;\n        if (list.isEmpty()) {\n            return null;\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            String libname = null;\n            String enginename = null;\n            String librarycode = null;\n            List<Map<String, Object>> functions = null;\n            for (KeyValue kv : (List<KeyValue>) list) {\n                switch (BuilderFactory.STRING.build(kv.getKey())) {\n                    case \"library_name\":\n                        libname = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"engine\":\n                        enginename = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                    case \"functions\":\n                        functions = ((List<Object>) kv.getValue()).stream().map(o -> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n                        break;\n                    case \"library_code\":\n                        librarycode = BuilderFactory.STRING.build(kv.getValue());\n                        break;\n                }\n            }\n\n            return new LibraryInfo(libname, enginename, functions, librarycode);\n        }\n\n        String libname = STRING.build(list.get(1));\n        String engine = STRING.build(list.get(3));\n        List<Object> rawFunctions = (List<Object>) list.get(5);\n\n        List<Map<String, Object>> functions = rawFunctions.stream().map(o -> ENCODED_OBJECT_MAP.build(o)).collect(Collectors.toList());\n        if (list.size() <= 6) {\n            return new LibraryInfo(libname, engine, functions);\n        }\n        String code = STRING.build(list.get(7));\n        return new LibraryInfo(libname, engine, functions, code);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "88", "src_id": "M934", "code": "    private Socket createSslSocket(HostAndPort _hostAndPort, Socket socket) throws IOException, GeneralSecurityException {\n        Socket plainSocket = socket;\n        SSLSocketFactory _sslSocketFactory;\n        SSLParameters _sslParameters;\n        if (sslOptions != null) {\n            SSLContext _sslContext = sslOptions.createSslContext();\n            _sslSocketFactory = _sslContext.getSocketFactory();\n            _sslParameters = sslOptions.getSslParameters();\n        } else {\n            _sslSocketFactory = this.sslSocketFactory;\n            _sslParameters = this.sslParameters;\n        }\n\n        if (_sslSocketFactory == null) {\n            _sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();\n        }\n\n        SSLSocket sslSocket = (SSLSocket) _sslSocketFactory.createSocket(socket, _hostAndPort.getHost(), _hostAndPort.getPort(), true);\n        if (_sslParameters != null) {\n            sslSocket.setSSLParameters(_sslParameters);\n        }\n\n        // allowing HostnameVerifier for both SslOptions and legacy ssl config\n        if (hostnameVerifier != null && !hostnameVerifier.verify(_hostAndPort.getHost(), sslSocket.getSession())) {\n            String message = String.format(\"The connection to '%s' failed ssl/tls hostname verification.\", _hostAndPort.getHost());\n\n            throw new JedisConnectionException(message);\n        }\n\n        return new SSLSocketWrapper(sslSocket, plainSocket);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "89", "src_id": "M1304", "code": "    @Override\n    public AggregationResult build(Object data) {\n        // return new AggregationResult(data);\n        List list = (List) data;\n        if (list.get(0) instanceof KeyValue) {\n            List<KeyValue> kvList = (List<KeyValue>) data;\n            long totalResults = -1;\n            List<Map<String, Object>> results = null;\n            List<String> warnings = null;\n            for (KeyValue kv : kvList) {\n                String key = BuilderFactory.STRING.build(kv.getKey());\n                Object rawVal = kv.getValue();\n                switch (key) {\n                    case TOTAL_RESULTS_STR:\n                        totalResults = BuilderFactory.LONG.build(rawVal);\n                        break;\n                    case RESULTS_STR:\n                        List<List<KeyValue>> resList = (List<List<KeyValue>>) rawVal;\n                        results = new ArrayList<>(resList.size());\n                        for (List<KeyValue> rikv : resList) {\n                            for (KeyValue ikv : rikv) {\n                                if (FIELDS_STR.equals(BuilderFactory.STRING.build(ikv.getKey()))) {\n                                    results.add(BuilderFactory.ENCODED_OBJECT_MAP.build(ikv.getValue()));\n                                    break;\n                                }\n                            }\n                        }\n                        break;\n                    case WARNINGS_STR:\n                        warnings = BuilderFactory.STRING_LIST.build(rawVal);\n                        break;\n                }\n            }\n\n            return new AggregationResult(totalResults, results, warnings);\n        }\n\n        list = (List<Object>) SafeEncoder.encodeObject(data);\n        // the first element is always the number of results\n        long totalResults = (Long) list.get(0);\n\n        List<Map<String, Object>> results = new ArrayList<>(list.size() - 1);\n        for (int i = 1; i < list.size(); i++) {\n            List<Object> mapList = (List<Object>) list.get(i);\n\n            Map<String, Object> map = new HashMap<>(mapList.size() / 2, 1f);\n            for (int j = 0; j < mapList.size(); j += 2) {\n                Object r = mapList.get(j);\n                if (r instanceof JedisDataException) {\n                    throw (JedisDataException) r;\n                }\n\n                map.put((String) r, mapList.get(j + 1));\n            }\n\n            results.add(map);\n        }\n\n        return new AggregationResult(totalResults, results);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "90", "src_id": "M959", "code": "    private void process() {\n        do {\n            Object reply = authenticator.client.getUnflushedObject();\n            if (reply instanceof List) {\n                List<Object> listReply = (List<Object>) reply;\n                final Object firstObj = listReply.get(0);\n                if (! (firstObj instanceof byte[])) {\n                    throw new JedisException(\"Unknown message type: \" + firstObj);\n                }\n                final byte[] resp = (byte[]) firstObj;\n                if (Arrays.equals(SUBSCRIBE.getRaw(), resp)) {\n                    subscribedChannels = ((Long) listReply.get(2)).intValue();\n\n                    final byte[] bchannel = (byte[]) listReply.get(1);\n\n                    final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                    onSubscribe(enchannel, subscribedChannels);\n                } else if (Arrays.equals(UNSUBSCRIBE.getRaw(), resp)) {\n                    subscribedChannels = ((Long) listReply.get(2)).intValue();\n\n                    final byte[] bchannel = (byte[]) listReply.get(1);\n\n                    final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                    onUnsubscribe(enchannel, subscribedChannels);\n                } else if (Arrays.equals(MESSAGE.getRaw(), resp)) {\n                    final byte[] bchannel = (byte[]) listReply.get(1);\n                    final Object mesg = listReply.get(2);\n                    final T enchannel = (bchannel == null) ? null : encode(bchannel);\n                    if (mesg instanceof List) {\n                        ((List<byte[]>) mesg).forEach(bmesg -> onMessage(enchannel, encode(bmesg)));\n                    } else {\n                        onMessage(enchannel, (mesg == null) ? null : encode((byte[]) mesg));\n                    }\n                } else if (Arrays.equals(PMESSAGE.getRaw(), resp)) {\n                    final byte[] bpattern = (byte[]) listReply.get(1);\n                    final byte[] bchannel = (byte[]) listReply.get(2);\n                    final byte[] bmesg = (byte[]) listReply.get(3);\n\n                    final T enpattern = (bpattern == null) ? null : encode(bpattern);\n\n                    final T enchannel = (bchannel == null) ? null : encode(bchannel);\n\n                    final T enmesg = (bmesg == null) ? null : encode(bmesg);\n                    onPMessage(enpattern, enchannel, enmesg);\n                } else if (Arrays.equals(PSUBSCRIBE.getRaw(), resp)) {\n                    subscribedChannels = ((Long) listReply.get(2)).intValue();\n\n                    final byte[] bpattern = (byte[]) listReply.get(1);\n\n                    final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                    onPSubscribe(enpattern, subscribedChannels);\n                } else if (Arrays.equals(PUNSUBSCRIBE.getRaw(), resp)) {\n                    subscribedChannels = ((Long) listReply.get(2)).intValue();\n\n                    final byte[] bpattern = (byte[]) listReply.get(1);\n\n                    final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                    onPUnsubscribe(enpattern, subscribedChannels);\n                } else if (Arrays.equals(PONG.getRaw(), resp)) {\n                    final byte[] bpattern = (byte[]) listReply.get(1);\n\n                    final T enpattern = (bpattern == null) ? null : encode(bpattern);\n                    onPong(enpattern);\n                } else {\n                    throw new JedisException(\"Unknown message type: \" + firstObj);\n                }\n            } else if (reply instanceof byte[]) {\n                Consumer<Object> resultHandler = authenticator.resultHandler.poll();\n                if (resultHandler == null) {\n                    throw new JedisException(\"Unexpected message : \" + SafeEncoder.encode((byte[]) reply));\n                }\n\n                resultHandler.accept(reply);\n            } else {\n                throw new JedisException(\"Unknown message type: \" + reply);\n            }\n        } while (!Thread.currentThread().isInterrupted() && isSubscribed());\n    //    /* Invalidate instance since this thread is no longer listening */\n    //    this.client = null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "91", "src_id": "M1145", "code": "    @Override\n    public final <T> T broadcastCommand(CommandObject<T> commandObject) {\n        Map<String, ConnectionPool> connectionMap = provider.getConnectionMap();\n        boolean isErrored = false;\n        T reply = null;\n        JedisBroadcastException bcastError = new JedisBroadcastException();\n        for (Map.Entry<String, ConnectionPool> entry : connectionMap.entrySet()) {\n            HostAndPort node = HostAndPort.from(entry.getKey());\n            ConnectionPool pool = entry.getValue();\n\n            try (Connection connection = pool.getResource()) {\n                T aReply = execute(connection, commandObject);\n                bcastError.addReply(node, aReply);\n\n                if (isErrored) { // already errored\n                } else if (reply == null) {\n                    reply = aReply; // ok\n\n                } else if (reply.equals(aReply)) {\n                // ok\n                } else {\n                    isErrored = true;\n                    reply = null;\n                }\n\n            } catch (Exception anError) {\n                    bcastError.addReply(node, anError);\n                    isErrored = true;\n                }\n\n        }\n\n        if (isErrored) {\n            throw bcastError;\n        }\n\n        return reply;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "92", "src_id": "M52", "code": "    @Override\n    public Map<String, Object> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (list.get(0) instanceof KeyValue) {\n            final Map<String, Object> map = new HashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));\n            }\n\n            return map;\n        } else {\n            final Map<String, Object> map = new HashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));\n            }\n\n            return map;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "93", "src_id": "M34", "code": "    @Override\n    public boolean isCacheable(ProtocolCommand command, List<Object> keys) {\n        if (allowCommands != null && !allowCommands.contains(command)) {\n            return false;\n        }\n        if (denyCommands != null && denyCommands.contains(command)) {\n            return false;\n        }\n\n        for (Object key : keys) {\n            if (! (key instanceof String)) {\n                return false;\n            }\n            if (allowKeys != null && !allowKeys.contains((String) key)) {\n                return false;\n            }\n            if (denyKeys != null && denyKeys.contains((String) key)) {\n                return false;\n            }\n        }\n\n        return DefaultCacheable.isDefaultCacheableCommand(command);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "94", "src_id": "M28", "code": "    @Override\n    public <T> T executeCommand(final CommandObject<T> commandObject) {\n        final CacheKey cacheKey = new CacheKey(commandObject);\n        if (!cache.isCacheable(cacheKey)) {\n            cache.getStats().nonCacheable();\n            return super.executeCommand(commandObject);\n        }\n        CacheEntry<T> cacheEntry = cache.get(cacheKey);\n        if (cacheEntry != null) { // (probable) CACHE HIT !!\n\n            cacheEntry = validateEntry(cacheEntry);\n\n            if (cacheEntry != null) {\n                // CACHE HIT confirmed !!!\n                cache.getStats().hit();\n                return cacheEntry.getValue();\n            }\n        }\n\n        // CACHE MISS !!\n        cache.getStats().miss();\n        T value = super.executeCommand(commandObject);\n        cacheEntry = new CacheEntry<>(cacheKey, value, this);\n        cache.set(cacheKey, cacheEntry);\n        // this line actually provides a deep copy of cached object instance \n        value = cacheEntry.getValue();\n        return value;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "240", "src_id": "M951", "code": "    @Override\n    protected void subscribeActual(CompletableObserver observer) {\n        InnerCompletableCache inner = new InnerCompletableCache(observer);\n        observer.onSubscribe(inner);\n        if (!add(inner)) {\n            Throwable ex = error;\n            if (ex != null) {\n                observer.onError(ex);\n            } else {\n                observer.onComplete();\n            }\n        } else {\n            if (inner.isDisposed()) {\n                remove(inner);\n            }\n\n            if (once.compareAndSet(false, true)) {\n                source.subscribe(this);\n            }\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "241", "src_id": "M961", "code": "    @Override\n    public boolean tryOnError(Throwable t) {\n        if (t == null) {\n            t = ExceptionHelper.createNullPointerException(\"onError called with a null Throwable.\");\n        }\n\n        if (get() != DisposableHelper.DISPOSED) {\n            Disposable d = getAndSet(DisposableHelper.DISPOSED);\n            if (d != DisposableHelper.DISPOSED) {\n                try {\n                    downstream.onError(t);\n                } finally {\n                        if (d != null) {\n                            d.dispose();\n                        }\n                    }\n\n                return true;\n            }\n        }\n        return false;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "242", "src_id": "M453", "code": "    @SuppressWarnings(\"unchecked\")\n    public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) {\n        if (source instanceof Supplier) {\n            T t;\n\n            try {\n                t = ((Supplier<T>) source).get();\n            } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n\n                    EmptyDisposable.error(ex, observer);\n\n                    return true;\n                }\n\n\n            if (t == null) {\n                EmptyDisposable.complete(observer);\n\n                return true;\n            }\n\n            ObservableSource<? extends R> r;\n\n            try {\n                r = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");\n            } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n\n                    EmptyDisposable.error(ex, observer);\n\n                    return true;\n                }\n\n\n            if (!(r instanceof Supplier)) {\n                r.subscribe(observer);\n            } else {\n                R u;\n\n                try {\n                    u = ((Supplier<R>) r).get();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n\n                        EmptyDisposable.error(ex, observer);\n\n                        return true;\n                    }\n\n\n                if (u == null) {\n                    EmptyDisposable.complete(observer);\n\n                    return true;\n                }\n\n                ScalarDisposable<R> sd = new ScalarDisposable<>(observer, u);\n                observer.onSubscribe(sd);\n\n                sd.run();\n            } \n\n            return true;\n        }\n\n        return false;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "243", "src_id": "M267", "code": "    void drainLoop() {\n        int missed = 1;\n        Observer<? super R> a = downstream;\n        AtomicInteger n = active;\n        AtomicReference<SpscLinkedArrayQueue<R>> qr = queue;\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    clear();\n\n                    return;\n                }\n\n                if (!delayErrors) {\n                    Throwable ex = errors.get();\n                    if (ex != null) {\n                        clear();\n\n                        errors.tryTerminateConsumer(a);\n\n                        return;\n                    }\n                }\n\n                boolean d = n.get() == 0;\n                SpscLinkedArrayQueue<R> q = qr.get();\n                R v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "244", "src_id": "M1163", "code": "    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        final SimplePlainQueue<Object> queue = this.queue;\n        final Subscriber<? super Flowable<T>> downstream = this.downstream;\n        UnicastProcessor<T> window = this.window;\n\n        for (;;) {\n            if (upstreamCancelled) {\n                queue.clear();\n\n                window = null;\n\n                this.window = null;\n            } else {\n                boolean isDone = done;\n                Object o = queue.poll();\n                boolean isEmpty = o == null;\n\n                if (isDone && isEmpty) {\n                    Throwable ex = error;\n                    if (ex != null) {\n                        if (window != null) {\n                            window.onError(ex);\n                        }\n                        downstream.onError(ex);\n                    } else {\n                        if (window != null) {\n                            window.onComplete();\n                        }\n                        downstream.onComplete();\n                    }\n                    cleanupResources();\n\n                    upstreamCancelled = true;\n\n                    continue;\n                } else if (!isEmpty) {\n                    if (o instanceof WindowBoundaryRunnable) {\n                        WindowBoundaryRunnable boundary = (WindowBoundaryRunnable) o;\n                        if (boundary.index == emitted || !restartTimerOnMaxSize) {\n                            this.count = 0;\n\n                            window = createNewWindow(window);\n                        }\n                    } else if (window != null) {\n                        @SuppressWarnings(\"unchecked\") T item = (T) o;\n                        window.onNext(item);\n\n                        long count = this.count + 1;\n                        if (count != maxSize) {\n                            this.count = count;\n                        } else {\n                            this.count = 0;\n\n                            window = createNewWindow(window);\n                        } \n                    }\n\n\n                    continue;\n                }\n\n\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "245", "src_id": "M598", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        Subscriber<? super R> a = downstream;\n        Iterator<? extends R> iterator = this.it;\n        if (outputFused && iterator != null) {\n            a.onNext(null);\n\n            a.onComplete();\n\n            return;\n        }\n\n        int missed = 1;\n\n        for (;;) {\n            if (iterator != null) {\n                long r = requested.get();\n                if (r == Long.MAX_VALUE) {\n                    fastPath(a, iterator);\n\n                    return;\n                }\n\n                long e = 0L;\n                while (e != r) {\n                    if (cancelled) {\n                        return;\n                    }\n\n                    R v;\n\n                    try {\n                        v = Objects.requireNonNull(iterator.next(), \"The iterator returned a null value\");\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n\n                            a.onError(ex);\n\n                            return;\n                        }\n\n\n                    a.onNext(v);\n                    if (cancelled) {\n                        return;\n                    }\n                    e++;\n\n                    boolean b;\n\n                    try {\n                        b = iterator.hasNext();\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n\n                            a.onError(ex);\n\n                            return;\n                        }\n\n\n                    if (b) { \n                        continue; \n                    }  \n                    a.onComplete();\n\n                    return;\n                }\n\n                if (e != 0L) {\n                    BackpressureHelper.produced(requested, e);\n                }\n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n\n            if (iterator == null) {\n                iterator = it;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "246", "src_id": "M1224", "code": "    void drainLoop() {\n        Subscriber<? super T> actual = this.downstream;\n        int missed = 1;\n        long e = emitted;\n        int c = consumed;\n        int lim = limit;\n\n        for (;;) {\n            long r = requested.get();\n\n            while (e != r) {\n                if (cancelled) {\n                    singleItem = null;\n\n                    queue = null;\n\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    singleItem = null;\n\n                    queue = null;\n\n                    errors.tryTerminateConsumer(downstream);\n\n                    return;\n                }\n\n                int os = otherState;\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n                    singleItem = null;\n\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n\n                    actual.onNext(v);\n\n                    e++;\n\n                    continue;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                T v = q != null ? q.poll() : null;\n                boolean empty = v == null;\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n\n                    actual.onComplete();\n\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n                actual.onNext(v);\n\n                e++;\n                if (++c != lim) { \n                    continue; \n                }  \n                c = 0;\n\n                mainSubscription.get().request(lim);\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    singleItem = null;\n\n                    queue = null;\n\n                    return;\n                }\n\n                if (errors.get() != null) {\n                    singleItem = null;\n\n                    queue = null;\n\n                    errors.tryTerminateConsumer(downstream);\n\n                    return;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                boolean empty = q == null || q.isEmpty();\n                if (d && empty && otherState == 2) {\n                    queue = null;\n\n                    actual.onComplete();\n\n                    return;\n                }\n            }\n            emitted = e;\n\n            consumed = c;\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "247", "src_id": "M142", "code": "    @Override void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Subscriber<? super R> downstream = this.downstream;\n        ErrorMode errorMode = this.errorMode;\n        SimpleQueue<T> queue = this.queue;\n        AtomicThrowable errors = this.errors;\n        AtomicLong requested = this.requested;\n        int limit = prefetch - (prefetch >> 1);\n        boolean syncFused = this.syncFused;\n\n        for (;;) {\n            for (;;) {\n                if (cancelled) {\n                    queue.clear();\n\n                    item = null;\n\n                    break;\n                }\n\n                int s = state;\n                if (errors.get() != null && (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE))) {\n                    queue.clear();\n\n                    item = null;\n\n                    errors.tryTerminateConsumer(downstream);\n\n                    return;\n                }\n\n                if (s != STATE_INACTIVE) {\n                    if (s != STATE_RESULT_VALUE) {\n                        break;\n                    } else {\n                        long e = emitted;\n                        if (e == requested.get()) {\n                            break;\n                        } else {\n                            R w = item;\n                            item = null;\n\n                            downstream.onNext(w);\n\n                            emitted = e + 1;\n\n                            state = STATE_INACTIVE;\n                        } \n                    }\n                } else {\n                    boolean d = done;\n                    T v;\n\n                    try {\n                        v = queue.poll();\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n\n                            upstream.cancel();\n\n                            errors.tryAddThrowableOrReport(ex);\n\n                            errors.tryTerminateConsumer(downstream);\n\n                            return;\n                        }\n\n                    boolean empty = v == null;\n                    if (d && empty) {\n                        errors.tryTerminateConsumer(downstream);\n\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    if (!syncFused) {\n                        int c = consumed + 1;\n                        if (c != limit) {\n                            consumed = c;\n                        } else {\n                            consumed = 0;\n\n                            upstream.request(limit);\n                        } \n                    }\n\n                    MaybeSource<? extends R> ms;\n\n                    try {\n                        ms = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\");\n                    } catch (Throwable ex) {\n                            Exceptions.throwIfFatal(ex);\n\n                            upstream.cancel();\n\n                            queue.clear();\n\n                            errors.tryAddThrowableOrReport(ex);\n\n                            errors.tryTerminateConsumer(downstream);\n\n                            return;\n                        }\n\n\n                    state = STATE_ACTIVE;\n\n                    ms.subscribe(inner);\n\n                    break;\n                } \n\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "248", "src_id": "M2196", "code": "    @SuppressWarnings(\"unchecked\") void remove(@NonNull SingleDisposable<T> inner) {\n        for (;;) {\n            SingleDisposable<T>[] a = observers.get();\n            int n = a.length;\n            if (n == 0) {\n                return;\n            }\n\n            int j = - 1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] != inner) { \n                    continue; \n                }  \n                j = i;\n\n                break;\n            }\n\n            if (j < 0) {\n                return;\n            }\n\n            SingleDisposable<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new SingleDisposable[n - 1];\n\n                System.arraycopy(a, 0, b, 0, j);\n\n                System.arraycopy(a, j + 1, b, j, n - j - 1);\n            }\n\n            if (observers.compareAndSet(a, b)) {\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "249", "src_id": "M2269", "code": "    @Override\n    protected void subscribeActual(@NonNull Subscriber<? super T> s) {\n        AsyncSubscription<T> as = new AsyncSubscription<>(s, this);\n        s.onSubscribe(as);\n        if (add(as)) {\n            if (as.isCancelled()) {\n                remove(as);\n            }\n        } else {\n            Throwable ex = error;\n            if (ex != null) {\n                s.onError(ex);\n            } else {\n                T v = value;\n                if (v != null) {\n                    as.complete(v);\n                } else {\n                    as.onComplete();\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "34", "src_id": "M361", "code": "        private static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n            try {\n                if (!isValidJakartaMailPart(part)) {\n                    log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n                    return;\n                }\n\n                Class<?> partClass = part.getClass();\n                Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n                Method getContent = partClass.getMethod(\"getContent\");\n                Method getDisposition = partClass.getMethod(\"getDisposition\");\n                Method getFileName = partClass.getMethod(\"getFileName\");\n                Method getContentType = partClass.getMethod(\"getContentType\");\n                Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n                Object disposition = getDisposition.invoke(part);\n                String filename = (String) getFileName.invoke(part);\n                String contentType = (String) getContentType.invoke(part);\n\n                if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n                    content.setTextBody((String) getContent.invoke(part));\n                } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n                    content.setHtmlBody((String) getContent.invoke(part));\n                } else if (\"attachment\".equalsIgnoreCase((String) disposition) || (filename != null && !filename.trim().isEmpty())) {\n                    content.setAttachmentCount(content.getAttachmentCount() + 1);\n\n                    // Always extract basic attachment metadata for display\n                    if (filename != null && !filename.trim().isEmpty()) {\n                        // Create attachment with metadata only\n                        EmailAttachment attachment = new EmailAttachment();\n\n                        // Apply MIME decoding to filename to handle encoded attachment names\n                        attachment.setFilename(safeMimeDecode(filename));\n                        attachment.setContentType(contentType);\n\n                        // Check if it's an embedded image\n                        String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n\n                        if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                            attachment.setEmbedded(true);\n\n                            // Store the Content-ID, removing angle brackets if present\n                            String contentId = contentIdHeaders[0];\n\n                            if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                                contentId = contentId.substring(1, contentId.length() - 1);\n                            }\n\n                            attachment.setContentId(contentId);\n                        }\n\n                        // Extract attachment data if attachments should be included OR if it's an\n                        // embedded image (needed for inline display)\n                        if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n                            try {\n                                Object attachmentContent = getContent.invoke(part);\n                                byte[] attachmentData = null;\n\n                                if (attachmentContent instanceof java.io.InputStream inputStream) {\n                                    try {\n                                        attachmentData = inputStream.readAllBytes();\n                                    } catch (IOException e) {\n                                            log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n                                        }\n\n                                } else if (attachmentContent instanceof byte[] byteArray) {\n                                    attachmentData = byteArray;\n                                } else if (attachmentContent instanceof String stringContent) {\n                                    attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n                                }\n\n\n                                if (attachmentData != null) {\n                                    // Check size limit (use default 10MB if request is null)\n                                    long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                                    long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                                    if (attachmentData.length <= maxSizeBytes) {\n                                        attachment.setData(attachmentData);\n                                        attachment.setSizeBytes(attachmentData.length);\n                                    } else {\n                                        // For embedded images, always include data regardless of size\n                                        // to ensure inline display works\n                                        if (attachment.isEmbedded()) { \n                                            attachment.setData(attachmentData);\n                                        }  \n\n                                        attachment.setSizeBytes(attachmentData.length);\n                                    }\n                                }\n                            } catch (Exception e) {\n                                    log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n                                }\n\n\n                        }\n\n                        // Add attachment to the list for display (with or without data)\n                        content.getAttachments().add(attachment);\n                    }\n                } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n                    // Handle nested multipart content\n                    try {\n                        Object multipartContent = getContent.invoke(part);\n                        Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n\n                        if (multipartClass.isInstance(multipartContent)) {\n                            processMultipartAdvanced(multipartContent, content, request);\n                        }\n                    } catch (Exception e) {\n                            log.warn(\"Error processing multipart content: {}\", e.getMessage());\n                        }\n\n\n                }\n\n            } catch (Exception e) {\n                    log.warn(\"Error processing multipart part: {}\", e.getMessage());\n                }\n\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "35", "src_id": "M362", "code": "        private static String generateEnhancedEmailHtml(EmailContent content, EmlToPdfRequest request) {\n            StringBuilder html = new StringBuilder();\n\n            html.append(\"<!DOCTYPE html>\\n\");\n            html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n            html.append(\"<title>\").append(escapeHtml(content.getSubject())).append(\"</title>\\n\");\n            html.append(\"<style>\\n\");\n            appendEnhancedStyles(html);\n            html.append(\"</style>\\n\");\n            html.append(\"</head><body>\\n\");\n            html.append(\"<div class=\\\"email-container\\\">\\n\");\n            html.append(\"<div class=\\\"email-header\\\">\\n\");\n            html.append(\"<h1>\").append(escapeHtml(content.getSubject())).append(\"</h1>\\n\");\n            html.append(\"<div class=\\\"email-meta\\\">\\n\");\n            html.append(\"<div><strong>From:</strong> \").append(escapeHtml(content.getFrom())).append(\"</div>\\n\");\n            html.append(\"<div><strong>To:</strong> \").append(escapeHtml(content.getTo())).append(\"</div>\\n\");\n\n            if (content.getDate() != null) {\n                html.append(\"<div><strong>Date:</strong> \").append(formatEmailDate(content.getDate())).append(\"</div>\\n\");\n            }\n\n            html.append(\"</div></div>\\n\");\n            html.append(\"<div class=\\\"email-body\\\">\\n\");\n\n            if (content.getHtmlBody() != null && !content.getHtmlBody().trim().isEmpty()) {\n                html.append(processEmailHtmlBody(content.getHtmlBody(), content));\n            } else if (content.getTextBody() != null && !content.getTextBody().trim().isEmpty()) {\n                html.append(\"<div class=\\\"text-body\\\">\");\n                html.append(convertTextToHtml(content.getTextBody()));\n                html.append(\"</div>\");\n            } else {\n                html.append(\"<div class=\\\"no-content\\\">\");\n                html.append(\"<p><em>No content available</em></p>\");\n                html.append(\"</div>\");\n            }\n\n\n            html.append(\"</div>\\n\");\n\n            if (content.getAttachmentCount() > 0 || !content.getAttachments().isEmpty()) {\n                html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n\n                int displayedAttachmentCount = content.getAttachmentCount() > 0 ? content.getAttachmentCount(): content.getAttachments().size();\n\n                html.append(\"<h3>Attachments (\").append(displayedAttachmentCount).append(\")</h3>\\n\");\n\n                if (!content.getAttachments().isEmpty()) {\n\n                    for (EmailAttachment attachment : content.getAttachments()) {\n                        // Create attachment info with paperclip emoji before filename\n                        String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n\n                        attachment.setEmbeddedFilename(attachment.getEmbeddedFilename() != null ? attachment.getEmbeddedFilename(): attachment.getFilename());\n                        html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\")\n                        .append(uniqueId)\n                        .append(\"\\\">\")\n                        .append(\"<span class=\\\"attachment-icon\\\">\")\n                        .append(MimeConstants.ATTACHMENT_MARKER)\n                        .append(\"</span> \")\n                        .append(\"<span class=\\\"attachment-name\\\">\")\n                        .append(escapeHtml(safeMimeDecode(attachment\n                        .getFilename())))\n                        .append(\"</span>\");\n\n                        String sizeStr = formatFileSize(attachment.getSizeBytes());\n\n                        html.append(\" <span class=\\\"attachment-details\\\">(\").append(sizeStr);\n\n                        if (attachment.getContentType() != null && !attachment.getContentType().isEmpty()) {\n                            html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                        }\n\n                        html.append(\")</span></div>\\n\");\n                    }\n                }\n\n                if (request.isIncludeAttachments()) {\n                    html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                    html.append(\"<p><em>Attachments are embedded in the file.</em></p>\\n\");\n                    html.append(\"</div>\\n\");\n                } else {\n                    html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                    html.append(\"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\");\n                    html.append(\"</div>\\n\");\n                }\n\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n            html.append(\"</body></html>\");\n            return html.toString();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "36", "src_id": "M367", "code": "        private static String decodeMimeHeader(String encodedText) {\n            if (encodedText == null || encodedText.trim().isEmpty()) {\n                return encodedText;\n            }\n\n            try {\n                StringBuilder result = new StringBuilder();\n                Matcher matcher = MimeConstants.MIME_ENCODED_PATTERN.matcher(encodedText);\n                int lastEnd = 0;\n\n                while (matcher.find()) {\n                    // Add any text before the encoded part\n                    result.append(encodedText, lastEnd, matcher.start());\n\n                    String charset = matcher.group(1);\n                    String encoding = matcher.group(2).toUpperCase();\n                    String encodedValue = matcher.group(3);\n\n                    try {\n                        String decodedValue;\n\n                        if (\"B\".equals(encoding)) {\n                            // Base64 decoding\n                            byte[] decodedBytes = Base64.getDecoder().decode(encodedValue);\n\n                            decodedValue = new String(decodedBytes, Charset.forName(charset));\n                        } else {\n                            decodedValue = \"Q\".equals(encoding)? decodeQuotedPrintable(encodedValue, charset): matcher.group(0);\n                        } \n\n                        result.append(decodedValue);\n                    } catch (Exception e) {\n                            log.warn(\"Failed to decode MIME header part: {}\", matcher.group(0), e);\n                            // If decoding fails, keep the original encoded text\n                            result.append(matcher.group(0));\n                        }\n\n                    lastEnd = matcher.end();\n                }\n\n                // Add any remaining text after the last encoded part\n                result.append(encodedText.substring(lastEnd));\n                return result.toString();\n            } catch (Exception e) {\n                    log.warn(\"Error decoding MIME header: {}\", encodedText, e);\n                    return encodedText; // Return original if decoding fails\n\n                }\n\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "37", "src_id": "M509", "code": "        @PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n        @Operation(\n        summary = \"Convert EML to PDF\",\n        description = \n        \"This endpoint converts EML (email) files to PDF format with extensive\" + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\" + \" and HTML debug output. Input: EML file, Output: PDF\" + \" or HTML file. Type: SISO\")\n        public ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n            MultipartFile inputFile = request.getFileInput();\n            String originalFilename = inputFile.getOriginalFilename();\n\n            // Validate input\n            if (inputFile.isEmpty()) {\n                log.error(\"No file provided for EML to PDF conversion.\");\n                return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n            }\n\n            if (originalFilename == null || originalFilename.trim().isEmpty()) {\n                log.error(\"Filename is null or empty.\");\n                return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n            }\n\n            // Validate file type - support EML\n            String lowerFilename = originalFilename.toLowerCase();\n\n            if (!lowerFilename.endsWith(\".eml\")) {\n                log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n                return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n            }\n\n            String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n\n\n            try {\n                byte[] fileBytes = inputFile.getBytes();\n\n                if (request.isDownloadHtml()) {\n                    try {\n                        String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n\n                        log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                        return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8), baseFilename + \".html\", MediaType.TEXT_HTML);\n                    } catch (IOException | IllegalArgumentException e) {\n                            log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body((\"HTML conversion failed: \" + e.getMessage()).getBytes(StandardCharsets.UTF_8));\n                        }\n\n\n                }\n\n                // Convert EML to PDF with enhanced options\n                try {\n                    byte[] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig\n                    .getWeasyPrintPath(), \n                    // Use configured WeasyPrint path\n                    request, fileBytes, originalFilename,\n                    false, pdfDocumentFactory, tempFileManager);\n\n                    if (pdfBytes == null || pdfBytes.length == 0) {\n                        log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"PDF conversion failed - empty output\".getBytes(StandardCharsets.UTF_8));\n                    }\n\n                    log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n                    return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n                } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n                    } catch (IllegalArgumentException e) {\n                        String errorMessage = buildErrorMessage(e, originalFilename);\n\n                        log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n                    } catch (RuntimeException e) {\n                        String errorMessage = buildErrorMessage(e, originalFilename);\n\n                        log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n                    }\n\n\n            } catch (IOException e) {\n                    log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n                }\n\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "292", "src_id": "M597", "code": "  private List<Integer> duplicate(int totalPages, String pageOrder) {\n    List<Integer> newPageOrder = new ArrayList<>();\n    int duplicateCount;\n    try {\n      // Parse the duplicate count from pageOrder\n      duplicateCount = pageOrder != null && !pageOrder.isEmpty() ? Integer.parseInt(pageOrder.trim()): 2; // Default to 2 if not specified\n\n\n    } catch (NumberFormatException e) {\n        log.error(\"Invalid duplicate count specified\", e);\n        duplicateCount = 2; // Default to 2 if invalid input\n\n      }\n\n    // Validate duplicate count\n    if (duplicateCount < 1) {\n      duplicateCount = 2; // Default to 2 if invalid input\n\n    }\n\n    // For each page in the document\n    for (int pageNum = 0; pageNum < totalPages; pageNum++) {\n      // Add the current page index duplicateCount times\n      for (int dupCount = 0; dupCount < duplicateCount; dupCount++) {\n        newPageOrder.add(pageNum);\n      }\n    }\n\n    return newPageOrder;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "293", "src_id": "M656", "code": "  private void runPipelineAgainstFiles(List<File> filesToProcess, PipelineConfig config, Path dir, Path processingDir) throws IOException {\n    try {\n      List<Resource> inputFiles = processor.generateInputFiles(filesToProcess.toArray(new File[0]));\n      if (inputFiles == null || inputFiles.isEmpty()) {\n        return;\n      }\n\n      PipelineResult result = processor.runPipelineAgainstFiles(inputFiles, config);\n\n      if (result.isHasErrors()) {\n        log.error(\"Errors occurred during processing, retaining original files\");\n        moveToErrorDirectory(filesToProcess, dir);\n\n      } else {\n        moveAndRenameFiles(result.getOutputFiles(), config, dir);\n        deleteOriginalFiles(filesToProcess, processingDir);\n\n      }\n    } catch (Exception e) {\n        log.error(\"Error during processing\", e);\n        moveFilesBack(filesToProcess, processingDir);\n\n      }\n\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "294", "src_id": "M32", "code": "  private boolean activateMachine(String licenseKey, String licenseId, String machineFingerprint, LicenseContext context) throws Exception {\n    // For floating licenses, we first need to check if we need to deregister any machines\n    if (context.isFloatingLicense) {\n      log.info(\"Processing floating license activation. Max machines allowed: {}\", context.maxMachines);\n      // Get the current machines for this license\n      JsonNode machinesResponse = fetchMachinesForLicense(licenseKey, licenseId);\n\n      if (machinesResponse != null) {\n        JsonNode machines = machinesResponse.path(\"data\");\n        int currentMachines = machines.size();\n        log.info(\"Current machine count: {}, Max allowed: {}\", currentMachines, context.maxMachines);\n        // Check if the current fingerprint is already activated\n        boolean isCurrentMachineActivated = false;\n        String currentMachineId = null;\n        for (JsonNode machine : machines) {\n          if (machineFingerprint.equals(machine.path(\"attributes\").path(\"fingerprint\").asText())) {\n            isCurrentMachineActivated = true;\n            currentMachineId = machine.path(\"id\").asText();\n            log.info(\"Current machine is already activated with ID: {}\", currentMachineId);\n            break;\n          }\n        }\n\n        // If the current machine is already activated, there's no need to do anything\n        if (isCurrentMachineActivated) {\n          log.info(\"Machine already activated. No action needed.\");\n          return true;\n        }\n\n        // If we've reached the max machines limit, we need to deregister the oldest machine\n        if (currentMachines >= context.maxMachines) {\n          log.info(\"Max machines reached. Deregistering oldest machine to make room for the new machine.\");\n          // Find the oldest machine based on creation timestamp\n          if (machines.size() > 0) {\n            // Find the machine with the oldest creation date\n            String oldestMachineId = null;\n            java.time.Instant oldestTime = null;\n\n            for (JsonNode machine : machines) {\n              String createdStr = machine.path(\"attributes\").path(\"created\").asText(null);\n\n              if (createdStr != null && !createdStr.isEmpty()) {\n                try {\n                  java.time.Instant createdTime = java.time.Instant.parse(createdStr);\n                  if (oldestTime == null || createdTime.isBefore(oldestTime)) {\n                    oldestTime = createdTime;\n                    oldestMachineId = machine.path(\"id\").asText();\n\n                  }\n                } catch (Exception e) {\n                    log.warn(\"Could not parse creation time for machine: {}\", e.getMessage());\n\n                  }\n\n              }\n            }\n\n            // If we couldn't determine the oldest by timestamp, use the first one\n            if (oldestMachineId == null) {\n              log.warn(\"Could not determine oldest machine by timestamp, using first machine in list\");\n              oldestMachineId = machines.path(0).path(\"id\").asText();\n\n            }\n\n            log.info(\"Deregistering machine with ID: {}\", oldestMachineId);\n            boolean deregistered = deregisterMachine(licenseKey, oldestMachineId);\n            if (!deregistered) {\n              log.error(\"Failed to deregister machine. Cannot proceed with activation.\");\n              return false;\n            }\n            log.info(\"Machine deregistered successfully. Proceeding with activation of new machine.\");\n\n          } else {\n            log.error(\"License has reached machine limit but no machines were found to deregister. This is unexpected.\");\n\n          // We'll still try to activate, but it might fail\n          }\n        }\n      }\n    }\n\n    // Proceed with machine activation\n    String hostname;\n    try {\n      hostname = java.net.InetAddress.getLocalHost().getHostName();\n\n    } catch (Exception e) {\n        hostname = \"Unknown\";\n      }\n\n\n    JSONObject body = new JSONObject()\n        .put(\"data\", new JSONObject().put(\"type\", \"machines\")\n        .put(\"attributes\", new JSONObject()\n        .put(\"fingerprint\", machineFingerprint)\n        .put(\"platform\", System.getProperty(\"os.name\"))\n        .put(\"name\", hostname))\n        .put(\"relationships\", new JSONObject()\n        .put(\"license\", new JSONObject()\n        .put(\"data\", new JSONObject().put(\"type\", \"licenses\")\n        .put(\"id\", licenseId)))));\n    HttpRequest request = HttpRequest.newBuilder()\n        .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/machines\"))\n        .header(\"Content-Type\", \"application/vnd.api+json\")\n        .header(\"Accept\", \"application/vnd.api+json\")\n        .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers\n        .ofString(body.toString()))\n        .build();\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.info(\"activateMachine Response body: \" + response.body());\n    if (response.statusCode() == 201) {\n      log.info(\"Machine activated successfully\");\n      return true;\n    } else {\n      log.error(\"Error activating machine. Status code: {}, error: {}\", response.statusCode(), response.body());\n      return false;\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "295", "src_id": "M625", "code": "  @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n  @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n  public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n    boolean readonly = true;\n    try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n      ObjectMapper objectMapper = new ObjectMapper();\n      ObjectNode jsonOutput = objectMapper.createObjectNode();\n      // Metadata using PDFBox\n      PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n      ObjectNode metadata = objectMapper.createObjectNode();\n      ObjectNode basicInfo = objectMapper.createObjectNode();\n      ObjectNode docInfoNode = objectMapper.createObjectNode();\n      ObjectNode compliancy = objectMapper.createObjectNode();\n      ObjectNode encryption = objectMapper.createObjectNode();\n      ObjectNode other = objectMapper.createObjectNode();\n      metadata.put(\"Title\", info.getTitle());\n      metadata.put(\"Author\", info.getAuthor());\n      metadata.put(\"Subject\", info.getSubject());\n      metadata.put(\"Keywords\", info.getKeywords());\n      metadata.put(\"Producer\", info.getProducer());\n      metadata.put(\"Creator\", info.getCreator());\n      metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n      metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n      jsonOutput.set(\"Metadata\", metadata);\n      // Total file size of the PDF\n      long fileSizeInBytes = inputFile.getSize();\n      basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n      // Number of words, paragraphs, and images in the entire document\n      String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n      String[] words = fullText.split(\"\\\\s+\");\n      int wordCount = words.length;\n      int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n      basicInfo.put(\"WordCount\", wordCount);\n      basicInfo.put(\"ParagraphCount\", paragraphCount);\n      // Number of characters in the entire document (including spaces and special characters)\n      int charCount = fullText.length();\n      basicInfo.put(\"CharacterCount\", charCount); // Initialize the flags and types\n      boolean hasCompression = false;\n      String compressionType = \"None\";\n      basicInfo.put(\"Compression\", hasCompression);\n      if (hasCompression) {\n        basicInfo.put(\"CompressionType\", compressionType);\n      }\n\n      String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n      basicInfo.put(\"Language\", language);\n      basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n      PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n      String pageMode = catalog.getPageMode().name();\n      // Document Information using PDFBox\n      docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n      docInfoNode.put(\"Trapped\", info.getTrapped());\n      docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n      ;\n\n      PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n      ObjectNode formFieldsNode = objectMapper.createObjectNode();\n      if (acroForm != null) {\n        for (PDField field : acroForm.getFieldTree()) {\n          formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n\n        }\n      }\n      jsonOutput.set(\"FormFields\", formFieldsNode);\n      // Generate structured summary data about PDF characteristics\n      ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n      if (summaryData != null && summaryData.size() > 0) {\n        jsonOutput.set(\"SummaryData\", summaryData);\n\n      }\n\n      // embeed files TODO size\n      if (catalog.getNames() != null) {\n        PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n        ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n\n        if (efTree != null) {\n          Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n\n          if (efMap != null) {\n            for (Map.Entry<String, PDComplexFileSpecification> entry :\n              efMap.entrySet()) {\n              ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n              embeddedFileNode.put(\"Name\", entry.getKey());\n              PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n              if (embeddedFile != null) {\n                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n\n\n              }\n              embeddedFilesArray.add(embeddedFileNode);\n\n            }\n          }\n        }\n\n        other.set(\"EmbeddedFiles\", embeddedFilesArray);\n\n      }\n\n      // attachments TODO size\n      ArrayNode attachmentsArray = objectMapper.createArrayNode();\n\n      for (PDPage page : pdfBoxDoc.getPages()) {\n        for (PDAnnotation annotation : page.getAnnotations()) {\n          if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n            ObjectNode attachmentNode = objectMapper.createObjectNode();\n            attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n            attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n            attachmentsArray.add(attachmentNode);\n\n          }\n        }\n      }\n\n      other.set(\"Attachments\", attachmentsArray);\n      // Javascript\n      PDDocumentNameDictionary namesDict = catalog.getNames();\n      ArrayNode javascriptArray = objectMapper.createArrayNode();\n\n      if (namesDict != null) {\n        PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n\n        if (javascriptDict != null) {\n          try {\n            Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n\n            for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n              ObjectNode jsNode = objectMapper.createObjectNode();\n              jsNode.put(\"JS Name\", entry.getKey());\n              PDActionJavaScript jsAction = entry.getValue();\n              if (jsAction != null) {\n                String jsCodeStr = jsAction.getAction();\n                if (jsCodeStr != null) {\n                  jsNode.put(\"JS Script Length\", jsCodeStr.length());\n\n                }\n              }\n              javascriptArray.add(jsNode);\n            }\n          } catch (IOException e) {\n              log.error(\"exception\", e);\n            }\n\n        }\n      }\n\n      other.set(\"JavaScript\", javascriptArray);\n      // TODO size\n      PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n      ArrayNode layersArray = objectMapper.createArrayNode();\n      if (ocProperties != null) {\n        for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n          ObjectNode layerNode = objectMapper.createObjectNode();\n          layerNode.put(\"Name\", ocg.getName());\n          layersArray.add(layerNode);\n        }\n      }\n\n      other.set(\"Layers\", layersArray); // TODO Security\n\n      PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n      ArrayNode structureTreeArray;\n      try {\n        if (structureTreeRoot != null) {\n          structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n          other.set(\"StructureTree\", structureTreeArray);\n\n        }\n      } catch (Exception e) {\n          // TODO Auto-generated catch block\n          log.error(\"exception\", e);\n        }\n\n\n      boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n      boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n      boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n      boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n      boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n      boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n\n      // an official ISO standard.\n      boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n      // development in 2021.\n\n      compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n      compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n      compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n      compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n      compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n      compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n      compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n      PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n      ArrayNode bookmarksArray = objectMapper.createArrayNode();\n      if (root != null) {\n        for (PDOutlineItem child : root.children()) {\n          addOutlinesToArray(child, bookmarksArray);\n\n        }\n      }\n      other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n      PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n      String xmpString = null;\n\n      if (pdMetadata != null) {\n        try {\n          try (COSInputStream is = pdMetadata.createInputStream()) {\n            DomXmpParser domXmpParser = new DomXmpParser();\n            XMPMetadata xmpMeta = domXmpParser.parse(is);\n            ByteArrayOutputStream os = new ByteArrayOutputStream();\n            new XmpSerializer().serialize(xmpMeta, os, true);\n            xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n\n          }\n        } catch (XmpParsingException e) {\n            // XMP parsing failed, try to read raw metadata instead\n            log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n\n            try (COSInputStream is = pdMetadata.createInputStream()) {\n              byte[] metadataBytes = is.readAllBytes();\n              xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n\n            }\n          } catch (IOException e) {\n            log.error(\"exception\", e);\n          }\n\n      }\n\n      other.put(\"XMPMetadata\", xmpString);\n      if (pdfBoxDoc.isEncrypted()) {\n        encryption.put(\"IsEncrypted\", true);\n        // Retrieve encryption details using getEncryption()\n        PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n        encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n        encryption.put(\"KeyLength\", pdfEncryption.getLength());\n\n      // Add other encryption-related properties as needed\n      } else {\n        encryption.put(\"IsEncrypted\", false);\n\n      }\n\n      ObjectNode permissionsNode = objectMapper.createObjectNode();\n      setNodePermissions(pdfBoxDoc, permissionsNode);\n      ObjectNode pageInfoParent = objectMapper.createObjectNode();\n\n      for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n        ObjectNode pageInfo = objectMapper.createObjectNode();\n        // Retrieve the page\n        PDPage page = pdfBoxDoc.getPage(pageNum);\n        // Page-level Information\n        PDRectangle mediaBox = page.getMediaBox();\n        float width = mediaBox.getWidth();\n        float height = mediaBox.getHeight();\n        ObjectNode sizeInfo = objectMapper.createObjectNode();\n        getDimensionInfo(sizeInfo, width, height);\n        sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n        pageInfo.set(\"Size\", sizeInfo);\n        pageInfo.put(\"Rotation\", page.getRotation());\n        pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n        // Boxes\n        pageInfo.put(\"MediaBox\", mediaBox.toString());\n        // Assuming the following boxes are defined for your document; if not, you may get\n        // null values.\n        PDRectangle cropBox = page.getCropBox();\n        pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n        PDRectangle bleedBox = page.getBleedBox();\n        pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n        PDRectangle trimBox = page.getTrimBox();\n        pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n        PDRectangle artBox = page.getArtBox();\n        pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n        // Content Extraction\n        PDFTextStripper textStripper = new PDFTextStripper();\n        textStripper.setStartPage(pageNum + 1);\n        textStripper.setEndPage(pageNum + 1);\n        String pageText = textStripper.getText(pdfBoxDoc);\n        pageInfo.put(\"Text Characters Count\", pageText.length()); //\n        // Annotations\n\n        List<PDAnnotation> annotations = page.getAnnotations();\n        int subtypeCount = 0;\n        int contentsCount = 0;\n        for (PDAnnotation annotation : annotations) {\n          if (annotation.getSubtype() != null) {\n            subtypeCount++; // Increase subtype count\n\n          }\n\n          if (annotation.getContents() != null) {\n            contentsCount++; // Increase contents count\n\n          }\n        }\n\n        ObjectNode annotationsObject = objectMapper.createObjectNode();\n        annotationsObject.put(\"AnnotationsCount\", annotations.size());\n        annotationsObject.put(\"SubtypeCount\", subtypeCount);\n        annotationsObject.put(\"ContentsCount\", contentsCount);\n        pageInfo.set(\"Annotations\", annotationsObject);\n        // Images (simplified)\n        // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n        // Here is a basic structure to recognize image XObjects on a page.\n        ArrayNode imagesArray = objectMapper.createArrayNode();\n        PDResources resources = page.getResources();\n\n        for (COSName name : resources.getXObjectNames()) {\n          PDXObject xObject = resources.getXObject(name);\n\n          if (xObject instanceof PDImageXObject image) {\n            ObjectNode imageNode = objectMapper.createObjectNode();\n            imageNode.put(\"Width\", image.getWidth());\n            imageNode.put(\"Height\", image.getHeight());\n            if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n              imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n\n            }\n\n            if (image.getColorSpace() != null) {\n              imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n\n            }\n            imagesArray.add(imageNode);\n          }\n        }\n\n        pageInfo.set(\"Images\", imagesArray);\n        // Links\n        ArrayNode linksArray = objectMapper.createArrayNode();\n        Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n\n        for (PDAnnotation annotation : annotations) {\n          if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n            String uri = uriAction.getURI();\n            uniqueURIs.add(uri); // Add to set to ensure uniqueness\n\n          }\n        }\n\n        // Add unique URIs to linksArray\n        for (String uri : uniqueURIs) {\n          ObjectNode linkNode = objectMapper.createObjectNode();\n          linkNode.put(\"URI\", uri);\n          linksArray.add(linkNode);\n        }\n\n        pageInfo.set(\"Links\", linksArray);\n        // Fonts\n        ArrayNode fontsArray = objectMapper.createArrayNode();\n        Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n\n        for (COSName fontName : resources.getFontNames()) {\n          PDFont font = resources.getFont(fontName);\n          ObjectNode fontNode = objectMapper.createObjectNode();\n          fontNode.put(\"IsEmbedded\", font.isEmbedded());\n          // PDFBox provides Font's BaseFont (i.e., the font name) directly\n          fontNode.put(\"Name\", font.getName());\n          fontNode.put(\"Subtype\", font.getType());\n          PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n\n          if (fontDescriptor != null) {\n            fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n            int flags = fontDescriptor.getFlags();\n            fontNode.put(\"IsItalic\", (flags & 1) != 0);\n            fontNode.put(\"IsBold\", (flags & 64) != 0);\n            fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n            fontNode.put(\"IsSerif\", (flags & 4) != 0);\n            fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n            fontNode.put(\"IsScript\", (flags & 16) != 0);\n            fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n            fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n            // Font stretch and BBox are not directly available in PDFBox's API, so\n            // these are omitted for simplicity\n            fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n\n          }\n\n          // Create a unique key for this font node based on its attributes\n          String uniqueKey = fontNode.toString();\n\n          // Increment count if this font exists, or initialize it if new\n          if (uniqueFontsMap.containsKey(uniqueKey)) {\n            ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n            int count = existingFontNode.get(\"Count\").asInt() + 1;\n            existingFontNode.put(\"Count\", count);\n\n          } else {\n            fontNode.put(\"Count\", 1);\n            uniqueFontsMap.put(uniqueKey, fontNode);\n\n          }\n        }\n\n        // Add unique font entries to fontsArray\n        for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n          fontsArray.add(uniqueFontNode);\n        }\n\n        pageInfo.set(\"Fonts\", fontsArray);\n        // Access resources dictionary\n        ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n        Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n\n        for (COSName name : colorSpaceNames) {\n          PDColorSpace colorSpace = resources.getColorSpace(name);\n\n          if (colorSpace instanceof PDICCBased iccBased) {\n            PDStream iccData = iccBased.getPDStream();\n            byte[] iccBytes = iccData.toByteArray();\n            // TODO: Further decode and analyze the ICC data if needed\n            ObjectNode iccProfileNode = objectMapper.createObjectNode();\n            iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n            colorSpacesArray.add(iccProfileNode);\n\n          }\n        }\n\n        pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n        // Other XObjects\n        Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n\n        for (COSName name : resources.getXObjectNames()) {\n          PDXObject xObject = resources.getXObject(name);\n          String xObjectType;\n          xObjectType = xObject instanceof PDImageXObject ? \"Image\": xObject instanceof PDFormXObject ? \"Form\": \"Other\"; \n          xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n\n        }\n\n        // Add the count map to pageInfo (or wherever you want to store it)\n        ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n        for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n          xObjectCountNode.put(entry.getKey(), entry.getValue());\n\n        }\n\n        pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n        ArrayNode multimediaArray = objectMapper.createArrayNode();\n        for (PDAnnotation annotation : annotations) {\n          if (\"RichMedia\".equals(annotation.getSubtype())) {\n            ObjectNode multimediaNode = objectMapper.createObjectNode();\n            // Extract details from the annotation as needed\n            multimediaArray.add(multimediaNode);\n\n          }\n        }\n\n        pageInfo.set(\"Multimedia\", multimediaArray);\n        pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n\n      }\n\n      jsonOutput.set(\"BasicInfo\", basicInfo);\n      jsonOutput.set(\"DocumentInfo\", docInfoNode);\n      jsonOutput.set(\"Compliancy\", compliancy);\n      jsonOutput.set(\"Encryption\", encryption);\n      jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n\n      jsonOutput.set(\"Other\", other);\n      jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n      // Save JSON to file\n      String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n      return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n\n    } catch (Exception e) {\n        log.error(\"exception\", e);\n      }\n\n    return null;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "296", "src_id": "M447", "code": "  private void configureCefSettings(CefAppBuilder builder) {\n    CefSettings settings = builder.getCefSettings();\n    String basePath = InstallationPathConfig.getClientWebUIPath();\n    log.info(\"basePath \" + basePath);\n    settings.cache_path = new File(basePath + \"cache\").getAbsolutePath();\n    settings.root_cache_path = new File(basePath + \"root_cache\").getAbsolutePath();\n    //        settings.browser_subprocess_path = new File(basePath +\n    // \"subprocess\").getAbsolutePath();\n    //        settings.resources_dir_path = new File(basePath + \"resources\").getAbsolutePath();\n    //        settings.locales_dir_path = new File(basePath + \"locales\").getAbsolutePath();\n    settings.log_file = new File(basePath, \"debug.log\").getAbsolutePath();\n    settings.persist_session_cookies = true;\n    settings.windowless_rendering_enabled = false;\n    settings.log_severity = CefSettings.LogSeverity.LOGSEVERITY_INFO;\n    builder.setAppHandler(new MavenCefAppHandlerAdapter() {@Override public void stateHasChanged(org.cef.CefApp.CefAppState state) {log\n            .info(\"CEF state changed: \" + state)\n            ;if (state == CefApp.CefAppState.TERMINATED) {System\n              .exit(0)\n              ;}}});\n\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "297", "src_id": "M310", "code": "  public static PDRectangle textToPageSize(String size) {\n    switch (size.toUpperCase()) {\n      case \"A0\" -> {\n          return PDRectangle.A0;\n        }\n      case \"A1\" -> {\n          return PDRectangle.A1;\n        }\n      case \"A2\" -> {\n          return PDRectangle.A2;\n        }\n      case \"A3\" -> {\n          return PDRectangle.A3;\n        }\n      case \"A4\" -> {\n          return PDRectangle.A4;\n        }\n      case \"A5\" -> {\n          return PDRectangle.A5;\n        }\n      case \"A6\" -> {\n          return PDRectangle.A6;\n        }\n      case \"LETTER\" -> {\n          return PDRectangle.LETTER;\n        }\n      case \"LEGAL\" -> {\n          return PDRectangle.LEGAL;\n        }\n      default -> throw ExceptionUtils.createInvalidPageSizeException(size);\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "298", "src_id": "M257", "code": "  private Object[] processArgsInPlace(Object[] originalArgs, boolean async) {\n    if (originalArgs == null || originalArgs.length == 0) {\n      return originalArgs;\n    }\n\n    // Process all arguments in-place\n    for (int i = 0; i < originalArgs.length; i++) {\n      Object arg = originalArgs[i];\n\n      if (arg instanceof PDFFile pdfFile) {\n        // Case 1: fileId is provided but no fileInput\n        if (pdfFile.getFileInput() == null && pdfFile.getFileId() != null) {\n          try {\n            log.debug(\"Using fileId {} to get file content\", pdfFile.getFileId());\n            MultipartFile file = fileStorage.retrieveFile(pdfFile.getFileId());\n            pdfFile.setFileInput(file);\n          } catch (Exception e) {\n              throw new RuntimeException(\"Failed to resolve file by ID: \" + pdfFile.getFileId(), e);\n\n            }\n\n        }// Case 2: For async requests, we need to make a copy of the MultipartFile\n        else if (async && pdfFile.getFileInput() != null) {\n          try {\n            log.debug(\"Making persistent copy of uploaded file for async processing\");\n            MultipartFile originalFile = pdfFile.getFileInput();\n            String fileId = fileStorage.storeFile(originalFile);\n            // Store the fileId for later reference\n            pdfFile.setFileId(fileId);\n            // Replace the original MultipartFile with our persistent copy\n            MultipartFile persistentFile = fileStorage.retrieveFile(fileId);\n            pdfFile.setFileInput(persistentFile);\n            log.debug(\"Created persistent file copy with fileId: {}\", fileId);\n\n          } catch (IOException e) {\n              throw new RuntimeException(\"Failed to create persistent copy of uploaded file\", e);\n\n            }\n\n        }\n\n      }\n    }\n\n    return originalArgs;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "299", "src_id": "M184", "code": "  private Map<String, Object> getDockerMetrics() {\n    Map<String, Object> dockerMetrics = new HashMap<>();\n    // Network-related Docker info\n    dockerMetrics.put(\"docker_network_mode\", System.getenv(\"DOCKER_NETWORK_MODE\"));\n    // Container name (if set)\n    String containerName = System.getenv(\"CONTAINER_NAME\");\n    if (containerName != null && !containerName.isEmpty()) {\n      dockerMetrics.put(\"container_name\", containerName);\n\n    }\n\n    // Docker compose information\n    String composeProject = System.getenv(\"COMPOSE_PROJECT_NAME\");\n    String composeService = System.getenv(\"COMPOSE_SERVICE_NAME\");\n    if (composeProject != null && composeService != null) {\n      dockerMetrics.put(\"compose_project\", composeProject);\n      dockerMetrics.put(\"compose_service\", composeService);\n\n    }\n\n    // Kubernetes-specific info (if running in K8s)\n    String k8sPodName = System.getenv(\"KUBERNETES_POD_NAME\");\n    if (k8sPodName != null) {\n      dockerMetrics.put(\"k8s_pod_name\", k8sPodName);\n      dockerMetrics.put(\"k8s_namespace\", System.getenv(\"KUBERNETES_NAMESPACE\"));\n      dockerMetrics.put(\"k8s_node_name\", System.getenv(\"KUBERNETES_NODE_NAME\"));\n\n    }\n\n    // New environment variables\n    dockerMetrics.put(\"version_tag\", System.getenv(\"VERSION_TAG\"));\n    dockerMetrics.put(\"additional_features_off\", System.getenv(\"ADDITIONAL_FEATURES_OFF\"));\n    dockerMetrics.put(\"fat_docker\", System.getenv(\"FAT_DOCKER\"));\n    return dockerMetrics;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "300", "src_id": "M170", "code": "  private void shutdownSchedulers() {\n    log.info(\"Shutting down job queue\");\n    shuttingDown = true;\n    // Complete any futures that are still waiting\n    jobMap.forEach((id, job) -> {if (!job.future.isDone()) {job\n            .future\n            .completeExceptionally(new RuntimeException(\"Server shutting down, job cancelled\"))\n            ;}});\n    // Shutdown schedulers and wait for termination\n    try {\n      scheduler.shutdown();\n      if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {\n        scheduler.shutdownNow();\n      }\n      jobExecutor.shutdown();\n      if (!jobExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n        jobExecutor.shutdownNow();\n      }\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        scheduler.shutdownNow();\n        jobExecutor.shutdownNow();\n      }\n\n\n    log.info(\"Job queue shutdown complete. Stats: total={}, rejected={}\", totalQueuedJobs, rejectedJobs);\n\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "301", "src_id": "M153", "code": "  private Path createTempFile(String prefix) throws IOException {\n    // Check if TempFileManager is available in the application context\n    try {\n      TempFileManager tempFileManager = ApplicationContextProvider.getBean(TempFileManager.class);\n      if (tempFileManager != null) {\n        // Use TempFileManager to create and register the temp file\n        File file = tempFileManager.createTempFile(\".tmp\");\n        log.debug(\"Created and registered temp file via TempFileManager: {}\", file);\n        return file.toPath();\n      }\n    } catch (Exception e) {\n        log.debug(\"TempFileManager not available, falling back to standard temp file creation\");\n\n      }\n\n\n    // Fallback to standard temp file creation\n    Path file = Files.createTempFile(prefix + tempCounter.incrementAndGet() + \"-\", \".tmp\");\n    log.debug(\"Created temp file: {}\", file);\n    // Try to register the file with a static registry if possible\n    try {\n      TempFileRegistry registry = ApplicationContextProvider.getBean(TempFileRegistry.class);\n      if (registry != null) {\n        registry.register(file);\n        log.debug(\"Registered fallback temp file with registry: {}\", file);\n\n      }\n    } catch (Exception e) {\n        log.debug(\"Could not register fallback temp file with registry: {}\", file);\n\n      }\n\n\n    return file;\n  }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "405", "src_id": "M2204", "code": "    @Override\n    protected void subscribeActual(MaybeObserver<? super T> observer) {\n        MaybeDisposable<T> md = new MaybeDisposable<>(observer, this);\n        observer.onSubscribe(md);\n\n        if (add(md)) {\n            if (md.isDisposed()) {\n                remove(md);\n            }\n        } else {\n\n            Throwable ex = error;\n            if (ex != null) {\n                observer.onError(ex);\n            } else {\n\n                T v = value;\n                if (v == null) {\n                    observer.onComplete();\n                } else {\n                    observer.onSuccess(v);\n                }\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "406", "src_id": "M919", "code": "    @Override\n    protected void subscribeActual(CompletableObserver observer) {\n\n        Disposable d = Disposable.empty();\n        observer.onSubscribe(d);\n\n        if (!d.isDisposed()) {\n            try {\n                run.run();\n            } catch (Throwable e) {\n                    Exceptions.throwIfFatal(e);\n                    if (!d.isDisposed()) {\n                        observer.onError(e);\n                    } else {\n                        RxJavaPlugins.onError(e);\n                    }\n                    return;\n                }\n\n            if (!d.isDisposed()) {\n                observer.onComplete();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "407", "src_id": "M352", "code": "    @Override\n    public void onNext(T value) {\n        if (upstream == DisposableHelper.DISPOSED) {\n            return;\n        }\n\n        Iterator<? extends R> it;\n\n        try {\n            it = mapper.apply(value).iterator();\n        } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                upstream.dispose();\n                onError(ex);\n                return;\n            }\n\n\n        Observer<? super R> a = downstream;\n\n        for (;;) {\n\n            boolean b;\n\n            try {\n                b = it.hasNext();\n            } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    upstream.dispose();\n                    onError(ex);\n                    return;\n                }\n\n\n            if (!b) {\n                break;\n            } else {\n\n                R v;\n\n                try {\n                    v = Objects.requireNonNull(it.next(), \"The iterator returned a null value\");\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        upstream.dispose();\n                        onError(ex);\n                        return;\n                    }\n\n\n                a.onNext(v);\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "408", "src_id": "M874", "code": "    @Override\n    public boolean tryOnNext(T t) {\n        if (!done) {\n\n            long retries = 0L;\n\n            for (;;) {\n\n                boolean b;\n\n                try {\n                    b = predicate.test(t);\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n\n                        ParallelFailureHandling h;\n\n                        try {\n                            h = Objects.requireNonNull(errorHandler\n                                    .apply(++retries, ex), \n                                    \"The errorHandler returned a null ParallelFailureHandling\");\n                        } catch (Throwable exc) {\n                                Exceptions.throwIfFatal(exc);\n                                cancel();\n                                onError(new CompositeException(ex, exc));\n                                return false;\n                            }\n\n\n                        switch (h) {\n                            case RETRY:\n                                continue;\n                            case SKIP:\n                                return false;\n                            case STOP:\n                                cancel();\n                                onComplete();\n                                return false;\n                            default:\n                                cancel();\n                                onError(ex);\n                                return false;\n                        }\n                    }\n\n\n                return b && downstream.tryOnNext(t);\n            }\n        }\n\n        return false;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "409", "src_id": "M2235", "code": "    @Override\n    @NonNull\n    public synchronized Throwable getCause() { // NOPMD\n\n        if (cause == null) {\n            String separator = System.getProperty(\"line.separator\");\n\n            if (exceptions.size() <= 1) {\n                cause = exceptions.get(0);\n            } else {\n                Map<Throwable, Boolean> seenCauses = new IdentityHashMap<>();\n                StringBuilder aggregateMessage = new StringBuilder();\n                aggregateMessage.append(\"Multiple exceptions (\")\n                        .append(exceptions.size())\n                        .append(\")\")\n                        .append(separator);\n\n                for (Throwable inner:exceptions) {\n\n                    int depth = 0;\n\n                    while (inner != null) {\n                        for (int i = 0; i < depth; i++) {\n                            aggregateMessage.append(\"  \");\n                        }\n\n                        aggregateMessage.append(\"|-- \");\n                        aggregateMessage.append(inner.getClass().getCanonicalName()).append(\": \");\n\n                        String innerMessage = inner.getMessage();\n                        if (!(innerMessage != null && innerMessage.contains(separator))) {\n                            aggregateMessage.append(innerMessage);\n                            aggregateMessage.append(separator);\n                        } else {\n                            aggregateMessage.append(separator);\n                            for (String line:innerMessage.split(separator)) {\n                                for (int i = 0; i < depth + 2; i++) {\n                                    aggregateMessage.append(\"  \");\n                                }\n\n                                aggregateMessage.append(line).append(separator);\n                            }\n                        } \n\n                        for (int i = 0; i < depth + 2; i++) {\n                            aggregateMessage.append(\"  \");\n                        }\n                        StackTraceElement[] st = inner.getStackTrace();\n                        if (st.length > 0) {\n                            aggregateMessage.append(\"at \").append(st[0]).append(separator);\n                        }\n\n                        if (!seenCauses.containsKey(inner)) {\n                            seenCauses.put(inner, true);\n                            inner = inner.getCause();\n                            depth++;\n                        } else {\n                            inner = inner.getCause();\n\n                            if (inner != null) {\n                                for (int i = 0; i < depth + 2; i++) {\n                                    aggregateMessage.append(\"  \");\n                                }\n\n                                aggregateMessage.append(\"|-- \");\n                                aggregateMessage.append(\"(cause not expanded again) \");\n                                aggregateMessage.append(inner.getClass().getCanonicalName()).append(\": \");\n                                aggregateMessage.append(inner.getMessage());\n                                aggregateMessage.append(separator);\n                            }\n\n                            break;\n                        }\n                    }\n                }\n\n                cause = new ExceptionOverview(aggregateMessage.toString().trim());\n            } \n        }\n\n        return cause;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "410", "src_id": "M1389", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Deque<T> dq = deque;\n        Subscriber<? super T> a = downstream;\n\n        for (;;) {\n\n            long r = requested.get();\n            long e = 0L;\n\n            while (e != r) {\n                if (cancelled) {\n                    clear(dq);\n                    return;\n                }\n\n                boolean d = done;\n                T v;\n                synchronized (dq) {\n                    v = dq.poll();\n                }\n\n                boolean empty = v == null;\n                if (d) {\n\n                    Throwable ex = error;\n                    if (ex != null) {\n                        clear(dq);\n                        a.onError(ex);\n                        return;\n                    }\n                    if (empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n                e++;\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    clear(dq);\n                    return;\n                }\n\n                boolean d = done;\n                boolean empty;\n                synchronized (dq) {\n                    empty = dq.isEmpty();\n                }\n                if (d) {\n\n                    Throwable ex = error;\n                    if (ex != null) {\n                        clear(dq);\n                        a.onError(ex);\n                        return;\n                    }\n                    if (empty) {\n                        a.onComplete();\n                        return;\n                    }\n                }\n            }\n\n            if (e != 0L) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "411", "src_id": "M243", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        AtomicReference<T> latest = this.latest;\n        Observer<? super T> downstream = this.downstream;\n\n        for (;;) {\n\n            for (;;) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n\n                boolean d = done;\n                Throwable error = this.error;\n                if (d && error != null) {\n                    if (onDropped == null) {\n                        latest.lazySet(null);\n                    } else {\n\n                        T v = latest.getAndSet(null);\n                        if (v != null) {\n                            try {\n                                onDropped.accept(v);\n                            } catch (Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    error = new CompositeException(error, ex);\n                                }\n\n                        }\n                    } \n\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                T v = latest.get();\n                boolean empty = v == null;\n                if (d) {\n                    if (!empty) {\n                        v = latest.getAndSet(null);\n\n                        if (emitLast) {\n                            downstream.onNext(v);\n                        } else {\n                            if (onDropped != null) {\n                                try {\n                                    onDropped.accept(v);\n                                } catch (Throwable ex) {\n                                        Exceptions.throwIfFatal(ex);\n                                        downstream.onError(ex);\n                                        worker.dispose();\n                                        return;\n                                    }\n\n                            }\n                        }\n                    }\n\n                    downstream.onComplete();\n                    worker.dispose();\n                    return;\n                }\n\n                if (empty) {\n                    if (timerFired) {\n                        timerRunning = false;\n                        timerFired = false;\n                    }\n                    break;\n                }\n\n                if (!(!timerRunning || timerFired)) {\n                    break;\n                } else {\n                    v = latest.getAndSet(null);\n                    downstream.onNext(v);\n                    timerFired = false;\n                    timerRunning = true;\n                    worker.schedule(this, timeout, unit);\n                } \n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "412", "src_id": "M1127", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        AtomicReference<T> latest = this.latest;\n        AtomicLong requested = this.requested;\n        Subscriber<? super T> downstream = this.downstream;\n\n        for (;;) {\n\n            for (;;) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n\n                boolean d = done;\n                Throwable error = this.error;\n                if (d && error != null) {\n                    if (onDropped == null) {\n                        latest.lazySet(null);\n                    } else {\n\n                        T v = latest.getAndSet(null);\n                        if (v != null) {\n                            try {\n                                onDropped.accept(v);\n                            } catch (Throwable ex) {\n                                    Exceptions.throwIfFatal(ex);\n                                    error = new CompositeException(error, ex);\n                                }\n\n                        }\n                    } \n\n                    downstream.onError(error);\n                    worker.dispose();\n                    return;\n                }\n\n                T v = latest.get();\n                boolean empty = v == null;\n                if (d) {\n                    if (empty) {\n                        downstream.onComplete();\n                    } else {\n                        v = latest.getAndSet(null);\n\n                        if (emitLast) {\n\n                            long e = emitted;\n                            if (e == requested.get()) {\n                                tryDropAndSignalMBE(v);\n                            } else {\n                                emitted = e + 1;\n                                downstream.onNext(v);\n                                downstream.onComplete();\n                            } \n                        } else {\n                            if (onDropped != null) {\n                                try {\n                                    onDropped.accept(v);\n                                } catch (Throwable ex) {\n                                        Exceptions.throwIfFatal(ex);\n                                        downstream.onError(ex);\n                                        worker.dispose();\n                                        return;\n                                    }\n\n                            }\n                            downstream.onComplete();\n                        }\n                    } \n\n                    worker.dispose();\n                    return;\n                }\n\n                if (empty) {\n                    if (timerFired) {\n                        timerRunning = false;\n                        timerFired = false;\n                    }\n                    break;\n                }\n\n                if (!(!timerRunning || timerFired)) {\n                    break;\n                } else {\n                    v = latest.getAndSet(null);\n\n                    long e = emitted;\n                    if (e != requested.get()) {\n                        downstream.onNext(v);\n                        emitted = e + 1;\n                    } else {\n                        upstream.cancel();\n                        tryDropAndSignalMBE(v);\n                        worker.dispose();\n                        return;\n                    }\n                    timerFired = false;\n                    timerRunning = true;\n                    worker.schedule(this, timeout, unit);\n                } \n            }\n\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "413", "src_id": "M1902", "code": "    @Override\n    protected void subscribeActual(Subscriber<? super R> s) {\n        if (!(source instanceof Supplier)) {\n            source.subscribe(subscribe(s, mapper, prefetch));\n        } else {\n\n            Stream<? extends R> stream = null;\n            try {\n                @SuppressWarnings(\"unchecked\") T t = ((Supplier<T>) source).get();\n                if (t != null) {\n                    stream = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null Stream\");\n                }\n            } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    EmptySubscription.error(ex, s);\n                    return;\n                }\n\n\n            if (stream != null) {\n                FlowableFromStream.subscribeStream(s, stream);\n            } else {\n                EmptySubscription.complete(s);\n            }\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "414", "src_id": "M1455", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        long e = emitted;\n        Subscriber<? super C> a = downstream;\n        SpscLinkedArrayQueue<C> q = queue;\n\n        for (;;) {\n\n            long r = requested.get();\n\n            while (e != r) {\n                if (cancelled) {\n                    q.clear();\n                    return;\n                }\n\n                boolean d = done;\n                if (d && errors.get() != null) {\n                    q.clear();\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n\n                C v = q.poll();\n                boolean empty = v == null;\n                if (d && empty) {\n                    a.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n                e++;\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    q.clear();\n                    return;\n                }\n                if (done) {\n                    if (errors.get() == null) if (q.isEmpty()) {\n                            a.onComplete();\n                            return;\n                        }\n                    else {\n                        q.clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    } \n                }\n            }\n            emitted = e;\n            missed = addAndGet(-missed);\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "146", "src_id": "M355", "code": "    private static String processInlineImages(String htmlContent, EmailContent emailContent) {\n        if (htmlContent == null || emailContent == null) {\n            return htmlContent;\n        }\n\n        // Create a map of Content-ID to attachment data\n        Map<String, EmailAttachment> contentIdMap = new HashMap<>();\n\n        for (EmailAttachment attachment:emailContent.getAttachments()) {\n            if (attachment.isEmbedded() && attachment.getContentId() != null && attachment.getData() != null) {\n                contentIdMap.put(attachment.getContentId(), attachment);\n            }\n        }\n\n        if (contentIdMap.isEmpty()) {\n            return htmlContent;\n        }\n\n        // Pattern to match cid: references in img src attributes\n        Pattern cidPattern = Pattern.compile(\"(?i)<img[^>]*\\\\ssrc\\\\s*=\\\\s*['\\\"]cid:([^'\\\"]+)['\\\"][^>]*>\",\n                Pattern.CASE_INSENSITIVE);\n        Matcher matcher = cidPattern.matcher(htmlContent);\n        StringBuffer result = new StringBuffer();\n\n        while (matcher.find()) {\n\n            String contentId = matcher.group(1);\n            EmailAttachment attachment = contentIdMap.get(contentId);\n\n            if (!(attachment != null && attachment.getData() != null)) {\n                // Keep original if attachment not found\n                matcher.appendReplacement(result, Matcher.quoteReplacement(matcher.group(0)));\n            } else {\n\n                // Convert to data URI\n                String mimeType = attachment.getContentType();\n\n                if (mimeType == null || mimeType.isEmpty()) {\n\n                    // Try to determine MIME type from filename\n                    String filename = attachment.getFilename();\n\n                    if (filename == null) {\n                        mimeType = \"image/png\"; // fallback\n\n                    } else {\n                        if (filename.toLowerCase().endsWith(\".png\")) {\n                            mimeType = \"image/png\";\n                        } else if (filename.toLowerCase().endsWith(\".jpg\") || filename.toLowerCase().endsWith(\".jpeg\")) {\n                            mimeType = \"image/jpeg\";\n                        } else if (filename.toLowerCase().endsWith(\".gif\")) {\n                            mimeType = \"image/gif\";\n                        } else if (filename.toLowerCase().endsWith(\".bmp\")) {\n                            mimeType = \"image/bmp\";\n                        } else {\n                            mimeType = \"image/png\"; // fallback\n\n                        }\n\n                    } \n                }\n\n                String base64Data = Base64.getEncoder().encodeToString(attachment.getData());\n                String dataUri = \"data:\" + mimeType + \";base64,\" + base64Data;\n                // Replace the cid: reference with the data URI\n                String replacement = matcher.group(0).replaceFirst(\"cid:\" + Pattern.quote(contentId), dataUri);\n                matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));\n            } \n        }\n\n        matcher.appendTail(result);\n        return result.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "147", "src_id": "M362", "code": "    private static String generateEnhancedEmailHtml(EmailContent content, EmlToPdfRequest request) {\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(content.getSubject())).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(content.getSubject())).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(content.getFrom())).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(content.getTo())).append(\"</div>\\n\");\n\n        if (content.getDate() != null) {\n            html.append(\"<div><strong>Date:</strong> \")\n                    .append(formatEmailDate(content.getDate()))\n                    .append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n\n        if (content.getHtmlBody() != null && !content.getHtmlBody().trim().isEmpty()) {\n            html.append(processEmailHtmlBody(content.getHtmlBody(), content));\n        } else if (content.getTextBody() != null && !content.getTextBody().trim().isEmpty()) {\n            html.append(\"<div class=\\\"text-body\\\">\");\n            html.append(convertTextToHtml(content.getTextBody()));\n            html.append(\"</div>\");\n        } else {\n            html.append(\"<div class=\\\"no-content\\\">\");\n            html.append(\"<p><em>No content available</em></p>\");\n            html.append(\"</div>\");\n        }\n\n\n        html.append(\"</div>\\n\");\n\n        if (content.getAttachmentCount() > 0 || !content.getAttachments().isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n\n            int displayedAttachmentCount = content\n                    .getAttachmentCount() \n                    > 0\n                    ? content.getAttachmentCount():content\n                    .getAttachments()\n                    .size();\n            html.append(\"<h3>Attachments (\").append(displayedAttachmentCount).append(\")</h3>\\n\");\n\n            if (!content.getAttachments().isEmpty()) {\n                for (EmailAttachment attachment:content.getAttachments()) {\n                    // Create attachment info with paperclip emoji before filename\n                    String uniqueId = generateUniqueAttachmentId(attachment.getFilename());\n                    attachment.setEmbeddedFilename(attachment\n                            .getEmbeddedFilename() \n                             != null\n                            ? attachment.getEmbeddedFilename():attachment\n                            .getFilename());\n                    html.append(\"<div class=\\\"attachment-item\\\" id=\\\"\")\n                            .append(uniqueId)\n                            .append(\"\\\">\")\n                            .append(\"<span class=\\\"attachment-icon\\\">\")\n                            .append(MimeConstants.ATTACHMENT_MARKER)\n                            .append(\"</span> \")\n                            .append(\"<span class=\\\"attachment-name\\\">\")\n                            .append(escapeHtml(safeMimeDecode(attachment\n                            .getFilename())))\n                            .append(\"</span>\");\n                    String sizeStr = formatFileSize(attachment.getSizeBytes());\n                    html.append(\" <span class=\\\"attachment-details\\\">(\").append(sizeStr);\n\n                    if (attachment.getContentType() != null && !attachment.getContentType().isEmpty()) {\n                        html.append(\", \").append(escapeHtml(attachment.getContentType()));\n                    }\n                    html.append(\")</span></div>\\n\");\n                }\n            }\n\n            if (request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachments are embedded in the file.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "148", "src_id": "M356", "code": "    private static void appendEnhancedStyles(StringBuilder html) {\n\n        int fontSize = StyleConstants.DEFAULT_FONT_SIZE;\n        String textColor = StyleConstants.DEFAULT_TEXT_COLOR;\n        String backgroundColor = StyleConstants.DEFAULT_BACKGROUND_COLOR;\n        String borderColor = StyleConstants.DEFAULT_BORDER_COLOR;\n        html.append(\"body {\\n\");\n        html.append(\"  font-family: \").append(StyleConstants.DEFAULT_FONT_FAMILY).append(\";\\n\");\n        html.append(\"  font-size: \").append(fontSize).append(\"px;\\n\");\n        html.append(\"  line-height: \").append(StyleConstants.DEFAULT_LINE_HEIGHT).append(\";\\n\");\n        html.append(\"  color: \").append(textColor).append(\";\\n\");\n        html.append(\"  margin: 0;\\n\");\n        html.append(\"  padding: 16px;\\n\");\n        html.append(\"  background-color: \").append(backgroundColor).append(\";\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-container {\\n\");\n        html.append(\"  width: 100%;\\n\");\n        html.append(\"  max-width: 100%;\\n\");\n        html.append(\"  margin: 0 auto;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header {\\n\");\n        html.append(\"  padding-bottom: 10px;\\n\");\n        html.append(\"  border-bottom: 1px solid \").append(borderColor).append(\";\\n\");\n        html.append(\"  margin-bottom: 10px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-header h1 {\\n\");\n        html.append(\"  margin: 0 0 10px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 4).append(\"px;\\n\");\n        html.append(\"  font-weight: bold;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-meta div {\\n\");\n        html.append(\"  margin-bottom: 2px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".email-body {\\n\");\n        html.append(\"  word-wrap: break-word;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section {\\n\");\n        html.append(\"  margin-top: 15px;\\n\");\n        html.append(\"  padding: 10px;\\n\");\n        html.append(\"  background-color: \").append(StyleConstants.ATTACHMENT_BACKGROUND_COLOR).append(\";\\n\");\n        html.append(\"  border: 1px solid \").append(StyleConstants.ATTACHMENT_BORDER_COLOR).append(\";\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-section h3 {\\n\");\n        html.append(\"  margin: 0 0 8px 0;\\n\");\n        html.append(\"  font-size: \").append(fontSize + 1).append(\"px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-item {\\n\");\n        html.append(\"  padding: 5px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-icon {\\n\");\n        html.append(\"  margin-right: 5px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-details, .attachment-type {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  color: #555555;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note, .attachment-info-note {\\n\");\n        html.append(\"  margin-top: 8px;\\n\");\n        html.append(\"  padding: 6px;\\n\");\n        html.append(\"  font-size: \").append(fontSize - 2).append(\"px;\\n\");\n        html.append(\"  border-radius: 3px;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-inclusion-note {\\n\");\n        html.append(\"  background-color: #e6ffed;\\n\");\n        html.append(\"  border: 1px solid #d4f7dc;\\n\");\n        html.append(\"  color: #006420;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-info-note {\\n\");\n        html.append(\"  background-color: #fff9e6;\\n\");\n        html.append(\"  border: 1px solid #fff0c2;\\n\");\n        html.append(\"  color: #664d00;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container {\\n\");\n        html.append(\"  display: flex;\\n\");\n        html.append(\"  align-items: center;\\n\");\n        html.append(\"  padding: 8px;\\n\");\n        html.append(\"  background-color: #f8f9fa;\\n\");\n        html.append(\"  border: 1px solid #dee2e6;\\n\");\n        html.append(\"  border-radius: 4px;\\n\");\n        html.append(\"  margin: 4px 0;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-link-container:hover {\\n\");\n        html.append(\"  background-color: #e9ecef;\\n\");\n        html.append(\"}\\n\\n\");\n        html.append(\".attachment-note {\\n\");\n        html.append(\"  font-size: \").append(fontSize - 3).append(\"px;\\n\");\n        html.append(\"  color: #6c757d;\\n\");\n        html.append(\"  font-style: italic;\\n\");\n        html.append(\"  margin-left: 8px;\\n\");\n        html.append(\"}\\n\\n\");\n        // Basic image styling: ensure images are responsive but not overly constrained.\n        html.append(\"img {\\n\");\n        html.append(\"  max-width: 100%;\\n\"); // Make images responsive to container width\n\n        html.append(\"  height: auto;\\n\"); // Maintain aspect ratio\n\n        html.append(\"  display: block;\\n\"); // Avoid extra space below images\n\n        html.append(\"}\\n\\n\");\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "149", "src_id": "M359", "code": "    private static EmailContent extractEmailContentAdvanced(Object message, EmlToPdfRequest request) {\n\n        EmailContent content = new EmailContent();\n\n        try {\n\n            Class<?> messageClass = message.getClass();\n            // Extract headers via reflection\n            Method getSubject = messageClass.getMethod(\"getSubject\");\n            String subject = (String) getSubject.invoke(message);\n            content.setSubject(subject != null ? safeMimeDecode(subject):\"No Subject\");\n\n            Method getFrom = messageClass.getMethod(\"getFrom\");\n            Object[] fromAddresses = (Object[]) getFrom.invoke(message);\n            content.setFrom(fromAddresses != null && fromAddresses\n                    .length \n                    > 0\n                    ? safeMimeDecode(fromAddresses[0].toString())\n                    :\"\");\n\n            Method getAllRecipients = messageClass.getMethod(\"getAllRecipients\");\n            Object[] recipients = (Object[]) getAllRecipients.invoke(message);\n            content.setTo(recipients != null && recipients.length > 0 ? safeMimeDecode(recipients[0].toString()):\"\");\n\n            Method getSentDate = messageClass.getMethod(\"getSentDate\");\n            content.setDate((Date) getSentDate.invoke(message));\n\n            // Extract content\n            Method getContent = messageClass.getMethod(\"getContent\");\n            Object messageContent = getContent.invoke(message);\n\n            if (messageContent instanceof String stringContent) {\n                Method getContentType = messageClass.getMethod(\"getContentType\");\n                String contentType = (String) getContentType.invoke(message);\n                if (contentType != null && contentType.toLowerCase().contains(\"text/html\")) {\n                    content.setHtmlBody(stringContent);\n                } else {\n                    content.setTextBody(stringContent);\n                }\n            } else {\n                // Handle multipart content\n                try {\n                    Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                    if (multipartClass.isInstance(messageContent)) {\n                        processMultipartAdvanced(messageContent, content, request);\n                    }\n                } catch (Exception e) {\n                        log.warn(\"Error processing content: {}\", e.getMessage());\n                    }\n\n            }\n        } catch (Exception e) {\n                content.setSubject(\"Email Conversion\");\n                content.setFrom(\"Unknown\");\n                content.setTo(\"Unknown\");\n                content.setTextBody(\"Email content could not be parsed with advanced processing\");\n            }\n\n\n        return content;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "190", "src_id": "M345", "code": "        @Override // seekbar listener\n\n        public void onStopTrackingTouch(final SeekBar seekBar) {\n            if (DEBUG) {\n                Log.d(TAG, \"onStopTrackingTouch() called with: seekBar = [\" + seekBar + \"]\");\n            }\n\n            player.seekTo(seekBar.getProgress());\n\n            if (player.getExoPlayer().getDuration() == seekBar.getProgress()) {\n                player.getExoPlayer().play();\n            }\n\n            binding.playbackCurrentTime.setText(getTimeString(seekBar.getProgress()));\n            animate(binding.currentDisplaySeek, false, 200, AnimationType.SCALE_AND_ALPHA);\n            animate(binding.currentSeekbarPreviewThumbnail, false, 200, AnimationType.SCALE_AND_ALPHA);\n\n            if (player.getCurrentState() == STATE_PAUSED_SEEK) {\n                player.changeState(STATE_BUFFERING);\n            }\n\n            if (!player.isProgressLoopRunning()) {\n                player.startProgressLoop();\n            }\n\n            showControlsThenHide();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "191", "src_id": "M374", "code": "        @Override\n        public boolean onMenuItemClick(@NonNull final MenuItem menuItem) {\n            if (DEBUG) {\n                Log.d(TAG, \"onMenuItemClick() called with: \" + \"menuItem = [\" + menuItem + \"], \" + \"menuItem.getItemId = [\" + menuItem.getItemId() + \"]\");\n            }\n\n            if (menuItem.getGroupId() == POPUP_MENU_ID_QUALITY) {\n                onQualityItemClick(menuItem);\n                return true;\n            } else if (menuItem.getGroupId() == POPUP_MENU_ID_AUDIO_TRACK) {\n                onAudioTrackItemClick(menuItem);\n                return true;\n            } else if (menuItem.getGroupId() == POPUP_MENU_ID_PLAYBACK_SPEED) {\n                final int speedIndex = menuItem.getItemId();\n                final float speed = PLAYBACK_SPEEDS[speedIndex];\n\n                player.setPlaybackSpeed(speed);\n                binding.playbackSpeed.setText(formatSpeed(speed));\n            }\n\n\n            return false;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "192", "src_id": "M684", "code": "        private void monitorSubscription(final ChannelInfo info) {\n            final Consumer<Throwable> onError = (final Throwable throwable) -> {animate(binding\n                .channelSubscribeButton, \n                false, 100)\n                ; showSnackBarError(new ErrorInfo(throwable, \n                UserAction.SUBSCRIPTION_GET, \"Get subscription status\", \n                currentInfo))\n                ;};\n            final Observable<List<SubscriptionEntity>> observable = subscriptionManager\n            .subscriptionTable()\n            .getSubscriptionFlowable(info.getServiceId(), \n            info.getUrl())\n            .toObservable();\n\n            disposables.add(observable.observeOn(AndroidSchedulers.mainThread()).subscribe(getSubscribeUpdateMonitor(info), onError));\n            disposables.add(observable.map(List\n            ::isEmpty)\n            .distinctUntilChanged()\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(isEmpty -> updateSubscribeButton(!isEmpty), \n            onError));\n            disposables.add(observable.map(List\n            ::isEmpty)\n            .distinctUntilChanged()\n            .skip(1) \n            // channel has just been opened\n            .filter(x -> NotificationHelper\n            .areNewStreamsNotificationsEnabled(requireContext()))\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(isEmpty -> {if (!isEmpty\n                    ) {showNotifySnackbar();}}, \n            onError));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "193", "src_id": "M754", "code": "        private void runOnVisible(final Consumer<AppCompatActivity> runnable) {\n            getActivityContext().ifPresentOrElse(context -> {if (getLifecycle()\n                    .getCurrentState()\n                    .isAtLeast(Lifecycle.State.STARTED)\n                    ) {context.runOnUiThread(() -> {runnable\n                        .accept(context)\n                        ; inFlight(false);})\n                    ;} else {getLifecycle().addObserver(new DefaultLifecycleObserver() {@Override public void onResume(@NonNull final LifecycleOwner owner) {getLifecycle()\n                            .removeObserver(this)\n                            ; getActivityContext().ifPresentOrElse(context -> context\n                            .runOnUiThread(() -> {runnable.accept(context); inFlight(false);}),\n                            () -> inFlight(false))\n                            ;}})\n                    ;// this trick doesn't seem to work on Android 10+ (API 29)\n                    // which places restrictions on starting activities from the background\n                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q && !context.isChangingConfigurations()) {// try to bring the activity back to front if minimised\n                        final Intent i = new Intent(context, RouterActivity.class); i.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT); startActivity(i);}}}, \n            () -> // this branch is executed if there is no activity context\n            inFlight(false));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "194", "src_id": "M950", "code": "        public static void showMetaInfoInTextView(@Nullable final List<MetaInfo> metaInfos,\n        final TextView metaInfoTextView, final View metaInfoSeparator,\n        final CompositeDisposable disposables) {\n            final Context context = metaInfoTextView.getContext();\n\n            if (metaInfos == null || metaInfos\n                .isEmpty()\n                 || !PreferenceManager.getDefaultSharedPreferences(context)\n                .getBoolean(context.getString(R\n                .string\n                .show_meta_info_key), \n                true)) {\n                metaInfoTextView.setVisibility(View.GONE);\n                metaInfoSeparator.setVisibility(View.GONE);\n            } else {\n                final StringBuilder stringBuilder = new StringBuilder();\n\n                for (final MetaInfo metaInfo : metaInfos) {\n                    if (!isNullOrEmpty(metaInfo.getTitle())) {\n                        stringBuilder.append(\"<b>\").append(metaInfo.getTitle()).append(\"</b>\").append(Localization.DOT_SEPARATOR);\n                    }\n\n                    String content = metaInfo.getContent().getContent().trim();\n\n                    if (content.endsWith(\".\")) {\n                        content = content.substring(0, content.length() - 1); // remove . at end\n\n                    }\n\n                    stringBuilder.append(content);\n\n                    for (int i = 0; i < metaInfo.getUrls().size(); i++) {\n                        if (i == 0) {\n                            stringBuilder.append(Localization.DOT_SEPARATOR);\n                        } else {\n                            stringBuilder.append(\"<br/><br/>\");\n                        }\n\n                        stringBuilder.append(\"<a href=\\\"\")\n                        .append(metaInfo.getUrls().get(i))\n                        .append(\"\\\">\")\n                        .append(capitalizeIfAllUppercase(metaInfo\n                        .getUrlTexts()\n                        .get(i)\n                        .trim()))\n                        .append(\"</a>\");\n                    }\n                }\n\n                metaInfoSeparator.setVisibility(View.VISIBLE);\n                TextLinkifier.fromHtml(metaInfoTextView, \n                stringBuilder.toString(), HtmlCompat\n                .FROM_HTML_SEPARATOR_LINE_BREAK_HEADING, \n                null, null, disposables, SET_LINK_MOVEMENT_METHOD);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "195", "src_id": "M257", "code": "        @Override // own playback listener\n\n        public void onPlaybackSynchronize(@NonNull final PlayQueueItem item, final boolean wasBlocked) {\n            if (DEBUG) {\n                Log.d(TAG, \"Playback - onPlaybackSynchronize(was blocked: \" + wasBlocked + \") called with item=[\" + item.getTitle() + \"], url=[\" + item.getUrl() + \"]\");\n            }\n\n            if (exoPlayerIsNull() || playQueue == null || currentItem == item) {\n                return; // nothing to synchronize\n\n            }\n\n            final int playQueueIndex = playQueue.indexOf(item);\n            final int playlistIndex = simpleExoPlayer.getCurrentMediaItemIndex();\n            final int playlistSize = simpleExoPlayer.getCurrentTimeline().getWindowCount();\n            final boolean removeThumbnailBeforeSync = currentItem == null || currentItem.getServiceId() != item.getServiceId() || !currentItem.getUrl().equals(item.getUrl());\n\n            currentItem = item;\n\n            if (playQueueIndex != playQueue.getIndex()) {\n                // wrong window (this should be impossible, as this method is called with\n                // `item=playQueue.getItem()`, so the index of that item must be equal to `getIndex()`)\n                Log.e(TAG, \"Playback - Play Queue may be not in sync: item index=[\" + playQueueIndex + \"], \" + \"queue index=[\" + playQueue.getIndex() + \"]\");\n            } else if ((playlistSize > 0 && playQueueIndex >= playlistSize) || playQueueIndex < 0) {\n                // the queue and the player's timeline are not in sync, since the play queue index\n                // points outside of the timeline\n                Log.e(TAG, \"Playback - Trying to seek to invalid index=[\" + playQueueIndex + \"] with playlist length=[\" + playlistSize + \"]\");\n            } else if (wasBlocked || playlistIndex != playQueueIndex || !isPlaying()) {\n                // either the player needs to be unblocked, or the play queue index has just been\n                // changed and needs to be synchronized, or the player is not playing\n                if (DEBUG) {\n                    Log.d(TAG, \"Playback - Rewinding to correct index=[\" + playQueueIndex + \"], \" + \"from=[\" + playlistIndex + \"], size=[\" + playlistSize + \"].\");\n                }\n\n                if (removeThumbnailBeforeSync) {\n                    // unset the current (now outdated) thumbnail to ensure it is not used during sync\n                    onThumbnailLoaded(null);\n                }\n\n                // sync the player index with the queue index, and seek to the correct position\n                if (item.getRecoveryPosition() != PlayQueueItem.RECOVERY_UNSET) {\n                    simpleExoPlayer.seekTo(playQueueIndex, item.getRecoveryPosition());\n                    playQueue.unsetRecovery(playQueueIndex);\n                } else {\n                    simpleExoPlayer.seekToDefaultPosition(playQueueIndex);\n                }\n            }\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "196", "src_id": "M887", "code": "        @Nullable\n        static String choosePreferredImage(@NonNull final List<Image> images, final PreferredImageQuality nonNoneQuality) {\n            // this will be used to estimate the pixel count for images where only one of height or\n            // width are known\n            final double widthOverHeight = images\n            .stream()\n            .filter(image -> image.getHeight() \n             != HEIGHT_UNKNOWN\n             && image.getWidth() != WIDTH_UNKNOWN)\n            .mapToDouble(image -> ((double) image\n            .getWidth()\n            ) \n             / image.getHeight())\n            .findFirst()\n            .orElse(1.0);\n            final Image.ResolutionLevel preferredLevel = nonNoneQuality.toResolutionLevel();\n            final Comparator<Image> initialComparator = Comparator\n            // the first step splits the images into groups of resolution levels\n            .<Image> comparingInt(i -> {if (i\n                    .getEstimatedResolutionLevel() \n                     == Image.ResolutionLevel.UNKNOWN\n                    ) {return 3; // avoid unknowns as much as possible\n                                    } else if (i.getEstimatedResolutionLevel() \n                     == preferredLevel\n                    ) {return 0; // prefer a matching resolution level\n                                    } else if (i.getEstimatedResolutionLevel() \n                     == Image.ResolutionLevel.MEDIUM\n                    ) {return 1; // the preferredLevel is only 1 \"step\" away (either HIGH or LOW)\n                                    } else {return 2; // the preferredLevel is the furthest away possible (2 \"steps\")\n                                    }})\n            // then each level's group is further split into two subgroups, one with known image\n            // size (which is also the preferred subgroup) and the other without\n            .thenComparing(image -> image.getHeight() \n             == HEIGHT_UNKNOWN \n             && image.getWidth() == WIDTH_UNKNOWN);\n            // The third step chooses, within each subgroup with known image size, the best image based\n            // on how close its size is to BEST_LOW_H or BEST_MEDIUM_H (with proper units). Subgroups\n            // without known image size will be left untouched since estimatePixelCount always returns\n            // the same number for those.\n            final Comparator<Image> finalComparator = switch (nonNoneQuality\n            ) {case NONE -> initialComparator\n                    ; // unreachable\n                case LOW -> initialComparator.thenComparingDouble(image -> {final double pixelCount = estimatePixelCount(image, \n                        widthOverHeight);return Math.abs(pixelCount \n                        -BEST_LOW_H * BEST_LOW_H * widthOverHeight)\n                        ;})\n                    ;case MEDIUM -> initialComparator\n                    .thenComparingDouble(image -> {final double pixelCount = estimatePixelCount(image, \n                        widthOverHeight);return Math.abs(pixelCount \n                        -BEST_MEDIUM_H * BEST_MEDIUM_H * widthOverHeight)\n                        ;})\n                    ;case HIGH -> initialComparator.thenComparingDouble(// this is reversed with a - so that the highest resolution is chosen\n                    i -> -estimatePixelCount(i, widthOverHeight));};\n\n            return images.stream()// using \"min\" basically means \"take the first group, then take the first subgroup,\n            // then choose the best image, while ignoring all other groups and subgroups\"\n            .min(finalComparator).map(Image::getUrl).orElse(null);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "197", "src_id": "M667", "code": "        private void updateTabLayoutPosition() {\n            final ScrollableTabLayout tabLayout = binding.mainTabLayout;\n            final ViewPager viewPager = binding.pager;\n            final boolean bottom = mainTabsPositionBottom;\n            // change layout params to make the tab layout appear either at the top or at the bottom\n            final var tabParams = (RelativeLayout.LayoutParams) tabLayout.getLayoutParams();\n            final var pagerParams = (RelativeLayout.LayoutParams) viewPager.getLayoutParams();\n\n            tabParams.removeRule(bottom ? ALIGN_PARENT_TOP : ALIGN_PARENT_BOTTOM);\n            tabParams.addRule(bottom ? ALIGN_PARENT_BOTTOM : ALIGN_PARENT_TOP);\n            pagerParams.removeRule(bottom ? BELOW : ABOVE);\n            pagerParams.addRule(bottom ? ABOVE : BELOW, R.id.main_tab_layout);\n            tabLayout.setSelectedTabIndicatorGravity(bottom ? INDICATOR_GRAVITY_TOP : INDICATOR_GRAVITY_BOTTOM);\n            tabLayout.setLayoutParams(tabParams);\n            viewPager.setLayoutParams(pagerParams);\n            // change the background and icon color of the tab layout:\n            // service-colored at the top, app-background-colored at the bottom\n            tabLayout.setBackgroundColor(ThemeHelper.resolveColorFromAttr(requireContext(), bottom ? android.R.attr.windowBackground : R.attr.colorPrimary));\n\n            @ColorInt final int iconColor = bottom? ThemeHelper.resolveColorFromAttr(requireContext(), android.R.attr.colorAccent): Color.WHITE;\n\n            tabLayout.setTabRippleColor(ColorStateList.valueOf(iconColor).withAlpha(32));\n            tabLayout.setTabIconTint(ColorStateList.valueOf(iconColor));\n            tabLayout.setSelectedTabIndicatorColor(iconColor);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "198", "src_id": "M395", "code": "        @Override\n        protected void setupElementsVisibility() {\n            binding.fullScreenButton.setVisibility(View.VISIBLE);\n            binding.screenRotationButton.setVisibility(View.GONE);\n            binding.resizeTextView.setVisibility(View.GONE);\n            binding.getRoot().findViewById(R.id.metadataView).setVisibility(View.GONE);\n            binding.queueButton.setVisibility(View.GONE);\n            binding.segmentsButton.setVisibility(View.GONE);\n            binding.moreOptionsButton.setVisibility(View.GONE);\n            binding.topControls.setOrientation(LinearLayout.HORIZONTAL);\n            binding.primaryControls.getLayoutParams().width = WRAP_CONTENT;\n            binding.secondaryControls.setAlpha(1.0f);\n            binding.secondaryControls.setVisibility(View.VISIBLE);\n            binding.secondaryControls.setTranslationY(0);\n            binding.share.setVisibility(View.GONE);\n            binding.playWithKodi.setVisibility(View.GONE);\n            binding.openInBrowser.setVisibility(View.GONE);\n            binding.switchMute.setVisibility(View.GONE);\n            binding.playerCloseButton.setVisibility(View.GONE);\n            binding.topControls.bringToFront();\n            binding.topControls.setClickable(false);\n            binding.topControls.setFocusable(false);\n            binding.bottomControls.bringToFront();\n            super.setupElementsVisibility();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "199", "src_id": "M338", "code": "        private void updateEndScreenThumbnail(@Nullable final Bitmap thumbnail) {\n            if (thumbnail == null) {\n                // remove end screen thumbnail\n                binding.endScreen.setImageDrawable(null);\n                return;\n            }\n\n            final float endScreenHeight = calculateMaxEndScreenThumbnailHeight(thumbnail);\n            final Bitmap endScreenBitmap = BitmapCompat\n            .createScaledBitmap(thumbnail,(int) (thumbnail\n            .getWidth() \n             / (thumbnail.getHeight() / endScreenHeight\n            )\n            ),\n            (int) endScreenHeight, null, true);\n\n            if (DEBUG) {\n                Log.d(TAG, \"Thumbnail - onThumbnailLoaded() called with: \"\n                 + \"currentThumbnail = [\" \n                 + thumbnail \n                 + \"], \"\n                 + thumbnail.getWidth() \n                 + \"x\" \n                 + thumbnail.getHeight()\n                 + \", scaled end screen height = \" \n                 + endScreenHeight\n                 + \", scaled end screen width = \" \n                 + endScreenBitmap.getWidth());\n            }\n\n            binding.endScreen.setImageBitmap(endScreenBitmap);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "357", "src_id": "M16", "code": "    private void handleCookiesFromUrl(@Nullable final String url) {\n        if (MainActivity.DEBUG) {\n            Log.d(TAG, \"handleCookiesFromUrl: url=\" + (url == null ? \"null\" : url));\n        }\n\n        if (url == null) {\n            return;\n        }\n\n        final String cookies = CookieManager.getInstance().getCookie(url);\n        handleCookies(cookies);\n\n        // sometimes cookies are inside the url\n        final int abuseStart = url.indexOf(\"google_abuse=\");\n\n        if (abuseStart != - 1) {\n            final int abuseEnd = url.indexOf(\"+path\");\n\n            try {\n                handleCookies(Utils.decodeUrlUtf8(url.substring(abuseStart + 13, abuseEnd)));\n            } catch (final StringIndexOutOfBoundsException e) {\n                    if (MainActivity.DEBUG) {\n                        Log.e(TAG, \"handleCookiesFromUrl: invalid google abuse starting at \" + abuseStart + \" and ending at \" + abuseEnd + \" for url \" + url, e);\n                    }\n                }\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "358", "src_id": "M339", "code": "    @Override\n    public void onUpdateProgress(final int currentProgress, final int duration, final int bufferPercent) {\n        if (duration != binding.playbackSeekBar.getMax()) {\n            setVideoDurationToControls(duration);\n        }\n\n        if (player.getCurrentState() != STATE_PAUSED) {\n            updatePlayBackElementsCurrentDuration(currentProgress);\n        }\n\n        if (player.isLoading() || bufferPercent > 90) {\n            binding.playbackSeekBar.setSecondaryProgress((int) (binding.playbackSeekBar.getMax() * ((float) bufferPercent / 100)));\n        }\n\n        if (DEBUG && bufferPercent % 20 == 0) { //Limit log\n\n            Log.d(TAG, \"notifyProgressUpdateToListeners() called with: \"\n                     + \"isVisible = \" \n                     + isControlsVisible() \n                     + \", \"\n                     + \"currentProgress = [\" \n                     + currentProgress \n                     + \"], \"\n                     + \"duration = [\" \n                     + duration \n                     + \"], bufferPercent = [\" \n                     + bufferPercent \n                     + \"]\");\n        }\n        binding.playbackLiveSync.setClickable(!player.isLiveEdge());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "359", "src_id": "M452", "code": "    private void updateQueueTime(final int currentTime) {\n        @Nullable final PlayQueue playQueue = player.getPlayQueue();\n        if (playQueue == null) {\n            return;\n        }\n\n        final int currentStream = playQueue.getIndex();\n        int before = 0;\n        int after = 0;\n        final List<PlayQueueItem> streams = playQueue.getStreams();\n        final int nStreams = streams.size();\n        for (int i = 0; i < nStreams; i++) {\n            if (i < currentStream) {\n                before += streams.get(i).getDuration();\n            } else {\n                after += streams.get(i).getDuration();\n            }\n        }\n        before *= 1000;\n\n        after *= 1000;\n        binding.itemsListHeaderDuration.setText(String.format(\"%s/%s\", getTimeString(currentTime + before), getTimeString(before + after)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "360", "src_id": "M900", "code": "    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        final String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n            return R.style.BlackSettingsTheme;\n        } else if (!(selectedTheme.equals(automaticDeviceTheme))) {\n            // default to dark theme\n            return R.style.DarkSettingsTheme;\n        } else {\n            if (!isDeviceDarkThemeEnabled(context)) {\n                // there is only one day theme\n                return R.style.LightSettingsTheme;\n            } else {\n                // use the dark theme variant preferred by the user\n                final String selectedNightTheme = getSelectedNightThemeKey(context);\n                if (selectedNightTheme.equals(blackTheme)) {\n                    return R.style.BlackSettingsTheme;\n                } else {\n                    return R.style.DarkSettingsTheme;\n                }\n            } \n        } \n\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "361", "src_id": "M383", "code": "    public boolean onKeyDown(final int keyCode) {\n        switch (keyCode) {\n            case KeyEvent.KEYCODE_BACK : \n                if (DeviceUtils.isTv(context) && isControlsVisible()) {\n                    hideControls(0, 0);\n\n                    return true;\n                }\n                break;\n            case KeyEvent.KEYCODE_DPAD_UP : \n            case KeyEvent.KEYCODE_DPAD_LEFT : \n            case KeyEvent.KEYCODE_DPAD_DOWN : \n            case KeyEvent.KEYCODE_DPAD_RIGHT : \n            case KeyEvent.KEYCODE_DPAD_CENTER : \n                if ((binding.getRoot().hasFocus() && !binding.playbackControlRoot.hasFocus()) || isAnyListViewOpen()) {\n                    // do not interfere with focus in playlist and play queue etc.\n                    break;\n                }\n\n                if (player.getCurrentState() == org.schabi.newpipe.player.Player.STATE_BLOCKED) {\n                    return true;\n                }\n\n                if (isControlsVisible()) {\n                    hideControls(DEFAULT_CONTROLS_DURATION, DPAD_CONTROLS_HIDE_TIME);\n                } else {\n                    binding.playPauseButton.requestFocus();\n\n                    showControlsThenHide();\n\n                    showSystemUIPartially();\n\n                    return true;\n                }\n                break;\n            default : \n                break; // ignore other keys\n        }\n\n        return false;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "362", "src_id": "M553", "code": "    public static String getActionName(@NonNull final Context context, @Action final int action) {\n        switch (action) {\n            case PREVIOUS : \n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_previous_description);\n            case NEXT : \n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_next_description);\n            case REWIND : \n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_rewind_description);\n            case FORWARD : \n                return context.getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fastforward_description);\n            case SMART_REWIND_PREVIOUS : \n                return Localization.concatenateStrings(context\n                        .getString(com.google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_rewind_description),\n                        context.getString(com\n                        .google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_previous_description));\n            case SMART_FORWARD_NEXT : \n                return Localization.concatenateStrings(context\n                        .getString(com.google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_fastforward_description),\n                        context.getString(com\n                        .google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_next_description));\n            case PLAY_PAUSE : \n                return Localization.concatenateStrings(context\n                        .getString(com.google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_play_description),\n                        context.getString(com\n                        .google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_pause_description));\n            case PLAY_PAUSE_BUFFERING : \n                return Localization.concatenateStrings(context\n                        .getString(com.google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_play_description),\n                        context.getString(com\n                        .google\n                        .android\n                        .exoplayer2\n                        .ui\n                        .R\n                        .string\n                        .exo_controls_pause_description),\n                        context.getString(R.string\n                        .notification_action_buffering));\n            case REPEAT : \n                return context.getString(R.string.notification_action_repeat);\n            case SHUFFLE : \n                return context.getString(R.string.notification_action_shuffle);\n            case CLOSE : \n                return context.getString(R.string.close);\n            case NOTHING : default : \n                return context.getString(R.string.notification_action_nothing);\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "363", "src_id": "M343", "code": "    private void adjustSeekbarPreviewContainer() {\n        try {\n            // Should only be required when an error occurred before\n            // and the layout was positioned in the center\n            binding.bottomSeekbarPreviewLayout.setGravity(Gravity.NO_GRAVITY);\n\n            // Calculate the current left position of seekbar progress in px\n            // More info: https://stackoverflow.com/q/20493577\n            final int currentSeekbarLeft = binding.playbackSeekBar.getLeft() + binding.playbackSeekBar.getPaddingLeft() + binding.playbackSeekBar.getThumb().getBounds().left;\n            // Calculate the (unchecked) left position of the container\n            final int uncheckedContainerLeft = currentSeekbarLeft - (binding.seekbarPreviewContainer.getWidth() / 2);\n            // Fix the position so it's within the boundaries\n            final int checkedContainerLeft = MathUtils.clamp(uncheckedContainerLeft, 0, binding.playbackWindowRoot.getWidth() - binding.seekbarPreviewContainer.getWidth());\n            // See also: https://stackoverflow.com/a/23249734\n            final LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(binding.seekbarPreviewContainer.getLayoutParams());\n\n            params.setMarginStart(checkedContainerLeft);\n            binding.seekbarPreviewContainer.setLayoutParams(params);\n        } catch (final Exception ex) {\n                Log.e(TAG, \"Failed to adjust seekbarPreviewContainer\", ex);\n                // Fallback - position in the middle\n                binding.bottomSeekbarPreviewLayout.setGravity(Gravity.CENTER);\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "364", "src_id": "M995", "code": "    public static void fetchStreamInfoAndSaveToDatabase(@NonNull final Context context, final int serviceId,@NonNull final String url, final Consumer<StreamInfo> callback) {\n        Toast.makeText(context, R.string.loading_stream_details, Toast.LENGTH_SHORT).show();\n        ExtractorHelper.getStreamInfo(serviceId, \n                url, false)\n                .subscribeOn(Schedulers\n                .io())\n                .observeOn(AndroidSchedulers\n                .mainThread())\n                .subscribe(result -> {// save to database in the background (not on main thread)\n            Completable.fromAction(() -> NewPipeDatabase\n                    .getInstance(context)\n                    .streamDAO()\n                    .upsert(new StreamEntity(result)))\n                    .subscribeOn(Schedulers\n                    .io())\n                    .observeOn(Schedulers\n                    .io())\n                    .doOnError(throwable -> ErrorUtil\n                    .createNotification(context,\n                    new ErrorInfo(throwable, \n                    UserAction.REQUESTED_STREAM,\n                    \"Saving stream info to database\", \n                    result)))\n                    .subscribe()\n                    ; // call callback on main thread with the obtained result\n            callback.accept(result)\n            ;}, \n        throwable -> ErrorUtil.createNotification(context, new ErrorInfo(throwable, UserAction.REQUESTED_STREAM, \"Loading stream info: \" + url, serviceId)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "365", "src_id": "M741", "code": "    private void onItemSelectedSetFileName() {\n        final String fileName = FilenameUtils.createFilename(getContext(), currentInfo.getName());\n        final String prevFileName = Optional.ofNullable(dialogBinding.fileName.getText()).map(Object::toString).orElse(\"\");\n\n        if (prevFileName.isEmpty() || prevFileName.equals(fileName) || prevFileName.startsWith(getString(R.string.caption_file_name, fileName, \"\"))) {// only update the file name field if it was not edited by the user\n\n            switch (dialogBinding.videoAudioGroup.getCheckedRadioButtonId()) {\n                case R.id.audio_button : \n                case R.id.video_button : \n                    if (!prevFileName.equals(fileName)) {\n                        // since the user might have switched between audio and video, the correct\n                        // text might already be in place, so avoid resetting the cursor position\n                        dialogBinding.fileName.setText(fileName);\n                    }\n                    break;\n\n                case R.id.subtitle_button : \n                    final String setSubtitleLanguageCode = subtitleStreamsAdapter.getItem(selectedSubtitleIndex).getLanguageTag();\n\n                    // this will reset the cursor position, which is bad UX, but it can't be avoided\n                    dialogBinding.fileName.setText(getString(R.string.caption_file_name, fileName, setSubtitleLanguageCode));\n                    break;\n            }\n\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "366", "src_id": "M338", "code": "    private void updateEndScreenThumbnail(@Nullable final Bitmap thumbnail) {\n        if (thumbnail == null) {\n            // remove end screen thumbnail\n            binding.endScreen.setImageDrawable(null);\n\n            return;\n        }\n\n        final float endScreenHeight = calculateMaxEndScreenThumbnailHeight(thumbnail);\n        final Bitmap endScreenBitmap = BitmapCompat\n                .createScaledBitmap(thumbnail,\n                (int) (thumbnail.getWidth() \n                 / (thumbnail.getHeight() \n                 / endScreenHeight\n                )\n                ),\n                (int) endScreenHeight,\n                null, true);\n\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - onThumbnailLoaded() called with: \"\n                     + \"currentThumbnail = [\" \n                     + thumbnail \n                     + \"], \"\n                     + thumbnail.getWidth() \n                     + \"x\" \n                     + thumbnail.getHeight()\n                     + \", scaled end screen height = \" \n                     + endScreenHeight\n                     + \", scaled end screen width = \" \n                     + endScreenBitmap.getWidth());\n        }\n        binding.endScreen.setImageBitmap(endScreenBitmap);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "250", "src_id": "M343", "code": "private static EmailContent extractEmailContentAdvanced(byte[] emlBytes, EmlToPdfRequest request) {\n\n    try {\n        // Use Jakarta Mail for processing\n        Class<?> sessionClass = Class.forName(\"jakarta.mail.Session\");\n        Class<?> mimeMessageClass = Class.forName(\"jakarta.mail.internet.MimeMessage\");\n        Method getDefaultInstance = sessionClass.getMethod(\"getDefaultInstance\", Properties.class);\n        Object session = getDefaultInstance.invoke(null, new Properties());\n        // Cast the session object to the proper type for the constructor\n        Class<?>[] constructorArgs = new Class<?>[] {sessionClass, InputStream.class};\n        Constructor<?> mimeMessageConstructor = mimeMessageClass.getConstructor(constructorArgs);\n        Object message = mimeMessageConstructor.newInstance(session, new ByteArrayInputStream(emlBytes));\n        return extractEmailContentAdvanced(message, request);\n\n    } catch (ReflectiveOperationException e) {\n            // Create basic EmailContent from basic processing\n            EmailContent content = new EmailContent();\n            content.setHtmlBody(convertEmlToHtmlBasic(emlBytes, request));\n            return content;\n        }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "251", "src_id": "M347", "code": "private static void addAttachmentToInfo(StringBuilder attachmentInfo, String filename, String contentType, String encoding) {\n    // Create attachment info with paperclip emoji before filename\n    attachmentInfo.append(\"<div class=\\\"attachment-item\\\">\")\n        .append(\"<span class=\\\"attachment-icon\\\">\")\n        .append(MimeConstants.ATTACHMENT_MARKER)\n        .append(\"</span> \")\n        .append(\"<span class=\\\"attachment-name\\\">\")\n        .append(escapeHtml(filename))\n        .append(\"</span>\");\n    // Add content type and encoding info\n    if (!contentType.isEmpty() || !encoding.isEmpty()) {\n        attachmentInfo.append(\" <span class=\\\"attachment-details\\\">(\");\n        if (!contentType.isEmpty()) {\n            attachmentInfo.append(escapeHtml(contentType));\n\n        }\n\n        if (!encoding.isEmpty()) {\n            if (!contentType.isEmpty()) {\n                attachmentInfo.append(\", \");\n            }\n            attachmentInfo.append(\"encoding: \").append(escapeHtml(encoding));\n\n        }\n        attachmentInfo.append(\")</span>\");\n    }\n\n    attachmentInfo.append(\"</div>\\n\");\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "252", "src_id": "M361", "code": "private static void processPartAdvanced(Object part, EmailContent content, EmlToPdfRequest request) {\n\n    try {\n        if (!isValidJakartaMailPart(part)) {\n            log.warn(\"Invalid Jakarta Mail part type: {}\", part.getClass().getName());\n            return;\n        }\n\n        Class<?> partClass = part.getClass();\n        Method isMimeType = partClass.getMethod(\"isMimeType\", String.class);\n        Method getContent = partClass.getMethod(\"getContent\");\n        Method getDisposition = partClass.getMethod(\"getDisposition\");\n        Method getFileName = partClass.getMethod(\"getFileName\");\n        Method getContentType = partClass.getMethod(\"getContentType\");\n        Method getHeader = partClass.getMethod(\"getHeader\", String.class);\n        Object disposition = getDisposition.invoke(part);\n        String filename = (String) getFileName.invoke(part);\n        String contentType = (String) getContentType.invoke(part);\n\n        if ((Boolean) isMimeType.invoke(part, \"text/plain\") && disposition == null) {\n            content.setTextBody((String) getContent.invoke(part));\n\n        } else if ((Boolean) isMimeType.invoke(part, \"text/html\") && disposition == null) {\n            content.setHtmlBody((String) getContent.invoke(part));\n\n        } else if (\"attachment\".equalsIgnoreCase((String) disposition) || (filename != null && !filename.trim().isEmpty())) {\n            content.setAttachmentCount(content.getAttachmentCount() + 1);\n            // Always extract basic attachment metadata for display\n            if (filename != null && !filename.trim().isEmpty()) {\n                // Create attachment with metadata only\n                EmailAttachment attachment = new EmailAttachment();\n                // Apply MIME decoding to filename to handle encoded attachment names\n                attachment.setFilename(safeMimeDecode(filename));\n                attachment.setContentType(contentType);\n                // Check if it's an embedded image\n                String[] contentIdHeaders = (String[]) getHeader.invoke(part, \"Content-ID\");\n\n                if (contentIdHeaders != null && contentIdHeaders.length > 0) {\n                    attachment.setEmbedded(true); // Store the Content-ID, removing angle brackets if present\n                    String contentId = contentIdHeaders[0];\n                    if (contentId.startsWith(\"<\") && contentId.endsWith(\">\")) {\n                        contentId = contentId.substring(1, contentId.length() - 1);\n\n                    }\n                    attachment.setContentId(contentId);\n                }\n\n                // Extract attachment data if attachments should be included OR if it's an\n                // embedded image (needed for inline display)\n                if ((request != null && request.isIncludeAttachments()) || attachment.isEmbedded()) {\n\n                    try {\n                        Object attachmentContent = getContent.invoke(part);\n                        byte[] attachmentData = null;\n\n                        if (attachmentContent instanceof java.io.InputStream inputStream) {\n                            try {\n                                attachmentData = inputStream.readAllBytes();\n\n                            } catch (IOException e) {\n                                    log.warn(\"Failed to read InputStream attachment: {}\", e.getMessage());\n\n                                }\n\n                        } else if (attachmentContent instanceof byte[] byteArray) {\n                            attachmentData = byteArray;\n                        } else if (attachmentContent instanceof String stringContent) {\n                            attachmentData = stringContent.getBytes(StandardCharsets.UTF_8);\n\n                        }\n\n\n                        if (attachmentData != null) {\n                            // Check size limit (use default 10MB if request is null)\n                            long maxSizeMB = request != null ? request.getMaxAttachmentSizeMB() : 10L;\n                            long maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n                            if (attachmentData.length <= maxSizeBytes) {\n                                attachment.setData(attachmentData);\n                                attachment.setSizeBytes(attachmentData.length);\n\n                            } else {\n                                // For embedded images, always include data regardless of size\n                                // to ensure inline display works\n                                if (attachment.isEmbedded()) { \n                                    attachment.setData(attachmentData);\n                                }  \n                                attachment.setSizeBytes(attachmentData.length);\n\n                            }\n                        }\n                    } catch (Exception e) {\n                            log.warn(\"Error extracting attachment data: {}\", e.getMessage());\n\n                        }\n\n                }\n\n                // Add attachment to the list for display (with or without data)\n                content.getAttachments().add(attachment);\n\n            }\n        } else if ((Boolean) isMimeType.invoke(part, \"multipart/*\")) {\n            // Handle nested multipart content\n            try {\n                Object multipartContent = getContent.invoke(part);\n                Class<?> multipartClass = Class.forName(\"jakarta.mail.Multipart\");\n                if (multipartClass.isInstance(multipartContent)) {\n                    processMultipartAdvanced(multipartContent, content, request);\n\n                }\n            } catch (Exception e) {\n                    log.warn(\"Error processing multipart content: {}\", e.getMessage());\n\n                }\n\n        }\n\n    } catch (Exception e) {\n            log.warn(\"Error processing multipart part: {}\", e.getMessage());\n\n        }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "253", "src_id": "M509", "code": "@Operation(\nsummary = \"Convert EML to PDF\",\ndescription = \n\"This endpoint converts EML (email) files to PDF format with extensive\" + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\" + \" and HTML debug output. Input: EML file, Output: PDF\" + \" or HTML file. Type: SISO\")\n@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\npublic ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n    MultipartFile inputFile = request.getFileInput();\n    String originalFilename = inputFile.getOriginalFilename();\n    // Validate input\n    if (inputFile.isEmpty()) {\n        log.error(\"No file provided for EML to PDF conversion.\");\n        return ResponseEntity.badRequest().body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n\n    }\n\n    if (originalFilename == null || originalFilename.trim().isEmpty()) {\n        log.error(\"Filename is null or empty.\");\n        return ResponseEntity.badRequest().body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n\n    }\n\n    // Validate file type - support EML\n    String lowerFilename = originalFilename.toLowerCase();\n    if (!lowerFilename.endsWith(\".eml\")) {\n        log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n        return ResponseEntity.badRequest().body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n\n    }\n\n    String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n\n    try {\n        byte[] fileBytes = inputFile.getBytes();\n\n        if (request.isDownloadHtml()) {\n            try {\n                String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(htmlContent.getBytes(StandardCharsets.UTF_8), baseFilename + \".html\", MediaType.TEXT_HTML);\n\n            } catch (IOException | IllegalArgumentException e) {\n                    log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                    return ResponseEntity.status(HttpStatus\n                        .INTERNAL_SERVER_ERROR)\n                        .body((\"HTML conversion failed: \" + e.getMessage())\n                        .getBytes(StandardCharsets.UTF_8));\n\n                }\n\n        }\n\n        // Convert EML to PDF with enhanced options\n        try {\n            byte[] pdfBytes = EmlToPdf.convertEmlToPdf(runtimePathConfig\n                .getWeasyPrintPath(), \n            // Use configured WeasyPrint path\n                request, fileBytes, originalFilename,\n                false, pdfDocumentFactory, tempFileManager);\n\n            if (pdfBytes == null || pdfBytes.length == 0) {\n                log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                return ResponseEntity.status(HttpStatus\n                    .INTERNAL_SERVER_ERROR)\n                    .body(\"PDF conversion failed - empty output\"\n                    .getBytes(StandardCharsets.UTF_8));\n\n            }\n\n            log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n            return WebResponseUtils.bytesToWebResponse(pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n\n        } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n\n            } catch (IllegalArgumentException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n\n            } catch (RuntimeException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\"EML to PDF conversion failed for {}: {}\", originalFilename, errorMessage, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorMessage.getBytes(StandardCharsets.UTF_8));\n\n            }\n\n    } catch (IOException e) {\n            log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n\n        }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "38", "src_id": "M1294", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (definition != null) {\n            definition.addParams(args);\n        }\n\n        if ((flags & USE_TERM_OFFSETS) == 0) {\n            args.add(SearchKeyword.NOOFFSETS.name());\n        }\n\n        if ((flags & KEEP_FIELD_FLAGS) == 0) {\n            args.add(SearchKeyword.NOFIELDS.name());\n        }\n\n        if ((flags & KEEP_TERM_FREQUENCIES) == 0) {\n            args.add(SearchKeyword.NOFREQS.name());\n        }\n\n        if (expire > 0) {\n            args.add(SearchKeyword.TEMPORARY.name());\n            args.add(Long.toString(this.expire));\n        }\n\n        if (stopwords != null) {\n            args.add(SearchKeyword.STOPWORDS.name());\n            args.add(Integer.toString(stopwords.size()));\n            if (!stopwords.isEmpty()) {\n                args.addObjects(stopwords);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "39", "src_id": "M50", "code": "    @Override @SuppressWarnings(\"unchecked\")\n    public Map<byte[], byte[]> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (!(list.get(0) instanceof KeyValue)) {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n            }\n            return map;\n        } else {\n            final Map<byte[], byte[]> map = new JedisByteHashMap();\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n            }\n            return map;\n        } \n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "40", "src_id": "M933", "code": "    @Deprecated\n    public static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n        Builder builder = builder();\n        builder.protocol(copy.getRedisProtocol());\n        builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n        builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n        builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n        Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n        if (credentialsProvider != null) {\n            builder.credentialsProvider(credentialsProvider);\n        } else {\n            builder.user(copy.getUser());\n\n            builder.password(copy.getPassword());\n        }\n        builder.database(copy.getDatabase());\n        builder.clientName(copy.getClientName());\n\n        builder.ssl(copy.isSsl());\n        builder.sslSocketFactory(copy.getSslSocketFactory());\n        builder.sslParameters(copy.getSslParameters());\n        builder.hostnameVerifier(copy.getHostnameVerifier());\n        builder.sslOptions(copy.getSslOptions());\n        builder.hostAndPortMapper(copy.getHostAndPortMapper());\n        builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n        if (copy.isReadOnlyForRedisClusterReplicas()) {\n            builder.readOnlyForRedisClusterReplicas();\n        }\n        builder.authXManager(copy.getAuthXManager());\n\n        return builder.build();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "41", "src_id": "M913", "code": "    @Override\n    public Map<String, TSMRangeElements> build(Object data) {\n        List<KeyValue> dataList = (List<KeyValue>) data;\n        Map<String, TSMRangeElements> map = new LinkedHashMap<>(dataList.size() / 2, 1f);\n\n        for (KeyValue kv : dataList) {\n            String key = BuilderFactory.STRING.build(kv.getKey());\n            List<Object> valueList = (List<Object>) kv.getValue();\n            TSMRangeElements elements;\n\n            switch (valueList.size()) {\n                case 3 : \n                    List<Object> aggrMapObj = (List<Object>) valueList.get(1);\n                    KeyValue aggKV = (KeyValue) aggrMapObj.get(0);\n                    assert \"aggregators\".equalsIgnoreCase(BuilderFactory.STRING.build(aggKV.getKey()));\n                    elements = new TSMRangeElements(key,\n                            BuilderFactory.STRING_MAP\n                            .build(valueList.get(0)),\n                            ((List<Object>) aggKV\n                            .getValue()\n                            )\n                            .stream()\n                            .map(BuilderFactory.STRING\n                            ::build)\n                            .map(AggregationType\n                            ::safeValueOf)\n                            .collect(Collectors.toList()),\n                            TIMESERIES_ELEMENT_LIST\n                            .build(valueList.get(2)));\n                    break;\n                case 4 : \n                    List<KeyValue> rdcMapObj = (List<KeyValue>) valueList.get(1);\n\n                    assert \"reducers\".equalsIgnoreCase(BuilderFactory.STRING.build(rdcMapObj.get(0).getKey()));\n\n                    List<KeyValue> srcMapObj = (List<KeyValue>) valueList.get(2);\n\n                    assert \"sources\".equalsIgnoreCase(BuilderFactory.STRING.build(srcMapObj.get(0).getKey()));\n                    elements = new TSMRangeElements(key,\n                            BuilderFactory.STRING_MAP\n                            .build(valueList.get(0)),\n                            BuilderFactory.STRING_LIST\n                            .build(rdcMapObj.get(0)\n                            .getValue()),\n                            BuilderFactory.STRING_LIST\n                            .build(srcMapObj.get(0)\n                            .getValue()),\n                            TIMESERIES_ELEMENT_LIST\n                            .build(valueList.get(3)));\n                    break;\n                default : \n                    throw new IllegalStateException();\n            }\n\n            map.put(key, elements);\n        }\n        return map;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1146", "code": "    private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n        JedisRedirectionException redirect = null;\n        int consecutiveConnectionFailures = 0;\n        Exception lastException = null;\n\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n            Connection connection = null;\n\n            try {\n                if (redirect == null) {\n                    connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments()) : provider.getConnection(commandObject.getArguments());\n                } else {\n                    connection = provider.getConnection(redirect.getTargetNode());\n                    if (redirect instanceof JedisAskDataException) {\n                        // TODO: Pipeline asking with the original command to make it faster....\n                        connection.executeCommand(Protocol.Command.ASKING);\n                    }\n                } \n\n                return execute(connection, commandObject);\n            } catch (JedisClusterOperationException jnrcne) {\n                    throw jnrcne;\n                } catch (JedisConnectionException jce) {\n                    lastException = jce;\n\n                    ++consecutiveConnectionFailures;\n                    log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n\n                    // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                    boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n                    if (reset) {\n                        consecutiveConnectionFailures = 0;\n\n                        redirect = null;\n                    }\n                } catch (JedisRedirectionException jre) {\n                    // avoid updating lastException if it is a connection exception\n                    if (lastException == null || lastException instanceof JedisRedirectionException) {\n                        lastException = jre;\n                    }\n                    log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n                    consecutiveConnectionFailures = 0;\n\n                    redirect = jre;\n                    // if MOVED redirection occurred,\n                    if (jre instanceof JedisMovedDataException) {\n                        // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                        provider.renewSlotCache(connection);\n                    }\n                } finally {\n                    IOUtils.closeQuietly(connection);\n                }\n            if (Instant.now().isAfter(deadline)) {\n                throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n            }\n        }\n\n        JedisClusterOperationException maxAttemptsException = new JedisClusterOperationException(\"No more cluster attempts left.\");\n\n        maxAttemptsException.addSuppressed(lastException);\n\n        throw maxAttemptsException;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "43", "src_id": "M55", "code": "    @Override @SuppressWarnings(\"unchecked\")\n    public Map<String, Long> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (!(list.get(0) instanceof KeyValue)) {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), LONG.build(iterator.next()));\n            }\n            return map;\n        } else {\n            final Map<String, Long> map = new LinkedHashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), LONG.build(kv.getValue()));\n            }\n            return map;\n        } \n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "44", "src_id": "M52", "code": "    @Override\n    public Map<String, Object> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) {\n            return Collections.emptyMap();\n        }\n\n        if (!(list.get(0) instanceof KeyValue)) {\n            final Map<String, Object> map = new HashMap<>(list.size() / 2, 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                map.put(STRING.build(iterator.next()), ENCODED_OBJECT.build(iterator.next()));\n            }\n            return map;\n        } else {\n            final Map<String, Object> map = new HashMap<>(list.size(), 1f);\n            final Iterator iterator = list.iterator();\n            while (iterator.hasNext()) {\n                KeyValue kv = (KeyValue) iterator.next();\n                map.put(STRING.build(kv.getKey()), ENCODED_OBJECT.build(kv.getValue()));\n            }\n            return map;\n        } \n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n                jedis.ping();\n\n                return jedis;\n            } catch (JedisException ex) {\n                    if (suppressed == null) { // remembering first suppressed exception\n\n                        suppressed = ex;\n                    }\n\n                    if (jedis != null) {\n                        jedis.close();\n                    }\n                }\n\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "46", "src_id": "M1131", "code": "    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE : \n                return is.readLineBytes();\n            case DOLLAR_BYTE : \n            case EQUAL_BYTE : \n                return processBulkReply(is);\n            case ASTERISK_BYTE : \n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE : \n                return is.readNullCrLf();\n            case HASH_BYTE : \n                return is.readBooleanCrLf();\n            case COLON_BYTE : \n                return is.readLongCrLf();\n            case COMMA_BYTE : \n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE : \n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE : // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE : \n                return processMultiBulkReply(is);\n            case MINUS_BYTE : \n                processError(is);\n\n                return null;\n            // TODO: Blob error '!'\n            default : \n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "47", "src_id": "M1298", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (type != null) {\n            args.add(SearchKeyword.ON.name());\n\n            args.add(type.name());\n        }\n\n        if (prefixes != null && prefixes.length > 0) {\n            args.add(SearchKeyword.PREFIX.name());\n            args.add(Integer.toString(prefixes.length));\n            args.addObjects((Object[]) prefixes);\n        }\n\n        if (filter != null) {\n            args.add(SearchKeyword.FILTER.name());\n\n            args.add(filter);\n        }\n\n        if (languageField != null) {\n            args.add(SearchKeyword.LANGUAGE_FIELD.name());\n\n            args.add(languageField);\n        }\n\n        if (language != null) {\n            args.add(SearchKeyword.LANGUAGE.name());\n\n            args.add(language);\n        }\n\n        if (scoreFiled != null) {\n            args.add(SearchKeyword.SCORE_FIELD.name());\n\n            args.add(scoreFiled);\n        }\n\n        if (score != 1.0) {\n            args.add(SearchKeyword.SCORE.name());\n\n            args.add(Double.toString(score));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "415", "src_id": "M676", "code": "    @SuppressWarnings(\"unchecked\") void done() {\n        if (decrementAndGet() == 0) {\n            Object o1 = observer1.value;\n            Object o2 = observer2.value;\n\n            if (o1 != null && o2 != null) {\n                boolean b;\n                try {\n                    b = isEqual.test((T) o1, (T) o2);\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        downstream.onError(ex);\n                        return;\n                    }\n\n                downstream.onSuccess(b);\n            } else {\n                downstream.onSuccess(o1 == null && o2 == null);\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "416", "src_id": "M275", "code": "    @Override\n    public void subscribe(Observer<? super T> observer) {\n        while (true) {\n            int s = once.get();\n\n            if ((s & HAS_SUBSCRIBER) != 0) {\n                break;\n            }\n\n            int u = s | HAS_SUBSCRIBER;\n\n            if (!(once.compareAndSet(s, u))) { \n                continue; \n            }  \n            observer.onSubscribe(this);\n            actual.lazySet(observer);\n\n            if (cancelled.get()) {\n                actual.lazySet(null);\n            } else {\n                drain();\n            }\n            return;\n        }\n\n        EmptyDisposable.error(new IllegalStateException(\"Only one Observer allowed!\"), observer);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "417", "src_id": "M1571", "code": "    @Override\n    public void onSuccess(T value) {\n        Observer<? super R> a = downstream;\n        Iterator<? extends R> iterator;\n        boolean has;\n        try {\n            iterator = mapper.apply(value).iterator();\n            has = iterator.hasNext();\n        } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                downstream.onError(ex);\n                return;\n            }\n\n\n        if (!has) {\n            a.onComplete();\n            return;\n        }\n\n        if (outputFused) {\n            it = iterator;\n            a.onNext(null);\n            a.onComplete();\n        } else {\n            while (true) {\n                if (cancelled) {\n                    return;\n                }\n\n                R v;\n                try {\n                    v = iterator.next();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        a.onError(ex);\n                        return;\n                    }\n\n                a.onNext(v);\n\n                if (cancelled) {\n                    return;\n                }\n\n                boolean b;\n                try {\n                    b = iterator.hasNext();\n                } catch (Throwable ex) {\n                        Exceptions.throwIfFatal(ex);\n                        a.onError(ex);\n                        return;\n                    }\n\n\n                if (b) { \n                    continue; \n                }  \n                a.onComplete();\n                return;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "418", "src_id": "M1183", "code": "    @Override void fastPath() {\n        Iterator<? extends T> it = this.iterator;\n        ConditionalSubscriber<? super T> a = downstream;\n\n        while (true) {\n            if (cancelled) {\n                return;\n            }\n\n            T t;\n            try {\n                t = it.next();\n            } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n\n            if (cancelled) {\n                return;\n            }\n            if (t == null) {\n                a.onError(new NullPointerException(\"Iterator.next() returned a null value\"));\n                return;\n            } else {\n                a.tryOnNext(t);\n            }\n            if (cancelled) {\n                return;\n            }\n\n            boolean b;\n            try {\n                b = it.hasNext();\n            } catch (Throwable ex) {\n                    Exceptions.throwIfFatal(ex);\n                    a.onError(ex);\n                    return;\n                }\n\n\n            if (b) { \n                continue; \n            }  \n            if (!cancelled) {\n                a.onComplete();\n            }\n            return;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "419", "src_id": "M1995", "code": "    static <T> boolean postCompleteDrain(long n, Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) {// TODO enable fast-path\n        //        if (n == -1 || n == Long.MAX_VALUE) {\n        //            for (;;) {\n        //                if (isCancelled.getAsBoolean()) {\n        //                    break;\n        //                }\n        //\n        //                T v = queue.poll();\n        //\n        //                if (v == null) {\n        //                    actual.onComplete();\n        //                    break;\n        //                }\n        //\n        //                actual.onNext(v);\n        //            }\n        //\n        //            return true;\n        //        }\n\n        long e = n & COMPLETED_MASK;\n\n        while (true) {\n            while (e != n) {\n                if (isCancelled(isCancelled)) {\n                    return true;\n                }\n\n                T t = queue.poll();\n\n                if (t == null) {\n                    actual.onComplete();\n                    return true;\n                }\n                actual.onNext(t);\n                e++;\n            }\n\n            if (isCancelled(isCancelled)) {\n                return true;\n            }\n            if (queue.isEmpty()) {\n                actual.onComplete();\n                return true;\n            }\n            n = state.get();\n\n            if (n != e) { \n                continue; \n            }  \n            n = state.addAndGet(-(e & REQUESTED_MASK));\n\n            if ((n & REQUESTED_MASK) == 0L) {\n                return false;\n            }\n            e = n & COMPLETED_MASK;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "420", "src_id": "M1315", "code": "    void drainLoop() {\n        int missed = 1;\n        Subscriber<? super R> a = downstream;\n        AtomicInteger n = active;\n        AtomicReference<SpscLinkedArrayQueue<R>> qr = queue;\n\n        while (true) {\n            long r = requested.get();\n            long e = 0L;\n\n            while (e != r) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n                if (!delayErrors) {\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                }\n\n                boolean d = n.get() == 0;\n                SpscLinkedArrayQueue<R> q = qr.get();\n                R v = q != null ? q.poll():null;\n                boolean empty = v == null;\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                a.onNext(v);\n                e++;\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    clear();\n                    return;\n                }\n                if (!delayErrors) {\n                    Throwable ex = errors.get();\n\n                    if (ex != null) {\n                        clear();\n                        errors.tryTerminateConsumer(a);\n                        return;\n                    }\n                }\n\n                boolean d = n.get() == 0;\n                SpscLinkedArrayQueue<R> q = qr.get();\n                boolean empty = q == null || q.isEmpty();\n\n                if (d && empty) {\n                    errors.tryTerminateConsumer(a);\n                    return;\n                }\n            }\n\n            if (e != 0L) {\n                BackpressureHelper.produced(requested, e);\n\n                if (maxConcurrency != Integer.MAX_VALUE) {\n                    upstream.request(e);\n                }\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "421", "src_id": "M856", "code": "    void drain() {\n        if (getAndIncrement() != 0) {\n            return;\n        }\n\n        int missed = 1;\n        Subscriber<? super T> a = downstream;\n        List<T>[] lists = this.lists;\n        int[] indexes = this.indexes;\n        int n = indexes.length;\n\n        while (true) {\n            long r = requested.get();\n            long e = 0L;\n\n            while (e != r) {\n                if (cancelled) {\n                    Arrays.fill(lists, null);\n                    return;\n                }\n\n                Throwable ex = error.get();\n\n                if (ex != null) {\n                    cancelAll();\n                    Arrays.fill(lists, null);\n                    a.onError(ex);\n                    return;\n                }\n\n                T min = null;\n                int minIndex = -1;\n\n                for (int i = 0; i < n; i++) {\n                    List<T> list = lists[i];\n                    int index = indexes[i];\n\n                    if (list.size() != index) {\n                        if (min == null) {\n                            min = list.get(index);\n                            minIndex = i;\n                        } else {\n                            T b = list.get(index);\n                            boolean smaller;\n                            try {\n                                smaller = comparator.compare(min, b) > 0;\n                            } catch (Throwable exc) {\n                                    Exceptions.throwIfFatal(exc);\n                                    cancelAll();\n                                    Arrays.fill(lists, null);\n\n                                    if (!error.compareAndSet(null, exc)) {\n                                        RxJavaPlugins.onError(exc);\n                                    }\n                                    a.onError(error.get());\n                                    return;\n                                }\n\n\n                            if (smaller) {\n                                min = b;\n                                minIndex = i;\n                            }\n                        }\n                    }\n                }\n\n                if (min == null) {\n                    Arrays.fill(lists, null);\n                    a.onComplete();\n                    return;\n                }\n                a.onNext(min);\n                indexes[minIndex]++;\n                e++;\n            }\n\n            if (cancelled) {\n                Arrays.fill(lists, null);\n                return;\n            }\n\n            Throwable ex = error.get();\n\n            if (ex != null) {\n                cancelAll();\n                Arrays.fill(lists, null);\n                a.onError(ex);\n                return;\n            }\n\n            boolean empty = true;\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] == lists[i].size()) { \n                    continue; \n                }  \n                empty = false;\n                break;\n            }\n\n            if (empty) {\n                Arrays.fill(lists, null);\n                a.onComplete();\n                return;\n            }\n            if (e != 0) {\n                BackpressureHelper.produced(requested, e);\n            }\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "422", "src_id": "M1224", "code": "    void drainLoop() {\n        Subscriber<? super T> actual = this.downstream;\n        int missed = 1;\n        long e = emitted;\n        int c = consumed;\n        int lim = limit;\n\n        while (true) {\n            long r = requested.get();\n\n            while (e != r) {\n                if (cancelled) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                int os = otherState;\n\n                if (os == OTHER_STATE_HAS_VALUE) {\n                    T v = singleItem;\n\n                    singleItem = null;\n                    otherState = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    os = OTHER_STATE_CONSUMED_OR_EMPTY;\n                    actual.onNext(v);\n                    e++;\n                    continue;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                T v = q != null ? q.poll():null;\n                boolean empty = v == null;\n\n                if (d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n                if (empty) {\n                    break;\n                }\n                actual.onNext(v);\n                e++;\n\n                if (++c != lim) { \n                    continue; \n                }  \n                c = 0;\n                mainSubscription.get().request(lim);\n            }\n\n            if (e == r) {\n                if (cancelled) {\n                    singleItem = null;\n                    queue = null;\n                    return;\n                }\n                if (errors.get() != null) {\n                    singleItem = null;\n                    queue = null;\n                    errors.tryTerminateConsumer(downstream);\n                    return;\n                }\n\n                boolean d = mainDone;\n                SimplePlainQueue<T> q = queue;\n                boolean empty = q == null || q.isEmpty();\n\n                if (d && empty && otherState == 2) {\n                    queue = null;\n                    actual.onComplete();\n                    return;\n                }\n            }\n            emitted = e;\n            consumed = c;\n            missed = addAndGet(-missed);\n\n            if (missed == 0) {\n                break;\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "423", "src_id": "M2134", "code": "    @NonNull\n    @SuppressWarnings(\"unchecked\")\n    public final U assertValueAt(int index, @NonNull Predicate<T> valuePredicate) {\n        int s = values.size();\n\n        if (s == 0) {\n            throw fail(\"No values\");\n        }\n        if (index < 0 || index >= s) {\n            throw fail(\"Index \" + index + \" is out of range [0, \" + s + \")\");\n        }\n\n        boolean found = false;\n        T v = values.get(index);\n        try {\n            if (valuePredicate.test(v)) {\n                found = true;\n            }\n        } catch (Throwable ex) {\n                throw ExceptionHelper.wrapOrThrow(ex);\n            }\n\n\n        if (!found) {\n            throw fail(\"Value \" + valueAndClass(v) + \" at position \" + index + \" did not pass the predicate\");\n        }\n        return (U) this;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "424", "src_id": "M2722", "code": "    @Override\n    public void onSubscribe(@NonNull Subscription s) {\n        if (SubscriptionHelper.validate(this.upstream, s)) {\n            this.upstream = s;\n            try {\n                downstream.onSubscribe(this);\n            } catch (Throwable e) {\n                    Exceptions.throwIfFatal(e);\n                    done = true;\n                    // can't call onError because the actual's state may be corrupt at this point\n                    try {\n                        s.cancel();\n                    } catch (Throwable e1) {\n                            Exceptions.throwIfFatal(e1);\n                            RxJavaPlugins.onError(new CompositeException(e, e1));\n                            return;\n                        }\n\n                    RxJavaPlugins.onError(e);\n                }\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1058", "code": "        private void startMission(Intent intent) {\n            String[] urls = intent.getStringArrayExtra(EXTRA_URLS);\n            Uri path = IntentCompat.getParcelableExtra(intent, EXTRA_PATH, Uri.class);\n            Uri parentPath = IntentCompat.getParcelableExtra(intent, EXTRA_PARENT_PATH, Uri.class);\n            int threads = intent.getIntExtra(EXTRA_THREADS, 1);\n            char kind = intent.getCharExtra(EXTRA_KIND, '?');\n            String psName = intent.getStringExtra(EXTRA_POSTPROCESSING_NAME);\n            String[] psArgs = intent.getStringArrayExtra(EXTRA_POSTPROCESSING_ARGS);\n            String source = intent.getStringExtra(EXTRA_SOURCE);\n            long nearLength = intent.getLongExtra(EXTRA_NEAR_LENGTH, 0);\n            String tag = intent.getStringExtra(EXTRA_STORAGE_TAG);\n            final var recovery = IntentCompat.getParcelableArrayListExtra(intent, EXTRA_RECOVERY_INFO, MissionRecoveryInfo.class);\n\n            Objects.requireNonNull(recovery);\n\n            StoredFileHelper storage;\n\n            try {\n                storage = new StoredFileHelper(this, parentPath, path, tag);\n            } catch (IOException e) {\n                    throw new RuntimeException(e);// this never should happen\n\n                }\n\n\n            Postprocessing ps = psName == null ? null: Postprocessing.getAlgorithm(psName, psArgs); \n            final DownloadMission mission = new DownloadMission(urls, storage, kind, ps);\n\n            mission.threadCount = threads;\n            mission.source = source;\n            mission.nearLength = nearLength;\n            mission.recoveryInfo = recovery.toArray(new MissionRecoveryInfo[0]);\n\n            if (ps != null) {\n\n                ps.setTemporalDir(DownloadManager.pickAvailableTemporalDir(this));\n            }\n\n            handleConnectivityState(true);// first check the actual network status\n\n            mManager.startMission(mission);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1037", "code": "        public void pause() {\n            if (!running) {\n                return;\n            }\n\n            if (isPsRunning()) {\n                if (DEBUG) {\n                    Log.w(TAG, \"pause during post-processing is not applicable.\");\n                }\n\n                return;\n            }\n\n            running = false;\n            notify(DownloadManagerService.MESSAGE_PAUSED);\n\n            if (init != null && init.isAlive()) {\n                // NOTE: if start() method is running Â¡will no have effect!\n                init.interrupt();\n                synchronized (LOCK) {\n                    resetState(false, true, ERROR_NOTHING);\n                }\n                return;\n            }\n\n            if (DEBUG && unknownLength) {\n                Log.w(TAG, \"pausing a download that can not be resumed (range requests not allowed by the server).\");\n            }\n\n            init = null;\n            pauseThreads();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "202", "src_id": "M1081", "code": "        void handleConnectivityState(NetworkState currentStatus, boolean updateOnly) {\n            if (currentStatus == mLastNetworkStatus) {\n                return;\n            }\n\n            mLastNetworkStatus = currentStatus;\n\n            if (currentStatus == NetworkState.Unavailable || !mSelfMissionsControl || updateOnly) {\n                return;\n            }\n\n            boolean isMetered = mPrefMeteredDownloads && mLastNetworkStatus == NetworkState.MeteredOperating;\n\n            synchronized (this) {\n                for (DownloadMission mission : mMissionsPending) {\n                    if (!(mission.isCorrupt() || mission.isPsRunning())) { \n                        if (mission.running && isMetered) {\n                            mission.pause();\n                        } else if (!mission.running && !isMetered && mission.enqueued) {\n                            mission.start();\n                            if (mPrefQueueLimit)break;\n                        }\n\n                    } \n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "203", "src_id": "M1099", "code": "        @SuppressLint(\"DefaultLocale\")\n        private void updateProgress(ViewHolderItem h) {\n            if (h == null || h.item == null || h.item.mission instanceof FinishedMission) {\n                return;\n            }\n\n            DownloadMission mission = (DownloadMission) h.item.mission;\n            double done = mission.done;\n            long length = mission.getLength();\n            long now = System.currentTimeMillis();\n            boolean hasError = mission.errCode != ERROR_NOTHING;\n\n            // hide on error\n            // show if current resource length is not fetched\n            // show if length is unknown\n            h.progress.setMarquee(mission.isRecovering() || !hasError && (!mission.isInitialized() || mission.unknownLength));\n\n            double progress;\n\n            if (mission.unknownLength) {\n                progress = Double.NaN;\n                h.progress.setProgress(0.0f);\n            } else {\n                progress = done / length;\n            }\n\n            if (hasError) {\n                h.progress.setProgress(isNotFinite(progress) ? 1d : progress);\n                h.status.setText(R.string.msg_error);\n            } else if (isNotFinite(progress)) {\n                h.status.setText(UNDEFINED_PROGRESS);\n            } else {\n                h.status.setText(String.format(\"%.2f%%\", progress * 100));\n                h.progress.setProgress(progress);\n            }\n\n\n            @StringRes int state;\n            String sizeStr = Utility.formatBytes(length).concat(\"  \");\n\n            if (mission.isPsFailed() || mission.errCode == ERROR_POSTPROCESSING_HOLD) {\n                h.size.setText(sizeStr);\n                return;\n            } else {\n                state = !mission.running? mission\n                .enqueued \n                ? R.string.queued : R.string.paused\n                : mission.isPsRunning()? R.string\n                .post_processing\n                : mission.isRecovering()? R.string\n                .recovering\n                : 0;\n            } \n\n            if (state != 0) {\n                // update state without download speed\n                h.size.setText(sizeStr.concat(\"(\").concat(mContext.getString(state)).concat(\")\"));\n                h.resetSpeedMeasure();\n                return;\n            }\n\n            if (h.lastTimestamp < 0) {\n                h.size.setText(sizeStr);\n                h.lastTimestamp = now;\n                h.lastDone = done;\n                return;\n            }\n\n            long deltaTime = now - h.lastTimestamp;\n            double deltaDone = done - h.lastDone;\n            if (h.lastDone > done) {\n                h.lastDone = done;\n                h.size.setText(sizeStr);\n                return;\n            }\n\n            if (deltaDone > 0 && deltaTime > 0) {\n                float speed = (float) ((deltaDone * 1000d) / deltaTime);\n                float averageSpeed = speed;\n\n                if (h.lastSpeedIdx < 0) {\n                    Arrays.fill(h.lastSpeed, speed);\n                    h.lastSpeedIdx = 0;\n                } else {\n                    for (int i = 0; i < h.lastSpeed.length; i++) {\n                        averageSpeed += h.lastSpeed[i];\n                    }\n                    averageSpeed /= h.lastSpeed.length + 1.0f;\n                }\n\n                String speedStr = Utility.formatSpeed(averageSpeed);\n                String etaStr;\n\n                if (mission.unknownLength) {\n                    etaStr = \"\";\n                } else {\n                    long eta = (long) Math.ceil((length - done) / averageSpeed);\n\n                    etaStr = Utility.formatBytes((long) done) + \"/\" + Utility.stringifySeconds(eta) + \"  \";\n                }\n\n                h.size.setText(sizeStr.concat(etaStr).concat(speedStr));\n                h.lastTimestamp = now;\n                h.lastDone = done;\n                h.lastSpeed[h.lastSpeedIdx++] = speed;\n\n                if (h.lastSpeedIdx >= h.lastSpeed.length) {\n                    h.lastSpeedIdx = 0;\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "204", "src_id": "M852", "code": "        public InputStream getView(final int size) {\n            if (view == null) {\n                view = new InputStream() {@Override public int read()throws IOException {if (viewSize \n                            < 1\n                            ) {return -1;} final int res = DataReader\n                        .this\n                        .read();if (res > 0) {viewSize--;} return res\n                        ;}@Override public int read(final byte[] buffer)throws IOException {return read(buffer, \n                        0, buffer.length)\n                        ;}@Override public int read(final byte[] buffer, final int offset, final int count)throws IOException {if (viewSize \n                            < 1\n                            ) {return -1;} final int res = DataReader.this.read(buffer, offset, Math.min(viewSize, count)); viewSize -= res;return res;}@Override public long skip(final long amount)throws IOException {if (viewSize < 1) {return 0;} final int res = (int) DataReader.this.skipBytes(Math.min(amount, viewSize)); viewSize -= res;return res;}@Override public int available() {return viewSize;}@Override public void close() {viewSize = 0;}@Override public boolean markSupported() {return false;}};\n            }\n\n            viewSize = size;\n            return view;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "205", "src_id": "M850", "code": "        public int read(final byte[] buffer, final int off, final int c)throws IOException {\n            int offset = off;\n            int count = c;\n            if (readCount < 0) {\n                return -1;\n            }\n\n            int total = 0;\n\n            if (count >= readBuffer.length) {\n                if (readCount > 0) {\n                    System.arraycopy(readBuffer, readOffset, buffer, offset, readCount);\n                    readOffset += readCount;\n                    offset += readCount;\n                    count -= readCount;\n                    total = readCount;\n                    readCount = 0;\n                }\n\n                total += Math.max(stream.read(buffer, offset, count), 0);\n            } else {\n                while (count > 0 && !fillBuffer()) {\n                    final int read = Math.min(readCount, count);\n\n                    System.arraycopy(readBuffer, readOffset, buffer, offset, read);\n                    readOffset += read;\n                    readCount -= read;\n                    offset += read;\n                    count -= read;\n                    total += read;\n                }\n            }\n\n            position += total;\n            return total;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "206", "src_id": "M803", "code": "        public void parse()throws IOException, NoSuchElementException {\n            if (selectedTrack > -1) {\n                return;\n            }\n\n            box = readBox(ATOM_FTYP);\n            brands = parseFtyp(box);\n\n            switch (brands[0]) {\n                case BRAND_DASH:\n                case BRAND_ISO5:// Â¿why not?\n\n                    break;\n                default:\n                    throw new NoSuchElementException(\"Not a MPEG-4 DASH container, major brand is not 'dash' or 'iso5' is \" + boxName(brands[0]));\n            }\n\n            Moov moov = null;\n            int i;\n            while (box.type != ATOM_MOOF) {\n                ensure(box);\n                box = readBox();\n\n                switch (box.type) {\n                    case ATOM_MOOV:\n                        moov = parseMoov(box);\n                        break;\n                    case ATOM_SIDX:\n                    case ATOM_MFRA:\n                        break;\n                }\n            }\n\n            if (moov == null) {\n                throw new IOException(\"The provided Mp4 doesn't have the 'moov' box\");\n            }\n\n            tracks = new Mp4Track[moov.trak.length];\n\n            for (i = 0; i < tracks.length; i++) {\n                tracks[i] = new Mp4Track();\n                tracks[i].trak = moov.trak[i];\n\n                if (moov.mvexTrex != null) {\n                    for (final Trex mvexTrex : moov.mvexTrex) {\n                        if (tracks[i].trak.tkhd.trackId == mvexTrex.trackId) {\n                            tracks[i].trex = mvexTrex;\n                        }\n                    }\n                }\n\n                switch (moov.trak[i].mdia.hdlr.subType) {\n                    case HANDLER_VIDE:\n                        tracks[i].kind = TrackKind.Video;\n                        break;\n                    case HANDLER_SOUN:\n                        tracks[i].kind = TrackKind.Audio;\n                        break;\n                    case HANDLER_SUBT:\n                        tracks[i].kind = TrackKind.Subtitles;\n                        break;\n                    default:\n                        tracks[i].kind = TrackKind.Other;\n                        break;\n                }\n            }\n\n            backupBox = box;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "207", "src_id": "M1066", "code": "        private void loadPendingMissions(Context ctx) {\n            File[] subs = mPendingMissionsDir.listFiles();\n            if (subs == null) {\n                Log.e(TAG, \"listFiles() returned null\");\n                return;\n            }\n\n            if (subs.length < 1) {\n                return;\n            }\n\n            if (DEBUG) {\n                Log.d(TAG, \"Loading pending downloads from directory: \" + mPendingMissionsDir.getAbsolutePath());\n            }\n\n            File tempDir = pickAvailableTemporalDir(ctx);\n\n            Log.i(TAG, \"using '\" + tempDir + \"' as temporal directory\");\n\n            for (File sub : subs) {\n                if (sub.isFile()) { \n                    if (sub.getName().equals(\".tmp\"))continue;\n\n                    DownloadMission mis = Utility.readFromFile(sub);\n\n                    if (mis == null || mis.isFinished() || mis.hasInvalidStorage()) {\n                        //noinspection ResultOfMethodCallIgnored\n                        sub.delete();\n                        continue;\n                    }\n\n                    mis.threads = new Thread[0];\n\n                    boolean exists;\n\n                    try {\n                        mis.storage = StoredFileHelper.deserialize(mis.storage, ctx);\n                        exists = !mis.storage.isInvalid() && mis.storage.existsAsFile();\n                    } catch (Exception ex) {\n                            Log.e(TAG, \"Failed to load the file source of \" + mis.storage.toString(), ex);\n                            mis.storage.invalidate();\n                            exists = false;\n                        }\n\n\n                    if (mis.isPsRunning()) {\n                        if (mis.psAlgorithm.worksOnSameFile) {\n                            // Incomplete post-processing results in a corrupted download file\n                            // because the selected algorithm works on the same file to save space.\n                            // the file will be deleted if the storage API\n                            // is Java IO (avoid showing the \"Save as...\" dialog)\n                            if (exists && mis.storage.isDirect() && !mis.storage.delete())\n                                Log.w(TAG, \"Unable to delete incomplete download file: \" + sub.getPath());\n                        }\n\n                        mis.psState = 0;\n                        mis.errCode = DownloadMission.ERROR_POSTPROCESSING_STOPPED;\n                    } else if (!exists) {\n                        tryRecover(mis);\n\n                        // the progress is lost, reset mission state\n                        if (mis.isInitialized())\n                            mis.resetState(true, true, DownloadMission.ERROR_PROGRESS_LOST);\n                    }\n\n\n                    if (mis.psAlgorithm != null) {\n                        mis.psAlgorithm.cleanupTemporalDir();\n                        mis.psAlgorithm.setTemporalDir(tempDir);\n                    }\n\n                    mis.metadata = sub;\n                    mis.maxRetry = mPrefMaxRetry;\n                    mis.mHandler = mHandler;\n                    mMissionsPending.add(mis);\n                } \n            }\n\n            if (mMissionsPending.size() > 1) {\n\n                Collections.sort(mMissionsPending, Comparator.comparingLong(Mission::getTimestamp));\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "208", "src_id": "M1067", "code": "        void startMission(DownloadMission mission) {\n            synchronized (this) {\n                mission.timestamp = System.currentTimeMillis();\n                mission.mHandler = mHandler;\n                mission.maxRetry = mPrefMaxRetry;\n\n                // create metadata file\n                for (; \n                    ;) {\n                    mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n\n                    if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                        try {\n                            if (!mission.metadata.createNewFile()) {\n\n                                throw new RuntimeException(\"Cant create download metadata file\");\n                            }\n                        } catch (IOException e) {\n                                throw new RuntimeException(e);\n                            }\n\n                        break;\n                    }\n\n                    mission.timestamp = System.currentTimeMillis();\n                }\n\n                mSelfMissionsControl = true;\n                mMissionsPending.add(mission);\n                // Before continue, save the metadata in case the internet connection is not available\n                Utility.writeToFile(mission.metadata, mission);\n\n                if (mission.storage == null) {\n                    // noting to do here\n                    mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n\n                    if (mission.errObject != null) {\n\n                        mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                    }\n\n                    return;\n                }\n\n                boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n                if (canDownloadInCurrentNetwork() && start) {\n                    mission.start();\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "95", "src_id": "M1009", "code": "    @Override\n    public String apply(String input) {\n        StringBuilder output = new StringBuilder();\n        String[] lines = input.split(\"\\n\");\n        int continueCount = 0;\n        int lastStartPos = 0;\n        int lastContinueLineNum = -1;\n        int matchCount = 0;\n        for (int lineNum = 0; lineNum < lines.length; ) {\n            String line = null;\n            if (this.trimEnd) {\n                line = StringUtils.stripEnd(lines[lineNum], null);\n            } else {\n                line = lines[lineNum];\n            }\n\n            lineNum++;\n            final boolean match;\n            if (pattern == null) {\n                match = (ignoreCase ? line.toLowerCase() : line).contains(keyword);\n            } else {\n                match = pattern.matcher(line).find();\n            }\n\n            if (invertMatch != match) {\n                matchCount++;\n\n                if (beforeLines > continueCount) {\n                    int n = lastContinueLineNum == -1 ? (beforeLines >= lineNum ? 1 : lineNum - beforeLines): lineNum - beforeLines - continueCount;\n                    if (n >= lastContinueLineNum || lastContinueLineNum == -1) {\n                        StringBuilder beforeSb = new StringBuilder();\n                        for (int i = n; i < lineNum; i++) {\n                            appendLine(beforeSb, i, lines[i - 1]);\n                        }\n\n                        output.insert(lastStartPos, beforeSb);\n                    }\n                } // end handle before lines\n\n\n                lastStartPos = output.length();\n                appendLine(output, lineNum, line);\n\n                if (afterLines > continueCount) {\n                    int last = lineNum + afterLines - continueCount;\n                    if (last > lines.length) {\n                        last = lines.length;\n                    }\n                    for (int i = lineNum; i < last; i++) {\n                        appendLine(output, i + 1, lines[i]);\n                        lineNum++;\n                        continueCount++;\n                        lastStartPos = output.length();\n                    }\n                } // end handle afterLines\n\n\n                continueCount++;\n\n                if (maxCount > 0 && matchCount >= maxCount) {\n                    break;\n                }\n            } else { // not match\n\n                if (continueCount > 0) {\n                    lastContinueLineNum = lineNum - 1;\n                    continueCount = 0;\n                }\n            }\n        }\n\n        final String str = output.toString();\n        return str;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "96", "src_id": "M87", "code": "    private static List<String> readLines(File batchFile) {\n        List<String> list = new ArrayList<String>();\n        BufferedReader br = null;\n        try {\n            br = new BufferedReader(new FileReader(batchFile));\n            for (String line = br.readLine(); \n                line != null; \n                line = br.readLine()) { \n                list.add(line);\n            } \n        } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if (br != null) {\n                    try {\n                        br.close();\n                    } catch (IOException e) {\n                        // ignore\n                        }\n\n                }\n            }\n\n        return list;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "97", "src_id": "M454", "code": "    private void renderObject(Object obj, int deep, int expand, final StringBuilder buf) throws ObjectTooLargeException {\n        if (obj == null) {\n            appendStringBuilder(buf, \"null\");\n        } else {\n            final Class<?> clazz = obj.getClass();\n            final String className = clazz.getSimpleName();\n            // 7ç§åºç¡ç±»å,ç´æ¥è¾åº@ç±»å[å¼]\n            if (Integer.class.isInstance(obj)\n                         || Long.class.isInstance(obj)\n                         || Float.class.isInstance(obj)\n                         || Double.class.isInstance(obj)\n                    //                    || Character.class.isInstance(obj)\n                        || Short.class.isInstance(obj)\n                         || Byte.class.isInstance(obj)\n                         || Boolean.class.isInstance(obj)) {\n                appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n            }// Charè¦ç¹æ®å¤ç,å ä¸ºæä¸å¯è§å­ç¬¦çå ç´ \n            else if (Character.class.isInstance(obj)) {\n                final Character c = (Character) obj;\n                // ASCIIçå¯è§å­ç¬¦\n                if (c >= 32 && c <= 126) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n                }// ASCIIçæ§å¶å­ç¬¦\n                else if (ASCII_MAP.containsKey((byte) c.charValue())) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, ASCII_MAP.get((byte) c.charValue())));\n                }// è¶è¿ASCIIçç¼ç èå´\n                else {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, c));\n                }\n            }// å­ç¬¦ä¸²ç±»ååç¬å¤ç\n            else if (String.class.isInstance(obj)) {\n                appendStringBuilder(buf, \"@\");\n                appendStringBuilder(buf, className);\n                appendStringBuilder(buf, \"[\");\n                for (Character c : ((String) obj).toCharArray()) {\n                    switch (c) {\n                        case '\\n':\n                            appendStringBuilder(buf, \"\\\\n\");\n                            break;\n                        case '\\r':\n                            appendStringBuilder(buf, \"\\\\r\");\n                            break;\n                        default:\n                            appendStringBuilder(buf, c.toString());\n                    }//switch\n\n                }//for\n\n\n                appendStringBuilder(buf, \"]\");\n            }// éåç±»è¾åº\n            else if (Collection.class.isInstance(obj)) {\n                @SuppressWarnings(\"unchecked\") final Collection<Object> collection = (Collection<Object>) obj;\n                // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                if (!isExpand(deep, expand) || collection.isEmpty()) {\n                    appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, collection.isEmpty(), collection.size()));\n                }// å±å¼å±ç¤º\n                else {\n                    appendStringBuilder(buf, format(\"@%s[\", className));\n                    for (Object e : collection) {\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep + 1; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        renderObject(e, deep + 1, expand, buf);\n                        appendStringBuilder(buf, \",\");\n                    }\n\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n\n                    appendStringBuilder(buf, \"]\");\n                }\n            }// Mapç±»è¾åº\n            else if (Map.class.isInstance(obj)) {\n                @SuppressWarnings(\"unchecked\") final Map<Object, Object> map = (Map<Object, Object>) obj;\n                // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                if (!isExpand(deep, expand) || map.isEmpty()) {\n                    appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", className, map.isEmpty(), map.size()));\n                } else {\n                    appendStringBuilder(buf, format(\"@%s[\", className));\n                    for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep + 1; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        renderObject(entry.getKey(), deep + 1, expand, buf);\n                        appendStringBuilder(buf, \":\");\n                        renderObject(entry.getValue(), deep + 1, expand, buf);\n                        appendStringBuilder(buf, \",\");\n                    }\n\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n\n                    appendStringBuilder(buf, \"]\");\n                }\n            }// æ°ç»ç±»è¾åº\n            else if (obj.getClass().isArray()) {\n                final String typeName = obj.getClass().getSimpleName();\n                // int[]\n                if (typeName.equals(\"int[]\")) {\n                    final int[] arrays = (int[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (int e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// long[]\n                else if (typeName.equals(\"long[]\")) {\n                    final long[] arrays = (long[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (long e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// short[]\n                else if (typeName.equals(\"short[]\")) {\n                    final short[] arrays = (short[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (short e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// float[]\n                else if (typeName.equals(\"float[]\")) {\n                    final float[] arrays = (float[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (float e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// double[]\n                else if (typeName.equals(\"double[]\")) {\n                    final double[] arrays = (double[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (double e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// boolean[]\n                else if (typeName.equals(\"boolean[]\")) {\n                    final boolean[] arrays = (boolean[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (boolean e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// char[]\n                else if (typeName.equals(\"char[]\")) {\n                    final char[] arrays = (char[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (char e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// byte[]\n                else if (typeName.equals(\"byte[]\")) {\n                    final byte[] arrays = (byte[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (byte e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }// Object[]\n                else {\n                    final Object[] arrays = (Object[]) obj;\n                    // éæ ¹èç¹æç©ºéååªå±ç¤ºæè¦ä¿¡æ¯\n                    if (!isExpand(deep, expand) || arrays.length == 0) {\n                        appendStringBuilder(buf, format(\"@%s[isEmpty=%s;size=%d]\", typeName, arrays.length == 0, arrays.length));\n                    }// å±å¼å±ç¤º\n                    else {\n                        appendStringBuilder(buf, format(\"@%s[\", className));\n                        for (Object e : arrays) {\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            renderObject(e, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        }\n\n                        appendStringBuilder(buf, \"\\n\");\n                        for (int i = 0; i < deep; i++) {\n                            appendStringBuilder(buf, TAB);\n                        }\n\n                        appendStringBuilder(buf, \"]\");\n                    }\n                }\n\n            }// Throwableè¾åº\n            else if (Throwable.class.isInstance(obj)) {\n                if (!isExpand(deep, expand)) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n                } else {\n                    final Throwable throwable = (Throwable) obj;\n                    final StringWriter sw = new StringWriter();\n                    final PrintWriter pw = new PrintWriter(sw);\n                    throwable.printStackTrace(pw);\n                    appendStringBuilder(buf, sw.toString());\n                }\n            }// Dateè¾åº\n            else if (Date.class.isInstance(obj)) {\n                appendStringBuilder(buf, format(\"@%s[%s]\", className, new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\").format(obj)));\n            } else if (object instanceof Enum<?>) {\n                appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n            }// æ®éObjectè¾åº\n            else {\n                if (!isExpand(deep, expand)) {\n                    appendStringBuilder(buf, format(\"@%s[%s]\", className, obj));\n                } else {\n                    appendStringBuilder(buf, format(\"@%s[\", className));\n                    final List<Field> fields;\n                    Class<?> objClass = obj.getClass();\n                    if (GlobalOptions.printParentFields) {\n                        fields = new ArrayList<Field>();\n                        // å½ç¶ç±»ä¸ºnullçæ¶åè¯´æå°è¾¾äºæä¸å±çç¶ç±»(Objectç±»).\n                        while (objClass != null) {\n                            fields.addAll(Arrays.asList(objClass.getDeclaredFields()));\n                            objClass = objClass.getSuperclass();\n                        }\n                    } else {\n                        fields = new ArrayList<Field>(Arrays.asList(objClass.getDeclaredFields()));\n                    }\n\n                    for (Field field : fields) {\n                        field.setAccessible(true);\n\n                        try {\n                            final Object value = field.get(obj);\n                            appendStringBuilder(buf, \"\\n\");\n                            for (int i = 0; i < deep + 1; i++) {\n                                appendStringBuilder(buf, TAB);\n                            }\n\n                            appendStringBuilder(buf, field.getName());\n                            appendStringBuilder(buf, \"=\");\n                            renderObject(value, deep + 1, expand, buf);\n                            appendStringBuilder(buf, \",\");\n                        } catch (ObjectTooLargeException t) {\n                                buf.append(\"...\");\n                                break;\n                            } catch (Throwable t) {\n                            // ignore\n                            }\n\n                    }//for\n\n\n                    appendStringBuilder(buf, \"\\n\");\n                    for (int i = 0; i < deep; i++) {\n                        appendStringBuilder(buf, TAB);\n                    }\n\n                    appendStringBuilder(buf, \"]\");\n                }\n            }\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "98", "src_id": "M114", "code": "    public boolean isAvailable() {\n        if (isConnected()) {\n            try {\n                if (_socket_.getInetAddress() == null) {\n                    return false;\n                }\n                if (_socket_.getPort() == 0) {\n                    return false;\n                }\n                if (_socket_.getRemoteSocketAddress() == null) {\n                    return false;\n                }\n                if (_socket_.isClosed()) {\n                    return false;\n                }/* these aren't exact checks (a Socket can be half-open),\n                   but since we usually require two-way data transfer,\n                   we check these here too: */\n                if (_socket_.isInputShutdown()) {\n                    return false;\n                }\n                if (_socket_.isOutputShutdown()) {\n                    return false;\n                }\n                /* ignore the result, catch exceptions: */\n                _socket_.getInputStream();\n                _socket_.getOutputStream();\n            } catch (IOException ioex) {\n                    return false;\n                }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "99", "src_id": "M716", "code": "    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n        // æ§è¡å¤±è´¥:è¾åºå¤±è´¥ç¶æ\n        table.row(\"IS-RETURN\", \"\" + false);\n        table.row(\"IS-EXCEPTION\", \"\" + true);\n        // æ§è¡å¤±è´¥:è¾åºå¤±è´¥å¼å¸¸ä¿¡æ¯\n        Throwable cause;\n        Throwable t = (Throwable) throwableVO.getObject();\n        if (t instanceof InvocationTargetException) {\n            cause = t.getCause();\n        } else {\n            cause = t;\n        }\n\n        if (throwableVO.needExpand()) {\n            table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n        } else {\n            StringWriter stringWriter = new StringWriter();\n            PrintWriter printWriter = new PrintWriter(stringWriter);\n            try {\n                cause.printStackTrace(printWriter);\n                table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n            } finally {\n                    printWriter.close();\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "100", "src_id": "M566", "code": "    @Override\n    public void process(final CommandProcess process) {\n        Session session = process.session();\n        timer = new Timer(\"Timer-for-arthas-dashboard-\" + session.getSessionId(), true);\n        // ctrl-C support\n        process.interruptHandler(new DashboardInterruptHandler(process, timer));\n        /*\n         * éè¿handleåè°ï¼å¨suspendåendæ¶åæ­¢timerï¼resumeæ¶éå¯timer\n         */\n\n        Handler<Void> stopHandler = new Handler<Void>() {@Override public void handle(Void event) {stop();}};\n\n        Handler<Void> restartHandler = new Handler<Void>() {@Override public void handle(Void event) {restart(process);}};\n\n        process.suspendHandler(stopHandler);\n        process.resumeHandler(restartHandler);\n        process.endHandler(stopHandler);\n        // q exit support\n        process.stdinHandler(new QExitHandler(process));\n        // start the timer\n        timer.scheduleAtFixedRate(new DashboardTimerTask(process), 0, getInterval());\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "101", "src_id": "M443", "code": "    private String drawField() {\n        final StringBuilder fieldSB = new StringBuilder();\n        final Field[] fields = clazz.getDeclaredFields();\n        if (fields.length > 0) {\n            for (Field field : fields) {\n                final KVView kvView = new KVView(new TableView.ColumnDefine(TableView\n                        .Align\n                        .RIGHT), \n                        new TableView.ColumnDefine(50, \n                        false, TableView.Align\n                        .LEFT))\n                        .add(\"modifier\", StringUtils\n                        .modifier(field.getModifiers(), \n                        ','))\n                        .add(\"type\", StringUtils\n                        .classname(field.getType()))\n                        .add(\"name\", field.getName());\n\n                final StringBuilder annotationSB = new StringBuilder();\n\n                final Annotation[] annotationArray = field.getAnnotations();\n                if (null != annotationArray && annotationArray.length > 0) {\n                    for (Annotation annotation : annotationArray) {\n                        annotationSB.append(StringUtils.classname(annotation.annotationType())).append(\",\");\n                    }\n\n                    if (annotationSB.length() > 0) {\n                        annotationSB.deleteCharAt(annotationSB.length() - 1);\n                    }\n\n                    kvView.add(\"annotation\", annotationSB);\n                }\n\n                if (Modifier.isStatic(field.getModifiers())) {\n                    final boolean isAccessible = field.isAccessible();\n                    try {\n                        field.setAccessible(true);\n                        kvView.add(\"value\", StringUtils.objectToString(field.get(null)));\n                    } catch (IllegalAccessException e) {\n                        //\n                        } finally {\n                            field.setAccessible(isAccessible);\n                        }\n                }//if\n\n\n                fieldSB.append(kvView.draw()).append(\"\\n\");\n            }//for\n\n        }\n\n        return fieldSB.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "102", "src_id": "M270", "code": "    private static String normalizeArch(String value) {\n        value = normalize(value);\n\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64w?|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (\"ia64n\".equals(value)) {\n            return \"itanium_32\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(mips|mips32)$\")) {\n            return \"mips_32\";\n        }\n        if (value.matches(\"^(mipsel|mips32el)$\")) {\n            return \"mipsel_32\";\n        }\n        if (\"mips64\".equals(value)) {\n            return \"mips_64\";\n        }\n        if (\"mips64el\".equals(value)) {\n            return \"mipsel_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (value.matches(\"^(ppcle|ppc32le)$\")) {\n            return \"ppcle_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n\n        return value;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "103", "src_id": "M232", "code": "    public void start() throws Exception {\n        // Configure SSL.\n        final SslContext sslCtx;\n        if (ssl) {\n            SelfSignedCertificate ssc = new SelfSignedCertificate();\n\n            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();\n        } else {\n            sslCtx = null;\n        }\n        ServerBootstrap b = new ServerBootstrap();\n\n        b.group(bossGroup, workerGroup)\n                .channel(NioServerSocketChannel.class)\n                .handler(new LoggingHandler(LogLevel\n                .INFO))\n                .childHandler(new TunnelSocketServerInitializer(this, \n                sslCtx));\n\n        if (StringUtils.isBlank(host)) {\n            channel = b.bind(port).sync().channel();\n        } else {\n            channel = b.bind(host, port).sync().channel();\n        }\n\n        logger.info(\"Tunnel server listen at {}:{}\", host, port);\n        workerGroup.scheduleWithFixedDelay(new Runnable() {@Override public void run() {agentInfoMap\n                        .entrySet()\n                        .removeIf(e -> !e.getValue()\n                        .getChannelHandlerContext()\n                        .channel()\n                        .isActive())\n                        ; clientConnectionInfoMap\n                        .entrySet()\n                        .removeIf(e -> !e.getValue()\n                        .getChannelHandlerContext()\n                        .channel()\n                        .isActive())\n                        ; // æ´æ°éç¾¤keyä¿¡æ¯\n                if (tunnelClusterStore \n                             != null \n                             && clientConnectHost \n                             != null\n                            ) {try {for (Entry<String, AgentInfo> entry : agentInfoMap\n                                    .entrySet()) {tunnelClusterStore\n                                    .addAgent(entry.getKey(), \n                                    new AgentClusterInfo(entry\n                            .getValue(), \n                            clientConnectHost, port), \n                            60 * 60, TimeUnit.SECONDS)\n                            ;}} catch (Throwable t) {logger.error(\"update tunnel info error\", t);}}}}, \n        60, 60, TimeUnit.SECONDS);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "104", "src_id": "M1354", "code": "    public static String nullSafeToString(byte[] array) {\n        if (array == null) {\n            return \"null\";\n        } else {\n            int length = array.length;\n            if (length == 0) {\n                return \"{}\";\n            } else {\n                StringBuilder sb = new StringBuilder(\"{\");\n                for (int i = 0; i < length; ++i) {\n                    if (i > 0) {\n                        sb.append(\", \");\n                    }\n\n                    sb.append(array[i]);\n                }\n\n                sb.append(\"}\");\n                return sb.toString();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "302", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n        String author = pdfMetadata.getAuthor();\n\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "303", "src_id": "M602", "code": "    @Operation(\n    summary = \"Get PDF document properties\",\n    description = \"Returns title, author, subject, etc. Input:PDF Output:JSON Type:SISO\")\n    @PostMapping(value = \"/document-properties\", consumes = \"multipart/form-data\")\n    public Map<String, String> getDocumentProperties(@ModelAttribute PDFFile file) throws IOException {\n        // Load the document in read-only mode to prevent modifications and ensure the integrity of\n        // the original file.\n        try (PDDocument document = pdfDocumentFactory.load(file.getFileInput(), true)) {\n            PDDocumentInformation info = document.getDocumentInformation();\n            Map<String, String> properties = new HashMap<>();\n            properties.put(\"title\", info.getTitle());\n            properties.put(\"author\", info.getAuthor());\n            properties.put(\"subject\", info.getSubject());\n            properties.put(\"keywords\", info.getKeywords());\n            properties.put(\"creator\", info.getCreator());\n            properties.put(\"producer\", info.getProducer());\n            properties.put(\"creationDate\", info.getCreationDate().toString());\n            properties.put(\"modificationDate\", info.getModificationDate().toString());\n            return properties;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "304", "src_id": "M458", "code": "    private void setupTrayIcon(Image icon) {\n        if (!SystemTray.isSupported()) {\n            log.warn(\"System tray is not supported\");\n            return;\n        }\n\n        try {\n            systemTray = SystemTray.getSystemTray();\n            // Create popup menu\n            PopupMenu popup = new PopupMenu();\n            // Create menu items\n            MenuItem showItem = new MenuItem(\"Show\");\n            showItem.addActionListener(e -> { frame.setVisible(true); frame.setState(Frame.NORMAL);});\n\n            MenuItem exitItem = new MenuItem(\"Exit\");\n            exitItem.addActionListener(e -> { cleanup(); System.exit(0);});\n            // Add menu items to popup menu\n            popup.add(showItem);\n            popup.addSeparator();\n            popup.add(exitItem);\n            // Create tray icon\n            trayIcon = new TrayIcon(icon, \"Stirling-PDF\", popup);\n            trayIcon.setImageAutoSize(true);\n            // Add double-click behavior\n            trayIcon.addActionListener(e -> { frame.setVisible(true); frame.setState(Frame.NORMAL);});\n            // Add tray icon to system tray\n            systemTray.add(trayIcon);\n            // Modify frame behavior to minimize to tray\n            frame.addWindowStateListener(new WindowStateListener() {public void windowStateChanged(WindowEvent e) {if (e.getNewState() == Frame.ICONIFIED) { frame.setVisible(false);}}});\n        } catch (AWTException e) {\n                log.error(\"Error setting up system tray icon\", e);\n            }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "305", "src_id": "M477", "code": "    private void handleSplitByDocCount(PDDocument sourceDocument, int documentCount, ZipOutputStream zipOut, String baseFilename) throws IOException {\n        log.debug(\"Starting handleSplitByDocCount with documentCount={}\", documentCount);\n\n        int totalPageCount = sourceDocument.getNumberOfPages();\n        log.debug(\"Total pages in source document: {}\", totalPageCount);\n\n        int pagesPerDocument = totalPageCount / documentCount;\n        int extraPages = totalPageCount % documentCount;\n        log.debug(\"Pages per document: {}, Extra pages: {}\", pagesPerDocument, extraPages);\n\n        int currentPageIndex = 0;\n        int fileIndex = 1;\n        for (int i = 0; i < documentCount; i++) {\n            log.debug(\"Creating document {} of {}\", i + 1, documentCount);\n            PDDocument currentDoc = null;\n            try {\n                currentDoc = pdfDocumentFactory.createNewDocumentBasedOnOldDocument(sourceDocument);\n                log.debug(\"Successfully created document {} of {}\", i + 1, documentCount);\n            } catch (Exception e) {\n                    log.error(\"Error creating document {} of {}\", i + 1, documentCount, e);\n                    throw ExceptionUtils.createFileProcessingException(\"split\", e);\n                }\n\n\n            int pagesToAdd = pagesPerDocument + (i < extraPages ? 1 : 0);\n            log.debug(\"Adding {} pages to document {}\", pagesToAdd, i + 1);\n            for (int j = 0; j < pagesToAdd; j++) {\n                try {\n                    log.debug(\"Adding page {} (index {}) to document {}\", j + 1, currentPageIndex, i + 1);\n                    currentDoc.addPage(sourceDocument.getPage(currentPageIndex));\n                    log.debug(\"Successfully added page {} to document {}\", j + 1, i + 1);\n                    currentPageIndex++;\n                } catch (Exception e) {\n                        log.error(\"Error adding page {} to document {}\", j + 1, i + 1, e);\n                        throw ExceptionUtils.createFileProcessingException(\"split\", e);\n                    }\n\n            }\n\n            try {\n                log.debug(\"Saving document {} with {} pages\", i + 1, pagesToAdd);\n                saveDocumentToZip(currentDoc, zipOut, baseFilename, fileIndex++);\n                log.debug(\"Successfully saved document {}\", i + 1);\n            } catch (Exception e) {\n                    log.error(\"Error saving document {}\", i + 1, e);\n                    throw e;\n                }\n\n        }\n\n        log.debug(\"Completed handleSplitByDocCount with {} documents created\", documentCount);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "306", "src_id": "M577", "code": "    private void processWithTesseract(List<String> selectedLanguages, String ocrType, Path tempInputFile, Path tempOutputFile) throws IOException, InterruptedException {\n\n        // Create temp directory for Tesseract processing\n        try (TempDirectory tempDir = new TempDirectory(tempFileManager)) {\n            File tempOutputDir = new File(tempDir.getPath().toFile(), \"output\");\n            File tempImagesDir = new File(tempDir.getPath().toFile(), \"images\");\n            File finalOutputFile = new File(tempDir.getPath().toFile(), \"final_output.pdf\");\n            // Create directories\n            tempOutputDir.mkdirs();\n            tempImagesDir.mkdirs();\n            PDFMergerUtility merger = new PDFMergerUtility();\n            merger.setDestinationFileName(finalOutputFile.toString());\n\n            try (PDDocument document = pdfDocumentFactory.load(tempInputFile.toFile())) {\n                PDFRenderer pdfRenderer = new PDFRenderer(document);\n                int pageCount = document.getNumberOfPages();\n                for (int pageNum = 0; pageNum < pageCount; pageNum++) {\n\n                    PDPage page = document.getPage(pageNum);\n                    boolean hasText = false;\n\n                    // Check for existing text\n                    try (PDDocument tempDoc = new PDDocument()) {\n                        tempDoc.addPage(page);\n                        PDFTextStripper stripper = new PDFTextStripper();\n                        hasText = !stripper.getText(tempDoc).trim().isEmpty();\n                    }\n\n                    boolean shouldOcr = switch (ocrType) {case \"skip-text\" -> !hasText;case \"force-ocr\" -> true;default -> true;};\n                    File pageOutputPath = new File(tempOutputDir, String.format(\"page_%d.pdf\", pageNum));\n\n                    if (!shouldOcr) {\n                        // Save original page without OCR\n                        try (PDDocument pageDoc = new PDDocument()) {\n                            pageDoc.addPage(page);\n                            pageDoc.save(pageOutputPath);\n                            merger.addSource(pageOutputPath);\n                        }\n                    } else {\n                        // Convert page to image\n                        BufferedImage image = pdfRenderer.renderImageWithDPI(pageNum, 300);\n                        File imagePath = new File(tempImagesDir, String.format(\"page_%d.png\", pageNum));\n                        ImageIO.write(image, \"png\", imagePath);\n                        // Build OCR command\n                        List<String> command = new ArrayList<>();\n                        command.add(\"tesseract\");\n                        command.add(imagePath.toString());\n                        command.add(new File(tempOutputDir, String.format(\"page_%d\", pageNum)).toString());\n                        command.add(\"-l\");\n                        command.add(String.join(\"+\", selectedLanguages));\n                        command.add(\"pdf\"); // Always output PDF\n\n\n                        ProcessExecutorResult result = ProcessExecutor.getInstance(ProcessExecutor.Processes.TESSERACT).runCommandWithOutputHandling(command);\n\n                        if (result.getRc() != 0) {\n                            throw ExceptionUtils.createRuntimeException(\"error.commandFailed\", \"{0} command failed with exit code: {1}\", null, \"Tesseract\", result.getRc());\n                        }\n\n                        // Add OCR'd PDF to merger\n                        merger.addSource(pageOutputPath);\n                    } \n                }\n            }\n\n            // Merge all pages into final PDF\n            merger.mergeDocuments(null);\n            // Copy final output to the expected location\n            Files.copy(finalOutputFile.toPath(), tempOutputFile, java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "307", "src_id": "M522", "code": "    @PostMapping(value = \"/auto-split-pdf\", consumes = \"multipart/form-data\")\n    @Operation(\n    summary = \"Auto split PDF pages into separate documents\",\n    description = \n    \"This endpoint accepts a PDF file, scans each page for a specific QR code, and\"\n    + \" splits the document at the QR code boundaries. The output is a zip file\"\n    + \" containing each separate PDF document. Input:PDF Output:ZIP-PDF\"\n    + \" Type:SISO\")\n    public ResponseEntity<byte[]> autoSplitPdf(@ModelAttribute AutoSplitPdfRequest request) throws IOException {\n\n        MultipartFile file = request.getFileInput();\n        boolean duplexMode = Boolean.TRUE.equals(request.getDuplexMode());\n        PDDocument document = null;\n        List<PDDocument> splitDocuments = new ArrayList<>();\n        Path zipFile = null;\n        byte[] data = null;\n        try {\n            document = pdfDocumentFactory.load(file.getInputStream());\n\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pdfRenderer.setSubsamplingAllowed(true);\n            for (int page = 0; page < document.getNumberOfPages(); ++page) {\n                BufferedImage bim = pdfRenderer.renderImageWithDPI(page, 150);\n                String result = decodeQRCode(bim);\n                boolean isValidQrCode = VALID_QR_CONTENTS.contains(result);\n                log.debug(\"detected qr code {}, code is vale={}\", result, isValidQrCode);\n                if (isValidQrCode && page != 0) {\n                    splitDocuments.add(new PDDocument());\n                }\n\n                if (!splitDocuments.isEmpty() && !isValidQrCode) {\n                    splitDocuments.get(splitDocuments.size() - 1).addPage(document.getPage(page));\n                } else if (page == 0) {\n\n                    PDDocument firstDocument = new PDDocument();\n                    firstDocument.addPage(document.getPage(page));\n                    splitDocuments.add(firstDocument);\n                }\n\n\n                // If duplexMode is true and current page is a divider, then skip next page\n                if (duplexMode && isValidQrCode) {\n                    page++;\n                }\n            }\n\n            // Remove split documents that have no pages\n            splitDocuments.removeIf(pdDocument -> pdDocument.getNumberOfPages() == 0);\n            zipFile = Files.createTempFile(\"split_documents\", \".zip\");\n\n            String filename = Filenames.toSimpleFileName(file.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\");\n\n            try (ZipOutputStream zipOut = new ZipOutputStream(Files.newOutputStream(zipFile))) {\n                for (int i = 0; i < splitDocuments.size(); i++) {\n\n                    String fileName = filename + \"_\" + (i + 1) + \".pdf\";\n                    PDDocument splitDocument = splitDocuments.get(i);\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    splitDocument.save(baos);\n                    byte[] pdf = baos.toByteArray();\n                    ZipEntry pdfEntry = new ZipEntry(fileName);\n                    zipOut.putNextEntry(pdfEntry);\n                    zipOut.write(pdf);\n                    zipOut.closeEntry();\n                }\n            }\n\n            data = Files.readAllBytes(zipFile);\n            return WebResponseUtils.bytesToWebResponse(data, filename + \".zip\", MediaType.APPLICATION_OCTET_STREAM);\n        } catch (Exception e) {\n                log.error(\"Error in auto split\", e);\n                throw e;\n            } finally {\n                // Clean up resources\n                if (document != null) {\n                    try {\n                        document.close();\n                    } catch (IOException e) {\n                            log.error(\"Error closing main PDDocument\", e);\n                        }\n\n                }\n\n                for (PDDocument splitDoc : splitDocuments) {\n                    try {\n                        splitDoc.close();\n                    } catch (IOException e) {\n                            log.error(\"Error closing split PDDocument\", e);\n                        }\n\n                }\n                if (zipFile != null) {\n                    try {\n                        Files.deleteIfExists(zipFile);\n                    } catch (IOException e) {\n                            log.error(\"Error deleting temporary zip file\", e);\n                        }\n\n                }\n            }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "308", "src_id": "M443", "code": "    private void checkAndRefreshExplorer() {\n        if (!IS_WINDOWS) {\n            return;\n        }\n\n        if (timeAt90Percent == -1) {\n            timeAt90Percent = System.currentTimeMillis();\n            stuckTimer = new Timer(1000, e -> {long currentTime = System\n                        .currentTimeMillis();if (currentTime \n                            -timeAt90Percent \n                            > stuckThreshold\n                            ) {try { log.debug(\"Attempting Windows explorer refresh due to 90% stuck state\")\n                                ; String currentDir = System.getProperty(\"user.dir\"); // Store current explorer PIDs before we start new one\n                        Set<String> existingPids = new HashSet<>(); ProcessBuilder listExplorer = new ProcessBuilder(\"cmd\",\n                                \"/c\", \"wmic\", \"process\", \"where\",\n                                \"name='explorer.exe'\", \"get\", \"ProcessId\",\n                                \"/format:csv\"); Process process = listExplorer\n                                .start(); BufferedReader reader = new BufferedReader(new InputStreamReader(process\n                        .getInputStream())); String line;while ((line = BoundedLineReader.readLine(reader, 5_000_000)) != null) {if (line.matches(\".*\\\\d+.*\")) { // Contains numbers\n                                    String[] parts = line.trim().split(\",\");if (parts.length >= 2) { existingPids.add(parts[parts.length - 1].trim());}}}process.waitFor(2, TimeUnit.SECONDS); // Start new explorer\n                        ProcessBuilder pb = new ProcessBuilder(\"cmd\", \"/c\", \"start\", \"/min\", \"/b\", \"explorer.exe\", currentDir); pb.redirectErrorStream(true); explorerProcess = pb.start(); // Schedule cleanup\n                        Timer cleanupTimer = new Timer(2000, cleanup -> {try { // Find new explorer processes\n                                ProcessBuilder findNewExplorer = new ProcessBuilder(\"cmd\", \"/c\", \"wmic\", \"process\", \"where\", \"name='explorer.exe'\", \"get\", \"ProcessId\", \"/format:csv\"); Process newProcess = findNewExplorer.start(); BufferedReader newReader = new BufferedReader(new InputStreamReader(newProcess.getInputStream())); String newLine;while ((newLine = BoundedLineReader.readLine(newReader, 5_000_000)) != null) {if (newLine.matches(\".*\\\\d+.*\")) { String[] parts = newLine.trim().split(\",\");if (parts.length >= 2) { String pid = parts[parts.length - 1].trim();if (!existingPids.contains(pid)) { log.debug(\"Found new explorer.exe with PID: \" + pid); ProcessBuilder killProcess = new ProcessBuilder(\"taskkill\", \"/PID\", pid, \"/F\"); killProcess.redirectErrorStream(true); Process killResult = killProcess.start(); killResult.waitFor(2, TimeUnit.SECONDS); log.debug(\"Explorer process terminated: \" + pid);}}}}newProcess.waitFor(2, TimeUnit.SECONDS);} catch (Exception ex) { log.error(\"Error cleaning up Windows explorer process\", ex);}}); cleanupTimer.setRepeats(false); cleanupTimer.start(); stuckTimer.stop();} catch (Exception ex) { log.error(\"Error refreshing Windows explorer\", ex);}}});\n            stuckTimer.setRepeats(true);\n            stuckTimer.start();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "309", "src_id": "M408", "code": "    private static Path unzipAndGetMainHtml(byte[] fileBytes) throws IOException {\n        Path tempDirectory = Files.createTempDirectory(\"unzipped_\");\n        try (ZipInputStream zipIn = \n            ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(fileBytes))) {\n            for (ZipEntry entry = zipIn.getNextEntry(); \n                entry != null; \n                entry = zipIn.getNextEntry()) { \n                Path filePath = tempDirectory.resolve(sanitizeZipFilename(entry.getName()));\n\n                if (entry.isDirectory()) \n                {\n                    Files.createDirectories(filePath); // Explicitly create the directory structure\n\n                } else {\n                    Files.createDirectories(filePath.getParent()); // Create parent directories if they don't exist\n\n                    Files.copy(zipIn, filePath);\n                }\n\n                zipIn.closeEntry();\n            } \n        }\n\n        // Search for the main HTML file.\n        try (Stream<Path> walk = Files.walk(tempDirectory)) {\n            List<Path> htmlFiles = walk.filter(file -> file.toString().endsWith(\".html\")).toList();\n\n            if (htmlFiles.isEmpty()) {\n                throw new IOException(\"No HTML files found in the unzipped directory.\");\n            }\n\n            // Prioritize 'index.html' if it exists, otherwise use the first .html file\n            for (Path htmlFile : htmlFiles) {\n                if (\"index.html\".equals(htmlFile.getFileName().toString())) {\n                    return htmlFile;\n                }\n            }\n\n            return htmlFiles.get(0);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "310", "src_id": "M197", "code": "    @Scheduled(\n    fixedDelayString = \n    \"#{applicationProperties.system.tempFileManagement.cleanupIntervalMinutes}\",\n    timeUnit = TimeUnit.MINUTES)\n    public void scheduledCleanup() {\n        log.info(\"Running scheduled temporary file cleanup\");\n\n        long maxAgeMillis = tempFileManager.getMaxAgeMillis();\n        // Clean up registered temp files (managed by TempFileRegistry)\n        int registeredDeletedCount = tempFileManager.cleanupOldTempFiles(maxAgeMillis);\n        log.info(\"Cleaned up {} registered temporary files\", registeredDeletedCount);\n\n        // Clean up registered temp directories\n        int directoriesDeletedCount = 0;\n        for (Path directory : registry.getTempDirectories()) {\n            try {\n                if (Files.exists(directory)) {\n                    GeneralUtils.deleteDirectory(directory);\n                    directoriesDeletedCount++;\n                    log.debug(\"Cleaned up temporary directory: {}\", directory);\n                }\n            } catch (IOException e) {\n                    log.warn(\"Failed to clean up temporary directory: {}\", directory, e);\n                }\n\n        }\n\n        // Clean up PDFBox cache file\n        cleanupPDFBoxCache();\n        // Clean up unregistered temp files based on our cleanup strategy\n        boolean containerMode = isContainerMode();\n        int unregisteredDeletedCount = cleanupUnregisteredFiles(containerMode, true, maxAgeMillis);\n\n        if (registeredDeletedCount > 0 || unregisteredDeletedCount > 0 || directoriesDeletedCount > 0) {\n            log.info(\"Scheduled cleanup complete. Deleted {} registered files, {} unregistered files, {} directories\",\n                    registeredDeletedCount, unregisteredDeletedCount,\n                    directoriesDeletedCount);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "311", "src_id": "M102", "code": "    @Override\n    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {\n\n        String uri = request.getRequestURI();\n        String contextPath = request.getContextPath();\n\n\n        String[] permitAllPatterns = { contextPath \n                 + \"/login\", contextPath + \"/register\", contextPath \n                 + \"/error\", contextPath + \"/images/\", contextPath \n                 + \"/public/\", contextPath + \"/css/\", contextPath \n                 + \"/fonts/\", contextPath + \"/js/\", contextPath \n                 + \"/pdfjs/\", contextPath + \"/pdfjs-legacy/\", contextPath \n                 + \"/api/v1/info/status\", contextPath \n                 + \"/site.webmanifest\" };\n        for (String pattern : permitAllPatterns) {\n            if (uri.startsWith(pattern) || uri.endsWith(\".svg\") || uri.endsWith(\".png\")) {\n                return true;\n            }\n\n            if (uri.endsWith(\".ico\")) {\n            return true;\n                }\n            }\n\n        return false;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}

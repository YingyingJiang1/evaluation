{"project_name": "jedis", "pair_id": "121", "src_id": "M580", "code": "@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {    \n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "122", "src_id": "M237", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (null == o || getClass() != o.getClass()) {\n        return false;\n    }\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration) \n    && Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "123", "src_id": "M227", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (null == o || getClass() != o.getClass()) {\n        return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "124", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n    try {\n        byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n        byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n        Token newToken = pendingTokenRef.getAndSet(token);\n        if (null == newToken) {\n            commandSync.lock();\n            try {\n                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n                resultHandler.add(this.authResultHandler);\n            } finally {\n                pendingTokenRef.set(null);\n                commandSync.unlock();\n            }\n        }\n    } catch (Exception e) {\n        logger.error(\"Error while re-authenticating connection\", e);\n        client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "125", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n        this.listener = listener;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "126", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n        onPong(null);\n    } else {\n        onPong(encode(resp));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "127", "src_id": "M581", "code": "@Override\npublic List<String> hgetdel(String key, String... fields) {    \n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "1", "src_id": "M127", "code": "private void build() {\n    // check build state to prevent recursion\n    if (building) return;    \n\n\n    building = true;\n    try {\n        if (data != null) {\n            if (data instanceof JedisDataException) {\n                exception = (JedisDataException) data;\n            } else {\n                response = builder.build(data);\n            }\n        }\n\n        data = null;\n    } finally {\n        building = false;\n        built = true;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "2", "src_id": "M1184", "code": "@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "3", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n    return new HostAndPort(host, port);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "4", "src_id": "M1154", "code": "public String getElement() {\n    if (null != element) {\n        return SafeEncoder.encode(element);\n    } else {\n        return null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "5", "src_id": "M937", "code": "@Override\npublic boolean equals(Object o) {\n    if (o == null) return false;    \n\n    if (o == this) return true;    \n\n    if (!(o instanceof GeoCoordinate)) return false;    \n\n\n    GeoCoordinate that = (GeoCoordinate) o;\n\n    if (Double.compare(that.longitude, longitude) != 0) return false;    \n\n    return Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "6", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "7", "src_id": "M127", "code": "private void build() {\n        // check build state to prevent recursion\n        if (building) return;    \n\n\n        building = true;\n        try {\n                if (data != null) {\n                        if (data instanceof JedisDataException) {\n                                exception = (JedisDataException) data;\n                        } else {\n                                response = builder.build(data);\n                        }\n                }\n\n                data = null;\n        } finally {\n                building = false;\n                built = true;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "8", "src_id": "M1184", "code": "@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n        ensureFill();\n\n        final int length = Math.min(limit - count, len);\n        System.arraycopy(buf, count, b, off, length);\n        count += length;\n        return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "9", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(\nList<String> getMasterAddrByNameResult) {\n        String host = getMasterAddrByNameResult.get(0);\n        int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n        return new HostAndPort(host, port);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "10", "src_id": "M1154", "code": "public String getElement() {\n        if (null != element) {\n                return SafeEncoder.encode(element);\n        } else {\n                return null;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "11", "src_id": "M937", "code": "@Override\npublic boolean equals(Object o) {\n        if (o == null) return false;    \n\n        if (o == this) return true;    \n\n        if (!(o instanceof GeoCoordinate)) return false;    \n\n\n        GeoCoordinate that = (GeoCoordinate) o;\n\n        if (Double.compare(that.longitude, longitude) != 0) return false;    \n\n        return Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "12", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n        flush();\n        return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "62", "src_id": "M107", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    if (!(list.get(0) instanceof KeyValue)) {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n\n        for (Object anObj : list) {\n\n            List<Object> streamObj = (List<Object>) anObj;\n\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n            result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n\n    }    else {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n    } \n\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "63", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(byte[] groupName, \nbyte[] consumer, \nXReadGroupParams xReadGroupParams,            Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "64", "src_id": "M1172", "code": "@Override\npublic boolean equals(Object other) {\n    if (other == null) {\n        return false;\n    }\n    if (other == this) {\n        return true;\n    }\n    if (!(other instanceof ByteArrayWrapper)) {\n        return false;\n    }\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "65", "src_id": "M154", "code": "@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\nXReadParams xReadParams,      Map<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "66", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "67", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "68", "src_id": "M152", "code": "@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, \nbyte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "188", "src_id": "M1177", "code": "public static void closeQuietly(AutoCloseable resource) {\n        // It's same thing as Apache Commons - IOUtils.closeQuietly()\n        if (resource != null) {\n                try {\n                        resource.close();\n                } catch (Exception e) {\n                // ignored\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "189", "src_id": "M620", "code": "@Override\npublic Set<String> sinter(final String... keys) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.sinter(keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "190", "src_id": "M50", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<byte[], byte[]> build(Object data) {\n        final List<Object> list = (List<Object>) data;\n        if (list.isEmpty()) return Collections.emptyMap();      \n\n        if (!(list.get(0) instanceof KeyValue)) {\n                final Map<byte[], byte[]> map = new JedisByteHashMap();\n                final Iterator iterator = list.iterator();\n                while (iterator.hasNext()) map.put(BINARY.build(iterator\n                        .next()), BINARY.build(iterator\n                        .next()));\n\n                return map;\n        }    else {\n                final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n                final Iterator iterator = list.iterator();\n                while (iterator.hasNext()) {\n                        KeyValue kv = (KeyValue) iterator\n                        .next();\n                        map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n                }\n                return map;\n        } \n\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "191", "src_id": "M933", "code": "@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n        Builder builder = builder();\n        builder.protocol(copy.getRedisProtocol());\n        builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n        builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n        builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n        Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n\n        if (credentialsProvider != null) {\n                builder.credentialsProvider(credentialsProvider);\n        } else {\n                builder.user(copy.getUser());\n                builder.password(copy.getPassword());\n        }\n        builder.database(copy.getDatabase());\n        builder.clientName(copy.getClientName());\n        builder.ssl(copy.isSsl());\n        builder.sslSocketFactory(copy.getSslSocketFactory());\n        builder.sslParameters(copy.getSslParameters());\n        builder.hostnameVerifier(copy.getHostnameVerifier());\n        builder.sslOptions(copy.getSslOptions());\n        builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n        builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n        if (copy.isReadOnlyForRedisClusterReplicas()) builder.readOnlyForRedisClusterReplicas();    \n\n\n        builder.authXManager(copy.getAuthXManager());\n\n        return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "192", "src_id": "M1146", "code": "private <T> T doExecuteCommand(\nCommandObject<T> commandObject, \nboolean toReplica) {\n        Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n        JedisRedirectionException redirect = null;\n        int consecutiveConnectionFailures = 0;\n        Exception lastException = null;\n        for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n                Connection connection = null;\n                try {\n                        if (redirect == null) { \n                                connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                                : provider.getConnection(commandObject.getArguments());\n                                return execute(connection, commandObject);\n                                } else { \n\n                                connection = provider.getConnection(redirect.getTargetNode());\n\n                                if (redirect instanceof JedisAskDataException) connection.executeCommand(Protocol.Command.ASKING);          \n\n                                return execute(connection, commandObject);\n\n                                } \n                } catch (JedisClusterOperationException jnrcne) {\n                        throw jnrcne;\n                } catch (JedisConnectionException jce) {\n                        lastException = jce;\n                        ++consecutiveConnectionFailures;\n                        log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n                        // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n                        boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n                        if (reset) {\n                                consecutiveConnectionFailures = 0;\n                                redirect = null;\n                        }\n                } catch (JedisRedirectionException jre) {\n                        // avoid updating lastException if it is a connection exception\n                        if (lastException == null || lastException instanceof JedisRedirectionException) lastException = jre;        \n\n                        log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n                        consecutiveConnectionFailures = 0;\n                        redirect = jre;\n                        // if MOVED redirection occurred,\n                        if (jre instanceof JedisMovedDataException) provider.renewSlotCache(connection);        \n\n                } finally {\n                        IOUtils.closeQuietly(connection);\n                }\n                if (Instant.now().isAfter(deadline)) throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);      \n\n        }\n\n        JedisClusterOperationException maxAttemptsException\n        = new JedisClusterOperationException(\"No more cluster attempts left.\");\n        maxAttemptsException.addSuppressed(lastException);\n        throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "193", "src_id": "M884", "code": "@Override\npublic void addParams(CommandArguments args) {\n\n        if (filters == null) throw new IllegalArgumentException(\"FILTER arguments must be set.\");    \n\n\n        if (fromTimestamp == null) {\n                args.add(MINUS);\n        } else {\n                args.add(toByteArray(fromTimestamp));\n        }\n\n        if (toTimestamp == null) {\n                args.add(PLUS);\n        } else {\n                args.add(toByteArray(toTimestamp));\n        }\n\n        if (latest) args.add(LATEST);    \n\n\n        if (filterByTimestamps != null) {\n                args.add(FILTER_BY_TS);\n                for (long ts : filterByTimestamps) args.add(toByteArray(ts));      \n\n        }\n\n        if (filterByValues != null) {\n                args.add(FILTER_BY_VALUE);\n                for (double value : filterByValues) args.add(toByteArray(value));      \n\n        }\n\n        if (withLabels) {\n                args.add(WITHLABELS);\n        } else {\n                if (selectedLabels != null) {\n                        args.add(SELECTED_LABELS);\n                        for (String label : selectedLabels) args.add(label);      \n\n                }\n        }\n\n        if (count != null) args.add(COUNT).add(toByteArray(count));    \n\n\n        if (aggregationType != null) {\n\n                if (align != null) args.add(ALIGN).add(align);      \n\n\n                args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n                if (bucketTimestamp != null) args.add(BUCKETTIMESTAMP).add(bucketTimestamp);      \n\n\n                if (empty) args.add(EMPTY);      \n\n        }\n\n        args.add(FILTER);\n        for (String filter : filters) args.add(filter);    \n\n\n        if (groupByLabel != null && groupByReduce != null) args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);    \n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "194", "src_id": "M502", "code": "@Deprecated\n@Override\npublic List<Object> xread(\nXReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "195", "src_id": "M416", "code": "@Override\npublic List<byte[]> aclLogBinary() {\n        checkIsInMultiOrPipeline();\n        connection.sendCommand(ACL, LOG);\n        return connection.getBinaryMultiBulkReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "196", "src_id": "M390", "code": "@Override\npublic Long objectFreq(final byte[] key) {\n        connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n        return connection.getIntegerReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "197", "src_id": "M231", "code": "public GeoRadiusStoreParam storeDist(String key) {\n        if (key != null) {\n                this.storeDist = true;\n                this.key = key;\n        }\n        return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "128", "src_id": "M107", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n    if (null == data) {\n        return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    if (!(list.get(0) instanceof KeyValue)) {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n        for (Object anObj : list) {\n            List<Object> streamObj = (List<Object>) anObj;\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n            result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n    }    else {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n    } \n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "129", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(byte[] groupName, \nbyte[] consumer, \nXReadGroupParams xReadGroupParams,            Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "130", "src_id": "M1172", "code": "@Override\npublic boolean equals(Object other) {\n    if (null == other) {\n        return false;\n    }\n    if (other == this) {\n        return true;\n    }\n    if (!(other instanceof ByteArrayWrapper)) {\n        return false;\n    }\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "131", "src_id": "M154", "code": "@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\nXReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "132", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "133", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "134", "src_id": "M152", "code": "@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, \nbyte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "69", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n        sb.append(\"(\");\n    }\n    if (n==Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n    } else {\n        if (n==Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n        } else {\n            sb.append(n);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "70", "src_id": "M1292", "code": "@Override\npublic String toString() {\n    StringBuilder sb=new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "71", "src_id": "M1290", "code": "@Override\npublic String toString(Parenthesize parenMode) {\n    StringBuilder sb=new StringBuilder();\n    StringJoiner sj=new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n    }\n    for (Node n : children) {\n        sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "13", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) sb.append(\"(\");    \n\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n    } else {\n        if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n        } else {\n            sb.append(n);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "14", "src_id": "M1292", "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "15", "src_id": "M1290", "code": "@Override\npublic String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) sb.append('(');    \n\n    for (Node n : children) sj.add(n.toString(parenMode));    \n\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) sb.append(')');    \n\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "198", "src_id": "M777", "code": "@Override\npublic List<Map<String, Object>> clusterLinks() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n    return connection.getObjectMultiBulkReply().stream()\n    .map(BuilderFactory.ENCODED_OBJECT_MAP::build).collect(Collectors.toList());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "199", "src_id": "M779", "code": "@Override\npublic String clusterDelSlotsRange(int... ranges) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER,\n    joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));\n    return connection.getStatusCodeReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "200", "src_id": "M818", "code": "@Override\npublic Map<String, Object> memoryStats() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(MEMORY, STATS);\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "135", "src_id": "M233", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "136", "src_id": "M1104", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "137", "src_id": "M260", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change && existence == that.existence && comparison == that.comparison;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "138", "src_id": "M234", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "139", "src_id": "M256", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "140", "src_id": "M238", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "141", "src_id": "M229", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "72", "src_id": "M890", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;    \n\n    if (o == null || getClass() != o.getClass()) return false;    \n\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "73", "src_id": "M903", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;    \n\n    if (o == null || getClass() != o.getClass()) return false;    \n\n\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && \n    Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "74", "src_id": "M907", "code": "@Override\npublic int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "201", "src_id": "M580", "code": "@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {    \n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "202", "src_id": "M237", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration) \n    && Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "203", "src_id": "M227", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "204", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n    try {\n        byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n        byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n        Token newToken = pendingTokenRef.getAndSet(token);\n        if (newToken == null) {\n            commandSync.lock();\n            try {\n                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n                resultHandler.add(this.authResultHandler);\n            } finally {\n                pendingTokenRef.set(null);\n                commandSync.unlock();\n            }\n        }\n    } catch (Exception e) {\n        logger.error(\"Error while re-authenticating connection\", e);\n        client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "205", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n        this.listener = listener;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "206", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n        onPong(null);\n    } else {\n        onPong(encode(resp));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "207", "src_id": "M581", "code": "@Override\npublic List<String> hgetdel(String key, String... fields) {    \n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "16", "src_id": "M284", "code": "@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "17", "src_id": "M792", "code": "@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "18", "src_id": "M727", "code": "@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "19", "src_id": "M728", "code": "@Override\npublic List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "20", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "21", "src_id": "M732", "code": "@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "22", "src_id": "M712", "code": "@Override\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "23", "src_id": "M551", "code": "@Override\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "24", "src_id": "M844", "code": "@Override\npublic List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "25", "src_id": "M298", "code": "@Override\npublic long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "75", "src_id": "M127", "code": "private void build() {\n    // check build state to prevent recursion\n    if (building) {\n        return;\n    }\n\n    building = true;\n    try {\n        if (data != null) {\n            if (data instanceof JedisDataException) {\n                exception = (JedisDataException) data;\n            } else {\n                response = builder.build(data);\n            }\n        }\n\n        data = null;\n    } finally {\n        building = false;\n        built = true;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "76", "src_id": "M1184", "code": "@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "77", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n    return new HostAndPort(host, port);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "78", "src_id": "M1154", "code": "public String getElement() {\n    if (null != element) {\n        return SafeEncoder.encode(element);\n    } else {\n        return null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "79", "src_id": "M937", "code": "@Override\npublic boolean equals(Object o) {\n    if (o == null) {\n        return false;\n    }\n    if (o == this) {\n        return true;\n    }\n    if (!(o instanceof GeoCoordinate)) {\n        return false;\n    }\n\n    GeoCoordinate that = (GeoCoordinate) o;\n\n    if (Double.compare(that.longitude, longitude) != 0) {\n        return false;\n    }\n    return Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "80", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "208", "src_id": "M890", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (null == o || getClass() != o.getClass()) {\n        return false;\n    }\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    0 == Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "209", "src_id": "M903", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (null == o || getClass() != o.getClass()) {\n        return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    0 == Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && \n    Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "210", "src_id": "M907", "code": "@Override\npublic int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "26", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n        sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n    } else {\n        if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n        } else {\n            sb.append(n);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "27", "src_id": "M1292", "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "28", "src_id": "M1290", "code": "@Override\npublic String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n    }\n    for (Node n : children) {\n        sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "81", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) sb.append(\"(\");    \n\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n    } else {\n        if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n        } else {\n            sb.append(n);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "82", "src_id": "M1292", "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "83", "src_id": "M1290", "code": "@Override\npublic String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) sb.append('(');    \n\n    for (Node n : children) sj.add(n.toString(parenMode));    \n\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) sb.append(')');    \n\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "211", "src_id": "M580", "code": "@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {    \n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "212", "src_id": "M237", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    BaseSetExParams setParams = (BaseSetExParams) o;\n    return Objects.equals(expiration, setParams.expiration) \n    && Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "213", "src_id": "M227", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    HSetExParams setParams = (HSetExParams) o;\n    return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "214", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n    try {\n        byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n        byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n        Token newToken = pendingTokenRef.getAndSet(token);\n        if (newToken == null) {\n            commandSync.lock();\n            try {\n                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n                resultHandler.add(this.authResultHandler);\n            } finally {\n                pendingTokenRef.set(null);\n                commandSync.unlock();\n            }\n        }\n    } catch (Exception e) {\n        logger.error(\"Error while re-authenticating connection\", e);\n        client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "215", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n    if (listener != null) {\n        this.listener = listener;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "216", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n    byte[] resp = (byte[]) reply;\n    if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n        onPong(null);\n    } else {\n        onPong(encode(resp));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "217", "src_id": "M581", "code": "@Override\npublic List<String> hgetdel(String key, String... fields) {    \n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "29", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n        sb.append(\"(\");\n    }\n    if (n != Double.NEGATIVE_INFINITY) {\n        if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n        } else {\n            sb.append(n);\n        }\n    } else {\n        sb.append(\"-inf\");\n    } \n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "30", "src_id": "M1292", "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "31", "src_id": "M1290", "code": "@Override\npublic String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n    }\n    for (Node n : children) {\n        sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "84", "src_id": "M284", "code": "@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "85", "src_id": "M792", "code": "@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "86", "src_id": "M727", "code": "@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "87", "src_id": "M728", "code": "@Override\npublic List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "88", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "89", "src_id": "M732", "code": "@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "90", "src_id": "M712", "code": "@Override\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "91", "src_id": "M551", "code": "@Override\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "92", "src_id": "M844", "code": "@Override\npublic List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "93", "src_id": "M298", "code": "@Override\npublic long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "142", "src_id": "M1177", "code": "public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource != null) {\n        try {\n            resource.close();\n        } catch (Exception e) {\n        // ignored\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "143", "src_id": "M620", "code": "@Override\npublic Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "144", "src_id": "M50", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<byte[], byte[]> build(Object data) {\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) {\n        return Collections.emptyMap();\n    }\n    if (list.get(0) instanceof KeyValue) {\n        final Map<byte[], byte[]> map = new JedisByteHashMap();\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n        }\n        return map;\n    }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "145", "src_id": "M933", "code": "@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n\n    if (credentialsProvider == null) {\n        builder.user(copy.getUser());\n        builder.password(copy.getPassword());\n    }    else {\n        builder.credentialsProvider(credentialsProvider);\n    } \n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) {\n        builder.readOnlyForRedisClusterReplicas();\n    }\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "146", "src_id": "M1146", "code": "private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n        Connection connection = null;\n        try {\n            if (redirect != null) { \n\n                connection = provider.getConnection(redirect.getTargetNode());\n                if (redirect instanceof JedisAskDataException) {\n                    // TODO: Pipeline asking with the original command to make it faster....\n                    connection.executeCommand(Protocol.Command.ASKING);\n                }\n                return execute(connection, commandObject);\n\n                } else { \n                connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                : provider.getConnection(commandObject.getArguments());\n\n                return execute(connection, commandObject);\n                } \n        } catch (JedisClusterOperationException jnrcne) {\n            throw jnrcne;\n        } catch (JedisConnectionException jce) {\n            lastException = jce;\n            ++consecutiveConnectionFailures;\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n            boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n            if (reset) {\n                consecutiveConnectionFailures = 0;\n                redirect = null;\n            }\n        } catch (JedisRedirectionException jre) {\n            // avoid updating lastException if it is a connection exception\n            if (lastException == null || lastException instanceof JedisRedirectionException) {\n                lastException = jre;\n            }\n            log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n            consecutiveConnectionFailures = 0;\n            redirect = jre;\n            // if MOVED redirection occurred,\n            if (jre instanceof JedisMovedDataException) {\n                // it rebuilds cluster's slot cache recommended by Redis cluster specification\n                provider.renewSlotCache(connection);\n            }\n        } finally {\n            IOUtils.closeQuietly(connection);\n        }\n        if (Instant.now().isAfter(deadline)) {\n            throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n        }\n    }\n\n    JedisClusterOperationException maxAttemptsException\n    = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "147", "src_id": "M884", "code": "@Override\npublic void addParams(CommandArguments args) {\n\n    if (filters == null) {\n        throw new IllegalArgumentException(\"FILTER arguments must be set.\");\n    }\n\n    if (fromTimestamp == null) {\n        args.add(MINUS);\n    } else {\n        args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n        args.add(PLUS);\n    } else {\n        args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) {\n        args.add(LATEST);\n    }\n\n    if (filterByTimestamps != null) {\n        args.add(FILTER_BY_TS);\n        for (long ts : filterByTimestamps) {\n            args.add(toByteArray(ts));\n        }\n    }\n\n    if (filterByValues != null) {\n        args.add(FILTER_BY_VALUE);\n        for (double value : filterByValues) {\n            args.add(toByteArray(value));\n        }\n    }\n\n    if (!(withLabels)) {\n        if (selectedLabels != null) {\n            args.add(SELECTED_LABELS);\n            for (String label : selectedLabels) {\n                args.add(label);\n            }\n        }\n    } else {\n        args.add(WITHLABELS);\n    } \n\n    if (count != null) {\n        args.add(COUNT).add(toByteArray(count));\n    }\n\n    if (aggregationType != null) {\n\n        if (align != null) {\n            args.add(ALIGN).add(align);\n        }\n\n        args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n        if (bucketTimestamp != null) {\n            args.add(BUCKETTIMESTAMP).add(bucketTimestamp);\n        }\n\n        if (empty) {\n            args.add(EMPTY);\n        }\n    }\n\n    args.add(FILTER);\n    for (String filter : filters) {\n        args.add(filter);\n    }\n\n    if (groupByLabel != null && groupByReduce != null) {\n        args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "148", "src_id": "M502", "code": "@Deprecated\n@Override\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "149", "src_id": "M416", "code": "@Override\npublic List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "150", "src_id": "M390", "code": "@Override\npublic Long objectFreq(final byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "151", "src_id": "M231", "code": "public GeoRadiusStoreParam storeDist(String key) {\n    if (key != null) {\n        this.storeDist = true;\n        this.key = key;\n    }\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "218", "src_id": "M233", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "219", "src_id": "M1104", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "220", "src_id": "M260", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change && existence == that.existence && comparison == that.comparison;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "221", "src_id": "M234", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "222", "src_id": "M256", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "223", "src_id": "M238", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "224", "src_id": "M229", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "32", "src_id": "M1291", "code": "private static void appendNum(StringBuilder sb, double n, boolean inclusive) {\n    if (!inclusive) {\n        sb.append(\"(\");\n    }\n    if (n == Double.NEGATIVE_INFINITY) {\n        sb.append(\"-inf\");\n    } else {\n        if (n == Double.POSITIVE_INFINITY) {\n            sb.append(\"inf\");\n        } else {\n            sb.append(n);\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "33", "src_id": "M1292", "code": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append('[');\n    appendFrom(sb, inclusiveMin);\n    sb.append(' ');\n    appendTo(sb, inclusiveMax);\n    sb.append(']');\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "34", "src_id": "M1290", "code": "@Override\npublic String toString(Parenthesize parenMode) {\n    StringBuilder sb = new StringBuilder();\n    StringJoiner sj = new StringJoiner(getJoinString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append('(');\n    }\n    for (Node n : children) {\n        sj.add(n.toString(parenMode));\n    }\n    sb.append(sj.toString());\n    if (shouldParenthesize(parenMode)) {\n        sb.append(')');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "152", "src_id": "M890", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "153", "src_id": "M903", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && \n    Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "154", "src_id": "M907", "code": "@Override\npublic int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "94", "src_id": "M284", "code": "@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "95", "src_id": "M792", "code": "@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "96", "src_id": "M727", "code": "@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n        checkIsInMultiOrPipeline();\n        connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n        return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "97", "src_id": "M728", "code": "@Override\npublic List<String> commandGetKeys(String... command) {\n        checkIsInMultiOrPipeline();\n        connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n        return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "98", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n        this.byBox = true;\n        this.width = width;\n        this.height = height;\n        this.unit = unit;\n        return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "99", "src_id": "M732", "code": "@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n        checkIsInMultiOrPipeline();\n        CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n        connection.sendCommand(args);\n        return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "100", "src_id": "M712", "code": "@Override\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "101", "src_id": "M551", "code": "@Override\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "102", "src_id": "M844", "code": "@Override\npublic List<Object> functionListBinary() {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "103", "src_id": "M298", "code": "@Override\npublic long sintercard(int limit, byte[]... keys) {\n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "155", "src_id": "M127", "code": "private void build() {\n    // check build state to prevent recursion\n    if (building) {\n        return;\n    }\n\n    building = true;\n    try {\n        if (data != null) {\n            if (data instanceof JedisDataException) {\n                exception = (JedisDataException) data;\n            } else {\n                response = builder.build(data);\n            }\n        }\n\n        data = null;\n    } finally {\n        building = false;\n        built = true;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "156", "src_id": "M1184", "code": "@Override\npublic int read(byte[] b, int off, int len) throws JedisConnectionException {\n    ensureFill();\n\n    final int length = Math.min(limit - count, len);\n    System.arraycopy(buf, count, b, off, length);\n    count += length;\n    return length;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "157", "src_id": "M1128", "code": "private HostAndPort toHostAndPort(List<String> getMasterAddrByNameResult) {\n    String host = getMasterAddrByNameResult.get(0);\n    int port = Integer.parseInt(getMasterAddrByNameResult.get(1));\n\n    return new HostAndPort(host, port);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "158", "src_id": "M1154", "code": "public String getElement() {\n    if (null != element) {\n        return SafeEncoder.encode(element);\n    } else {\n        return null;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "159", "src_id": "M937", "code": "@Override\npublic boolean equals(Object o) {\n    if (o == null) {\n        return false;\n    }\n    if (o == this) {\n        return true;\n    }\n    if (!(o instanceof GeoCoordinate)) {\n        return false;\n    }\n\n    GeoCoordinate that = (GeoCoordinate) o;\n\n    if (Double.compare(that.longitude, longitude) != 0) {\n        return false;\n    }\n    return Double.compare(that.latitude, latitude) == 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "160", "src_id": "M1073", "code": "@SuppressWarnings(\"unchecked\")\npublic List<byte[]> getBinaryMultiBulkReply() {\n    flush();\n    return (List<byte[]>) readProtocolWithCheckingBroken();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "104", "src_id": "M890", "code": "@Override\npublic boolean equals(Object o) {\n\n    if (this==o) {\n        return true;\n    }\n    if (null==o||getClass()!=o.getClass()) {\n        return false;\n    }\n    TSArithByParams<?> that=(TSArithByParams<?>) o;\n    return ignore==that.ignore&&ignoreMaxTimediff==that.ignoreMaxTimediff &&\n    0==Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding==that.encoding&&Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy==that.duplicatePolicy&&Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "105", "src_id": "M903", "code": "@Override\npublic boolean equals(Object o) {\n    if (this==o) {\n        return true;\n    }\n    if (null==o||getClass()!=o.getClass()) {\n        return false;\n    }\n\n    TSCreateParams that=(TSCreateParams) o;\n    return ignore==that.ignore&&ignoreMaxTimediff==that.ignoreMaxTimediff &&\n    0==Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding==that.encoding&&\n    Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy==that.duplicatePolicy&&Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "106", "src_id": "M907", "code": "@Override\npublic int hashCode() {\n    int result=Boolean.hashCode(latest);\n    result=31*result+Boolean.hashCode(withLabels);\n    result=31*result+Arrays.hashCode(selectedLabels);\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "35", "src_id": "M107", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n    if (data == null) return null;      \n\n    List list = (List) data;\n    if (list.isEmpty()) return Collections.emptyList();      \n\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream().map(\n        kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n        for (Object anObj : list) {\n            List<Object> streamObj = (List<Object>) anObj;\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n            result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "36", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(byte[] groupName, \nbyte[] consumer, \nXReadGroupParams xReadGroupParams,            Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "37", "src_id": "M1172", "code": "@Override\npublic boolean equals(Object other) {\n    if (other == null) return false;            \n\n    if (other == this) return true;            \n\n    if (!(other instanceof ByteArrayWrapper)) return false;            \n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "38", "src_id": "M154", "code": "@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\nXReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "39", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "40", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "41", "src_id": "M152", "code": "@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, \nbyte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "225", "src_id": "M107", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n        for (Object anObj : list) {\n            List<Object> streamObj = (List<Object>) anObj;\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n            result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "226", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(byte[] groupName, \nbyte[] consumer, \nXReadGroupParams xReadGroupParams,            Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "227", "src_id": "M1172", "code": "@Override\npublic boolean equals(Object other) {\n    if (other == null) {\n        return false;\n    }\n    if (other == this) {\n        return true;\n    }\n    if (!(other instanceof ByteArrayWrapper)) {\n        return false;\n    }\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "228", "src_id": "M154", "code": "@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\nXReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "229", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "230", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "231", "src_id": "M152", "code": "@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, \nbyte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "161", "src_id": "M284", "code": "@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "162", "src_id": "M792", "code": "@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "163", "src_id": "M727", "code": "@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "164", "src_id": "M728", "code": "@Override\npublic List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "165", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "166", "src_id": "M732", "code": "@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "167", "src_id": "M712", "code": "@Override\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "168", "src_id": "M551", "code": "@Override\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "169", "src_id": "M844", "code": "@Override\npublic List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "170", "src_id": "M298", "code": "@Override\npublic long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "232", "src_id": "M777", "code": "@Override\npublic List<Map<String, Object>> clusterLinks() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER, ClusterKeyword.LINKS);\n    return connection.getObjectMultiBulkReply().stream()\n    .map(BuilderFactory.ENCODED_OBJECT_MAP::build).collect(Collectors.toList());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "233", "src_id": "M779", "code": "@Override\npublic String clusterDelSlotsRange(int... ranges) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(CLUSTER,\n    joinParameters(ClusterKeyword.DELSLOTSRANGE.getRaw(), joinParameters(ranges)));\n    return connection.getStatusCodeReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "234", "src_id": "M818", "code": "@Override\npublic Map<String, Object> memoryStats() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(MEMORY, STATS);\n    return BuilderFactory.ENCODED_OBJECT_MAP.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "107", "src_id": "M107", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n    if (data == null) return null;      \n\n    List list = (List) data;\n    if (list.isEmpty()) return Collections.emptyList();      \n\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n        for (Object anObj : list) {\n            List<Object> streamObj = (List<Object>) anObj;\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n            result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "108", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(byte[] groupName, \nbyte[] consumer, \nXReadGroupParams xReadGroupParams,            Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "109", "src_id": "M1172", "code": "@Override\npublic boolean equals(Object other) {\n    if (other == null) return false;            \n\n    if (other == this) return true;            \n\n    if (!(other instanceof ByteArrayWrapper)) return false;            \n\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "110", "src_id": "M154", "code": "@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\nXReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "111", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "112", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "113", "src_id": "M152", "code": "@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, \nbyte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "171", "src_id": "M580", "code": "@Override\npublic List<String> hgetex(String key, HGetExParams params, String... fields) {    \n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.hgetex(key, params, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "172", "src_id": "M237", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        BaseSetExParams setParams = (BaseSetExParams) o;\n        return Objects.equals(expiration, setParams.expiration) \n        && Objects.equals(expirationValue, setParams.expirationValue);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "173", "src_id": "M227", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;        \n\n        if (o == null || getClass() != o.getClass()) return false;        \n\n        HSetExParams setParams = (HSetExParams) o;\n        return Objects.equals(existance, setParams.existance) && super.equals((BaseSetExParams) o);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "174", "src_id": "M868", "code": "private void safeReAuthenticate(Token token) {\n        try {\n                byte[] rawPass = client.encodeToBytes(token.getValue().toCharArray());\n                byte[] rawUser = client.encodeToBytes(token.getUser().toCharArray());\n\n                Token newToken = pendingTokenRef.getAndSet(token);\n                if (newToken == null) {\n                        commandSync.lock();\n                        try {\n                                sendAndFlushCommand(Command.AUTH, rawUser, rawPass);\n                                resultHandler.add(this.authResultHandler);\n                        } finally {\n                                pendingTokenRef.set(null);\n                                commandSync.unlock();\n                        }\n                }\n        } catch (Exception e) {\n                logger.error(\"Error while re-authenticating connection\", e);\n                client.getAuthXManager().getListener().onConnectionAuthenticationError(e);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "175", "src_id": "M957", "code": "public void setListener(AuthXEventListener listener) {\n        if (listener != null) this.listener = listener;        \n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "176", "src_id": "M960", "code": "private void processPingReply(Object reply) {\n        byte[] resp = (byte[]) reply;\n        if (\"PONG\".equals(SafeEncoder.encode(resp))) {\n                onPong(null);\n        } else {\n                onPong(encode(resp));\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "177", "src_id": "M581", "code": "@Override\npublic List<String> hgetdel(String key, String... fields) {    \n        checkIsInMultiOrPipeline();\n        return connection.executeCommand(commandObjects.hgetdel(key, fields));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "235", "src_id": "M233", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        XAutoClaimParams that = (XAutoClaimParams) o;\n        return Objects.equals(count, that.count);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "236", "src_id": "M1104", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;      \n\n        if (o == null || getClass() != o.getClass()) return false;      \n\n        return Arrays.equals(raw, ((Raw) o).raw);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "237", "src_id": "M260", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        ZAddParams that = (ZAddParams) o;\n        return change == that.change && existence == that.existence && comparison == that.comparison;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "238", "src_id": "M234", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        ClientKillParams that = (ClientKillParams) o;\n        return Objects.equals(params, that.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "239", "src_id": "M256", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        ModuleLoadExParams that = (ModuleLoadExParams) o;\n        return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "240", "src_id": "M238", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        MigrateParams that = (MigrateParams) o;\n        return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "241", "src_id": "M229", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        ZParams zParams = (ZParams) o;\n        return Objects.equals(params, zParams.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "42", "src_id": "M1177", "code": "public static void closeQuietly(AutoCloseable resource) {\n    // It's same thing as Apache Commons - IOUtils.closeQuietly()\n    if (resource != null) {\n        try {\n            resource.close();\n        } catch (Exception e) {\n        // ignored\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "43", "src_id": "M620", "code": "@Override\npublic Set<String> sinter(final String... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sinter(keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "44", "src_id": "M50", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic Map<byte[], byte[]> build(Object data) {\n    final List<Object> list = (List<Object>) data;\n    if (list.isEmpty()) return Collections.emptyMap();      \n\n    if (list.get(0) instanceof KeyValue) {\n        final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) {\n            KeyValue kv = (KeyValue) iterator.next();\n            map.put(BINARY.build(kv.getKey()), BINARY.build(kv.getValue()));\n        }\n        return map;\n    } else {\n        final Map<byte[], byte[]> map = new JedisByteHashMap();\n\n        final Iterator iterator = list.iterator();\n        while (iterator.hasNext()) map.put(BINARY.build(iterator.next()), BINARY.build(iterator.next()));\n\n        return map;\n    }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "45", "src_id": "M933", "code": "@Deprecated\npublic static DefaultJedisClientConfig copyConfig(JedisClientConfig copy) {\n    Builder builder = builder();\n    builder.protocol(copy.getRedisProtocol());\n    builder.connectionTimeoutMillis(copy.getConnectionTimeoutMillis());\n    builder.socketTimeoutMillis(copy.getSocketTimeoutMillis());\n    builder.blockingSocketTimeoutMillis(copy.getBlockingSocketTimeoutMillis());\n\n    Supplier<RedisCredentials> credentialsProvider = copy.getCredentialsProvider();\n\n    if (credentialsProvider == null) {\n        builder.user(copy.getUser());\n        builder.password(copy.getPassword());\n    }    else {\n        builder.credentialsProvider(credentialsProvider);\n    } \n\n    builder.database(copy.getDatabase());\n    builder.clientName(copy.getClientName());\n    builder.ssl(copy.isSsl());\n    builder.sslSocketFactory(copy.getSslSocketFactory());\n    builder.sslParameters(copy.getSslParameters());\n    builder.hostnameVerifier(copy.getHostnameVerifier());\n    builder.sslOptions(copy.getSslOptions());\n    builder.hostAndPortMapper(copy.getHostAndPortMapper());\n\n    builder.clientSetInfoConfig(copy.getClientSetInfoConfig());\n    if (copy.isReadOnlyForRedisClusterReplicas()) builder.readOnlyForRedisClusterReplicas();    \n\n\n    builder.authXManager(copy.getAuthXManager());\n\n    return builder.build();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "46", "src_id": "M1146", "code": "private <T> T doExecuteCommand(CommandObject<T> commandObject, boolean toReplica) {\n    Instant deadline = Instant.now().plus(maxTotalRetriesDuration);\n\n    JedisRedirectionException redirect = null;\n    int consecutiveConnectionFailures = 0;\n    Exception lastException = null;\n    for (int attemptsLeft = this.maxAttempts; attemptsLeft > 0; attemptsLeft--) {\n        Connection connection = null;\n        try {\n            if (redirect != null) { \n\n                connection = provider.getConnection(redirect.getTargetNode());\n\n                if (redirect instanceof JedisAskDataException) connection.executeCommand(Protocol.Command.ASKING);          \n\n                return execute(connection, commandObject);\n\n                } else { \n                connection = toReplica ? provider.getReplicaConnection(commandObject.getArguments())\n                : provider.getConnection(commandObject.getArguments());\n\n                return execute(connection, commandObject);\n                } \n        } catch (JedisClusterOperationException jnrcne) {\n            throw jnrcne;\n        } catch (JedisConnectionException jce) {\n            lastException = jce;\n            ++consecutiveConnectionFailures;\n            log.debug(\"Failed connecting to Redis: {}\", connection, jce);\n            // \"- 1\" because we just did one, but the attemptsLeft counter hasn't been decremented yet\n            boolean reset = handleConnectionProblem(attemptsLeft - 1, consecutiveConnectionFailures, deadline);\n            if (reset) {\n                consecutiveConnectionFailures = 0;\n                redirect = null;\n            }\n        } catch (JedisRedirectionException jre) {\n            // avoid updating lastException if it is a connection exception\n            if (lastException == null || lastException instanceof JedisRedirectionException) lastException = jre;        \n\n            log.debug(\"Redirected by server to {}\", jre.getTargetNode());\n            consecutiveConnectionFailures = 0;\n            redirect = jre;\n            // if MOVED redirection occurred,\n            if (jre instanceof JedisMovedDataException) provider.renewSlotCache(connection);        \n\n        } finally {\n            IOUtils.closeQuietly(connection);\n        }\n        if ( !(Instant.now().isAfter(deadline))) { \n            continue ; \n        }  \n        throw new JedisClusterOperationException(\"Cluster retry deadline exceeded.\", lastException);\n    }\n\n    JedisClusterOperationException maxAttemptsException\n    = new JedisClusterOperationException(\"No more cluster attempts left.\");\n    maxAttemptsException.addSuppressed(lastException);\n    throw maxAttemptsException;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "47", "src_id": "M884", "code": "@Override\npublic void addParams(CommandArguments args) {\n\n    if (filters == null) throw new IllegalArgumentException(\"FILTER arguments must be set.\");    \n\n\n    if (fromTimestamp == null) {\n        args.add(MINUS);\n    } else {\n        args.add(toByteArray(fromTimestamp));\n    }\n\n    if (toTimestamp == null) {\n        args.add(PLUS);\n    } else {\n        args.add(toByteArray(toTimestamp));\n    }\n\n    if (latest) args.add(LATEST);    \n\n\n    if (filterByTimestamps != null) {\n        args.add(FILTER_BY_TS);\n        for (long ts : filterByTimestamps) args.add(toByteArray(ts));      \n\n    }\n\n    if (filterByValues != null) {\n        args.add(FILTER_BY_VALUE);\n        for (double value : filterByValues) args.add(toByteArray(value));      \n\n    }\n\n    if (!(withLabels)) {\n        if (selectedLabels != null) {\n            args.add(SELECTED_LABELS);\n            for (String label : selectedLabels) args.add(label);      \n\n        }\n    } else {\n        args.add(WITHLABELS);\n    } \n\n    if (count != null) args.add(COUNT).add(toByteArray(count));    \n\n\n    if (aggregationType != null) {\n\n        if (align != null) args.add(ALIGN).add(align);      \n\n\n        args.add(AGGREGATION).add(aggregationType).add(toByteArray(bucketDuration));\n\n        if (bucketTimestamp != null) args.add(BUCKETTIMESTAMP).add(bucketTimestamp);      \n\n\n        if (empty) args.add(EMPTY);      \n\n    }\n\n    args.add(FILTER);\n    for (String filter : filters) args.add(filter);    \n\n\n    if (groupByLabel != null && groupByReduce != null) args.add(GROUPBY).add(groupByLabel).add(REDUCE).add(groupByReduce);    \n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "48", "src_id": "M502", "code": "@Deprecated\n@Override\npublic List<Object> xread(XReadParams xReadParams, Entry<byte[], byte[]>... streams) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.xread(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "49", "src_id": "M416", "code": "@Override\npublic List<byte[]> aclLogBinary() {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(ACL, LOG);\n    return connection.getBinaryMultiBulkReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "50", "src_id": "M390", "code": "@Override\npublic Long objectFreq(final byte[] key) {\n    connection.sendCommand(OBJECT, FREQ.getRaw(), key);\n    return connection.getIntegerReply();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "51", "src_id": "M231", "code": "public GeoRadiusStoreParam storeDist(String key) {\n    if (key != null) {\n        this.storeDist = true;\n        this.key = key;\n    }\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "114", "src_id": "M107", "code": "@Override\n@SuppressWarnings(\"unchecked\")\npublic List<Map.Entry<byte[], List<StreamEntryBinary >>> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    List list = (List) data;\n    if (list.isEmpty()) {\n        return Collections.emptyList();\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        return ((List<KeyValue>) list).stream()\n        .map(kv -> new KeyValue<>(BINARY.build(kv.getKey()),\n        STREAM_ENTRY_BINARY_LIST.build(kv.getValue())))\n        .collect(Collectors.toList());\n    } else {\n        List<Map.Entry<byte[], List<StreamEntryBinary >>> result = new ArrayList<>(list.size());\n        for (Object anObj : list) {\n            List<Object> streamObj = (List<Object>) anObj;\n            byte[] streamKey = BINARY.build(streamObj.get(0));\n            List<StreamEntryBinary> streamEntries = STREAM_ENTRY_BINARY_LIST.build(streamObj.get(1));\n            result.add(KeyValue.of(streamKey, streamEntries));\n        }\n        return result;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "115", "src_id": "M1012", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadGroupBinaryAsMap(byte[] groupName, \nbyte[] consumer, \nXReadGroupParams xReadGroupParams,            Map<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREADGROUP)\n    .add(GROUP).add(groupName).add(consumer)\n    .addParams(xReadGroupParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "116", "src_id": "M1172", "code": "@Override\npublic boolean equals(Object other) {\n    if (other == null) {\n        return false;\n    }\n    if (other == this) {\n        return true;\n    }\n    if (!(other instanceof ByteArrayWrapper)) {\n        return false;\n    }\n\n    return Arrays.equals(data, ((ByteArrayWrapper) other).data);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "117", "src_id": "M154", "code": "@Override\npublic Map<byte[], List<StreamEntryBinary>> xreadBinaryAsMap(\nXReadParams xReadParams,\nMap<byte[], StreamEntryID> streams) {\n    return executeCommand(commandObjects.xreadBinaryAsMap(xReadParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "118", "src_id": "M1010", "code": "public final CommandObject<Map<byte[], List<StreamEntryBinary>>> xreadBinaryAsMap(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_MAP_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "119", "src_id": "M1009", "code": "public final CommandObject<List<Map.Entry<byte[], List<StreamEntryBinary >>>> xreadBinary(\nXReadParams xReadParams, \nMap<byte[], StreamEntryID> streams) {\n    CommandArguments args = commandArguments(XREAD).addParams(xReadParams).add(STREAMS);\n    Set<Map.Entry<byte[], StreamEntryID >> entrySet = streams.entrySet();\n    entrySet.forEach(entry -> args.key(entry.getKey()));\n    entrySet.forEach(entry -> args.add(entry.getValue()));\n    return new CommandObject<>(args, BuilderFactory.STREAM_READ_BINARY_RESPONSE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "120", "src_id": "M152", "code": "@Deprecated\n@Override\npublic List<Object> xreadGroup(byte[] groupName, \nbyte[] consumer,\nXReadGroupParams xReadGroupParams, Map.Entry<byte[], byte[]>... streams) {\n    return executeCommand(\n    commandObjects.xreadGroup(groupName, consumer, xReadGroupParams, streams));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "178", "src_id": "M233", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    XAutoClaimParams that = (XAutoClaimParams) o;\n    return Objects.equals(count, that.count);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "179", "src_id": "M1104", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    return Arrays.equals(raw, ((Raw) o).raw);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "180", "src_id": "M260", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ZAddParams that = (ZAddParams) o;\n    return change == that.change && existence == that.existence && comparison == that.comparison;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "181", "src_id": "M234", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ClientKillParams that = (ClientKillParams) o;\n    return Objects.equals(params, that.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "182", "src_id": "M256", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ModuleLoadExParams that = (ModuleLoadExParams) o;\n    return Objects.equals(configs, that.configs) && Objects.equals(args, that.args);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "183", "src_id": "M238", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    MigrateParams that = (MigrateParams) o;\n    return copy == that.copy && replace == that.replace && Objects.equals(username, that.username) && Objects.equals(password, that.password);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "184", "src_id": "M229", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    ZParams zParams = (ZParams) o;\n    return Objects.equals(params, zParams.params);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "242", "src_id": "M890", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n        TSArithByParams<?> that = (TSArithByParams<?>) o;\n        return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n        Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n        Objects.equals(timestamp, that.timestamp) &&\n        Objects.equals(retentionPeriod, that.retentionPeriod) &&\n        encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n        duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "243", "src_id": "M903", "code": "@Override\npublic boolean equals(Object o) {\n        if (this == o) return true;    \n\n        if (o == null || getClass() != o.getClass()) return false;    \n\n\n        TSCreateParams that = (TSCreateParams) o;\n        return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n        Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n        Objects.equals(retentionPeriod, that.retentionPeriod) &&\n        encoding == that.encoding && \n        Objects.equals(chunkSize, that.chunkSize) &&\n        duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "jedis", "pair_id": "244", "src_id": "M907", "code": "@Override\npublic int hashCode() {\n        int result = Boolean.hashCode(latest);\n        result = 31 * result + Boolean.hashCode(withLabels);\n        result = 31 * result + Arrays.hashCode(selectedLabels);\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "52", "src_id": "M284", "code": "@Override\npublic long expireAt(byte[] key, long unixTime, ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.expireAt(key, unixTime, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "53", "src_id": "M792", "code": "@Override\npublic List<GeoRadiusResponse> geosearch(String key, String member, double width, double height, GeoUnit unit) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.geosearch(key, member, width, height, unit));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "54", "src_id": "M727", "code": "@Override\npublic Map<String, CommandDocument> commandDocs(String... commands) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(DOCS.name(), commands));\n    return BuilderFactory.COMMAND_DOCS_RESPONSE.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "55", "src_id": "M728", "code": "@Override\npublic List<String> commandGetKeys(String... command) {\n    checkIsInMultiOrPipeline();\n    connection.sendCommand(COMMAND, joinParameters(GETKEYS.name(), command));\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "56", "src_id": "M245", "code": "public GeoSearchParam byBox(double width, double height, GeoUnit unit) {\n    this.byBox = true;\n    this.width = width;\n    this.height = height;\n    this.unit = unit;\n    return this;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "57", "src_id": "M732", "code": "@Override\npublic List<String> commandListFilterBy(CommandListFilterByParams filterByParams) {\n    checkIsInMultiOrPipeline();\n    CommandArguments args = new CommandArguments(COMMAND).add(LIST).addParams(filterByParams);\n    connection.sendCommand(args);\n    return BuilderFactory.STRING_LIST.build(connection.getOne());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "58", "src_id": "M712", "code": "@Override\npublic LCSMatchResult lcs(final String keyA, final String keyB, final LCSParams params) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.lcs(keyA, keyB, params));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "59", "src_id": "M551", "code": "@Override\npublic long pexpire(final String key, final long milliseconds, final ExpiryOption expiryOption) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.pexpire(key, milliseconds, expiryOption));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "60", "src_id": "M844", "code": "@Override\npublic List<Object> functionListBinary() {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.functionListBinary());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "61", "src_id": "M298", "code": "@Override\npublic long sintercard(int limit, byte[]... keys) {\n    checkIsInMultiOrPipeline();\n    return connection.executeCommand(commandObjects.sintercard(limit, keys));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "185", "src_id": "M890", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n    TSArithByParams<?> that = (TSArithByParams<?>) o;\n\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(timestamp, that.timestamp) &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "186", "src_id": "M903", "code": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n\n    TSCreateParams that = (TSCreateParams) o;\n    return ignore == that.ignore && ignoreMaxTimediff == that.ignoreMaxTimediff &&\n    Double.compare(ignoreMaxValDiff, that.ignoreMaxValDiff) == 0 &&\n    Objects.equals(retentionPeriod, that.retentionPeriod) &&\n    encoding == that.encoding && \n    Objects.equals(chunkSize, that.chunkSize) &&\n    duplicatePolicy == that.duplicatePolicy && Objects.equals(labels, that.labels);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "jedis", "pair_id": "187", "src_id": "M907", "code": "@Override\npublic int hashCode() {\n    int result = Boolean.hashCode(latest);\n    result = 31 * result + Boolean.hashCode(withLabels);\n    result = 31 * result + Arrays.hashCode(selectedLabels);\n    return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "157", "src_id": "M347", "code": "@Override\npublic void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n                case TokenTypes.IDENT:\n                        if (collect) {\n                                processIdent(ast);\n                        }\n                        break;\n                case TokenTypes.IMPORT:\n                        processImport(ast);\n                        break;\n                case TokenTypes.STATIC_IMPORT:\n                        processStaticImport(ast);\n                        break;\n                case TokenTypes.OBJBLOCK:\n                case TokenTypes.SLIST:\n                        currentFrame = currentFrame.push();\n                        break;\n                default:\n                        collect = true;\n                        if (processJavadoc) {\n                                collectReferencesFromJavadoc(ast);\n                        }\n                        break;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "158", "src_id": "M394", "code": "@Override\npublic int[] getRequiredJavadocTokens() {\n        return new int[] {\n        JavadocTokenTypes.TEXT,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "159", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                result = node.getPreviousSibling();\n        }\n        else {\n                if (isInPatternDefinition(node)) {\n                        result = node.getFirstChild();\n                }\n                else {\n                        result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n                }\n        }\n        while (result.getLastChild() != null) {\n                result = result.getLastChild();\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "59", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n        || entry.getLastLine() == line && column <= entry\n        .getLastColumn();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "60", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n        && modifiers.findFirstToken(TokenTypes.FINAL) == null\n        && hasDefaultOrExplicitNonPrivateCtor(classDef);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "61", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n                }\n                while (vertex != null) {\n                        if (vertex.getType() == tokenType) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex = vertex.getFirstChild();\n                }\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "62", "src_id": "M504", "code": "@Override\npublic int[] getAcceptableTokens() {\n        return new int[] {\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "63", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n                extension = \"\";\n        }\n        else {\n                extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "64", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, \nDetailAST token,\nint endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n                }\n                while (vertex != null) {\n                        if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex = vertex.getFirstChild();\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "65", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n        && searchAST.getType() != TokenTypes.ENUM_DEF) {\n                searchAST = searchAST.getParent();\n        }\n        return searchAST;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "66", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n                if (classFieldNames.contains(ident.getText())) {\n                        forwardReference = true;\n                        break;\n                }\n        }\n        return forwardReference;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "103", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "104", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "105", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "106", "src_id": "M4", "code": "@Override\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n                final String value = config.getProperty(key);\n\n                tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n                setupChild(childConfig);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "107", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode != null) {\n                annotationString = identNode.getText();\n        }\n        else {\n                final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n                annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n\n        return annotationString;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "1", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return line            < entry.getLastLine() \n        || entry.getLastLine() == line && column <= entry\n        .getLastColumn();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "2", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n        && modifiers.findFirstToken(TokenTypes.FINAL) == null\n        && hasDefaultOrExplicitNonPrivateCtor(classDef);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "3", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n                }\n                while (vertex != null) {\n                        if (vertex.getType() == tokenType) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex = vertex.getFirstChild();\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "4", "src_id": "M504", "code": "@Override\npublic int[] getAcceptableTokens() {\n        return new int[] {\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "5", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n                extension = \"\";\n        }\n        else {\n                extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "6", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, \nDetailAST token,\nint endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n                }\n                while (vertex != null) {\n                        if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex = vertex.getFirstChild();\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "7", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n        && searchAST.getType() != TokenTypes.ENUM_DEF) {\n                searchAST = searchAST.getParent();\n        }\n        return searchAST;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "8", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n                if (classFieldNames.contains(ident.getText())) {\n                        forwardReference = true;\n                        break;\n                }\n        }\n        return forwardReference;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "160", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "161", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "162", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub=new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "163", "src_id": "M4", "code": "@Override\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n        configuration=config;\n\n        final String[] attributes=config.getPropertyNames();\n\n        for (final String key : attributes) {\n                final String value=config.getProperty(key);\n\n                tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs=config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n                setupChild(childConfig);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "164", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode=annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode!=null) {\n                annotationString=identNode.getText();\n        }\n        else {\n                final DetailAST dotNode=annotationNode.findFirstToken(TokenTypes.DOT);\n                annotationString=FullIdent.createFullIdent(dotNode).getText();\n        }\n\n        return annotationString;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "67", "src_id": "M37", "code": "private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        final ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n                result = ModuleType.FILEFILTER;\n        }\n        else {\n                if (simpleModuleName.endsWith(\"Filter\")) {\n                        result = ModuleType.FILTER;\n                }\n                else {\n                        result = ModuleType.CHECK;\n                }\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "68", "src_id": "M28", "code": "private void scrapeContent(DetailNode ast) {\n        if (ast.getType() != JavadocTokenTypes.PARAGRAPH) {\n                if (ast.getType() == JavadocTokenTypes.LI) {\n                        if (!(isPropertyList(ast))) {\n                                if (scrapingViolationMessageList) {\n                                        moduleDetails.addToViolationMessages(getViolationMessages(ast));\n                                }\n                        }\n                        else {\n                                if (propertySectionStartIdx \n                                == -1) {\n                                        propertySectionStartIdx = getParentIndexOf(ast);\n                                }\n                                moduleDetails.addToProperties(createProperties(ast));\n                        }\n                }\n        }\n        else {\n                if (!(isParentText(ast))) {\n                        if (isViolationMessagesText(ast)) {\n                                scrapingViolationMessageList = true;\n                        }\n                        else {\n                                if (exampleSectionStartIdx \n                                == -1\n                                && isExamplesText(ast)) {\n                                        exampleSectionStartIdx = getParentIndexOf(ast);\n                                }\n                        }\n                }\n                else {\n                        parentSectionStartIdx = getParentIndexOf(ast);\n                        moduleDetails.setParent(getParentText(ast));\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "69", "src_id": "M27", "code": "@Override\npublic void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n                moduleDetails = new ModuleDetails();\n                toScan = false;\n                scrapingViolationMessageList = false;\n                propertySectionStartIdx = -1;\n                exampleSectionStartIdx = -1;\n                parentSectionStartIdx = -1;\n\n                String moduleName = getModuleSimpleName();\n                final String checkModuleExtension = \"Check\";\n                if (moduleName.endsWith(checkModuleExtension)) {\n                        moduleName = moduleName\n                        .substring(0, moduleName.length() - checkModuleExtension.length());\n                }\n                moduleDetails.setName(moduleName);\n                moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n                moduleDetails.setModuleType(getModuleType());\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "70", "src_id": "M35", "code": "private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\nPattern pattern) {\n        return Arrays.stream(node.getChildren())\n        .filter(child -> pattern.matcher(child.getText()).matches())\n        .findFirst();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "108", "src_id": "M697", "code": "@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,                              DetailAST bound, int neededTokenType) {\n\n        DetailAST match = null;\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n                        break;\n                }\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "109", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; \n        astNode != null;\n        astNode = astNode.getLastChild()) {\n                previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "110", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n                }\n\n        }\n\n        return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "165", "src_id": "M697", "code": "@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,                              DetailAST bound, int neededTokenType) {\n\n        DetailAST match = null;\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n                        break;\n                }\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "166", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; \n        astNode != null;\n        astNode = astNode.getLastChild()) {\n                previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "167", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n                }\n\n        }\n\n        return reassignedVariableIdents;\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "9", "src_id": "M855", "code": "@Override\npublic DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n        final DetailAstImpl bop=create(ctx.bop);\n        bop.addChild(visit(ctx.expr()));\n        bop.addChild(create(ctx.LITERAL_THIS()));\n        return bop;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "10", "src_id": "M770", "code": "@Override\npublic DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n        final DetailAstImpl interfaceExtends=create(ctx.EXTENDS_CLAUSE());\n        interfaceExtends.addChild(visit(ctx.typeList()));\n        return interfaceExtends;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "11", "src_id": "M854", "code": "@Override\npublic DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n        final DetailAstImpl lambda=create(ctx.LAMBDA());\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n        final JavaLanguageParser.BlockContext blockContext=ctx.block();\n        final DetailAstImpl rightHandLambdaChild;\n        if (blockContext!=null) {\n                rightHandLambdaChild=visit(blockContext);\n        }\n        else {\n                // Lambda expression child is built the same way that we build\n                // the initial expression node in visitExpression, i.e. with\n                // an imaginary EXPR node. This results in nested EXPR nodes\n                // in the AST.\n                rightHandLambdaChild=buildExpressionNode(ctx.expr());\n        }\n        lambda.addChild(rightHandLambdaChild);\n        return lambda;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "12", "src_id": "M779", "code": "@Override\npublic DetailAstImpl visitInterfaceMethodDeclaration(\nJavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n        final DetailAstImpl methodDef=createImaginary(TokenTypes.METHOD_DEF);\n        methodDef.addChild(createModifiers(ctx.mods));\n\n        // Process all children except C style array declarators and modifiers\n        final List<ParseTree> children=ctx.children\n        .stream()\n        .filter(child->!(childinstanceofJavaLanguageParser.ArrayDeclaratorContext))\n        .collect(Collectors.toUnmodifiableList());\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n        final DetailAstImpl typeAst=(DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n        ctx.cStyleArrDec.forEach(child->typeAst.addChild(visit(child)));\n\n        return methodDef;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "13", "src_id": "M839", "code": "@Override\npublic DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n        final DetailAstImpl dummyRoot=new DetailAstImpl();\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n        if (ctx.forInit()!=null) {\n                dummyRoot.addChild(visit(ctx.forInit()));\n        }\n        else {\n                final DetailAstImpl imaginaryForInitParent =\n                createImaginary(TokenTypes.FOR_INIT);\n                dummyRoot.addChild(imaginaryForInitParent);\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n        final DetailAstImpl forCondParent=createImaginary(TokenTypes.FOR_CONDITION);\n        forCondParent.addChild(visit(ctx.forCond));\n        dummyRoot.addChild(forCondParent);\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n        final DetailAstImpl forItParent=createImaginary(TokenTypes.FOR_ITERATOR);\n        forItParent.addChild(visit(ctx.forUpdate));\n        dummyRoot.addChild(forItParent);\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n        return dummyRoot.getFirstChild();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "14", "src_id": "M228", "code": "private static Map.Entry<Integer, Integer> countLinesColumns(\nString text, int initialLinesCnt, int initialColumnsCnt) {\n        int lines=initialLinesCnt;\n        int columns=initialColumnsCnt;\n        boolean foundCr=false;\n        for (char c : text.toCharArray()) {\n                if (c=='\\n') {\n                        foundCr=false;\n                        lines++;\n                        columns=0;\n                }\n                else {\n                        if (foundCr) {\n                                foundCr=false;\n                                lines++;\n                                columns=0;\n                        }\n                        if (c=='\\r') {\n                                foundCr=true;\n                        }\n                        columns++;\n                }\n        }\n        if (foundCr) {\n                lines++;\n                columns=0;\n        }\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "15", "src_id": "M212", "code": "public static Properties getResolvedProperties(Properties properties)\nthrows CheckstyleException {\n\n        final Set<String> unresolvedPropertyNames=new HashSet<>(properties.stringPropertyNames());\n\n        Iterator<String> unresolvedPropertyIterator=unresolvedPropertyNames.iterator();\n\n        final Map<Object, Object> comparisonProperties=new Properties();\n        while (unresolvedPropertyIterator.hasNext()) {\n                final String propertyName=unresolvedPropertyIterator.next();\n                String propertyValue=properties.getProperty(propertyName);\n                final Matcher matcher=PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n                while (matcher.find()) {\n                        final String propertyVariableExpression=matcher.group();\n                        final String unresolvedPropertyName =\n                        getPropertyNameFromExpression(propertyVariableExpression);\n\n                        final String resolvedPropertyValue =\n                        properties.getProperty(unresolvedPropertyName);\n\n                        if (resolvedPropertyValue!=null) {\n                                propertyValue=propertyValue.replace(propertyVariableExpression,\n                                resolvedPropertyValue);\n                                properties.setProperty(propertyName, propertyValue);\n                        }\n                }\n\n                if (allChainedPropertiesAreResolved(propertyValue)) {\n                        unresolvedPropertyIterator.remove();\n                }\n\n                if (!unresolvedPropertyIterator.hasNext()) {\n\n                        if (comparisonProperties.equals(properties)) {\n                                // At this point, we will have not resolved any properties in two iterations,\n                                // so unresolvable properties exist.\n                                throw new CheckstyleException(UNDEFINED_PROPERTY_MESSAGE\n                                +unresolvedPropertyNames);\n                        }\n                        comparisonProperties.putAll(properties);\n                        unresolvedPropertyIterator=unresolvedPropertyNames.iterator();\n                }\n\n        }\n        return properties;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "16", "src_id": "M794", "code": "@Override\npublic DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n        final DetailAstImpl annotations;\n\n        if (!ctx.createImaginaryNode&&ctx.anno.isEmpty()) {\n                // There are no annotations, and we don't want to create the empty node\n                annotations=null;\n        }\n        else {\n                // There are annotations, or we just want the empty node\n                annotations=createImaginary(TokenTypes.ANNOTATIONS);\n                processChildren(annotations, ctx.anno);\n        }\n\n        return annotations;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "17", "src_id": "M764", "code": "@Override\npublic DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n        final DetailAstImpl typeParameter=createImaginary(TokenTypes.TYPE_PARAMETER);\n        processChildren(typeParameter, ctx.children);\n        return typeParameter;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "18", "src_id": "M492", "code": "private void checkYield() {\n        final DetailAST yieldKey=getMainAst();\n        final int columnNo=expandedTabsColumnNo(yieldKey);\n        if (isOnStartOfLine(yieldKey)&&!getIndent().isAcceptable(columnNo)) {\n                logError(yieldKey, \"\", columnNo);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "71", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine()>line\n        ||entry.getLastLine()==line&&entry\n        .getLastColumn()>=column;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "72", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers=classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType()!=TokenTypes.ENUM_DEF\n        &&modifiers.findFirstToken(TokenTypes.FINAL)==null\n        &&hasDefaultOrExplicitNonPrivateCtor(classDef);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "73", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n\n        DetailAST vertex=ast;\n        final Set<DetailAST> result=new HashSet<>();\n        final Deque<DetailAST> stack=new ArrayDeque<>();\n        while (vertex!=null||!stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex=stack.pop();\n                }\n                while (vertex!=null) {\n                        if (vertex.getType()==tokenType) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling()!=null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex=vertex.getFirstChild();\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "74", "src_id": "M504", "code": "@Override\npublic int[] getAcceptableTokens() {\n        return new int[] {\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "75", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName=Paths.get(fileNameWithExtension).toString();\n        final int dotIndex=fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex==-1) {\n                extension=\"\";\n        }\n        else {\n                extension=fileName.substring(dotIndex+1);\n        }\n        return extension;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "76", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, \nDetailAST token,\nint endLineNumber) {\n\n        DetailAST vertex=ast;\n        final Set<DetailAST> result=new HashSet<>();\n        final Deque<DetailAST> stack=new ArrayDeque<>();\n        while (vertex!=null||!stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex=stack.pop();\n                }\n                while (vertex!=null) {\n                        if (isAstSimilar(token, vertex)\n                        &&endLineNumber>=vertex.getLineNo()) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling()!=null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex=vertex.getFirstChild();\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "77", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST=ast;\n        while (searchAST.getType()!=TokenTypes.CLASS_DEF\n        &&searchAST.getType()!=TokenTypes.ENUM_DEF) {\n                searchAST=searchAST.getParent();\n        }\n        return searchAST;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "78", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent=fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents=getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference=false;\n\n        for (DetailAST ident : exprIdents) {\n                if (classFieldNames.contains(ident.getText())) {\n                        forwardReference=true;\n                        break;\n                }\n        }\n        return forwardReference;\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "79", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "80", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "168", "src_id": "M624", "code": "private static boolean hasLiteralNull(DetailAST caseAST) {\n            return Optional.ofNullable(caseAST.findFirstToken(TokenTypes.EXPR))\n            .map(exp -> exp.findFirstToken(TokenTypes.LITERAL_NULL))\n            .isPresent();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "169", "src_id": "M253", "code": "private void checkUnnamedVariables(DetailAST ast) {\n            if (jdkVersion >= JDK_22 && isUnnamedVariable(ast)) {\n                        checkForRedundantModifier(ast, TokenTypes.FINAL);\n            }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "170", "src_id": "M638", "code": "@Override\npublic void leaveToken(DetailAST ast) {\n            if (ast.getType() == TokenTypes.LITERAL_CATCH) {\n                        final Optional<CatchParameterDetails> unusedCatchParameter =\n                        Optional.ofNullable(catchParameters.peek())\n                        .filter(parameter -> !parameter.isUsed())\n                        .filter(parameter -> !\"_\".equals(parameter.getName()));\n\n                        unusedCatchParameter.ifPresent(parameter -> {\n                                    log(parameter.getParameterDefinition(),\n                                    MSG_UNUSED_CATCH_PARAMETER,\n                                    parameter.getName());\n                        });\n                        catchParameters.pop();\n            }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "171", "src_id": "M626", "code": "private static boolean hasStringCaseLabel(DetailAST caseAST) {\n            DetailAST curNode = caseAST;\n            boolean hasStringCaseLabel = false;\n            boolean exitCaseLabelExpression = false;\n            while (!exitCaseLabelExpression) {\n                        DetailAST toVisit = curNode.getFirstChild();\n                        if (curNode.getType() == TokenTypes.STRING_LITERAL) {\n                                    hasStringCaseLabel = true;\n                                    break;\n                        }\n                        while (toVisit == null) {\n                                    toVisit = curNode.getNextSibling();\n                                    curNode = curNode.getParent();\n                        }\n                        curNode = toVisit;\n                        exitCaseLabelExpression = TokenUtil.isOfType(curNode, \n                        TokenTypes.COLON,\n                        TokenTypes.LAMBDA);\n            }\n            return hasStringCaseLabel;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "172", "src_id": "M673", "code": "private static boolean isLambdaParameterIdentifierCandidate(DetailAST identifierAst) {\n            // we should ignore the ident if it is in the lambda parameters declaration\n            final boolean isLambdaParameterDeclaration =\n            identifierAst.getParent().getType() == TokenTypes.LAMBDA\n            || identifierAst.getParent().getType() == TokenTypes.PARAMETER_DEF;\n\n            return !isLambdaParameterDeclaration\n            && (hasValidParentToken(identifierAst) || isMethodInvocation(identifierAst));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "173", "src_id": "M251", "code": "public void setJdkVersion(String jdkVersion) {\n            final String singleVersionNumber;\n            if (jdkVersion.startsWith(\"1.\")) {\n                        singleVersionNumber = jdkVersion.substring(2);\n            }\n            else {\n                        singleVersionNumber = jdkVersion;\n            }\n\n            this.jdkVersion = Integer.parseInt(singleVersionNumber);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "174", "src_id": "M675", "code": "private static boolean isLeftHandOfAssignment(DetailAST identAst) {\n            final DetailAST parent = identAst.getParent();\n            return parent.getType() == TokenTypes.ASSIGN\n            && !identAst.equals(parent.getLastChild());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "111", "src_id": "M855", "code": "@Override\npublic DetailAstImpl visitThisExp(JavaLanguageParser.ThisExpContext ctx) {\n        final DetailAstImpl bop = create(ctx.bop);\n        bop.addChild(visit(ctx.expr()));\n        bop.addChild(create(ctx.LITERAL_THIS()));\n        return bop;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "112", "src_id": "M770", "code": "@Override\npublic DetailAstImpl visitInterfaceExtends(JavaLanguageParser.InterfaceExtendsContext ctx) {\n        final DetailAstImpl interfaceExtends = create(ctx.EXTENDS_CLAUSE());\n        interfaceExtends.addChild(visit(ctx.typeList()));\n        return interfaceExtends;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "113", "src_id": "M854", "code": "@Override\npublic DetailAstImpl visitLambdaExp(JavaLanguageParser.LambdaExpContext ctx) {\n        final DetailAstImpl lambda = create(ctx.LAMBDA());\n\n        lambda.addChild(visit(ctx.lambdaParameters()));\n\n        final JavaLanguageParser.BlockContext blockContext = ctx.block();\n        final DetailAstImpl rightHandLambdaChild = \n        buildExpressionNode(ctx.expr()); \n        if (blockContext != null) { \n                rightHandLambdaChild = visit(blockContext); \n        } \n\n        lambda.addChild(rightHandLambdaChild);\n        return lambda;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "114", "src_id": "M779", "code": "@Override\npublic DetailAstImpl visitInterfaceMethodDeclaration(\nJavaLanguageParser.InterfaceMethodDeclarationContext ctx) {\n        final DetailAstImpl methodDef = createImaginary(TokenTypes.METHOD_DEF);\n        methodDef.addChild(createModifiers(ctx.mods));\n        // Process all children except C style array declarators and modifiers\n        final List<ParseTree> children = ctx.children\n        .stream()\n        .filter(child -> !(child instanceof JavaLanguageParser.ArrayDeclaratorContext))\n        .collect(Collectors.toUnmodifiableList());\n        processChildren(methodDef, children);\n\n        // We add C style array declarator brackets to TYPE ast\n        final DetailAstImpl typeAst = (DetailAstImpl) methodDef.findFirstToken(TokenTypes.TYPE);\n        ctx.cStyleArrDec.forEach(child -> typeAst.addChild(visit(child)));\n\n        return methodDef;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "115", "src_id": "M839", "code": "@Override\npublic DetailAstImpl visitForFor(JavaLanguageParser.ForForContext ctx) {\n        final DetailAstImpl dummyRoot = new DetailAstImpl();\n        dummyRoot.addChild(create(ctx.LPAREN()));\n\n        if (ctx.forInit() != null) {\n                dummyRoot.addChild(visit(ctx.forInit()));\n        }\n        else {\n                final DetailAstImpl imaginaryForInitParent =\n                createImaginary(TokenTypes.FOR_INIT);\n                dummyRoot.addChild(imaginaryForInitParent);\n        }\n\n        dummyRoot.addChild(create(ctx.SEMI(0)));\n\n        final DetailAstImpl forCondParent = createImaginary(TokenTypes.FOR_CONDITION);\n        forCondParent.addChild(visit(ctx.forCond));\n        dummyRoot.addChild(forCondParent);\n        dummyRoot.addChild(create(ctx.SEMI(1)));\n\n        final DetailAstImpl forItParent = createImaginary(TokenTypes.FOR_ITERATOR);\n        forItParent.addChild(visit(ctx.forUpdate));\n        dummyRoot.addChild(forItParent);\n\n        dummyRoot.addChild(create(ctx.RPAREN()));\n\n        return dummyRoot.getFirstChild();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "116", "src_id": "M228", "code": "private static Map.Entry<Integer, Integer> countLinesColumns(\nString text, int initialLinesCnt, int initialColumnsCnt) {\n        int lines = initialLinesCnt;\n        int columns = initialColumnsCnt;\n        boolean foundCr = false;\n        for (char c : text.toCharArray()) {\n                if (c == '\\n') {\n                        foundCr = false;\n                        lines++;\n                        columns = 0;\n                }\n                else {\n                        if (foundCr) {\n                                foundCr = false;\n                                lines++;\n                                columns = 0;\n                        }\n                        if (c == '\\r') {\n                                foundCr = true;\n                        }\n                        columns++;\n                }\n        }\n        if (foundCr) {\n                lines++;\n                columns = 0;\n        }\n        return new AbstractMap.SimpleEntry<>(lines, columns);\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "117", "src_id": "M212", "code": "public static Properties getResolvedProperties(Properties properties)\nthrows CheckstyleException {\n        final Set<String> unresolvedPropertyNames =            new HashSet<>(properties.stringPropertyNames());\n        Iterator<String> unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n        final Map<Object, Object> comparisonProperties = new Properties();\n        while (unresolvedPropertyIterator.hasNext()) {\n                final String propertyName = unresolvedPropertyIterator.next();\n                String propertyValue = properties.getProperty(propertyName);\n                final Matcher matcher = PROPERTY_VARIABLE_PATTERN.matcher(propertyValue);\n\n                while (matcher.find()) {\n                        final String propertyVariableExpression = matcher.group();\n                        final String unresolvedPropertyName =\n                        getPropertyNameFromExpression(propertyVariableExpression);\n\n                        final String resolvedPropertyValue =\n                        properties.getProperty(unresolvedPropertyName);\n\n                        if (resolvedPropertyValue != null) {\n                                propertyValue = propertyValue.replace(propertyVariableExpression,\n                                resolvedPropertyValue);\n                                properties.setProperty(propertyName, propertyValue);\n                        }\n                }\n\n                if (allChainedPropertiesAreResolved(propertyValue)) {\n                        unresolvedPropertyIterator.remove();\n                }\n\n                if (!unresolvedPropertyIterator.hasNext()) {\n\n                        if (comparisonProperties.equals(properties)) {\n                                // At this point, we will have not resolved any properties in two iterations,\n                                // so unresolvable properties exist.\n                                throw new CheckstyleException(UNDEFINED_PROPERTY_MESSAGE\n                                + unresolvedPropertyNames);\n                        }\n                        comparisonProperties.putAll(properties);\n                        unresolvedPropertyIterator = unresolvedPropertyNames.iterator();\n                }\n\n        }\n        return properties;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "118", "src_id": "M794", "code": "@Override\npublic DetailAstImpl visitAnnotations(JavaLanguageParser.AnnotationsContext ctx) {\n        final DetailAstImpl annotations;\n\n        if (!ctx.createImaginaryNode && ctx.anno.isEmpty()) {\n                // There are no annotations, and we don't want to create the empty node\n                annotations = null;\n        }\n        else {\n                // There are annotations, or we just want the empty node\n                annotations = createImaginary(TokenTypes.ANNOTATIONS);\n                processChildren(annotations, ctx.anno);\n        }\n\n        return annotations;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "119", "src_id": "M764", "code": "@Override\npublic DetailAstImpl visitTypeParameter(JavaLanguageParser.TypeParameterContext ctx) {\n        final DetailAstImpl typeParameter = createImaginary(TokenTypes.TYPE_PARAMETER);\n        processChildren(typeParameter, ctx.children);\n        return typeParameter;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "120", "src_id": "M492", "code": "private void checkYield() {\n        final DetailAST yieldKey = getMainAst();\n        final int columnNo = expandedTabsColumnNo(yieldKey);\n        if (isOnStartOfLine(yieldKey) && !getIndent().isAcceptable(columnNo)) {\n                logError(yieldKey, \"\", columnNo);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "175", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "176", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "81", "src_id": "M646", "code": "private static List<DetailAST> getChildList(DetailAST ast) {\n            final List<DetailAST> children = new ArrayList<>();\n            DetailAST child = ast.findFirstToken(TokenTypes.OBJBLOCK).getFirstChild();\n            while (child != null) {\n                        children.add(child);\n                        child = child.getNextSibling();\n            }\n            return children;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "82", "src_id": "M373", "code": "private void checkParagraphTag(DetailNode tag) {\n            if (!isNestedParagraph(tag)) {\n                        final DetailNode newLine = getNearestEmptyLine(tag);\n                        if (isFirstParagraph(tag)) {\n                                    log(tag.getLineNumber(), tag.getColumnNumber(), MSG_REDUNDANT_PARAGRAPH);\n                        }\n                        else {\n                                    if (newLine == null || tag.getLineNumber() - newLine.getLineNumber() != 1) {\n                                                log(tag.getLineNumber(), tag.getColumnNumber(), MSG_LINE_BEFORE);\n                                    }\n                        }\n                        final String blockTagName = findFollowedBlockTagName(tag);\n                        if (blockTagName != null) {\n                                    log(tag.getLineNumber(), \n                                    tag.getColumnNumber(),\n                                    MSG_PRECEDED_BLOCK_TAG, blockTagName);\n                        }\n\n                        if (!allowNewlineParagraph && isImmediatelyFollowedByNewLine(tag) || isImmediatelyFollowedByText(tag)) {\n                                    log(tag.getLineNumber(), tag.getColumnNumber(), MSG_MISPLACED_TAG);\n                        }\n            }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "83", "src_id": "M406", "code": "@Override\npublic void finishJavadocTree(DetailNode rootAst) {\n            // this method checks the alignment of closing javadoc tag.\n            final DetailAST javadocEndToken = getBlockCommentAst().getLastChild();\n            final String lastLine = fileLines[javadocEndToken.getLineNo() - 1];\n            final Optional<Integer> endingBlockColumnNumber = getAsteriskColumnNumber(lastLine);\n            endingBlockColumnNumber\n            .map(columnNumber -> expandedTabs(lastLine, columnNumber))\n            .filter(columnNumber -> {\n                        return !hasValidAlignment(expectedColumnNumberTabsExpanded, columnNumber);\n            })\n            .ifPresent(columnNumber -> {\n                        logViolation(javadocEndToken.getLineNo(),\n                        columnNumber,\n                        expectedColumnNumberTabsExpanded);\n            });\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "19", "src_id": "M284", "code": "private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return line            < entry.getLastLine() \n        || entry.getLastLine() == line && column <= entry\n        .getLastColumn();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "20", "src_id": "M294", "code": "private static boolean canBeSubclassed(DetailAST classDef) {\n        final DetailAST modifiers = classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classDef.getType() != TokenTypes.ENUM_DEF\n        && modifiers.findFirstToken(TokenTypes.FINAL) == null\n        && hasDefaultOrExplicitNonPrivateCtor(classDef);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "21", "src_id": "M714", "code": "private static Set<DetailAST> getAllTokensOfType(DetailAST ast, int tokenType) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n\n        while (vertex != null || !stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n                }\n                while (vertex != null) {\n                        if (vertex.getType() == tokenType) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex = vertex.getFirstChild();\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "22", "src_id": "M504", "code": "@Override\npublic int[] getAcceptableTokens() {\n        return new int[] {\n        TokenTypes.SINGLE_LINE_COMMENT,\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "23", "src_id": "M207", "code": "public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n                extension = \"\";\n        }\n        else {\n                extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "24", "src_id": "M716", "code": "private static Set<DetailAST> getAllTokensWhichAreEqualToCurrent(DetailAST ast, \nDetailAST token,\nint endLineNumber) {\n        DetailAST vertex = ast;\n        final Set<DetailAST> result = new HashSet<>();\n        final Deque<DetailAST> stack = new ArrayDeque<>();\n        while (vertex != null || !stack.isEmpty()) {\n                if (!stack.isEmpty()) {\n                        vertex = stack.pop();\n                }\n                while (vertex != null) {\n                        if (isAstSimilar(token, vertex)\n                        && vertex.getLineNo() <= endLineNumber) {\n                                result.add(vertex);\n                        }\n                        if (vertex.getNextSibling() != null) {\n                                stack.push(vertex.getNextSibling());\n                        }\n                        vertex = vertex.getFirstChild();\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "25", "src_id": "M293", "code": "private static DetailAST getNearestClassOrEnumDefinition(DetailAST ast) {\n        DetailAST searchAST = ast;\n        while (searchAST.getType() != TokenTypes.CLASS_DEF\n        && searchAST.getType() != TokenTypes.ENUM_DEF) {\n                searchAST = searchAST.getParent();\n        }\n        return searchAST;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "26", "src_id": "M704", "code": "private boolean isForwardReference(DetailAST fieldDef) {\n        final DetailAST exprStartIdent = fieldDef.findFirstToken(TokenTypes.IDENT);\n        final Set<DetailAST> exprIdents = getAllTokensOfType(exprStartIdent, TokenTypes.IDENT);\n        boolean forwardReference = false;\n        for (DetailAST ident : exprIdents) {\n                if (classFieldNames.contains(ident.getText())) {\n                        forwardReference = true;\n                        break;\n                }\n        }\n\n        return forwardReference;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "177", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n            return CommonUtil.createPattern(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "178", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n            return SeverityLevel.getInstance(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "179", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n            final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n            registerIntegralTypes(cub);\n            registerCustomTypes(cub);\n\n            return new BeanUtilsBean(cub, new PropertyUtilsBean());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "180", "src_id": "M4", "code": "@Override\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n            configuration = config;\n\n            final String[] attributes = config.getPropertyNames();\n\n            for (final String key : attributes) {\n                        final String value = config.getProperty(key);\n\n                        tryCopyProperty(key, value, true);\n            }\n\n            finishLocalSetup();\n\n            final Configuration[] childConfigs = config.getChildren();\n            for (final Configuration childConfig : childConfigs) {\n                        setupChild(childConfig);\n            }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "181", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n            final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n            final String annotationString;\n\n            // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n            if (identNode != null) {\n                        annotationString = identNode.getText();\n            }\n            else {\n                        final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n                        annotationString = FullIdent.createFullIdent(dotNode).getText();\n            }\n\n            return annotationString;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "84", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "85", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "121", "src_id": "M601", "code": "@Override\npublic void beginTree(DetailAST root) {\n        variables.clear();\n        typeDeclarations.clear();\n        typeDeclAstToTypeDeclDesc.clear();\n        anonInnerAstToTypeDeclDesc.clear();\n        anonInnerClassHolders.clear();\n        packageName=null;\n        depth=0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "122", "src_id": "M600", "code": "@Override\npublic int[] getDefaultTokens() {\n        return new int[] {\n        TokenTypes.DOT,\n        TokenTypes.VARIABLE_DEF,\n        TokenTypes.IDENT,\n        TokenTypes.SLIST,\n        TokenTypes.LITERAL_FOR,\n        TokenTypes.OBJBLOCK,\n        TokenTypes.CLASS_DEF,\n        TokenTypes.INTERFACE_DEF,\n        TokenTypes.ANNOTATION_DEF,\n        TokenTypes.PACKAGE_DEF,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.CTOR_DEF,\n        TokenTypes.STATIC_INIT,\n        TokenTypes.INSTANCE_INIT,\n        TokenTypes.COMPILATION_UNIT,\n        TokenTypes.LAMBDA,\n        TokenTypes.ENUM_DEF,\n        TokenTypes.RECORD_DEF,\n        TokenTypes.COMPACT_CTOR_DEF,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "123", "src_id": "M615", "code": "private void iterateOverBlockContainingLocalAnonInnerClass(\nDetailAST ast, Deque<VariableDesc> variablesStack) {\n        DetailAST currNode=ast;\n        while (currNode!=null) {\n                customVisitToken(currNode, variablesStack);\n                DetailAST toVisit=currNode.getFirstChild();\n                while (currNode!=ast&&toVisit==null) {\n                        customLeaveToken(currNode, variablesStack);\n                        toVisit=currNode.getNextSibling();\n                        currNode=currNode.getParent();\n                }\n                currNode=toVisit;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "124", "src_id": "M383", "code": "private static void extractInlineTagContent(DetailNode node,\nStringBuilder customTagContent) {\n        final DetailNode[] children=node.getChildren();\n        if (children.length==0) {\n                customTagContent.append(node.getText());\n        }\n        else {\n                for (DetailNode child : children) {\n                        if (child.getType()!=JavadocTokenTypes.LEADING_ASTERISK) {\n                                extractInlineTagContent(child, customTagContent);\n                        }\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "125", "src_id": "M593", "code": "private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType()==TokenTypes.IDENT) {\n                parameterNames.add(ast.getText());\n        }\n        else {\n                visitParameters(ast);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "126", "src_id": "M175", "code": "@Override\npublic void auditFinished(AuditEvent event) {\n        errorWriter.flush();\n        if (closeErrorWriter) {\n                errorWriter.close();\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "127", "src_id": "M603", "code": "@Override\npublic void leaveToken(DetailAST ast) {\n        if (!(TokenUtil.isOfType(ast, SCOPES))) {\n                if (ast.getType()==TokenTypes.COMPILATION_UNIT) {\n                        leaveCompilationUnit();\n                }\n                else {\n                        if (isNonLocalTypeDeclaration(ast)) {\n                                depth--;\n                                typeDeclarations.pop();\n                        }\n                }\n        }\n        else {\n                logViolations(ast, variables);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "27", "src_id": "M697", "code": "@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,                              DetailAST bound, int neededTokenType) {\n\n        DetailAST match = null;\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n                        break;\n                }\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "28", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; \n        astNode != null;\n        astNode = astNode.getLastChild()) {\n                previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "29", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n                }\n\n        }\n        return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "128", "src_id": "M347", "code": "@Override\npublic void visitToken(DetailAST ast) {\n            switch (ast.getType()) {\n                        case TokenTypes.IDENT:\n                                    if (collect) {\n                                                processIdent(ast);\n                                    }\n                                    break;\n                        case TokenTypes.IMPORT:\n                                    processImport(ast);\n                                    break;\n                        case TokenTypes.STATIC_IMPORT:\n                                    processStaticImport(ast);\n                                    break;\n                        case TokenTypes.OBJBLOCK:\n                        case TokenTypes.SLIST:\n                                    currentFrame = currentFrame.push();\n                                    break;\n                        default:\n                                    collect = true;\n                                    if (processJavadoc) {\n                                                collectReferencesFromJavadoc(ast);\n                                    }\n                                    break;\n            }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "129", "src_id": "M394", "code": "@Override\npublic int[] getRequiredJavadocTokens() {\n            return new int[] {\n            JavadocTokenTypes.TEXT,\n            };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "130", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n            DetailAST result;\n            if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                        result = node.getPreviousSibling();\n            }\n            else {\n                        if (isInPatternDefinition(node)) {\n                                    result = node.getFirstChild();\n                        }\n                        else {\n                                    result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n                        }\n            }\n            while (result.getLastChild() != null) {\n                        result = result.getLastChild();\n            }\n            return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "182", "src_id": "M697", "code": "@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,                              DetailAST bound, int neededTokenType) {\n\n        DetailAST match=null;\n\n        DetailAST iteratedBranch=shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch!=null) {\n                if (iteratedBranch.getType()==neededTokenType) {\n                        match=iteratedBranch;\n                        break;\n                }\n\n                iteratedBranch=shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "183", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n        DetailAST previousSibling=parentToken.getPreviousSibling();\n        for (DetailAST astNode=previousSibling; \n        astNode!=null;\n        astNode=astNode.getLastChild()) {\n                previousSibling=astNode;\n        }\n\n        return token.getLineNo()!=previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "184", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n        final DetailAST branchLeadingToReassignedVar=getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents=new ArrayList<>();\n        for (DetailAST expressionBranch=branchLeadingToReassignedVar;\n        expressionBranch!=null;\n        expressionBranch=traverseUntilNeededBranchType(expressionBranch,                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n                final DetailAST assignToken=getMatchedAssignToken(expressionBranch);\n                if (assignToken==null) { \n                        continue ; \n                }  \n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n        }\n\n        return reassignedVariableIdents;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "30", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "31", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "86", "src_id": "M37", "code": "private ModuleType getModuleType() {\n        final String simpleModuleName=getModuleSimpleName();\n        final ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n                result=ModuleType.FILEFILTER;\n        }\n        else {\n                if (simpleModuleName.endsWith(\"Filter\")) {\n                        result=ModuleType.FILTER;\n                }\n                else {\n                        result=ModuleType.CHECK;\n                }\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "87", "src_id": "M28", "code": "private void scrapeContent(DetailNode ast) {\n        if (ast.getType()!=JavadocTokenTypes.PARAGRAPH) {\n\n                if (ast.getType()==JavadocTokenTypes.LI) {\n                        if (!(isPropertyList(ast))) {\n                                if (scrapingViolationMessageList) {\n                                        moduleDetails.addToViolationMessages(getViolationMessages(ast));\n                                }\n                        }\n                        else {\n                                if (propertySectionStartIdx==-1) {\n                                        propertySectionStartIdx=getParentIndexOf(ast);\n                                }\n                                moduleDetails.addToProperties(createProperties(ast));\n                        }\n                }\n        }\n        else {\n\n                if (!(isParentText(ast))) {\n                        if (isViolationMessagesText(ast)) {\n                                scrapingViolationMessageList=true;\n                        }\n                        else {\n                                if (exampleSectionStartIdx==-1&&isExamplesText(ast)) {\n                                        exampleSectionStartIdx=getParentIndexOf(ast);\n                                }\n                        }\n                }\n                else {\n                        parentSectionStartIdx=getParentIndexOf(ast);\n                        moduleDetails.setParent(getParentText(ast));\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "88", "src_id": "M27", "code": "@Override\npublic void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n                moduleDetails=new ModuleDetails();\n                toScan=false;\n                scrapingViolationMessageList=false;\n                propertySectionStartIdx=-1;\n                exampleSectionStartIdx=-1;\n                parentSectionStartIdx=-1;\n\n                String moduleName=getModuleSimpleName();\n                final String checkModuleExtension=\"Check\";\n                if (moduleName.endsWith(checkModuleExtension)) {\n                        moduleName=moduleName\n                        .substring(0, moduleName.length()-checkModuleExtension.length());\n                }\n                moduleDetails.setName(moduleName);\n                moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n                moduleDetails.setModuleType(getModuleType());\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "89", "src_id": "M35", "code": "private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\nPattern pattern) {\n        return Arrays.stream(node.getChildren())\n        .filter(child->pattern.matcher(child.getText()).matches())\n        .findFirst();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "131", "src_id": "M697", "code": "@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,                              DetailAST bound, int neededTokenType) {\n\n        DetailAST match = null;\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n                        break;\n                }\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "132", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; \n        astNode != null;\n        astNode = astNode.getLastChild()) {\n                previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "133", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n                }\n\n        }\n        return reassignedVariableIdents;\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "185", "src_id": "M310", "code": "@Override\npublic int[] getAcceptableTokens() {\n        return new int[] {\n        TokenTypes.CTOR_DEF,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.EXPR,\n        TokenTypes.LAND,\n        TokenTypes.BAND,\n        TokenTypes.LOR,\n        TokenTypes.BOR,\n        TokenTypes.BXOR,\n        TokenTypes.COMPACT_CTOR_DEF,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "186", "src_id": "M200", "code": "public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result=false;\n        if (fileExtensions==null||fileExtensions.length==0) {\n                result=true;\n        }\n        else {\n                // normalize extensions so all of them have a leading dot\n                final String[] withDotExtensions=new String[fileExtensions.length];\n                for (int i=0; i<fileExtensions.length; i++) {\n                        final String extension=fileExtensions[i];\n                        if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                                withDotExtensions[i]=extension;\n                        }\n                        else {\n                                withDotExtensions[i]=EXTENSION_SEPARATOR+extension;\n                        }\n                }\n\n                final String fileName=file.getName();\n                for (final String fileExtension : withDotExtensions) {\n                        if (!(fileName.endsWith(fileExtension))) { \n                                continue ; \n                        }  \n                        result=true;\n                        break;\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "187", "src_id": "M201", "code": "public static int lengthMinusTrailingWhitespace(String line) {\n        int len=line.length();\n        for (int i=len-1; i>=0; i--) {\n                if (!Character.isWhitespace(line.charAt(i))) {\n                        break;\n                }\n                len--;\n        }\n        return len;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "188", "src_id": "M255", "code": "private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result=false;\n        final List<DetailAST> methodAnnotationsList=getMethodAnnotationsList(methodDef);\n        for (DetailAST annotationNode : methodAnnotationsList) {\n                if (!(\"SafeVarargs\".equals(annotationNode.getLastChild().getText()))) { \n                        continue ; \n                }  \n                result=true;\n                break;\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "189", "src_id": "M689", "code": "@Override\npublic int[] getRequiredTokens() {\n        return new int[] {\n        TokenTypes.ASSIGN,            // '='\n        TokenTypes.DIV_ASSIGN,        // \"/=\"\n        TokenTypes.PLUS_ASSIGN,       // \"+=\"\n        TokenTypes.MINUS_ASSIGN,      // \"-=\"\n        TokenTypes.STAR_ASSIGN,       // \"*=\"\n        TokenTypes.MOD_ASSIGN,        // \"%=\"\n        TokenTypes.SR_ASSIGN,         // \">>=\"\n        TokenTypes.BSR_ASSIGN,        // \">>>=\"\n        TokenTypes.SL_ASSIGN,         // \"<<=\"\n        TokenTypes.BXOR_ASSIGN,       // \"^=\"\n        TokenTypes.BOR_ASSIGN,        // \"|=\"\n        TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "90", "src_id": "M37", "code": "private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        final ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n                result = ModuleType.FILEFILTER;\n        }\n        else {\n                if (simpleModuleName.endsWith(\"Filter\")) {\n                        result = ModuleType.FILTER;\n                }\n                else {\n                        result = ModuleType.CHECK;\n                }\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "91", "src_id": "M28", "code": "private void scrapeContent(DetailNode ast) {\n        if (ast.getType() != JavadocTokenTypes.PARAGRAPH) {\n                if (ast.getType() == JavadocTokenTypes.LI) {\n                        if (!(isPropertyList(ast))) {\n                                if (scrapingViolationMessageList) {\n                                        moduleDetails.addToViolationMessages(getViolationMessages(ast));\n                                }\n                        }\n                        else {\n                                if (propertySectionStartIdx == -1) {\n                                        propertySectionStartIdx = getParentIndexOf(ast);\n                                }\n                                moduleDetails.addToProperties(createProperties(ast));\n                        }\n                }\n        }\n        else {\n                if (!(isParentText(ast))) {\n                        if (isViolationMessagesText(ast)) {\n                                scrapingViolationMessageList = true;\n                        }\n                        else {\n                                if (exampleSectionStartIdx == -1\n                                && isExamplesText(ast)) {\n                                        exampleSectionStartIdx = getParentIndexOf(ast);\n                                }\n                        }\n                }\n                else {\n                        parentSectionStartIdx = getParentIndexOf(ast);\n                        moduleDetails.setParent(getParentText(ast));\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "92", "src_id": "M27", "code": "@Override\npublic void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n                moduleDetails = new ModuleDetails();\n                toScan = false;\n                scrapingViolationMessageList = false;\n                propertySectionStartIdx = -1;\n                exampleSectionStartIdx = -1;\n                parentSectionStartIdx = -1;\n\n                String moduleName = getModuleSimpleName();\n                final String checkModuleExtension = \"Check\";\n                if (moduleName.endsWith(checkModuleExtension)) {\n                        moduleName = moduleName\n                        .substring(0, moduleName.length() - checkModuleExtension.length());\n                }\n                moduleDetails.setName(moduleName);\n                moduleDetails.setFullQualifiedName(getPackageName(getFilePath()));\n                moduleDetails.setModuleType(getModuleType());\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "93", "src_id": "M35", "code": "private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\nPattern pattern) {\n        return Arrays.stream(node.getChildren())\n        .filter(child -> pattern.matcher(child.getText()).matches())\n        .findFirst();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "32", "src_id": "M597", "code": "private void checkTypeDefinition(DetailAST ast) {\n        if (!ScopeUtil.isOuterMostType(ast)&&isSemicolon(ast.getNextSibling())) {\n                log(ast.getNextSibling(), MSG_SEMI);\n        }\n        final DetailAST firstMember =\n        ast.findFirstToken(TokenTypes.OBJBLOCK).getFirstChild().getNextSibling();\n        if (isSemicolon(firstMember)&&!ScopeUtil.isInEnumBlock(firstMember)) {\n                log(firstMember, MSG_SEMI);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "33", "src_id": "M655", "code": "private void checkLambda(DetailAST ast, DetailAST currentStatement) {\n        int countOfSemiInCurrentLambda=countOfSemiInLambda.pop();\n        countOfSemiInCurrentLambda++;\n        countOfSemiInLambda.push(countOfSemiInCurrentLambda);\n        if (!inForHeader&&countOfSemiInCurrentLambda>1\n        &&isOnTheSameLine(currentStatement,                lastStatementEnd, forStatementEnd,\n        lambdaStatementEnd)) {\n                log(ast, MSG_KEY);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "34", "src_id": "M587", "code": "@Override\npublic void visitToken(DetailAST ast) {\n        final DetailAST enumBlock=ast.findFirstToken(TokenTypes.OBJBLOCK);\n        final DetailAST semicolon=enumBlock.findFirstToken(TokenTypes.SEMI);\n        if (semicolon!=null&&isEndOfEnumerationAfter(semicolon)) {\n                log(semicolon, MSG_SEMI);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "35", "src_id": "M202", "code": "public static InputSource sourceFromFilename(String filename) throws CheckstyleException {\n        // figure out if this is a File or a URL\n        final URI uri=getUriByFilename(filename);\n        return new InputSource(uri.toASCIIString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "36", "src_id": "M633", "code": "@Override\npublic int[] getAcceptableTokens() {\n        return new int[] {\n        TokenTypes.CLASS_DEF,\n        TokenTypes.INTERFACE_DEF,\n        TokenTypes.ENUM_DEF,\n        TokenTypes.ANNOTATION_DEF,\n        TokenTypes.RECORD_DEF,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "37", "src_id": "M285", "code": "private static void addSuppressions(List<String> values, \nDetailAST targetAST) {\n        // get text range of target\n        final int firstLine=targetAST.getLineNo();\n        final int firstColumn=targetAST.getColumnNo();\n        final DetailAST nextAST=targetAST.getNextSibling();\n        final int lastLine;\n        final int lastColumn;\n        if (nextAST==null) {\n                lastLine=Integer.MAX_VALUE;\n                lastColumn=Integer.MAX_VALUE;\n        }\n        else {\n                lastLine=nextAST.getLineNo();\n                lastColumn=nextAST.getColumnNo();\n        }\n\n        final List<Entry> entries=ENTRIES.get();\n\n        for (String value : values) {\n                // strip off the checkstyle-only prefix if present\n                final String checkName=removeCheckstylePrefixIfExists(value);\n                entries.add(new Entry(checkName, firstLine, firstColumn,\n                lastLine, lastColumn));\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "38", "src_id": "M276", "code": "@Override\npublic void visitToken(DetailAST ast) {\n        if (ast.getParent().getType()!=TokenTypes.SWITCH_RULE) {\n                final int length=getLength(ast);\n                if (length>max) {\n                        log(ast, MSG_KEY, length, max);\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "39", "src_id": "M279", "code": "private static int getFirstNodeLineNumber(DetailAST lambdaBody) {\n        DetailAST node=lambdaBody;\n        int result;\n        do {\n                result=node.getLineNo();\n                node=node.getFirstChild();\n        } while (node!=null);\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "94", "src_id": "M485", "code": "private static Pattern createPatternFromLine(String line) {\n        final Pattern result;\n        if (line.isEmpty()) {\n                result = BLANK_LINE;\n        }\n        else {\n                result = Pattern.compile(validateRegex(line));\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "95", "src_id": "M478", "code": "public String getConfiguredHeaderPaths() {\n        return headerFilesMetadata.stream()\n        .map(HeaderFileMetadata::getHeaderFilePath)\n        .collect(Collectors.joining(\", \"));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "190", "src_id": "M310", "code": "@Override\npublic int[] getAcceptableTokens() {\n            return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.EXPR,\n            TokenTypes.LAND,\n            TokenTypes.BAND,\n            TokenTypes.LOR,\n            TokenTypes.BOR,\n            TokenTypes.BXOR,\n            TokenTypes.COMPACT_CTOR_DEF,\n            };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "191", "src_id": "M200", "code": "public static boolean matchesFileExtension(File file, String... fileExtensions) {\n            boolean result = false;\n            if (fileExtensions == null || fileExtensions.length == 0) {\n                        result = true;\n            }\n            else {\n                        // normalize extensions so all of them have a leading dot\n                        final String[] withDotExtensions = new String[fileExtensions.length];\n                        for (int i = 0; i < fileExtensions.length; i++) {\n                                    final String extension = fileExtensions[i];\n                                    if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                                                withDotExtensions[i] = extension;\n                                    }\n                                    else {\n                                                withDotExtensions[i] = EXTENSION_SEPARATOR + extension;\n                                    }\n                        }\n\n                        final String fileName = file.getName();\n                        for (final String fileExtension : withDotExtensions) {\n                                    if (fileName.endsWith(fileExtension)) {\n                                                result = true;\n                                                break;\n                                    }\n                        }\n            }\n\n            return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "192", "src_id": "M201", "code": "public static int lengthMinusTrailingWhitespace(String line) {\n            int len = line.length();\n            for (int i = len - 1; i >= 0; i--) {\n                        if (!Character.isWhitespace(line.charAt(i))) {\n                                    break;\n                        }\n                        len--;\n            }\n            return len;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "193", "src_id": "M255", "code": "private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n            boolean result = false;\n            final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n\n            for (DetailAST annotationNode : methodAnnotationsList) {\n                        if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                                    result = true;\n                                    break;\n                        }\n            }\n            return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "194", "src_id": "M689", "code": "@Override\npublic int[] getRequiredTokens() {\n            return new int[] {\n            TokenTypes.ASSIGN,            // '='\n            TokenTypes.DIV_ASSIGN,        // \"/=\"\n            TokenTypes.PLUS_ASSIGN,       // \"+=\"\n            TokenTypes.MINUS_ASSIGN,      // \"-=\"\n            TokenTypes.STAR_ASSIGN,       // \"*=\"\n            TokenTypes.MOD_ASSIGN,        // \"%=\"\n            TokenTypes.SR_ASSIGN,         // \">>=\"\n            TokenTypes.BSR_ASSIGN,        // \">>>=\"\n            TokenTypes.SL_ASSIGN,         // \"<<=\"\n            TokenTypes.BXOR_ASSIGN,       // \"^=\"\n            TokenTypes.BOR_ASSIGN,        // \"|=\"\n            TokenTypes.BAND_ASSIGN,       // \"&=\"\n            };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "40", "src_id": "M697", "code": "@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,                              DetailAST bound, int neededTokenType) {\n\n        DetailAST match = null;\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n                        break;\n                }\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "41", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; \n        astNode != null;\n        astNode = astNode.getLastChild()) {\n                previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "42", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n                if (assignToken == null) { \n                        continue ; \n                }  \n                reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n\n        }\n\n        return reassignedVariableIdents;\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "134", "src_id": "M502", "code": "private int expandedTabsColumnNo(DetailAST ast) {\n        final String line =\n        indentCheck.getLine(ast.getLineNo()-1);\n\n        return CommonUtil.lengthExpandedTabs(line, \n        ast.getColumnNo(),\n        indentCheck.getIndentationTabWidth());\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "135", "src_id": "M455", "code": "@Override\npublic void init() {\n        if (fileNamePattern==null&&folderPattern==null) {\n                fileNamePattern=CommonUtil.createPattern(\"\\\\s\");\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "136", "src_id": "M456", "code": "@Override\nprotected void processFiltered(File file, FileText fileText) throws CheckstyleException {\n        final String fileName=getFileName(file);\n        final String folderPath=getFolderPath(file);\n\n        if (isMatchFolder(folderPath)&&isMatchFile(fileName)) {\n                log();\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "137", "src_id": "M165", "code": "private AxisIterator getPrecedingSiblingsIterator() {\n        final AxisIterator result;\n        if (indexAmongSiblings==0) {\n                result=EmptyIterator.ofNodes();\n        }\n        else {\n                result=new ReverseListIterator(getPrecedingSiblings());\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "138", "src_id": "M750", "code": "private static String convertUpperCamelToUpperUnderscore(String text) {\n        final StringBuilder result=new StringBuilder(20);\n        boolean first=true;\n        for (char letter : text.toCharArray()) {\n                if (!first&&Character.isUpperCase(letter)) {\n                        result.append('_');\n                }\n                result.append(Character.toUpperCase(letter));\n                first=false;\n        }\n        return result.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "139", "src_id": "M346", "code": "@Override\nprotected boolean matchesExactly(String pkg, String fileName) {\n        final boolean result;\n        if (fileName==null) {\n                result=false;\n        }\n        else {\n                if (regex) {\n                        result=patternForExactMatch.matcher(fileName).matches();\n                }\n                else {\n                        result=name.equals(fileName);\n                }\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "140", "src_id": "M706", "code": "@Override\npublic void beginTree(DetailAST rootAST) {\n        frames=new HashMap<>();\n        current.clear();\n        final Deque<AbstractFrame> frameStack=new LinkedList<>();\n        DetailAST curNode=rootAST;\n        while (curNode!=null) {\n                collectDeclarations(frameStack, curNode);\n                DetailAST toVisit=curNode.getFirstChild();\n                while (curNode!=null&&toVisit==null) {\n                        endCollectingDeclarations(frameStack, curNode);\n                        toVisit=curNode.getNextSibling();\n                        curNode=curNode.getParent();\n                }\n                curNode=toVisit;\n        }\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "141", "src_id": "M308", "code": "@Override\npublic void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n                case TokenTypes.CTOR_DEF:\n                case TokenTypes.METHOD_DEF:\n                case TokenTypes.INSTANCE_INIT:\n                case TokenTypes.STATIC_INIT:\n                case TokenTypes.COMPACT_CTOR_DEF:\n                        leaveMethodDef(ast);\n                        break;\n                default:\n                        break;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "142", "src_id": "M167", "code": "private AttributeNode getAttributeNode() {\n        if (attributeNode==ATTRIBUTE_NODE_UNINITIALIZED) {\n                attributeNode=createAttributeNode();\n        }\n        return attributeNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "143", "src_id": "M398", "code": "@Override\npublic int[] getDefaultTokens() {\n        return new int[] {\n        TokenTypes.BLOCK_COMMENT_BEGIN,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "195", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "196", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "197", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "198", "src_id": "M4", "code": "@Override\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n                final String value = config.getProperty(key);\n\n                tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n                setupChild(childConfig);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "199", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode != null) {\n                annotationString = identNode.getText();\n        }\n        else {\n                final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n                annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n\n        return annotationString;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "144", "src_id": "M8", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return CommonUtil.createPattern(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "145", "src_id": "M10", "code": "@SuppressWarnings(\"unchecked\")\n@Override\npublic Object convert(Class type, Object value) {\n        return SeverityLevel.getInstance(value.toString());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "146", "src_id": "M1", "code": "private static BeanUtilsBean createBeanUtilsBean() {\n        final ConvertUtilsBean cub = new ConvertUtilsBean();\n\n        registerIntegralTypes(cub);\n        registerCustomTypes(cub);\n\n        return new BeanUtilsBean(cub, new PropertyUtilsBean());\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "147", "src_id": "M4", "code": "@Override\npublic final void configure(Configuration config)\nthrows CheckstyleException {\n        configuration = config;\n\n        final String[] attributes = config.getPropertyNames();\n\n        for (final String key : attributes) {\n                final String value = config.getProperty(key);\n\n                tryCopyProperty(key, value, true);\n        }\n\n        finishLocalSetup();\n\n        final Configuration[] childConfigs = config.getChildren();\n        for (final Configuration childConfig : childConfigs) {\n                setupChild(childConfig);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "148", "src_id": "M196", "code": "private static String getAnnotationFullIdent(DetailAST annotationNode) {\n        final DetailAST identNode = annotationNode.findFirstToken(TokenTypes.IDENT);\n        final String annotationString;\n\n        // If no `IDENT` is found, then we have a `DOT` -> more than 1 qualifier\n        if (identNode == null) {\n                final DetailAST dotNode = annotationNode.findFirstToken(TokenTypes.DOT);\n                annotationString = FullIdent.createFullIdent(dotNode).getText();\n        }\n        else {\n                annotationString = identNode.getText();\n        }\n\n        return annotationString;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "43", "src_id": "M347", "code": "@Override\npublic void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n                case TokenTypes.IDENT:\n                        if (collect) {\n                                processIdent(ast);\n                        }\n                        break;\n                case TokenTypes.IMPORT:\n                        processImport(ast);\n                        break;\n                case TokenTypes.STATIC_IMPORT:\n                        processStaticImport(ast);\n                        break;\n                case TokenTypes.OBJBLOCK:\n                case TokenTypes.SLIST:\n                        currentFrame = currentFrame.push();\n                        break;\n                default:\n                        collect = true;\n                        if (processJavadoc) {\n                                collectReferencesFromJavadoc(ast);\n                        }\n                        break;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "44", "src_id": "M394", "code": "@Override\npublic int[] getRequiredJavadocTokens() {\n        return new int[] {\n        JavadocTokenTypes.TEXT,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "45", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                result = node.getPreviousSibling();\n        }\n        else {\n                if (isInPatternDefinition(node)) {\n                        result = node.getFirstChild();\n                }\n                else {\n                        result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n                }\n        }\n        while (result.getLastChild() != null) {\n                result = result.getLastChild();\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "96", "src_id": "M601", "code": "@Override\npublic void beginTree(DetailAST root) {\n        variables.clear();\n        typeDeclarations.clear();\n        typeDeclAstToTypeDeclDesc.clear();\n        anonInnerAstToTypeDeclDesc.clear();\n        anonInnerClassHolders.clear();\n        packageName = null;\n        depth = 0;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "97", "src_id": "M600", "code": "@Override\npublic int[] getDefaultTokens() {\n        return new int[] {\n        TokenTypes.DOT,\n        TokenTypes.VARIABLE_DEF,\n        TokenTypes.IDENT,\n        TokenTypes.SLIST,\n        TokenTypes.LITERAL_FOR,\n        TokenTypes.OBJBLOCK,\n        TokenTypes.CLASS_DEF,\n        TokenTypes.INTERFACE_DEF,\n        TokenTypes.ANNOTATION_DEF,\n        TokenTypes.PACKAGE_DEF,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.CTOR_DEF,\n        TokenTypes.STATIC_INIT,\n        TokenTypes.INSTANCE_INIT,\n        TokenTypes.COMPILATION_UNIT,\n        TokenTypes.LAMBDA,\n        TokenTypes.ENUM_DEF,\n        TokenTypes.RECORD_DEF,\n        TokenTypes.COMPACT_CTOR_DEF,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "98", "src_id": "M615", "code": "private void iterateOverBlockContainingLocalAnonInnerClass(DetailAST ast, Deque<VariableDesc> variablesStack) {\n        DetailAST currNode = ast;\n        while (currNode != null) {\n                customVisitToken(currNode, variablesStack);\n                DetailAST toVisit = currNode.getFirstChild();\n                while (currNode != ast && toVisit == null) {\n                        customLeaveToken(currNode, variablesStack);\n                        toVisit = currNode.getNextSibling();\n                        currNode = currNode.getParent();\n                }\n                currNode = toVisit;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "99", "src_id": "M383", "code": "private static void extractInlineTagContent(DetailNode node,\nStringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n                customTagContent.append(node.getText());\n        }\n        else {\n                for (DetailNode child : children) {\n                        if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                                extractInlineTagContent(child, customTagContent);\n                        }\n                }\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "100", "src_id": "M593", "code": "private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n                parameterNames.add(ast.getText());\n        }\n        else {\n                visitParameters(ast);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "101", "src_id": "M175", "code": "@Override\npublic void auditFinished(AuditEvent event) {\n        errorWriter.flush();\n        if (closeErrorWriter) {\n                errorWriter.close();\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "102", "src_id": "M603", "code": "@Override\npublic void leaveToken(DetailAST ast) {\n        if (!(TokenUtil.isOfType(ast, SCOPES))) {\n                if (ast.getType() == TokenTypes.COMPILATION_UNIT) {\n                        leaveCompilationUnit();\n                }\n                else {\n                        if (isNonLocalTypeDeclaration(ast)) {\n                                depth--;\n                                typeDeclarations.pop();\n                        }\n                }\n        }\n        else {\n                logViolations(ast, variables);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "149", "src_id": "M347", "code": "@Override\npublic void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n                case TokenTypes.IDENT:\n                        if (collect) {\n                                processIdent(ast);\n                        }\n                        break;\n                case TokenTypes.IMPORT:\n                        processImport(ast);\n                        break;\n                case TokenTypes.STATIC_IMPORT:\n                        processStaticImport(ast);\n                        break;\n                case TokenTypes.OBJBLOCK:\n                case TokenTypes.SLIST:\n                        currentFrame = currentFrame.push();\n                        break;\n                default:\n                        collect = true;\n                        if (processJavadoc) {\n                                collectReferencesFromJavadoc(ast);\n                        }\n                        break;\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "150", "src_id": "M394", "code": "@Override\npublic int[] getRequiredJavadocTokens() {\n        return new int[] {\n        JavadocTokenTypes.TEXT,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "151", "src_id": "M571", "code": "private static DetailAST getLeftNode(DetailAST node) {\n        DetailAST result;\n        if (node.getFirstChild() == null || isAssignToVariable(node)) {\n                result = node.getPreviousSibling();\n        }\n        else {\n                if (isInPatternDefinition(node)) {\n                        result = node.getFirstChild();\n                }\n                else {\n                        result = adjustParens(node.getFirstChild(), DetailAST::getNextSibling);\n                }\n        }\n        while (result.getLastChild() != null) {\n                result = result.getLastChild();\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "152", "src_id": "M310", "code": "@Override\npublic int[] getAcceptableTokens() {\n        return new int[] {\n        TokenTypes.CTOR_DEF,\n        TokenTypes.METHOD_DEF,\n        TokenTypes.EXPR,\n        TokenTypes.LAND,\n        TokenTypes.BAND,\n        TokenTypes.LOR,\n        TokenTypes.BOR,\n        TokenTypes.BXOR,\n        TokenTypes.COMPACT_CTOR_DEF,\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "153", "src_id": "M200", "code": "public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result=false;\n        if (fileExtensions==null||fileExtensions.length==0) {\n                result=true;\n        }\n        else {\n                // normalize extensions so all of them have a leading dot\n                final String[] withDotExtensions=new String[fileExtensions.length];\n                for (int i=0; fileExtensions.length>i; i++) {\n                        final String extension=fileExtensions[i];\n                        if (extension.startsWith(EXTENSION_SEPARATOR)) {\n                                withDotExtensions[i]=extension;\n                        }\n                        else {\n                                withDotExtensions[i]=EXTENSION_SEPARATOR+extension;\n                        }\n                }\n\n                final String fileName=file.getName();\n                for (final String fileExtension : withDotExtensions) {\n                        if (fileName.endsWith(fileExtension)) {\n                                result=true;\n                                break;\n                        }\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "154", "src_id": "M201", "code": "public static int lengthMinusTrailingWhitespace(String line) {\n        int len=line.length();\n        for (int i=len-1; i>=0; i--) {\n                if (!Character.isWhitespace(line.charAt(i))) {\n                        break;\n                }\n                len--;\n        }\n        return len;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "155", "src_id": "M255", "code": "private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result=false;\n\n        final List<DetailAST> methodAnnotationsList=getMethodAnnotationsList(methodDef);\n\n        for (DetailAST annotationNode : methodAnnotationsList) {\n                if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                        result=true;\n                        break;\n                }\n        }\n\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "156", "src_id": "M689", "code": "@Override\npublic int[] getRequiredTokens() {\n        return new int[] {\n        TokenTypes.ASSIGN,            // '='\n        TokenTypes.DIV_ASSIGN,        // \"/=\"\n        TokenTypes.PLUS_ASSIGN,       // \"+=\"\n        TokenTypes.MINUS_ASSIGN,      // \"-=\"\n        TokenTypes.STAR_ASSIGN,       // \"*=\"\n        TokenTypes.MOD_ASSIGN,        // \"%=\"\n        TokenTypes.SR_ASSIGN,         // \">>=\"\n        TokenTypes.BSR_ASSIGN,        // \">>>=\"\n        TokenTypes.SL_ASSIGN,         // \"<<=\"\n        TokenTypes.BXOR_ASSIGN,       // \"^=\"\n        TokenTypes.BOR_ASSIGN,        // \"|=\"\n        TokenTypes.BAND_ASSIGN,       // \"&=\"\n        };\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "46", "src_id": "M79", "code": "private static Stream<?> getValuesStream(Object value) {\n        final Stream<?> valuesStream;\n        if (value instanceof Collection) {\n                final Collection<?> collection = (Collection<?>) value;\n                valuesStream = collection.stream();\n        }\n        else {\n                final Object[] array = (Object[]) value;\n                valuesStream = Arrays.stream(array);\n        }\n        return valuesStream;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "47", "src_id": "M103", "code": "@Override\npublic void body() {\n        write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding + \"\\\"?>\");\n        writeEOL();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "48", "src_id": "M72", "code": "private static DetailNode getSinceJavadocTag(DetailNode javadoc) {\n        final DetailNode[] children = javadoc.getChildren();\n        DetailNode javadocTagWithSince = null;\n        for (final DetailNode child : children) {\n                if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                        final DetailNode sinceNode = JavadocUtil.findFirstToken(child, JavadocTokenTypes.SINCE_LITERAL);\n                        if (sinceNode != null) {\n                                javadocTagWithSince = child;\n                                break;\n                        }\n                }\n        }\n        return javadocTagWithSince;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "49", "src_id": "M46", "code": "private static String getLinkToParentModule(String parentModule, String moduleName)\nthrows MacroExecutionException {\n        final Path templatePath = SiteUtil.getTemplatePath(moduleName);\n        if (templatePath == null) {\n                throw new MacroExecutionException(\n                String.format(Locale.ROOT, \"Could not find template for %s\", moduleName));\n        }\n        final Path templatePathParent = templatePath.getParent();\n        if (templatePathParent == null) {\n                throw new MacroExecutionException(\"Failed to get parent path for \" + templatePath);\n        }\n        return templatePathParent\n        .relativize(Path.of(\"src\", \"site/xdoc\", \"config.xml\"))\n        .toString()\n        .replace(\".xml\", \".html\")\n        .replace('\\\\', '/')\n        + \"#\" + parentModule;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "50", "src_id": "M78", "code": "private static String getStringArrayPropertyValue(String propertyName, Object value) {\n        String result;\n        if (value != null) {\n                try (Stream<?> valuesStream = getValuesStream(value)) {\n                        result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(COMMA_SPACE));\n                }\n        }\n        else {\n                result = \"\";\n        }\n\n        if (result.isEmpty()) {\n                if (FILE_EXTENSIONS.equals(propertyName)) {\n                        result = \"all files\";\n                }\n                else {\n                        result = CURLY_BRACKETS;\n                }\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "51", "src_id": "M114", "code": "private static void createListItem(XdocSink sink\n, Class<?> clss, String messageKey) {\n        final String messageKeyUrl = constructMessageKeyUrl(clss, messageKey);\n        final String indentLevel10 = SiteUtil.getNewlineAndIndentSpaces(10);\n        final String indentLevel12 = SiteUtil.getNewlineAndIndentSpaces(12);\n        final String indentLevel14 = SiteUtil.getNewlineAndIndentSpaces(14);\n        // Place the <li>.\n        sink.rawText(indentLevel10);\n        // This is a hack to prevent a newline from being inserted by the default sink.\n        // Once we get rid of the custom parser, we can remove this.\n        // until https://github.com/checkstyle/checkstyle/issues/13426\n        sink.setInsertNewline(false);\n        sink.listItem();\n        sink.setInsertNewline(true);\n        // Place an <a>.\n        sink.rawText(indentLevel12);\n        sink.link(messageKeyUrl);\n        // Further indent the text.\n        sink.rawText(indentLevel14);\n        sink.rawText(messageKey);\n\n        // Place closing </a> and </li> tags.\n        sink.rawText(indentLevel12);\n        sink.link_();\n        sink.rawText(indentLevel10);\n        sink.listItem_();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "52", "src_id": "M58", "code": "private static Set<Field> getCheckMessageKeys(Class<?> module)            throws MacroExecutionException {\n        try {\n                final Set<Field> checkstyleMessages = new HashSet<>();\n                // get all fields from current class\n                final Field[] fields = module.getDeclaredFields();\n                for (Field field : fields) {\n                        if (field.getName().startsWith(\"MSG_\")) {\n                                checkstyleMessages.add(field);\n                        }\n                }\n                // deep scan class through hierarchy\n                final Class<?> superModule = module.getSuperclass();\n                if (superModule != null) {\n                        checkstyleMessages.addAll(getCheckMessageKeys(superModule));\n                }\n                // special cases that require additional classes\n                if (module != RegexpMultilineCheck.class) {\n                        if (module == RegexpSinglelineCheck.class\n                        || module == RegexpSinglelineJavaCheck.class) {\n                                checkstyleMessages.addAll(getCheckMessageKeys(Class\n                                .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.SinglelineDetector\")));\n                        }\n                }\n                else {\n                        checkstyleMessages.addAll(getCheckMessageKeys(Class\n                        .forName(\"com.puppycrawl.tools.checkstyle.checks.regexp.MultilineDetector\")));\n                }\n\n                return checkstyleMessages;\n        }\n        catch (ClassNotFoundException exc) {\n                final String message = String.format(Locale.ROOT, \n                \"Couldn't find class: %s\",\n                module.getName());\n                throw new MacroExecutionException(message, exc);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "53", "src_id": "M68", "code": "private static Set<String> getNonExplicitProperties(Object instance, Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n\n                final int[] acceptableTokens = check.getAcceptableTokens();\n                Arrays.sort(acceptableTokens);\n                final int[] defaultTokens = check.getDefaultTokens();\n                Arrays.sort(defaultTokens);\n                final int[] requiredTokens = check.getRequiredTokens();\n                Arrays.sort(requiredTokens);\n\n                if (!Arrays.equals(acceptableTokens, defaultTokens)\n                || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                        result.add(TOKENS);\n                }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                result.add(\"violateExecutionOnNonTightHtml\");\n\n                final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n                Arrays.sort(acceptableJavadocTokens);\n                final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n                Arrays.sort(defaultJavadocTokens);\n                final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n                Arrays.sort(requiredJavadocTokens);\n\n                if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                        result.add(JAVADOC_TOKENS);\n                }\n        }\n\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n                result.add(FILE_EXTENSIONS);\n        }\n        return result;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "54", "src_id": "M65", "code": "private static void processModule(String moduleName, Path modulePath)\nthrows MacroExecutionException {\n        if (!Files.isRegularFile(modulePath)) {\n                final String message = String.format(Locale.ROOT,                    \"File %s is not a file. Please check the 'modulePath' property.\", modulePath);\n                throw new MacroExecutionException(message);\n        }\n        ClassAndPropertiesSettersJavadocScraper.initialize(moduleName);\n        final Checker checker = new Checker();\n        checker.setModuleClassLoader(Checker.class.getClassLoader());\n        final DefaultConfiguration scraperCheckConfig =\n        new DefaultConfiguration(ClassAndPropertiesSettersJavadocScraper.class.getName());\n        final DefaultConfiguration defaultConfiguration =\n        new DefaultConfiguration(\"configuration\");\n        final DefaultConfiguration treeWalkerConfig =\n        new DefaultConfiguration(TreeWalker.class.getName());\n        defaultConfiguration.addProperty(CHARSET, StandardCharsets.UTF_8.name());\n        defaultConfiguration.addChild(treeWalkerConfig);\n        treeWalkerConfig.addChild(scraperCheckConfig);\n        try {\n                checker.configure(defaultConfiguration);\n                final List<File> filesToProcess = List.of(modulePath.toFile());\n\n                checker.process(filesToProcess);\n                checker.destroy();\n        }\n        catch (CheckstyleException checkstyleException) {\n                final String message = String.format(Locale.ROOT, \"Failed processing %s\", moduleName);\n                throw new MacroExecutionException(message, checkstyleException);\n        }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "55", "src_id": "M110", "code": "private static DetailAST getParentAst(DetailAST ast, int type) {\n        DetailAST node = ast.getParent();\n\n        while (node != null && node.getType() != type) {\n                node = node.getParent();\n        }\n\n        return node;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "checkstyle", "pair_id": "56", "src_id": "M697", "code": "@Nullable\nprivate static DetailAST traverseUntilNeededBranchType(DetailAST startingBranch,                              DetailAST bound, int neededTokenType) {\n\n        DetailAST match = null;\n\n        DetailAST iteratedBranch = shiftToNextTraversedBranch(startingBranch, bound);\n\n        while (iteratedBranch != null) {\n                if (iteratedBranch.getType() == neededTokenType) {\n                        match = iteratedBranch;\n                        break;\n                }\n\n                iteratedBranch = shiftToNextTraversedBranch(iteratedBranch, bound);\n        }\n\n        return match;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "57", "src_id": "M564", "code": "private static boolean isTokenNotOnPreviousSiblingLines(DetailAST token,\nDetailAST parentToken) {\n        DetailAST previousSibling = parentToken.getPreviousSibling();\n        for (DetailAST astNode = previousSibling; \n        astNode != null;\n        astNode = astNode.getLastChild()) {\n                previousSibling = astNode;\n        }\n\n        return token.getLineNo() != previousSibling.getLineNo();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "checkstyle", "pair_id": "58", "src_id": "M695", "code": "private static List<DetailAST> getReassignedVariableIdents(DetailAST ast) {\n\n        final DetailAST branchLeadingToReassignedVar = getBranchLeadingToReassignedVars(ast);\n\n        final List<DetailAST> reassignedVariableIdents = new ArrayList<>();\n        for (DetailAST expressionBranch = branchLeadingToReassignedVar;\n        expressionBranch != null;\n        expressionBranch = traverseUntilNeededBranchType(expressionBranch,                 branchLeadingToReassignedVar, TokenTypes.EXPR)) {\n\n                final DetailAST assignToken = getMatchedAssignToken(expressionBranch);\n\n                if (assignToken != null) {\n                        reassignedVariableIdents.add(getNeededAssignIdent(assignToken));\n                }\n\n        }\n\n        return reassignedVariableIdents;\n\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}

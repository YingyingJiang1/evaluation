{"project_name": "across-project", "pair_id": "1", "src_id": "M475", "code": "\n@Override\npublic void draw(CommandProcess process, JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n        String group = entry.getKey();\n        List<JvmItemVO> items = entry.getValue();\n\n        table.row(true, label(group).style(Decoration.bold.bold()));\n        for (JvmItemVO item : items) {\n            String valueStr;\n            if (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\n                valueStr = renderMemoryUsage((Map<String, Object>) item.getValue());\n            } else {\n                valueStr = renderItemValue(item.getValue());\n            }\n\n            String rowName = item.getName();\n            if (item.getDesc() != null) {\n                rowName += \"\\n[\" + item.getDesc() + \"]\";\n            }\n            table.row(rowName, valueStr);\n        }\n        table.row(\"\", \"\");\n    }\n\n    process.write(RenderUtil.render(table, process.width()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "2", "src_id": "M535", "code": "\npublic static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n    final StringBuilder infoSB = new StringBuilder();\n    List<String> classDumpFiles = affectVO.getClassDumpFiles();\n    if (classDumpFiles != null) {\n        for (String classDumpFile : classDumpFiles) {\n            infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n        }\n    }\n\n    List<String> methods = affectVO.getMethods();\n    if (methods != null) {\n        for (String method : methods) {\n            infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n        }\n    }\n\n    infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\",\n            affectVO.getClassCount(),\n            affectVO.getMethodCount(),\n            affectVO.getCost(),\n            affectVO.getListenerId()));\n    if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n        infoSB.append('\\n').append(affectVO.getOverLimitMsg());\n    }\n    if (affectVO.getThrowable() != null) {\n        infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n    }\n    infoSB.append('\\n');\n\n    return infoSB.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "3", "src_id": "M753", "code": "\npublic List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n\n    List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n\n    // First sample: initialize CPU times\n    if (lastCpuTimes.isEmpty()) {\n        lastSampleTimeNanos = System.nanoTime();\n        // Sample all threads\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                lastCpuTimes.put(thread, cpu);\n                thread.setTime(cpu / 1000000);\n            }\n        }\n\n        // Add internal threads\n        Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (internalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                String key = entry.getKey();\n                ThreadVO thread = createThreadVO(key);\n                thread.setTime(entry.getValue() / 1000000);\n                threads.add(thread);\n                lastCpuTimes.put(thread, entry.getValue());\n            }\n        }\n\n        // Sort by time in descending order\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n            @Override\n            public int compare(ThreadVO o1, ThreadVO o2) {\n                long l1 = o1.getTime();\n                long l2 = o2.getTime();\n                if (l1 < l2) {\n                    return 1;\n                } else if (l1 > l2) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            }\n        });\n        return threads;\n    }\n\n    // Resample: take new CPU times\n    long newSampleTimeNanos = System.nanoTime();\n    Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : threads) {\n        if (thread.getId() > 0) {\n            long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n            newCpuTimes.put(thread, cpu);\n        }\n    }\n\n    // Add internal threads in the resample\n    Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n    if (newInternalThreadCpuTimes != null) {\n        for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n            ThreadVO threadVO = createThreadVO(entry.getKey());\n            threads.add(threadVO);\n            newCpuTimes.put(threadVO, entry.getValue());\n        }\n    }\n\n    // Compute delta time for each thread\n    final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : newCpuTimes.keySet()) {\n        Long t = lastCpuTimes.get(thread);\n        if (t == null) {\n            t = 0L;\n        }\n        long time1 = t;\n        long time2 = newCpuTimes.get(thread);\n        if (time1 == -1) {\n            time1 = time2;\n        } else if (time2 == -1) {\n            time2 = time1;\n        }\n        long delta = time2 - time1;\n        deltas.put(thread, delta);\n    }\n\n    long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n\n    // Compute CPU usage percentage for each thread\n    final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n    for (ThreadVO thread : threads) {\n        double cpu = sampleIntervalNanos == 0 ? 0 : (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0);\n        cpuUsages.put(thread, cpu);\n    }\n\n    // Sort threads by delta time in descending order\n    Collections.sort(threads, new Comparator<ThreadVO>() {\n        @Override\n        public int compare(ThreadVO o1, ThreadVO o2) {\n            long l1 = deltas.get(o1);\n            long l2 = deltas.get(o2);\n            if (l1 < l2) {\n                return 1;\n            } else if (l1 > l2) {\n                return -1;\n            } else {\n                return 0;\n            }\n        }\n    });\n\n    // Update thread information with new times and CPU usage\n    for (ThreadVO thread : threads) {\n        // Convert nanos to mills\n        long timeMills = newCpuTimes.get(thread) / 1000000;\n        long deltaTime = deltas.get(thread) / 1000000;\n        double cpu = cpuUsages.get(thread);\n\n        thread.setCpu(cpu);\n        thread.setTime(timeMills);\n        thread.setDeltaTime(deltaTime);\n    }\n\n    // Update last sample times\n    lastCpuTimes = newCpuTimes;\n    lastSampleTimeNanos = newSampleTimeNanos;\n\n    return threads;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "4", "src_id": "M1131", "code": "\nprivate ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<String, Object>();\n    body.put(\"command\", commandLine);\n\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId())\n            .setBody(body);\n\n    // Attempt to acquire lock for the session\n    if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED)\n                .setMessage(\"Another command is executing.\");\n        return response;\n    }\n\n    int lock = session.getLock();\n    try {\n        // Check if there's already a foreground job\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n            response.setState(ApiState.REFUSED)\n                    .setMessage(\"Another job is running.\");\n            logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n            return response;\n        }\n\n        // Create a new job for the command\n        Job job = this.createJob(commandLine, session, session.getResultDistributor());\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        response.setState(ApiState.SCHEDULED);\n\n        // Record the command request before execution\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n        commandRequestModel.setJobId(job.id());\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) {\n            resultDistributor.appendResult(commandRequestModel);\n        }\n\n        // Set the job as foreground job\n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n        // Execute the job\n        job.run();\n\n        return response;\n    } catch (Throwable e) {\n        logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n        session.getResultDistributor().appendResult(commandRequestModel);\n        return response;\n    } finally {\n        // Release the lock if still held by this request\n        if (session.getLock() == lock) {\n            session.unLock();\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "5", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    // Process each logger configuration\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        // Extract logger class\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        // Build table for logger attributes\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n                .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n                .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoader)))\n                .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n                .row(label(LoggerHelper.level).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.level)));\n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()),\n                label(\"\" + info.get(LoggerHelper.additivity)))\n                .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()),\n                        label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        // Process appenders for this logger\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\n                // Build appender details\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()),\n                        label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                appendersTable.row(label(LoggerHelper.classLoaderHash),\n                        label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target),\n                            label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking),\n                            label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef),\n                            label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n\n            // Add appenders table to main logger table\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n\n        // Append rendered table to result\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "6", "src_id": "M15", "code": "\npublic static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n    // Prepare classloader for arthas-client.jar\n    URLClassLoader classLoader = new URLClassLoader(\n            new URL[]{new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n    Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n    Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n\n    // Backup original system streams\n    PrintStream originSysOut = System.out;\n    PrintStream originSysErr = System.err;\n    // Redirect output streams\n    PrintStream newOut = new PrintStream(out);\n    PrintStream newErr = new PrintStream(out);\n\n    // Execute TelnetConsole.process with context classloader\n    ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n    try {\n        System.setOut(newOut);\n        System.setErr(newErr);\n        Thread.currentThread().setContextClassLoader(classLoader);\n        return (Integer) processMethod.invoke(null, new Object[]{telnetArgs.toArray(new String[0])});\n    } catch (Throwable e) {\n        // Unwrap InvocationTargetException\n        e = e.getCause();\n        if (e instanceof IOException || e instanceof InterruptedException) {\n            // Handle expected connection errors\n            return STATUS_ERROR;\n        } else {\n            // Log unexpected errors\n            AnsiLog.error(\"process error: {}\", e.toString());\n            AnsiLog.error(e);\n            return STATUS_EXEC_ERROR;\n        }\n    } finally {\n        // Restore original context classloader\n        Thread.currentThread().setContextClassLoader(tccl);\n\n        // Restore original system streams\n        System.setOut(originSysOut);\n        System.setErr(originSysErr);\n        // Flush all output\n        newOut.flush();\n        newErr.flush();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "7", "src_id": "M1469", "code": "\npublic static FieldVO[] getFields(Class clazz, Integer expand) {\n    Field[] fields = clazz.getDeclaredFields();\n    if (fields.length == 0) {\n        return new FieldVO[0];\n    }\n\n    List<FieldVO> list = new ArrayList<>(fields.length);\n    for (Field field : fields) {\n        FieldVO fieldVO = new FieldVO();\n        fieldVO.setName(field.getName());\n        fieldVO.setType(StringUtils.classname(field.getType()));\n        fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n        fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n        if (Modifier.isStatic(field.getModifiers())) {\n            fieldVO.setStatic(true);\n            fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n        } else {\n            fieldVO.setStatic(false);\n        }\n        list.add(fieldVO);\n    }\n    return list.toArray(new FieldVO[0]);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "8", "src_id": "M95", "code": "\npublic static HealthCountsStream getInstance(HystrixCommandKey commandKey, int numBuckets, int bucketSizeInMs) {\n    HealthCountsStream initialStream = streams.get(commandKey.name());\n    if (initialStream != null) {\n        return initialStream;\n    }\n\n    final HealthCountsStream healthStream;\n    synchronized (HealthCountsStream.class) {\n        HealthCountsStream existingStream = streams.get(commandKey.name());\n        if (existingStream == null) {\n            HealthCountsStream newStream = new HealthCountsStream(commandKey, numBuckets, bucketSizeInMs,\n                    HystrixCommandMetrics.appendEventToBucket);\n\n            streams.putIfAbsent(commandKey.name(), newStream);\n            healthStream = newStream;\n        } else {\n            healthStream = existingStream;\n        }\n    }\n    healthStream.startCachingStreamValuesIfUnstarted();\n    return healthStream;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "9", "src_id": "M118", "code": "\npublic Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {\n    Map<CommandAndCacheKey, Integer> cachingDetector = new HashMap<CommandAndCacheKey, Integer>();\n    List<HystrixInvokableInfo<?>> nonCachedExecutions = new ArrayList<HystrixInvokableInfo<?>>(executions.size());\n    for (HystrixInvokableInfo<?> execution : executions) {\n        if (execution.getPublicCacheKey() != null) {\n            CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), execution.getPublicCacheKey());\n            Integer count = cachingDetector.get(key);\n            if (count != null) {\n                cachingDetector.put(key, count + 1);\n            } else {\n                cachingDetector.put(key, 0);\n            }\n        }\n        if (!execution.isResponseFromCache()) {\n            nonCachedExecutions.add(execution);\n        }\n    }\n\n    Map<ExecutionSignature, List<Integer>> commandDeduper = new HashMap<ExecutionSignature, List<Integer>>();\n    for (HystrixInvokableInfo<?> execution : nonCachedExecutions) {\n        int cachedCount = 0;\n        String cacheKey = execution.getPublicCacheKey();\n        if (cacheKey != null) {\n            CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), cacheKey);\n            cachedCount = cachingDetector.get(key);\n        }\n        ExecutionSignature signature;\n        if (cachedCount > 0) {\n            signature = ExecutionSignature.from(execution, cacheKey, cachedCount);\n        } else {\n            signature = ExecutionSignature.from(execution);\n        }\n        List<Integer> currentLatencyList = commandDeduper.get(signature);\n        if (currentLatencyList != null) {\n            currentLatencyList.add(execution.getExecutionTimeInMilliseconds());\n        } else {\n            List<Integer> newLatencyList = new ArrayList<Integer>();\n            newLatencyList.add(execution.getExecutionTimeInMilliseconds());\n            commandDeduper.put(signature, newLatencyList);\n        }\n    }\n\n    return commandDeduper;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "10", "src_id": "M223", "code": "\npublic ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties) {\n    final ThreadFactory threadFactory = getThreadFactory(threadPoolKey);\n\n    final boolean allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();\n    final int dynamicCoreSize = threadPoolProperties.coreSize().get();\n    final int keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();\n    final int maxQueueSize = threadPoolProperties.maxQueueSize().get();\n    final BlockingQueue<Runnable> workQueue = getBlockingQueue(maxQueueSize);\n\n    if (allowMaximumSizeToDivergeFromCoreSize) {\n        final int dynamicMaximumSize = threadPoolProperties.maximumSize().get();\n        if (dynamicCoreSize > dynamicMaximumSize) {\n            logger.error(\"Hystrix ThreadPool configuration at startup for : \" + threadPoolKey.name() + \" is trying to set coreSize = \" +\n                    dynamicCoreSize + \" and maximumSize = \" + dynamicMaximumSize + \".  Maximum size will be set to \" +\n                    dynamicCoreSize + \", the coreSize value, since it must be equal to or greater than the coreSize value\");\n            return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n        } else {\n            return new ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n        }\n    } else {\n        return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "11", "src_id": "M498", "code": "\nprotected static String convertToJson(HystrixUtilization utilization) throws IOException {\n    StringWriter jsonString = new StringWriter();\n    JsonGenerator json = jsonFactory.createGenerator(jsonString);\n\n    json.writeStartObject();\n    json.writeStringField(\"type\", \"HystrixUtilization\");\n    json.writeObjectFieldStart(\"commands\");\n    for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n        final HystrixCommandKey key = entry.getKey();\n        final HystrixCommandUtilization commandUtilization = entry.getValue();\n        writeCommandUtilizationJson(json, key, commandUtilization);\n    }\n    json.writeEndObject();\n\n    json.writeObjectFieldStart(\"threadpools\");\n    for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n        final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n        final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n        writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n    }\n    json.writeEndObject();\n    json.writeEndObject();\n    json.close();\n\n    return jsonString.getBuffer().toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "12", "src_id": "M171", "code": "\nEventCounts plus(HystrixEventType eventType, int count) {\n    BitSet newBitSet = (BitSet) events.clone();\n    int localNumEmits = numEmissions;\n    int localNumFallbackEmits = numFallbackEmissions;\n    int localNumCollapsed = numCollapsed;\n    switch (eventType) {\n        case EMIT:\n            newBitSet.set(HystrixEventType.EMIT.ordinal());\n            localNumEmits += count;\n            break;\n        case FALLBACK_EMIT:\n            newBitSet.set(HystrixEventType.FALLBACK_EMIT.ordinal());\n            localNumFallbackEmits += count;\n            break;\n        case COLLAPSED:\n            newBitSet.set(HystrixEventType.COLLAPSED.ordinal());\n            localNumCollapsed += count;\n            break;\n        default:\n            newBitSet.set(eventType.ordinal());\n            break;\n    }\n    return new EventCounts(newBitSet, localNumEmits, localNumFallbackEmits, localNumCollapsed);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "13", "src_id": "M448", "code": "\nprivate static void writeThreadPoolMetrics(final HystrixThreadPoolMetrics threadPoolMetrics, JsonGenerator json) throws IOException {\n    HystrixThreadPoolKey key = threadPoolMetrics.getThreadPoolKey();\n\n    json.writeStartObject();\n\n    json.writeStringField(\"type\", \"HystrixThreadPool\");\n    json.writeStringField(\"name\", key.name());\n    json.writeNumberField(\"currentTime\", System.currentTimeMillis());\n\n    json.writeNumberField(\"currentActiveCount\", threadPoolMetrics.getCurrentActiveCount().intValue());\n    json.writeNumberField(\"currentCompletedTaskCount\", threadPoolMetrics.getCurrentCompletedTaskCount().longValue());\n    json.writeNumberField(\"currentCorePoolSize\", threadPoolMetrics.getCurrentCorePoolSize().intValue());\n    json.writeNumberField(\"currentLargestPoolSize\", threadPoolMetrics.getCurrentLargestPoolSize().intValue());\n    json.writeNumberField(\"currentMaximumPoolSize\", threadPoolMetrics.getCurrentMaximumPoolSize().intValue());\n    json.writeNumberField(\"currentPoolSize\", threadPoolMetrics.getCurrentPoolSize().intValue());\n    json.writeNumberField(\"currentQueueSize\", threadPoolMetrics.getCurrentQueueSize().intValue());\n    json.writeNumberField(\"currentTaskCount\", threadPoolMetrics.getCurrentTaskCount().longValue());\n    safelyWriteNumberField(json, \"rollingCountThreadsExecuted\", new Func0<Long>() {\n        @Override\n        public Long call() {\n            return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.EXECUTED);\n        }\n    });\n    json.writeNumberField(\"rollingMaxActiveThreads\", threadPoolMetrics.getRollingMaxActiveThreads());\n    safelyWriteNumberField(json, \"rollingCountCommandRejections\", new Func0<Long>() {\n        @Override\n        public Long call() {\n            return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.REJECTED);\n        }\n    });\n\n    json.writeNumberField(\"propertyValue_queueSizeRejectionThreshold\", threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());\n    json.writeNumberField(\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());\n\n    json.writeNumberField(\"reportingHosts\", 1);\n    json.writeEndObject();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "14", "src_id": "M69", "code": "\n@Override\npublic String toString() {\n    StringBuffer sb = new StringBuffer();\n    List<HystrixEventType> foundEventTypes = new ArrayList<HystrixEventType>();\n\n    sb.append(getCommandKey().name()).append(\"[\");\n    for (HystrixEventType eventType : ALL_EVENT_TYPES) {\n        if (executionResult.getEventCounts().contains(eventType)) {\n            foundEventTypes.add(eventType);\n        }\n    }\n    int i = 0;\n    for (HystrixEventType eventType : foundEventTypes) {\n        sb.append(eventType.name());\n        int eventCount = executionResult.getEventCounts().getCount(eventType);\n        if (eventCount > 1) {\n            sb.append(\"x\").append(eventCount);\n        }\n        if (i < foundEventTypes.size() - 1) {\n            sb.append(\", \");\n        }\n        i++;\n    }\n    sb.append(\"][\").append(getExecutionLatency()).append(\" ms]\");\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "15", "src_id": "M52", "code": "\n@Override\npublic void run() {\n    while (true) {\n        try {\n            Thread.sleep(5000);\n        } catch (Exception e) {\n            // ignore\n        }\n\n        HystrixCommandMetrics creditCardMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(CreditCardCommand.class.getSimpleName()));\n        HystrixCommandMetrics orderMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetOrderCommand.class.getSimpleName()));\n        HystrixCommandMetrics userAccountMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetUserAccountCommand.class.getSimpleName()));\n        HystrixCommandMetrics paymentInformationMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetPaymentInformationCommand.class.getSimpleName()));\n\n        if (shouldLog) {\n            StringBuilder out = new StringBuilder();\n            out.append(\"\\n\");\n            out.append(\"#####################################################################################\").append(\"\\n\");\n            out.append(\"# CreditCardCommand: \" + getStatsStringFromMetrics(creditCardMetrics)).append(\"\\n\");\n            out.append(\"# GetOrderCommand: \" + getStatsStringFromMetrics(orderMetrics)).append(\"\\n\");\n            out.append(\"# GetUserAccountCommand: \" + getStatsStringFromMetrics(userAccountMetrics)).append(\"\\n\");\n            out.append(\"# GetPaymentInformationCommand: \" + getStatsStringFromMetrics(paymentInformationMetrics)).append(\"\\n\");\n            out.append(\"#####################################################################################\").append(\"\\n\");\n            System.out.println(out.toString());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "16", "src_id": "M312", "code": "\nprivate Observable<R> handleRequestCacheHitAndEmitValues(final HystrixCommandResponseFromCache<R> fromCache, final AbstractCommand<R> _cmd) {\n    try {\n        executionHook.onCacheHit(this);\n    } catch (Throwable hookEx) {\n        logger.warn(\"Error calling HystrixCommandExecutionHook.onCacheHit\", hookEx);\n    }\n\n    return fromCache.toObservableWithStateCopiedInto(this)\n            .doOnTerminate(new Action0() {\n                @Override\n                public void call() {\n                    if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) {\n                        cleanUpAfterResponseFromCache(false);\n                    } else if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) {\n                        cleanUpAfterResponseFromCache(true);\n                    }\n                }\n            })\n            .doOnUnsubscribe(new Action0() {\n                @Override\n                public void call() {\n                    if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) {\n                        cleanUpAfterResponseFromCache(false);\n                    } else if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.UNSUBSCRIBED)) {\n                        cleanUpAfterResponseFromCache(true);\n                    }\n                }\n            });\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "17", "src_id": "M438", "code": "\nprivate static void serializeUtilization(HystrixUtilization utilization, JsonGenerator json) {\n    try {\n        json.writeStartObject();\n        json.writeStringField(\"type\", \"HystrixUtilization\");\n        json.writeObjectFieldStart(\"commands\");\n        for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n            final HystrixCommandKey key = entry.getKey();\n            final HystrixCommandUtilization commandUtilization = entry.getValue();\n            writeCommandUtilizationJson(json, key, commandUtilization);\n        }\n        json.writeEndObject();\n\n        json.writeObjectFieldStart(\"threadpools\");\n        for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n            final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n            final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n            writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n        }\n        json.writeEndObject();\n        json.writeEndObject();\n        json.close();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "18", "src_id": "M342", "code": "\nprivate static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n    if (emlBytes == null || emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n    }\n\n    String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n    \n    // Basic email parsing\n    String subject = extractBasicHeader(emlContent, \"Subject:\");\n    String from = extractBasicHeader(emlContent, \"From:\");\n    String to = extractBasicHeader(emlContent, \"To:\");\n    String cc = extractBasicHeader(emlContent, \"Cc:\");\n    String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n    String date = extractBasicHeader(emlContent, \"Date:\");\n\n    // Try to extract HTML content\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n        String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(\n            textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n\n    // Generate HTML with custom styling based on request\n    StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\");\n    html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n    html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n    html.append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n\");\n    html.append(\"</head><body>\\n\");\n\n    html.append(\"<div class=\\\"email-container\\\">\\n\");\n    html.append(\"<div class=\\\"email-header\\\">\\n\");\n    html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n    html.append(\"<div class=\\\"email-meta\\\">\\n\");\n    html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n    html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n    // Include CC and BCC if present and requested\n    if (request != null && request.isIncludeAllRecipients()) {\n        if (!cc.trim().isEmpty()) {\n            html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        }\n        if (!bcc.trim().isEmpty()) {\n            html.append(\"<div><strong>BCC:</strong> \")\n                .append(escapeHtml(bcc))\n                .append(\"</div>\\n\");\n        }\n    }\n\n    if (!date.trim().isEmpty()) {\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n    }\n    html.append(\"</div></div>\\n\");\n\n    html.append(\"<div class=\\\"email-body\\\">\\n\");\n    html.append(processEmailHtmlBody(htmlBody));\n    html.append(\"</div>\\n\");\n\n    // Add attachment information\n    String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n        html.append(\"<h3>Attachments</h3>\\n\");\n        html.append(attachmentInfo);\n\n        // Add attachment inclusion status\n        if (request != null && request.isIncludeAttachments()) {\n            html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n            html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n            html.append(\"</div>\\n\");\n        } else {\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n            html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n    }\n\n    assert request != null;\n    if (request.getFileInput().isEmpty()) {\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n        html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n    }\n\n    html.append(\"</div>\\n\");\n    html.append(\"</body></html>\");\n\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "19", "src_id": "M371", "code": "\nprivate static boolean isValidJakartaMailMultipart(Object multipart) {\n    if (multipart == null) {\n        return false;\n    }\n\n    try {\n        Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n        if (!multipartInterface.isInstance(multipart)) {\n            return false;\n        }\n\n        try {\n            Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n            if (mimeMultipartClass.isInstance(multipart)) {\n                log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                return true;\n            }\n        } catch (ClassNotFoundException e) {\n            log.debug(\"MimeMultipart not available, using base Multipart interface\");\n        }\n\n        return true;\n    } catch (ClassNotFoundException e) {\n        log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "20", "src_id": "M348", "code": "\nprivate static String extractBasicHeader(String emlContent, String headerName) {\n    try {\n        String[] lines = emlContent.split(\"\\r?\\n\");\n        for (int i = 0; i < lines.length; i++) {\n            String line = lines[i];\n            if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                // Handle multi-line headers\n                for (int j = i + 1; j < lines.length; j++) {\n                    if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                        value.append(\" \").append(lines[j].trim());\n                    } else {\n                        break;\n                    }\n                }\n                return safeMimeDecode(value.toString());\n            }\n            if (line.trim().isEmpty()) {\n                break;\n            }\n        }\n    } catch (RuntimeException e) {\n        log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n    }\n    return \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "21", "src_id": "M364", "code": "\nprivate static void addAttachmentAnnotationsToDocument(\n        PDDocument document, List<EmailAttachment> attachments) throws IOException {\n    if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n        return;\n    }\n\n    // 1. Find attachment markers\n    AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n    finder.setSortByPosition(true);\n    finder.getText(document);\n    List<MarkerPosition> markerPositions = finder.getPositions();\n\n    // 2. Validate marker count\n    if (markerPositions.size() != attachments.size()) {\n        log.warn(\n            \"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n            markerPositions.size(),\n            attachments.size());\n    }\n\n    // 3. Create invisible annotations\n    int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n    for (int i = 0; i < annotationsToAdd; i++) {\n        MarkerPosition position = markerPositions.get(i);\n        EmailAttachment attachment = attachments.get(i);\n\n        if (attachment.getEmbeddedFilename() != null) {\n            PDPage page = document.getPage(position.getPageIndex());\n            addAttachmentAnnotationToPage(\n                document, page, attachment, position.getX(), position.getY());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "32", "src_id": "M31", "code": "\n    private JsonNode validateLicense(\n            String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\n            \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\",\n            licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n            .header(\"Content-Type\", \"application/vnd.api+json\")\n            .header(\"Accept\", \"application/vnd.api+json\")\n            .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n            .build();\n\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() == 200) {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n                log.info(\n                    \"License floating (from license): {}, maxMachines: {}\",\n                    context.isFloatingLicense,\n                    context.maxMachines);\n            }\n\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n\n            if (policyNode != null) {\n                boolean policyFloating = policyNode.path(\"attributes\")\n                    .path(\"floating\")\n                    .asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\")\n                    .path(\"maxMachines\")\n                    .asInt(1);\n\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n\n                log.info(\n                    \"License floating (from policy): {}, maxMachines: {}\",\n                    context.isFloatingLicense,\n                    context.maxMachines);\n            }\n\n            int users = jsonResponse.path(\"data\")\n                .path(\"attributes\")\n                .path(\"metadata\")\n                .path(\"users\")\n                .asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n\n            context.isEnterpriseLicense = jsonResponse.path(\"data\")\n                .path(\"attributes\")\n                .path(\"metadata\")\n                .path(\"isEnterprise\")\n                .asBoolean(false);\n\n            log.debug(applicationProperties.toString());\n        } else {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n        return jsonResponse;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "33", "src_id": "M488", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n        summary = \"Convert a file to a PDF using LibreOffice\",\n        description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\"\n            + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n            throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(\n                doc,\n                Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                        .replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) file.delete();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "34", "src_id": "M625", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            \n            ObjectNode metadata = objectMapper.createObjectNode();\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n\n            long fileSizeInBytes = inputFile.getSize();\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n            int wordCount = words.length;\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n            int charCount = fullText.length();\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            boolean hasCompression = false;\n            String compressionType = \"None\";\n            basicInfo.put(\"Compression\", hasCompression);\n            if (hasCompression) basicInfo.put(\"CompressionType\", compressionType);\n\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            String pageMode = catalog.getPageMode().name();\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n            PDAcroForm acroForm = catalog.getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n            if (summaryData != null && summaryData.size() > 0) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                jsonOutput.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            jsonOutput.set(\"Attachments\", attachmentsArray);\n\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n                            PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n            jsonOutput.set(\"JavaScript\", javascriptArray);\n\n            PDOptionalContentProperties ocProperties = catalog.getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n            jsonOutput.set(\"Layers\", layersArray);\n\n            PDStructureTreeRoot structureTreeRoot = catalog.getStructureTreeRoot();\n            ArrayNode structureTreeArray;\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    jsonOutput.set(\"StructureTree\", structureTreeArray);\n                }\n            } catch (Exception e) {\n                log.error(\"exception\", e);\n            }\n\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            compliancy.put(\"IsPDF/ACompliant\", checkForStandard(pdfBoxDoc, \"PDF/A\"));\n            compliancy.put(\"IsPDF/XCompliant\", checkForStandard(pdfBoxDoc, \"PDF/X\"));\n            compliancy.put(\"IsPDF/ECompliant\", checkForStandard(pdfBoxDoc, \"PDF/E\"));\n            compliancy.put(\"IsPDF/VTCompliant\", checkForStandard(pdfBoxDoc, \"PDF/VT\"));\n            compliancy.put(\"IsPDF/UACompliant\", checkForStandard(pdfBoxDoc, \"PDF/UA\"));\n            compliancy.put(\"IsPDF/BCompliant\", checkForStandard(pdfBoxDoc, \"PDF/B\"));\n            compliancy.put(\"IsPDF/SECCompliant\", checkForStandard(pdfBoxDoc, \"PDF/SEC\"));\n\n            PDOutlineNode root = catalog.getDocumentOutline();\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            jsonOutput.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n            PDMetadata pdMetadata = catalog.getMetadata();\n            String xmpString = null;\n            if (pdMetadata != null) {\n                try (COSInputStream is = pdMetadata.createInputStream()) {\n                    DomXmpParser domXmpParser = new DomXmpParser();\n                    XMPMetadata xmpMeta = domXmpParser.parse(is);\n                    ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    new XmpSerializer().serialize(xmpMeta, os, true);\n                    xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                } catch (XmpParsingException e) {\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n            jsonOutput.put(\"XMPMetadata\", xmpString);\n\n            ObjectNode encryption = objectMapper.createObjectNode();\n            if (pdfBoxDoc.isEncrypted()) {\n                encryption.put(\"IsEncrypted\", true);\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n            } else {\n                encryption.put(\"IsEncrypted\", false);\n            }\n            jsonOutput.set(\"Encryption\", encryption);\n\n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n            jsonOutput.set(\"Permissions\", permissionsNode);\n\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n                PDRectangle mediaBox = page.getMediaBox();\n                float width = mediaBox.getWidth();\n                float height = mediaBox.getHeight();\n                \n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n                \n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n                \n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                pageInfo.put(\"CropBox\", page.getCropBox() == null ? \"Undefined\" : page.getCropBox().toString());\n                pageInfo.put(\"BleedBox\", page.getBleedBox() == null ? \"Undefined\" : page.getBleedBox().toString());\n                pageInfo.put(\"TrimBox\", page.getTrimBox() == null ? \"Undefined\" : page.getTrimBox().toString());\n                pageInfo.put(\"ArtBox\", page.getArtBox() == null ? \"Undefined\" : page.getArtBox().toString());\n                \n                PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n                String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length());\n                \n                List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) subtypeCount++;\n                    if (annotation.getContents() != null) contentsCount++;\n                }\n                \n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n                \n                PDResources resources = page.getResources();\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null\n                                && image.getMetadata().getFile() != null\n                                && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n                \n                Set<String> uniqueURIs = new HashSet<>();\n                ArrayNode linksArray = objectMapper.createArrayNode();\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation) {\n                        if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                            uniqueURIs.add(uriAction.getURI());\n                        }\n                    }\n                }\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n                pageInfo.set(\"Links\", linksArray);\n                \n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n                    \n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n                    \n                    String uniqueKey = fontNode.toString();\n                    if (uniqueFontsMap.containsKey(uniqueKey)) {\n                        ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        existingFontNode.put(\"Count\", existingFontNode.get(\"Count\").asInt() + 1);\n                    } else {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    }\n                }\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", fontsArray);\n                \n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n                for (COSName name : resources.getColorSpaceNames()) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        byte[] iccBytes = iccData.toByteArray();\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n                \n                Map<String, Integer> xObjectCountMap = new HashMap<>();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType = xObject instanceof PDImageXObject ? \"Image\"\n                         : xObject instanceof PDFormXObject ? \"Form\" : \"Other\";\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n                \n                ArrayNode multimediaArray = objectMapper.createArrayNode();\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        multimediaArray.add(objectMapper.createObjectNode());\n                    }\n                }\n                pageInfo.set(\"Multimedia\", multimediaArray);\n                \n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Other\", jsonOutput.objectNode());\n            \n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(\n                jsonString.getBytes(StandardCharsets.UTF_8),\n                \"response.json\",\n                MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "35", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile.replace(CERT_PREFIX, \"\")\n                .replace(CERT_SUFFIX, \"\")\n                .replaceAll(\"\\\\r?\\\\n\", \"\");\n\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = attrs.getString(\"enc\");\n                encodedSignature = attrs.getString(\"sig\");\n                algorithm = attrs.getString(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n\n            log.info(\"License file signature is valid\");\n            String decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            return processCertificateData(decodedData, context);\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "36", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(\n            Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n            throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager);\n             ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n                 new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n             \n            ZipEntry entry;\n            while ((entry = zipIn.getNextEntry()) != null) {\n                Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                if (!entry.isDirectory()) {\n                    Files.createDirectories(filePath.getParent());\n                    if (entry.getName().toLowerCase().endsWith(\".html\")\n                            || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                        String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                        String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                        Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                    } else {\n                        Files.copy(zipIn, filePath);\n                    }\n                }\n                zipIn.closeEntry();\n            }\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "37", "src_id": "M317", "code": "\n    public static void addImageToDocument(\n            PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n            throws IOException {\n        boolean imageIsLandscape = image.getWidth() > image.getHeight();\n        PDRectangle pageSize = PDRectangle.A4;\n\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n\n        try (PDPageContentStream contentStream = new PDPageContentStream(\n                doc, page, AppendMode.APPEND, true, true)) {\n                \n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } else if (\"maintainAspectRatio\".equals(fitOption)) {\n                float imageAspectRatio = (float) image.getWidth() / image.getHeight();\n                float pageAspectRatio = pageWidth / pageHeight;\n                float scaleFactor = imageAspectRatio > pageAspectRatio\n                    ? pageWidth / image.getWidth()\n                    : pageHeight / image.getHeight();\n\n                float xPos = (pageWidth - image.getWidth() * scaleFactor) / 2;\n                float yPos = (pageHeight - image.getHeight() * scaleFactor) / 2;\n                contentStream.drawImage(\n                    image,\n                    xPos,\n                    yPos,\n                    image.getWidth() * scaleFactor,\n                    image.getHeight() * scaleFactor);\n            }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "38", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n            if (network == null) {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (byte b : mac) {\n                            sb.append(String.format(\"%02X\", b));\n                        }\n                        break;\n                    }\n                }\n            } else {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (byte b : mac) {\n                        sb.append(String.format(\"%02X\", b));\n                    }\n                }\n            }\n\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "39", "src_id": "M135", "code": "\n    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata()\n                && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "40", "src_id": "M128", "code": "\n    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            } else if (isDocker) {\n                return \"Docker\";\n            } else if (isBrowserOpen) {\n                String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                if (os.contains(\"win\")) {\n                    return \"Client-windows\";\n                } else if (os.contains(\"mac\")) {\n                    return \"Client-mac\";\n                } else {\n                    return \"Client-unix\";\n                }\n            } else {\n                return \"Server-jar\";\n            }\n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "41", "src_id": "M101", "code": "\n    private void processRequest(\n            int limitPerDay,\n            String identifier,\n            Map<String, Bucket> buckets,\n            HttpServletRequest request,\n            HttpServletResponse response,\n            FilterChain filterChain)\n            throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\n                \"X-Rate-Limit-Remaining\",\n                stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\n                \"X-Rate-Limit-Retry-After-Seconds\",\n                Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "43", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    List list = (List) data;\n    if (list == null || list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (KeyValue keyValue : (List<KeyValue>) data) {\n            String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        assert resultsData != null : \"Could not detect Results data.\";\n        assert profileData != null : \"Could not detect Profile data.\";\n        return KeyValue.of(\n                resultsBuilder.build(resultsData),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n    }\n\n    return KeyValue.of(\n            resultsBuilder.build(list.get(0)),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "46", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    if (keystoreResource != null) {\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "47", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rulesValueMap;\n                    break;\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = chunkDataAsList.stream()\n                                .collect(Collectors.toMap(\n                                        kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                        kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n                    value = chunksValueList;\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) { }\n            }\n        }\n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "48", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "49", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n\n    JedisException suppressed = null;\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) {\n                continue;\n            }\n\n            jedis.ping();\n            return jedis;\n\n        } catch (JedisException ex) {\n            if (suppressed == null) {\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "50", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            } else {\n                Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "51", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "52", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<String, String>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "53", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "54", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE:\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE:\n            return processMultiBulkReply(is);\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "55", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    List list = (List) data;\n    if (list == null || list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) {\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (KeyValue keyValue : (List<KeyValue>) data) {\n            String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        assert resultsData != null : \"Could not detect Results data.\";\n        assert profileData != null : \"Could not detect Profile data.\";\n        return KeyValue.of(resultsBuilder.build(resultsData),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n    }\n\n    return KeyValue.of(resultsBuilder.build(list.get(0)),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "56", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    if (keystoreResource != null) {\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "57", "src_id": "M894", "code": "\npublic TSInfo build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    Map<String, Object> properties = new HashMap<String, Object>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    Map<String, List<Object>> rulesValueMap = new HashMap<String, List<Object>>(rulesDataList.size(), 1f);\n                    rules = new HashMap<String, Rule>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rulesValueMap;\n                    break;\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    List<Map<String, Object>> chunksValueList = new ArrayList<Map<String, Object>>(chunksDataList.size());\n                    chunks = new ArrayList<Map<String, Object>>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = chunkDataAsList.stream()\n                            .collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                    kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n                    value = chunksValueList;\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "58", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "59", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n\n    JedisException suppressed = null;\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) {\n                continue;\n            }\n\n            jedis.ping();\n            return jedis;\n\n        } catch (JedisException ex) {\n            if (suppressed == null) {\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "60", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        EvictionPolicy policy = getEvictionPolicy();\n        policy.touch(cacheKey);\n        CacheKey evictedKey = policy.evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n            } else {\n                Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                set.add(cacheKey);\n                redisKeysToCacheKeys.put(mapKey, set);\n            }\n        }\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "61", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "62", "src_id": "M342", "code": "\nprivate static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n    if (emlBytes == null || emlBytes.length == 0)\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n\n    String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n    String subject = extractBasicHeader(emlContent, \"Subject:\");\n    String from = extractBasicHeader(emlContent, \"From:\");\n    String to = extractBasicHeader(emlContent, \"To:\");\n    String cc = extractBasicHeader(emlContent, \"Cc:\");\n    String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n    String date = extractBasicHeader(emlContent, \"Date:\");\n\n    String htmlBody = extractHtmlBody(emlContent);\n    if (htmlBody == null) {\n        String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n    }\n\n    StringBuilder html = new StringBuilder();\n    html.append(\"<!DOCTYPE html>\\n\")\n        .append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\")\n        .append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\")\n        .append(\"<style>\\n\");\n    appendEnhancedStyles(html);\n    html.append(\"</style>\\n</head><body>\\n<div class=\\\"email-container\\\">\\n\")\n        .append(\"<div class=\\\"email-header\\\">\\n<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\")\n        .append(\"<div class=\\\"email-meta\\\">\\n<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\")\n        .append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n    if (request != null && request.isIncludeAllRecipients()) {\n        if (!cc.trim().isEmpty())\n            html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        if (!bcc.trim().isEmpty())\n            html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n    }\n\n    if (!date.trim().isEmpty())\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        \n    html.append(\"</div></div>\\n<div class=\\\"email-body\\\">\\n\")\n        .append(processEmailHtmlBody(htmlBody)).append(\"</div>\\n\");\n\n    String attachmentInfo = extractAttachmentInfo(emlContent);\n    if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n<h3>Attachments</h3>\\n\")\n            .append(attachmentInfo);\n\n        if (request != null && request.isIncludeAttachments())\n            html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n</div>\\n\");\n        else\n            html.append(\"<div class=\\\"attachment-info-note\\\">\\n<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n</div>\\n\");\n\n        html.append(\"</div>\\n\");\n    }\n\n    assert request != null;\n    if (request.getFileInput().isEmpty())\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n</div>\\n\");\n\n    html.append(\"</div>\\n</body></html>\");\n    return html.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "63", "src_id": "M371", "code": "\nprivate static boolean isValidJakartaMailMultipart(Object multipart) {\n    if (multipart == null) return false;\n\n    try {\n        Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n        if (!multipartInterface.isInstance(multipart)) return false;\n\n        try {\n            Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n            if (mimeMultipartClass.isInstance(multipart)) {\n                log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                return true;\n            }\n        } catch (ClassNotFoundException e) {\n            log.debug(\"MimeMultipart not available, using base Multipart interface\");\n        }\n        return true;\n    } catch (ClassNotFoundException e) {\n        log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n        return false;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "64", "src_id": "M348", "code": "\nprivate static String extractBasicHeader(String emlContent, String headerName) {\n    try {\n        String[] lines = emlContent.split(\"\\r?\\n\");\n        for (int i = 0; i < lines.length; i++) {\n            String line = lines[i];\n            if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                for (int j = i + 1; j < lines.length; j++) {\n                    if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\"))\n                        value.append(\" \").append(lines[j].trim());\n                    else break;\n                }\n                return safeMimeDecode(value.toString());\n            }\n            if (line.trim().isEmpty()) break;\n        }\n    } catch (RuntimeException e) {\n        log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n    }\n    return \"\";\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "65", "src_id": "M364", "code": "\nprivate static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n    if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) return;\n\n    AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n    finder.setSortByPosition(true);\n    finder.getText(document);\n    List<MarkerPosition> markerPositions = finder.getPositions();\n\n    if (markerPositions.size() != attachments.size())\n        log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n                markerPositions.size(), attachments.size());\n\n    int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n    for (int i = 0; i < annotationsToAdd; i++) {\n        MarkerPosition position = markerPositions.get(i);\n        EmailAttachment attachment = attachments.get(i);\n        if (attachment.getEmbeddedFilename() != null) {\n            PDPage page = document.getPage(position.getPageIndex());\n            addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "66", "src_id": "M475", "code": "\n@Override\npublic void draw(CommandProcess process, JvmModel result) {\n    TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n\n    for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n        String group = entry.getKey();\n        List<JvmItemVO> items = entry.getValue();\n\n        table.row(true, label(group).style(Decoration.bold.bold()));\n        for (JvmItemVO item : items) {\n            String valueStr = (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\"))\n                ? renderMemoryUsage((Map<String, Object>) item.getValue())\n                : renderItemValue(item.getValue());\n                \n            String namePart = (item.getDesc() != null)\n                ? item.getName() + \"\\n[\" + item.getDesc() + \"]\"\n                : item.getName();\n            table.row(namePart, valueStr);\n        }\n        table.row(\"\", \"\");\n    }\n\n    process.write(RenderUtil.render(table, process.width()));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "67", "src_id": "M535", "code": "\npublic static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n    final StringBuilder infoSB = new StringBuilder();\n    List<String> classDumpFiles = affectVO.getClassDumpFiles();\n    if (classDumpFiles != null) {\n        for (String classDumpFile : classDumpFiles) {\n            infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n        }\n    }\n\n    List<String> methods = affectVO.getMethods();\n    if (methods != null) {\n        for (String method : methods) {\n            infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n        }\n    }\n\n    infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\",\n            affectVO.getClassCount(),\n            affectVO.getMethodCount(),\n            affectVO.getCost(),\n            affectVO.getListenerId()));\n            \n    if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n        infoSB.append('\\n').append(affectVO.getOverLimitMsg());\n    }\n    if (affectVO.getThrowable() != null) {\n        infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n    }\n    infoSB.append('\\n');\n\n    return infoSB.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "68", "src_id": "M753", "code": "\npublic List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n    List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n\n    if (lastCpuTimes.isEmpty()) {\n        lastSampleTimeNanos = System.nanoTime();\n        for (ThreadVO thread : threads) {\n            if (thread.getId() > 0) {\n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                lastCpuTimes.put(thread, cpu);\n                thread.setTime(cpu / 1000000);\n            }\n        }\n\n        Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (internalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                String key = entry.getKey();\n                ThreadVO thread = createThreadVO(key);\n                thread.setTime(entry.getValue() / 1000000);\n                threads.add(thread);\n                lastCpuTimes.put(thread, entry.getValue());\n            }\n        }\n\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n            @Override\n            public int compare(ThreadVO o1, ThreadVO o2) {\n                return Long.compare(o2.getTime(), o1.getTime());\n            }\n        });\n        return threads;\n    }\n\n    long newSampleTimeNanos = System.nanoTime();\n    Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : threads) {\n        if (thread.getId() > 0) {\n            long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n            newCpuTimes.put(thread, cpu);\n        }\n    }\n    \n    Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n    if (newInternalThreadCpuTimes != null) {\n        for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n            ThreadVO threadVO = createThreadVO(entry.getKey());\n            threads.add(threadVO);\n            newCpuTimes.put(threadVO, entry.getValue());\n        }\n    }\n\n    final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n    for (ThreadVO thread : newCpuTimes.keySet()) {\n        Long t = lastCpuTimes.get(thread);\n        if (t == null) t = 0L;\n        long time1 = t;\n        long time2 = newCpuTimes.get(thread);\n        if (time1 == -1) time1 = time2;\n        else if (time2 == -1) time2 = time1;\n        deltas.put(thread, time2 - time1);\n    }\n\n    long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n    final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n    for (ThreadVO thread : threads) {\n        double cpu = sampleIntervalNanos == 0 \n            ? 0 \n            : (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0;\n        cpuUsages.put(thread, cpu);\n    }\n\n    Collections.sort(threads, new Comparator<ThreadVO>() {\n        @Override\n        public int compare(ThreadVO o1, ThreadVO o2) {\n            return Long.compare(deltas.get(o2), deltas.get(o1));\n        }\n    });\n\n    for (ThreadVO thread : threads) {\n        long timeMills = newCpuTimes.get(thread) / 1000000;\n        long deltaTime = deltas.get(thread) / 1000000;\n        double cpu = cpuUsages.get(thread);\n\n        thread.setCpu(cpu);\n        thread.setTime(timeMills);\n        thread.setDeltaTime(deltaTime);\n    }\n    lastCpuTimes = newCpuTimes;\n    lastSampleTimeNanos = newSampleTimeNanos;\n\n    return threads;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1131", "code": "\nprivate ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n    String commandLine = apiRequest.getCommand();\n    Map<String, Object> body = new TreeMap<String, Object>();\n    body.put(\"command\", commandLine);\n\n    ApiResponse response = new ApiResponse();\n    response.setSessionId(session.getSessionId()).setBody(body);\n\n    if (!session.tryLock()) {\n        response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n        return response;\n    }\n    \n    int lock = session.getLock();\n    try {\n        Job foregroundJob = session.getForegroundJob();\n        if (foregroundJob != null) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n            logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n            return response;\n        }\n\n        Job job = createJob(commandLine, session, session.getResultDistributor());\n        body.put(\"jobId\", job.id());\n        body.put(\"jobStatus\", job.status());\n        response.setState(ApiState.SCHEDULED);\n\n        CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n        commandRequestModel.setJobId(job.id());\n        SharingResultDistributor resultDistributor = session.getResultDistributor();\n        if (resultDistributor != null) resultDistributor.appendResult(commandRequestModel);\n        \n        session.setForegroundJob(job);\n        updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n        job.run();\n\n        return response;\n    } catch (Throwable e) {\n        logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n        response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n        session.getResultDistributor().appendResult(\n            new CommandRequestModel(commandLine, response.getState(), response.getMessage()));\n        return response;\n    } finally {\n        if (session.getLock() == lock) session.unLock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "70", "src_id": "M542", "code": "\nprivate String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n    StringBuilder sb = new StringBuilder(8192);\n\n    for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n        Map<String, Object> info = entry.getValue();\n        TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n        TableElement appendersTable = new TableElement().rightCellPadding(1);\n\n        Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n        table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)))\n            .row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName()))\n            .row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader)))\n            .row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash)))\n            .row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n        \n        if (info.get(LoggerHelper.effectiveLevel) != null) {\n            table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n        }\n        if (info.get(LoggerHelper.config) != null) {\n            table.row(label(LoggerHelper.config).style(Decoration.bold.bold()),\n                    label(\"\" + info.get(LoggerHelper.config)));\n        }\n\n        table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity)))\n            .row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n        @SuppressWarnings(\"unchecked\")\n        List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n        if (appenders != null && !appenders.isEmpty()) {\n            for (Map<String, Object> appenderInfo : appenders) {\n                Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)))\n                    .row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()))\n                    .row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)))\n                    .row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                \n                if (appenderInfo.get(LoggerHelper.file) != null) {\n                    appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                }\n                if (appenderInfo.get(LoggerHelper.target) != null) {\n                    appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                }\n                if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                    appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                }\n                if (appenderInfo.get(LoggerHelper.appenderRef) != null) {\n                    appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n            }\n            table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n        }\n        sb.append(RenderUtil.render(table, width)).append('\\n');\n    }\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "71", "src_id": "M15", "code": "\npublic static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n    URLClassLoader classLoader = new URLClassLoader(\n        new URL[]{new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n    Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n    Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n\n    PrintStream originSysOut = System.out;\n    PrintStream originSysErr = System.err;\n    PrintStream newOut = new PrintStream(out);\n    PrintStream newErr = new PrintStream(out);\n\n    ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n    try {\n        System.setOut(newOut);\n        System.setErr(newErr);\n        Thread.currentThread().setContextClassLoader(classLoader);\n        return (Integer) processMethod.invoke(null, new Object[]{telnetArgs.toArray(new String[0])});\n    } catch (Throwable e) {\n        e = e.getCause();\n        if (e instanceof IOException || e instanceof InterruptedException) return STATUS_ERROR;\n        else {\n            AnsiLog.error(\"process error: {}\", e.toString());\n            AnsiLog.error(e);\n            return STATUS_EXEC_ERROR;\n        }\n    } finally {\n        Thread.currentThread().setContextClassLoader(tccl);\n        System.setOut(originSysOut);\n        System.setErr(originSysErr);\n        newOut.flush();\n        newErr.flush();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1469", "code": "\npublic static FieldVO[] getFields(Class clazz, Integer expand) {\n    Field[] fields = clazz.getDeclaredFields();\n    if (fields.length == 0) return new FieldVO[0];\n\n    List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n    for (Field field : fields) {\n        FieldVO fieldVO = new FieldVO();\n        fieldVO.setName(field.getName());\n        fieldVO.setType(StringUtils.classname(field.getType()));\n        fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n        fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n        \n        boolean isStatic = Modifier.isStatic(field.getModifiers());\n        fieldVO.setStatic(isStatic);\n        if (isStatic) fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n        \n        list.add(fieldVO);\n    }\n    return list.toArray(new FieldVO[0]);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "73", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "74", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach(entry -> \n            args.add(entry.getKey()).add(entry.getValue())\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE:\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE:\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "76", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    List list = (List) data;\n    if (list == null || list.isEmpty()) return null;\n\n    if (list.get(0) instanceof KeyValue) {\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (KeyValue keyValue : (List<KeyValue>) data) {\n            String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        if (resultsData == null) throw new AssertionError(\"Could not detect Results data.\");\n        if (profileData == null) throw new AssertionError(\"Could not detect Profile data.\");\n        return KeyValue.of(\n            resultsBuilder.build(resultsData),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData)\n        );\n    }\n\n    return KeyValue.of(\n        resultsBuilder.build(list.get(0)),\n        ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1))\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    if (keystoreResource != null) {\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    if (trustManagers == null && truststoreResource != null) {\n        KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "78", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;\n                    break;\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    rules = new HashMap<>(rulesDataList.size());\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    break;\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    chunks = new ArrayList<>(chunksDataList.size());\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = new HashMap<>();\n                        for (KeyValue kv : chunkDataAsList) {\n                            chunk.put(\n                                BuilderFactory.STRING.build(kv.getKey()),\n                                BuilderFactory.ENCODED_OBJECT.build(kv.getValue())\n                            );\n                        }\n                        chunks.add(chunk);\n                    }\n                    break;\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) { \n                    // Ignore conversion failure\n                }\n            }\n        }\n        properties.put(prop, value);\n    }\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "79", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n    if (labels != null) {\n        args.add(LABELS);\n        labels.entrySet().forEach(entry -> \n            args.add(entry.getKey()).add(entry.getValue())\n        );\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "80", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n    JedisException suppressed = null;\n\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) continue;\n            jedis.ping();\n            return jedis;\n        } catch (JedisException ex) {\n            if (suppressed == null) suppressed = ex;\n            if (jedis != null) jedis.close();\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) noReachableNode.addSuppressed(suppressed);\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "81", "src_id": "M9", "code": "\n@Override\npublic CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n        entry = putIntoStore(cacheKey, entry);\n        getEvictionPolicy().touch(cacheKey);\n        CacheKey evictedKey = getEvictionPolicy().evictNext();\n        if (evictedKey != null) {\n            delete(evictedKey);\n            stats.evict();\n        }\n        for (Object redisKey : cacheKey.getRedisKeys()) {\n            ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n            redisKeysToCacheKeys.computeIfAbsent(mapKey, k -> \n                ConcurrentHashMap.newKeySet()\n            ).add(cacheKey);\n        }\n        stats.load();\n        return entry;\n    } finally {\n        lock.unlock();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "82", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) return null;\n    String str = STRING.build(data);\n    switch (str) {\n        case \"null\": return null;\n        case \"boolean\": return boolean.class;\n        case \"integer\": return int.class;\n        case \"number\": return float.class;\n        case \"string\": return String.class;\n        case \"object\": return Object.class;\n        case \"array\": return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "83", "src_id": "M491", "code": "\n    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom supported\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,\n            @ResizeMode final int resizeMode) {\n        int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n\n        // save for future sessions\n        player.getPrefs().edit().putInt(\n                player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "84", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        String action = intent.getAction();\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {\n            closeItemsList(); // orientation change requires closing\n        } else if (ACTION_PLAY_PAUSE.equals(action)) {\n            if (!fragmentIsVisible) onFragmentStopped();\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(action)) {\n            fragmentIsVisible = false;\n            onFragmentStopped();\n        } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(action)) {\n            fragmentIsVisible = true;\n            player.useVideoSource(true);\n            if (!isControlsVisible()) hideSystemUIIfNeeded();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "85", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        Resources res = context.getResources();\n        String light = res.getString(R.string.light_theme_key);\n        String black = res.getString(R.string.black_theme_key);\n        String auto = res.getString(R.string.auto_device_theme_key);\n        String selected = getSelectedThemeKey(context);\n\n        if (selected.equals(light)) return R.style.LightSettingsTheme;\n        else if (selected.equals(black)) return R.style.BlackSettingsTheme;\n        else if (selected.equals(auto)) {\n            if (isDeviceDarkThemeEnabled(context)) {\n                String nightTheme = getSelectedNightThemeKey(context);\n                return nightTheme.equals(black) ? R.style.BlackSettingsTheme : R.style.DarkSettingsTheme;\n            } else return R.style.LightSettingsTheme;\n        } else return R.style.DarkSettingsTheme; // default\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "86", "src_id": "M895", "code": "\n    @Override\n    public Bitmap transform(final Bitmap source) {\n        if (DEBUG) Log.d(TAG, \"Thumbnail - transform() called\");\n\n        float width = Math.min(\n                context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                source.getWidth());\n        int newHeight = (int) (source.getHeight() / (source.getWidth() / width));\n        \n        Bitmap result = BitmapCompat.createScaledBitmap(source, (int)width, newHeight, null, true);\n        if (result == source || !result.isMutable()) {\n            Bitmap copied = BitmapCompat.createScaledBitmap(\n                    source,\n                    (int)width - 1,\n                    (int)(source.getHeight() / (source.getWidth() / (width - 1))),\n                    null,\n                    true);\n            source.recycle();\n            return copied;\n        } else {\n            source.recycle();\n            return result;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "87", "src_id": "M225", "code": "\n    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) return;\n        if (DEBUG) Log.d(TAG, \"onBroadcastReceived() intent = [\" + intent + \"]\");\n\n        String action = intent.getAction();\n        switch (action) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                break;\n        }\n\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "88", "src_id": "M749", "code": "\n    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        Throwable t = errorInfo.getThrowable();\n        if (t != null) t.printStackTrace();\n\n        if (t instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n            context.startActivity(intent);\n        } else if (t != null && ExceptionUtils.isNetworkRelated(t)) {\n            Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n        } else if (t instanceof AgeRestrictedContentException) {\n            Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n        } else if (t instanceof GeographicRestrictionException) {\n            Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n        } else if (t instanceof PaidContentException) {\n            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n        } else if (t instanceof PrivateContentException) {\n            Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n        } else if (t instanceof SoundCloudGoPlusContentException) {\n            Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n        } else if (t instanceof YoutubeMusicPremiumContentException) {\n            Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n        } else if (t instanceof ContentNotAvailableException) {\n            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n        } else if (t instanceof ContentNotSupportedException) {\n            Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n        } else ErrorUtil.createNotification(context, errorInfo);\n\n        if (context instanceof RouterActivity) ((RouterActivity) context).finish();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "89", "src_id": "M999", "code": "\n    public static void openVideoDetailFragment(@NonNull Context context,\n            @NonNull FragmentManager fragmentManager,\n            int serviceId,\n            @Nullable String url,\n            @NonNull String title,\n            @Nullable PlayQueue playQueue,\n            boolean switchingPlayers) {\n\n        boolean autoPlay;\n        PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        else if (switchingPlayers) autoPlay = PlayerHolder.getInstance().isPlaying();\n        else if (playerType == PlayerType.MAIN) autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        else autoPlay = false;\n\n        RunnableWithVideoDetailFragment onReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (switchingPlayers) {\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP ||\n                        PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } else detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            detailFragment.scrollToTop();\n        };\n\n        Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n            onReady.run((VideoDetailFragment) fragment);\n        } else {\n            VideoDetailFragment instance = VideoDetailFragment\n                    .getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n\n            defaultTransaction(fragmentManager)\n                    .replace(R.id.fragment_player_holder, instance)\n                    .runOnCommit(() -> onReady.run(instance))\n                    .commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "90", "src_id": "M698", "code": "\n    @Override\n    public void handleResult(@NonNull ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG)\n                    .into(binding.channelBannerImage);\n        } else binding.channelBannerImage.setImageDrawable(null); // no banner\n\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG)\n                .into(binding.subChannelAvatarView);\n\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        binding.channelSubscriberView.setText(result.getSubscriberCount() >= 0 ?\n                Localization.shortSubscriberCount(activity, result.getSubscriberCount()) :\n                getString(R.string.subscribers_count_not_available));\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(\n                    getString(R.string.channel_created_by),\n                    currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n\n        updateRssButton();\n        channelContentNotSupported = false;\n        for (Throwable t : result.getErrors()) {\n            if (t instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n\n        disposables.clear();\n        if (subscribeButtonMonitor != null) subscribeButtonMonitor.dispose();\n\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "91", "src_id": "M379", "code": "\n    @Override\n    public void onTextTracksChanged(@NonNull Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n\n        boolean textSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) ||\n                currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null || !textSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        List<Tracks.Group> textTracks = currentTracks.getGroups().stream()\n                .filter(g -> C.TRACK_TYPE_TEXT == g.getType())\n                .collect(Collectors.toList());\n        List<String> languages = textTracks.stream()\n                .map(Tracks.Group::getMediaTrackGroup)\n                .filter(track -> track.length > 0)\n                .map(track -> track.getFormat(0).language)\n                .collect(Collectors.toList());\n\n        Optional<Format> selected = textTracks.stream()\n                .filter(Tracks.Group::isSelected)\n                .filter(info -> info.getMediaTrackGroup().length >= 1)\n                .map(info -> info.getMediaTrackGroup().getFormat(0))\n                .findFirst();\n\n        buildCaptionMenu(languages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(\n                player.getCaptionRendererIndex()) || selected.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else binding.captionTextView.setText(selected.get().language);\n        binding.captionTextView.setVisibility(languages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "92", "src_id": "M894", "code": "\n    public static RequestCreator loadScaledDownThumbnail(final Context context,\n            @NonNull final List<Image> images) {\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n            @Override\n            public Bitmap transform(Bitmap source) {\n                if (DEBUG) Log.d(TAG, \"Thumbnail - transform() called\");\n\n                float width = Math.min(\n                        context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n                        source.getWidth());\n                int height = (int)(source.getHeight() / (source.getWidth() / width));\n                \n                Bitmap result = BitmapCompat.createScaledBitmap(source, (int)width, height, null, true);\n                if (result == source || !result.isMutable()) {\n                    Bitmap copied = BitmapCompat.createScaledBitmap(\n                            source,\n                            (int)width - 1,\n                            (int)(source.getHeight() / (source.getWidth() / (width - 1))),\n                            null,\n                            true);\n                    source.recycle();\n                    return copied;\n                } else {\n                    source.recycle();\n                    return result;\n                }\n            }\n\n            @Override\n            public String key() {\n                return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n            }\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "93", "src_id": "M267", "code": "\n@Override\npublic void startElement(final XlsxReadContext xlsxReadContext, final String name, \n        final Attributes attributes) {\n    final String ref = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_REF);\n    if (StringUtils.isEmpty(ref)) {\n        return;\n    }\n\n    // Hyperlink has 2 cases:\n    // Case 1: In the 'location' tag\n    final String location = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_LOCATION);\n    if (location != null) {\n        final CellExtra cellExtra = new CellExtra(CellExtraTypeEnum.HYPERLINK, location, ref);\n        xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n        xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n        return;\n    }\n\n    // Case 2: In the 'r:id' tag, then go to 'PackageRelationshipCollection'\n    final String rId = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_RID);\n    final PackageRelationshipCollection packageRelationshipCollection = xlsxReadContext\n            .xlsxReadSheetHolder().getPackageRelationshipCollection();\n    if (rId == null || packageRelationshipCollection == null) {\n        return;\n    }\n\n    Optional.ofNullable(packageRelationshipCollection.getRelationshipByID(rId))\n            .map(PackageRelationship::getTargetURI)\n            .ifPresent(uri -> {\n                final CellExtra cellExtra = new CellExtra(\n                        CellExtraTypeEnum.HYPERLINK, uri.toString(), ref);\n                xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n                xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n            });\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "94", "src_id": "M248", "code": "\n@Override\npublic void processRecord(final XlsReadContext xlsReadContext, final Record record) {\n    final LabelSSTRecord lsrec = (LabelSSTRecord) record;\n    final ReadCache readCache = xlsReadContext.readWorkbookHolder().getReadCache();\n    final Map<Integer, Cell> cellMap = xlsReadContext.xlsReadSheetHolder().getCellMap();\n    \n    if (readCache == null) {\n        cellMap.put((int) lsrec.getColumn(), \n                ReadCellData.newEmptyInstance(lsrec.getRow(), (int) lsrec.getColumn()));\n        return;\n    }\n    \n    String data = readCache.get(lsrec.getSSTIndex());\n    if (data == null) {\n        cellMap.put((int) lsrec.getColumn(), \n                ReadCellData.newEmptyInstance(lsrec.getRow(), (int) lsrec.getColumn()));\n        return;\n    }\n    \n    if (xlsReadContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\n        data = data.trim();\n    }\n    \n    cellMap.put((int) lsrec.getColumn(), \n            ReadCellData.newInstance(data, lsrec.getRow(), (int) lsrec.getColumn()));\n    xlsReadContext.xlsReadSheetHolder().setTempRowType(RowTypeEnum.DATA);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "95", "src_id": "M106", "code": "\nprivate Row createRowIfNecessary(final Sheet sheet, final Sheet cachedSheet, \n        final Integer lastRowIndex, final FillConfig fillConfig, \n        final AnalysisCell analysisCell, final boolean isOriginalCell,\n        final RowWriteHandlerContext rowWriteHandlerContext) {\n    \n    rowWriteHandlerContext.setRowIndex(lastRowIndex);\n    Row row = sheet.getRow(lastRowIndex);\n    if (row != null) {\n        checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n        rowWriteHandlerContext.setRow(row);\n        return row;\n    }\n    \n    row = cachedSheet.getRow(lastRowIndex);\n    if (row == null) {\n        rowWriteHandlerContext.setRowIndex(lastRowIndex);\n        WriteHandlerUtils.beforeRowCreate(rowWriteHandlerContext);\n\n        if (fillConfig.getForceNewRow()) {\n            row = cachedSheet.createRow(lastRowIndex);\n        } else {\n            // Handle case where disk has empty rows causing createRow failure\n            try {\n                row = sheet.createRow(lastRowIndex);\n            } catch (IllegalArgumentException ignore) {\n                row = cachedSheet.createRow(lastRowIndex);\n            }\n        }\n        \n        rowWriteHandlerContext.setRow(row);\n        checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n        WriteHandlerUtils.afterRowCreate(rowWriteHandlerContext);\n    } else {\n        checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n        rowWriteHandlerContext.setRow(row);\n    }\n    \n    return row;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "96", "src_id": "M12", "code": "\nprivate Object buildNoModel(final Map<Integer, ReadCellData<?>> cellDataMap, \n        final ReadSheetHolder readSheetHolder, final AnalysisContext context) {\n    \n    int index = 0;\n    final Map<Integer, Object> map = MapUtils.newLinkedHashMapWithExpectedSize(\n            cellDataMap.size());\n\n    for (final Map.Entry<Integer, ReadCellData<?>> entry : cellDataMap.entrySet()) {\n        final Integer key = entry.getKey();\n        final ReadCellData<?> cellData = entry.getValue();\n        \n        while (index < key) {\n            map.put(index, null);\n            index++;\n        }\n        index++;\n\n        final ReadDefaultReturnEnum readDefaultReturn = context.readWorkbookHolder()\n                .getReadDefaultReturn();\n        if (readDefaultReturn == ReadDefaultReturnEnum.STRING) {\n            // Convert to string\n            map.put(key, ConverterUtils.convertToJavaObject(\n                    cellData, null, null, readSheetHolder.converterMap(),\n                    context, context.readRowHolder().getRowIndex(), key));\n        } else {\n            // Return ReadCellData\n            final ReadCellData<?> convertedReadCellData = convertReadCellData(\n                    cellData, readDefaultReturn, readSheetHolder, context, key);\n            if (readDefaultReturn == ReadDefaultReturnEnum.READ_CELL_DATA) {\n                map.put(key, convertedReadCellData);\n            } else {\n                map.put(key, convertedReadCellData.getData());\n            }\n        }\n    }\n    \n    // Handle trailing empty cells (fixes issue #2014)\n    final int headSize = calculateHeadSize(readSheetHolder);\n    while (index < headSize) {\n        map.put(index, null);\n        index++;\n    }\n    \n    return map;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "97", "src_id": "M94", "code": "\nprivate void fillComment(final CellWriteHandlerContext cellWriteHandlerContext, \n        final CommentData commentData) {\n    \n    if (commentData == null) {\n        return;\n    }\n    \n    final Integer rowIndex = cellWriteHandlerContext.getRowIndex();\n    final Integer columnIndex = cellWriteHandlerContext.getColumnIndex();\n    final Sheet sheet = cellWriteHandlerContext.getWriteSheetHolder().getSheet();\n    final Cell cell = cellWriteHandlerContext.getCell();\n    final ClientAnchor anchor;\n\n    if (writeContext.writeWorkbookHolder().getExcelType() == ExcelTypeEnum.XLSX) {\n        anchor = new XSSFClientAnchor(\n                StyleUtil.getCoordinate(commentData.getLeft()),\n                StyleUtil.getCoordinate(commentData.getTop()),\n                StyleUtil.getCoordinate(commentData.getRight()),\n                StyleUtil.getCoordinate(commentData.getBottom()),\n                StyleUtil.getCellCoordinate(columnIndex, \n                        commentData.getFirstColumnIndex(),\n                        commentData.getRelativeFirstColumnIndex()),\n                StyleUtil.getCellCoordinate(rowIndex, \n                        commentData.getFirstRowIndex(),\n                        commentData.getRelativeFirstRowIndex()),\n                StyleUtil.getCellCoordinate(columnIndex, \n                        commentData.getLastColumnIndex(),\n                        commentData.getRelativeLastColumnIndex()) + 1,\n                StyleUtil.getCellCoordinate(rowIndex, \n                        commentData.getLastRowIndex(),\n                        commentData.getRelativeLastRowIndex()) + 1);\n    } else {\n        anchor = new HSSFClientAnchor(\n                StyleUtil.getCoordinate(commentData.getLeft()),\n                StyleUtil.getCoordinate(commentData.getTop()),\n                StyleUtil.getCoordinate(commentData.getRight()),\n                StyleUtil.getCoordinate(commentData.getBottom()),\n                (short) StyleUtil.getCellCoordinate(columnIndex, \n                        commentData.getFirstColumnIndex(),\n                        commentData.getRelativeFirstColumnIndex()),\n                StyleUtil.getCellCoordinate(rowIndex, \n                        commentData.getFirstRowIndex(),\n                        commentData.getRelativeFirstRowIndex()),\n                (short) (StyleUtil.getCellCoordinate(columnIndex, \n                        commentData.getLastColumnIndex(),\n                        commentData.getRelativeLastColumnIndex()) + 1),\n                StyleUtil.getCellCoordinate(rowIndex, \n                        commentData.getLastRowIndex(),\n                        commentData.getRelativeLastRowIndex()) + 1);\n    }\n\n    final Comment comment = sheet.createDrawingPatriarch().createCellComment(anchor);\n    if (commentData.getRichTextStringData() != null) {\n        comment.setString(StyleUtil.buildRichTextString(\n                writeContext.writeWorkbookHolder(), \n                commentData.getRichTextStringData()));\n    }\n    \n    if (commentData.getAuthor() != null) {\n        comment.setAuthor(commentData.getAuthor());\n    }\n    \n    cell.setCellComment(comment);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "98", "src_id": "M212", "code": "\nprivate Format getFormat(final Double data, final Short dataFormat, \n        final String dataFormatString) {\n    \n    // Handle multi-part conditional formats separately\n    String formatStr = dataFormatString;\n    if (formatStr.contains(\";\") &&\n            (formatStr.indexOf(';') != formatStr.lastIndexOf(';')\n                || rangeConditionalPattern.matcher(formatStr).matches())) {\n        \n        try {\n            // Attempt to format via CellFormat\n            final CellFormat cfmt = CellFormat.getInstance(locale, formatStr);\n            final Object cellValueO = data;\n            \n            if (DateUtils.isADateFormat(dataFormat, formatStr) &&\n                    data.doubleValue() != 0.0) {\n                cellValueO = DateUtils.getJavaDate(data, use1904windowing);\n            }\n            \n            return new CellFormatResultWrapper(cfmt.apply(cellValueO));\n        } catch (Exception e) {\n            LOGGER.warn(\"Formatting failed for format {}, falling back\", formatStr, e);\n        }\n    }\n\n    // Check format cache\n    Format format = formats.get(formatStr);\n    if (format != null) {\n        return format;\n    }\n\n    // Handle special built-in types\n    if (\"General\".equalsIgnoreCase(formatStr) || \"@\".equals(formatStr)) {\n        format = getDefaultFormat();\n        addFormat(formatStr, format);\n        return format;\n    }\n\n    // Create and cache new format\n    format = createFormat(dataFormat, formatStr);\n    addFormat(formatStr, format);\n    return format;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "99", "src_id": "M35", "code": "\nprivate static void buildStyleProperty(final StyleProperty styleProperty, \n        final WriteCellStyle writeCellStyle) {\n    \n    if (styleProperty == null) {\n        return;\n    }\n    \n    // Apply style properties conditionally\n    if (styleProperty.getDataFormatData() != null) {\n        if (writeCellStyle.getDataFormatData() == null) {\n            writeCellStyle.setDataFormatData(styleProperty.getDataFormatData());\n        } else {\n            DataFormatData.merge(\n                    styleProperty.getDataFormatData(), \n                    writeCellStyle.getDataFormatData());\n        }\n    }\n    \n    // Set all available properties\n    setIfNotNull(styleProperty.getHidden(), writeCellStyle::setHidden);\n    setIfNotNull(styleProperty.getLocked(), writeCellStyle::setLocked);\n    setIfNotNull(styleProperty.getQuotePrefix(), writeCellStyle::setQuotePrefix);\n    setIfNotNull(styleProperty.getHorizontalAlignment(), writeCellStyle::setHorizontalAlignment);\n    setIfNotNull(styleProperty.getWrapped(), writeCellStyle::setWrapped);\n    setIfNotNull(styleProperty.getVerticalAlignment(), writeCellStyle::setVerticalAlignment);\n    setIfNotNull(styleProperty.getRotation(), writeCellStyle::setRotation);\n    setIfNotNull(styleProperty.getIndent(), writeCellStyle::setIndent);\n    \n    // Border properties\n    setIfNotNull(styleProperty.getBorderLeft(), writeCellStyle::setBorderLeft);\n    setIfNotNull(styleProperty.getBorderRight(), writeCellStyle::setBorderRight);\n    setIfNotNull(styleProperty.getBorderTop(), writeCellStyle::setBorderTop);\n    setIfNotNull(styleProperty.getBorderBottom(), writeCellStyle::setBorderBottom);\n    \n    // Border colors\n    setIfNotNull(styleProperty.getLeftBorderColor(), writeCellStyle::setLeftBorderColor);\n    setIfNotNull(styleProperty.getRightBorderColor(), writeCellStyle::setRightBorderColor);\n    setIfNotNull(styleProperty.getTopBorderColor(), writeCellStyle::setTopBorderColor);\n    setIfNotNull(styleProperty.getBottomBorderColor(), writeCellStyle::setBottomBorderColor);\n    \n    // Fill properties\n    setIfNotNull(styleProperty.getFillPatternType(), writeCellStyle::setFillPatternType);\n    setIfNotNull(styleProperty.getFillBackgroundColor(), writeCellStyle::setFillBackgroundColor);\n    setIfNotNull(styleProperty.getFillForegroundColor(), writeCellStyle::setFillForegroundColor);\n    \n    // Other properties\n    setIfNotNull(styleProperty.getShrinkToFit(), writeCellStyle::setShrinkToFit);\n}\n\n// Helper method for concise property setting\nprivate static <T> void setIfNotNull(final T value, final Consumer<T> setter) {\n    if (value != null) {\n        setter.accept(value);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "100", "src_id": "M90", "code": "\nprivate void addJavaObjectToExcel(final Object oneRowData, final Row row, \n        final int rowIndex, final int relativeRowIndex) {\n    \n    final WriteHolder currentWriteHolder = writeContext.currentWriteHolder();\n    final BeanMap beanMap = BeanMapUtils.create(oneRowData);\n    final Set<String> beanKeySet = new HashSet<>(beanMap.keySet());\n    final Set<String> beanMapHandledSet = new HashSet<>();\n    int maxCellIndex = -1;\n\n    // Handle class-based mapping\n    if (HeadKindEnum.CLASS.equals(currentWriteHolder.excelWriteHeadProperty().getHeadKind())) {\n        final Map<Integer, Head> headMap = currentWriteHolder.excelWriteHeadProperty()\n                .getHeadMap();\n        \n        for (final Map.Entry<Integer, Head> entry : headMap.entrySet()) {\n            final int columnIndex = entry.getKey();\n            final Head head = entry.getValue();\n            final String name = head.getFieldName();\n            \n            if (!beanKeySet.contains(name)) {\n                continue;\n            }\n\n            final ExcelContentProperty excelContentProperty = ClassUtils\n                    .declaredExcelContentProperty(\n                        beanMap,\n                        currentWriteHolder.excelWriteHeadProperty().getHeadClazz(),\n                        name,\n                        currentWriteHolder);\n            \n            final CellWriteHandlerContext cellWriteHandlerContext = WriteHandlerUtils\n                    .createCellWriteHandlerContext(\n                        writeContext, row, rowIndex, head, columnIndex, \n                        relativeRowIndex, Boolean.FALSE, excelContentProperty);\n            \n            WriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n            final Cell cell = WorkBookUtil.createCell(row, columnIndex);\n            cellWriteHandlerContext.setCell(cell);\n            WriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n\n            cellWriteHandlerContext.setOriginalValue(beanMap.get(name));\n            cellWriteHandlerContext.setOriginalFieldClass(head.getField().getType());\n            converterAndSet(cellWriteHandlerContext);\n            WriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n\n            beanMapHandledSet.add(name);\n            maxCellIndex = Math.max(maxCellIndex, columnIndex);\n        }\n    }\n\n    // Handle remaining fields\n    if (beanMapHandledSet.size() == beanMap.size()) {\n        return;\n    }\n    maxCellIndex++;\n\n    final FieldCache fieldCache = ClassUtils.declaredFields(\n            oneRowData.getClass(), currentWriteHolder);\n    \n    for (final Map.Entry<Integer, FieldWrapper> entry : fieldCache\n            .getSortedFieldMap().entrySet()) {\n        \n        final FieldWrapper field = entry.getValue();\n        final String fieldName = field.getFieldName();\n        final boolean uselessData = !beanKeySet.contains(fieldName) \n                || beanMapHandledSet.contains(fieldName);\n        \n        if (uselessData) {\n            continue;\n        }\n        \n        final Object value = beanMap.get(fieldName);\n        final ExcelContentProperty excelContentProperty = ClassUtils\n                .declaredExcelContentProperty(\n                    beanMap,\n                    currentWriteHolder.excelWriteHeadProperty().getHeadClazz(),\n                    fieldName,\n                    currentWriteHolder);\n        \n        final CellWriteHandlerContext cellWriteHandlerContext = WriteHandlerUtils\n                .createCellWriteHandlerContext(\n                    writeContext, row, rowIndex, null, maxCellIndex, \n                    relativeRowIndex, Boolean.FALSE, excelContentProperty);\n        \n        WriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n        final Cell cell = WorkBookUtil.createCell(row, maxCellIndex);\n        cellWriteHandlerContext.setCell(cell);\n        WriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n\n        cellWriteHandlerContext.setOriginalValue(value);\n        cellWriteHandlerContext.setOriginalFieldClass(\n                FieldUtils.getFieldClass(beanMap, fieldName, value));\n        \n        converterAndSet(cellWriteHandlerContext);\n        WriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n        maxCellIndex++;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "101", "src_id": "M50", "code": "\npublic CellStyle createCellStyle(final WriteCellStyle writeCellStyle, \n        final CellStyle originCellStyle) {\n    \n    if (writeCellStyle == null) {\n        return originCellStyle;\n    }\n\n    short styleIndex = -1;\n    Font originFont = null;\n    boolean useCache = true;\n    \n    if (originCellStyle != null) {\n        styleIndex = originCellStyle.getIndex();\n        if (originCellStyle instanceof XSSFCellStyle) {\n            originFont = ((XSSFCellStyle) originCellStyle).getFont();\n        } else if (originCellStyle instanceof HSSFCellStyle) {\n            originFont = ((HSSFCellStyle) originCellStyle).getFont(workbook);\n        }\n        useCache = false;\n    }\n\n    final Map<WriteCellStyle, CellStyle> cellStyleMap = cellStyleIndexMap\n            .computeIfAbsent(styleIndex, key -> MapUtils.newHashMap());\n    \n    CellStyle cellStyle = cellStyleMap.get(writeCellStyle);\n    if (cellStyle != null) {\n        return cellStyle;\n    }\n    \n    if (log.isDebugEnabled()) {\n        log.info(\"Creating new style: {}, {}\", writeCellStyle, originCellStyle);\n    }\n    \n    final WriteCellStyle tempWriteCellStyle = new WriteCellStyle();\n    WriteCellStyle.merge(writeCellStyle, tempWriteCellStyle);\n\n    cellStyle = StyleUtil.buildCellStyle(workbook, originCellStyle, tempWriteCellStyle);\n    final Short dataFormat = createDataFormat(\n            tempWriteCellStyle.getDataFormatData(), useCache);\n    \n    if (dataFormat != null) {\n        cellStyle.setDataFormat(dataFormat);\n    }\n    \n    final Font font = createFont(\n            tempWriteCellStyle.getWriteFont(), originFont, useCache);\n    \n    if (font != null) {\n        cellStyle.setFont(font);\n    }\n    \n    cellStyleMap.put(tempWriteCellStyle, cellStyle);\n    return cellStyle;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "102", "src_id": "M21", "code": "\nprivate void buildHead(final AnalysisContext analysisContext, \n        final Map<Integer, ReadCellData<?>> cellDataMap) {\n    \n    // Determine max column with data\n    if (MapUtils.isNotEmpty(cellDataMap)) {\n        cellDataMap.entrySet().stream()\n                .filter(entry -> CellDataTypeEnum.EMPTY != entry.getValue().getType())\n                .forEach(entry -> analysisContext.readSheetHolder()\n                        .setMaxNotEmptyDataHeadSize(entry.getKey()));\n    }\n\n    if (!HeadKindEnum.CLASS.equals(analysisContext.currentReadHolder()\n            .excelReadHeadProperty().getHeadKind())) {\n        return;\n    }\n    \n    final Map<Integer, String> dataMap = ConverterUtils\n            .convertToStringMap(cellDataMap, analysisContext);\n    final ExcelReadHeadProperty excelHeadPropertyData = analysisContext.readSheetHolder()\n            .excelReadHeadProperty();\n    final Map<Integer, Head> headMapData = excelHeadPropertyData.getHeadMap();\n    final Map<Integer, Head> tmpHeadMap = new HashMap<>(\n            headMapData.size() * 4 / 3 + 1);\n    \n    for (final Map.Entry<Integer, Head> entry : headMapData.entrySet()) {\n        final Head headData = entry.getValue();\n        if (headData.getForceIndex() || !headData.getForceName()) {\n            tmpHeadMap.put(entry.getKey(), headData);\n            continue;\n        }\n        \n        final List<String> headNameList = headData.getHeadNameList();\n        final String headName = headNameList.get(headNameList.size() - 1);\n        \n        for (final Map.Entry<Integer, String> stringEntry : dataMap.entrySet()) {\n            if (stringEntry == null) {\n                continue;\n            }\n            \n            String headString = stringEntry.getValue();\n            final Integer stringKey = stringEntry.getKey();\n            if (StringUtils.isEmpty(headString)) {\n                continue;\n            }\n            \n            if (analysisContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\n                headString = headString.trim();\n            }\n            \n            if (headName.equals(headString)) {\n                headData.setColumnIndex(stringKey);\n                tmpHeadMap.put(stringKey, headData);\n                break;\n            }\n        }\n    }\n    \n    excelHeadPropertyData.setHeadMap(tmpHeadMap);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "113", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        final Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n            if (err instanceof InterruptedIOException \n                || err instanceof ClosedByInterruptException \n                || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1031", "code": "\n    void establishConnection(final int threadId, final HttpURLConnection conn) throws IOException, HttpError {\n        final int statusCode = conn.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // let the download thread handle this error\n            default:\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "115", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n\n        if (v1) {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        }\n\n        obj.bMediaRate = stream.readInt();\n\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "116", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n        try {\n            long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n            int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n\n            mIs = mConn.getInputStream();\n\n            final byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n            dispose();\n\n            // if thread goes interrupted check if the last part is written\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n\n            mMission.fallbackResumeOffset = start;\n\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams, recover when URL has expired\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n\n            run(); // try again\n            return;\n        }\n\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1141", "code": "\n    private void flushAuxiliar(final long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n\n        out.flush();\n        aux.flush();\n\n        final boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        final byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long length = amount;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n        if (underflow) {\n            if (out.offset >= out.length) {\n                // calculate the aux underflow pointer\n                if (aux.offset < amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        } else {\n            out.offset += amount;\n            aux.offset -= amount;\n        }\n\n        out.length += amount;\n\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n\n            aux.length -= amount;\n            length = aux.length;\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n        }\n\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1106", "code": "\n    private void showError(\n        final DownloadMission mission, \n        final UserAction action, \n        @StringRes final int reason\n    ) {\n        final StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n\n        request.append(\" [\");\n        if (mission.recoveryInfo != null) {\n            for (final MissionRecoveryInfo recovery : mission.recoveryInfo) {\n                request.append(' ')\n                    .append(recovery.toString())\n                    .append(' ');\n            }\n        }\n        request.append(\"]\");\n\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(\n            mContext,\n            new ErrorInfo(\n                ErrorInfo.Companion.throwableToStringList(mission.errObject),\n                action,\n                service,\n                request.toString(),\n                reason\n            )\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1067", "code": "\n    void startMission(final DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // save metadata before continuing\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n\n            final boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "120", "src_id": "M1136", "code": "\n    @Override\n    int process(final SharpStream out, final SharpStream... sources) throws IOException {\n        // check if subtitle is already in srt\n        final String format = getArgumentAt(0, null);\n        final boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n        if (format == null || format.equals(\"ttml\")) {\n            final SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException ? 1 : 8;\n            }\n\n            return OK_RESULT;\n        } else if (format.equals(\"srt\")) {\n            final byte[] buffer = new byte[8 * 1024];\n            int read;\n            while ((read = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, read);\n            }\n            return OK_RESULT;\n        }\n\n        throw new UnsupportedOperationException(\n            \"Can't convert this subtitle, unimplemented format: \" + format\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "121", "src_id": "M1047", "code": "\n    private void joinForThreads(final int millis) {\n        final Thread currentThread = Thread.currentThread();\n\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n            }\n        }\n\n        // if a thread is still alive:\n        //   slow device\n        //   user spamming start/pause\n        //   start() called quickly after pause()\n        for (final Thread thread : threads) {\n            if (!thread.isAlive() || thread == Thread.currentThread()) {\n                continue;\n            }\n            thread.interrupt();\n        }\n\n        try {\n            for (final Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue;\n                }\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n                if (millis > 0) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "122", "src_id": "M95", "code": "\npublic static HealthCountsStream getInstance(\n        HystrixCommandKey commandKey, int numBuckets, int bucketSizeInMs) {\n    HealthCountsStream initialStream = streams.get(commandKey.name());\n    if (initialStream != null) {\n        return initialStream;\n    } else {\n        final HealthCountsStream healthStream;\n        synchronized (HealthCountsStream.class) {\n            HealthCountsStream existingStream = streams.get(commandKey.name());\n            if (existingStream == null) {\n                HealthCountsStream newStream = new HealthCountsStream(\n                        commandKey,\n                        numBuckets,\n                        bucketSizeInMs,\n                        HystrixCommandMetrics.appendEventToBucket);\n\n                streams.putIfAbsent(commandKey.name(), newStream);\n                healthStream = newStream;\n            } else {\n                healthStream = existingStream;\n            }\n        }\n        healthStream.startCachingStreamValuesIfUnstarted();\n        return healthStream;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "123", "src_id": "M118", "code": "\npublic Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {\n    Map<CommandAndCacheKey, Integer> cachingDetector = \n            new HashMap<CommandAndCacheKey, Integer>();\n    List<HystrixInvokableInfo<?>> nonCachedExecutions = \n            new ArrayList<HystrixInvokableInfo<?>>(executions.size());\n    for (HystrixInvokableInfo<?> execution : executions) {\n        if (execution.getPublicCacheKey() != null) {\n            CommandAndCacheKey key = new CommandAndCacheKey(\n                    execution.getCommandKey().name(), \n                    execution.getPublicCacheKey());\n            Integer count = cachingDetector.get(key);\n            if (count != null) {\n                cachingDetector.put(key, count + 1);\n            } else {\n                cachingDetector.put(key, 0);\n            }\n        }\n        if (!execution.isResponseFromCache()) {\n            nonCachedExecutions.add(execution);\n        }\n    }\n\n    Map<ExecutionSignature, List<Integer>> commandDeduper = \n            new HashMap<ExecutionSignature, List<Integer>>();\n    for (HystrixInvokableInfo<?> execution : nonCachedExecutions) {\n        int cachedCount = 0;\n        String cacheKey = execution.getPublicCacheKey();\n        if (cacheKey != null) {\n            CommandAndCacheKey key = new CommandAndCacheKey(\n                    execution.getCommandKey().name(), \n                    cacheKey);\n            cachedCount = cachingDetector.get(key);\n        }\n        ExecutionSignature signature;\n        if (cachedCount > 0) {\n            signature = ExecutionSignature.from(\n                    execution, \n                    cacheKey, \n                    cachedCount);\n        } else {\n            signature = ExecutionSignature.from(execution);\n        }\n        List<Integer> currentLatencyList = commandDeduper.get(signature);\n        if (currentLatencyList != null) {\n            currentLatencyList.add(execution.getExecutionTimeInMilliseconds());\n        } else {\n            List<Integer> newLatencyList = new ArrayList<Integer>();\n            newLatencyList.add(execution.getExecutionTimeInMilliseconds());\n            commandDeduper.put(signature, newLatencyList);\n        }\n    }\n\n    return commandDeduper;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "124", "src_id": "M223", "code": "\npublic ThreadPoolExecutor getThreadPool(\n        final HystrixThreadPoolKey threadPoolKey,\n        HystrixThreadPoolProperties threadPoolProperties) {\n    final ThreadFactory threadFactory = getThreadFactory(threadPoolKey);\n    final boolean allowMaximumSizeToDivergeFromCoreSize = \n            threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();\n    final int dynamicCoreSize = threadPoolProperties.coreSize().get();\n    final int keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();\n    final int maxQueueSize = threadPoolProperties.maxQueueSize().get();\n    final BlockingQueue<Runnable> workQueue = getBlockingQueue(maxQueueSize);\n\n    if (allowMaximumSizeToDivergeFromCoreSize) {\n        final int dynamicMaximumSize = threadPoolProperties.maximumSize().get();\n        if (dynamicCoreSize > dynamicMaximumSize) {\n            logger.error(\n                    \"Hystrix ThreadPool configuration at startup for : \" \n                    + threadPoolKey.name() \n                    + \" is trying to set coreSize = \" \n                    + dynamicCoreSize \n                    + \" and maximumSize = \" \n                    + dynamicMaximumSize \n                    + \".  Maximum size will be set to \" \n                    + dynamicCoreSize \n                    + \", the coreSize value, since it must be equal to or greater than the coreSize value\");\n            return new ThreadPoolExecutor(\n                    dynamicCoreSize,\n                    dynamicCoreSize,\n                    keepAliveTime,\n                    TimeUnit.MINUTES,\n                    workQueue,\n                    threadFactory);\n        } else {\n            return new ThreadPoolExecutor(\n                    dynamicCoreSize,\n                    dynamicMaximumSize,\n                    keepAliveTime,\n                    TimeUnit.MINUTES,\n                    workQueue,\n                    threadFactory);\n        }\n    } else {\n        return new ThreadPoolExecutor(\n                dynamicCoreSize,\n                dynamicCoreSize,\n                keepAliveTime,\n                TimeUnit.MINUTES,\n                workQueue,\n                threadFactory);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "125", "src_id": "M498", "code": "\nprotected static String convertToJson(HystrixUtilization utilization) \n        throws IOException {\n    StringWriter jsonString = new StringWriter();\n    JsonGenerator json = jsonFactory.createGenerator(jsonString);\n\n    json.writeStartObject();\n    json.writeStringField(\"type\", \"HystrixUtilization\");\n    json.writeObjectFieldStart(\"commands\");\n    for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : \n            utilization.getCommandUtilizationMap().entrySet()) {\n        final HystrixCommandKey key = entry.getKey();\n        final HystrixCommandUtilization commandUtilization = entry.getValue();\n        writeCommandUtilizationJson(json, key, commandUtilization);\n    }\n    json.writeEndObject();\n\n    json.writeObjectFieldStart(\"threadpools\");\n    for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : \n            utilization.getThreadPoolUtilizationMap().entrySet()) {\n        final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n        final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n        writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n    }\n    json.writeEndObject();\n    json.writeEndObject();\n    json.close();\n\n    return jsonString.getBuffer().toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "126", "src_id": "M171", "code": "\nEventCounts plus(HystrixEventType eventType, int count) {\n    BitSet newBitSet = (BitSet) events.clone();\n    int localNumEmits = numEmissions;\n    int localNumFallbackEmits = numFallbackEmissions;\n    int localNumCollapsed = numCollapsed;\n    switch (eventType) {\n        case EMIT:\n            newBitSet.set(HystrixEventType.EMIT.ordinal());\n            localNumEmits += count;\n            break;\n        case FALLBACK_EMIT:\n            newBitSet.set(HystrixEventType.FALLBACK_EMIT.ordinal());\n            localNumFallbackEmits += count;\n            break;\n        case COLLAPSED:\n            newBitSet.set(HystrixEventType.COLLAPSED.ordinal());\n            localNumCollapsed += count;\n            break;\n        default:\n            newBitSet.set(eventType.ordinal());\n            break;\n    }\n    return new EventCounts(\n            newBitSet, \n            localNumEmits, \n            localNumFallbackEmits, \n            localNumCollapsed);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "127", "src_id": "M448", "code": "\nprivate static void writeThreadPoolMetrics(\n        final HystrixThreadPoolMetrics threadPoolMetrics, \n        JsonGenerator json) throws IOException {\n    HystrixThreadPoolKey key = threadPoolMetrics.getThreadPoolKey();\n\n    json.writeStartObject();\n    json.writeStringField(\"type\", \"HystrixThreadPool\");\n    json.writeStringField(\"name\", key.name());\n    json.writeNumberField(\"currentTime\", System.currentTimeMillis());\n\n    json.writeNumberField(\"currentActiveCount\", \n            threadPoolMetrics.getCurrentActiveCount().intValue());\n    json.writeNumberField(\"currentCompletedTaskCount\", \n            threadPoolMetrics.getCurrentCompletedTaskCount().longValue());\n    json.writeNumberField(\"currentCorePoolSize\", \n            threadPoolMetrics.getCurrentCorePoolSize().intValue());\n    json.writeNumberField(\"currentLargestPoolSize\", \n            threadPoolMetrics.getCurrentLargestPoolSize().intValue());\n    json.writeNumberField(\"currentMaximumPoolSize\", \n            threadPoolMetrics.getCurrentMaximumPoolSize().intValue());\n    json.writeNumberField(\"currentPoolSize\", \n            threadPoolMetrics.getCurrentPoolSize().intValue());\n    json.writeNumberField(\"currentQueueSize\", \n            threadPoolMetrics.getCurrentQueueSize().intValue());\n    json.writeNumberField(\"currentTaskCount\", \n            threadPoolMetrics.getCurrentTaskCount().longValue());\n    safelyWriteNumberField(\n            json, \n            \"rollingCountThreadsExecuted\", \n            new Func0<Long>() {\n                @Override\n                public Long call() {\n                    return threadPoolMetrics.getRollingCount(\n                            HystrixEventType.ThreadPool.EXECUTED);\n                }\n            });\n    json.writeNumberField(\"rollingMaxActiveThreads\", \n            threadPoolMetrics.getRollingMaxActiveThreads());\n    safelyWriteNumberField(\n            json, \n            \"rollingCountCommandRejections\", \n            new Func0<Long>() {\n                @Override\n                public Long call() {\n                    return threadPoolMetrics.getRollingCount(\n                            HystrixEventType.ThreadPool.REJECTED);\n                }\n            });\n\n    json.writeNumberField(\"propertyValue_queueSizeRejectionThreshold\", \n            threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());\n    json.writeNumberField(\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", \n            threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());\n\n    json.writeNumberField(\"reportingHosts\", 1);\n    json.writeEndObject();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "128", "src_id": "M69", "code": "\n@Override\npublic String toString() {\n    StringBuffer sb = new StringBuffer();\n    List<HystrixEventType> foundEventTypes = \n            new ArrayList<HystrixEventType>();\n\n    sb.append(getCommandKey().name()).append(\"[\");\n    for (HystrixEventType eventType : ALL_EVENT_TYPES) {\n        if (executionResult.getEventCounts().contains(eventType)) {\n            foundEventTypes.add(eventType);\n        }\n    }\n    int i = 0;\n    for (HystrixEventType eventType : foundEventTypes) {\n        sb.append(eventType.name());\n        int eventCount = executionResult.getEventCounts().getCount(eventType);\n        if (eventCount > 1) {\n            sb.append(\"x\").append(eventCount);\n        }\n        if (i < foundEventTypes.size() - 1) {\n            sb.append(\", \");\n        }\n        i++;\n    }\n    sb.append(\"][\").append(getExecutionLatency()).append(\" ms]\");\n    return sb.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "129", "src_id": "M52", "code": "\n@Override\npublic void run() {\n    while (true) {\n        try {\n            Thread.sleep(5000);\n        } catch (Exception e) {\n        }\n\n        HystrixCommandMetrics creditCardMetrics = HystrixCommandMetrics.getInstance(\n                HystrixCommandKey.Factory.asKey(CreditCardCommand.class.getSimpleName()));\n        HystrixCommandMetrics orderMetrics = HystrixCommandMetrics.getInstance(\n                HystrixCommandKey.Factory.asKey(GetOrderCommand.class.getSimpleName()));\n        HystrixCommandMetrics userAccountMetrics = HystrixCommandMetrics.getInstance(\n                HystrixCommandKey.Factory.asKey(GetUserAccountCommand.class.getSimpleName()));\n        HystrixCommandMetrics paymentInformationMetrics = HystrixCommandMetrics.getInstance(\n                HystrixCommandKey.Factory.asKey(GetPaymentInformationCommand.class.getSimpleName()));\n\n        if (shouldLog) {\n            StringBuilder out = new StringBuilder();\n            out.append(\"\\n\");\n            out.append(\"#####################################################################################\")\n                    .append(\"\\n\");\n            out.append(\"# CreditCardCommand: \")\n                    .append(getStatsStringFromMetrics(creditCardMetrics))\n                    .append(\"\\n\");\n            out.append(\"# GetOrderCommand: \")\n                    .append(getStatsStringFromMetrics(orderMetrics))\n                    .append(\"\\n\");\n            out.append(\"# GetUserAccountCommand: \")\n                    .append(getStatsStringFromMetrics(userAccountMetrics))\n                    .append(\"\\n\");\n            out.append(\"# GetPaymentInformationCommand: \")\n                    .append(getStatsStringFromMetrics(paymentInformationMetrics))\n                    .append(\"\\n\");\n            out.append(\"#####################################################################################\")\n                    .append(\"\\n\");\n            System.out.println(out.toString());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "130", "src_id": "M312", "code": "\nprivate Observable<R> handleRequestCacheHitAndEmitValues(\n        final HystrixCommandResponseFromCache<R> fromCache,\n        final AbstractCommand<R> _cmd) {\n    try {\n        executionHook.onCacheHit(this);\n    } catch (Throwable hookEx) {\n        logger.warn(\"Error calling HystrixCommandExecutionHook.onCacheHit\", hookEx);\n    }\n\n    return fromCache.toObservableWithStateCopiedInto(this)\n            .doOnTerminate(new Action0() {\n                @Override\n                public void call() {\n                    if (commandState.compareAndSet(\n                            CommandState.OBSERVABLE_CHAIN_CREATED, \n                            CommandState.TERMINAL)) {\n                        cleanUpAfterResponseFromCache(false);\n                    } else if (commandState.compareAndSet(\n                            CommandState.USER_CODE_EXECUTED, \n                            CommandState.TERMINAL)) {\n                        cleanUpAfterResponseFromCache(true);\n                    }\n                }\n            })\n            .doOnUnsubscribe(new Action0() {\n                @Override\n                public void call() {\n                    if (commandState.compareAndSet(\n                            CommandState.OBSERVABLE_CHAIN_CREATED, \n                            CommandState.UNSUBSCRIBED)) {\n                        cleanUpAfterResponseFromCache(false);\n                    } else if (commandState.compareAndSet(\n                            CommandState.USER_CODE_EXECUTED, \n                            CommandState.UNSUBSCRIBED)) {\n                        cleanUpAfterResponseFromCache(true);\n                    }\n                }\n            });\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "131", "src_id": "M438", "code": "\nprivate static void serializeUtilization(\n        HystrixUtilization utilization, \n        JsonGenerator json) {\n    try {\n        json.writeStartObject();\n        json.writeStringField(\"type\", \"HystrixUtilization\");\n        json.writeObjectFieldStart(\"commands\");\n        for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : \n                utilization.getCommandUtilizationMap().entrySet()) {\n            final HystrixCommandKey key = entry.getKey();\n            final HystrixCommandUtilization commandUtilization = entry.getValue();\n            writeCommandUtilizationJson(json, key, commandUtilization);\n        }\n        json.writeEndObject();\n\n        json.writeObjectFieldStart(\"threadpools\");\n        for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : \n                utilization.getThreadPoolUtilizationMap().entrySet()) {\n            final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n            final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n            writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n        }\n        json.writeEndObject();\n        json.writeEndObject();\n        json.close();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "132", "src_id": "M342", "code": "\n    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null || emlBytes.length == 0) throw new IllegalArgumentException(\"EML file is empty or null\");\n\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n\n        StringBuilder html = new StringBuilder();\n        html.append(\"<!DOCTYPE html>\\n\");\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n        html.append(\"<style>\\n\");\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n            html.append(attachmentInfo);\n\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n        }\n\n        assert request != null;\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n\n        return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "133", "src_id": "M371", "code": "\n    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) return false;\n\n        try {\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) return false;\n\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "134", "src_id": "M348", "code": "\n    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                            value.append(\" \").append(lines[j].trim());\n                        } else {\n                            break;\n                        }\n                    }\n                    return safeMimeDecode(value.toString());\n                }\n                if (line.trim().isEmpty()) {\n                    break;\n                }\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "135", "src_id": "M364", "code": "\n    private static void addAttachmentAnnotationsToDocument(\n            PDDocument document, List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) return;\n\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n        finder.setSortByPosition(true);\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\",\n                     markerPositions.size(), attachments.size());\n        }\n\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n\n            if (attachment.getEmbeddedFilename() != null) {\n                PDPage page = document.getPage(position.getPageIndex());\n                addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "136", "src_id": "M267", "code": "\n    @Override\n    public void startElement(XlsxReadContext xlsxReadContext, String name, Attributes attributes) {\n        String ref = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_REF);\n        if (StringUtils.isEmpty(ref)) {\n            return;\n        }\n        // Hyperlink has two cases:\n        // Case 1: In 'location' tag\n        String location = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_LOCATION);\n        if (location != null) {\n            CellExtra cellExtra = new CellExtra(CellExtraTypeEnum.HYPERLINK, location, ref);\n            xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n            xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n            return;\n        }\n        // Case 2: In 'r:id' tag\n        String rId = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_RID);\n        PackageRelationshipCollection packageRelationshipCollection =\n                xlsxReadContext.xlsxReadSheetHolder().getPackageRelationshipCollection();\n        if (rId == null || packageRelationshipCollection == null) {\n            return;\n        }\n        Optional.ofNullable(packageRelationshipCollection.getRelationshipByID(rId))\n                .map(PackageRelationship::getTargetURI)\n                .ifPresent(\n                        uri -> {\n                            CellExtra cellExtra =\n                                    new CellExtra(CellExtraTypeEnum.HYPERLINK, uri.toString(), ref);\n                            xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n                            xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n                        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "137", "src_id": "M248", "code": "\n    @Override\n    public void processRecord(XlsReadContext xlsReadContext, Record record) {\n        LabelSSTRecord lsrec = (LabelSSTRecord) record;\n        ReadCache readCache = xlsReadContext.readWorkbookHolder().getReadCache();\n        Map<Integer, Cell> cellMap = xlsReadContext.xlsReadSheetHolder().getCellMap();\n\n        if (readCache == null) {\n            cellMap.put(\n                    (int) lsrec.getColumn(),\n                    ReadCellData.newEmptyInstance(lsrec.getRow(), (int) lsrec.getColumn()));\n            return;\n        }\n\n        String data = readCache.get(lsrec.getSSTIndex());\n        if (data == null) {\n            cellMap.put(\n                    (int) lsrec.getColumn(),\n                    ReadCellData.newEmptyInstance(lsrec.getRow(), (int) lsrec.getColumn()));\n            return;\n        }\n\n        if (xlsReadContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\n            data = data.trim();\n        }\n\n        cellMap.put(\n                (int) lsrec.getColumn(),\n                ReadCellData.newInstance(data, lsrec.getRow(), (int) lsrec.getColumn()));\n        xlsReadContext.xlsReadSheetHolder().setTempRowType(RowTypeEnum.DATA);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "138", "src_id": "M106", "code": "\n    private Row createRowIfNecessary(\n            Sheet sheet,\n            Sheet cachedSheet,\n            Integer lastRowIndex,\n            FillConfig fillConfig,\n            AnalysisCell analysisCell,\n            boolean isOriginalCell,\n            RowWriteHandlerContext rowWriteHandlerContext) {\n\n        rowWriteHandlerContext.setRowIndex(lastRowIndex);\n        Row row = sheet.getRow(lastRowIndex);\n        if (row != null) {\n            checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n            rowWriteHandlerContext.setRow(row);\n            return row;\n        }\n\n        row = cachedSheet.getRow(lastRowIndex);\n        if (row == null) {\n            rowWriteHandlerContext.setRowIndex(lastRowIndex);\n            WriteHandlerUtils.beforeRowCreate(rowWriteHandlerContext);\n\n            if (fillConfig.getForceNewRow()) {\n                row = cachedSheet.createRow(lastRowIndex);\n            } else {\n                // Handle disk-written empty rows\n                try {\n                    row = sheet.createRow(lastRowIndex);\n                } catch (IllegalArgumentException ignore) {\n                    row = cachedSheet.createRow(lastRowIndex);\n                }\n            }\n            rowWriteHandlerContext.setRow(row);\n            checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n            WriteHandlerUtils.afterRowCreate(rowWriteHandlerContext);\n        } else {\n            checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n            rowWriteHandlerContext.setRow(row);\n        }\n        return row;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "139", "src_id": "M12", "code": "\n    private Object buildNoModel(\n            Map<Integer, ReadCellData<?>> cellDataMap,\n            ReadSheetHolder readSheetHolder,\n            AnalysisContext context) {\n\n        int index = 0;\n        Map<Integer, Object> map = MapUtils.newLinkedHashMapWithExpectedSize(cellDataMap.size());\n        for (Map.Entry<Integer, ReadCellData<?>> entry : cellDataMap.entrySet()) {\n            Integer key = entry.getKey();\n            ReadCellData<?> cellData = entry.getValue();\n\n            while (index < key) {\n                map.put(index, null);\n                index++;\n            }\n            index++;\n\n            ReadDefaultReturnEnum readDefaultReturn = context.readWorkbookHolder().getReadDefaultReturn();\n            if (readDefaultReturn == ReadDefaultReturnEnum.STRING) {\n                map.put(\n                        key,\n                        (String) ConverterUtils.convertToJavaObject(\n                                cellData,\n                                null,\n                                null,\n                                readSheetHolder.converterMap(),\n                                context,\n                                context.readRowHolder().getRowIndex(),\n                                key));\n            } else {\n                ReadCellData<?> convertedReadCellData =\n                        convertReadCellData(\n                                cellData,\n                                context.readWorkbookHolder().getReadDefaultReturn(),\n                                readSheetHolder,\n                                context,\n                                key);\n                if (readDefaultReturn == ReadDefaultReturnEnum.READ_CELL_DATA) {\n                    map.put(key, convertedReadCellData);\n                } else {\n                    map.put(key, convertedReadCellData.getData());\n                }\n            }\n        }\n        // Fix trailing cells\n        int headSize = calculateHeadSize(readSheetHolder);\n        while (index < headSize) {\n            map.put(index, null);\n            index++;\n        }\n        return map;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "140", "src_id": "M94", "code": "\n    private void fillComment(CellWriteHandlerContext cellWriteHandlerContext, CommentData commentData) {\n        if (commentData == null) {\n            return;\n        }\n\n        Integer rowIndex = cellWriteHandlerContext.getRowIndex();\n        Integer columnIndex = cellWriteHandlerContext.getColumnIndex();\n        Sheet sheet = cellWriteHandlerContext.getWriteSheetHolder().getSheet();\n        Cell cell = cellWriteHandlerContext.getCell();\n\n        ClientAnchor anchor;\n        if (writeContext.writeWorkbookHolder().getExcelType() == ExcelTypeEnum.XLSX) {\n            anchor = new XSSFClientAnchor(\n                    StyleUtil.getCoordinate(commentData.getLeft()),\n                    StyleUtil.getCoordinate(commentData.getTop()),\n                    StyleUtil.getCoordinate(commentData.getRight()),\n                    StyleUtil.getCoordinate(commentData.getBottom()),\n                    StyleUtil.getCellCoordinate(\n                            columnIndex,\n                            commentData.getFirstColumnIndex(),\n                            commentData.getRelativeFirstColumnIndex()),\n                    StyleUtil.getCellCoordinate(\n                            rowIndex,\n                            commentData.getFirstRowIndex(),\n                            commentData.getRelativeFirstRowIndex()),\n                    StyleUtil.getCellCoordinate(\n                            columnIndex,\n                            commentData.getLastColumnIndex(),\n                            commentData.getRelativeLastColumnIndex()) + 1,\n                    StyleUtil.getCellCoordinate(\n                            rowIndex,\n                            commentData.getLastRowIndex(),\n                            commentData.getRelativeLastRowIndex()) + 1);\n        } else {\n            anchor = new HSSFClientAnchor(\n                    StyleUtil.getCoordinate(commentData.getLeft()),\n                    StyleUtil.getCoordinate(commentData.getTop()),\n                    StyleUtil.getCoordinate(commentData.getRight()),\n                    StyleUtil.getCoordinate(commentData.getBottom()),\n                    (short) StyleUtil.getCellCoordinate(\n                            columnIndex,\n                            commentData.getFirstColumnIndex(),\n                            commentData.getRelativeFirstColumnIndex()),\n                    StyleUtil.getCellCoordinate(\n                            rowIndex,\n                            commentData.getFirstRowIndex(),\n                            commentData.getRelativeFirstRowIndex()),\n                    (short) (StyleUtil.getCellCoordinate(\n                                    columnIndex,\n                                    commentData.getLastColumnIndex(),\n                                    commentData.getRelativeLastColumnIndex())\n                            + 1),\n                    StyleUtil.getCellCoordinate(\n                                    rowIndex,\n                                    commentData.getLastRowIndex(),\n                                    commentData.getRelativeLastRowIndex())\n                            + 1);\n        }\n\n        Comment comment = sheet.createDrawingPatriarch().createCellComment(anchor);\n        if (commentData.getRichTextStringData() != null) {\n            comment.setString(\n                    StyleUtil.buildRichTextString(\n                            writeContext.writeWorkbookHolder(), commentData.getRichTextStringData()));\n        }\n        if (commentData.getAuthor() != null) {\n            comment.setAuthor(commentData.getAuthor());\n        }\n        cell.setCellComment(comment);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "141", "src_id": "M212", "code": "\n    private Format getFormat(Double data, Short dataFormat, String dataFormatString) {\n        String formatStr = dataFormatString;\n\n        // Handle conditional formats\n        if (formatStr.contains(\";\") &&\n                (formatStr.indexOf(';') != formatStr.lastIndexOf(';')\n                        || rangeConditionalPattern.matcher(formatStr).matches())) {\n            try {\n                CellFormat cfmt = CellFormat.getInstance(locale, formatStr);\n                Object cellValueO = data;\n                if (DateUtils.isADateFormat(dataFormat, formatStr) &&\n                        data.doubleValue() != 0.0) {\n                    cellValueO = DateUtils.getJavaDate(data, use1904windowing);\n                }\n                return new CellFormatResultWrapper(cfmt.apply(cellValueO));\n            } catch (Exception e) {\n                LOGGER.warn(\"Formatting failed for format {}, falling back\", formatStr, e);\n            }\n        }\n\n        // Check cache\n        Format format = formats.get(formatStr);\n        if (format != null) {\n            return format;\n        }\n\n        // Handle built-in types\n        if (\"General\".equalsIgnoreCase(formatStr) || \"@\".equals(formatStr)) {\n            format = getDefaultFormat();\n            addFormat(formatStr, format);\n            return format;\n        }\n\n        // Create new format\n        format = createFormat(dataFormat, formatStr);\n        addFormat(formatStr, format);\n        return format;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "142", "src_id": "M35", "code": "\n    private static void buildStyleProperty(StyleProperty styleProperty, WriteCellStyle writeCellStyle) {\n        if (styleProperty == null) {\n            return;\n        }\n\n        // Apply style properties conditionally\n        if (styleProperty.getDataFormatData() != null) {\n            if (writeCellStyle.getDataFormatData() == null) {\n                writeCellStyle.setDataFormatData(styleProperty.getDataFormatData());\n            } else {\n                DataFormatData.merge(styleProperty.getDataFormatData(), writeCellStyle.getDataFormatData());\n            }\n        }\n        if (styleProperty.getHidden() != null) {\n            writeCellStyle.setHidden(styleProperty.getHidden());\n        }\n        if (styleProperty.getLocked() != null) {\n            writeCellStyle.setLocked(styleProperty.getLocked());\n        }\n        if (styleProperty.getQuotePrefix() != null) {\n            writeCellStyle.setQuotePrefix(styleProperty.getQuotePrefix());\n        }\n        if (styleProperty.getHorizontalAlignment() != null) {\n            writeCellStyle.setHorizontalAlignment(styleProperty.getHorizontalAlignment());\n        }\n        if (styleProperty.getWrapped() != null) {\n            writeCellStyle.setWrapped(styleProperty.getWrapped());\n        }\n        if (styleProperty.getVerticalAlignment() != null) {\n            writeCellStyle.setVerticalAlignment(styleProperty.getVerticalAlignment());\n        }\n        if (styleProperty.getRotation() != null) {\n            writeCellStyle.setRotation(styleProperty.getRotation());\n        }\n        if (styleProperty.getIndent() != null) {\n            writeCellStyle.setIndent(styleProperty.getIndent());\n        }\n        if (styleProperty.getBorderLeft() != null) {\n            writeCellStyle.setBorderLeft(styleProperty.getBorderLeft());\n        }\n        if (styleProperty.getBorderRight() != null) {\n            writeCellStyle.setBorderRight(styleProperty.getBorderRight());\n        }\n        if (styleProperty.getBorderTop() != null) {\n            writeCellStyle.setBorderTop(styleProperty.getBorderTop());\n        }\n        if (styleProperty.getBorderBottom() != null) {\n            writeCellStyle.setBorderBottom(styleProperty.getBorderBottom());\n        }\n        if (styleProperty.getLeftBorderColor() != null) {\n            writeCellStyle.setLeftBorderColor(styleProperty.getLeftBorderColor());\n        }\n        if (styleProperty.getRightBorderColor() != null) {\n            writeCellStyle.setRightBorderColor(styleProperty.getRightBorderColor());\n        }\n        if (styleProperty.getTopBorderColor() != null) {\n            writeCellStyle.setTopBorderColor(styleProperty.getTopBorderColor());\n        }\n        if (styleProperty.getBottomBorderColor() != null) {\n            writeCellStyle.setBottomBorderColor(styleProperty.getBottomBorderColor());\n        }\n        if (styleProperty.getFillPatternType() != null) {\n            writeCellStyle.setFillPatternType(styleProperty.getFillPatternType());\n        }\n        if (styleProperty.getFillBackgroundColor() != null) {\n            writeCellStyle.setFillBackgroundColor(styleProperty.getFillBackgroundColor());\n        }\n        if (styleProperty.getFillForegroundColor() != null) {\n            writeCellStyle.setFillForegroundColor(styleProperty.getFillForegroundColor());\n        }\n        if (styleProperty.getShrinkToFit() != null) {\n            writeCellStyle.setShrinkToFit(styleProperty.getShrinkToFit());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "143", "src_id": "M90", "code": "\n    private void addJavaObjectToExcel(\n            Object oneRowData,\n            Row row,\n            int rowIndex,\n            int relativeRowIndex) {\n\n        WriteHolder currentWriteHolder = writeContext.currentWriteHolder();\n        BeanMap beanMap = BeanMapUtils.create(oneRowData);\n        Set<String> beanKeySet = new HashSet<>(beanMap.keySet());\n        Set<String> beanMapHandledSet = new HashSet<>();\n        int maxCellIndex = -1;\n\n        // Class-based handling\n        if (HeadKindEnum.CLASS.equals(currentWriteHolder.excelWriteHeadProperty().getHeadKind())) {\n            Map<Integer, Head> headMap = currentWriteHolder.excelWriteHeadProperty().getHeadMap();\n            for (Map.Entry<Integer, Head> entry : headMap.entrySet()) {\n                int columnIndex = entry.getKey();\n                Head head = entry.getValue();\n                String name = head.getFieldName();\n                if (!beanKeySet.contains(name)) {\n                    continue;\n                }\n\n                ExcelContentProperty excelContentProperty =\n                        ClassUtils.declaredExcelContentProperty(\n                                beanMap,\n                                currentWriteHolder.excelWriteHeadProperty().getHeadClazz(),\n                                name,\n                                currentWriteHolder);\n                CellWriteHandlerContext cellWriteHandlerContext =\n                        WriteHandlerUtils.createCellWriteHandlerContext(\n                                writeContext,\n                                row,\n                                rowIndex,\n                                head,\n                                columnIndex,\n                                relativeRowIndex,\n                                Boolean.FALSE,\n                                excelContentProperty);\n                WriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n\n                Cell cell = WorkBookUtil.createCell(row, columnIndex);\n                cellWriteHandlerContext.setCell(cell);\n                WriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n\n                cellWriteHandlerContext.setOriginalValue(beanMap.get(name));\n                cellWriteHandlerContext.setOriginalFieldClass(head.getField().getType());\n                converterAndSet(cellWriteHandlerContext);\n                WriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n\n                beanMapHandledSet.add(name);\n                maxCellIndex = Math.max(maxCellIndex, columnIndex);\n            }\n        }\n\n        // Handle remaining fields\n        if (beanMapHandledSet.size() == beanMap.size()) {\n            return;\n        }\n        maxCellIndex++;\n\n        FieldCache fieldCache = ClassUtils.declaredFields(\n                oneRowData.getClass(),\n                writeContext.currentWriteHolder());\n        for (Map.Entry<Integer, FieldWrapper> entry : fieldCache.getSortedFieldMap().entrySet()) {\n            FieldWrapper field = entry.getValue();\n            String fieldName = field.getFieldName();\n            if (!beanKeySet.contains(fieldName) || beanMapHandledSet.contains(fieldName)) {\n                continue;\n            }\n\n            Object value = beanMap.get(fieldName);\n            ExcelContentProperty excelContentProperty =\n                    ClassUtils.declaredExcelContentProperty(\n                            beanMap,\n                            currentWriteHolder.excelWriteHeadProperty().getHeadClazz(),\n                            fieldName,\n                            currentWriteHolder);\n            CellWriteHandlerContext cellWriteHandlerContext =\n                    WriteHandlerUtils.createCellWriteHandlerContext(\n                            writeContext,\n                            row,\n                            rowIndex,\n                            null,\n                            maxCellIndex,\n                            relativeRowIndex,\n                            Boolean.FALSE,\n                            excelContentProperty);\n            WriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n\n            Cell cell = WorkBookUtil.createCell(row, maxCellIndex);\n            cellWriteHandlerContext.setCell(cell);\n            WriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n\n            cellWriteHandlerContext.setOriginalValue(value);\n            cellWriteHandlerContext.setOriginalFieldClass(\n                    FieldUtils.getFieldClass(beanMap, fieldName, value));\n            converterAndSet(cellWriteHandlerContext);\n            WriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n\n            maxCellIndex++;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "144", "src_id": "M50", "code": "\n    public CellStyle createCellStyle(WriteCellStyle writeCellStyle, CellStyle originCellStyle) {\n        if (writeCellStyle == null) {\n            return originCellStyle;\n        }\n\n        short styleIndex = -1;\n        Font originFont = null;\n        boolean useCache = true;\n        if (originCellStyle != null) {\n            styleIndex = originCellStyle.getIndex();\n            if (originCellStyle instanceof XSSFCellStyle) {\n                originFont = ((XSSFCellStyle) originCellStyle).getFont();\n            } else if (originCellStyle instanceof HSSFCellStyle) {\n                originFont = ((HSSFCellStyle) originCellStyle).getFont(workbook);\n            }\n            useCache = false;\n        }\n\n        Map<WriteCellStyle, CellStyle> cellStyleMap =\n                cellStyleIndexMap.computeIfAbsent(styleIndex, key -> MapUtils.newHashMap());\n        CellStyle cellStyle = cellStyleMap.get(writeCellStyle);\n        if (cellStyle != null) {\n            return cellStyle;\n        }\n\n        WriteCellStyle tempWriteCellStyle = new WriteCellStyle();\n        WriteCellStyle.merge(writeCellStyle, tempWriteCellStyle);\n\n        cellStyle = StyleUtil.buildCellStyle(workbook, originCellStyle, tempWriteCellStyle);\n        Short dataFormat = createDataFormat(tempWriteCellStyle.getDataFormatData(), useCache);\n        if (dataFormat != null) {\n            cellStyle.setDataFormat(dataFormat);\n        }\n\n        Font font = createFont(tempWriteCellStyle.getWriteFont(), originFont, useCache);\n        if (font != null) {\n            cellStyle.setFont(font);\n        }\n\n        cellStyleMap.put(tempWriteCellStyle, cellStyle);\n        return cellStyle;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "145", "src_id": "M21", "code": "\n    private void buildHead(\n            AnalysisContext analysisContext,\n            Map<Integer, ReadCellData<?>> cellDataMap) {\n\n        // Find max non-empty column\n        if (MapUtils.isNotEmpty(cellDataMap)) {\n            cellDataMap.entrySet()\n                    .stream()\n                    .filter(entry -> CellDataTypeEnum.EMPTY != entry.getValue().getType())\n                    .forEach(entry -> analysisContext.readSheetHolder()\n                            .setMaxNotEmptyDataHeadSize(entry.getKey()));\n        }\n\n        if (!HeadKindEnum.CLASS.equals(\n                analysisContext.currentReadHolder().excelReadHeadProperty().getHeadKind())) {\n            return;\n        }\n\n        Map<Integer, String> dataMap = ConverterUtils.convertToStringMap(cellDataMap, analysisContext);\n        ExcelReadHeadProperty excelHeadPropertyData = analysisContext.readSheetHolder().excelReadHeadProperty();\n        Map<Integer, Head> headMapData = excelHeadPropertyData.getHeadMap();\n        Map<Integer, Head> tmpHeadMap = new HashMap<Integer, Head>(headMapData.size() * 4 / 3 + 1);\n\n        for (Map.Entry<Integer, Head> entry : headMapData.entrySet()) {\n            Head headData = entry.getValue();\n            if (headData.getForceIndex() || !headData.getForceName()) {\n                tmpHeadMap.put(entry.getKey(), headData);\n                continue;\n            }\n\n            List<String> headNameList = headData.getHeadNameList();\n            String headName = headNameList.get(headNameList.size() - 1);\n            for (Map.Entry<Integer, String> stringEntry : dataMap.entrySet()) {\n                if (stringEntry == null) {\n                    continue;\n                }\n\n                String headString = stringEntry.getValue();\n                Integer stringKey = stringEntry.getKey();\n                if (StringUtils.isEmpty(headString)) {\n                    continue;\n                }\n\n                if (analysisContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\n                    headString = headString.trim();\n                }\n\n                if (headName.equals(headString)) {\n                    headData.setColumnIndex(stringKey);\n                    tmpHeadMap.put(stringKey, headData);\n                    break;\n                }\n            }\n        }\n        excelHeadPropertyData.setHeadMap(tmpHeadMap);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "146", "src_id": "M31", "code": "\nprivate JsonNode validateLicense(\n    String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n  final String requestBody = String.format(\n      \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\",\n      licenseKey, machineFingerprint);\n  \n  final HttpRequest request = HttpRequest.newBuilder()\n      .uri(URI.create(\n          BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n      .header(\"Content-Type\", \"application/vnd.api+json\")\n      .header(\"Accept\", \"application/vnd.api+json\")\n      .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n      .build();\n\n  final HttpResponse<String> response = httpClient.send(\n      request, HttpResponse.BodyHandlers.ofString());\n  log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n  \n  final JsonNode jsonResponse = objectMapper.readTree(response.body());\n  if (response.statusCode() == 200) {\n    final JsonNode metaNode = jsonResponse.path(\"meta\");\n    final boolean isValid = metaNode.path(\"valid\").asBoolean();\n    final String detail = metaNode.path(\"detail\").asText();\n    final String code = metaNode.path(\"code\").asText();\n\n    log.info(\"License validity: {}\", isValid);\n    log.info(\"Validation detail: {}\", detail);\n    log.info(\"Validation code: {}\", code);\n\n    final JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n    if (!licenseAttrs.isMissingNode()) {\n      context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n      context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n      log.info(\n          \"License floating (from license): {}, maxMachines: {}\",\n          context.isFloatingLicense,\n          context.maxMachines);\n    }\n\n    JsonNode policyNode = null;\n    final JsonNode includedNode = jsonResponse.path(\"included\");\n    if (includedNode.isArray()) {\n      for (final JsonNode node : includedNode) {\n        if (\"policies\".equals(node.path(\"type\").asText())) {\n          policyNode = node;\n          break;\n        }\n      }\n    }\n\n    if (policyNode != null) {\n      final boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n      final int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n      \n      if (policyFloating) {\n        context.isFloatingLicense = true;\n        context.maxMachines = policyMaxMachines;\n      }\n      log.info(\n          \"License floating (from policy): {}, maxMachines: {}\",\n          context.isFloatingLicense,\n          context.maxMachines);\n    }\n\n    final int users = jsonResponse\n        .path(\"data\")\n        .path(\"attributes\")\n        .path(\"metadata\")\n        .path(\"users\")\n        .asInt(1);\n    applicationProperties.getPremium().setMaxUsers(users);\n\n    context.isEnterpriseLicense = jsonResponse\n        .path(\"data\")\n        .path(\"attributes\")\n        .path(\"metadata\")\n        .path(\"isEnterprise\")\n        .asBoolean(false);\n\n    log.debug(applicationProperties.toString());\n  } else {\n    log.error(\"Error validating license. Status code: {}\", response.statusCode());\n  }\n  return jsonResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "147", "src_id": "M488", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n@Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description = \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY Output:PDF Type:SISO\")\npublic ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n    throws Exception {\n  final MultipartFile inputFile = generalFile.getFileInput();\n  File file = null;\n  try {\n    file = convertToPdf(inputFile);\n    final PDDocument doc = pdfDocumentFactory.load(file);\n    return WebResponseUtils.pdfDocToWebResponse(\n        doc,\n        Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                .replaceFirst(\"[.][^.]+$\", \"\")\n            + \"_convertedToPDF.pdf\");\n  } finally {\n    if (file != null) file.delete();\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "148", "src_id": "M625", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\npublic ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n  final MultipartFile inputFile = request.getFileInput();\n  final boolean readonly = true;\n  try (final PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n    final ObjectMapper objectMapper = new ObjectMapper();\n    final ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n    final PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n    final ObjectNode metadata = objectMapper.createObjectNode();\n    final ObjectNode basicInfo = objectMapper.createObjectNode();\n    final ObjectNode docInfoNode = objectMapper.createObjectNode();\n    final ObjectNode compliancy = objectMapper.createObjectNode();\n    final ObjectNode encryption = objectMapper.createObjectNode();\n    final ObjectNode other = objectMapper.createObjectNode();\n\n    metadata.put(\"Title\", info.getTitle());\n    metadata.put(\"Author\", info.getAuthor());\n    metadata.put(\"Subject\", info.getSubject());\n    metadata.put(\"Keywords\", info.getKeywords());\n    metadata.put(\"Producer\", info.getProducer());\n    metadata.put(\"Creator\", info.getCreator());\n    metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n    metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n    jsonOutput.set(\"Metadata\", metadata);\n\n    final long fileSizeInBytes = inputFile.getSize();\n    basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n    final String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n    final String[] words = fullText.split(\"\\\\s+\");\n    final int wordCount = words.length;\n    final int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n    basicInfo.put(\"WordCount\", wordCount);\n    basicInfo.put(\"ParagraphCount\", paragraphCount);\n    basicInfo.put(\"CharacterCount\", fullText.length());\n\n    boolean hasCompression = false;\n    String compressionType = \"None\";\n    basicInfo.put(\"Compression\", hasCompression);\n    if (hasCompression) basicInfo.put(\"CompressionType\", compressionType);\n\n    final String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n    basicInfo.put(\"Language\", language);\n    basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n    final PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n    final String pageMode = catalog.getPageMode().name();\n    docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n    docInfoNode.put(\"Trapped\", info.getTrapped());\n    docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n    final PDAcroForm acroForm = catalog.getAcroForm();\n    final ObjectNode formFieldsNode = objectMapper.createObjectNode();\n    if (acroForm != null) {\n      for (final PDField field : acroForm.getFieldTree()) {\n        formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n      }\n    }\n    jsonOutput.set(\"FormFields\", formFieldsNode);\n\n    final ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n    if (summaryData != null && summaryData.size() > 0) {\n      jsonOutput.set(\"SummaryData\", summaryData);\n    }\n\n    if (catalog.getNames() != null) {\n      final PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n      final ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n      if (efTree != null) {\n        final Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n        if (efMap != null) {\n          for (final Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n            final ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n            embeddedFileNode.put(\"Name\", entry.getKey());\n            final PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n            if (embeddedFile != null) {\n              embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n            }\n            embeddedFilesArray.add(embeddedFileNode);\n          }\n        }\n      }\n      other.set(\"EmbeddedFiles\", embeddedFilesArray);\n    }\n\n    final ArrayNode attachmentsArray = objectMapper.createArrayNode();\n    for (final PDPage page : pdfBoxDoc.getPages()) {\n      for (final PDAnnotation annotation : page.getAnnotations()) {\n        if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n          final ObjectNode attachmentNode = objectMapper.createObjectNode();\n          attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n          attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n          attachmentsArray.add(attachmentNode);\n        }\n      }\n    }\n    other.set(\"Attachments\", attachmentsArray);\n\n    final PDDocumentNameDictionary namesDict = catalog.getNames();\n    final ArrayNode javascriptArray = objectMapper.createArrayNode();\n    if (namesDict != null) {\n      final PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n      if (javascriptDict != null) {\n        try {\n          final Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n          for (final Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n            final ObjectNode jsNode = objectMapper.createObjectNode();\n            jsNode.put(\"JS Name\", entry.getKey());\n            final PDActionJavaScript jsAction = entry.getValue();\n            if (jsAction != null) {\n              final String jsCodeStr = jsAction.getAction();\n              if (jsCodeStr != null) {\n                jsNode.put(\"JS Script Length\", jsCodeStr.length());\n              }\n            }\n            javascriptArray.add(jsNode);\n          }\n        } catch (IOException e) {\n          log.error(\"exception\", e);\n        }\n      }\n    }\n    other.set(\"JavaScript\", javascriptArray);\n\n    final PDOptionalContentProperties ocProperties = catalog.getOCProperties();\n    final ArrayNode layersArray = objectMapper.createArrayNode();\n    if (ocProperties != null) {\n      for (final PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n        final ObjectNode layerNode = objectMapper.createObjectNode();\n        layerNode.put(\"Name\", ocg.getName());\n        layersArray.add(layerNode);\n      }\n    }\n    other.set(\"Layers\", layersArray);\n\n    final PDStructureTreeRoot structureTreeRoot = catalog.getStructureTreeRoot();\n    if (structureTreeRoot != null) {\n      try {\n        final ArrayNode structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n        other.set(\"StructureTree\", structureTreeArray);\n      } catch (Exception e) {\n        log.error(\"exception\", e);\n      }\n    }\n\n    compliancy.put(\"IsPDF/ACompliant\", checkForStandard(pdfBoxDoc, \"PDF/A\"));\n    compliancy.put(\"IsPDF/XCompliant\", checkForStandard(pdfBoxDoc, \"PDF/X\"));\n    compliancy.put(\"IsPDF/ECompliant\", checkForStandard(pdfBoxDoc, \"PDF/E\"));\n    compliancy.put(\"IsPDF/VTCompliant\", checkForStandard(pdfBoxDoc, \"PDF/VT\"));\n    compliancy.put(\"IsPDF/UACompliant\", checkForStandard(pdfBoxDoc, \"PDF/UA\"));\n    compliancy.put(\"IsPDF/BCompliant\", checkForStandard(pdfBoxDoc, \"PDF/B\"));\n    compliancy.put(\"IsPDF/SECCompliant\", checkForStandard(pdfBoxDoc, \"PDF/SEC\"));\n\n    final PDOutlineNode root = catalog.getDocumentOutline();\n    final ArrayNode bookmarksArray = objectMapper.createArrayNode();\n    if (root != null) {\n      for (final PDOutlineItem child : root.children()) {\n        addOutlinesToArray(child, bookmarksArray);\n      }\n    }\n    other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n    final PDMetadata pdMetadata = catalog.getMetadata();\n    String xmpString = null;\n    if (pdMetadata != null) {\n      try (final COSInputStream is = pdMetadata.createInputStream()) {\n        final DomXmpParser domXmpParser = new DomXmpParser();\n        final XMPMetadata xmpMeta = domXmpParser.parse(is);\n        final ByteArrayOutputStream os = new ByteArrayOutputStream();\n        new XmpSerializer().serialize(xmpMeta, os, true);\n        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n      } catch (XmpParsingException e) {\n        log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n        try (final COSInputStream is = pdMetadata.createInputStream()) {\n          xmpString = new String(is.readAllBytes(), StandardCharsets.UTF_8);\n        }\n      } catch (IOException e) {\n        log.error(\"exception\", e);\n      }\n    }\n    other.put(\"XMPMetadata\", xmpString);\n\n    encryption.put(\"IsEncrypted\", pdfBoxDoc.isEncrypted());\n    if (pdfBoxDoc.isEncrypted()) {\n      final PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n      encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n      encryption.put(\"KeyLength\", pdfEncryption.getLength());\n    }\n\n    final ObjectNode permissionsNode = objectMapper.createObjectNode();\n    setNodePermissions(pdfBoxDoc, permissionsNode);\n\n    final ObjectNode pageInfoParent = objectMapper.createObjectNode();\n    for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n      final ObjectNode pageInfo = objectMapper.createObjectNode();\n      final PDPage page = pdfBoxDoc.getPage(pageNum);\n      final PDRectangle mediaBox = page.getMediaBox();\n      final float width = mediaBox.getWidth();\n      final float height = mediaBox.getHeight();\n      final ObjectNode sizeInfo = objectMapper.createObjectNode();\n\n      getDimensionInfo(sizeInfo, width, height);\n      sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n      pageInfo.set(\"Size\", sizeInfo);\n\n      pageInfo.put(\"Rotation\", page.getRotation());\n      pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n      pageInfo.put(\"MediaBox\", mediaBox.toString());\n      pageInfo.put(\"CropBox\", getBoxString(page.getCropBox()));\n      pageInfo.put(\"BleedBox\", getBoxString(page.getBleedBox()));\n      pageInfo.put(\"TrimBox\", getBoxString(page.getTrimBox()));\n      pageInfo.put(\"ArtBox\", getBoxString(page.getArtBox()));\n\n      final PDFTextStripper textStripper = new PDFTextStripper();\n      textStripper.setStartPage(pageNum + 1);\n      textStripper.setEndPage(pageNum + 1);\n      final String pageText = textStripper.getText(pdfBoxDoc);\n      pageInfo.put(\"Text Characters Count\", pageText.length());\n\n      final List<PDAnnotation> annotations = page.getAnnotations();\n      int subtypeCount = 0;\n      int contentsCount = 0;\n      for (final PDAnnotation annotation : annotations) {\n        if (annotation.getSubtype() != null) subtypeCount++;\n        if (annotation.getContents() != null) contentsCount++;\n      }\n      final ObjectNode annotationsObject = objectMapper.createObjectNode();\n      annotationsObject.put(\"AnnotationsCount\", annotations.size());\n      annotationsObject.put(\"SubtypeCount\", subtypeCount);\n      annotationsObject.put(\"ContentsCount\", contentsCount);\n      pageInfo.set(\"Annotations\", annotationsObject);\n\n      final ArrayNode imagesArray = objectMapper.createArrayNode();\n      final PDResources resources = page.getResources();\n      for (final COSName name : resources.getXObjectNames()) {\n        final PDXObject xObject = resources.getXObject(name);\n        if (xObject instanceof PDImageXObject image) {\n          final ObjectNode imageNode = objectMapper.createObjectNode();\n          imageNode.put(\"Width\", image.getWidth());\n          imageNode.put(\"Height\", image.getHeight());\n          if (image.getMetadata() != null\n              && image.getMetadata().getFile() != null\n              && image.getMetadata().getFile().getFile() != null) {\n            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n          }\n          if (image.getColorSpace() != null) {\n            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n          }\n          imagesArray.add(imageNode);\n        }\n      }\n      pageInfo.set(\"Images\", imagesArray);\n\n      final ArrayNode linksArray = objectMapper.createArrayNode();\n      final Set<String> uniqueURIs = new HashSet<>();\n      for (final PDAnnotation annotation : annotations) {\n        if (annotation instanceof PDAnnotationLink linkAnnotation) {\n          if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n            uniqueURIs.add(uriAction.getURI());\n          }\n        }\n      }\n      for (final String uri : uniqueURIs) {\n        final ObjectNode linkNode = objectMapper.createObjectNode();\n        linkNode.put(\"URI\", uri);\n        linksArray.add(linkNode);\n      }\n      pageInfo.set(\"Links\", linksArray);\n\n      final ArrayNode fontsArray = objectMapper.createArrayNode();\n      final Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n      for (final COSName fontName : resources.getFontNames()) {\n        final PDFont font = resources.getFont(fontName);\n        final ObjectNode fontNode = objectMapper.createObjectNode();\n        fontNode.put(\"IsEmbedded\", font.isEmbedded());\n        fontNode.put(\"Name\", font.getName());\n        fontNode.put(\"Subtype\", font.getType());\n\n        final PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n        if (fontDescriptor != null) {\n          fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n          final int flags = fontDescriptor.getFlags();\n          fontNode.put(\"IsItalic\", (flags & 1) != 0);\n          fontNode.put(\"IsBold\", (flags & 64) != 0);\n          fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n          fontNode.put(\"IsSerif\", (flags & 4) != 0);\n          fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n          fontNode.put(\"IsScript\", (flags & 16) != 0);\n          fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n          fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n          fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n        }\n\n        final String uniqueKey = fontNode.toString();\n        if (uniqueFontsMap.containsKey(uniqueKey)) {\n          final ObjectNode existing = uniqueFontsMap.get(uniqueKey);\n          existing.put(\"Count\", existing.get(\"Count\").asInt() + 1);\n        } else {\n          fontNode.put(\"Count\", 1);\n          uniqueFontsMap.put(uniqueKey, fontNode);\n        }\n      }\n      for (final ObjectNode fontNode : uniqueFontsMap.values()) {\n        fontsArray.add(fontNode);\n      }\n      pageInfo.set(\"Fonts\", fontsArray);\n\n      final ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n      for (final COSName name : resources.getColorSpaceNames()) {\n        final PDColorSpace colorSpace = resources.getColorSpace(name);\n        if (colorSpace instanceof PDICCBased iccBased) {\n          final byte[] iccBytes = iccBased.getPDStream().toByteArray();\n          final ObjectNode iccProfileNode = objectMapper.createObjectNode();\n          iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n          colorSpacesArray.add(iccProfileNode);\n        }\n      }\n      pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n      final Map<String, Integer> xObjectCountMap = new HashMap<>();\n      for (final COSName name : resources.getXObjectNames()) {\n        final PDXObject xObject = resources.getXObject(name);\n        final String type = (xObject instanceof PDImageXObject) ? \"Image\"\n            : (xObject instanceof PDFormXObject) ? \"Form\" : \"Other\";\n        xObjectCountMap.put(type, xObjectCountMap.getOrDefault(type, 0) + 1);\n      }\n      final ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n      for (final Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n        xObjectCountNode.put(entry.getKey(), entry.getValue());\n      }\n      pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n      final ArrayNode multimediaArray = objectMapper.createArrayNode();\n      for (final PDAnnotation annotation : annotations) {\n        if (\"RichMedia\".equals(annotation.getSubtype())) {\n          multimediaArray.add(objectMapper.createObjectNode());\n        }\n      }\n      pageInfo.set(\"Multimedia\", multimediaArray);\n\n      pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n    }\n\n    jsonOutput.set(\"BasicInfo\", basicInfo);\n    jsonOutput.set(\"DocumentInfo\", docInfoNode);\n    jsonOutput.set(\"Compliancy\", compliancy);\n    jsonOutput.set(\"Encryption\", encryption);\n    jsonOutput.set(\"Permissions\", permissionsNode);\n    jsonOutput.set(\"Other\", other);\n    jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n    final String jsonString = objectMapper.writerWithDefaultPrettyPrinter()\n        .writeValueAsString(jsonOutput);\n    return WebResponseUtils.bytesToWebResponse(\n        jsonString.getBytes(StandardCharsets.UTF_8),\n        \"response.json\",\n        MediaType.APPLICATION_JSON);\n  } catch (Exception e) {\n    log.error(\"exception\", e);\n  }\n  return null;\n}\n\nprivate String getBoxString(PDRectangle box) {\n  return box == null ? \"Undefined\" : box.toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "149", "src_id": "M24", "code": "\nprivate boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n  try {\n    String encodedPayload = licenseFile\n        .replace(CERT_PREFIX, \"\")\n        .replace(CERT_SUFFIX, \"\")\n        .replaceAll(\"\\\\r?\\\\n\", \"\");\n\n    final byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n    final String payload = new String(payloadBytes);\n    log.info(\"Decoded certificate payload: {}\", payload);\n\n    String encryptedData = \"\";\n    String encodedSignature = \"\";\n    String algorithm = \"\";\n\n    try {\n      final JSONObject attrs = new JSONObject(payload);\n      encryptedData = (String) attrs.get(\"enc\");\n      encodedSignature = (String) attrs.get(\"sig\");\n      algorithm = (String) attrs.get(\"alg\");\n    } catch (JSONException e) {\n      log.error(\"Failed to parse license file: {}\", e.getMessage());\n      return false;\n    }\n\n    if (!\"base64+ed25519\".equals(algorithm)) {\n      log.error(\"Unsupported algorithm: {}\", algorithm);\n      return false;\n    }\n\n    final boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n    if (!isSignatureValid) {\n      log.error(\"License file signature is invalid\");\n      return false;\n    }\n    log.info(\"License file signature is valid\");\n\n    final String decodedData = new String(Base64.getDecoder().decode(encryptedData));\n    return processCertificateData(decodedData, context);\n  } catch (Exception e) {\n    log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n    return false;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "150", "src_id": "M403", "code": "\nprivate static void sanitizeHtmlFilesInZip(\n    Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n    throws IOException {\n  try (final TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager);\n       final ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n           new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n    \n    ZipEntry entry = zipIn.getNextEntry();\n    while (entry != null) {\n      final Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n      if (!entry.isDirectory()) {\n        Files.createDirectories(filePath.getParent());\n        final String nameLower = entry.getName().toLowerCase();\n        if (nameLower.endsWith(\".html\") || nameLower.endsWith(\".htm\")) {\n          final String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n          Files.write(filePath, sanitizeHtmlContent(content, disableSanitize).getBytes(StandardCharsets.UTF_8));\n        } else {\n          Files.copy(zipIn, filePath);\n        }\n      }\n      zipIn.closeEntry();\n      entry = zipIn.getNextEntry();\n    }\n    zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "151", "src_id": "M317", "code": "\npublic static void addImageToDocument(\n    PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n    throws IOException {\n  boolean imageIsLandscape = image.getWidth() > image.getHeight();\n  PDRectangle pageSize = PDRectangle.A4;\n\n  if (autoRotate && imageIsLandscape) {\n    pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n  }\n\n  if (\"fitDocumentToImage\".equals(fitOption)) {\n    pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n  }\n\n  final PDPage page = new PDPage(pageSize);\n  doc.addPage(page);\n\n  final float pageWidth = page.getMediaBox().getWidth();\n  final float pageHeight = page.getMediaBox().getHeight();\n\n  try (final PDPageContentStream contentStream = new PDPageContentStream(\n      doc, page, AppendMode.APPEND, true, true)) {\n    \n    if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n      contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n    } else if (\"maintainAspectRatio\".equals(fitOption)) {\n      final float imageAspectRatio = (float) image.getWidth() / image.getHeight();\n      final float pageAspectRatio = pageWidth / pageHeight;\n      float scaleFactor = (imageAspectRatio > pageAspectRatio)\n          ? pageWidth / image.getWidth()\n          : pageHeight / image.getHeight();\n\n      final float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n      final float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n      contentStream.drawImage(\n          image, \n          xPos, \n          yPos, \n          image.getWidth() * scaleFactor, \n          image.getHeight() * scaleFactor);\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "152", "src_id": "M307", "code": "\npublic static String generateMachineFingerprint() {\n  try {\n    final StringBuilder sb = new StringBuilder();\n    final InetAddress ip = InetAddress.getLocalHost();\n    NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n    if (network == null) {\n      final Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n      while (networks.hasMoreElements()) {\n        final NetworkInterface net = networks.nextElement();\n        final byte[] mac = net.getHardwareAddress();\n        if (mac != null) {\n          for (final byte b : mac) {\n            sb.append(String.format(\"%02X\", b));\n          }\n          break;\n        }\n      }\n    } else {\n      final byte[] mac = network.getHardwareAddress();\n      if (mac != null) {\n        for (final byte b : mac) {\n          sb.append(String.format(\"%02X\", b));\n        }\n      }\n    }\n\n    final MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    final byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n    final StringBuilder fingerprint = new StringBuilder();\n    for (final byte b : hash) {\n      fingerprint.append(String.format(\"%02x\", b));\n    }\n    return fingerprint.toString();\n  } catch (Exception e) {\n    return \"GenericID\";\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "153", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n  final String title = pdfMetadata.getTitle();\n  pdf.getDocumentInformation().setTitle(title);\n  pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n  pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n  pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n  pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n  String author = pdfMetadata.getAuthor();\n  if (applicationProperties\n          .getPremium()\n          .getProFeatures()\n          .getCustomMetadata()\n          .isAutoUpdateMetadata()\n      && runningProOrHigher) {\n    \n    author = applicationProperties\n        .getPremium()\n        .getProFeatures()\n        .getCustomMetadata()\n        .getAuthor()\n        .replace(\"username\", \n            userService != null ? userService.getCurrentUsername() : \"\");\n  }\n  pdf.getDocumentInformation().setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "154", "src_id": "M128", "code": "\n@Bean(name = \"machineType\")\npublic String determineMachineType() {\n  try {\n    final boolean isDocker = runningInDocker();\n    final boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n    final boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n    if (isKubernetes) {\n      return \"Kubernetes\";\n    } else if (isDocker) {\n      return \"Docker\";\n    } else if (isBrowserOpen) {\n      final String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n      if (os.contains(\"win\")) {\n        return \"Client-windows\";\n      } else if (os.contains(\"mac\")) {\n        return \"Client-mac\";\n      } else {\n        return \"Client-unix\";\n      }\n    } else {\n      return \"Server-jar\";\n    }\n  } catch (Exception e) {\n    return \"Unknown\";\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "155", "src_id": "M101", "code": "\nprivate void processRequest(\n    int limitPerDay,\n    String identifier,\n    Map<String, Bucket> buckets,\n    HttpServletRequest request,\n    HttpServletResponse response,\n    FilterChain filterChain)\n    throws IOException, ServletException {\n  \n  final Bucket userBucket = buckets.computeIfAbsent(\n      identifier, k -> createUserBucket(limitPerDay));\n  final ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n  \n  if (probe.isConsumed()) {\n    response.setHeader(\n        \"X-Rate-Limit-Remaining\",\n        Long.toString(probe.getRemainingTokens()));\n    filterChain.doFilter(request, response);\n  } else {\n    final long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n    response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n    response.setHeader(\n        \"X-Rate-Limit-Retry-After-Seconds\",\n        Long.toString(waitForRefill));\n    response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "156", "src_id": "M270", "code": "\nprivate static String normalizeArch(String value) {\n  value = normalize(value);\n  if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n    return \"x86_64\";\n  }\n  if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n    return \"x86_32\";\n  }\n  if (value.matches(\"^(ia64w?|itanium64)$\")) {\n    return \"itanium_64\";\n  }\n  if (\"ia64n\".equals(value)) {\n    return \"itanium_32\";\n  }\n  if (value.matches(\"^(sparc|sparc32)$\")) {\n    return \"sparc_32\";\n  }\n  if (value.matches(\"^(sparcv9|sparc64)$\")) {\n    return \"sparc_64\";\n  }\n  if (value.matches(\"^(arm|arm32)$\")) {\n    return \"arm_32\";\n  }\n  if (\"aarch64\".equals(value)) {\n    return \"aarch_64\";\n  }\n  if (value.matches(\"^(mips|mips32)$\")) {\n    return \"mips_32\";\n  }\n  if (value.matches(\"^(mipsel|mips32el)$\")) {\n    return \"mipsel_32\";\n  }\n  if (\"mips64\".equals(value)) {\n    return \"mips_64\";\n  }\n  if (\"mips64el\".equals(value)) {\n    return \"mipsel_64\";\n  }\n  if (value.matches(\"^(ppc|ppc32)$\")) {\n    return \"ppc_32\";\n  }\n  if (value.matches(\"^(ppcle|ppc32le)$\")) {\n    return \"ppcle_32\";\n  }\n  if (\"ppc64\".equals(value)) {\n    return \"ppc_64\";\n  }\n  if (\"ppc64le\".equals(value)) {\n    return \"ppcle_64\";\n  }\n  if (\"s390\".equals(value)) {\n    return \"s390_32\";\n  }\n  if (\"s390x\".equals(value)) {\n    return \"s390_64\";\n  }\n  return value;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "157", "src_id": "M928", "code": "\nprivate static Map<String, Object> doGetLoggerInfo(Logger logger) {\n  final Map<String, Object> info = new HashMap<>();\n  info.put(LoggerHelper.name, logger.getName());\n  info.put(LoggerHelper.clazz, logger.getClass());\n  \n  final CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n  if (codeSource != null) {\n    info.put(LoggerHelper.codeSource, codeSource.getLocation());\n  }\n  \n  info.put(LoggerHelper.additivity, logger.getAdditivity());\n  \n  final Level level = logger.getLevel();\n  final Level effectiveLevel = logger.getEffectiveLevel();\n  if (level != null) {\n    info.put(LoggerHelper.level, level.toString());\n  }\n  if (effectiveLevel != null) {\n    info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  final List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n  info.put(LoggerHelper.appenders, result);\n  \n  return info;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "158", "src_id": "M9", "code": "\n@SuppressWarnings(\"resource\")\npublic static long select(boolean v, long telnetPortPid, String select) throws InputMismatchException {\n  Map<Long, String> processMap = listProcessByJps(v);\n  \n  if (telnetPortPid > 0 && processMap.containsKey(telnetPortPid)) {\n    final String telnetPortProcess = processMap.get(telnetPortPid);\n    processMap.remove(telnetPortPid);\n    final Map<Long, String> newProcessMap = new LinkedHashMap<>();\n    newProcessMap.put(telnetPortPid, telnetPortProcess);\n    newProcessMap.putAll(processMap);\n    processMap = newProcessMap;\n  }\n\n  if (processMap.isEmpty()) {\n    AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n    return -1;\n  }\n\n  if (select != null && !select.trim().isEmpty()) {\n    int matchedSelectCount = 0;\n    Long matchedPid = null;\n    for (final Map.Entry entry : processMap.entrySet()) {\n      if (((String) entry.getValue()).contains(select)) {\n        matchedSelectCount++;\n        matchedPid = (Long) entry.getKey();\n      }\n    }\n    if (matchedSelectCount == 1) {\n      return matchedPid;\n    }\n  }\n\n  AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n  \n  int count = 1;\n  for (final String process : processMap.values()) {\n    if (count == 1) {\n      System.out.println(\"* [\" + count + \"]: \" + process);\n    } else {\n      System.out.println(\"  [\" + count + \"]: \" + process);\n    }\n    count++;\n  }\n\n  final String line = new Scanner(System.in).nextLine();\n  if (line.trim().isEmpty()) {\n    return processMap.keySet().iterator().next();\n  }\n\n  final int choice = new Scanner(line).nextInt();\n  if (choice <= 0 || choice > processMap.size()) {\n    return -1;\n  }\n\n  final Iterator idIter = processMap.keySet().iterator();\n  for (int i = 1; i <= choice; ++i) {\n    if (i == choice) {\n      return (Long) idIter.next();\n    }\n    idIter.next();\n  }\n\n  return -1;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "159", "src_id": "M140", "code": "\nvoid _processDo(int option) throws IOException {\n  if (debugoptions) {\n    System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n  }\n\n  if (__notifhand != null) {\n    __notifhand.receivedNegotiation(\n      TelnetNotificationHandler.RECEIVED_DO,\n      option\n    );\n  }\n\n  boolean acceptNewState = false;\n\n  if (optionHandlers[option] != null) {\n    acceptNewState = optionHandlers[option].getAcceptLocal();\n  } else {\n    if (option == TERMINAL_TYPE) {\n      if (terminalType != null && terminalType.length() > 0) {\n        acceptNewState = true;\n      }\n    }\n  }\n\n  if (_willResponse[option] > 0) {\n    --_willResponse[option];\n    if (_willResponse[option] > 0 && _stateIsWill(option)) {\n      --_willResponse[option];\n    }\n  }\n\n  if (_willResponse[option] == 0) {\n    if (_requestedWont(option)) {\n      switch (option) {\n        default:\n          break;\n      }\n\n      if (acceptNewState) {\n        _setWantWill(option);\n        _sendWill(option);\n      } else {\n        ++_willResponse[option];\n        _sendWont(option);\n      }\n    } else {\n      switch (option) {\n        default:\n          break;\n      }\n    }\n  }\n\n  _setWill(option);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "160", "src_id": "M1324", "code": "\nprivate void bind(Configure configure) throws Throwable {\n  final long start = System.currentTimeMillis();\n\n  if (!isBindRef.compareAndSet(false, true)) {\n    throw new IllegalStateException(\"already bind\");\n  }\n\n  if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n    final int newTelnetPort = SocketUtils.findAvailableTcpPort();\n    configure.setTelnetPort(newTelnetPort);\n    logger().info(\"generate random telnet port: \" + newTelnetPort);\n  }\n  \n  if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n    final int newHttpPort = SocketUtils.findAvailableTcpPort();\n    configure.setHttpPort(newHttpPort);\n    logger().info(\"generate random http port: \" + newHttpPort);\n  }\n  \n  if (configure.getAppName() == null) {\n    configure.setAppName(System.getProperty(\n      ArthasConstants.PROJECT_NAME,\n      System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)\n    ));\n  }\n\n  try {\n    if (configure.getTunnelServer() != null) {\n      tunnelClient = new TunnelClient();\n      tunnelClient.setAppName(configure.getAppName());\n      tunnelClient.setId(configure.getAgentId());\n      tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n      tunnelClient.setVersion(ArthasBanner.version());\n      final ChannelFuture channelFuture = tunnelClient.start();\n      channelFuture.await(10, TimeUnit.SECONDS);\n    }\n  } catch (Throwable t) {\n    logger().error(\"start tunnel client error\", t);\n  }\n\n  try {\n    final ShellServerOptions options = new ShellServerOptions()\n      .setInstrumentation(instrumentation)\n      .setPid(PidUtils.currentLongPid())\n      .setWelcomeMessage(ArthasBanner.welcome());\n    \n    if (configure.getSessionTimeout() != null) {\n      options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n    }\n\n    this.httpSessionManager = new HttpSessionManager();\n    if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n      final String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \"\n        + \"No password is currently configured. Therefore, a default password is generated, \"\n        + \"and clients need to use the password to connect!\";\n      AnsiLog.error(errorMsg);\n      configure.setPassword(StringUtils.randomString(64));\n      AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n      logger().error(errorMsg);\n      logger().info(\"Generated arthas password: \" + configure.getPassword());\n    }\n\n    this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n    shellServer = new ShellServerImpl(options);\n\n    final List<String> disabledCommands = new ArrayList<>();\n    if (configure.getDisabledCommands() != null) {\n      final String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n      if (strings != null) {\n        disabledCommands.addAll(Arrays.asList(strings));\n      }\n    }\n    \n    final BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n    final List<CommandResolver> resolvers = new ArrayList<>();\n    resolvers.add(builtinCommands);\n\n    workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n    if (configure.getTelnetPort() != null && configure.getTelnetPort() > 0) {\n      logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n      shellServer.registerTermServer(new HttpTelnetTermServer(\n        configure.getIp(),\n        configure.getTelnetPort(),\n        options.getConnectionTimeout(),\n        workerGroup,\n        httpSessionManager\n      ));\n    } else {\n      logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n    }\n    \n    if (configure.getHttpPort() != null && configure.getHttpPort() > 0) {\n      logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n      shellServer.registerTermServer(new HttpTermServer(\n        configure.getIp(),\n        configure.getHttpPort(),\n        options.getConnectionTimeout(),\n        workerGroup,\n        httpSessionManager\n      ));\n    } else {\n      if (configure.getTunnelServer() != null) {\n        shellServer.registerTermServer(new HttpTermServer(\n          configure.getIp(),\n          configure.getHttpPort(),\n          options.getConnectionTimeout(),\n          workerGroup,\n          httpSessionManager\n        ));\n      }\n      logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n    }\n\n    for (final CommandResolver resolver : resolvers) {\n      shellServer.registerCommandResolver(resolver);\n    }\n\n    shellServer.listen(new BindHandler(isBindRef));\n    if (!isBind()) {\n      throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \"\n        + configure.getTelnetPort() + \", http port: \" + configure.getHttpPort());\n    }\n\n    sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n    httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n\n    logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\",\n      configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n    if (configure.getStatUrl() != null) {\n      logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n    }\n    \n    UserStatUtil.setStatUrl(configure.getStatUrl());\n    UserStatUtil.setAgentId(configure.getAgentId());\n    UserStatUtil.arthasStart();\n\n    try {\n      SpyAPI.init();\n    } catch (Throwable e) {\n      // ignore\n    }\n\n    logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n  } catch (Throwable e) {\n    logger().error(\"Error during start as-server\", e);\n    destroy();\n    throw e;\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "161", "src_id": "M122", "code": "\nprivate int __read(boolean mayBlock) throws IOException {\n  int ch;\n\n  while (true) {\n    if (!mayBlock && super.available() == 0) {\n      return WOULD_BLOCK;\n    }\n\n    if ((ch = super.read()) < 0) {\n      return EOF;\n    }\n\n    ch = (ch & 0xff);\n\n    synchronized (__client) {\n      __client._processAYTResponse();\n    }\n\n    __client._spyRead(ch);\n\n    switch (__receiveState) {\n      case _STATE_CR:\n        if (ch == '\\0') {\n          continue;\n        }\n      case _STATE_DATA:\n        if (ch == TelnetCommand.IAC) {\n          __receiveState = _STATE_IAC;\n          continue;\n        }\n\n        if (ch == '\\r') {\n          synchronized (__client) {\n            if (__client._requestedDont(TelnetOption.BINARY)) {\n              __receiveState = _STATE_CR;\n            } else {\n              __receiveState = _STATE_DATA;\n            }\n          }\n        } else {\n          __receiveState = _STATE_DATA;\n        }\n        break;\n\n      case _STATE_IAC:\n        switch (ch) {\n          case TelnetCommand.WILL:\n            __receiveState = _STATE_WILL;\n            continue;\n          case TelnetCommand.WONT:\n            __receiveState = _STATE_WONT;\n            continue;\n          case TelnetCommand.DO:\n            __receiveState = _STATE_DO;\n            continue;\n          case TelnetCommand.DONT:\n            __receiveState = _STATE_DONT;\n            continue;\n          case TelnetCommand.SB:\n            __suboption_count = 0;\n            __receiveState = _STATE_SB;\n            continue;\n          case TelnetCommand.IAC:\n            __receiveState = _STATE_DATA;\n            break;\n          case TelnetCommand.SE:\n            __receiveState = _STATE_DATA;\n            continue;\n          default:\n            __receiveState = _STATE_DATA;\n            __client._processCommand(ch);\n            continue;\n        }\n        break;\n      case _STATE_WILL:\n        synchronized (__client) {\n          __client._processWill(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_WONT:\n        synchronized (__client) {\n          __client._processWont(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_DO:\n        synchronized (__client) {\n          __client._processDo(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_DONT:\n        synchronized (__client) {\n          __client._processDont(ch);\n          __client._flushOutputStream();\n        }\n        __receiveState = _STATE_DATA;\n        continue;\n      case _STATE_SB:\n        switch (ch) {\n          case TelnetCommand.IAC:\n            __receiveState = _STATE_IAC_SB;\n            continue;\n          default:\n            if (__suboption_count < __suboption.length) {\n              __suboption[__suboption_count++] = ch;\n            }\n            break;\n        }\n        __receiveState = _STATE_SB;\n        continue;\n      case _STATE_IAC_SB:\n        switch (ch) {\n          case TelnetCommand.SE:\n            synchronized (__client) {\n              __client._processSuboption(__suboption, __suboption_count);\n              __client._flushOutputStream();\n            }\n            __receiveState = _STATE_DATA;\n            continue;\n          case TelnetCommand.IAC:\n            if (__suboption_count < __suboption.length) {\n              __suboption[__suboption_count++] = ch;\n            }\n            break;\n          default:\n            break;\n        }\n        __receiveState = _STATE_SB;\n        continue;\n    }\n\n    break;\n  }\n\n  return ch;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "162", "src_id": "M8", "code": "\nprivate static String formatFileSize(long size) {\n  final double b = size;\n  final double k = size / 1024.0;\n  final double m = k / 1024.0;\n  final double g = m / 1024.0;\n  final double t = g / 1024.0;\n\n  final DecimalFormat dec = new DecimalFormat(\"0.00\");\n\n  if (t > 1) {\n    return dec.format(t).concat(\" TB\");\n  } else if (g > 1) {\n    return dec.format(g).concat(\" GB\");\n  } else if (m > 1) {\n    return dec.format(m).concat(\" MB\");\n  } else if (k > 1) {\n    return dec.format(k).concat(\" KB\");\n  } else {\n    return dec.format(b).concat(\" Bytes\");\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "163", "src_id": "M790", "code": "\n@Override\npublic byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n                        ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n  if (className == null) {\n    return null;\n  }\n\n  className = className.replace('/', '.');\n\n  final List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n  final ListIterator<RetransformEntry> listIterator = allRetransformEntries\n    .listIterator(allRetransformEntries.size());\n  \n  while (listIterator.hasPrevious()) {\n    final RetransformEntry retransformEntry = listIterator.previous();\n    final int id = retransformEntry.getId();\n    \n    boolean updateFlag = false;\n    if (className.equals(retransformEntry.getClassName())) {\n      if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) {\n        updateFlag = isLoaderMatch(retransformEntry, loader);\n      } else {\n        updateFlag = true;\n      }\n    }\n\n    if (updateFlag) {\n      logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\",\n        className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n      retransformEntry.incTransformCount();\n      return retransformEntry.getBytes();\n    }\n  }\n\n  return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "164", "src_id": "M716", "code": "\npublic static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n  table.row(\"IS-RETURN\", \"false\");\n  table.row(\"IS-EXCEPTION\", \"true\");\n\n  final Throwable t = (Throwable) throwableVO.getObject();\n  final Throwable cause = t instanceof InvocationTargetException ? t.getCause() : t;\n\n  if (throwableVO.needExpand()) {\n    table.row(\"THROW-EXCEPTION\", new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n  } else {\n    final StringWriter stringWriter = new StringWriter();\n    final PrintWriter printWriter = new PrintWriter(stringWriter);\n    try {\n      cause.printStackTrace(printWriter);\n      table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n    } finally {\n      printWriter.close();\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "165", "src_id": "M602", "code": "\nprivate AsyncProfiler profilerInstance() {\n  if (profiler != null) {\n    return profiler;\n  }\n\n  if (ProfilerAction.load.toString().equals(action)) {\n    profiler = AsyncProfiler.getInstance(actionArg);\n  }\n\n  if (libPath != null) {\n    FileOutputStream tmpLibOutputStream = null;\n    FileInputStream libInputStream = null;\n    try {\n      final File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n      tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n      libInputStream = new FileInputStream(libPath);\n\n      IOUtils.copy(libInputStream, tmpLibOutputStream);\n      libPath = tmpLibFile.getAbsolutePath();\n      logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n    } catch (Throwable e) {\n      logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n    } finally {\n      IOUtils.close(libInputStream);\n      IOUtils.close(tmpLibOutputStream);\n    }\n    profiler = AsyncProfiler.getInstance(libPath);\n  } else {\n    if (OSUtils.isLinux() || OSUtils.isMac()) {\n      throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n    } else {\n      throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n    }\n  }\n\n  return profiler;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        final Thread currentThread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            currentThread.setName(\n                \"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName()\n            );\n        }\n\n        Exception caughtException = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception processingError) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), processingError);\n\n            if (processingError instanceof InterruptedIOException \n                || processingError instanceof ClosedByInterruptException \n                || currentThread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            caughtException = processingError;\n        } finally {\n            final int status = (errCode == ERROR_NOTHING) ? 2 : 0;\n            notifyPostProcessing(status);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (caughtException == null) {\n                caughtException = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, caughtException);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "167", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection connection) \n            throws IOException, HttpError {\n        final int statusCode = connection.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + connection.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + connection.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" \n                + connection.getHeaderField(\"Content-Range\"));\n        }\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // Let download thread handle this error case\n            default:\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "168", "src_id": "M827", "code": "\n    private Elst parseEdts(final Box ref) throws IOException {\n        final Box box = untilBox(ref, ATOM_ELST);\n        if (box == null) {\n            return null;\n        }\n\n        final Elst elst = new Elst();\n\n        final boolean isVersion1 = (stream.read() == 1);\n        stream.skipBytes(3); // Skip flags\n\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            elst.bMediaRate = 0x00010000; // Default media rate (1.0)\n            return elst;\n        }\n\n        if (isVersion1) {\n            stream.skipBytes(DataReader.LONG_SIZE); // Skip segment duration\n            elst.mediaTime = stream.readLong();\n            // Skip remaining entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } else {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // Skip segment duration\n            elst.mediaTime = stream.readInt();\n        }\n\n        elst.bMediaRate = stream.readInt();\n        return elst;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "169", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        boolean completedSuccessfully = false;\n        long currentOffset = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && currentOffset > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + currentOffset);\n        }\n\n        try {\n            final long rangeStart = (mMission.unknownLength || currentOffset < 1) ? -1 : currentOffset;\n\n            final int threadId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // Workaround: bypass Android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(threadId, mConn);\n\n            // Handle possible resume error\n            if (mConn.getResponseCode() == 416 && currentOffset > 0) {\n                mMission.notifyProgress(-currentOffset);\n                currentOffset = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // Verify content length\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = (Utility.getContentLength(mConn) == -1);\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // Reset downloaded bytes counter\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + currentOffset);\n\n            mIs = mConn.getInputStream();\n            final byte[] buffer = new byte[DownloadMission.BUFFER_SIZE];\n            int bytesRead = 0;\n\n            while (mMission.running && (bytesRead = mIs.read(buffer, 0, buffer.length)) != -1) {\n                mF.write(buffer, 0, bytesRead);\n                currentOffset += bytesRead;\n                mMission.notifyProgress(bytesRead);\n            }\n\n            dispose();\n            completedSuccessfully = (bytesRead == -1);\n        } catch (Exception error) {\n            dispose();\n            mMission.fallbackResumeOffset = currentOffset;\n\n            if (!mMission.running || error instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            if (error instanceof HttpError \n                && ((HttpError) error).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // Recover expired URL (YouTube specific)\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(error);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"Encountered exception, retrying...\", error);\n            }\n\n            run(); // Retry download\n            return;\n        }\n\n        if (completedSuccessfully) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = currentOffset;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "170", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n\n        out.flush();\n        aux.flush();\n\n        final boolean underflow = (aux.offset < aux.length) || (out.offset < out.length);\n        final byte[] copyBuffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long bytesToCopy = amount;\n        while (bytesToCopy > 0) {\n            int readAmount = (int) Math.min(bytesToCopy, Integer.MAX_VALUE);\n            readAmount = aux.target.read(\n                copyBuffer, \n                0, \n                Math.min(readAmount, copyBuffer.length)\n            );\n\n            if (readAmount < 1) {\n                amount -= bytesToCopy;\n                break;\n            }\n\n            out.writeProof(copyBuffer, readAmount);\n            bytesToCopy -= readAmount;\n        }\n\n        if (underflow) {\n            if (out.offset >= out.length) {\n                if (aux.offset < amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        } else {\n            out.offset += amount;\n            aux.offset -= amount;\n        }\n\n        out.length += amount;\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        if (amount < aux.length) {\n            // Move remaining data to file start\n            long readPointer = amount;\n            long writePointer = 0;\n            aux.length -= amount;\n            long remainingBytes = aux.length;\n\n            while (remainingBytes > 0) {\n                int copyAmount = (int) Math.min(remainingBytes, Integer.MAX_VALUE);\n                copyAmount = aux.target.read(\n                    copyBuffer, \n                    0, \n                    Math.min(copyAmount, copyBuffer.length)\n                );\n\n                aux.target.seek(writePointer);\n                aux.writeProof(copyBuffer, copyAmount);\n\n                writePointer += copyAmount;\n                readPointer += copyAmount;\n                remainingBytes -= copyAmount;\n                aux.target.seek(readPointer);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);\n        }\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "171", "src_id": "M1106", "code": "\n    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        final StringBuilder requestBuilder = new StringBuilder(256);\n        requestBuilder.append(mission.source).append(\" [\");\n\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n                requestBuilder.append(' ')\n                    .append(recovery.toString())\n                    .append(' ');\n            }\n        }\n        requestBuilder.append(']');\n\n        final String serviceName;\n        try {\n            serviceName = NewPipe.getServiceByUrl(mission.source)\n                .getServiceInfo()\n                .getName();\n        } catch (Exception e) {\n            serviceName = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(\n            mContext,\n            new ErrorInfo(\n                ErrorInfo.Companion.throwableToStringList(mission.errObject),\n                action,\n                serviceName,\n                requestBuilder.toString(),\n                reason\n            )\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "172", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            // Create mission metadata file\n            while (true) {\n                mission.metadata = new File(\n                    mPendingMissionsDir, \n                    String.valueOf(mission.timestamp)\n                );\n                \n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Failed to create metadata file\");\n                        }\n                    } catch (IOException creationError) {\n                        throw new RuntimeException(creationError);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Persist mission state before proceeding\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"Storage unavailable\");\n                }\n                return;\n            }\n\n            final boolean shouldStartImmediately = \n                !mPrefQueueLimit || (getRunningMissionsCount() < 1);\n\n            if (canDownloadInCurrentNetwork() && shouldStartImmediately) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "173", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        final String format = getArgumentAt(0, null);\n        final boolean ignoreEmptyFrames = \"true\".equals(getArgumentAt(1, \"true\"));\n\n        if (format == null || \"ttml\".equals(format)) {\n            final SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception conversionError) {\n                Log.e(TAG, \"Subtitle conversion failed\", conversionError);\n                return (conversionError instanceof IOException) ? 1 : 8;\n            }\n            return OK_RESULT;\n        } else if (\"srt\".equals(format)) {\n            final byte[] buffer = new byte[8 * 1024];\n            int bytesRead;\n            while ((bytesRead = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, bytesRead);\n            }\n            return OK_RESULT;\n        }\n\n        throw new UnsupportedOperationException(\n            \"Unimplemented subtitle format: \" + format\n        );\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "174", "src_id": "M1047", "code": "\n    private void joinForThreads(int timeoutMillis) {\n        final Thread currentThread = Thread.currentThread();\n\n        // Handle initializer thread\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (timeoutMillis > 0) {\n                try {\n                    init.join(timeoutMillis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread still active\", e);\n                    return;\n                }\n            }\n        }\n\n        // Interrupt all active worker threads\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == currentThread) continue;\n            thread.interrupt();\n        }\n\n        try {\n            // Wait for threads to terminate\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) continue;\n                if (DEBUG) {\n                    Log.w(TAG, \"Active thread: \" + thread.getName());\n                }\n                if (timeoutMillis > 0) {\n                    thread.join(timeoutMillis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"Thread termination timeout exceeded\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "22", "src_id": "M1277", "code": "\npublic static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n    Map<String, String> output = new HashMap<>(input.size());\n    for (Map.Entry<String, Object> entry : input.entrySet()) {\n        String key = entry.getKey();\n        Object obj = entry.getValue();\n        if (key == null || obj == null) {\n            throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n        }\n\n        String str;\n        if (obj instanceof byte[]) {\n            str = SafeEncoder.encode((byte[]) obj);\n        } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n            redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n            str = geo.getLongitude() + \",\" + geo.getLatitude();\n        } else if (obj instanceof String) {\n            str = stringEscape ? escape((String) obj) : (String) obj;\n        } else {\n            str = String.valueOf(obj);\n        }\n        output.put(key, str);\n    }\n    return output;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "23", "src_id": "M902", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (ignore) {\n        args.add(IGNORE)\n            .add(ignoreMaxTimediff)\n            .add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        for (Map.Entry<String, String> entry : labels.entrySet()) {\n            args.add(entry.getKey());\n            args.add(entry.getValue());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "24", "src_id": "M1131", "code": "\nprivate static Object process(RedisInputStream is) {\n    byte b = is.readByte();\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE:  // TODO: Currently just to start working with HELLO\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE:  // TODO: Implement proper handling\n            return processMultiBulkReply(is);\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        // TODO: Handle blob error '!' type\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "25", "src_id": "M1057", "code": "\n@Override\npublic Map.Entry<T, ProfilingInfo> build(Object data) {\n    List list = (List) data;\n    if (list == null || list.isEmpty()) {\n        return null;\n    }\n\n    if (list.get(0) instanceof KeyValue) { // RESP3\n        Object resultsData = null;\n        Object profileData = null;\n\n        for (KeyValue keyValue : (List<KeyValue>) data) {\n            String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n            switch (keyStr) {\n                case PROFILE_STR_REDIS7:\n                case PROFILE_STR_REDIS8:\n                    profileData = keyValue.getValue();\n                    break;\n                case RESULTS_STR_REDIS7:\n                    resultsData = data;\n                    break;\n                case RESULTS_STR_REDIS8:\n                    resultsData = keyValue.getValue();\n                    break;\n            }\n        }\n\n        assert resultsData != null : \"Could not detect Results data.\";\n        assert profileData != null : \"Could not detect Profile data.\";\n        return KeyValue.of(\n                resultsBuilder.build(resultsData),\n                ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n    }\n\n    return KeyValue.of(\n            resultsBuilder.build(list.get(0)),\n            ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "26", "src_id": "M1229", "code": "\npublic SSLContext createSslContext() throws IOException, GeneralSecurityException {\n    KeyManager[] keyManagers = null;\n    TrustManager[] trustManagers = null;\n\n    // Configure trust managers based on SSL verification mode\n    if (sslVerifyMode == SslVerifyMode.FULL) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n    } else if (sslVerifyMode == SslVerifyMode.CA) {\n        this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n        trustManagers = new TrustManager[] { INSECURE_TRUST_MANAGER };\n    }\n\n    // Load keystore if provided\n    if (keystoreResource != null) {\n        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n        try (InputStream keystoreStream = keystoreResource.get()) {\n            keyStore.load(keystoreStream, keystorePassword);\n        }\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n        keyManagerFactory.init(keyStore, keystorePassword);\n        keyManagers = keyManagerFactory.getKeyManagers();\n    }\n\n    // Load truststore if provided and trustManagers not set\n    if (trustManagers == null && truststoreResource != null) {\n        KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n        try (InputStream truststoreStream = truststoreResource.get()) {\n            trustStore.load(truststoreStream, truststorePassword);\n        }\n\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n        trustManagerFactory.init(trustStore);\n        trustManagers = trustManagerFactory.getTrustManagers();\n    }\n\n    // Initialize SSL context\n    SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n    sslContext.init(keyManagers, trustManagers, null);\n\n    return sslContext;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "27", "src_id": "M894", "code": "\n@Override\npublic TSInfo build(Object data) {\n    List<KeyValue> list = (List<KeyValue>) data;\n    Map<String, Object> properties = new HashMap<>();\n    Map<String, String> labels = null;\n    Map<String, Rule> rules = null;\n    List<Map<String, Object>> chunks = null;\n\n    for (KeyValue propertyValue : list) {\n        String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n        Object value = propertyValue.getValue();\n\n        // Handle list-type properties\n        if (value instanceof List) {\n            switch (prop) {\n                case LABELS_PROPERTY:\n                    labels = BuilderFactory.STRING_MAP.build(value);\n                    value = labels;  // Use decoded labels map as value\n                    break;\n\n                case RULES_PROPERTY:\n                    List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                    Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), 1f);\n                    rules = new HashMap<>(rulesDataList.size());\n\n                    for (KeyValue rkv : rulesDataList) {\n                        String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                        List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                        rulesValueMap.put(ruleName, ruleValueList);\n                        rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                    }\n                    value = rulesValueMap;\n                    break;\n\n                case CHUNKS_PROPERTY:\n                    List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                    List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                    chunks = new ArrayList<>(chunksDataList.size());\n\n                    for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                        Map<String, Object> chunk = chunkDataAsList.stream()\n                            .collect(Collectors.toMap(\n                                kv -> BuilderFactory.STRING.build(kv.getKey()),\n                                kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())\n                            ));\n                        chunksValueList.add(chunk);\n                        chunks.add(chunk);\n                    }\n                    value = chunksValueList;\n                    break;\n\n                default:\n                    value = SafeEncoder.encodeObject(value);\n                    break;\n            }\n        } \n        // Handle byte array properties\n        else if (value instanceof byte[]) {\n            value = BuilderFactory.STRING.build(value);\n            \n            // Special handling for duplicate policy property\n            if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                try {\n                    value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                } catch (Exception e) {\n                    // Ignore conversion failure, retain string value\n                }\n            }\n        }\n        \n        properties.put(prop, value);\n    }\n\n    return new TSInfo(properties, labels, rules, chunks);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "28", "src_id": "M897", "code": "\n@Override\npublic void addParams(CommandArguments args) {\n\n    if (retentionPeriod != null) {\n        args.add(RETENTION).add(toByteArray(retentionPeriod));\n    }\n\n    if (encoding != null) {\n        args.add(ENCODING).add(encoding);\n    }\n\n    if (chunkSize != null) {\n        args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (duplicatePolicy != null) {\n        args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n    }\n\n    if (onDuplicate != null) {\n        args.add(ON_DUPLICATE).add(onDuplicate);\n    }\n\n    if (ignore) {\n        args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n    }\n\n    if (labels != null) {\n        args.add(LABELS);\n        for (Map.Entry<?, ?> entry : labels.entrySet()) {\n            args.add(entry.getKey()).add(entry.getValue());\n        }\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "29", "src_id": "M1213", "code": "\n@Override\npublic Connection getConnection() {\n    List<ConnectionPool> pools = getShuffledNodesPool();\n\n    JedisException suppressed = null;\n    for (ConnectionPool pool : pools) {\n        Connection jedis = null;\n        try {\n            jedis = pool.getResource();\n            if (jedis == null) {\n                continue;\n            }\n\n            jedis.ping();\n            return jedis;\n        } catch (JedisException ex) {\n            if (suppressed == null) { // Remember first suppressed exception\n                suppressed = ex;\n            }\n            if (jedis != null) {\n                jedis.close();\n            }\n        }\n    }\n\n    JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n    if (suppressed != null) {\n        noReachableNode.addSuppressed(suppressed);\n    }\n    throw noReachableNode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "30", "src_id": "M9", "code": "\n  @Override\n  public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n    lock.lock();\n    try {\n      // Store the entry and get updated reference\n      entry = putIntoStore(cacheKey, entry);\n      \n      // Update eviction policy and check for evictions\n      EvictionPolicy policy = getEvictionPolicy();\n      policy.touch(cacheKey);\n      \n      CacheKey evictedKey = policy.evictNext();\n      if (evictedKey != null) {\n        delete(evictedKey);\n        stats.evict();\n      }\n      \n      // Maintain reverse mapping for Redis keys\n      for (Object redisKey : cacheKey.getRedisKeys()) {\n        ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n        \n        // Get or create key set for this Redis key\n        Set<CacheKey<?>> set = redisKeysToCacheKeys.get(mapKey);\n        if (set == null) {\n          set = ConcurrentHashMap.newKeySet();\n          redisKeysToCacheKeys.put(mapKey, set);\n        }\n        set.add(cacheKey);\n      }\n      \n      // Update statistics and return result\n      stats.load();\n      return entry;\n    } finally {\n      lock.unlock();\n    }\n  }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "31", "src_id": "M1105", "code": "\n@Override\npublic Class<?> build(Object data) {\n    if (data == null) {\n        return null;\n    }\n\n    String str = STRING.build(data);\n\n    switch (str) {\n        case \"null\":\n            return null;\n        case \"boolean\":\n            return boolean.class;\n        case \"integer\":\n            return int.class;\n        case \"number\":\n            return float.class;\n        case \"string\":\n            return String.class;\n        case \"object\":\n            return Object.class;\n        case \"array\":\n            return List.class;\n        default:\n            throw new JedisException(\"Unknown type: \" + str);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "103", "src_id": "M31", "code": "\nprivate JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n    String requestBody = String.format(\n        \"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\",\n        licenseKey,\n        machineFingerprint\n    );\n    \n    HttpRequest request = HttpRequest.newBuilder()\n        .uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\"))\n        .header(\"Content-Type\", \"application/vnd.api+json\")\n        .header(\"Accept\", \"application/vnd.api+json\")\n        // .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n        .build();\n\n    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n    log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n    JsonNode jsonResponse = objectMapper.readTree(response.body());\n    \n    if (response.statusCode() == 200) {\n        JsonNode metaNode = jsonResponse.path(\"meta\");\n        boolean isValid = metaNode.path(\"valid\").asBoolean();\n        String detail = metaNode.path(\"detail\").asText();\n        String code = metaNode.path(\"code\").asText();\n\n        log.info(\"License validity: {}\", isValid);\n        log.info(\"Validation detail: {}\", detail);\n        log.info(\"Validation code: {}\", code);\n\n        JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n        if (!licenseAttrs.isMissingNode()) {\n            context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n            context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n            log.info(\n                \"License floating (from license): {}, maxMachines: {}\",\n                context.isFloatingLicense,\n                context.maxMachines\n            );\n        }\n\n        JsonNode includedNode = jsonResponse.path(\"included\");\n        JsonNode policyNode = null;\n\n        if (includedNode.isArray()) {\n            for (JsonNode node : includedNode) {\n                if (\"policies\".equals(node.path(\"type\").asText())) {\n                    policyNode = node;\n                    break;\n                }\n            }\n        }\n\n        if (policyNode != null) {\n            boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n            int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n            if (policyFloating) {\n                context.isFloatingLicense = true;\n                context.maxMachines = policyMaxMachines;\n            }\n\n            log.info(\n                \"License floating (from policy): {}, maxMachines: {}\",\n                context.isFloatingLicense,\n                context.maxMachines\n            );\n        }\n\n        int users = jsonResponse\n            .path(\"data\")\n            .path(\"attributes\")\n            .path(\"metadata\")\n            .path(\"users\")\n            .asInt(1);\n        applicationProperties.getPremium().setMaxUsers(users);\n\n        context.isEnterpriseLicense = jsonResponse\n            .path(\"data\")\n            .path(\"attributes\")\n            .path(\"metadata\")\n            .path(\"isEnterprise\")\n            .asBoolean(false);\n\n        log.debug(applicationProperties.toString());\n    } else {\n        log.error(\"Error validating license. Status code: {}\", response.statusCode());\n    }\n    return jsonResponse;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "104", "src_id": "M488", "code": "\n    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n            summary = \"Convert a file to a PDF using LibreOffice\",\n            description = \n                    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\"\n                            + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n            throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n\n            PDDocument doc = pdfDocumentFactory.load(file);\n            String baseFilename = Filenames.toSimpleFileName(inputFile.getOriginalFilename())\n                                          .replaceFirst(\"[.][^.]+$\", \"\");\n            String outputFilename = baseFilename + \"_convertedToPDF.pdf\";\n            \n            return WebResponseUtils.pdfDocToWebResponse(\n                    doc, \n                    outputFilename);\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "105", "src_id": "M625", "code": "\n@PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n@Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\npublic ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n    MultipartFile inputFile = request.getFileInput();\n    boolean readonly = true;\n    try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly)) {\n        ObjectMapper objectMapper = new ObjectMapper();\n        ObjectNode jsonOutput = objectMapper.createObjectNode();\n\n        PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n        ObjectNode metadata = objectMapper.createObjectNode();\n        ObjectNode basicInfo = objectMapper.createObjectNode();\n        ObjectNode docInfoNode = objectMapper.createObjectNode();\n        ObjectNode compliancy = objectMapper.createObjectNode();\n        ObjectNode encryption = objectMapper.createObjectNode();\n        ObjectNode other = objectMapper.createObjectNode();\n\n        metadata.put(\"Title\", info.getTitle());\n        metadata.put(\"Author\", info.getAuthor());\n        metadata.put(\"Subject\", info.getSubject());\n        metadata.put(\"Keywords\", info.getKeywords());\n        metadata.put(\"Producer\", info.getProducer());\n        metadata.put(\"Creator\", info.getCreator());\n        metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n        metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n        jsonOutput.set(\"Metadata\", metadata);\n\n        long fileSizeInBytes = inputFile.getSize();\n        basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n\n        String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n        String[] words = fullText.split(\"\\\\s+\");\n        int wordCount = words.length;\n        int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n        basicInfo.put(\"WordCount\", wordCount);\n        basicInfo.put(\"ParagraphCount\", paragraphCount);\n        int charCount = fullText.length();\n        basicInfo.put(\"CharacterCount\", charCount);\n\n        boolean hasCompression = false;\n        String compressionType = \"None\";\n        basicInfo.put(\"Compression\", hasCompression);\n        if (hasCompression) {\n            basicInfo.put(\"CompressionType\", compressionType);\n        }\n\n        String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n        basicInfo.put(\"Language\", language);\n        basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n\n        PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n        String pageMode = catalog.getPageMode().name();\n\n        docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n        docInfoNode.put(\"Trapped\", info.getTrapped());\n        docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n\n        PDAcroForm acroForm = catalog.getAcroForm();\n        ObjectNode formFieldsNode = objectMapper.createObjectNode();\n        if (acroForm != null) {\n            for (PDField field : acroForm.getFieldTree()) {\n                formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n            }\n        }\n        jsonOutput.set(\"FormFields\", formFieldsNode);\n\n        ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n        if (summaryData != null && summaryData.size() > 0) {\n            jsonOutput.set(\"SummaryData\", summaryData);\n        }\n\n        if (catalog.getNames() != null) {\n            PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n            ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n            if (efTree != null) {\n                Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                if (efMap != null) {\n                    for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                        ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                        embeddedFileNode.put(\"Name\", entry.getKey());\n                        PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                        if (embeddedFile != null) {\n                            embeddedFileNode.put(\"FileSize\", embeddedFile.getLength());\n                        }\n                        embeddedFilesArray.add(embeddedFileNode);\n                    }\n                }\n            }\n            other.set(\"EmbeddedFiles\", embeddedFilesArray);\n        }\n\n        ArrayNode attachmentsArray = objectMapper.createArrayNode();\n        for (PDPage page : pdfBoxDoc.getPages()) {\n            for (PDAnnotation annotation : page.getAnnotations()) {\n                if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                    ObjectNode attachmentNode = objectMapper.createObjectNode();\n                    attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n                    attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n                    attachmentsArray.add(attachmentNode);\n                }\n            }\n        }\n        other.set(\"Attachments\", attachmentsArray);\n\n        PDDocumentNameDictionary namesDict = catalog.getNames();\n        ArrayNode javascriptArray = objectMapper.createArrayNode();\n        if (namesDict != null) {\n            PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n            if (javascriptDict != null) {\n                try {\n                    Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                    for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                        ObjectNode jsNode = objectMapper.createObjectNode();\n                        jsNode.put(\"JS Name\", entry.getKey());\n                        PDActionJavaScript jsAction = entry.getValue();\n                        if (jsAction != null) {\n                            String jsCodeStr = jsAction.getAction();\n                            if (jsCodeStr != null) {\n                                jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                            }\n                        }\n                        javascriptArray.add(jsNode);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n        }\n        other.set(\"JavaScript\", javascriptArray);\n\n        PDOptionalContentProperties ocProperties = catalog.getOCProperties();\n        ArrayNode layersArray = objectMapper.createArrayNode();\n        if (ocProperties != null) {\n            for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                ObjectNode layerNode = objectMapper.createObjectNode();\n                layerNode.put(\"Name\", ocg.getName());\n                layersArray.add(layerNode);\n            }\n        }\n        other.set(\"Layers\", layersArray);\n\n        PDStructureTreeRoot structureTreeRoot = catalog.getStructureTreeRoot();\n        ArrayNode structureTreeArray;\n        try {\n            if (structureTreeRoot != null) {\n                structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                other.set(\"StructureTree\", structureTreeArray);\n            }\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n\n        boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n        boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n        boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n        boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n        boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n        boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\");\n        boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\");\n\n        compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n        compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n        compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n        compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n        compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n        compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n        compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n        PDOutlineNode root = catalog.getDocumentOutline();\n        ArrayNode bookmarksArray = objectMapper.createArrayNode();\n        if (root != null) {\n            for (PDOutlineItem child : root.children()) {\n                addOutlinesToArray(child, bookmarksArray);\n            }\n        }\n        other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n        PDMetadata pdMetadata = catalog.getMetadata();\n        String xmpString = null;\n        if (pdMetadata != null) {\n            try {\n                try (COSInputStream is = pdMetadata.createInputStream()) {\n                    DomXmpParser domXmpParser = new DomXmpParser();\n                    XMPMetadata xmpMeta = domXmpParser.parse(is);\n                    ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    new XmpSerializer().serialize(xmpMeta, os, true);\n                    xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                }\n            } catch (XmpParsingException e) {\n                log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                try (COSInputStream is = pdMetadata.createInputStream()) {\n                    byte[] metadataBytes = is.readAllBytes();\n                    xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                }\n            } catch (IOException e) {\n                log.error(\"exception\", e);\n            }\n        }\n        other.put(\"XMPMetadata\", xmpString);\n\n        if (pdfBoxDoc.isEncrypted()) {\n            encryption.put(\"IsEncrypted\", true);\n            PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n            encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n            encryption.put(\"KeyLength\", pdfEncryption.getLength());\n        } else {\n            encryption.put(\"IsEncrypted\", false);\n        }\n\n        ObjectNode permissionsNode = objectMapper.createObjectNode();\n        setNodePermissions(pdfBoxDoc, permissionsNode);\n\n        ObjectNode pageInfoParent = objectMapper.createObjectNode();\n        for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n            ObjectNode pageInfo = objectMapper.createObjectNode();\n            PDPage page = pdfBoxDoc.getPage(pageNum);\n            PDRectangle mediaBox = page.getMediaBox();\n            float width = mediaBox.getWidth();\n            float height = mediaBox.getHeight();\n            ObjectNode sizeInfo = objectMapper.createObjectNode();\n\n            getDimensionInfo(sizeInfo, width, height);\n            sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n            pageInfo.set(\"Size\", sizeInfo);\n\n            pageInfo.put(\"Rotation\", page.getRotation());\n            pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n            pageInfo.put(\"MediaBox\", mediaBox.toString());\n            PDRectangle cropBox = page.getCropBox();\n            pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n            PDRectangle bleedBox = page.getBleedBox();\n            pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n            PDRectangle trimBox = page.getTrimBox();\n            pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n            PDRectangle artBox = page.getArtBox();\n            pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n\n            PDFTextStripper textStripper = new PDFTextStripper();\n            textStripper.setStartPage(pageNum + 1);\n            textStripper.setEndPage(pageNum + 1);\n            String pageText = textStripper.getText(pdfBoxDoc);\n            pageInfo.put(\"Text Characters Count\", pageText.length());\n\n            List<PDAnnotation> annotations = page.getAnnotations();\n            int subtypeCount = 0;\n            int contentsCount = 0;\n            for (PDAnnotation annotation : annotations) {\n                if (annotation.getSubtype() != null) {\n                    subtypeCount++;\n                }\n                if (annotation.getContents() != null) {\n                    contentsCount++;\n                }\n            }\n            ObjectNode annotationsObject = objectMapper.createObjectNode();\n            annotationsObject.put(\"AnnotationsCount\", annotations.size());\n            annotationsObject.put(\"SubtypeCount\", subtypeCount);\n            annotationsObject.put(\"ContentsCount\", contentsCount);\n            pageInfo.set(\"Annotations\", annotationsObject);\n\n            ArrayNode imagesArray = objectMapper.createArrayNode();\n            PDResources resources = page.getResources();\n            for (COSName name : resources.getXObjectNames()) {\n                PDXObject xObject = resources.getXObject(name);\n                if (xObject instanceof PDImageXObject image) {\n                    ObjectNode imageNode = objectMapper.createObjectNode();\n                    imageNode.put(\"Width\", image.getWidth());\n                    imageNode.put(\"Height\", image.getHeight());\n                    if (image.getMetadata() != null\n                            && image.getMetadata().getFile() != null\n                            && image.getMetadata().getFile().getFile() != null) {\n                        imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                    }\n                    if (image.getColorSpace() != null) {\n                        imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                    }\n                    imagesArray.add(imageNode);\n                }\n            }\n            pageInfo.set(\"Images\", imagesArray);\n\n            ArrayNode linksArray = objectMapper.createArrayNode();\n            Set<String> uniqueURIs = new HashSet<>();\n            for (PDAnnotation annotation : annotations) {\n                if (annotation instanceof PDAnnotationLink linkAnnotation) {\n                    if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        uniqueURIs.add(uriAction.getURI());\n                    }\n                }\n            }\n            for (String uri : uniqueURIs) {\n                ObjectNode linkNode = objectMapper.createObjectNode();\n                linkNode.put(\"URI\", uri);\n                linksArray.add(linkNode);\n            }\n            pageInfo.set(\"Links\", linksArray);\n\n            ArrayNode fontsArray = objectMapper.createArrayNode();\n            Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n            for (COSName fontName : resources.getFontNames()) {\n                PDFont font = resources.getFont(fontName);\n                ObjectNode fontNode = objectMapper.createObjectNode();\n                fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                fontNode.put(\"Name\", font.getName());\n                fontNode.put(\"Subtype\", font.getType());\n                PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                if (fontDescriptor != null) {\n                    fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                    int flags = fontDescriptor.getFlags();\n                    fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                    fontNode.put(\"IsBold\", (flags & 64) != 0);\n                    fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                    fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                    fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                    fontNode.put(\"IsScript\", (flags & 16) != 0);\n                    fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                    fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                    fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                }\n                String uniqueKey = fontNode.toString();\n                if (uniqueFontsMap.containsKey(uniqueKey)) {\n                    ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                    int count = existingFontNode.get(\"Count\").asInt() + 1;\n                    existingFontNode.put(\"Count\", count);\n                } else {\n                    fontNode.put(\"Count\", 1);\n                    uniqueFontsMap.put(uniqueKey, fontNode);\n                }\n            }\n            for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                fontsArray.add(uniqueFontNode);\n            }\n            pageInfo.set(\"Fonts\", fontsArray);\n\n            ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n            Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n            for (COSName name : colorSpaceNames) {\n                PDColorSpace colorSpace = resources.getColorSpace(name);\n                if (colorSpace instanceof PDICCBased iccBased) {\n                    PDStream iccData = iccBased.getPDStream();\n                    byte[] iccBytes = iccData.toByteArray();\n                    ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                    iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                    colorSpacesArray.add(iccProfileNode);\n                }\n            }\n            pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n\n            Map<String, Integer> xObjectCountMap = new HashMap<>();\n            for (COSName name : resources.getXObjectNames()) {\n                PDXObject xObject = resources.getXObject(name);\n                String xObjectType;\n                if (xObject instanceof PDImageXObject) {\n                    xObjectType = \"Image\";\n                } else if (xObject instanceof PDFormXObject) {\n                    xObjectType = \"Form\";\n                } else {\n                    xObjectType = \"Other\";\n                }\n                xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n            }\n            ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n            for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                xObjectCountNode.put(entry.getKey(), entry.getValue());\n            }\n            pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n\n            ArrayNode multimediaArray = objectMapper.createArrayNode();\n            for (PDAnnotation annotation : annotations) {\n                if (\"RichMedia\".equals(annotation.getSubtype())) {\n                    multimediaArray.add(objectMapper.createObjectNode());\n                }\n            }\n            pageInfo.set(\"Multimedia\", multimediaArray);\n\n            pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n        }\n\n        jsonOutput.set(\"BasicInfo\", basicInfo);\n        jsonOutput.set(\"DocumentInfo\", docInfoNode);\n        jsonOutput.set(\"Compliancy\", compliancy);\n        jsonOutput.set(\"Encryption\", encryption);\n        jsonOutput.set(\"Permissions\", permissionsNode);\n        jsonOutput.set(\"Other\", other);\n        jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n\n        String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n        return WebResponseUtils.bytesToWebResponse(\n            jsonString.getBytes(StandardCharsets.UTF_8),\n            \"response.json\",\n            MediaType.APPLICATION_JSON\n        );\n    } catch (Exception e) {\n        log.error(\"exception\", e);\n    }\n    return null;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "106", "src_id": "M24", "code": "\n    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile.replace(CERT_PREFIX, \"\")\n                                              .replace(CERT_SUFFIX, \"\")\n                                              .replaceAll(\"\\\\r?\\\\n\", \"\");\n            String payload = new String(Base64.getDecoder().decode(encodedPayload));\n            log.info(\"Decoded certificate payload: {}\", payload);\n\n            String encryptedData;\n            String encodedSignature;\n            String algorithm;\n\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            if (!verifyEd25519Signature(encryptedData, encodedSignature)) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n\n            log.info(\"License file signature is valid\");\n\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n\n            return processCertificateData(decodedData, context);\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "107", "src_id": "M403", "code": "\n    private static void sanitizeHtmlFilesInZip(\n            Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n            throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(\n                    new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(\n                            sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase().endsWith(\".html\")\n                                || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(\n                                    StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "108", "src_id": "M317", "code": "\npublic static void addImageToDocument(\n        PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n        throws IOException {\n    boolean imageIsLandscape = image.getWidth() > image.getHeight();\n    PDRectangle pageSize = PDRectangle.A4;\n\n    if (autoRotate && imageIsLandscape) {\n        pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n    }\n\n    if (\"fitDocumentToImage\".equals(fitOption)) {\n        pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n    }\n\n    PDPage page = new PDPage(pageSize);\n    doc.addPage(page);\n\n    float pageWidth = page.getMediaBox().getWidth();\n    float pageHeight = page.getMediaBox().getHeight();\n\n    try (PDPageContentStream contentStream =\n            new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n        if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n            contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n        } else if (\"maintainAspectRatio\".equals(fitOption)) {\n            float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n            float pageAspectRatio = pageWidth / pageHeight;\n\n            float scaleFactor = 1.0f;\n            if (imageAspectRatio > pageAspectRatio) {\n                scaleFactor = pageWidth / image.getWidth();\n            } else {\n                scaleFactor = pageHeight / image.getHeight();\n            }\n\n            float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n            float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n            contentStream.drawImage(\n                    image,\n                    xPos,\n                    yPos,\n                    image.getWidth() * scaleFactor,\n                    image.getHeight() * scaleFactor);\n        }\n    } catch (IOException e) {\n        log.error(\"Error adding image to PDF\", e);\n        throw e;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "109", "src_id": "M307", "code": "\n    public static String generateMachineFingerprint() {\n        try {\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n            byte[] mac = null;\n            if (network != null) {\n                mac = network.getHardwareAddress();\n            } else {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements() && mac == null) {\n                    NetworkInterface net = networks.nextElement();\n                    mac = net.getHardwareAddress();\n                }\n            }\n\n            if (mac != null) {\n                for (byte b : mac) {\n                    sb.append(String.format(\"%02X\", b));\n                }\n            }\n\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "110", "src_id": "M135", "code": "\nprivate void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n    PDDocumentInformation documentInformation = pdf.getDocumentInformation();\n    String title = pdfMetadata.getTitle();\n    documentInformation.setTitle(title);\n    documentInformation.setProducer(stirlingPDFLabel);\n    documentInformation.setSubject(pdfMetadata.getSubject());\n    documentInformation.setKeywords(pdfMetadata.getKeywords());\n    documentInformation.setModificationDate(Calendar.getInstance());\n\n    String author = pdfMetadata.getAuthor();\n    if (applicationProperties\n            .getPremium()\n            .getProFeatures()\n            .getCustomMetadata()\n            .isAutoUpdateMetadata()\n            && runningProOrHigher) {\n        author = applicationProperties\n                .getPremium()\n                .getProFeatures()\n                .getCustomMetadata()\n                .getAuthor();\n\n        if (userService != null) {\n            author = author.replace(\"username\", userService.getCurrentUsername());\n        }\n    }\n    documentInformation.setAuthor(author);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "111", "src_id": "M128", "code": "\n@Bean(name = \"machineType\")\npublic String determineMachineType() {\n    try {\n        boolean isDocker = runningInDocker();\n        boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n        boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n        if (isKubernetes) {\n            return \"Kubernetes\";\n        } else if (isDocker) {\n            return \"Docker\";\n        } else if (isBrowserOpen) {\n            String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n            if (os.contains(\"win\")) {\n                return \"Client-windows\";\n            } else if (os.contains(\"mac\")) {\n                return \"Client-mac\";\n            } else {\n                return \"Client-unix\";\n            }\n        } else {\n            return \"Server-jar\";\n        }\n    } catch (Exception e) {\n        return \"Unknown\";\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "112", "src_id": "M101", "code": "\nprivate void processRequest(\n        int limitPerDay,\n        String identifier,\n        Map<String, Bucket> buckets,\n        HttpServletRequest request,\n        HttpServletResponse response,\n        FilterChain filterChain)\n        throws IOException, ServletException {\n    Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n    ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n    if (probe.isConsumed()) {\n        response.setHeader(\n                \"X-Rate-Limit-Remaining\",\n                stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n        filterChain.doFilter(request, response);\n    } else {\n        long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n        response.setHeader(\n                \"X-Rate-Limit-Retry-After-Seconds\",\n                Newlines.stripAll(String.valueOf(waitForRefill)));\n        response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "175", "src_id": "M1043", "code": "\nprivate void doPostprocessing() {\n    errCode = ERROR_NOTHING;\n    errObject = null;\n    Thread thread = Thread.currentThread();\n\n    notifyPostProcessing(1);\n\n    if (DEBUG) {\n        thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n    }\n\n    Exception exception = null;\n\n    try {\n        psAlgorithm.run(this);\n    } catch (Exception err) {\n        Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n        if (err instanceof InterruptedIOException \n                || err instanceof ClosedByInterruptException \n                || thread.isInterrupted()) {\n            notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n            return;\n        }\n\n        if (errCode == ERROR_NOTHING) {\n            errCode = ERROR_POSTPROCESSING;\n        }\n        exception = err;\n    } finally {\n        notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n    }\n\n    if (errCode != ERROR_NOTHING) {\n        if (exception == null) {\n            exception = errObject;\n        }\n        notifyError(ERROR_POSTPROCESSING, exception);\n        return;\n    }\n\n    notifyFinished();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "176", "src_id": "M1031", "code": "\n    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                // let the download thread handle this error\n                return;\n            default:\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "177", "src_id": "M827", "code": "\nprivate Elst parseEdts(Box ref) throws IOException {\n    Box box = untilBox(ref, ATOM_ELST);\n    if (box == null) {\n        return null;\n    }\n\n    Elst elst = new Elst();\n    boolean isVersion1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n    \n    int entryCount = stream.readInt();\n    if (entryCount < 1) {\n        elst.bMediaRate = 0x00010000; // default media rate (1.0)\n        return elst;\n    }\n\n    if (isVersion1) {\n        stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n        elst.mediaTime = stream.readLong();\n        // Ignore remaining entries\n        stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n    } else {\n        stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n        elst.mediaTime = stream.readInt();\n    }\n\n    elst.bMediaRate = stream.readInt();\n    return elst;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "178", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        long start = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n        try {\n            long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n            int id = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(id, mConn);\n\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n            mIs = mConn.getInputStream();\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n            dispose();\n            boolean done = len == -1;\n\n            if (done) {\n                mMission.notifyFinished();\n            } else {\n                mMission.fallbackResumeOffset = start;\n            }\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n\n            if (mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            if (e instanceof DownloadMission.HttpError \n                    && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n\n            run();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "179", "src_id": "M1141", "code": "\n    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n\n        out.flush();\n        aux.flush();\n\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long length = amount;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n        if (underflow) {\n            if (out.offset >= out.length) {\n                // calculate the aux underflow pointer\n                if (aux.offset < amount) {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } else {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                }\n            } else {\n                aux.offset = 0;\n            }\n        }\n\n        out.length += amount;\n\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n\n            aux.length -= amount;\n            length = aux.length;\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);// or setLength(0);\n        }\n\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "180", "src_id": "M1106", "code": "\nprivate void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n    StringBuilder request = new StringBuilder();\n    request.append(mission.source);\n    \n    request.append(\" [\");\n    if (mission.recoveryInfo != null) {\n        for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n            request.append(' ')\n                   .append(recovery.toString())\n                   .append(' ');\n        }\n    }\n    request.append(\"]\");\n    \n    String service;\n    try {\n        service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n    } catch (Exception e) {\n        service = ErrorInfo.SERVICE_NONE;\n    }\n    \n    ErrorUtil.createNotification(\n        mContext,\n        new ErrorInfo(\n            ErrorInfo.Companion.throwableToStringList(mission.errObject),\n            action,\n            service,\n            request.toString(),\n            reason\n        )\n    );\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "181", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n\n            boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "182", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n        if (format == null || format.equals(\"ttml\")) {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException ? 1 : 8;\n            }\n            return OK_RESULT;\n        } else if (format.equals(\"srt\")) {\n            byte[] buffer = new byte[8 * 1024];\n            int read;\n            while ((read = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, read);\n            }\n            return OK_RESULT;\n        }\n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "183", "src_id": "M1047", "code": "\nprivate void joinForThreads(int millis) {\n    Thread currentThread = Thread.currentThread();\n\n    if (init != null && init != currentThread && init.isAlive()) {\n        init.interrupt();\n\n        if (millis > 0) {\n            try {\n                init.join(millis);\n            } catch (InterruptedException e) {\n                Log.w(TAG, \"Initializer thread is still running\", e);\n                return;\n            }\n        }\n    }\n\n    // if a thread is still alive, possible reasons:\n    //      slow device\n    //      the user is spamming start/pause buttons\n    //      start() method called quickly after pause()\n\n    for (Thread thread : threads) {\n        if (!thread.isAlive() || thread == Thread.currentThread()) {\n            continue;\n        }\n        thread.interrupt();\n    }\n\n    try {\n        for (Thread thread : threads) {\n            if (!thread.isAlive()) {\n                continue;\n            }\n            if (DEBUG) {\n                Log.w(TAG, \"thread alive: \" + thread.getName());\n            }\n            if (millis > 0) {\n                thread.join(millis);\n            }\n        }\n    } catch (InterruptedException e) {\n        throw new RuntimeException(\"A download thread is still running\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "184", "src_id": "M95", "code": "\npublic static HealthCountsStream getInstance(HystrixCommandKey commandKey, int numBuckets, int bucketSizeInMs) {\n  HealthCountsStream initialStream = streams.get(commandKey.name());\n  if (initialStream != null) return initialStream;\n\n  final HealthCountsStream healthStream;\n  synchronized (HealthCountsStream.class) {\n    HealthCountsStream existingStream = streams.get(commandKey.name());\n    if (existingStream == null) {\n      HealthCountsStream newStream = new HealthCountsStream(commandKey, numBuckets, bucketSizeInMs,\n          HystrixCommandMetrics.appendEventToBucket);\n\n      streams.putIfAbsent(commandKey.name(), newStream);\n      healthStream = newStream;\n    } else {\n      healthStream = existingStream;\n    }\n  }\n\n  healthStream.startCachingStreamValuesIfUnstarted();\n  return healthStream;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "185", "src_id": "M118", "code": "\npublic Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {\n  final Map<CommandAndCacheKey, Integer> cachingDetector = new HashMap<>(executions.size(), 1f);\n  final List<HystrixInvokableInfo<?>> nonCachedExecutions = new ArrayList<>(executions.size());\n  \n  for (HystrixInvokableInfo<?> execution : executions) {\n    if (execution.getPublicCacheKey() != null) {\n      final CommandAndCacheKey key = new CommandAndCacheKey(\n          execution.getCommandKey().name(), execution.getPublicCacheKey());\n      cachingDetector.merge(key, 0, (oldValue, value) -> oldValue + 1);\n    }\n    \n    if (!execution.isResponseFromCache()) {\n      nonCachedExecutions.add(execution);\n    }\n  }\n\n  final Map<ExecutionSignature, List<Integer>> commandDeduper = new HashMap<>(nonCachedExecutions.size(), 1f);\n  for (HystrixInvokableInfo<?> execution : nonCachedExecutions) {\n    int cachedCount = 0;\n    final String cacheKey = execution.getPublicCacheKey();\n    \n    if (cacheKey != null) {\n      final CommandAndCacheKey key = new CommandAndCacheKey(\n          execution.getCommandKey().name(), cacheKey);\n      cachedCount = cachingDetector.get(key);\n    }\n\n    final ExecutionSignature signature = (cachedCount > 0)\n        ? ExecutionSignature.from(execution, cacheKey, cachedCount)\n        : ExecutionSignature.from(execution);\n\n    commandDeduper\n        .computeIfAbsent(signature, k -> new ArrayList<>())\n        .add(execution.getExecutionTimeInMilliseconds());\n  }\n\n  return commandDeduper;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "186", "src_id": "M223", "code": "\npublic ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties) {\n  final ThreadFactory threadFactory = getThreadFactory(threadPoolKey);\n\n  final boolean allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();\n  final int dynamicCoreSize = threadPoolProperties.coreSize().get();\n  final int keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();\n  final int maxQueueSize = threadPoolProperties.maxQueueSize().get();\n  final BlockingQueue<Runnable> workQueue = getBlockingQueue(maxQueueSize);\n\n  if (allowMaximumSizeToDivergeFromCoreSize) {\n    final int dynamicMaximumSize = threadPoolProperties.maximumSize().get();\n    if (dynamicCoreSize > dynamicMaximumSize) {\n      logger.error(\"Hystrix ThreadPool configuration at startup for : \" + threadPoolKey.name()\n          + \" is trying to set coreSize = \" + dynamicCoreSize\n          + \" and maximumSize = \" + dynamicMaximumSize\n          + \".  Maximum size will be set to \" + dynamicCoreSize\n          + \", the coreSize value, since it must be equal to or greater than the coreSize value\");\n      return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n    } else {\n      return new ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n    }\n  } else {\n    return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "187", "src_id": "M498", "code": "\nprotected static String convertToJson(HystrixUtilization utilization) throws IOException {\n  StringWriter jsonString = new StringWriter();\n  JsonGenerator json = jsonFactory.createGenerator(jsonString);\n\n  json.writeStartObject();\n  json.writeStringField(\"type\", \"HystrixUtilization\");\n  json.writeObjectFieldStart(\"commands\");\n  for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n    final HystrixCommandKey key = entry.getKey();\n    final HystrixCommandUtilization commandUtilization = entry.getValue();\n    writeCommandUtilizationJson(json, key, commandUtilization);\n  }\n  json.writeEndObject();\n\n  json.writeObjectFieldStart(\"threadpools\");\n  for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n    final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n    final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n    writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n  }\n  json.writeEndObject();\n  json.writeEndObject();\n  json.close();\n\n  return jsonString.getBuffer().toString();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "188", "src_id": "M171", "code": "\nEventCounts plus(HystrixEventType eventType, int count) {\n  BitSet newBitSet = (BitSet) events.clone();\n  int localNumEmits = numEmissions;\n  int localNumFallbackEmits = numFallbackEmissions;\n  int localNumCollapsed = numCollapsed;\n  switch (eventType) {\n    case EMIT:\n      newBitSet.set(HystrixEventType.EMIT.ordinal());\n      localNumEmits += count;\n      break;\n    case FALLBACK_EMIT:\n      newBitSet.set(HystrixEventType.FALLBACK_EMIT.ordinal());\n      localNumFallbackEmits += count;\n      break;\n    case COLLAPSED:\n      newBitSet.set(HystrixEventType.COLLAPSED.ordinal());\n      localNumCollapsed += count;\n      break;\n    default:\n      newBitSet.set(eventType.ordinal());\n      break;\n  }\n  return new EventCounts(newBitSet, localNumEmits, localNumFallbackEmits, localNumCollapsed);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "189", "src_id": "M448", "code": "\nprivate static void writeThreadPoolMetrics(HystrixThreadPoolMetrics threadPoolMetrics, JsonGenerator json) throws IOException {\n  HystrixThreadPoolKey key = threadPoolMetrics.getThreadPoolKey();\n\n  json.writeStartObject();\n\n  json.writeStringField(\"type\", \"HystrixThreadPool\");\n  json.writeStringField(\"name\", key.name());\n  json.writeNumberField(\"currentTime\", System.currentTimeMillis());\n\n  json.writeNumberField(\"currentActiveCount\", threadPoolMetrics.getCurrentActiveCount().intValue());\n  json.writeNumberField(\"currentCompletedTaskCount\", threadPoolMetrics.getCurrentCompletedTaskCount().longValue());\n  json.writeNumberField(\"currentCorePoolSize\", threadPoolMetrics.getCurrentCorePoolSize().intValue());\n  json.writeNumberField(\"currentLargestPoolSize\", threadPoolMetrics.getCurrentLargestPoolSize().intValue());\n  json.writeNumberField(\"currentMaximumPoolSize\", threadPoolMetrics.getCurrentMaximumPoolSize().intValue());\n  json.writeNumberField(\"currentPoolSize\", threadPoolMetrics.getCurrentPoolSize().intValue());\n  json.writeNumberField(\"currentQueueSize\", threadPoolMetrics.getCurrentQueueSize().intValue());\n  json.writeNumberField(\"currentTaskCount\", threadPoolMetrics.getCurrentTaskCount().longValue());\n  safelyWriteNumberField(json, \"rollingCountThreadsExecuted\",\n      () -> threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.EXECUTED));\n  json.writeNumberField(\"rollingMaxActiveThreads\", threadPoolMetrics.getRollingMaxActiveThreads());\n  safelyWriteNumberField(json, \"rollingCountCommandRejections\",\n      () -> threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.REJECTED));\n\n  json.writeNumberField(\"propertyValue_queueSizeRejectionThreshold\", threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());\n  json.writeNumberField(\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());\n\n  json.writeNumberField(\"reportingHosts\", 1); // this will get summed across all instances in a cluster\n\n  json.writeEndObject();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "190", "src_id": "M69", "code": "\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        final List<HystrixEventType> foundEventTypes = new ArrayList<>(ALL_EVENT_TYPES.size());\n\n        sb.append(getCommandKey().name()).append(\"[\");\n        for (final HystrixEventType eventType : ALL_EVENT_TYPES) {\n            if (executionResult.getEventCounts().contains(eventType)) {\n                foundEventTypes.add(eventType);\n            }\n        }\n        final Iterator<HystrixEventType> iterator = foundEventTypes.iterator();\n        while (iterator.hasNext()) {\n            final HystrixEventType eventType = iterator.next();\n            sb.append(eventType.name());\n            final int eventCount = executionResult.getEventCounts().getCount(eventType);\n            if (eventCount > 1) {\n                sb.append(\"x\").append(eventCount);\n            }\n            if (iterator.hasNext()) {\n                sb.append(\", \");\n            }\n        }\n        sb.append(\"][\").append(getExecutionLatency()).append(\" ms]\");\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "191", "src_id": "M52", "code": "\n@Override\npublic void run() {\n  while (true) {\n    // Since this is a simple example and we know the exact HystrixCommandKeys we are interested in\n    // we will retrieve the HystrixCommandMetrics objects directly.\n    //\n    // Typically you would instead retrieve metrics from where they are published which is by default\n    // done using Servo: https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring\n\n    try {\n      Thread.sleep(5000);\n    } catch (Exception e) {\n      // ignore\n    }\n\n    final HystrixCommandMetrics creditCardMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(CreditCardCommand.class.getSimpleName()));\n    final HystrixCommandMetrics orderMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetOrderCommand.class.getSimpleName()));\n    final HystrixCommandMetrics userAccountMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetUserAccountCommand.class.getSimpleName()));\n    final HystrixCommandMetrics paymentInformationMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetPaymentInformationCommand.class.getSimpleName()));\n\n    if (shouldLog) {\n      final StringBuilder out = new StringBuilder();\n      out.append(\"\\n\");\n      out.append(\"#####################################################################################\").append(\"\\n\");\n      out.append(\"# CreditCardCommand: \").append(getStatsStringFromMetrics(creditCardMetrics)).append(\"\\n\");\n      out.append(\"# GetOrderCommand: \").append(getStatsStringFromMetrics(orderMetrics)).append(\"\\n\");\n      out.append(\"# GetUserAccountCommand: \").append(getStatsStringFromMetrics(userAccountMetrics)).append(\"\\n\");\n      out.append(\"# GetPaymentInformationCommand: \").append(getStatsStringFromMetrics(paymentInformationMetrics)).append(\"\\n\");\n      out.append(\"#####################################################################################\").append(\"\\n\");\n      System.out.println(out.toString());\n    }\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "192", "src_id": "M312", "code": "\nprivate Observable<R> handleRequestCacheHitAndEmitValues(final HystrixCommandResponseFromCache<R> fromCache, final AbstractCommand<R> _cmd) {\n  try {\n    executionHook.onCacheHit(this);\n  } catch (Throwable hookEx) {\n    logger.warn(\"Error calling HystrixCommandExecutionHook.onCacheHit\", hookEx);\n  }\n\n  return fromCache.toObservableWithStateCopiedInto(this)\n    .doOnTerminate(new Action0() {\n      @Override\n      public void call() {\n        if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) {\n          cleanUpAfterResponseFromCache(false); //user code never ran\n        } else if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) {\n          cleanUpAfterResponseFromCache(true); //user code did run\n        }\n      }\n    })\n    .doOnUnsubscribe(new Action0() {\n      @Override\n      public void call() {\n        if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) {\n          cleanUpAfterResponseFromCache(false); //user code never ran\n        } else if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.UNSUBSCRIBED)) {\n          cleanUpAfterResponseFromCache(true); //user code did run\n        }\n      }\n    });\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "193", "src_id": "M438", "code": "\nprivate static void serializeUtilization(HystrixUtilization utilization, JsonGenerator json) {\n  try {\n    json.writeStartObject();\n    json.writeStringField(\"type\", \"HystrixUtilization\");\n    json.writeObjectFieldStart(\"commands\");\n    for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n      final HystrixCommandKey key = entry.getKey();\n      final HystrixCommandUtilization commandUtilization = entry.getValue();\n      writeCommandUtilizationJson(json, key, commandUtilization);\n    }\n    json.writeEndObject();\n    json.writeObjectFieldStart(\"threadpools\");\n    for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n      final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n      final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n      writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n    }\n    json.writeEndObject();\n    json.writeEndObject();\n    json.close();\n  } catch (Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "194", "src_id": "M1043", "code": "\n    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        final Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (final Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n\n            // Check if the error is due to thread interruption\n            if (err instanceof InterruptedIOException \n                    || err instanceof ClosedByInterruptException \n                    || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return; // exit early on interruption\n            }\n\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n\n            exception = err;\n        } finally {\n            final int status = errCode == ERROR_NOTHING ? 2 : 0;\n            notifyPostProcessing(status);\n        }\n\n        // If there was an error (and not due to interruption, which returns above)\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "195", "src_id": "M1031", "code": "\n    void establishConnection(final int threadId, final HttpURLConnection conn) throws IOException, HttpError {\n        final int statusCode = conn.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, \"establishConnection(): [threadId=\" + threadId + \"] [request] Range=[\" + conn.getRequestProperty(\"Range\") + \"]\");\n            Log.d(TAG, \"establishConnection(): [threadId=\" + threadId + \"] [response] Code=[\" + statusCode + \"]\");\n            Log.d(TAG, \"establishConnection(): [threadId=\" + threadId + \"] [response] Content-Length=[\" + conn.getContentLength() + \"]\");\n            Log.d(TAG, \"establishConnection(): [threadId=\" + threadId + \"] [response] Content-Range=[\" + conn.getHeaderField(\"Content-Range\") + \"]\");\n        }\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // let the download thread handle this error\n            default:\n                // Handle non-success status codes\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "196", "src_id": "M827", "code": "\nprivate Elst parseEdts(final Box ref) throws IOException {\n    final Box b = untilBox(ref, ATOM_ELST);\n    if (b == null) {\n        return null;\n    }\n\n    final Elst obj = new Elst();\n\n    final boolean v1 = stream.read() == 1;\n    stream.skipBytes(3); // flags\n\n    final int entryCount = stream.readInt();\n    if (entryCount < 1) {\n        obj.bMediaRate = 0x00010000; // default media rate (1.0)\n        return obj;\n    }\n\n    if (v1) {\n        stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n        obj.mediaTime = stream.readLong();\n        // ignore all remain entries\n        stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n    } else {\n        stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n        obj.mediaTime = stream.readInt();\n    }\n\n    obj.bMediaRate = stream.readInt();\n\n    return obj;\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "197", "src_id": "M1048", "code": "\n    @Override\n    public void run() {\n        if (DEBUG) {\n            Log.d(TAG, \"run() called; starting at offset: \" + mMission.fallbackResumeOffset);\n        }\n\n        long start = mMission.fallbackResumeOffset;\n        // Tracks completion status for notification\n        boolean done = false;\n\n        try {\n            // Determine range start based on mission parameters\n            final long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n\n            if (DEBUG && !mMission.unknownLength && start > 0) {\n                Log.i(TAG, \"Resuming single-thread download at \" + start);\n            }\n\n            final int mId = 1;\n            final HttpURLConnection mConn = mMission.openConnection(false, rangeStart, -1);\n\n            // Bypass Android connection pool for initial requests\n            if (mRetryCount == 0 && rangeStart == -1) {\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n\n            // Handle HTTP 416 (Range Not Satisfiable) for resumable downloads\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // Verify content length availability\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            // Reset download counter for new connections\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            final RandomAccessFile mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n\n            final InputStream mIs = mConn.getInputStream();\n            final byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n\n            // Main download loop\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n            dispose();\n            done = len == -1;  // Set completion status\n\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n\n            // Handle termination cases\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n\n            // Handle expired URLs (e.g., YouTube streams)\n            if (e instanceof DownloadMission.HttpError \n                    && ((DownloadMission.HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n\n            // Retry or notify on failure\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n\n            if (DEBUG) {\n                Log.e(TAG, \"Exception occurred, retrying...\", e);\n            }\n\n            run();  // Attempt retry\n            return;\n        }\n\n        // Final state handling\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "198", "src_id": "M1141", "code": "\nprivate void flushAuxiliar(long amount) throws IOException {\n    if (aux.length < 1) {\n        return;\n    }\n\n    out.flush();\n    aux.flush();\n\n    final boolean underflow = aux.offset < aux.length || out.offset < out.length;\n    final byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n    aux.target.seek(0);\n    out.target.seek(out.length);\n\n    long length = amount;\n    while (length > 0) {\n        int read = (int) Math.min(length, Integer.MAX_VALUE);\n        read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n        if (read < 1) {\n            amount -= length;\n            break;\n        }\n\n        out.writeProof(buffer, read);\n        length -= read;\n    }\n\n    if (underflow) {\n        if (out.offset >= out.length) {\n            // Calculate auxiliary underflow pointer\n            if (aux.offset < amount) {\n                out.offset += aux.offset;\n                aux.offset = 0;\n                out.target.seek(out.offset);\n            } else {\n                aux.offset -= amount;\n                out.offset = out.length + amount;\n            }\n        } else {\n            aux.offset = 0;\n        }\n    } else {\n        out.offset += amount;\n        aux.offset -= amount;\n    }\n\n    out.length += amount;\n\n    if (out.length > maxLengthKnown) {\n        maxLengthKnown = out.length;\n    }\n\n    if (amount < aux.length) {\n        // Move excess data to file beginning\n        long readOffset = amount;\n        long writeOffset = 0;\n        \n        aux.length -= amount;\n        length = aux.length;\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n            \n            aux.target.seek(writeOffset);\n            aux.writeProof(buffer, read);\n            \n            writeOffset += read;\n            readOffset += read;\n            length -= read;\n            \n            aux.target.seek(readOffset);\n        }\n        \n        aux.target.setLength(aux.length);\n        return;\n    }\n\n    if (aux.length > THRESHOLD_AUX_LENGTH) {\n        aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0)\n    }\n    \n    aux.reset();\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "199", "src_id": "M1106", "code": "\n    private void showError(final DownloadMission mission, final UserAction action,\n            @StringRes final int reason) {\n        if (DEBUG) {\n            Log.d(TAG, \"showError() called with: mission source=[\" + mission.source \n                    + \"], action=[\" + action + \"], reason=[\" + reason + \"]\");\n        }\n\n        final StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n        request.append(\" [\");\n\n        if (mission.recoveryInfo != null) {\n            for (final MissionRecoveryInfo recovery : mission.recoveryInfo) {\n                request.append(' ')\n                        .append(recovery.toString())\n                        .append(' ');\n            }\n        }\n        request.append(\"]\");\n\n        final String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (final Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        final List<String> errorList = ErrorInfo.Companion.throwableToStringList(mission.errObject);\n        final ErrorInfo errorInfo = new ErrorInfo(errorList, action, service, request.toString(), reason);\n\n        ErrorUtil.createNotification(mContext, errorInfo);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1067", "code": "\n    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n\n            // Create metadata file with unique timestamp\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Persist metadata before proceeding\n            Utility.writeToFile(mission.metadata, mission);\n\n            // Validate storage availability\n            if (mission.storage == null) {\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n                return;\n            }\n\n            final boolean shouldStart = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n\n            // Initiate download if conditions met\n            if (canDownloadInCurrentNetwork() && shouldStart) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1136", "code": "\n    @Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n        if (format == null || format.equals(\"ttml\")) {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException ? 1 : 8;\n            }\n\n            return OK_RESULT;\n        } else if (format.equals(\"srt\")) {\n            byte[] buffer = new byte[8 * 1024];\n            int read;\n            while ((read = sources[0].read(buffer)) > 0) {\n                out.write(buffer, 0, read);\n            }\n            return OK_RESULT;\n        }\n\n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "202", "src_id": "M1047", "code": "\nprivate void joinForThreads(final int millis) {\n    if (DEBUG) {\n        Log.d(TAG, \"joinForThreads() called with: millis = [\" + millis + \"]\");\n    }\n\n    final Thread currentThread = Thread.currentThread();\n\n    if (init != null && init != currentThread && init.isAlive()) {\n        init.interrupt();\n\n        if (millis > 0) {\n            try {\n                init.join(millis);\n            } catch (InterruptedException e) {\n                Log.w(TAG, \"Initializer thread is still running\", e);\n                return;\n            }\n        }\n    }\n\n    // if a thread is still alive, possible reasons:\n    //     slow device\n    //     the user is spamming start/pause buttons\n    //     start() method called quickly after pause()\n\n    for (Thread thread : threads) {\n        if (!thread.isAlive() || thread == Thread.currentThread()) {\n            continue;\n        }\n        thread.interrupt();\n    }\n\n    try {\n        for (Thread thread : threads) {\n            if (!thread.isAlive()) {\n                continue;\n            }\n            if (DEBUG) {\n                Log.d(TAG, \"thread alive: \" + thread.getName());\n            }\n            if (millis > 0) {\n                thread.join(millis);\n            }\n        }\n    } catch (InterruptedException e) {\n        throw new RuntimeException(\"A download thread is still running\", e);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "203", "src_id": "M491", "code": "\n@SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n@ResizeMode\npublic static int nextResizeModeAndSaveToPrefs(Player player,\n        @ResizeMode int resizeMode) {\n    int newResizeMode;\n    switch (resizeMode) {\n        case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n            break;\n        case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n        default:\n            newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n            break;\n    }\n\n    // save the new resize mode so it can be restored in a future session\n    player.getPrefs().edit()\n        .putInt(\n            player.getContext().getString(R.string.last_resize_mode),\n            newResizeMode\n        )\n        .apply();\n    return newResizeMode;\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "204", "src_id": "M424", "code": "\n    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        String action = intent.getAction();\n        if (action == null) {\n            return;\n        }\n        switch (action) {\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                // Close it because when changing orientation from portrait\n                // (in fullscreen mode) the size of queue layout can be larger than the screen size\n                closeItemsList();\n                break;\n            case ACTION_PLAY_PAUSE:\n                // Ensure that we have audio-only stream playing when a user\n                // started to play from notification's play button from outside of the app\n                if (!fragmentIsVisible) {\n                    onFragmentStopped();\n                }\n                break;\n            case VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED:\n                fragmentIsVisible = false;\n                onFragmentStopped();\n                break;\n            case VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED:\n                // Restore video source when user returns to the fragment\n                fragmentIsVisible = true;\n                player.useVideoSource(true);\n\n                // When a user returns from background, the system UI will always be shown even if\n                // controls are invisible: hide it in that case\n                if (!isControlsVisible()) {\n                    hideSystemUIIfNeeded();\n                }\n                break;\n            default:\n                // Unhandled action\n                break;\n        }\n    }\n\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "205", "src_id": "M900", "code": "\n    @StyleRes\n    public static int getSettingsThemeStyle(Context context) {\n        Resources res = context.getResources();\n        String lightTheme = res.getString(R.string.light_theme_key);\n        String blackTheme = res.getString(R.string.black_theme_key);\n        String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        String selectedTheme = getSelectedThemeKey(context);\n\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else if (selectedTheme.equals(blackTheme)) {\n            return R.style.BlackSettingsTheme;\n        } else if (selectedTheme.equals(automaticDeviceTheme)) {\n            if (!isDeviceDarkThemeEnabled(context)) {\n                // Single day theme\n                return R.style.LightSettingsTheme;\n            }\n            // User's preferred dark theme variant\n            String selectedNightTheme = getSelectedNightThemeKey(context);\n            if (selectedNightTheme.equals(blackTheme)) {\n                return R.style.BlackSettingsTheme;\n            }\n            return R.style.DarkSettingsTheme;\n        } else {\n            // Default theme\n            return R.style.DarkSettingsTheme;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "206", "src_id": "M895", "code": "\n@Override\npublic Bitmap transform(Bitmap source) {\n    if (DEBUG) {\n        Log.d(TAG, \"Thumbnail - transform() called\");\n    }\n\n    float notificationThumbnailWidth = Math.min(\n        context.getResources().getDimension(R.dimen.player_notification_thumbnail_width),\n        source.getWidth()\n    );\n\n    Bitmap result = BitmapCompat.createScaledBitmap(\n        source,\n        (int) notificationThumbnailWidth,\n        (int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)),\n        null,\n        true\n    );\n\n    if (result == source || !result.isMutable()) {\n        Bitmap copied = BitmapCompat.createScaledBitmap(\n            source,\n            (int) notificationThumbnailWidth - 1,\n            (int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))),\n            null,\n            true\n        );\n        source.recycle();\n        return copied;\n    } else {\n        source.recycle();\n        return result;\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "207", "src_id": "M225", "code": "\nprivate void onBroadcastReceived(Intent intent) {\n    if (intent == null || intent.getAction() == null) {\n        return;\n    }\n\n    if (DEBUG) {\n        Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n    }\n\n    switch (intent.getAction()) {\n        case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n            pause();\n            break;\n        case ACTION_CLOSE:\n            service.destroyPlayerAndStopService();\n            break;\n        case ACTION_PLAY_PAUSE:\n            playPause();\n            break;\n        case ACTION_PLAY_PREVIOUS:\n            playPrevious();\n            break;\n        case ACTION_PLAY_NEXT:\n            playNext();\n            break;\n        case ACTION_FAST_REWIND:\n            fastRewind();\n            break;\n        case ACTION_FAST_FORWARD:\n            fastForward();\n            break;\n        case ACTION_REPEAT:\n            cycleNextRepeatMode();\n            break;\n        case ACTION_SHUFFLE:\n            toggleShuffleModeEnabled();\n            break;\n        case Intent.ACTION_CONFIGURATION_CHANGED:\n            if (DEBUG) {\n                Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n            }\n            break;\n    }\n\n    UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "208", "src_id": "M749", "code": "\nprivate static void handleError(Context context, ErrorInfo errorInfo) {\n    if (errorInfo.getThrowable() != null) {\n        errorInfo.getThrowable().printStackTrace();\n    }\n\n    if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n        Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n        // Starting ReCaptcha Challenge Activity\n        Intent intent = new Intent(context, ReCaptchaActivity.class);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        context.startActivity(intent);\n    } else if (errorInfo.getThrowable() != null\n            && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n        Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n        Toast.makeText(context, R.string.restricted_video_no_stream,\n                Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n        Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof PaidContentException) {\n        Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof PrivateContentException) {\n        Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n        Toast.makeText(context, R.string.soundcloud_go_plus_content,\n                Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n        Toast.makeText(context, R.string.youtube_music_premium_content,\n                Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) {\n        Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n    } else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n        Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n    } else {\n        ErrorUtil.createNotification(context, errorInfo);\n    }\n\n    if (context instanceof RouterActivity) {\n        ((RouterActivity) context).finish();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "209", "src_id": "M999", "code": "\npublic static void openVideoDetailFragment(@NonNull Context context,\n        @NonNull FragmentManager fragmentManager,\n        int serviceId,\n        @Nullable String url,\n        @NonNull String title,\n        @Nullable PlayQueue playQueue,\n        boolean switchingPlayers) {\n\n    boolean autoPlay;\n    @Nullable PlayerType playerType = PlayerHolder.getInstance().getType();\n    if (playerType == null) {\n        autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n    } else if (switchingPlayers) {\n        autoPlay = PlayerHolder.getInstance().isPlaying();\n    } else if (playerType == PlayerType.MAIN) {\n        autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n    } else {\n        autoPlay = false;\n    }\n\n    RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n        expandMainPlayer(detailFragment.requireActivity());\n        detailFragment.setAutoPlay(autoPlay);\n        if (switchingPlayers) {\n            detailFragment.openVideoPlayer(playerType == PlayerType.POPUP\n                    || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n        } else {\n            detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n        }\n        detailFragment.scrollToTop();\n    };\n\n    Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n    if (fragment instanceof VideoDetailFragment && fragment.isVisible()) {\n        onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);\n    } else {\n        VideoDetailFragment instance = VideoDetailFragment\n                .getInstance(serviceId, null, title, playQueue);\n        instance.setAutoPlay(autoPlay);\n\n        defaultTransaction(fragmentManager)\n                .replace(R.id.fragment_player_holder, instance)\n                .runOnCommit(() -> onVideoDetailFragmentReady.run(instance))\n                .commit();\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "210", "src_id": "M698", "code": "\n@Override\npublic void handleResult(@NonNull final ChannelInfo result) {\n    super.handleResult(result);\n    currentInfo = result;\n    setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n    if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n        PicassoHelper.loadBanner(result.getBanners())\n            .tag(PICASSO_CHANNEL_TAG)\n            .into(binding.channelBannerImage);\n    } else {\n        binding.channelBannerImage.setImageDrawable(null);\n    }\n\n    PicassoHelper.loadAvatar(result.getAvatars())\n        .tag(PICASSO_CHANNEL_TAG)\n        .into(binding.channelAvatarView);\n    PicassoHelper.loadAvatar(result.getParentChannelAvatars())\n        .tag(PICASSO_CHANNEL_TAG)\n        .into(binding.subChannelAvatarView);\n\n    binding.channelTitleView.setText(result.getName());\n    binding.channelSubscriberView.setVisibility(View.VISIBLE);\n    if (result.getSubscriberCount() >= 0) {\n        binding.channelSubscriberView.setText(\n            Localization.shortSubscriberCount(activity, result.getSubscriberCount())\n        );\n    } else {\n        binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n    }\n\n    if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n        binding.subChannelTitleView.setText(\n            String.format(\n                getString(R.string.channel_created_by),\n                currentInfo.getParentChannelName()\n            )\n        );\n        binding.subChannelTitleView.setVisibility(View.VISIBLE);\n        binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n    }\n\n    updateRssButton();\n\n    channelContentNotSupported = false;\n    for (final Throwable throwable : result.getErrors()) {\n        if (throwable instanceof ContentNotSupportedException) {\n            channelContentNotSupported = true;\n            showContentNotSupportedIfNeeded();\n            break;\n        }\n    }\n\n    disposables.clear();\n    if (subscribeButtonMonitor != null) {\n        subscribeButtonMonitor.dispose();\n    }\n\n    updateTabs();\n    updateSubscription(result);\n    monitorSubscription(result);\n}\n", "compilable": "", "test_passed": "", "successful_trans": true}
{"project_name": "across-project", "pair_id": "211", "src_id": "M379", "code": "\n@Override\npublic void onTextTracksChanged(@NonNull Tracks currentTracks) {\n    super.onTextTracksChanged(currentTracks);\n\n    boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT)\n        || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n    if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n        || !trackTypeTextSupported) {\n        binding.captionTextView.setVisibility(View.GONE);\n        return;\n    }\n\n    // Extract all loaded languages\n    List<Tracks.Group> textTracks = currentTracks\n        .getGroups()\n        .stream()\n        .filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType())\n        .collect(Collectors.toList());\n    List<String> availableLanguages = textTracks.stream()\n        .map(Tracks.Group::getMediaTrackGroup)\n        .filter(textTrack -> textTrack.length > 0)\n        .map(textTrack -> textTrack.getFormat(0).language)\n        .collect(Collectors.toList());\n\n    // Find selected text track\n    Optional<Format> selectedTracks = textTracks.stream()\n        .filter(Tracks.Group::isSelected)\n        .filter(info -> info.getMediaTrackGroup().length >= 1)\n        .map(info -> info.getMediaTrackGroup().getFormat(0))\n        .findFirst();\n\n    // Build UI\n    buildCaptionMenu(availableLanguages);\n    if (player.getTrackSelector()\n        .getParameters()\n        .getRendererDisabled(player.getCaptionRendererIndex())\n        || selectedTracks.isEmpty()) {\n        binding.captionTextView.setText(R.string.caption_none);\n    } else {\n        binding.captionTextView.setText(selectedTracks.get().language);\n    }\n    binding.captionTextView.setVisibility(availableLanguages.isEmpty()\n        ? View.GONE\n        : View.VISIBLE);\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "212", "src_id": "M894", "code": "\npublic static RequestCreator loadScaledDownThumbnail(final Context context,\n    @NonNull final List<Image> images) {\n    return PicassoHelper.loadThumbnail(images)\n        .transform(new Transformation() {\n            @Override\n            public Bitmap transform(final Bitmap source) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n                }\n\n                final float notificationThumbnailWidth = Math.min(\n                    context.getResources()\n                        .getDimension(R.dimen.player_notification_thumbnail_width),\n                    source.getWidth());\n                final Bitmap result = BitmapCompat.createScaledBitmap(\n                    source,\n                    (int) notificationThumbnailWidth,\n                    (int) (source.getHeight() \n                        / (source.getWidth() / notificationThumbnailWidth)),\n                    null,\n                    true);\n\n                if (result == source || !result.isMutable()) {\n                    // create a new mutable bitmap to prevent crashes on some devices\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(\n                        source,\n                        (int) notificationThumbnailWidth - 1,\n                        (int) (source.getHeight() \n                            / (source.getWidth() / (notificationThumbnailWidth - 1))),\n                        null,\n                        true);\n                    source.recycle();\n                    return copied;\n                } else {\n                    source.recycle();\n                    return result;\n                }\n            }\n\n            @Override\n            public String key() {\n                return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n            }\n        });\n}\n", "compilable": "", "test_passed": "", "successful_trans": false}
{"project_name": "across-project", "pair_id": "44", "src_id": "M1131", "code": "\nprivate static Object process(final RedisInputStream is) {\n    final byte b = is.readByte();\n    // System.out.println(\"BYTE: \" + (char) b);\n    switch (b) {\n        case PLUS_BYTE:\n            return is.readLineBytes();\n        case DOLLAR_BYTE:\n        case EQUAL_BYTE:\n            return processBulkReply(is);\n        case ASTERISK_BYTE:\n            return processMultiBulkReply(is);\n        case UNDERSCORE_BYTE:\n            return is.readNullCrLf();\n        case HASH_BYTE:\n            return is.readBooleanCrLf();\n        case COLON_BYTE:\n            return is.readLongCrLf();\n        case COMMA_BYTE:\n            return is.readDoubleCrLf();\n        case LEFT_BRACE_BYTE:\n            return is.readBigIntegerCrLf();\n        case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n            return processMapKeyValueReply(is);\n        case TILDE_BYTE: // TODO:\n            return processMultiBulkReply(is);\n        case GREATER_THAN_BYTE:\n            return processMultiBulkReply(is);\n        case MINUS_BYTE:\n            processError(is);\n            return null;\n        // TODO: Blob error '!'\n        default:\n            throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n    }\n}\n", "compilable": "", "test_passed": "", "successful_trans": ""}

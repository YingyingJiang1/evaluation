{"project_name": "across-project", "pair_id": "18", "src_id": "M342", "code": "        private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n            if (emlBytes==null||emlBytes.length==0) {\n                throw new IllegalArgumentException(\"EML file is empty or null\");\n            }\n            String emlContent=new String(emlBytes, StandardCharsets.UTF_8);\n            // Basic email parsing\n            String subject=extractBasicHeader(emlContent, \"Subject:\");\n            String from=extractBasicHeader(emlContent, \"From:\");\n            String to=extractBasicHeader(emlContent, \"To:\");\n            String cc=extractBasicHeader(emlContent, \"Cc:\");\n            String bcc=extractBasicHeader(emlContent, \"Bcc:\");\n            String date=extractBasicHeader(emlContent, \"Date:\");\n            // Try to extract HTML content\n            String htmlBody=extractHtmlBody(emlContent);\n            if (htmlBody==null) {\n                String textBody=extractTextBody(emlContent);\n                htmlBody =\n                convertTextToHtml(textBody!=null ? textBody : \"Email content could not be parsed\");\n            }\n            // Generate HTML with custom styling based on request\n            StringBuilder html=new StringBuilder();\n            html.append(\"<!DOCTYPE html>\\n\");\n            html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n            html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n            html.append(\"<style>\\n\");\n            appendEnhancedStyles(html);\n            html.append(\"</style>\\n\");\n            html.append(\"</head><body>\\n\");\n            html.append(\"<div class=\\\"email-container\\\">\\n\");\n            html.append(\"<div class=\\\"email-header\\\">\\n\");\n            html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n            html.append(\"<div class=\\\"email-meta\\\">\\n\");\n            html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n            html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n            // Include CC and BCC if present and requested\n            if (request!=null&&request.isIncludeAllRecipients()) {\n                if (!cc.trim().isEmpty()) {\n                    html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n                }\n                if (!bcc.trim().isEmpty()) {\n                    html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n                }\n            }\n            if (!date.trim().isEmpty()) {\n                html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n            }\n            html.append(\"</div></div>\\n\");\n            html.append(\"<div class=\\\"email-body\\\">\\n\");\n            html.append(processEmailHtmlBody(htmlBody));\n            html.append(\"</div>\\n\");\n            // Add attachment information - always check for and display attachments\n            String attachmentInfo=extractAttachmentInfo(emlContent);\n\n            if (!attachmentInfo.isEmpty()) {\n                html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n                html.append(\"<h3>Attachments</h3>\\n\");\n                html.append(attachmentInfo);\n                // Add a status message about attachment inclusion\n                if (request!=null&&request.isIncludeAttachments()) {\n                    html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                    html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n\n                    html.append(\"</div>\\n\");\n                } else {\n\n                    html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n\n                    html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                    html.append(\"</div>\\n\");\n                }\n                html.append(\"</div>\\n\");\n            }\n\n            // Show advanced features status if requested\n            assert request!=null;\n            if (request.getFileInput().isEmpty()) {\n                html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n                html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n\n                html.append(\"</div>\\n\");\n            }\n\n            html.append(\"</div>\\n\");\n            html.append(\"</body></html>\");\n            return html.toString();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "19", "src_id": "M371", "code": "        private static boolean isValidJakartaMailMultipart(Object multipart) {\n            if (multipart==null) {\n                return false;\n            }\n            try {\n                // Check if the object implements jakarta.mail.Multipart interface\n                Class<?> multipartInterface=Class.forName(\"jakarta.mail.Multipart\");\n                if (!multipartInterface.isInstance(multipart)) {\n                    return false;\n                }\n                // Additional check for MimeMultipart\n                try {\n                    Class<?> mimeMultipartClass=Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                    if (mimeMultipartClass.isInstance(multipart)) {\n                        log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                        return true;\n                    }\n                } catch (ClassNotFoundException e) {\n                    log.debug(\"MimeMultipart not available, using base Multipart interface\");\n                }\n                return true;\n            } catch (ClassNotFoundException e) {\n                log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n                return false;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "20", "src_id": "M348", "code": "        private static String extractBasicHeader(String emlContent, String headerName) {\n            try {\n                String[] lines=emlContent.split(\"\\r?\\n\");\n                for (int i=0; i<lines.length; i++) {\n                    String line=lines[i];\n                    if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n\n\n                        StringBuilder value=new StringBuilder(line.substring(headerName.length()).trim());\n\n                        // Handle multi-line headers\n                        for (int j=i+1; j<lines.length; j++) {\n                            if (lines[j].startsWith(\" \")||lines[j].startsWith(\"\\t\")) {\n                                value.append(\" \").append(lines[j].trim());\n                            } else {\n                                break;\n                            }\n                        }\n                        // Apply MIME header decoding\n                        return safeMimeDecode(value.toString());\n\n                    }\n                    if (line.trim().isEmpty()) {\n                        break;\n                    }\n                }\n            } catch (RuntimeException e) {\n                log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n            }\n            return \"\";\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "21", "src_id": "M364", "code": "        private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n            if (document.getNumberOfPages()==0||attachments==null||attachments.isEmpty()) {\n                return;\n            }\n            // 1. Find the screen position of all attachment markers\n            AttachmentMarkerPositionFinder finder=new AttachmentMarkerPositionFinder();\n            finder.setSortByPosition(true); // Process pages in order\n            finder.getText(document);\n            List<MarkerPosition> markerPositions=finder.getPositions();\n            // 2. Warn if the number of markers and attachments don't match\n            if (markerPositions.size()!=attachments.size()) {\n                log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n            }\n            // 3. Create an invisible annotation over each found marker\n            int annotationsToAdd=Math.min(markerPositions.size(), attachments.size());\n            for (int i=0; i<annotationsToAdd; i++) {\n                MarkerPosition position=markerPositions.get(i);\n                EmailAttachment attachment=attachments.get(i);\n\n                if (attachment.getEmbeddedFilename()!=null) {\n                    PDPage page=document.getPage(position.getPageIndex());\n                    addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "122", "src_id": "M95", "code": "    public static HealthCountsStream getInstance(HystrixCommandKey commandKey, int numBuckets, int bucketSizeInMs) {\n        HealthCountsStream initialStream = streams.get(commandKey.name());\n        if (initialStream != null) {\n            return initialStream;\n        } else {\n            final HealthCountsStream healthStream;\n\n            synchronized (HealthCountsStream.class) {\n                HealthCountsStream existingStream = streams.get(commandKey.name());\n                if (existingStream != null) {\n                    healthStream = existingStream;\n                } else {\n                    HealthCountsStream newStream = new HealthCountsStream(commandKey, numBuckets, bucketSizeInMs, HystrixCommandMetrics.appendEventToBucket);\n                    streams.putIfAbsent(commandKey.name(), newStream);\n                    healthStream = newStream;\n                } \n            }\n            healthStream.startCachingStreamValuesIfUnstarted();\n            return healthStream;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "123", "src_id": "M118", "code": "    public Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {\n        Map<CommandAndCacheKey, Integer> cachingDetector = new HashMap<CommandAndCacheKey, Integer>();\n        List<HystrixInvokableInfo<?>> nonCachedExecutions = new ArrayList<HystrixInvokableInfo<?>>(executions.size());\n        for (HystrixInvokableInfo<?> execution : executions) {\n            if (execution.getPublicCacheKey() != null) {\n                //eligible for caching - might be the initial, or might be from cache\n                CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), execution.getPublicCacheKey());\n\n                Integer count = cachingDetector.get(key);\n                if (count != null) {\n                    //key already seen\n                    cachingDetector.put(key, count + 1);\n                } else {\n                    //key not seen yet\n                    cachingDetector.put(key, 0);\n                }\n            }\n            if (!execution.isResponseFromCache()) {\n                nonCachedExecutions.add(execution);\n            }\n        }\n\n        Map<ExecutionSignature, List<Integer>> commandDeduper = new HashMap<ExecutionSignature, List<Integer>>();\n        for (HystrixInvokableInfo<?> execution : nonCachedExecutions) {\n            int cachedCount = 0;\n            String cacheKey = execution.getPublicCacheKey();\n            if (cacheKey != null) {\n                CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), cacheKey);\n\n                cachedCount = cachingDetector.get(key);\n            }\n            ExecutionSignature signature = cachedCount > 0 ? ExecutionSignature.from(execution, cacheKey, cachedCount) : ExecutionSignature.from(execution); \n\n            List<Integer> currentLatencyList = commandDeduper.get(signature);\n            if (currentLatencyList != null) {\n                currentLatencyList.add(execution.getExecutionTimeInMilliseconds());\n            } else {\n                List<Integer> newLatencyList = new ArrayList<Integer>();\n                newLatencyList.add(execution.getExecutionTimeInMilliseconds());\n\n                commandDeduper.put(signature, newLatencyList);\n            }\n        }\n\n        return commandDeduper;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "124", "src_id": "M223", "code": "    public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties) {\n        final ThreadFactory threadFactory = getThreadFactory(threadPoolKey);\n        final boolean allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();\n        final int dynamicCoreSize = threadPoolProperties.coreSize().get();\n        final int keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();\n        final int maxQueueSize = threadPoolProperties.maxQueueSize().get();\n        final BlockingQueue<Runnable> workQueue = getBlockingQueue(maxQueueSize);\n\n        if (!allowMaximumSizeToDivergeFromCoreSize) {\n            return new ThreadPoolExecutor(\n            dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n        } else {\n            final int dynamicMaximumSize = threadPoolProperties.maximumSize().get();\n            if (dynamicCoreSize <= dynamicMaximumSize) {\n                return new ThreadPoolExecutor(\n                dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n            } else {\n                logger.error(\"Hystrix ThreadPool configuration at startup for : \" + threadPoolKey.name() + \" is trying to set coreSize = \" + dynamicCoreSize + \" and maximumSize = \" + dynamicMaximumSize + \".  Maximum size will be set to \" + dynamicCoreSize + \", the coreSize value, since it must be equal to or greater than the coreSize value\");\n                return new ThreadPoolExecutor(\n                dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n            } \n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "125", "src_id": "M498", "code": "    protected static String convertToJson(HystrixUtilization utilization) throws IOException {\n        StringWriter jsonString = new StringWriter();\n        JsonGenerator json = jsonFactory.createGenerator(jsonString);\n        json.writeStartObject();\n\n        json.writeStringField(\"type\", \"HystrixUtilization\");\n        json.writeObjectFieldStart(\"commands\");\n        for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n            final HystrixCommandKey key = entry.getKey();\n            final HystrixCommandUtilization commandUtilization = entry.getValue();\n            writeCommandUtilizationJson(json, key, commandUtilization);\n        }\n        json.writeEndObject();\n        json.writeObjectFieldStart(\"threadpools\");\n\n        for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n            final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n            final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n            writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n        }\n\n        json.writeEndObject();\n\n        json.writeEndObject();\n\n        json.close();\n        return jsonString.getBuffer().toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "126", "src_id": "M171", "code": "    EventCounts plus(HystrixEventType eventType, int count) {\n        BitSet newBitSet = (BitSet) events.clone();\n        int localNumEmits = numEmissions;\n        int localNumFallbackEmits =  numFallbackEmissions;\n\n        int localNumCollapsed = numCollapsed;\n\n        switch (eventType) {\n            case EMIT:\n                newBitSet.set(HystrixEventType.EMIT.ordinal());\n\n                localNumEmits += count;\n\n                break;\n            case FALLBACK_EMIT:\n                newBitSet.set(HystrixEventType.FALLBACK_EMIT.ordinal());\n\n                localNumFallbackEmits += count;\n                break;\n            case COLLAPSED:\n                newBitSet.set(HystrixEventType.COLLAPSED.ordinal());\n\n                localNumCollapsed += count;\n\n                break;\n            default:\n                newBitSet.set(eventType.ordinal());\n\n                break;\n        }\n        return new EventCounts(newBitSet, localNumEmits, localNumFallbackEmits, localNumCollapsed);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "127", "src_id": "M448", "code": "    private static void writeThreadPoolMetrics(final HystrixThreadPoolMetrics threadPoolMetrics, JsonGenerator json) throws IOException {\n        HystrixThreadPoolKey key = threadPoolMetrics.getThreadPoolKey();\n        json.writeStartObject();\n\n        json.writeStringField(\"type\", \"HystrixThreadPool\");\n        json.writeStringField(\"name\", key.name());\n\n        json.writeNumberField(\"currentTime\", System.currentTimeMillis());\n        json.writeNumberField(\"currentActiveCount\", threadPoolMetrics.getCurrentActiveCount().intValue());\n\n        json.writeNumberField(\n        \"currentCompletedTaskCount\", threadPoolMetrics.getCurrentCompletedTaskCount().longValue());\n        json.writeNumberField(\"currentCorePoolSize\", threadPoolMetrics.getCurrentCorePoolSize().intValue());\n        json.writeNumberField(\"currentLargestPoolSize\", threadPoolMetrics.getCurrentLargestPoolSize().intValue());\n        json.writeNumberField(\"currentMaximumPoolSize\", threadPoolMetrics.getCurrentMaximumPoolSize().intValue());\n        json.writeNumberField(\"currentPoolSize\", threadPoolMetrics.getCurrentPoolSize().intValue());\n        json.writeNumberField(\"currentQueueSize\", threadPoolMetrics.getCurrentQueueSize().intValue());\n        json.writeNumberField(\"currentTaskCount\", threadPoolMetrics.getCurrentTaskCount().longValue());\n        safelyWriteNumberField(json, \"rollingCountThreadsExecuted\", new Func0<Long>() {\n            @Override\n            public Long call() {\n                return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.EXECUTED);\n            }\n        });\n        json.writeNumberField(\"rollingMaxActiveThreads\", threadPoolMetrics.getRollingMaxActiveThreads());\n        safelyWriteNumberField(json, \"rollingCountCommandRejections\", new Func0<Long>() {\n            @Override\n            public Long call() {\n                return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.REJECTED);\n            }\n        });\n\n        json.writeNumberField(\"propertyValue_queueSizeRejectionThreshold\", threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());\n        json.writeNumberField(\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());\n\n        json.writeNumberField(\"reportingHosts\", 1); // this will get summed across all instances in a cluster\n        json.writeEndObject();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "128", "src_id": "M69", "code": "    @Override\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n        List<HystrixEventType> foundEventTypes = new ArrayList<HystrixEventType>();\n\n        sb.append(getCommandKey().name()).append(\"[\");\n        for (HystrixEventType eventType : ALL_EVENT_TYPES) {\n            if (executionResult.getEventCounts().contains(eventType)) {\n                foundEventTypes.add(eventType);\n            }\n        }\n\n        int i = 0;\n\n        for (HystrixEventType eventType : foundEventTypes) {\n            sb.append(eventType.name());\n            int eventCount = executionResult.getEventCounts().getCount(eventType);\n            if (eventCount > 1) {\n                sb.append(\"x\").append(eventCount);\n            }\n            if (foundEventTypes.size() - 1> i) {\n                sb.append(\", \");\n            }\n            i++;\n\n        }\n        sb.append(\"][\").append(getExecutionLatency()).append(\" ms]\");\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "129", "src_id": "M52", "code": "    @Override\n    public void run() {\n        while (true) {/**\n                     * Since this is a simple example and we know the exact HystrixCommandKeys we are interested in\n                     * we will retrieve the HystrixCommandMetrics objects directly.\n                     *\n                     * Typically you would instead retrieve metrics from where they are published which is by default\n                     * done using Servo: https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring\n                     */\n            // wait 5 seconds on each loop\n            try {\n                Thread.sleep(5000);\n            } catch (Exception e) {\n            // ignore\n            }\n\n            // we are using default names so can use class.getSimpleName() to derive the keys\n            HystrixCommandMetrics creditCardMetrics = HystrixCommandMetrics\n            .getInstance(HystrixCommandKey.Factory.asKey(CreditCardCommand.class.getSimpleName()));\n\n            HystrixCommandMetrics orderMetrics = HystrixCommandMetrics\n            .getInstance(HystrixCommandKey.Factory.asKey(GetOrderCommand.class.getSimpleName()));\n            HystrixCommandMetrics userAccountMetrics = HystrixCommandMetrics\n            .getInstance(HystrixCommandKey.Factory.asKey(GetUserAccountCommand.class.getSimpleName()));\n            HystrixCommandMetrics paymentInformationMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetPaymentInformationCommand.class.getSimpleName()));\n\n            if (shouldLog) {\n                // print out metrics\n                StringBuilder out = new StringBuilder();\n                out.append(\"\\n\");\n                out.append(\n                \"#####################################################################################\").append(\"\\n\");\n                out.append(\"# CreditCardCommand: \" + getStatsStringFromMetrics(creditCardMetrics)).append(\"\\n\");\n                out.append(\"# GetOrderCommand: \" + getStatsStringFromMetrics(orderMetrics)).append(\"\\n\");\n                out.append(\"# GetUserAccountCommand: \" + getStatsStringFromMetrics(userAccountMetrics)).append(\"\\n\");\n                out.append(\n                \"# GetPaymentInformationCommand: \" + getStatsStringFromMetrics(paymentInformationMetrics)).append(\"\\n\");\n                out.append(\n                \"#####################################################################################\").append(\"\\n\");\n                System.out.println(out.toString());\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "130", "src_id": "M312", "code": "    private Observable<R> handleRequestCacheHitAndEmitValues(final HystrixCommandResponseFromCache<R> fromCache, final AbstractCommand<R> _cmd) {\n        try {\n            executionHook.onCacheHit(this);\n        } catch (Throwable hookEx) {\n            logger.warn(\"Error calling HystrixCommandExecutionHook.onCacheHit\", hookEx);\n        }\n\n        return fromCache.toObservableWithStateCopiedInto(this).doOnTerminate(new Action0() {\n            @Override\n            public void call() {\n                if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) {\n                    cleanUpAfterResponseFromCache(false); //user code never ran\n                } else {\n                    if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) {\n                        cleanUpAfterResponseFromCache(true); //user code did run\n                    }\n                }\n            }\n        }).doOnUnsubscribe(new Action0() {\n            @Override\n            public void call() {\n                if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) {\n                    cleanUpAfterResponseFromCache(false); //user code never ran\n                } else {\n                    if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.UNSUBSCRIBED)) {\n                        cleanUpAfterResponseFromCache(true); //user code did run\n                    }\n                }\n            }\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "131", "src_id": "M438", "code": "    private static void serializeUtilization(HystrixUtilization utilization, JsonGenerator json) {\n        try {\n            json.writeStartObject();\n            json.writeStringField(\"type\", \"HystrixUtilization\");\n            json.writeObjectFieldStart(\"commands\");\n            for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n                final HystrixCommandKey key = entry.getKey();\n                final HystrixCommandUtilization commandUtilization = entry.getValue();\n                writeCommandUtilizationJson(json, key, commandUtilization);\n            }\n            json.writeEndObject();\n            json.writeObjectFieldStart(\"threadpools\");\n\n            for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n                final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n                final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n                writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n            }\n\n            json.writeEndObject();\n\n            json.writeEndObject();\n\n            json.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "52", "src_id": "M1277", "code": "    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n            if (obj instanceof byte[]) str = SafeEncoder.encode((byte[]) obj);else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                    redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                    str = geo.getLongitude() + \",\" + geo.getLatitude();\n                } else if (obj instanceof String) str = stringEscape ? escape((String) obj) : (String) obj;else str = String.valueOf(obj);\n            output.put(key, str);\n        }\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "53", "src_id": "M902", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "54", "src_id": "M1131", "code": "    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE : // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n                return null;\n                // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "55", "src_id": "M1057", "code": "    @Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n\n        if (list.get(0) instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n            return KeyValue.of(resultsBuilder.build(resultsData)\n            ,ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n        return KeyValue.of(resultsBuilder.build(list.get(0))\n        ,ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "56", "src_id": "M1229", "code": "    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode == SslVerifyMode.FULL) this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");else if (sslVerifyMode == SslVerifyMode.CA) this.sslParameters.setEndpointIdentificationAlgorithm(\"\");else if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                    trustManagers = new TrustManager[] { \n                    INSECURE_TRUST_MANAGER };\n                }\n\n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n\n            keyManagerFactory.init(keyStore, keystorePassword);\n\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "57", "src_id": "M894", "code": "    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n\n        Map<String, Object> properties = new HashMap<>();\n\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n\n            Object value = propertyValue.getValue();\n\n            if (!(value instanceof List)) if (value instanceof byte[]) {\n                    value = BuilderFactory.STRING.build(value);\n                    if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                        try {\n                            value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                        } catch (Exception e) { \n                        }\n                    }\n                } else {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n                        value = labels;\n                        break;\n                    case RULES_PROPERTY:\n                        List<KeyValue> rulesDataList = (List<KeyValue>) value;\n                        Map<String, List<Object>> rulesValueMap = new HashMap<>(rulesDataList.size(), \n                        1f);\n                        rules = new HashMap<>(rulesDataList.size());\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n\n                            List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, \n                            new Rule(ruleName, ruleValueList));\n                        }\n                        value = rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n                        List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                        chunks = new ArrayList<>(chunksDataList.size());\n                        for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n\n                            chunks.add(chunk);\n                        }\n                        value = chunksValueList;\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n                        break;\n                }\n            } \n\n            properties.put(prop, value);\n        }\n\n        return new TSInfo(properties, labels, rules, chunks);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "58", "src_id": "M897", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "59", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n\n                if (jedis != null) { \n                    jedis.ping();\n                    return jedis;\n                } \n\n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n\n                if (jedis != null) {\n                    jedis.close();\n                }\n\n            }\n        }\n\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "60", "src_id": "M9", "code": "    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n            EvictionPolicy policy = getEvictionPolicy();\n\n            policy.touch(cacheKey);\n\n            CacheKey evictedKey = policy.evictNext();\n\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n\n                if (redisKeysToCacheKeys.containsKey(mapKey)) redisKeysToCacheKeys.get(mapKey).add(cacheKey);else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n\n                    redisKeysToCacheKeys.put(mapKey, set);\n\n                }\n            }\n\n            stats.load();\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "61", "src_id": "M1105", "code": "    @Override\n    public Class<?> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "83", "src_id": "M491", "code": "    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,\n    @ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n\n                break;\n        }\n        // save the new resize mode so it can be restored in a future session\n        player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "84", "src_id": "M424", "code": "    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) closeItemsList();else if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n                // Ensure that we have audio-only stream playing when a user\n                // started to play from notification's play button from outside of the app\n                if (!fragmentIsVisible) {\n                    onFragmentStopped();\n                }\n            } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction())) {\n                    fragmentIsVisible = false;\n                    onFragmentStopped();\n                } else if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n                        // Restore video source when user returns to the fragment\n                        fragmentIsVisible = true;\n                        player.useVideoSource(true);\n                        // When a user returns from background, the system UI will always be shown even if\n                        // controls are invisible: hide it in that case\n                        if (!isControlsVisible()) {\n                            hideSystemUIIfNeeded();\n                        }\n                    }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "85", "src_id": "M900", "code": "    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n\n        final String selectedTheme = getSelectedThemeKey(context);\n        if (selectedTheme.equals(lightTheme)) return R.style.LightSettingsTheme;else if (selectedTheme.equals(blackTheme)) return R.style.BlackSettingsTheme;else if (!(selectedTheme.equals(automaticDeviceTheme))) return R.style.DarkSettingsTheme;else {\n                    if (!isDeviceDarkThemeEnabled(context)) return R.style.LightSettingsTheme;else {\n                        // use the dark theme variant preferred by the user\n                        final String selectedNightTheme = getSelectedNightThemeKey(context);\n                        if (selectedNightTheme.equals(blackTheme)) return R.style.BlackSettingsTheme;else return R.style.DarkSettingsTheme;\n                    } \n                } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "86", "src_id": "M895", "code": "    @Override\n    public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n        final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n        final Bitmap result = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth,(int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n        if (!(result == source || !result.isMutable())) {\n            source.recycle();\n            return result;\n        } else {\n            // create a new mutable bitmap to prevent strange crashes on some\n            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n            source.recycle();\n            return copied;\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "87", "src_id": "M225", "code": "    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null) {\n            return;\n        }\n        if (intent.getAction() == null) {\n        return;\n            }\n\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                }\n\n                break;\n        }\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "88", "src_id": "M749", "code": "    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            // Starting ReCaptcha Challenge Activity\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n            context.startActivity(intent);\n        } else if (errorInfo.getThrowable() != null && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) \n                Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) \n                    Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof GeographicRestrictionException) \n                        Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof PaidContentException) \n                            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof PrivateContentException) \n                                Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) \n                                    Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) \n                                        Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof ContentNotAvailableException) Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();else if (errorInfo.getThrowable() instanceof ContentNotSupportedException) Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();else ErrorUtil.createNotification(context, errorInfo);\n        if (context instanceof RouterActivity) {\n            ((RouterActivity) context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "89", "src_id": "M999", "code": "    public static void openVideoDetailFragment(@NonNull final Context context,\n    @NonNull final FragmentManager fragmentManager,\n    final int serviceId,\n    @Nullable final String url,\n    @NonNull final String title,\n    @Nullable final PlayQueue playQueue,\n    final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);else if (switchingPlayers) autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n            else if (playerType == PlayerType.MAIN) autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);else autoPlay = false;\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (!switchingPlayers) detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);else detailFragment.openVideoPlayer(playerType == PlayerType.POPUP || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n\n            detailFragment.scrollToTop();\n        };\n\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (fragment instanceof VideoDetailFragment && fragment.isVisible()) onVideoDetailFragmentReady.run((VideoDetailFragment) fragment);else {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n\n            instance.setAutoPlay(autoPlay);\n\n            defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(() -> onVideoDetailFragmentReady.run(instance)).commit();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "90", "src_id": "M698", "code": "    @Override\n    public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) \n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);else binding.channelBannerImage.setImageDrawable(null);\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n        binding.channelTitleView.setText(result.getName());\n\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n\n        if (result.getSubscriberCount() < 0) binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);else binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n        updateRssButton();\n        channelContentNotSupported = false;\n        for (final Throwable throwable : result.getErrors()) {\n            if (!(throwable instanceof ContentNotSupportedException)) { \n                continue ; \n            }  \n            channelContentNotSupported = true;\n\n            showContentNotSupportedIfNeeded();\n            break;\n        }\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "91", "src_id": "M379", "code": "    importnull;@Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null) \n        {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n        if (!trackTypeTextSupported) {\n        binding.captionTextView.setVisibility(View.GONE);\n            return;\n            }\n\n        // Extract all loaded languages\n        final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType()).collect(Collectors.toList());\n        List<Tracks.Group>tmp = textTracks.stream().map(Tracks.Group::getMediaTrackGroup);final List<String> availableLanguages = tmp.filter(textTrack -> textTrack.length > 0).map(textTrack -> textTrack.getFormat(0).language).collect(Collectors.toList());\n\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info -> info.getMediaTrackGroup().length >= 1).map(info -> info.getMediaTrackGroup().getFormat(0)).findFirst();\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n\n        if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) binding.captionTextView.setText(R.string.caption_none);else binding.captionTextView.setText(selectedTracks.get().language);\n\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "92", "src_id": "M894", "code": "    public static RequestCreator loadScaledDownThumbnail(final Context context,\n    @NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n            @Override\n            public Bitmap transform(final Bitmap source) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n                }\n                final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n                final Bitmap result = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth,(int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)), null, true);\n\n                if (!(result == source || !result.isMutable())) {\n                    source.recycle();\n                    return result;\n                } else {\n                    // create a new mutable bitmap to prevent strange crashes on some\n                    // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int) notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))), null, true);\n                    source.recycle();\n                    return copied;\n                } \n            }\n\n            @Override\n            public String key() {\n                return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n            }\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "136", "src_id": "M267", "code": "            @Override\n            public void startElement(XlsxReadContext xlsxReadContext, String name, Attributes attributes) {\n        String ref = \n        attributes.getValue(ExcelXmlConstants.ATTRIBUTE_REF);\n        if (StringUtils.isEmpty(ref)) {\n    return;\n        }\n        // Hyperlink has 2 case:\n        // case 1，In the 'location' tag\n        String location = \n        attributes.getValue(ExcelXmlConstants.ATTRIBUTE_LOCATION);\n        if (location != null) {\n    CellExtra cellExtra = new CellExtra(CellExtraTypeEnum.HYPERLINK, location, ref);\n    xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n\n    xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n\n    return;\n        }\n\n        // case 2, In the 'r:id' tag, Then go to 'PackageRelationshipCollection' to get inside\n        String rId = \n        attributes.getValue(ExcelXmlConstants.ATTRIBUTE_RID);\n        PackageRelationshipCollection packageRelationshipCollection = xlsxReadContext.xlsxReadSheetHolder().getPackageRelationshipCollection();\n\n        if (rId == null) {\n    return;\n        }\n        if (packageRelationshipCollection == null) {\n        return;\n    }\n        Optional.ofNullable(packageRelationshipCollection.getRelationshipByID(rId)).map(PackageRelationship::getTargetURI).ifPresent(uri -> {\n    CellExtra cellExtra = \n    new CellExtra(CellExtraTypeEnum.HYPERLINK, uri.toString(), ref);\n    xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n\n    xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n        });\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "137", "src_id": "M248", "code": "            @Override\n            public void processRecord(XlsReadContext xlsReadContext, Record record) {\n        LabelSSTRecord lsrec = (LabelSSTRecord) record;\n\n        ReadCache readCache = xlsReadContext.readWorkbookHolder().getReadCache();\n        Map<Integer, Cell> cellMap = xlsReadContext.xlsReadSheetHolder().getCellMap();\n\n        if (readCache == null) {\n    cellMap.put(\n    (int) lsrec.getColumn()\n    , ReadCellData.newEmptyInstance(lsrec.getRow(), (int) lsrec.getColumn()));\n\n    return;\n        }\n        String data = readCache.get(lsrec.getSSTIndex());\n        if (data == null) {\n    cellMap.put(\n    (int) lsrec.getColumn()\n    , ReadCellData.newEmptyInstance(lsrec.getRow(), (int) lsrec.getColumn()));\n\n    return;\n        }\n        if (xlsReadContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\n    data = data.trim();\n        }\n        cellMap.put(\n        (int) lsrec.getColumn()\n        , ReadCellData.newInstance(data, lsrec.getRow(), (int) lsrec.getColumn()));\n\n        xlsReadContext.xlsReadSheetHolder().setTempRowType(RowTypeEnum.DATA);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "138", "src_id": "M106", "code": "            private Row createRowIfNecessary(Sheet sheet, Sheet cachedSheet, Integer lastRowIndex, FillConfig fillConfig, AnalysisCell analysisCell, boolean isOriginalCell, RowWriteHandlerContext rowWriteHandlerContext) {\n        rowWriteHandlerContext.setRowIndex(lastRowIndex);\n        Row row = sheet.getRow(lastRowIndex);\n\n        if (row != null) {\n    checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n    rowWriteHandlerContext.setRow(row);\n    return row;\n        }\n\n        row = cachedSheet.getRow(lastRowIndex);\n\n        if (row != null) {\n    checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n    rowWriteHandlerContext.setRow(row);\n        }\n        else {\n    rowWriteHandlerContext.setRowIndex(lastRowIndex);\n\n    WriteHandlerUtils.beforeRowCreate(rowWriteHandlerContext);\n\n    if (fillConfig.getForceNewRow()) {\nrow = cachedSheet.createRow(lastRowIndex);\n    } else {\n// The last row of the middle disk inside empty rows, resulting in cachedSheet can not get inside.\n// Will throw Attempting to write a row[\" + rownum + \"] \" + \"in the range [0,\" + this._sh\n// .getLastRowNum() + \"] that is already written to disk.\ntry {\nrow = sheet.createRow(lastRowIndex);\n} catch (IllegalArgumentException ignore) {\nrow = cachedSheet.createRow(lastRowIndex);\n}\n    }\n\n    rowWriteHandlerContext.setRow(row);\n\n    checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n\n    WriteHandlerUtils.afterRowCreate(rowWriteHandlerContext);\n        } \n        return row;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "139", "src_id": "M12", "code": "            private Object buildNoModel(Map<Integer, ReadCellData<?>> cellDataMap, ReadSheetHolder readSheetHolder, AnalysisContext context) {\n        int index = 0;\n\n        Map<Integer, Object> map = \n        MapUtils.newLinkedHashMapWithExpectedSize(cellDataMap.size());\n        for (Map.Entry<Integer, ReadCellData<?>> entry : cellDataMap.entrySet()) {\n    Integer key = entry.getKey();\n    ReadCellData<?> cellData = entry.getValue();\n\n    while (key> index) {\nmap.put(index, null);\n\nindex++;\n    }\n    index++;\n    ReadDefaultReturnEnum readDefaultReturn = context.readWorkbookHolder().getReadDefaultReturn();\n    if (readDefaultReturn == ReadDefaultReturnEnum.STRING) {\n// string\nmap.put(key,(String) ConverterUtils.convertToJavaObject(cellData, null, null, readSheetHolder.converterMap(), context, \ncontext.readRowHolder().getRowIndex(), key));\n    } else {\n// retrun ReadCellData\nReadCellData<?> convertedReadCellData = convertReadCellData(\ncellData, context.readWorkbookHolder().getReadDefaultReturn(), readSheetHolder, context, key);\nif (readDefaultReturn == ReadDefaultReturnEnum.READ_CELL_DATA) {\nmap.put(key, convertedReadCellData);\n} else {\nmap.put(key, convertedReadCellData.getData());\n}\n    }\n        }\n        // fix https://github.com/alibaba/easyexcel/issues/2014\n        int headSize = calculateHeadSize(readSheetHolder);\n        while (headSize> index) {\n    map.put(index, null);\n\n    index++;\n        }\n        return map;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "140", "src_id": "M94", "code": "            private void fillComment(\n            CellWriteHandlerContext cellWriteHandlerContext, CommentData commentData) {\n        if (commentData == null) {\n    return;\n        }\n        ClientAnchor anchor;\n        Integer rowIndex = cellWriteHandlerContext.getRowIndex();\n        Integer columnIndex = cellWriteHandlerContext.getColumnIndex();\n\n        Sheet sheet = \n        cellWriteHandlerContext.getWriteSheetHolder().getSheet();\n        Cell cell = cellWriteHandlerContext.getCell();\n        if (writeContext.writeWorkbookHolder().getExcelType() == ExcelTypeEnum.XLSX) {\n    anchor = new XSSFClientAnchor(StyleUtil.getCoordinate(commentData.getLeft()), StyleUtil.getCoordinate(commentData.getTop()), StyleUtil.getCoordinate(commentData.getRight()), StyleUtil.getCoordinate(commentData.getBottom()), StyleUtil.getCellCoordinate(\n    columnIndex, commentData.getFirstColumnIndex(), commentData.getRelativeFirstColumnIndex()), StyleUtil.getCellCoordinate(\n    rowIndex, commentData.getFirstRowIndex(), commentData.getRelativeFirstRowIndex()), StyleUtil.getCellCoordinate(\n    columnIndex, commentData.getLastColumnIndex(), commentData.getRelativeLastColumnIndex()) + 1, StyleUtil.getCellCoordinate(\n    rowIndex, commentData.getLastRowIndex(), commentData.getRelativeLastRowIndex()) + 1);\n        } else {\n    anchor = new HSSFClientAnchor(StyleUtil.getCoordinate(commentData.getLeft()), StyleUtil.getCoordinate(commentData.getTop()), StyleUtil.getCoordinate(commentData.getRight()), StyleUtil.getCoordinate(commentData.getBottom()),(short) StyleUtil.getCellCoordinate(\n    columnIndex, commentData.getFirstColumnIndex(), commentData.getRelativeFirstColumnIndex()), StyleUtil.getCellCoordinate(\n    rowIndex, commentData.getFirstRowIndex(), commentData.getRelativeFirstRowIndex()),(short) (StyleUtil.getCellCoordinate(\n    columnIndex, commentData.getLastColumnIndex(), commentData.getRelativeLastColumnIndex()) + 1), StyleUtil.getCellCoordinate(\n    rowIndex, commentData.getLastRowIndex(), commentData.getRelativeLastRowIndex()) + 1);\n        }\n        Comment comment = \n        sheet.createDrawingPatriarch().createCellComment(anchor);\n        if (commentData.getRichTextStringData() != null) {\n    comment.setString(StyleUtil\n    .buildRichTextString(writeContext.writeWorkbookHolder(), commentData.getRichTextStringData()));\n        }\n        if (commentData.getAuthor() != null) {\n    comment.setAuthor(commentData.getAuthor());\n        }\n        cell.setCellComment(comment);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "141", "src_id": "M212", "code": "            private Format getFormat(Double data, Short dataFormat, String dataFormatString) {\n        // Might be better to separate out the n p and z formats, falling back to p when n and z are not set.\n        // That however would require other code to be re factored.\n        // String[] formatBits = formatStrIn.split(\";\");\n        // int i = cellValue > 0.0 ? 0 : cellValue < 0.0 ? 1 : 2;\n        // String formatStr = (i < formatBits.length) ? formatBits[i] : formatBits[0];\n        String formatStr = dataFormatString;\n        // Excel supports 2+ part conditional data formats, eg positive/negative/zero,\n        //  or (>1000),(>0),(0),(negative). As Java doesn't handle these kinds\n        //  of different formats for different ranges, just +ve/-ve, we need to\n        //  handle these ourselves in a special way.\n        // For now, if we detect 2+ parts, we call out to CellFormat to handle it\n        // TODO Going forward, we should really merge the logic between the two classes\n        if (formatStr.contains(\";\") && (formatStr.indexOf(';') != formatStr.lastIndexOf(';') || rangeConditionalPattern.matcher(formatStr).matches())) {\n    try {\n// Ask CellFormat to get a formatter for it\nCellFormat cfmt = CellFormat.getInstance(locale, formatStr);\n// CellFormat requires callers to identify date vs not, so do so\nObject cellValueO; \n\nif (DateUtils.isADateFormat(dataFormat, formatStr) && // don't try to handle Date value 0, let a 3 or 4-part format take care of it\ndata.doubleValue() != 0.0) { \ncellValueO = DateUtils.getJavaDate(data, use1904windowing); \n} \nelse { \ncellValueO = data; \n} \n\nreturn new CellFormatResultWrapper(cfmt.apply(cellValueO));\n    } catch (Exception e) {\nLOGGER.warn(\"Formatting failed for format {}, falling back\", formatStr, e);\n    }\n        }\n\n        // See if we already have it cached\n        Format format = formats.get(formatStr);\n\n        if (format != null) {\n    return format;\n        }\n\n        // Is it one of the special built in types, General or @?\n        if (\"General\".equalsIgnoreCase(formatStr)) {\n    format = getDefaultFormat();\n    addFormat(formatStr, format);\n    return format;\n        }\n        // Build a formatter, and cache it\n        if (\"@\".equals(formatStr)) {\n        format = getDefaultFormat();\n    addFormat(formatStr, format);\n    return format;\n    }\n        // Build a formatter, and cache it\n        format = createFormat(dataFormat, formatStr);\n\n        addFormat(formatStr, format);\n\n        return format;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "142", "src_id": "M35", "code": "            private static void buildStyleProperty(StyleProperty styleProperty, WriteCellStyle writeCellStyle) {\n        if (styleProperty == null) {\n    return;\n        }\n        if (styleProperty.getDataFormatData() != null) {\n    if (writeCellStyle.getDataFormatData() == null) {\nwriteCellStyle.setDataFormatData(styleProperty.getDataFormatData());\n    } else {\nDataFormatData.merge(styleProperty.getDataFormatData(), writeCellStyle.getDataFormatData());\n    }\n        }\n        if (styleProperty.getHidden() != null) {\n    writeCellStyle.setHidden(styleProperty.getHidden());\n        }\n        if (styleProperty.getLocked() != null) {\n    writeCellStyle.setLocked(styleProperty.getLocked());\n        }\n        if (styleProperty.getQuotePrefix() != null) {\n    writeCellStyle.setQuotePrefix(styleProperty.getQuotePrefix());\n        }\n        if (styleProperty.getHorizontalAlignment() != null) {\n    writeCellStyle.setHorizontalAlignment(styleProperty.getHorizontalAlignment());\n        }\n        if (styleProperty.getWrapped() != null) {\n    writeCellStyle.setWrapped(styleProperty.getWrapped());\n        }\n        if (styleProperty.getVerticalAlignment() != null) {\n    writeCellStyle.setVerticalAlignment(styleProperty.getVerticalAlignment());\n        }\n        if (styleProperty.getRotation() != null) {\n    writeCellStyle.setRotation(styleProperty.getRotation());\n        }\n        if (styleProperty.getIndent() != null) {\n    writeCellStyle.setIndent(styleProperty.getIndent());\n        }\n        if (styleProperty.getBorderLeft() != null) {\n    writeCellStyle.setBorderLeft(styleProperty.getBorderLeft());\n        }\n        if (styleProperty.getBorderRight() != null) {\n    writeCellStyle.setBorderRight(styleProperty.getBorderRight());\n        }\n        if (styleProperty.getBorderTop() != null) {\n    writeCellStyle.setBorderTop(styleProperty.getBorderTop());\n        }\n        if (styleProperty.getBorderBottom() != null) {\n    writeCellStyle.setBorderBottom(styleProperty.getBorderBottom());\n        }\n        if (styleProperty.getLeftBorderColor() != null) {\n    writeCellStyle.setLeftBorderColor(styleProperty.getLeftBorderColor());\n        }\n\n        if (styleProperty.getRightBorderColor() != null) {\n    writeCellStyle.setRightBorderColor(styleProperty.getRightBorderColor());\n        }\n\n        if (styleProperty.getTopBorderColor() != null) {\n    writeCellStyle.setTopBorderColor(styleProperty.getTopBorderColor());\n        }\n\n        if (styleProperty.getBottomBorderColor() != null) {\n    writeCellStyle.setBottomBorderColor(styleProperty.getBottomBorderColor());\n        }\n\n        if (styleProperty.getFillPatternType() != null) {\n    writeCellStyle.setFillPatternType(styleProperty.getFillPatternType());\n        }\n\n        if (styleProperty.getFillBackgroundColor() != null) {\n    writeCellStyle.setFillBackgroundColor(styleProperty.getFillBackgroundColor());\n        }\n        if (styleProperty.getFillForegroundColor() != null) {\n    writeCellStyle.setFillForegroundColor(styleProperty.getFillForegroundColor());\n        }\n        if (styleProperty.getShrinkToFit() != null) {\n    writeCellStyle.setShrinkToFit(styleProperty.getShrinkToFit());\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "143", "src_id": "M90", "code": "            private void addJavaObjectToExcel(Object oneRowData, Row row, int rowIndex, int relativeRowIndex) {\n        WriteHolder currentWriteHolder = writeContext.currentWriteHolder();\n\n        BeanMap beanMap = BeanMapUtils.create(oneRowData);\n\n        // Bean the contains of the Map Key method with poor performance,So to create a keySet here\n        Set<String> beanKeySet = \n        new HashSet<>(beanMap.keySet());\n        Set<String> beanMapHandledSet = new HashSet<>();\n\n        int maxCellIndex = -1;\n        // If it's a class it needs to be cast by type\n        if (HeadKindEnum.CLASS\n        .equals(writeContext.currentWriteHolder().excelWriteHeadProperty().getHeadKind())) {\n    Map<Integer, Head> headMap = \n    writeContext.currentWriteHolder().excelWriteHeadProperty().getHeadMap();\n    for (Map.Entry<Integer, Head> entry : headMap.entrySet()) {\nint columnIndex = entry.getKey();\nHead head = entry.getValue();\nString name = head.getFieldName();\nif (beanKeySet.contains(name)) { ExcelContentProperty excelContentProperty = ClassUtils.declaredExcelContentProperty(\nbeanMap, currentWriteHolder.excelWriteHeadProperty().getHeadClazz(), name, currentWriteHolder);\nCellWriteHandlerContext cellWriteHandlerContext = WriteHandlerUtils.createCellWriteHandlerContext(\nwriteContext, row, rowIndex, head, columnIndex, relativeRowIndex, Boolean.FALSE, excelContentProperty);\n\nWriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n\nCell cell = WorkBookUtil.createCell(row, columnIndex);\n\ncellWriteHandlerContext.setCell(cell);\n\nWriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n\ncellWriteHandlerContext.setOriginalValue(beanMap.get(name));\n\ncellWriteHandlerContext.setOriginalFieldClass(head.getField().getType());\nconverterAndSet(cellWriteHandlerContext);\nWriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n\nbeanMapHandledSet.add(name);\n\nmaxCellIndex = Math.max(maxCellIndex, columnIndex);\n} \n    }\n        }\n\n        // Finish\n        if (beanMapHandledSet.size() == beanMap.size()) {\n    return;\n        }\n        maxCellIndex++;\n        FieldCache fieldCache = \n        ClassUtils.declaredFields(oneRowData.getClass(), \n        writeContext.currentWriteHolder());\n        for (Map.Entry<Integer, FieldWrapper> entry : fieldCache.getSortedFieldMap().entrySet()) {\n    FieldWrapper field = entry.getValue();\n    String fieldName = field.getFieldName();\n    boolean uselessData = \n    !beanKeySet.contains(fieldName) || beanMapHandledSet.contains(fieldName);\n    if (!uselessData) { \nObject value = beanMap.get(fieldName);\n\nExcelContentProperty excelContentProperty = ClassUtils.declaredExcelContentProperty(beanMap, currentWriteHolder.excelWriteHeadProperty().getHeadClazz(), fieldName, currentWriteHolder);\nCellWriteHandlerContext cellWriteHandlerContext = WriteHandlerUtils.createCellWriteHandlerContext(writeContext, row, rowIndex, null, maxCellIndex, relativeRowIndex, Boolean.FALSE, excelContentProperty);\n\nWriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n\n// fix https://github.com/alibaba/easyexcel/issues/1870\n// If there is data, it is written to the next cell\nCell cell = WorkBookUtil.createCell(row, maxCellIndex);\n\ncellWriteHandlerContext.setCell(cell);\n\nWriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n\ncellWriteHandlerContext.setOriginalValue(value);\n\ncellWriteHandlerContext\n.setOriginalFieldClass(FieldUtils.getFieldClass(beanMap, fieldName, value));\nconverterAndSet(cellWriteHandlerContext);\n\nWriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n\nmaxCellIndex++;\n    } \n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "144", "src_id": "M50", "code": "            public CellStyle createCellStyle(WriteCellStyle writeCellStyle, CellStyle originCellStyle) {\n        if (writeCellStyle == null) {\n    return originCellStyle;\n        }\n        short styleIndex = -1;\n        Font originFont = null;\n        boolean useCache = true;\n        if (originCellStyle != null) {\n    styleIndex = originCellStyle.getIndex();\n\n    if (originCellStyle instanceof XSSFCellStyle) {\noriginFont = ((XSSFCellStyle) originCellStyle).getFont();\n    } else if (originCellStyle instanceof HSSFCellStyle) {\noriginFont = ((HSSFCellStyle) originCellStyle).getFont(workbook);\n}\n\n    useCache = false;\n        }\n\n        Map<WriteCellStyle, CellStyle> cellStyleMap = \n        cellStyleIndexMap.computeIfAbsent(styleIndex, key -> MapUtils.newHashMap());\n        CellStyle cellStyle = cellStyleMap.get(writeCellStyle);\n        if (cellStyle != null) {\n    return cellStyle;\n        }\n        if (log.isDebugEnabled()) {\n    log.info(\"create new style:{},{}\", writeCellStyle, originCellStyle);\n        }\n        WriteCellStyle tempWriteCellStyle = new WriteCellStyle();\n\n        WriteCellStyle.merge(writeCellStyle, tempWriteCellStyle);\n\n        cellStyle = StyleUtil.buildCellStyle(workbook, originCellStyle, tempWriteCellStyle);\n        Short dataFormat = \n        createDataFormat(tempWriteCellStyle.getDataFormatData(), \n        useCache);\n        if (dataFormat != null) {\n    cellStyle.setDataFormat(dataFormat);\n        }\n        Font font = \n        createFont(tempWriteCellStyle.getWriteFont(), originFont, useCache);\n\n        if (font != null) {\n    cellStyle.setFont(font);\n        }\n        cellStyleMap.put(tempWriteCellStyle, cellStyle);\n        return cellStyle;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "145", "src_id": "M21", "code": "            private void buildHead(AnalysisContext analysisContext, Map<Integer, ReadCellData<?>> cellDataMap) {\n        // Rule out empty head, and then take the largest column\n        if (MapUtils.isNotEmpty(cellDataMap)) {\n    cellDataMap.entrySet().stream().filter(entry -> \n    CellDataTypeEnum.EMPTY != entry.getValue().getType()).forEach(\n    entry -> \n    analysisContext.readSheetHolder().setMaxNotEmptyDataHeadSize(entry.getKey()));\n        }\n\n        if (!HeadKindEnum.CLASS\n        .equals(analysisContext.currentReadHolder().excelReadHeadProperty().getHeadKind())) {\n    return;\n        }\n        Map<Integer, String> dataMap = \n        ConverterUtils.convertToStringMap(cellDataMap, analysisContext);\n        ExcelReadHeadProperty excelHeadPropertyData = \n        analysisContext.readSheetHolder().excelReadHeadProperty();\n        Map<Integer, Head> headMapData = excelHeadPropertyData.getHeadMap();\n        Map<Integer, Head> tmpHeadMap = \n        new HashMap<Integer, Head>(headMapData.size() * 4 / 3 + 1);\n        for (Map.Entry<Integer, Head> entry : headMapData.entrySet()) {\n    Head headData = entry.getValue();\n    if (headData.getForceIndex()) {\ntmpHeadMap.put(entry.getKey(), headData);\ncontinue;\n    }\n    if (!headData.getForceName()) {\n    tmpHeadMap.put(entry.getKey(), headData);\ncontinue;\n}\n    List<String> headNameList = headData.getHeadNameList();\n    String headName = headNameList.get(headNameList.size() - 1);\n    for (Map.Entry<Integer, String> stringEntry : dataMap.entrySet()) {\nif (stringEntry != null) { \nString headString = stringEntry.getValue();\nInteger stringKey = stringEntry.getKey();\nif (StringUtils.isEmpty(headString)) {\ncontinue;\n}\nif (analysisContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\nheadString = headString.trim();\n}\nif (headName.equals(headString)) {\nheadData.setColumnIndex(stringKey);\ntmpHeadMap.put(stringKey, headData);\nbreak;\n}\n} \n    }\n        }\n        excelHeadPropertyData.setHeadMap(tmpHeadMap);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "1", "src_id": "M475", "code": "            @Override\n            public void draw(CommandProcess process, JvmModel result) {\n        TableElement table = \n        new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n        for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n    String group = entry.getKey();\n    List<JvmItemVO> items = entry.getValue();\n    table.row(true, label(group).style(Decoration.bold.bold()));\n\n    for (JvmItemVO item : items) {\nString valueStr;\nif (item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\")) {\nvalueStr = \nrenderMemoryUsage((Map<String, Object>) item.getValue());\n} else {\nvalueStr = renderItemValue(item.getValue());\n}\nif (item.getDesc() != null) {\ntable.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", \nvalueStr);\n} else {\ntable.row(item.getName(), valueStr);\n}\n    }\n\n    table.row(\"\", \"\");\n        }\n\n        process.write(RenderUtil.render(table, process.width()));\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "2", "src_id": "M535", "code": "            public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n        final StringBuilder infoSB = new StringBuilder();\n\n        List<String> classDumpFiles = affectVO.getClassDumpFiles();\n        if (classDumpFiles != null) {\n    for (String classDumpFile : classDumpFiles) {\ninfoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n    }\n        }\n        List<String> methods = affectVO.getMethods();\n\n        if (methods != null) {\n    for (String method : methods) {\ninfoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n    }\n        }\n\n        infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\"\n        ,affectVO.getClassCount(),\n        affectVO.getMethodCount(),\n        affectVO.getCost(), affectVO.getListenerId()));\n        if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n    infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n        }\n        if (affectVO.getThrowable() != null) {\n    infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n        }\n        infoSB.append(\"\\n\");\n        return infoSB.toString();\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "3", "src_id": "M753", "code": "            public List<ThreadVO> sample(\n            Collection<ThreadVO> originThreads) {\n\n        List<ThreadVO> threads = \n        new ArrayList<ThreadVO>(originThreads);\n        // Sample CPU\n        if (lastCpuTimes.isEmpty()) {\n    lastSampleTimeNanos = System.nanoTime();\n\n    for (ThreadVO thread : threads) {\nif (thread.getId() > 0) {\nlong cpu = \nthreadMXBean.getThreadCpuTime(thread.getId());\nlastCpuTimes.put(thread, cpu);\nthread.setTime(cpu / 1000000);\n}\n    }\n\n    // add internal threads\n    Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n    if (internalThreadCpuTimes != null) {\nfor (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\nString key = entry.getKey();\nThreadVO thread = createThreadVO(key);\n\nthread.setTime(entry.getValue() / 1000000);\n\nthreads.add(thread);\n\nlastCpuTimes.put(thread, entry.getValue());\n\n}\n    }\n\n    //sort by time\n    Collections.sort(threads, new Comparator<ThreadVO>() {\n@Override\npublic int compare(ThreadVO o1, ThreadVO o2) {\nlong l1 = o1.getTime();\nlong l2 = o2.getTime();\nif (l2> l1) {\nreturn 1;\n} else if (l1 > l2) {\nreturn -1;\n} else {\nreturn 0;\n}\n}\n    });\n    return threads;\n        }\n        // Resample\n        long newSampleTimeNanos = System.nanoTime();\n        Map<ThreadVO, Long> newCpuTimes = \n        new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : threads) {\n    if (thread.getId() > 0) {\nlong cpu = \nthreadMXBean.getThreadCpuTime(thread.getId());\nnewCpuTimes.put(thread, cpu);\n    }\n        }\n        // internal threads\n        Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (newInternalThreadCpuTimes != null) {\n    for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\nThreadVO threadVO = createThreadVO(entry.getKey());\nthreads.add(threadVO);\nnewCpuTimes.put(threadVO, entry.getValue());\n\n    }\n        }\n\n        // Compute delta time\n        final Map<ThreadVO, Long> deltas = \n        new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : newCpuTimes.keySet()) {\n    Long t; \n\n    if (t == null) { \nt = 0L; \n    } else { \nt = lastCpuTimes.get(thread); \n    } \n    long time1 = t;\n\n    long time2 = newCpuTimes.get(thread);\n    if (time1 == -1) {\ntime1 = time2;\n    } else if (time2 == -1) {\ntime2 = time1;\n}\n    long delta = time2 - time1;\n    deltas.put(thread, delta);\n        }\n\n        long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n        // Compute cpu usage\n        final HashMap<ThreadVO, Double> cpuUsages = \n        new HashMap<ThreadVO, Double>(threads.size());\n        for (ThreadVO thread : threads) {\n    double cpu; \n\n    if (sampleIntervalNanos == 0) { \ncpu = 0; \n    } else { \ncpu = (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0); \n    } \n    cpuUsages.put(thread, cpu);\n        }\n\n        // Sort by CPU time : should be a rendering hint...\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n    @Override\n    public int compare(ThreadVO o1, ThreadVO o2) {\nlong l1 = deltas.get(o1);\nlong l2 = deltas.get(o2);\nif (l2> l1) {\nreturn 1;\n} else if (l1 > l2) {\nreturn -1;\n} else {\nreturn 0;\n}\n    }\n        });\n\n        for (ThreadVO thread : threads) {\n    //nanos to mills\n    long timeMills = newCpuTimes.get(thread) / 1000000;\n    long deltaTime = deltas.get(thread) / 1000000;\n    double cpu = cpuUsages.get(thread);\n    thread.setCpu(cpu);\n    thread.setTime(timeMills);\n    thread.setDeltaTime(deltaTime);\n        }\n        lastCpuTimes = newCpuTimes;\n\n        lastSampleTimeNanos = newSampleTimeNanos;\n\n        return threads;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "4", "src_id": "M1131", "code": "            private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = \n        new TreeMap<String, Object>();\n\n        body.put(\"command\", commandLine);\n\n        ApiResponse response = new ApiResponse();\n\n        response.setSessionId(session.getSessionId()).setBody(body);\n\n        if (!session.tryLock()) {\n    response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n    return response;\n        }\n\n        int lock = session.getLock();\n\n        try {\n    Job foregroundJob = session.getForegroundJob();\n\n    if (foregroundJob != null) {\nresponse.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\nlogger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\nreturn response;\n    }\n    //create job\n    Job job = \n    this.createJob(commandLine, session, session.getResultDistributor());\n    body.put(\"jobId\", job.id());\n    body.put(\"jobStatus\", job.status());\n\n    response.setState(ApiState.SCHEDULED);\n    //add command before exec job\n    CommandRequestModel commandRequestModel = \n    new CommandRequestModel(commandLine, response.getState());\n    commandRequestModel.setJobId(job.id());\n    SharingResultDistributor resultDistributor = session.getResultDistributor();\n    if (resultDistributor != null) {\nresultDistributor.appendResult(commandRequestModel);\n    }\n    session.setForegroundJob(job);\n    updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n\n    //run job\n    job.run();\n\n    return response;\n        } catch (Throwable e) {\n    logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n    response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n    CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n    session.getResultDistributor().appendResult(commandRequestModel);\n\n    return response;\n        } finally {\n    if (session.getLock() == lock) {\nsession.unLock();\n    }\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "5", "src_id": "M542", "code": "            private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n    Map<String, Object> info = entry.getValue();\n    TableElement table = \n    new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n    TableElement appendersTable = new TableElement().rightCellPadding(1);\n    Class<?> clazz = \n    (Class<?>) info.get(LoggerHelper.clazz);\n    table.row(\n    label(LoggerHelper.name).style(Decoration.bold.bold()), \n    label(\"\" + info.get(LoggerHelper.name))).row(\n    label(LoggerHelper.clazz).style(Decoration.bold.bold())\n    , label(\"\" + clazz.getName())).row(\n    label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(\n    label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(\n    label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n    if (info.get(LoggerHelper.effectiveLevel) != null) {\ntable.row(\nlabel(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n    }\n\n    if (info.get(LoggerHelper.config) != null) {\ntable.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n    }\n\n    table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n    @SuppressWarnings(\"unchecked\") List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n    if (appenders != null && !appenders.isEmpty()) {\nfor (Map<String, Object> appenderInfo : appenders) {\nClass<?> appenderClass = \n(Class<?>) appenderInfo.get(LoggerHelper.clazz);\n\nappendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\nappendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\nappendersTable.row(\nlabel(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n\nappendersTable\n.row(\nlabel(LoggerHelper.classLoaderHash),\nlabel(\"\" + info.get(LoggerHelper.classLoaderHash)));\nif (appenderInfo.get(LoggerHelper.file) != null) {\nappendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n}\nif (appenderInfo.get(LoggerHelper.target) != null) {\nappendersTable.row(label(LoggerHelper.target)\n,label(\"\" + appenderInfo.get(LoggerHelper.target)));\n}\nif (appenderInfo.get(LoggerHelper.blocking) != null) {\nappendersTable.row(\nlabel(LoggerHelper.blocking)\n,label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n}\nif (appenderInfo.get(LoggerHelper.appenderRef) != null) {\nappendersTable\n.row(\nlabel(LoggerHelper.appenderRef)\n,label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n}\n}\ntable.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n    }\n\n    sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n\n        return sb.toString();\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "6", "src_id": "M15", "code": "            public static int startArthasClient(\n            String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n        // start java telnet client\n        // find arthas-client.jar\n        URLClassLoader classLoader = \n        new URLClassLoader(new URL[]{\n        new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n\n        Class<?> telnetConsoleClass = \n        classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n\n        Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n        //redirect System.out/System.err\n        PrintStream originSysOut = System.out;\n        PrintStream originSysErr = System.err;\n        PrintStream newOut = new PrintStream(out);\n        PrintStream newErr = new PrintStream(out);\n        // call TelnetConsole.process()\n        // fix https://github.com/alibaba/arthas/issues/833\n        ClassLoader tccl = \n        Thread.currentThread().getContextClassLoader();\n\n        try {\n    System.setOut(newOut);\n    System.setErr(newErr);\n    Thread.currentThread().setContextClassLoader(classLoader);\n    return (Integer) processMethod.invoke(null, new Object[]{\n    telnetArgs.toArray(new String[0])});\n        } catch (Throwable e) {\n    //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n    e = e.getCause();\n    if (e instanceof IOException || e instanceof InterruptedException) {\n// ignore connection error and interrupted error\nreturn STATUS_ERROR;\n    } else {\n// process error\nAnsiLog.error(\"process error: {}\", e.toString());\nAnsiLog.error(e);\nreturn STATUS_EXEC_ERROR;\n    }\n        } finally {\n    Thread.currentThread().setContextClassLoader(tccl);\n    //reset System.out/System.err\n    System.setOut(originSysOut);\n    System.setErr(originSysErr);\n    //flush output\n    newOut.flush();\n    newErr.flush();\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "7", "src_id": "M1469", "code": "            public static FieldVO[] getFields(Class clazz, Integer expand) {\n        Field[] fields = clazz.getDeclaredFields();\n        if (fields.length == 0) {\n    return new FieldVO[0];\n        }\n        List<FieldVO> list = \n        new ArrayList<FieldVO>(fields.length);\n        for (Field field : fields) {\n    FieldVO fieldVO = new FieldVO();\n    fieldVO.setName(field.getName());\n\n    fieldVO.setType(StringUtils.classname(field.getType()));\n    fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n\n    fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n\n    if (!(Modifier.isStatic(field.getModifiers()))) {\nfieldVO.setStatic(false);\n    } else {\nfieldVO.setStatic(true);\nfieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n    } \n\n    list.add(fieldVO);\n        }\n        return list.toArray(new FieldVO[0]);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "32", "src_id": "M31", "code": "    import null;private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")// .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() == 200) {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n\n                log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n                log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n            }\n            // Extract user count, default to 1 if not specified\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n\n            applicationProperties.getPremium().setMaxUsers(users);\n            // Extract isEnterprise flag\n            JsonNode tmp = jsonResponse.path(\"data\").path(\"attributes\");\n            context.isEnterpriseLicense = tmp.path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } else {\n            log.error(\"Error validating license. Status code: {}\", response.statusCode());\n        }\n        return jsonResponse;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "33", "src_id": "M488", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description =\n    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n    throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "34", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            // Metadata using PDFBox\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode();\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            ObjectNode encryption = objectMapper.createObjectNode();\n            ObjectNode other = objectMapper.createObjectNode();\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", metadata);\n            // Total file size of the PDF\n            long fileSizeInBytes = inputFile.getSize();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n            // Number of words, paragraphs, and images in the entire document\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n            int wordCount = words.length;\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n            basicInfo.put(\"WordCount\", wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n            // Number of characters in the entire document (including spaces and special characters)\n            int charCount = fullText.length();\n            basicInfo.put(\"CharacterCount\", charCount);\n\n            // Initialize the flags and types\n            boolean hasCompression = false;\n\n            String compressionType = \"None\";\n\n            basicInfo.put(\"Compression\", hasCompression);\n            if (hasCompression) {\n                basicInfo.put(\"CompressionType\", compressionType);\n            }\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", language);\n            basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            String pageMode = catalog.getPageMode().name();\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n            ;\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", formFieldsNode);\n            // Generate structured summary data about PDF characteristics\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n            if (summaryData != null && 0< summaryData.size()) {\n                jsonOutput.set(\"SummaryData\", summaryData);\n            }\n            // embeed files TODO size\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n\n                ArrayNode embeddedFilesArray \n                = objectMapper.createArrayNode();\n\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            ObjectNode embeddedFileNode \n                            = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", entry.getKey());\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n            // attachments TODO size\n            ArrayNode attachmentsArray \n            = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n\n                        attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n\n                        attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n            // Javascript\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n            ArrayNode javascriptArray \n            = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", entry.getKey());\n                            PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n            // TODO size\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n\n            other.set(\"Layers\", layersArray);// TODO Security\n\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            ArrayNode structureTreeArray;\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                }\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                log.error(\"exception\", e);\n            }\n\n            boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n            boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n            boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n            boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n            boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n            boolean isPdfBCompliant = checkForStandard(pdfBoxDoc,\"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n            // an official ISO standard.\n            boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc,\"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n            // development in 2021.\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            String xmpString = null;\n            if (pdMetadata != null) {\n                try {\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        DomXmpParser domXmpParser = new DomXmpParser();\n                        XMPMetadata xmpMeta = domXmpParser.parse(is);\n                        ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        new XmpSerializer().serialize(xmpMeta, os, true);\n                        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                    }\n                } catch (XmpParsingException e) {\n                    // XMP parsing failed, try to read raw metadata instead\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", xmpString);\n            if (pdfBoxDoc.isEncrypted()) {\n                encryption.put(\"IsEncrypted\", true);\n                // Retrieve encryption details using getEncryption()\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n                // Add other encryption-related properties as needed\n            } else {\n                encryption.put(\"IsEncrypted\", false);\n            }\n            ObjectNode permissionsNode \n            = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                // Retrieve the page\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n                // Page-level Information\n                PDRectangle mediaBox = page.getMediaBox();\n                float width = mediaBox.getWidth();\n\n                float height = mediaBox.getHeight();\n\n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, width, height);\n                sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n                pageInfo.set(\"Size\", sizeInfo);\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                // Assuming the following boxes are defined for your document; if not, you may get\n                // null values.\n                PDRectangle cropBox = page.getCropBox();\n                pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n                PDRectangle bleedBox = page.getBleedBox();\n\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n                PDRectangle trimBox = page.getTrimBox();\n\n                pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n                PDRectangle artBox = page.getArtBox();\n\n                pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n                // Content Extraction\n                PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n                String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length()); //\n                // Annotations\n                List<PDAnnotation> annotations = page.getAnnotations();\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) {\n                        subtypeCount++; // Increase subtype count\n                    }\n                    if (annotation.getContents() != null) {\n                        contentsCount++; // Increase contents count\n                    }\n                }\n                ObjectNode annotationsObject \n                = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n                // Images (simplified)\n                // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                // Here is a basic structure to recognize image XObjects on a page.\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                PDResources resources = page.getResources();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null && image.getMetadata().getFile() != null\n                        && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n                        }\n\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", imagesArray);\n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n                Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation\n                    && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri); // Add to set to ensure uniqueness\n                    }\n                }\n\n                // Add unique URIs to linksArray\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n                pageInfo.set(\"Links\", linksArray);\n\n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                    fontNode.put(\"Name\", font.getName());\n                    fontNode.put(\"Subtype\", font.getType());\n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        // Font stretch and BBox are not directly available in PDFBox's API, so\n                        // these are omitted for simplicity\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n                    // Create a unique key for this font node based on its attributes\n                    String uniqueKey = fontNode.toString();\n                    // Increment count if this font exists, or initialize it if new\n                    if (uniqueFontsMap.containsKey(uniqueKey)) {\n                        ObjectNode existingFontNode \n                        = uniqueFontsMap.get(uniqueKey);\n                        int count = existingFontNode.get(\"Count\").asInt() + 1;\n                        existingFontNode.put(\"Count\", count);\n                    } else {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, fontNode);\n                    }\n                }\n                // Add unique font entries to fontsArray\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", fontsArray);\n                // Access resources dictionary\n                ArrayNode colorSpacesArray \n                = objectMapper.createArrayNode();\n\n                Iterable<COSName> colorSpaceNames \n                = resources.getColorSpaceNames();\n                for (COSName name : colorSpaceNames) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        byte[] iccBytes = iccData.toByteArray();\n                        // TODO: Further decode and analyze the ICC data if needed\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n                // Other XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType;\n                    if (!(xObject instanceof PDImageXObject)) {\n                        if (xObject instanceof PDFormXObject) {\n                            xObjectType = \"Form\";\n                        } else {\n                            xObjectType = \"Other\";\n                        }\n                        // Increment the count for this type in the map\n                    } else {\n                        xObjectType = \"Image\";\n                    } \n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                // Add the count map to pageInfo (or wherever you want to store it)\n                ObjectNode xObjectCountNode \n                = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n                ArrayNode multimediaArray \n                = objectMapper.createArrayNode();\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        ObjectNode multimediaNode = objectMapper.createObjectNode();\n                        // Extract details from the annotation as needed\n                        multimediaArray.add(multimediaNode);\n                    }\n                }\n                pageInfo.set(\"Multimedia\", multimediaArray);\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n            jsonOutput.set(\"BasicInfo\", basicInfo);\n            jsonOutput.set(\"DocumentInfo\", docInfoNode);\n            jsonOutput.set(\"Compliancy\", compliancy);\n            jsonOutput.set(\"Encryption\", encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n            jsonOutput.set(\"Other\", other);\n            jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n            // Save JSON to file\n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n\n            return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8),\"response.json\", MediaType.APPLICATION_JSON);\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "35", "src_id": "M24", "code": "    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String)attrs.get(\"enc\");\n                encodedSignature = (String)attrs.get(\"sig\");\n                algorithm = (String)attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n            // Verify license file algorithm\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n            // Verify signature\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n            log.info(\"License file signature is valid\");\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", e.getMessage());\n                return false;\n            }\n            // Process the certificate data\n            boolean isValid = processCertificateData(decodedData, context);\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "36", "src_id": "M403", "code": "    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n    throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "37", "src_id": "M317", "code": "    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n    throws IOException {\n        boolean imageIsLandscape \n        = image.getHeight()< image.getWidth();\n        PDRectangle pageSize = PDRectangle.A4;\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (!(\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption))) {\n                if (\"maintainAspectRatio\".equals(fitOption)) {\n                    float imageAspectRatio = (float)image.getWidth() / (float)image.getHeight();\n                    float pageAspectRatio = pageWidth / pageHeight;\n                    float scaleFactor = 1.0f;\n                    if (pageAspectRatio< imageAspectRatio) {\n                        scaleFactor = pageWidth / image.getWidth();\n                    } else {\n                        scaleFactor = pageHeight / image.getHeight();\n                    }\n                    float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                    float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                    contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n                }\n            } else {\n                contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n            } \n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "38", "src_id": "M307", "code": "    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network == null) {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", mac[i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } else {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", mac[i]));\n                    }\n                }\n            }\n            // Hash the MAC address for privacy and consistency\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "39", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n        String author = pdfMetadata.getAuthor();\n\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "40", "src_id": "M128", "code": "    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (isKubernetes) {\n                return \"Kubernetes\";\n            } else {\n                if (!isDocker) {\n                    if (isBrowserOpen) {\n                        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                        if (!(os.contains(\"win\"))) {\n                            if (os.contains(\"mac\")) {\n                                return \"Client-mac\";\n                            } else {\n                                return \"Client-unix\";\n                            }\n                        } else {\n                            return \"Client-windows\";\n                        } \n                    } else {\n                        return \"Server-jar\";\n                    }\n                } else {\n                    return \"Docker\";\n                } \n            }\n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "41", "src_id": "M101", "code": "    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets, HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n    throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (!(probe.isConsumed())) {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        } else {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, response);\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "66", "src_id": "M475", "code": "    @Override\n    public void draw(CommandProcess process, JvmModel result) {\n        TableElement table = new TableElement(2, 5).leftCellPadding(1).rightCellPadding(1);\n        for (Map.Entry<String, List<JvmItemVO>> entry : result.getJvmInfo().entrySet()) {\n            String group = entry.getKey();\n            List<JvmItemVO> items = entry.getValue();\n\n            table.row(true, label(group).style(Decoration.bold.bold()));\n            for (JvmItemVO item : items) {\n                String valueStr = item.getValue() instanceof Map && item.getName().endsWith(\"MEMORY-USAGE\") ? renderMemoryUsage((Map<String, Object>) item.getValue()) : renderItemValue(item.getValue()); if (item.getDesc() != null) { \n                    table.row(item.getName() + \"\\n[\" + item.getDesc() + \"]\", valueStr);\n                    continue; \n                }  \n                table.row(item.getName(), valueStr);\n            }\n            table.row(\"\", \"\");\n        }\n        process.write(RenderUtil.render(table, process.width()));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "67", "src_id": "M535", "code": "    public static String renderEnhancerAffect(EnhancerAffectVO affectVO) {\n        final StringBuilder infoSB = new StringBuilder();\n        List<String> classDumpFiles = affectVO.getClassDumpFiles();\n\n        if (classDumpFiles != null) {\n            for (String classDumpFile : classDumpFiles) {\n                infoSB.append(\"[dump: \").append(classDumpFile).append(\"]\\n\");\n            }\n        }\n\n        List<String> methods = affectVO.getMethods();\n        if (methods != null) {\n            for (String method : methods) {\n                infoSB.append(\"[Affect method: \").append(method).append(\"]\\n\");\n            }\n        }\n\n        infoSB.append(format(\"Affect(class count: %d , method count: %d) cost in %s ms, listenerId: %d\", affectVO.getClassCount(), affectVO.getMethodCount(), affectVO.getCost(), affectVO.getListenerId()));\n        if (!StringUtils.isEmpty(affectVO.getOverLimitMsg())) {\n            infoSB.append(\"\\n\" + affectVO.getOverLimitMsg());\n        }\n        if (affectVO.getThrowable() != null) {\n            infoSB.append(\"\\nEnhance error! exception: \").append(affectVO.getThrowable());\n        }\n        infoSB.append(\"\\n\");\n        return infoSB.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "68", "src_id": "M753", "code": "    public List<ThreadVO> sample(Collection<ThreadVO> originThreads) {\n        List<ThreadVO> threads = new ArrayList<ThreadVO>(originThreads);\n        // Sample CPU\n        if (lastCpuTimes.isEmpty()) {\n            lastSampleTimeNanos = System.nanoTime();\n            for (ThreadVO thread : threads) {\n                if (thread.getId() <= 0) { \n                    continue ; \n                }  \n                long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n                lastCpuTimes.put(thread, cpu);\n                thread.setTime(cpu / 1000000);\n            }\n            // add internal threads\n            Map<String, Long> internalThreadCpuTimes = getInternalThreadCpuTimes();\n            if (internalThreadCpuTimes != null) {\n                for (Map.Entry<String, Long> entry : internalThreadCpuTimes.entrySet()) {\n                    String key = entry.getKey();\n                    ThreadVO thread = createThreadVO(key);\n\n                    thread.setTime(entry.getValue() / 1000000);\n                    threads.add(thread);\n                    lastCpuTimes.put(thread, entry.getValue());\n                }\n            }\n\n            //sort by time\n            Collections.sort(threads, new Comparator<ThreadVO>() {\n                @Override\n                public int compare(ThreadVO o1, ThreadVO o2) {\n                    long l1 = o1.getTime();\n                    long l2 = o2.getTime();\n                    if (l1 < l2) return 1;else if (l1 > l2) return -1;else return 0;\n                }\n            });\n\n            return threads;\n        }\n        // Resample\n        long newSampleTimeNanos = System.nanoTime();\n        Map<ThreadVO, Long> newCpuTimes = new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : threads) {\n            if (thread.getId() <= 0) { \n                continue ; \n            }  \n            long cpu = threadMXBean.getThreadCpuTime(thread.getId());\n            newCpuTimes.put(thread, cpu);\n        }\n        // internal threads\n        Map<String, Long> newInternalThreadCpuTimes = getInternalThreadCpuTimes();\n        if (newInternalThreadCpuTimes != null) {\n            for (Map.Entry<String, Long> entry : newInternalThreadCpuTimes.entrySet()) {\n                ThreadVO threadVO = createThreadVO(entry.getKey());\n                threads.add(threadVO);\n                newCpuTimes.put(threadVO, entry.getValue());\n            }\n        }\n\n        // Compute delta time\n        final Map<ThreadVO, Long> deltas = new HashMap<ThreadVO, Long>(threads.size());\n        for (ThreadVO thread : newCpuTimes.keySet()) {\n            Long t = lastCpuTimes.get(thread);\n            if (t == null) {\n                t = 0L;\n            }\n            long time1 = t;\n            long time2 = newCpuTimes.get(thread);\n            if (time1 == -1) time1 = time2;else if (time2 == -1) {\n                    time2 = time1;\n                }\n            long delta = time2 - time1;\n            deltas.put(thread, delta);\n        }\n        long sampleIntervalNanos = newSampleTimeNanos - lastSampleTimeNanos;\n        // Compute cpu usage\n        final HashMap<ThreadVO, Double> cpuUsages = new HashMap<ThreadVO, Double>(threads.size());\n        for (ThreadVO thread : threads) {\n            double cpu = sampleIntervalNanos == 0 ? 0 : (Math.rint(deltas.get(thread) * 10000.0 / sampleIntervalNanos) / 100.0);\n\n            cpuUsages.put(thread, cpu);\n\n        }\n\n        // Sort by CPU time : should be a rendering hint...\n        Collections.sort(threads, new Comparator<ThreadVO>() {\n            @Override\n            public int compare(ThreadVO o1, ThreadVO o2) {\n                long l1 = deltas.get(o1);\n                long l2 = deltas.get(o2);\n                if (l1 < l2) return 1;else if (l1 > l2) return -1;else return 0;\n            }\n        });\n\n        for (ThreadVO thread : threads) {\n            //nanos to mills\n            long timeMills = newCpuTimes.get(thread) / 1000000;\n            long deltaTime = deltas.get(thread) / 1000000;\n\n            double cpu = cpuUsages.get(thread);\n            thread.setCpu(cpu);\n\n            thread.setTime(timeMills);\n\n            thread.setDeltaTime(deltaTime);\n        }\n        lastCpuTimes = newCpuTimes;\n\n        lastSampleTimeNanos = newSampleTimeNanos;\n        return threads;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "69", "src_id": "M1131", "code": "    private ApiResponse processAsyncExecRequest(ApiRequest apiRequest, Session session) {\n        String commandLine = apiRequest.getCommand();\n        Map<String, Object> body = new TreeMap<String, Object>();\n\n        body.put(\"command\", commandLine);\n\n        ApiResponse response = new ApiResponse();\n        response.setSessionId(session.getSessionId()).setBody(body);\n        if (!session.tryLock()) {\n            response.setState(ApiState.REFUSED).setMessage(\"Another command is executing.\");\n            return response;\n        }\n        int lock = session.getLock();\n        try {\n            Job foregroundJob = session.getForegroundJob();\n            if (foregroundJob != null) {\n                response.setState(ApiState.REFUSED).setMessage(\"Another job is running.\");\n                logger.info(\"Another job is running, jobId: {}\", foregroundJob.id());\n                return response;\n            }\n            //create job\n            Job job = this.createJob(commandLine, session, session.getResultDistributor());\n\n            body.put(\"jobId\", job.id());\n\n            body.put(\"jobStatus\", job.status());\n\n            response.setState(ApiState.SCHEDULED);\n            //add command before exec job\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState());\n            commandRequestModel.setJobId(job.id());\n            SharingResultDistributor resultDistributor = session.getResultDistributor();\n            if (resultDistributor != null) {\n                resultDistributor.appendResult(commandRequestModel);\n            }\n\n            session.setForegroundJob(job);\n            updateSessionInputStatus(session, InputStatus.ALLOW_INTERRUPT);\n            //run job\n            job.run();\n            return response;\n        } catch (Throwable e) {\n            logger.error(\"Async exec command failed:\" + e.getMessage() + \", command:\" + commandLine, e);\n\n            response.setState(ApiState.FAILED).setMessage(\"Async exec command failed:\" + e.getMessage());\n\n            CommandRequestModel commandRequestModel = new CommandRequestModel(commandLine, response.getState(), response.getMessage());\n            session.getResultDistributor().appendResult(commandRequestModel);\n            return response;\n        } finally {\n            if (session.getLock() == lock) {\n                session.unLock();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "70", "src_id": "M542", "code": "    importnull;private String renderLoggerInfo(Map<String, Map<String, Object>> loggerInfos, int width) {\n        StringBuilder sb = new StringBuilder(8192);\n        for (Map.Entry<String, Map<String, Object>> entry : loggerInfos.entrySet()) {\n            Map<String, Object> info = entry.getValue();\n            TableElement table = new TableElement(2, 10).leftCellPadding(1).rightCellPadding(1);\n            TableElement appendersTable = new TableElement().rightCellPadding(1);\n            Class<?> clazz = (Class<?>) info.get(LoggerHelper.clazz);\n            TableElement tmp = table.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.name)));\n            tmp.row(label(LoggerHelper.clazz).style(Decoration.bold.bold()), label(\"\" + clazz.getName())).row(label(LoggerHelper.classLoader).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoader))).row(label(LoggerHelper.classLoaderHash).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.classLoaderHash))).row(label(LoggerHelper.level).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.level)));\n            if (info.get(LoggerHelper.effectiveLevel) != null) {\n                table.row(label(LoggerHelper.effectiveLevel).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.effectiveLevel)));\n            }\n\n            if (info.get(LoggerHelper.config) != null) {\n                table.row(label(LoggerHelper.config).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.config)));\n            }\n\n            table.row(label(LoggerHelper.additivity).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.additivity))).row(label(LoggerHelper.codeSource).style(Decoration.bold.bold()), label(\"\" + info.get(LoggerHelper.codeSource)));\n\n            @SuppressWarnings(\"unchecked\")\n            List<Map<String, Object>> appenders = (List<Map<String, Object>>) info.get(LoggerHelper.appenders);\n            if (appenders != null && !appenders.isEmpty()) {\n                for (Map<String, Object> appenderInfo : appenders) {\n                    Class<?> appenderClass = (Class<?>) appenderInfo.get(LoggerHelper.clazz);\n                    appendersTable.row(label(LoggerHelper.name).style(Decoration.bold.bold()), label(\"\" + appenderInfo.get(LoggerHelper.name)));\n                    appendersTable.row(label(LoggerHelper.clazz), label(\"\" + appenderClass.getName()));\n                    appendersTable.row(label(LoggerHelper.classLoader), label(\"\" + info.get(LoggerHelper.classLoader)));\n                    appendersTable.row(label(LoggerHelper.classLoaderHash), label(\"\" + info.get(LoggerHelper.classLoaderHash)));\n                    if (appenderInfo.get(LoggerHelper.file) != null) {\n                        appendersTable.row(label(LoggerHelper.file), label(\"\" + appenderInfo.get(LoggerHelper.file)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.target) != null) {\n                        appendersTable.row(label(LoggerHelper.target), label(\"\" + appenderInfo.get(LoggerHelper.target)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.blocking) != null) {\n                        appendersTable.row(label(LoggerHelper.blocking), label(\"\" + appenderInfo.get(LoggerHelper.blocking)));\n                    }\n                    if (appenderInfo.get(LoggerHelper.appenderRef) == null) { \n                        continue ; \n                    }  \n\n                    appendersTable.row(label(LoggerHelper.appenderRef), label(\"\" + appenderInfo.get(LoggerHelper.appenderRef)));\n                }\n                table.row(label(\"appenders\").style(Decoration.bold.bold()), appendersTable);\n            }\n            sb.append(RenderUtil.render(table, width)).append('\\n');\n        }\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "71", "src_id": "M15", "code": "    public static int startArthasClient(String arthasHomeDir, List<String> telnetArgs, OutputStream out) throws Throwable {\n        // start java telnet client\n        // find arthas-client.jar\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{\n        new File(arthasHomeDir, \"arthas-client.jar\").toURI().toURL()});\n        Class<?> telnetConsoleClass = classLoader.loadClass(\"com.taobao.arthas.client.TelnetConsole\");\n        Method processMethod = telnetConsoleClass.getMethod(\"process\", String[].class);\n        //redirect System.out/System.err\n        PrintStream originSysOut = System.out;\n        PrintStream originSysErr = System.err;\n        PrintStream newOut = new PrintStream(out);\n        PrintStream newErr = new PrintStream(out);\n\n        // call TelnetConsole.process()\n        // fix https://github.com/alibaba/arthas/issues/833\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n\n        try {\n            System.setOut(newOut);\n            System.setErr(newErr);\n            Thread.currentThread().setContextClassLoader(classLoader);\n            return (Integer) processMethod.invoke(null, new Object[]{\n            telnetArgs.toArray(new String[0])});\n        } catch (Throwable e) {\n            //java.lang.reflect.InvocationTargetException : java.net.ConnectException\n            e = e.getCause();\n            if (e instanceof IOException || e instanceof InterruptedException) return STATUS_ERROR;else {\n                // process error\n                AnsiLog.error(\"process error: {}\", e.toString());\n                AnsiLog.error(e);\n                return STATUS_EXEC_ERROR;\n            }\n        } finally {\n            Thread.currentThread().setContextClassLoader(tccl);\n            //reset System.out/System.err\n            System.setOut(originSysOut);\n            System.setErr(originSysErr);\n\n            //flush output\n            newOut.flush();\n            newErr.flush();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "72", "src_id": "M1469", "code": "    public static FieldVO[] getFields(Class clazz, Integer expand) {\n        Field[] fields = clazz.getDeclaredFields();\n        if (fields.length == 0) {\n            return new FieldVO[0];\n        }\n        List<FieldVO> list = new ArrayList<FieldVO>(fields.length);\n        for (Field field : fields) {\n            FieldVO fieldVO = new FieldVO();\n            fieldVO.setName(field.getName());\n            fieldVO.setType(StringUtils.classname(field.getType()));\n\n            fieldVO.setModifier(StringUtils.modifier(field.getModifiers(), ','));\n            fieldVO.setAnnotations(getAnnotations(field.getAnnotations()));\n            if (!(Modifier.isStatic(field.getModifiers()))) fieldVO.setStatic(false);else {\n                fieldVO.setStatic(true);\n                fieldVO.setValue(new ObjectVO(getFieldValue(field), expand));\n            } \n            list.add(fieldVO);\n        }\n\n        return list.toArray(new FieldVO[0]);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "156", "src_id": "M270", "code": "    private static String normalizeArch(String value) {\n\n      value = normalize(value);\n\n      if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n        return \"x86_64\";\n      }\n      if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n        return \"x86_32\";\n      }\n      if (value.matches(\"^(ia64w?|itanium64)$\")) {\n        return \"itanium_64\";\n      }\n\n      if (\"ia64n\".equals(value)) {\n        return \"itanium_32\";\n      }\n      if (value.matches(\"^(sparc|sparc32)$\")) {\n        return \"sparc_32\";\n      }\n      if (value.matches(\"^(sparcv9|sparc64)$\")) {\n        return \"sparc_64\";\n      }\n      if (value.matches(\"^(arm|arm32)$\")) {\n        return \"arm_32\";\n      }\n      if (\"aarch64\".equals(value)) {\n        return \"aarch_64\";\n      }\n      if (value.matches(\"^(mips|mips32)$\")) {\n        return \"mips_32\";\n      }\n      if (value.matches(\"^(mipsel|mips32el)$\")) {\n        return \"mipsel_32\";\n      }\n      if (\"mips64\".equals(value)) {\n        return \"mips_64\";\n      }\n      if (\"mips64el\".equals(value)) {\n        return \"mipsel_64\";\n      }\n      if (value.matches(\"^(ppc|ppc32)$\")) {\n        return \"ppc_32\";\n      }\n      if (value.matches(\"^(ppcle|ppc32le)$\")) {\n        return \"ppcle_32\";\n      }\n      if (\"ppc64\".equals(value)) {\n        return \"ppc_64\";\n      }\n      if (\"ppc64le\".equals(value)) {\n        return \"ppcle_64\";\n      }\n\n      if (\"s390\".equals(value)) {\n        return \"s390_32\";\n      }\n\n      if (\"s390x\".equals(value)) {\n        return \"s390_64\";\n      }\n\n      return value;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "157", "src_id": "M928", "code": "    private static Map<String, Object> doGetLoggerInfo(Logger logger) {\n      Map<String, Object> info = new HashMap<String, Object>();\n\n      info.put(LoggerHelper.name, logger.getName());\n      info.put(LoggerHelper.clazz, logger.getClass());\n      CodeSource codeSource = logger.getClass().getProtectionDomain().getCodeSource();\n      if (codeSource != null) {\n        info.put(LoggerHelper.codeSource, codeSource.getLocation());\n      }\n\n      info.put(LoggerHelper.additivity, logger.getAdditivity());\n\n      Level level = logger.getLevel(), effectiveLevel = logger.getEffectiveLevel();\n      if (level != null) {\n        info.put(LoggerHelper.level, level.toString());\n      }\n\n      if (effectiveLevel != null) {\n        info.put(LoggerHelper.effectiveLevel, effectiveLevel.toString());\n      }\n\n      @SuppressWarnings(\"unchecked\") List<Map<String, Object>> result = doGetLoggerAppenders(logger.getAllAppenders());\n      info.put(LoggerHelper.appenders, result);\n      return info;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "158", "src_id": "M9", "code": "    @SuppressWarnings(\"resource\")\n    public static long select(boolean v, long telnetPortPid, String select) throws InputMismatchException {\n\n      Map<Long, String> processMap = listProcessByJps(v);\n\n      // Put the port that is already listening at the first\n      if (0 < telnetPortPid && processMap.containsKey(telnetPortPid)) {\n        String telnetPortProcess = processMap.get(telnetPortPid);\n        processMap.remove(telnetPortPid);\n        Map<Long, String> newProcessMap = new LinkedHashMap<Long, String>();\n        newProcessMap.put(telnetPortPid, telnetPortProcess);\n        newProcessMap.putAll(processMap);\n\n        processMap = newProcessMap;\n      }\n\n      if (processMap.isEmpty()) {\n        AnsiLog.info(\"Can not find java process. Try to run `jps` command lists the instrumented Java HotSpot VMs on the target system.\");\n        return -1;\n      }\n\n      // select target process by the '--select' option when match only one process\n      if (select != null && !select.trim().isEmpty()) {\n        int matchedSelectCount = 0;\n        Long matchedPid = null;\n        for (Entry<Long, String> entry : processMap.entrySet()) {\n          if (entry.getValue().contains(select)) {\n            matchedSelectCount++;\n            matchedPid = entry.getKey();\n          }\n        }\n        if (matchedSelectCount == 1) {\n          return matchedPid;\n        }\n      }\n\n      AnsiLog.info(\"Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.\");\n      // print list\n      int count = 1;\n      for (String process : processMap.values()) {\n        if (count == 1) {\n          System.out.println(\"* [\" + count + \"]: \" + process);\n        } else {\n          System.out.println(\"  [\" + count + \"]: \" + process);\n        }\n        count++;\n\n      }\n      // read choice\n      String line = new Scanner(System.in).nextLine();\n\n      if (line.trim().isEmpty()) {\n        // get the first process id\n        return processMap.keySet().iterator().next();\n      }\n\n      int choice = new Scanner(line).nextInt();\n      if (choice <= 0 || processMap.size()< choice) {\n        return -1;\n      }\n\n      Iterator<Long> idIter = processMap.keySet().iterator();\n\n      for (int i = 1; i <= choice; ++i) {\n        if (i == choice) {\n          return idIter.next();\n        }\n        idIter.next();\n\n      }\n      return -1;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "159", "src_id": "M140", "code": "    void _processDo(int option) throws IOException\n    {\n      if (debugoptions) {\n        System.err.println(\"RECEIVED DO: \" + TelnetOption.getOption(option));\n      }\n      if (__notifhand != null) {\n        __notifhand.receivedNegotiation(TelnetNotificationHandler.RECEIVED_DO, option);\n      }\n\n      boolean acceptNewState = false;\n      /* open TelnetOptionHandler functionality (start)*/\n\n      if (optionHandlers[option] == null) { /* open TelnetOptionHandler functionality (end)*//* TERMINAL-TYPE option (start)*/\n        if (option == TERMINAL_TYPE) {\n          if ((terminalType != null) && (0< terminalType.length())) {\n            acceptNewState = true;\n          }\n        }/* TERMINAL-TYPE option (end)*//* open TelnetOptionHandler functionality (start)*/\n      }/* open TelnetOptionHandler functionality (end)*/else {\n        acceptNewState = optionHandlers[option].getAcceptLocal();\n      }\n\n      if (0< _willResponse[option]) {\n\n        --_willResponse[option];\n\n        if (0 < _willResponse[option] && _stateIsWill(option)) {\n          --_willResponse[option];\n        }\n      }\n\n      if (_willResponse[option] == 0) {\n        if (_requestedWont(option)) {\n          switch (option) {default:\n              break;\n\n          }\n          if (acceptNewState) {\n            _setWantWill(option);\n            _sendWill(option);\n          } else {\n            ++_willResponse[option];\n            _sendWont(option);\n          }\n        } else\n        { // Other end has acknowledged option.\n\n          switch (option) {default:\n              break;\n\n          }\n        }\n      }\n\n      _setWill(option);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "160", "src_id": "M1324", "code": "    private void bind(Configure configure) throws Throwable {\n      long start = System.currentTimeMillis();\n      if (!isBindRef.compareAndSet(false, true)) {\n        throw new IllegalStateException(\"already bind\");\n      }\n      // init random port\n      if (configure.getTelnetPort() != null && configure.getTelnetPort() == 0) {\n        int newTelnetPort = SocketUtils.findAvailableTcpPort();\n\n        configure.setTelnetPort(newTelnetPort);\n        logger().info(\"generate random telnet port: \" + newTelnetPort);\n      }\n      if (configure.getHttpPort() != null && configure.getHttpPort() == 0) {\n        int newHttpPort = SocketUtils.findAvailableTcpPort();\n\n        configure.setHttpPort(newHttpPort);\n        logger().info(\"generate random http port: \" + newHttpPort);\n      }\n      // try to find appName\n      if (configure.getAppName() == null) {\n        configure.setAppName(System.getProperty(ArthasConstants.PROJECT_NAME, System.getProperty(ArthasConstants.SPRING_APPLICATION_NAME, null)));\n      }\n\n      try {\n        if (configure.getTunnelServer() != null) {\n          tunnelClient = new TunnelClient();\n          tunnelClient.setAppName(configure.getAppName());\n          tunnelClient.setId(configure.getAgentId());\n          tunnelClient.setTunnelServerUrl(configure.getTunnelServer());\n          tunnelClient.setVersion(ArthasBanner.version());\n          ChannelFuture channelFuture = tunnelClient.start();\n          channelFuture.await(10, TimeUnit.SECONDS);\n        }\n      } catch (Throwable t) {\n        logger().error(\"start tunnel client error\", t);\n      }\n\n      try {\n        ShellServerOptions options = new ShellServerOptions().setInstrumentation(instrumentation).setPid(PidUtils.currentLongPid()).setWelcomeMessage(ArthasBanner.welcome());\n        if (configure.getSessionTimeout() != null) {\n          options.setSessionTimeout(configure.getSessionTimeout() * 1000);\n        }\n\n        this.httpSessionManager = new HttpSessionManager();\n\n        if (IPUtils.isAllZeroIP(configure.getIp()) && StringUtils.isBlank(configure.getPassword())) {\n          // 当 listen 0.0.0.0 时，强制生成密码，防止被远程连接\n          String errorMsg = \"Listening on 0.0.0.0 is very dangerous! External users can connect to your machine! \" + \"No password is currently configured. \" + \"Therefore, a default password is generated, \" + \"and clients need to use the password to connect!\";\n          AnsiLog.error(errorMsg);\n          configure.setPassword(StringUtils.randomString(64));\n          AnsiLog.error(\"Generated arthas password: \" + configure.getPassword());\n\n          logger().error(errorMsg);\n\n          logger().info(\"Generated arthas password: \" + configure.getPassword());\n        }\n        this.securityAuthenticator = new SecurityAuthenticatorImpl(configure.getUsername(), configure.getPassword());\n\n        shellServer = new ShellServerImpl(options);\n\n        List<String> disabledCommands = new ArrayList<String>();\n        if (configure.getDisabledCommands() != null) {\n\n          String[] strings = StringUtils.tokenizeToStringArray(configure.getDisabledCommands(), \",\");\n\n          if (strings != null) {\n            disabledCommands.addAll(Arrays.asList(strings));\n          }\n        }\n        BuiltinCommandPack builtinCommands = new BuiltinCommandPack(disabledCommands);\n        List<CommandResolver> resolvers = new ArrayList<CommandResolver>();\n\n        resolvers.add(builtinCommands);\n\n        //worker group\n        workerGroup = new NioEventLoopGroup(new DefaultThreadFactory(\"arthas-TermServer\", true));\n\n        // TODO: discover user provided command resolver\n        if (configure.getTelnetPort() != null && 0< configure.getTelnetPort()) {\n          logger().info(\"try to bind telnet server, host: {}, port: {}.\", configure.getIp(), configure.getTelnetPort());\n          shellServer.registerTermServer(new HttpTelnetTermServer(configure.getIp(), configure.getTelnetPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n        } else {\n          logger().info(\"telnet port is {}, skip bind telnet server.\", configure.getTelnetPort());\n        }\n\n        if (!(configure.getHttpPort() != null && 0< configure.getHttpPort())) {\n\n          // listen local address in VM communication\n          if (configure.getTunnelServer() != null) {\n            shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n          }\n\n          logger().info(\"http port is {}, skip bind http server.\", configure.getHttpPort());\n        }\n\n        else {\n          logger().info(\"try to bind http server, host: {}, port: {}.\", configure.getIp(), configure.getHttpPort());\n          shellServer.registerTermServer(new HttpTermServer(configure.getIp(), configure.getHttpPort(), options.getConnectionTimeout(), workerGroup, httpSessionManager));\n        } for (CommandResolver resolver : resolvers) {\n          shellServer.registerCommandResolver(resolver);\n        }\n        shellServer.listen(new BindHandler(isBindRef));\n        if (!isBind()) {\n          throw new IllegalStateException(\"Arthas failed to bind telnet or http port! Telnet port: \" + String.valueOf(configure.getTelnetPort()) + \", http port: \" + String.valueOf(configure.getHttpPort()));\n        }\n        //http api session manager\n        sessionManager = new SessionManagerImpl(options, shellServer.getCommandManager(), shellServer.getJobController());\n\n        //http api handler\n        httpApiHandler = new HttpApiHandler(historyManager, sessionManager);\n\n        logger().info(\"as-server listening on network={};telnet={};http={};timeout={};\", configure.getIp(), configure.getTelnetPort(), configure.getHttpPort(), options.getConnectionTimeout());\n\n        // 异步回报启动次数\n        if (configure.getStatUrl() != null) {\n          logger().info(\"arthas stat url: {}\", configure.getStatUrl());\n        }\n        UserStatUtil.setStatUrl(configure.getStatUrl());\n        UserStatUtil.setAgentId(configure.getAgentId());\n        UserStatUtil.arthasStart();\n        try {\n          SpyAPI.init();\n        } catch (Throwable e) { // ignore\n        }\n        logger().info(\"as-server started in {} ms\", System.currentTimeMillis() - start);\n\n      } catch (Throwable e) {\n        logger().error(\"Error during start as-server\", e);\n\n        destroy();\n        throw e;\n\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "161", "src_id": "M122", "code": "    private int __read(boolean mayBlock) throws IOException{\n      int ch;\n      while (true) {\n        // If there is no more data AND we were told not to block,\n        // just return WOULD_BLOCK (-2). (More efficient than exception.)\n        if (!mayBlock && super.available() == 0) {\n          return WOULD_BLOCK;\n        }\n        // Otherwise, exit only when we reach end of stream.\n        if ((ch = super.read()) < 0) {\n          return EOF;\n        }\n\n        ch = (ch & 0xff);\n        /* Code Section added for supporting AYT (start)*/\n\n        synchronized (__client) {\n          __client._processAYTResponse();\n        }/* Code Section added for supporting AYT (end)*//* Code Section added for supporting spystreams (start)*/\n        __client._spyRead(ch);/* Code Section added for supporting spystreams (end)*/\n        switch (__receiveState) {\n\n          case _STATE_CR:\n            if (ch == '\\0') {\n              // Strip null\n              continue;\n            }\n            // How do we handle newline after cr?\n            //  else if (ch == '\\n' && _requestedDont(TelnetOption.ECHO) &&\n\n            // Handle as normal data by falling through to _STATE_DATA case\n\n            //$FALL-THROUGH$\n          case _STATE_DATA:\n            if (ch == TelnetCommand.IAC) {\n              __receiveState = _STATE_IAC;\n              continue;\n\n            }\n            if (ch == '\\r') {\n              synchronized (__client) {\n                if (__client._requestedDont(TelnetOption.BINARY)) {\n                  __receiveState = _STATE_CR;\n                } else {\n                  __receiveState = _STATE_DATA;\n                }\n              }\n            } else {\n              __receiveState = _STATE_DATA;\n            }\n            break;\n\n          case _STATE_IAC:\n            switch (ch) {\n              case TelnetCommand.WILL:\n                __receiveState = _STATE_WILL;\n                continue;\n              case TelnetCommand.WONT:\n                __receiveState = _STATE_WONT;\n                continue;\n              case TelnetCommand.DO:\n                __receiveState = _STATE_DO;\n                continue;\n              case TelnetCommand.DONT:\n                __receiveState = _STATE_DONT;\n                continue;\n                /* TERMINAL-TYPE option (start)*/\n              case TelnetCommand.SB:\n                __suboption_count = 0;\n                __receiveState = _STATE_SB;\n                continue;\n                /* TERMINAL-TYPE option (end)*/\n              case TelnetCommand.IAC:\n                __receiveState = _STATE_DATA;\n                break; // exit to enclosing switch to return IAC from read\n              case TelnetCommand.SE : // unexpected byte! ignore it (don't send it as a command)\n                __receiveState = _STATE_DATA;\n                continue;\n              default:\n                __receiveState = _STATE_DATA;\n\n                __client._processCommand(ch); // Notify the user\n\n                continue; // move on the next char\n            }\n            break; // exit and return from read\n          case _STATE_WILL:\n            synchronized (__client) {\n              __client._processWill(ch);\n              __client._flushOutputStream();\n            }\n\n            __receiveState = _STATE_DATA;\n            continue;\n          case _STATE_WONT:\n            synchronized (__client) {\n              __client._processWont(ch);\n              __client._flushOutputStream();\n            }\n\n            __receiveState = _STATE_DATA;\n            continue;\n          case _STATE_DO:\n            synchronized (__client) {\n              __client._processDo(ch);\n              __client._flushOutputStream();\n            }\n            __receiveState = _STATE_DATA;\n            continue;\n          case _STATE_DONT:\n            synchronized (__client) {\n              __client._processDont(ch);\n              __client._flushOutputStream();\n            }\n\n            __receiveState = _STATE_DATA;\n            continue;\n            /* TERMINAL-TYPE option (start)*/\n          case _STATE_SB:\n            switch (ch) {\n              case TelnetCommand.IAC:\n                __receiveState = _STATE_IAC_SB;\n                continue;\n              default:\n                // store suboption char\n                if (__suboption_count < __suboption.length) {\n                  __suboption[__suboption_count++] = ch;\n                }\n                break;\n            }\n            __receiveState = _STATE_SB;\n            continue;\n          case _STATE_IAC_SB : // IAC received during SB phase\n            switch (ch) {\n              case TelnetCommand.SE:\n                synchronized (__client) {\n\n                  __client._processSuboption(__suboption, __suboption_count);\n\n                  __client._flushOutputStream();\n                }\n\n                __receiveState = _STATE_DATA;\n                continue;\n              case TelnetCommand.IAC : // De-dup the duplicated IAC\n                if (__suboption_count < __suboption.length) {\n                  __suboption[__suboption_count++] = ch;\n                }\n                break;\n              default :            // unexpected byte! ignore it\n                break;\n            }\n            __receiveState = _STATE_SB;\n            continue;\n            /* TERMINAL-TYPE option (end)*/\n        }\n        break;\n\n      }\n      return ch;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "162", "src_id": "M8", "code": "    private static String formatFileSize(long size) {\n      String hrSize;\n\n      double b = size;\n      double k = size / 1024.0;\n      double m = ((size / 1024.0) / 1024.0);\n      double g = (((size / 1024.0) / 1024.0) / 1024.0);\n      double t = ((((size / 1024.0) / 1024.0) / 1024.0) / 1024.0);\n\n      DecimalFormat dec = new DecimalFormat(\"0.00\");\n      if (1< t) {\n        hrSize = dec.format(t).concat(\" TB\");\n      } else {\n        if (1< g) {\n          hrSize = dec.format(g).concat(\" GB\");\n        } else {\n          if (1 >= m) {\n            if (1< k) {\n              hrSize = dec.format(k).concat(\" KB\");\n            } else {\n              hrSize = dec.format(b).concat(\" Bytes\");\n            }\n          } else {\n            hrSize = dec.format(m).concat(\" MB\");\n          } \n        }\n      }\n      return hrSize;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "163", "src_id": "M790", "code": "    @Override\n    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n    ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n      if (className == null) {\n        return null;\n      }\n      className = className.replace('/', '.');\n\n      List<RetransformEntry> allRetransformEntries = allRetransformEntries();\n      // 倒序，因为要执行的配置生效\n      ListIterator<RetransformEntry> listIterator = allRetransformEntries.listIterator(allRetransformEntries.size());\n      while (listIterator.hasPrevious()) {\n\n        RetransformEntry retransformEntry = listIterator.previous();\n\n        int id = retransformEntry.getId();\n\n        // 判断类名是否一致\n        boolean updateFlag = false;\n        // 类名一致，则看是否要比较 loader，如果不需要比较 loader，则认为成功\n        if (className.equals(retransformEntry.getClassName())) {\n          if (retransformEntry.getClassLoaderClass() != null || retransformEntry.getHashCode() != null) {\n            updateFlag = isLoaderMatch(retransformEntry, loader);\n          } else {\n            updateFlag = true;\n          }\n        }\n\n        if (updateFlag) {\n          logger.info(\"RetransformCommand match class: {}, id: {}, classLoaderClass: {}, hashCode: {}\", className, id, retransformEntry.getClassLoaderClass(), retransformEntry.getHashCode());\n          retransformEntry.incTransformCount();\n          return retransformEntry.getBytes();\n        }\n\n      }\n      return null;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "164", "src_id": "M716", "code": "    public static void drawPlayException(TableElement table, ObjectVO throwableVO) {\n      // 执行失败:输出失败状态\n      table.row(\"IS-RETURN\", \"\" + false);\n      table.row(\"IS-EXCEPTION\", \"\" + true);\n\n      // 执行失败:输出失败异常信息\n      Throwable cause;\n      Throwable t = (Throwable) throwableVO.getObject();\n      if (t instanceof InvocationTargetException) {\n        cause = t.getCause();\n      } else {\n        cause = t;\n      }\n      if (!(throwableVO.needExpand())) {\n        StringWriter stringWriter = new StringWriter();\n\n        PrintWriter printWriter = new PrintWriter(stringWriter);\n        try {\n          cause.printStackTrace(printWriter);\n\n          table.row(\"THROW-EXCEPTION\", stringWriter.toString());\n        } finally {\n          printWriter.close();\n        }\n      } else {\n        table.row(\"THROW-EXCEPTION\", \n        new ObjectView(cause, throwableVO.expandOrDefault()).draw());\n      } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "165", "src_id": "M602", "code": "    private AsyncProfiler profilerInstance() {\n      if (profiler != null) {\n        return profiler;\n      }\n      // try to load from special path\n      if (ProfilerAction.load.toString().equals(action)) {\n        profiler = AsyncProfiler.getInstance(this.actionArg);\n      }\n      if (libPath != null) {\n        // load from arthas directory\n        // 尝试把lib文件复制到临时文件里，避免多次attach时出现 Native Library already loaded in another classloader\n        FileOutputStream tmpLibOutputStream = null;\n        FileInputStream libInputStream = null;\n\n        try {\n\n          File tmpLibFile = File.createTempFile(VmTool.JNI_LIBRARY_NAME, null);\n\n          tmpLibOutputStream = new FileOutputStream(tmpLibFile);\n\n          libInputStream = new FileInputStream(libPath);\n          IOUtils.copy(libInputStream, tmpLibOutputStream);\n\n          libPath = tmpLibFile.getAbsolutePath();\n          logger.debug(\"copy {} to {}\", libPath, tmpLibFile);\n        } catch (Throwable e) {\n          logger.error(\"try to copy lib error! libPath: {}\", libPath, e);\n        } finally {\n          IOUtils.close(libInputStream);\n          IOUtils.close(tmpLibOutputStream);\n        }\n\n        profiler = AsyncProfiler.getInstance(libPath);\n      } else {\n        if (OSUtils.isLinux() || OSUtils.isMac()) {\n          throw new IllegalStateException(\"Can not find libasyncProfiler so, please check the arthas directory.\");\n        } else {\n          throw new IllegalStateException(\"Current OS do not support AsyncProfiler, Only support Linux/Mac.\");\n        }\n      }\n\n      return profiler;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "103", "src_id": "M31", "code": "    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n        String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")// .header(\"Authorization\", \"License \" + licenseKey)\n        .POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n        HttpResponse<String> response = httpClient.send(request, \n        HttpResponse.BodyHandlers.ofString());\n        log.debug(\"ValidateLicenseResponse body: {}\", \n        response.body());\n        JsonNode jsonResponse = objectMapper.readTree(response.body());\n        if (response.statusCode() != 200) {\n            log.error(\"Error validating license. Status code: {}\", \n            response.statusCode());\n        } else {\n            JsonNode metaNode = jsonResponse.path(\"meta\");\n            boolean isValid = metaNode.path(\"valid\").asBoolean();\n            String detail = metaNode.path(\"detail\").asText();\n            String code = metaNode.path(\"code\").asText();\n            log.info(\"License validity: {}\", isValid);\n            log.info(\"Validation detail: {}\", detail);\n            log.info(\"Validation code: {}\", code);\n            // Check if the license itself has floating attribute\n            JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n            if (!licenseAttrs.isMissingNode()) {\n                context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n                context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n\n                log.info(\"License floating (from license): {}, maxMachines: {}\",\n                context.isFloatingLicense,\n                context.maxMachines);\n            }\n            // Also check the policy for floating license support if included\n            JsonNode includedNode = jsonResponse.path(\"included\");\n            JsonNode policyNode = null;\n            if (includedNode.isArray()) {\n                for (JsonNode node : includedNode) {\n                    if (\"policies\".equals(node.path(\"type\").asText())) {\n                        policyNode = node;\n                        break;\n                    }\n                }\n            }\n            if (policyNode != null) {\n                // Check if this is a floating license from policy\n                boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n                int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n                // Policy takes precedence over license attributes\n                if (policyFloating) {\n                    context.isFloatingLicense = true;\n                    context.maxMachines = policyMaxMachines;\n                }\n                log.info(\"License floating (from policy): {}, maxMachines: {}\",\n                context.isFloatingLicense,\n                context.maxMachines);\n            }\n\n            // Extract user count, default to 1 if not specified\n            int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n            applicationProperties.getPremium().setMaxUsers(users);\n            // Extract isEnterprise flag\n            context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n            log.debug(applicationProperties.toString());\n        } \n        return jsonResponse;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "104", "src_id": "M488", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description =\n    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n    throws Exception {\n        MultipartFile inputFile = generalFile.getFileInput();\n        // unused but can start server instance if startup time is to long\n        // LibreOfficeListener.getInstance().start();\n        File file = null;\n        try {\n            file = convertToPdf(inputFile);\n            PDDocument doc = pdfDocumentFactory.load(file);\n            return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n        } finally {\n            if (file != null) {\n                file.delete();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "105", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n        MultipartFile inputFile = request.getFileInput();\n        boolean readonly = true;\n        try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, \n        readonly); ) {\n            ObjectMapper objectMapper = new ObjectMapper();\n            ObjectNode jsonOutput = objectMapper.createObjectNode();\n            // Metadata using PDFBox\n            PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n            ObjectNode metadata = objectMapper.createObjectNode();\n            ObjectNode basicInfo = objectMapper.createObjectNode();\n            ObjectNode docInfoNode = objectMapper.createObjectNode();\n            ObjectNode compliancy = objectMapper.createObjectNode();\n            ObjectNode encryption = objectMapper.createObjectNode();\n            ObjectNode other = objectMapper.createObjectNode();\n            metadata.put(\"Title\", info.getTitle());\n            metadata.put(\"Author\", info.getAuthor());\n            metadata.put(\"Subject\", info.getSubject());\n            metadata.put(\"Keywords\", info.getKeywords());\n            metadata.put(\"Producer\", info.getProducer());\n            metadata.put(\"Creator\", info.getCreator());\n            metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n            metadata.put(\"ModificationDate\", \n            formatDate(info.getModificationDate()));\n            jsonOutput.set(\"Metadata\", \n            metadata);\n            // Total file size of the PDF\n            long fileSizeInBytes = inputFile.getSize();\n            basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n            // Number of words, paragraphs, and images in the entire document\n            String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n            String[] words = fullText.split(\"\\\\s+\");\n            int wordCount = words.length;\n            int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n            basicInfo.put(\"WordCount\", \n            wordCount);\n            basicInfo.put(\"ParagraphCount\", paragraphCount);\n            // Number of characters in the entire document (including spaces and special characters)\n            int charCount = fullText.length();\n            basicInfo.put(\"CharacterCount\", charCount);\n            // Initialize the flags and types\n            boolean hasCompression = false;\n            String compressionType = \"None\";\n            basicInfo.put(\"Compression\", \n            hasCompression);\n            if (hasCompression) {\n                basicInfo.put(\"CompressionType\", compressionType);\n            }\n            String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n            basicInfo.put(\"Language\", \n            language);\n            basicInfo.put(\"Number of pages\", \n            pdfBoxDoc.getNumberOfPages());\n            PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n            String pageMode = catalog.getPageMode().name();\n            // Document Information using PDFBox\n            docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n            docInfoNode.put(\"Trapped\", info.getTrapped());\n            docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n            ;\n            PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n            ObjectNode formFieldsNode = objectMapper.createObjectNode();\n            if (acroForm != null) {\n                for (PDField field : acroForm.getFieldTree()) {\n                    formFieldsNode.put(field.getFullyQualifiedName(), \n                    field.getValueAsString());\n                }\n            }\n            jsonOutput.set(\"FormFields\", \n            formFieldsNode);\n            // Generate structured summary data about PDF characteristics\n            ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n\n            if (summaryData != null && 0< summaryData.size()) {\n                jsonOutput.set(\"SummaryData\", \n                summaryData);\n            }\n\n            // embeed files TODO size\n            if (catalog.getNames() != null) {\n                PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n                ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n                if (efTree != null) {\n                    Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n\n                    if (efMap != null) {\n                        for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                            ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                            embeddedFileNode.put(\"Name\", \n                            entry.getKey());\n                            PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n                            if (embeddedFile != null) {\n                                embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                            }\n                            embeddedFilesArray.add(embeddedFileNode);\n                        }\n                    }\n                }\n                other.set(\"EmbeddedFiles\", embeddedFilesArray);\n            }\n\n            // attachments TODO size\n            ArrayNode attachmentsArray = objectMapper.createArrayNode();\n            for (PDPage page : pdfBoxDoc.getPages()) {\n                for (PDAnnotation annotation : page.getAnnotations()) {\n                    if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n                        ObjectNode attachmentNode = objectMapper.createObjectNode();\n                        attachmentNode.put(\"Name\", \n                        fileAttachmentAnnotation.getAttachmentName());\n                        attachmentNode.put(\"Description\", \n                        fileAttachmentAnnotation.getContents());\n                        attachmentsArray.add(attachmentNode);\n                    }\n                }\n            }\n            other.set(\"Attachments\", attachmentsArray);\n            // Javascript\n            PDDocumentNameDictionary namesDict = catalog.getNames();\n            ArrayNode javascriptArray = objectMapper.createArrayNode();\n            if (namesDict != null) {\n                PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n                if (javascriptDict != null) {\n                    try {\n                        Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n\n                        for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                            ObjectNode jsNode = objectMapper.createObjectNode();\n                            jsNode.put(\"JS Name\", \n                            entry.getKey());\n                            PDActionJavaScript jsAction = entry.getValue();\n                            if (jsAction != null) {\n                                String jsCodeStr = jsAction.getAction();\n                                if (jsCodeStr != null) {\n                                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                                }\n                            }\n\n                            javascriptArray.add(jsNode);\n                        }\n                    } catch (IOException e) {\n                        log.error(\"exception\", e);\n                    }\n                }\n            }\n            other.set(\"JavaScript\", javascriptArray);\n            // TODO size\n            PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n            ArrayNode layersArray = objectMapper.createArrayNode();\n            if (ocProperties != null) {\n                for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n                    ObjectNode layerNode = objectMapper.createObjectNode();\n                    layerNode.put(\"Name\", \n                    ocg.getName());\n                    layersArray.add(layerNode);\n                }\n            }\n            other.set(\"Layers\", \n            layersArray);// TODO Security\n\n            PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n            ArrayNode structureTreeArray;\n            try {\n                if (structureTreeRoot != null) {\n                    structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n                    other.set(\"StructureTree\", structureTreeArray);\n                }\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                log.error(\"exception\", e);\n            }\n\n            boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \n            \"PDF/A\");\n            boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \n            \"PDF/X\");\n            boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \n            \"PDF/E\");\n            boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \n            \"PDF/VT\");\n            boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \n            \"PDF/UA\");\n            boolean isPdfBCompliant = checkForStandard(pdfBoxDoc,\n            \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n            // an official ISO standard.\n            boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc,\n            \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n            // development in 2021.\n            compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n            compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n            compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n            compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n            compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n            compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n            compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n            PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n            ArrayNode bookmarksArray = objectMapper.createArrayNode();\n            if (root != null) {\n                for (PDOutlineItem child : root.children()) {\n                    addOutlinesToArray(child, \n                    bookmarksArray);\n                }\n            }\n            other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n            PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n            String xmpString = null;\n            if (pdMetadata != null) {\n                try {\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        DomXmpParser domXmpParser = new DomXmpParser();\n                        XMPMetadata xmpMeta = domXmpParser.parse(is);\n                        ByteArrayOutputStream os = new ByteArrayOutputStream();\n                        new XmpSerializer().serialize(xmpMeta, os, true);\n                        xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n                    }\n                } catch (XmpParsingException e) {\n                    // XMP parsing failed, try to read raw metadata instead\n                    log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n                    try (COSInputStream is = pdMetadata.createInputStream()) {\n                        byte[] metadataBytes = is.readAllBytes();\n                        xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n                    }\n                } catch (IOException e) {\n                    log.error(\"exception\", e);\n                }\n            }\n            other.put(\"XMPMetadata\", \n            xmpString);\n\n            if (!(pdfBoxDoc.isEncrypted())) {\n                encryption.put(\"IsEncrypted\", \n                false);\n            } else {\n                encryption.put(\"IsEncrypted\", true);\n                // Retrieve encryption details using getEncryption()\n                PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n                encryption.put(\"EncryptionAlgorithm\", \n                pdfEncryption.getFilter());\n                encryption.put(\"KeyLength\", pdfEncryption.getLength());\n                // Add other encryption-related properties as needed\n            } \n            ObjectNode permissionsNode = objectMapper.createObjectNode();\n            setNodePermissions(pdfBoxDoc, permissionsNode);\n            ObjectNode pageInfoParent = objectMapper.createObjectNode();\n            for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n                ObjectNode pageInfo = objectMapper.createObjectNode();\n                // Retrieve the page\n                PDPage page = pdfBoxDoc.getPage(pageNum);\n                // Page-level Information\n                PDRectangle mediaBox = page.getMediaBox();\n                float width = mediaBox.getWidth();\n                float height = mediaBox.getHeight();\n                ObjectNode sizeInfo = objectMapper.createObjectNode();\n                getDimensionInfo(sizeInfo, \n                width, \n                height);\n                sizeInfo.put(\"Standard Page\", \n                getPageSize(width, \n                height));\n                pageInfo.set(\"Size\", \n                sizeInfo);\n                pageInfo.put(\"Rotation\", page.getRotation());\n                pageInfo.put(\"Page Orientation\", \n                getPageOrientation(width, \n                height));\n                // Boxes\n                pageInfo.put(\"MediaBox\", mediaBox.toString());\n                // Assuming the following boxes are defined for your document; if not, you may get\n                // null values.\n                PDRectangle cropBox = page.getCropBox();\n                pageInfo.put(\"CropBox\", \n                cropBox == null ? \"Undefined\" : cropBox.toString());\n                PDRectangle bleedBox = page.getBleedBox();\n                pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n                PDRectangle trimBox = page.getTrimBox();\n                pageInfo.put(\"TrimBox\", \n                trimBox == null ? \"Undefined\" : trimBox.toString());\n                PDRectangle artBox = page.getArtBox();\n                pageInfo.put(\"ArtBox\", \n                artBox == null ? \"Undefined\" : artBox.toString());\n                // Content Extraction\n                PDFTextStripper textStripper = new PDFTextStripper();\n                textStripper.setStartPage(pageNum + 1);\n                textStripper.setEndPage(pageNum + 1);\n                String pageText = textStripper.getText(pdfBoxDoc);\n                pageInfo.put(\"Text Characters Count\", pageText.length()); //\n                // Annotations\n\n                List<PDAnnotation> annotations = page.getAnnotations();\n\n                int subtypeCount = 0;\n                int contentsCount = 0;\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation.getSubtype() != null) {\n                        subtypeCount++; // Increase subtype count\n                    }\n                    if (annotation.getContents() != null) {\n                        contentsCount++; // Increase contents count\n                    }\n                }\n                ObjectNode annotationsObject = objectMapper.createObjectNode();\n                annotationsObject.put(\"AnnotationsCount\", annotations.size());\n                annotationsObject.put(\"SubtypeCount\", \n                subtypeCount);\n                annotationsObject.put(\"ContentsCount\", contentsCount);\n                pageInfo.set(\"Annotations\", annotationsObject);\n                // Images (simplified)\n                // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n                // Here is a basic structure to recognize image XObjects on a page.\n                ArrayNode imagesArray = objectMapper.createArrayNode();\n                PDResources resources = page.getResources();\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    if (xObject instanceof PDImageXObject image) {\n                        ObjectNode imageNode = objectMapper.createObjectNode();\n                        imageNode.put(\"Width\", image.getWidth());\n                        imageNode.put(\"Height\", image.getHeight());\n                        if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                            imageNode.put(\"Name\", \n                            image.getMetadata().getFile().getFile());\n                        }\n                        if (image.getColorSpace() != null) {\n                            imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n                        }\n                        imagesArray.add(imageNode);\n                    }\n                }\n                pageInfo.set(\"Images\", \n                imagesArray);\n                // Links\n                ArrayNode linksArray = objectMapper.createArrayNode();\n\n                Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n                for (PDAnnotation annotation : annotations) {\n                    if (annotation instanceof PDAnnotationLink linkAnnotation && linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                        String uri = uriAction.getURI();\n                        uniqueURIs.add(uri); // Add to set to ensure uniqueness\n                    }\n                }\n                // Add unique URIs to linksArray\n                for (String uri : uniqueURIs) {\n                    ObjectNode linkNode = objectMapper.createObjectNode();\n                    linkNode.put(\"URI\", uri);\n                    linksArray.add(linkNode);\n                }\n\n                pageInfo.set(\"Links\", \n                linksArray);\n                // Fonts\n                ArrayNode fontsArray = objectMapper.createArrayNode();\n                Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n                for (COSName fontName : resources.getFontNames()) {\n                    PDFont font = resources.getFont(fontName);\n                    ObjectNode fontNode = objectMapper.createObjectNode();\n                    fontNode.put(\"IsEmbedded\", font.isEmbedded());\n                    // PDFBox provides Font's BaseFont (i.e., the font name) directly\n                    fontNode.put(\"Name\", \n                    font.getName());\n                    fontNode.put(\"Subtype\", \n                    font.getType());\n                    PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n                    if (fontDescriptor != null) {\n                        fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n                        int flags = fontDescriptor.getFlags();\n                        fontNode.put(\"IsItalic\", \n                        (flags & 1) != 0);\n                        fontNode.put(\"IsBold\", \n                        (flags & 64) != 0);\n                        fontNode.put(\"IsFixedPitch\", \n                        (flags & 2) != 0);\n                        fontNode.put(\"IsSerif\", \n                        (flags & 4) != 0);\n                        fontNode.put(\"IsSymbolic\", \n                        (flags & 8) != 0);\n                        fontNode.put(\"IsScript\", \n                        (flags & 16) != 0);\n                        fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n                        fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n                        // Font stretch and BBox are not directly available in PDFBox's API, so\n                        // these are omitted for simplicity\n                        fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n                    }\n                    // Create a unique key for this font node based on its attributes\n                    String uniqueKey = fontNode.toString();\n\n                    // Increment count if this font exists, or initialize it if new\n                    if (!(uniqueFontsMap.containsKey(uniqueKey))) {\n                        fontNode.put(\"Count\", 1);\n                        uniqueFontsMap.put(uniqueKey, \n                        fontNode);\n                    } else {\n                        ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n                        int count = existingFontNode.get(\"Count\").asInt() + 1;\n                        existingFontNode.put(\"Count\", \n                        count);\n                    } \n                }\n                // Add unique font entries to fontsArray\n                for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n                    fontsArray.add(uniqueFontNode);\n                }\n                pageInfo.set(\"Fonts\", \n                fontsArray);\n\n                // Access resources dictionary\n                ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n\n                Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n                for (COSName name : colorSpaceNames) {\n                    PDColorSpace colorSpace = resources.getColorSpace(name);\n                    if (colorSpace instanceof PDICCBased iccBased) {\n                        PDStream iccData = iccBased.getPDStream();\n                        byte[] iccBytes = iccData.toByteArray();\n                        // TODO: Further decode and analyze the ICC data if needed\n                        ObjectNode iccProfileNode = objectMapper.createObjectNode();\n                        iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n                        colorSpacesArray.add(iccProfileNode);\n                    }\n                }\n                pageInfo.set(\"Color Spaces & ICC Profiles\", \n                colorSpacesArray);\n                // Other XObjects\n                Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n                for (COSName name : resources.getXObjectNames()) {\n                    PDXObject xObject = resources.getXObject(name);\n                    String xObjectType;\n                    if (xObject instanceof PDImageXObject) {\n                        xObjectType = \"Image\";\n                    } else {\n                        if (xObject instanceof PDFormXObject) {\n                            xObjectType = \"Form\";\n                        } else {\n                            xObjectType = \"Other\";\n                        }\n                        // Increment the count for this type in the map\n                    }\n                    xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n                }\n                // Add the count map to pageInfo (or wherever you want to store it)\n                ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n                for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n                    xObjectCountNode.put(entry.getKey(), entry.getValue());\n                }\n                pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n                ArrayNode multimediaArray = objectMapper.createArrayNode();\n                for (PDAnnotation annotation : annotations) {\n                    if (\"RichMedia\".equals(annotation.getSubtype())) {\n                        ObjectNode multimediaNode = objectMapper.createObjectNode();\n                        // Extract details from the annotation as needed\n                        multimediaArray.add(multimediaNode);\n                    }\n                }\n                pageInfo.set(\"Multimedia\", multimediaArray);\n                pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n            }\n            jsonOutput.set(\"BasicInfo\", \n            basicInfo);\n            jsonOutput.set(\"DocumentInfo\", \n            docInfoNode);\n            jsonOutput.set(\"Compliancy\", \n            compliancy);\n            jsonOutput.set(\"Encryption\", \n            encryption);\n            jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n            jsonOutput.set(\"Other\", \n            other);\n            jsonOutput.set(\"PerPageInfo\", \n            pageInfoParent);\n            // Save JSON to file\n            String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n            return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8),\n            \"response.json\",\n            MediaType.APPLICATION_JSON);\n\n        } catch (Exception e) {\n            log.error(\"exception\", e);\n        }\n        return null;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "106", "src_id": "M24", "code": "    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n        try {\n            String encodedPayload = licenseFile;\n            // Remove the header\n            encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n            // Remove the footer\n            encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n            // Remove all newlines\n            encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n            byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n            String payload = new String(payloadBytes);\n            log.info(\"Decoded certificate payload: {}\", payload);\n            String encryptedData = \"\";\n            String encodedSignature = \"\";\n            String algorithm = \"\";\n            try {\n                JSONObject attrs = new JSONObject(payload);\n                encryptedData = (String) attrs.get(\"enc\");\n                encodedSignature = (String) attrs.get(\"sig\");\n                algorithm = (String) attrs.get(\"alg\");\n            } catch (JSONException e) {\n                log.error(\"Failed to parse license file: {}\", e.getMessage());\n                return false;\n            }\n            // Verify license file algorithm\n            if (!\"base64+ed25519\".equals(algorithm)) {\n                log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n                return false;\n            }\n\n            // Verify signature\n            boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n\n            if (!isSignatureValid) {\n                log.error(\"License file signature is invalid\");\n                return false;\n            }\n            log.info(\"License file signature is valid\");\n            // Decode the base64 data\n            String decodedData;\n            try {\n                decodedData = new String(Base64.getDecoder().decode(encryptedData));\n            } catch (IllegalArgumentException e) {\n                log.error(\"Failed to decode license data: {}\", \n                e.getMessage());\n                return false;\n            }\n            // Process the certificate data\n            boolean isValid = processCertificateData(decodedData, \n            context);\n            return isValid;\n        } catch (Exception e) {\n            log.error(\"Error verifying certificate license: {}\", \n            e.getMessage(), e);\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "107", "src_id": "M403", "code": "    importnull;private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n    throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        ZipEntry tmp = entry.getName().toLowerCase();\n                        if (!(tmp.endsWith(\".html\") || tmp.endsWith(\".htm\"))) {\n                            Files.copy(zipIn, \n                            filePath);\n                        } else {\n                            String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } \n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "108", "src_id": "M317", "code": "    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n    throws IOException {\n        boolean imageIsLandscape = image.getHeight()< image.getWidth();\n        PDRectangle pageSize = PDRectangle.A4;\n        if (autoRotate && imageIsLandscape) {\n            pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n        }\n        if (\"fitDocumentToImage\".equals(fitOption)) {\n            pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n        }\n        PDPage page = new PDPage(pageSize);\n        doc.addPage(page);\n        float pageWidth = page.getMediaBox().getWidth();\n        float pageHeight = page.getMediaBox().getHeight();\n        try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n            if (\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption)) {\n                contentStream.drawImage(image, 0, 0, pageWidth, \n                pageHeight);\n            } else {\n                if (\"maintainAspectRatio\".equals(fitOption)) {\n                    float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n                    float pageAspectRatio = pageWidth / pageHeight;\n                    float scaleFactor = 1.0f;\n                    if (pageAspectRatio< imageAspectRatio) {\n                        scaleFactor = pageWidth / image.getWidth();\n                    } else {\n                        scaleFactor = pageHeight / image.getHeight();\n                    }\n                    float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n                    float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n                    contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor,\n                    image.getHeight() * scaleFactor);\n                }\n            }\n        } catch (IOException e) {\n            log.error(\"Error adding image to PDF\", e);\n            throw e;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "109", "src_id": "M307", "code": "    public static String generateMachineFingerprint() {\n        try {\n            // Get the MAC address\n            StringBuilder sb = new StringBuilder();\n            InetAddress ip = InetAddress.getLocalHost();\n            NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n            if (network != null) {\n                byte[] mac = network.getHardwareAddress();\n                if (mac != null) {\n                    for (int i = 0; i < mac.length; i++) {\n                        sb.append(String.format(\"%02X\", \n                        mac[i]));\n                    }\n                }\n            }// Hash the MAC address for privacy and consistency\n            else {\n                Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n                while (networks.hasMoreElements()) {\n                    NetworkInterface net = networks.nextElement();\n                    byte[] mac = net.getHardwareAddress();\n                    if (mac != null) {\n                        for (int i = 0; i < mac.length; i++) {\n                            sb.append(String.format(\"%02X\", \n                            mac[i]));\n                        }\n                        break; // Use the first network interface with a MAC address\n                    }\n                }\n            } \n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n            StringBuilder fingerprint = new StringBuilder();\n            for (byte b : hash) {\n                fingerprint.append(String.format(\"%02x\", b));\n            }\n            return fingerprint.toString();\n        } catch (Exception e) {\n            return \"GenericID\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "110", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n        String title = pdfMetadata.getTitle();\n        pdf.getDocumentInformation().setTitle(title);\n        pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n        pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n        pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n        pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n        String author = pdfMetadata.getAuthor();\n        if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n            author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n            if (userService != null) {\n                author = author.replace(\"username\", userService.getCurrentUsername());\n            }\n        }\n        pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "111", "src_id": "M128", "code": "    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n        try {\n            boolean isDocker = runningInDocker();\n            boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n\n            boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n            if (!isKubernetes) {\n                if (isDocker) {\n                    return \"Docker\";\n                } else {\n                    if (!isBrowserOpen) {\n                        return \"Server-jar\";\n                    } else {\n                        String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n                        if (os.contains(\"win\")) {\n                            return \"Client-windows\";\n                        } else {\n                            if (os.contains(\"mac\")) {\n                                return \"Client-mac\";\n                            } else {\n                                return \"Client-unix\";\n                            }\n                        }\n                    } \n                }\n            }else {\n                return \"Kubernetes\";\n            } \n        } catch (Exception e) {\n            return \"Unknown\";\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "112", "src_id": "M101", "code": "    private void processRequest(int limitPerDay, String identifier, Map<String, Bucket> buckets,\n    HttpServletRequest request,\n    HttpServletResponse response, FilterChain filterChain)\n    throws IOException, ServletException {\n        Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n        ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n        if (probe.isConsumed()) {\n            response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n            filterChain.doFilter(request, \n            response);\n        } else {\n            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n            response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\",\n            Newlines.stripAll(String.valueOf(waitForRefill)));\n            response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "22", "src_id": "M1277", "code": "    public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = new HashMap<>(input.size());\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n            String key = entry.getKey();\n            Object obj = entry.getValue();\n            if (key == null || obj == null) {\n                throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n            }\n            String str;\n            if (!(obj instanceof byte[])) {\n                if (obj instanceof redis.clients.jedis.GeoCoordinate) {\n                    redis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\n                    str = geo.getLongitude() + \",\" + geo.getLatitude();\n                } else {\n                    if (obj instanceof String) {\n                        if (stringEscape) { \n                            str = escape((String) obj); \n                        } else { \n                            str = (String) obj; \n                        } \n                    } else {\n                        str = String.valueOf(obj);\n                    }\n                }\n            }else {\n                str = SafeEncoder.encode((byte[]) obj);\n            } \n            output.put(key, str);\n        }\n\n        return output;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "23", "src_id": "M902", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "24", "src_id": "M1131", "code": "    private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n            case PLUS_BYTE:\n                return is.readLineBytes();\n            case DOLLAR_BYTE:\n            case EQUAL_BYTE:\n                return processBulkReply(is);\n            case ASTERISK_BYTE:\n                return processMultiBulkReply(is);\n            case UNDERSCORE_BYTE:\n                return is.readNullCrLf();\n            case HASH_BYTE:\n                return is.readBooleanCrLf();\n            case COLON_BYTE:\n                return is.readLongCrLf();\n            case COMMA_BYTE:\n                return is.readDoubleCrLf();\n            case LEFT_BRACE_BYTE:\n                return is.readBigIntegerCrLf();\n            case PERCENT_BYTE : // TODO: currently just to start working with HELLO\n                return processMapKeyValueReply(is);\n            case TILDE_BYTE : // TODO:\n                return processMultiBulkReply(is);\n            case GREATER_THAN_BYTE:\n                return processMultiBulkReply(is);\n            case MINUS_BYTE:\n                processError(is);\n\n                return null;\n                // TODO: Blob error '!'\n            default:\n                throw new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "25", "src_id": "M1057", "code": "    importnull;@Override\n    public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n        if (list == null || list.isEmpty()) {\n            return null;\n        }\n\n        Listtmp = list.get(0);\n        if (tmp instanceof KeyValue) { // RESP3\n            Object resultsData = null, profileData = null;\n\n            for (KeyValue keyValue : (List<KeyValue>) data) {\n                String keyStr = BuilderFactory.STRING.build(keyValue.getKey());\n                switch (keyStr) {\n                    case PROFILE_STR_REDIS7:\n                    case PROFILE_STR_REDIS8:\n                        profileData = keyValue.getValue();\n                        break;\n                    case RESULTS_STR_REDIS7:\n                        resultsData = data;\n\n                        break;\n                    case RESULTS_STR_REDIS8:\n                        resultsData = keyValue.getValue();\n                        break;\n                }\n            }\n            assert resultsData != null : \"Could not detect Results data.\";\n            assert profileData != null : \"Could not detect Profile data.\";\n            return KeyValue.of(\n            resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue.of(\n        resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "26", "src_id": "M1229", "code": "    public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode != SslVerifyMode.FULL) {\n            if (sslVerifyMode == SslVerifyMode.CA) {\n                this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n            } else {\n                if (sslVerifyMode == SslVerifyMode.INSECURE) {\n                    trustManagers = new TrustManager[] { \n                    INSECURE_TRUST_MANAGER };\n                }\n            }\n        }else {\n            this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } \n        if (keystoreResource != null) {\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n            try (InputStream keystoreStream = keystoreResource.get()) {\n                keyStore.load(keystoreStream, keystorePassword);\n            }\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n            keyManagerFactory.init(keyStore, keystorePassword);\n            keyManagers = keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n            KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n            try (InputStream truststoreStream = truststoreResource.get()) {\n                trustStore.load(truststoreStream, truststorePassword);\n            }\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n            trustManagerFactory.init(trustStore);\n            trustManagers = trustManagerFactory.getTrustManagers();\n        }\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n\n        sslContext.init(keyManagers, trustManagers, null);\n\n        return sslContext;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "27", "src_id": "M894", "code": "    @Override\n    public TSInfo build(Object data) {\n        List<KeyValue> list = (List<KeyValue>) data;\n        Map<String, Object> properties = new HashMap<>();\n        Map<String, String> labels = null;\n        Map<String, Rule> rules = null;\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n            String prop = BuilderFactory.STRING.build(propertyValue.getKey());\n            Object value = propertyValue.getValue();\n            if (!(value instanceof List)) {\n                if (value instanceof byte[]) {\n                    value = BuilderFactory.STRING.build(value);\n                    if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                        try {\n                            value = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                        } catch (Exception e) { \n                        }\n                    }\n                }\n            } else {\n                switch (prop) {\n                    case LABELS_PROPERTY:\n                        labels = BuilderFactory.STRING_MAP.build(value);\n\n                        value = labels;\n\n                        break;\n                    case RULES_PROPERTY:\n                        List<KeyValue> rulesDataList = (List<KeyValue>) value;\n\n                        Map<String, List<Object>> rulesValueMap = \n                        new HashMap<>(rulesDataList.size(), 1f);\n                        rules = new HashMap<>(rulesDataList.size());\n                        for (KeyValue rkv : rulesDataList) {\n                            String ruleName = BuilderFactory.STRING.build(rkv.getKey());\n                            List<Object> ruleValueList = BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                            rulesValueMap.put(ruleName, ruleValueList);\n                            rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                        }\n                        value = rulesValueMap;\n                        break;\n                    case CHUNKS_PROPERTY:\n                        List<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\n\n                        List<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\n                        chunks = new ArrayList<>(chunksDataList.size());\n                        for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                            Map<String, Object> chunk = chunkDataAsList.stream().collect(Collectors.toMap(\n                            kv -> BuilderFactory.STRING.build(kv.getKey()), kv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                            chunksValueList.add(chunk);\n\n                            chunks.add(chunk);\n                        }\n                        value = chunksValueList;\n                        break;\n                    default:\n                        value = SafeEncoder.encodeObject(value);\n\n                        break;\n                }\n            } \n            properties.put(prop, value);\n        }\n        return new TSInfo(properties, labels, rules, chunks);\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "28", "src_id": "M897", "code": "    @Override\n    public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n            args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n            args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n            args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null || duplicatePolicy != null) {\n            args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n            args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n        if (ignore) {\n            args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n            args.add(LABELS);\n            labels.entrySet().forEach((entry) -> args.add(entry.getKey()).add(entry.getValue()));\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "29", "src_id": "M1213", "code": "    @Override\n    public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n            Connection jedis = null;\n            try {\n                jedis = pool.getResource();\n                if (jedis == null) {\n                    continue;\n                }\n                jedis.ping();\n\n                return jedis;\n            } catch (JedisException ex) {\n                if (suppressed == null) { // remembering first suppressed exception\n                    suppressed = ex;\n                }\n                if (jedis != null) {\n                    jedis.close();\n                }\n            }\n        }\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n        if (suppressed != null) {\n            noReachableNode.addSuppressed(suppressed);\n        }\n        throw noReachableNode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "30", "src_id": "M9", "code": "    @Override\n    public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n        try {\n            entry = putIntoStore(cacheKey, entry);\n\n            EvictionPolicy policy = getEvictionPolicy();\n            policy.touch(cacheKey);\n            CacheKey evictedKey = policy.evictNext();\n            if (evictedKey != null) {\n                delete(evictedKey);\n                stats.evict();\n            }\n            for (Object redisKey : cacheKey.getRedisKeys()) {\n                ByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\n                if (redisKeysToCacheKeys.containsKey(mapKey)) {\n                    redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                } else {\n                    Set<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n                    set.add(cacheKey);\n                    redisKeysToCacheKeys.put(mapKey, set);\n                }\n            }\n            stats.load();\n\n            return entry;\n        } finally {\n            lock.unlock();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "31", "src_id": "M1105", "code": "    @Override\n    public Class<?> build(Object data) {\n        if (data == null) {\n            return null;\n        }\n        String str = STRING.build(data);\n        switch (str) {\n            case \"null\":\n                return null;\n            case \"boolean\":\n                return boolean.class;\n            case \"integer\":\n                return int.class;\n            case \"number\":\n                return float.class;\n            case \"string\":\n                return String.class;\n            case \"object\":\n                return Object.class;\n            case \"array\":\n                return List.class;\n            default:\n                throw new JedisException(\"Unknown type: \" + str);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "62", "src_id": "M342", "code": "    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n        if (emlBytes == null) {\n            throw new IllegalArgumentException(\"EML file is empty or null\");\n        }\n\n        if (emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n            }\n        String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n        // Basic email parsing\n        String subject = extractBasicHeader(emlContent, \"Subject:\");\n\n        String from = extractBasicHeader(emlContent, \"From:\");\n        String to = extractBasicHeader(emlContent, \"To:\");\n        String cc = extractBasicHeader(emlContent, \"Cc:\");\n        String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n        String date = extractBasicHeader(emlContent, \"Date:\");\n        // Try to extract HTML content\n        String htmlBody = extractHtmlBody(emlContent);\n        if (htmlBody == null) {\n            String textBody = extractTextBody(emlContent);\n            htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n        }\n        // Generate HTML with custom styling based on request\n        StringBuilder html = new StringBuilder();\n\n        html.append(\"<!DOCTYPE html>\\n\");\n\n        html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n\n        html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n\n        html.append(\"<style>\\n\");\n\n        appendEnhancedStyles(html);\n        html.append(\"</style>\\n\");\n        html.append(\"</head><body>\\n\");\n        html.append(\"<div class=\\\"email-container\\\">\\n\");\n        html.append(\"<div class=\\\"email-header\\\">\\n\");\n        html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n        html.append(\"<div class=\\\"email-meta\\\">\\n\");\n        html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n        html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n        // Include CC and BCC if present and requested\n        if (request != null && request.isIncludeAllRecipients()) {\n            if (!cc.trim().isEmpty()) {\n                html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n            }\n            if (!bcc.trim().isEmpty()) {\n                html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n            }\n        }\n\n        if (!date.trim().isEmpty()) {\n            html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n        }\n        html.append(\"</div></div>\\n\");\n\n        html.append(\"<div class=\\\"email-body\\\">\\n\");\n\n        html.append(processEmailHtmlBody(htmlBody));\n        html.append(\"</div>\\n\");\n\n        // Add attachment information - always check for and display attachments\n        String attachmentInfo = extractAttachmentInfo(emlContent);\n        if (!attachmentInfo.isEmpty()) {\n            html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n            html.append(\"<h3>Attachments</h3>\\n\");\n\n            html.append(attachmentInfo);\n\n            // Add a status message about attachment inclusion\n            if (request != null && request.isIncludeAttachments()) {\n                html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n                html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n                html.append(\"</div>\\n\");\n            } else {\n                html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n                html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n                html.append(\"</div>\\n\");\n            }\n            html.append(\"</div>\\n\");\n        }\n        // Show advanced features status if requested\n        assert request != null;\n\n        if (request.getFileInput().isEmpty()) {\n            html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n            html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n            html.append(\"</div>\\n\");\n        }\n        html.append(\"</div>\\n\");\n        html.append(\"</body></html>\");\n        return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "63", "src_id": "M371", "code": "    private static boolean isValidJakartaMailMultipart(Object multipart) {\n        if (multipart == null) {\n            return false;\n        }\n        try {\n            // Check if the object implements jakarta.mail.Multipart interface\n            Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n            if (!multipartInterface.isInstance(multipart)) {\n                return false;\n            }\n            // Additional check for MimeMultipart\n            try {\n                Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n                if (mimeMultipartClass.isInstance(multipart)) {\n                    log.debug(\"Found MimeMultipart instance for enhanced processing\");\n                    return true;\n                }\n            } catch (ClassNotFoundException e) {\n                log.debug(\"MimeMultipart not available, using base Multipart interface\");\n            }\n\n            return true;\n        } catch (ClassNotFoundException e) {\n            log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n            return false;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "64", "src_id": "M348", "code": "    private static String extractBasicHeader(String emlContent, String headerName) {\n        try {\n            String[] lines = emlContent.split(\"\\r?\\n\");\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n                    StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n                    // Handle multi-line headers\n                    for (int j = i + 1; j < lines.length; j++) {\n                        if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) { \n                            value.append(\" \").append(lines[j].trim());\n                            continue; \n                        }  \n                        break;\n                    }\n                    // Apply MIME header decoding\n                    return safeMimeDecode(value.toString());\n                }\n                if (line.trim().isEmpty()) {\n                    break;\n                }\n            }\n        } catch (RuntimeException e) {\n            log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n        }\n        return \"\";\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "65", "src_id": "M364", "code": "    private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n        if (document.getNumberOfPages() == 0 || attachments == null) {\n            return;\n        }\n        // 1. Find the screen position of all attachment markers\n        if (attachments.isEmpty()) {\n        return;\n            }\n\n        // 1. Find the screen position of all attachment markers\n        AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n\n        finder.setSortByPosition(true); // Process pages in order\n\n        finder.getText(document);\n        List<MarkerPosition> markerPositions = finder.getPositions();\n        // 2. Warn if the number of markers and attachments don't match\n        if (markerPositions.size() != attachments.size()) {\n            log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n        }\n\n        // 3. Create an invisible annotation over each found marker\n        int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n\n        for (int i = 0; i < annotationsToAdd; i++) {\n            MarkerPosition position = markerPositions.get(i);\n            EmailAttachment attachment = attachments.get(i);\n            if (attachment.getEmbeddedFilename() == null) { \n                continue ; \n            }  \n            PDPage page = document.getPage(position.getPageIndex());\n            addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "132", "src_id": "M342", "code": "    private static String convertEmlToHtmlBasic(byte[] emlBytes, EmlToPdfRequest request) {\n      if (emlBytes == null || emlBytes.length == 0) {\n        throw new IllegalArgumentException(\"EML file is empty or null\");\n      }\n      String emlContent = new String(emlBytes, StandardCharsets.UTF_8);\n      // Basic email parsing\n      String subject = extractBasicHeader(emlContent, \"Subject:\");\n      String from = extractBasicHeader(emlContent, \"From:\");\n      String to = extractBasicHeader(emlContent, \"To:\");\n      String cc = extractBasicHeader(emlContent, \"Cc:\");\n      String bcc = extractBasicHeader(emlContent, \"Bcc:\");\n      String date = extractBasicHeader(emlContent, \"Date:\");\n      // Try to extract HTML content\n      String htmlBody = extractHtmlBody(emlContent);\n      if (htmlBody == null) {\n        String textBody = extractTextBody(emlContent);\n        htmlBody = convertTextToHtml(textBody != null ? textBody : \"Email content could not be parsed\");\n      }\n\n      // Generate HTML with custom styling based on request\n      StringBuilder html = new StringBuilder();\n      html.append(\"<!DOCTYPE html>\\n\");\n      html.append(\"<html><head><meta charset=\\\"UTF-8\\\">\\n\");\n\n      html.append(\"<title>\").append(escapeHtml(subject)).append(\"</title>\\n\");\n\n      html.append(\"<style>\\n\");\n\n      appendEnhancedStyles(html);\n\n      html.append(\"</style>\\n\");\n\n      html.append(\"</head><body>\\n\");\n\n      html.append(\"<div class=\\\"email-container\\\">\\n\");\n      html.append(\"<div class=\\\"email-header\\\">\\n\");\n\n      html.append(\"<h1>\").append(escapeHtml(subject)).append(\"</h1>\\n\");\n\n      html.append(\"<div class=\\\"email-meta\\\">\\n\");\n      html.append(\"<div><strong>From:</strong> \").append(escapeHtml(from)).append(\"</div>\\n\");\n      html.append(\"<div><strong>To:</strong> \").append(escapeHtml(to)).append(\"</div>\\n\");\n\n      // Include CC and BCC if present and requested\n      if (request != null && request.isIncludeAllRecipients()) {\n        if (!cc.trim().isEmpty()) {\n          html.append(\"<div><strong>CC:</strong> \").append(escapeHtml(cc)).append(\"</div>\\n\");\n        }\n        if (!bcc.trim().isEmpty()) {\n          html.append(\"<div><strong>BCC:</strong> \").append(escapeHtml(bcc)).append(\"</div>\\n\");\n        }\n      }\n\n      if (!date.trim().isEmpty()) {\n        html.append(\"<div><strong>Date:</strong> \").append(escapeHtml(date)).append(\"</div>\\n\");\n      }\n\n      html.append(\"</div></div>\\n\");\n      html.append(\"<div class=\\\"email-body\\\">\\n\");\n      html.append(processEmailHtmlBody(htmlBody));\n      html.append(\"</div>\\n\");\n      // Add attachment information - always check for and display attachments\n      String attachmentInfo = extractAttachmentInfo(emlContent);\n      if (!attachmentInfo.isEmpty()) {\n        html.append(\"<div class=\\\"attachment-section\\\">\\n\");\n\n        html.append(\"<h3>Attachments</h3>\\n\");\n        html.append(attachmentInfo);\n        // Add a status message about attachment inclusion\n        if (request != null && request.isIncludeAttachments()) {\n          html.append(\"<div class=\\\"attachment-inclusion-note\\\">\\n\");\n          html.append(\"<p><strong>Note:</strong> Attachments are saved as external files and linked in this PDF. Click the links to open files externally.</p>\\n\");\n          html.append(\"</div>\\n\");\n        } else {\n          html.append(\"<div class=\\\"attachment-info-note\\\">\\n\");\n\n          html.append(\"<p><em>Attachment information displayed - files not included in PDF. Enable 'Include attachments' to embed files.</em></p>\\n\");\n          html.append(\"</div>\\n\");\n        }\n        html.append(\"</div>\\n\");\n      }\n      // Show advanced features status if requested\n      assert request != null;\n      if (request.getFileInput().isEmpty()) {\n        html.append(\"<div class=\\\"advanced-features-notice\\\">\\n\");\n        html.append(\"<p><em>Note: Some advanced features require Jakarta Mail dependencies.</em></p>\\n\");\n        html.append(\"</div>\\n\");\n      }\n      html.append(\"</div>\\n\");\n      html.append(\"</body></html>\");\n      return html.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "133", "src_id": "M371", "code": "    private static boolean isValidJakartaMailMultipart(Object multipart) {\n      if (multipart == null) {\n        return false;\n      }\n      try {\n        // Check if the object implements jakarta.mail.Multipart interface\n        Class<?> multipartInterface = Class.forName(\"jakarta.mail.Multipart\");\n        if (!multipartInterface.isInstance(multipart)) {\n          return false;\n        }\n        // Additional check for MimeMultipart\n        try {\n          Class<?> mimeMultipartClass = Class.forName(\"jakarta.mail.internet.MimeMultipart\");\n          if (mimeMultipartClass.isInstance(multipart)) {\n            log.debug(\"Found MimeMultipart instance for enhanced processing\");\n            return true;\n          }\n        } catch (ClassNotFoundException e) {\n          log.debug(\"MimeMultipart not available, using base Multipart interface\");\n        }\n        return true;\n\n      } catch (ClassNotFoundException e) {\n\n        log.debug(\"Jakarta Mail Multipart interface not available for validation\");\n\n        return false;\n\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "134", "src_id": "M348", "code": "    private static String extractBasicHeader(String emlContent, String headerName) {\n      try {\n        String[] lines = emlContent.split(\"\\r?\\n\");\n        for (int i = 0; i < lines.length; i++) {\n          String line = lines[i];\n          if (line.toLowerCase().startsWith(headerName.toLowerCase())) {\n\n            StringBuilder value = new StringBuilder(line.substring(headerName.length()).trim());\n\n            // Handle multi-line headers\n            for (int j = i + 1; j < lines.length; j++) {\n              if (lines[j].startsWith(\" \") || lines[j].startsWith(\"\\t\")) {\n                value.append(\" \").append(lines[j].trim());\n              } else {\n                break;\n              }\n            }\n\n            // Apply MIME header decoding\n            return safeMimeDecode(value.toString());\n          }\n          if (line.trim().isEmpty()) {\n            break;\n          }\n        }\n      } catch (RuntimeException e) {\n        log.warn(\"Error extracting header '{}': {}\", headerName, e.getMessage());\n      }\n      return \"\";\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "135", "src_id": "M364", "code": "    private static void addAttachmentAnnotationsToDocument(PDDocument document, List<EmailAttachment> attachments) throws IOException {\n\n      if (document.getNumberOfPages() == 0 || attachments == null || attachments.isEmpty()) {\n        return;\n      }\n\n      // 1. Find the screen position of all attachment markers\n      AttachmentMarkerPositionFinder finder = new AttachmentMarkerPositionFinder();\n\n      finder.setSortByPosition(true); // Process pages in order\n\n      finder.getText(document);\n\n      List<MarkerPosition> markerPositions = finder.getPositions();\n      // 2. Warn if the number of markers and attachments don't match\n      if (markerPositions.size() != attachments.size()) {\n        log.warn(\"Found {} attachment markers, but there are {} attachments. Annotation count may be incorrect.\", markerPositions.size(), attachments.size());\n      }\n\n      // 3. Create an invisible annotation over each found marker\n      int annotationsToAdd = Math.min(markerPositions.size(), attachments.size());\n      for (int i = 0; i < annotationsToAdd; i++) {\n        MarkerPosition position = markerPositions.get(i);\n\n        EmailAttachment attachment = attachments.get(i);\n        if (attachment.getEmbeddedFilename() != null) {\n          PDPage page = document.getPage(position.getPageIndex());\n\n          addAttachmentAnnotationToPage(document, page, attachment, position.getX(), position.getY());\n        }\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "73", "src_id": "M1277", "code": "        public static Map<String, String> toStringMap(Map<String, Object> input, boolean stringEscape) {\n            Map<String, String> output=new HashMap<>(input.size());\n            for (Map.Entry<String, Object> entry : input.entrySet()) {\n                String key=entry.getKey();\n                Object obj=entry.getValue();\n                if (key==null||obj==null) {\n                    throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n                }\n                String str;\n                if (!(objinstanceofbyte[])) {\n                    if (!(objinstanceofredis.clients.jedis.GeoCoordinate)) {\n                        if (objinstanceofString) {\n                            str=stringEscape ? escape((String) obj) : (String) obj;\n                        } else {\n                            str=String.valueOf(obj);\n                        }\n                    } else {\n                        redis.clients.jedis.GeoCoordinate geo=(redis.clients.jedis.GeoCoordinate) obj;\n                        str=geo.getLongitude()+\",\"+geo.getLatitude();\n                    } \n                }else {\n                    str=SafeEncoder.encode((byte[]) obj);\n                } \n\n                output.put(key, str);\n            }\n            return output;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "74", "src_id": "M902", "code": "        @Override\n        public void addParams(CommandArguments args) {\n            if (retentionPeriod!=null) {\n                args.add(RETENTION).add(toByteArray(retentionPeriod));\n            }\n            if (encoding!=null) {\n                args.add(ENCODING).add(encoding);\n            }\n            if (chunkSize!=null) {\n                args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n            }\n            if (duplicatePolicy!=null) {\n                args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n            }\n            if (ignore) {\n                args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n            }\n            if (labels!=null) {\n                args.add(LABELS);\n                labels.entrySet().forEach((entry)->args.add(entry.getKey()).add(entry.getValue()));\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "75", "src_id": "M1131", "code": "        private static Object process(final RedisInputStream is) {\n            final byte b=is.readByte();\n            // System.out.println(\"BYTE: \" + (char) b);\n            switch (b) {\n                case PLUS_BYTE:\n                    return is.readLineBytes();\n                case DOLLAR_BYTE:\n                case EQUAL_BYTE:\n                    return processBulkReply(is);\n                case ASTERISK_BYTE:\n                    return processMultiBulkReply(is);\n                case UNDERSCORE_BYTE:\n                    return is.readNullCrLf();\n                case HASH_BYTE:\n                    return is.readBooleanCrLf();\n                case COLON_BYTE:\n                    return is.readLongCrLf();\n                case COMMA_BYTE:\n                    return is.readDoubleCrLf();\n                case LEFT_BRACE_BYTE:\n                    return is.readBigIntegerCrLf();\n                case PERCENT_BYTE: // TODO: currently just to start working with HELLO\n                    return processMapKeyValueReply(is);\n                case TILDE_BYTE: // TODO:\n                    return processMultiBulkReply(is);\n                case GREATER_THAN_BYTE:\n                    return processMultiBulkReply(is);\n                case MINUS_BYTE:\n                    processError(is);\n\n                    return null;\n                    // TODO: Blob error '!'\n                default:\n                    throw new JedisConnectionException(\"Unknown reply: \"+(char) b);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "76", "src_id": "M1057", "code": "        @Override\n        public Map.Entry<T, ProfilingInfo> build(Object data) {\n            List list=(List) data;\n            if (list==null||list.isEmpty()) {\n                return null;\n            }\n\n            if (list.get(0)instanceofKeyValue) { // RESP3\n                Object resultsData=null, profileData=null;\n                for (KeyValue keyValue : (List<KeyValue>) data) {\n                    String keyStr=BuilderFactory.STRING.build(keyValue.getKey());\n                    switch (keyStr) {\n                        case PROFILE_STR_REDIS7:\n                        case PROFILE_STR_REDIS8:\n                            profileData=keyValue.getValue();\n                            break;\n                        case RESULTS_STR_REDIS7:\n                            resultsData=data;\n\n                            break;\n                        case RESULTS_STR_REDIS8:\n                            resultsData=keyValue.getValue();\n                            break;\n                    }\n\n                }\n                assert resultsData!=null : \"Could not detect Results data.\";\n                assert profileData!=null : \"Could not detect Profile data.\";\n                return KeyValue.of(resultsBuilder.build(resultsData), ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n            }\n            return KeyValue.of(resultsBuilder.build(list.get(0)), ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "77", "src_id": "M1229", "code": "        public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n            KeyManager[] keyManagers=null;\n            TrustManager[] trustManagers=null;\n            if (sslVerifyMode==SslVerifyMode.FULL) {\n                this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n            } else {\n                if (sslVerifyMode==SslVerifyMode.CA) {\n                    this.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n                } else {\n                    if (sslVerifyMode==SslVerifyMode.INSECURE) {\n                        trustManagers=new TrustManager[] { \n                        INSECURE_TRUST_MANAGER };\n                    }\n                }\n            }\n            if (keystoreResource!=null) {\n                KeyStore keyStore=KeyStore.getInstance(keyStoreType);\n                try (InputStream keystoreStream=keystoreResource.get()) {\n                    keyStore.load(keystoreStream, keystorePassword);\n                }\n                KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(keyManagerAlgorithm);\n                keyManagerFactory.init(keyStore, keystorePassword);\n                keyManagers=keyManagerFactory.getKeyManagers();\n            }\n\n            if (trustManagers==null&&truststoreResource!=null) {\n                KeyStore trustStore=KeyStore.getInstance(trustStoreType);\n                try (InputStream truststoreStream=truststoreResource.get()) {\n                    trustStore.load(truststoreStream, truststorePassword);\n                }\n                TrustManagerFactory trustManagerFactory=TrustManagerFactory.getInstance(trustManagerAlgorithm);\n                trustManagerFactory.init(trustStore);\n                trustManagers=trustManagerFactory.getTrustManagers();\n            }\n            SSLContext sslContext=SSLContext.getInstance(sslProtocol);\n            sslContext.init(keyManagers, trustManagers, null);\n\n            return sslContext;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "78", "src_id": "M894", "code": "        @Override\n        public TSInfo build(Object data) {\n            List<KeyValue> list=(List<KeyValue>) data;\n            Map<String, Object> properties=new HashMap<>();\n            Map<String, String> labels=null;\n            Map<String, Rule> rules=null;\n            List<Map<String, Object>> chunks=null;\n            for (KeyValue propertyValue : list) {\n                String prop=BuilderFactory.STRING.build(propertyValue.getKey());\n                Object value=propertyValue.getValue();\n                if (valueinstanceofList) {\n                    switch (prop) {\n                        case LABELS_PROPERTY:\n                            labels=BuilderFactory.STRING_MAP.build(value);\n                            value=labels;\n\n                            break;\n                        case RULES_PROPERTY:\n                            List<KeyValue> rulesDataList=(List<KeyValue>) value;\n                            Map<String, List<Object>> rulesValueMap=new HashMap<>(rulesDataList.size(), 1f);\n                            rules=new HashMap<>(rulesDataList.size());\n                            for (KeyValue rkv : rulesDataList) {\n                                String ruleName=BuilderFactory.STRING.build(rkv.getKey());\n                                List<Object> ruleValueList=BuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n                                rulesValueMap.put(ruleName, ruleValueList);\n                                rules.put(ruleName, new Rule(ruleName, ruleValueList));\n                            }\n                            value=rulesValueMap;\n\n                            break;\n                        case CHUNKS_PROPERTY:\n                            List<List<KeyValue>> chunksDataList=(List<List<KeyValue>>) value;\n\n                            List<Map<String, Object>> chunksValueList=new ArrayList<>(chunksDataList.size());\n\n                            chunks=new ArrayList<>(chunksDataList.size());\n                            for (List<KeyValue> chunkDataAsList : chunksDataList) {\n                                Map<String, Object> chunk=chunkDataAsList.stream().collect(Collectors.toMap(kv->BuilderFactory.STRING.build(kv.getKey()), kv->BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\n                                chunksValueList.add(chunk);\n                                chunks.add(chunk);\n                            }\n                            value=chunksValueList;\n\n                            break;\n                        default:\n                            value=SafeEncoder.encodeObject(value);\n\n                            break;\n                    }\n                } else {\n                    if (valueinstanceofbyte[]) {\n                        value=BuilderFactory.STRING.build(value);\n                        if (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\n                            try {\n                                value=DuplicatePolicy.valueOf(((String) value).toUpperCase());\n                            } catch (Exception e) { \n                            }\n                        }\n                    }\n                }\n                properties.put(prop, value);\n            }\n            return new TSInfo(properties, labels, rules, chunks);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "79", "src_id": "M897", "code": "        @Override\n        public void addParams(CommandArguments args) {\n            if (retentionPeriod!=null) {\n                args.add(RETENTION).add(toByteArray(retentionPeriod));\n            }\n            if (encoding!=null) {\n                args.add(ENCODING).add(encoding);\n            }\n            if (chunkSize!=null) {\n                args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n            }\n            if (duplicatePolicy!=null) {\n                args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n            }\n            if (duplicatePolicy!=null) {\n                args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n            }\n\n            if (onDuplicate!=null) {\n                args.add(ON_DUPLICATE).add(onDuplicate);\n            }\n            if (ignore) {\n                args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n            }\n            if (labels!=null) {\n                args.add(LABELS);\n                labels.entrySet().forEach((entry)->args.add(entry.getKey()).add(entry.getValue()));\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "80", "src_id": "M1213", "code": "        @Override\n        public Connection getConnection() {\n            List<ConnectionPool> pools=getShuffledNodesPool();\n            JedisException suppressed=null;\n            for (ConnectionPool pool : pools) {\n                Connection jedis=null;\n                try {\n                    jedis=pool.getResource();\n                    if (jedis!=null) { jedis.ping();\n                        return jedis;\n                    } \n                } catch (JedisException ex) {\n                    if (suppressed==null) { // remembering first suppressed exception\n                        suppressed=ex;\n                    }\n                    if (jedis!=null) {\n                        jedis.close();\n                    }\n                }\n            }\n            JedisException noReachableNode=new JedisException(\"No reachable shard.\");\n            if (suppressed!=null) {\n                noReachableNode.addSuppressed(suppressed);\n            }\n            throw noReachableNode;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "81", "src_id": "M9", "code": "        @Override\n        public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n            lock.lock();\n            try {\n                entry=putIntoStore(cacheKey, entry);\n                EvictionPolicy policy=getEvictionPolicy();\n                policy.touch(cacheKey);\n                CacheKey evictedKey=policy.evictNext();\n                if (evictedKey!=null) {\n                    delete(evictedKey);\n                    stats.evict();\n                }\n                for (Object redisKey : cacheKey.getRedisKeys()) {\n                    ByteBuffer mapKey=makeKeyForRedisKeysToCacheKeys(redisKey);\n                    if (!(redisKeysToCacheKeys.containsKey(mapKey))) {\n                        Set<CacheKey<?>> set=ConcurrentHashMap.newKeySet();\n                        set.add(cacheKey);\n\n                        redisKeysToCacheKeys.put(mapKey, set);\n                    }\n                    else {\n                        redisKeysToCacheKeys.get(mapKey).add(cacheKey);\n                    } \n                }\n                stats.load();\n\n                return entry;\n            } finally {\n                lock.unlock();\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "82", "src_id": "M1105", "code": "        @Override\n        public Class<?> build(Object data) {\n            if (data==null) {\n                return null;\n            }\n            String str=STRING.build(data);\n            switch (str) {\n                case \"null\":\n                    return null;\n                case \"boolean\":\n                    return boolean.class;\n                case \"integer\":\n                    return int.class;\n                case \"number\":\n                    return float.class;\n                case \"string\":\n                    return String.class;\n                case \"object\":\n                    return Object.class;\n                case \"array\":\n                    return List.class;\n                default:\n                    throw new JedisException(\"Unknown type: \"+str);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "93", "src_id": "M267", "code": "    @Override\n    public void startElement(\n    XlsxReadContext xlsxReadContext, String name, Attributes attributes\n    ) {\n        String ref = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_REF);\n        if (StringUtils.isEmpty(ref)) {\n            return;\n\n        }\n\n        // Hyperlink has 2 case:\n        // case 1，In the 'location' tag\n        String location = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_LOCATION);\n        if (location != null) {\n            CellExtra cellExtra = new CellExtra(CellExtraTypeEnum.HYPERLINK, location, ref);\n\n            xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n            xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n            return;\n        }\n        // case 2, In the 'r:id' tag, Then go to 'PackageRelationshipCollection' to get inside\n        String rId = attributes.getValue(ExcelXmlConstants.ATTRIBUTE_RID);\n        PackageRelationshipCollection packageRelationshipCollection = xlsxReadContext.xlsxReadSheetHolder().getPackageRelationshipCollection();\n        if (rId == null || packageRelationshipCollection == null) {\n            return;\n\n        }\n        Optional.ofNullable(packageRelationshipCollection.getRelationshipByID(rId))\n        .map(PackageRelationship::getTargetURI).ifPresent(uri -> {\n            CellExtra cellExtra = new CellExtra(CellExtraTypeEnum.HYPERLINK, uri.toString(), ref);\n\n            xlsxReadContext.readSheetHolder().setCellExtra(cellExtra);\n            xlsxReadContext.analysisEventProcessor().extra(xlsxReadContext);\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "94", "src_id": "M248", "code": "    @Override\n    public void processRecord(XlsReadContext xlsReadContext, Record record) {\n        LabelSSTRecord lsrec = (LabelSSTRecord)record;\n        ReadCache readCache = xlsReadContext.readWorkbookHolder().getReadCache();\n        Map<Integer, Cell> cellMap = xlsReadContext.xlsReadSheetHolder().getCellMap();\n        if (readCache == null) {\n            cellMap.put((int)lsrec.getColumn()\n            , ReadCellData.newEmptyInstance(lsrec.getRow(), (int)lsrec.getColumn()));\n            return;\n        }\n        String data = readCache.get(lsrec.getSSTIndex());\n\n        if (data == null) {\n            cellMap.put((int)lsrec.getColumn()\n            , ReadCellData.newEmptyInstance(lsrec.getRow(), (int)lsrec.getColumn()));\n            return;\n        }\n\n        if (xlsReadContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\n            data = data.trim();\n        }\n        cellMap.put((int)lsrec.getColumn()\n        , ReadCellData.newInstance(data, lsrec.getRow(), (int)lsrec.getColumn()));\n        xlsReadContext.xlsReadSheetHolder().setTempRowType(RowTypeEnum.DATA);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "95", "src_id": "M106", "code": "    private Row createRowIfNecessary(\n    Sheet sheet, Sheet cachedSheet, Integer lastRowIndex, FillConfig fillConfig, AnalysisCell analysisCell, boolean isOriginalCell, RowWriteHandlerContext rowWriteHandlerContext\n    ) {\n        rowWriteHandlerContext.setRowIndex(lastRowIndex);\n\n        Row row = sheet.getRow(lastRowIndex);\n\n        if (row != null) {\n            checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n            rowWriteHandlerContext.setRow(row);\n\n            return row;\n        }\n\n        row = cachedSheet.getRow(lastRowIndex);\n\n        if (row != null) {\n            checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n            rowWriteHandlerContext.setRow(row);\n        } else {\n            rowWriteHandlerContext.setRowIndex(lastRowIndex);\n\n            WriteHandlerUtils.beforeRowCreate(rowWriteHandlerContext);\n\n            if (fillConfig.getForceNewRow()) {\n                row = cachedSheet.createRow(lastRowIndex);\n\n            } else {\n                // The last row of the middle disk inside empty rows, resulting in cachedSheet can not get inside.\n                // Will throw Attempting to write a row[\" + rownum + \"] \" + \"in the range [0,\" + this._sh\n                // .getLastRowNum() + \"] that is already written to disk.\n                try {\n                    row = sheet.createRow(lastRowIndex);\n                } catch (IllegalArgumentException ignore) {\n                    row = cachedSheet.createRow(lastRowIndex);\n\n                }\n\n            }\n\n            rowWriteHandlerContext.setRow(row);\n\n            checkRowHeight(analysisCell, fillConfig, isOriginalCell, row);\n\n            WriteHandlerUtils.afterRowCreate(rowWriteHandlerContext);\n        } \n\n        return row;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "96", "src_id": "M12", "code": "    private Object buildNoModel(\n    Map<Integer, ReadCellData<?>> cellDataMap, ReadSheetHolder readSheetHolder, AnalysisContext context\n    ) {\n        int index = 0;\n        Map<Integer, Object> map = MapUtils.newLinkedHashMapWithExpectedSize(cellDataMap.size());\n        for (Map.Entry<Integer, ReadCellData<?>> entry : cellDataMap.entrySet()) {\n            Integer key = entry.getKey();\n            ReadCellData<?> cellData = entry.getValue();\n            while (index < key) {\n                map.put(index, null);\n                index++;\n            }\n            index++;\n            ReadDefaultReturnEnum readDefaultReturn = context.readWorkbookHolder().getReadDefaultReturn();\n            if (readDefaultReturn == ReadDefaultReturnEnum.STRING) {\n                // string\n                map.put(key,(String)ConverterUtils.convertToJavaObject(cellData, null, null, readSheetHolder.converterMap(), context, context.readRowHolder().getRowIndex(), key));\n\n            } else {\n                // retrun ReadCellData\n                ReadCellData<?> convertedReadCellData = convertReadCellData(cellData, context.readWorkbookHolder().getReadDefaultReturn(), readSheetHolder, context, key);\n                if (readDefaultReturn == ReadDefaultReturnEnum.READ_CELL_DATA) {\n                    map.put(key, convertedReadCellData);\n\n                } else {\n                    map.put(key, convertedReadCellData.getData());\n                }\n            }\n        }\n\n        // fix https://github.com/alibaba/easyexcel/issues/2014\n        int headSize = calculateHeadSize(readSheetHolder);\n\n        while (index < headSize) {\n            map.put(index, null);\n            index++;\n        }\n\n        return map;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "97", "src_id": "M94", "code": "    private void fillComment(\n    CellWriteHandlerContext cellWriteHandlerContext, CommentData commentData\n    ) {\n        if (commentData == null) {\n            return;\n\n        }\n        ClientAnchor anchor;\n\n        Integer rowIndex = cellWriteHandlerContext.getRowIndex();\n\n        Integer columnIndex = cellWriteHandlerContext.getColumnIndex();\n        Sheet sheet = cellWriteHandlerContext.getWriteSheetHolder().getSheet();\n\n        Cell cell = cellWriteHandlerContext.getCell();\n        if (writeContext.writeWorkbookHolder().getExcelType() == ExcelTypeEnum.XLSX) {\n            anchor = new XSSFClientAnchor(StyleUtil.getCoordinate(commentData.getLeft()), StyleUtil.getCoordinate(commentData.getTop()), StyleUtil.getCoordinate(commentData.getRight()), StyleUtil.getCoordinate(commentData.getBottom()), StyleUtil.getCellCoordinate(columnIndex, commentData.getFirstColumnIndex(), commentData.getRelativeFirstColumnIndex()), StyleUtil.getCellCoordinate(rowIndex, commentData.getFirstRowIndex(), commentData.getRelativeFirstRowIndex()), StyleUtil.getCellCoordinate(columnIndex, commentData.getLastColumnIndex(), commentData.getRelativeLastColumnIndex()) + 1, StyleUtil.getCellCoordinate(rowIndex, commentData.getLastRowIndex(), commentData.getRelativeLastRowIndex()) + 1);\n\n        } else {\n            anchor = new HSSFClientAnchor(StyleUtil.getCoordinate(commentData.getLeft()), StyleUtil.getCoordinate(commentData.getTop()), StyleUtil.getCoordinate(commentData.getRight()), StyleUtil.getCoordinate(commentData.getBottom()),(short)StyleUtil.getCellCoordinate(columnIndex, commentData.getFirstColumnIndex(), commentData.getRelativeFirstColumnIndex()), StyleUtil.getCellCoordinate(rowIndex, commentData.getFirstRowIndex(), commentData.getRelativeFirstRowIndex()),(short)(StyleUtil.getCellCoordinate(columnIndex, commentData.getLastColumnIndex(), commentData.getRelativeLastColumnIndex()) + 1), StyleUtil.getCellCoordinate(rowIndex, commentData.getLastRowIndex(), commentData.getRelativeLastRowIndex()) + 1);\n\n        }\n        Comment comment = sheet.createDrawingPatriarch().createCellComment(anchor);\n        if (commentData.getRichTextStringData() != null) {\n            comment.setString(StyleUtil.buildRichTextString(writeContext.writeWorkbookHolder(), commentData.getRichTextStringData()));\n\n        }\n        if (commentData.getAuthor() != null) {\n            comment.setAuthor(commentData.getAuthor());\n\n        }\n        cell.setCellComment(comment);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "98", "src_id": "M212", "code": "    private Format getFormat(Double data, Short dataFormat, String dataFormatString) {\n        // Might be better to separate out the n p and z formats, falling back to p when n and z are not set.\n        // That however would require other code to be re factored.\n        // String[] formatBits = formatStrIn.split(\";\");\n        // int i = cellValue > 0.0 ? 0 : cellValue < 0.0 ? 1 : 2;\n        // String formatStr = (i < formatBits.length) ? formatBits[i] : formatBits[0];\n        String formatStr = dataFormatString;\n        // Excel supports 2+ part conditional data formats, eg positive/negative/zero,\n        //  or (>1000),(>0),(0),(negative). As Java doesn't handle these kinds\n        //  of different formats for different ranges, just +ve/-ve, we need to\n        //  handle these ourselves in a special way.\n        // For now, if we detect 2+ parts, we call out to CellFormat to handle it\n        // TODO Going forward, we should really merge the logic between the two classes\n        if (formatStr.contains(\";\") && (formatStr.indexOf(';') != formatStr.lastIndexOf(';') || rangeConditionalPattern.matcher(formatStr).matches())) {\n            try {\n                // Ask CellFormat to get a formatter for it\n                CellFormat cfmt = CellFormat.getInstance(locale, formatStr);\n\n                // CellFormat requires callers to identify date vs not, so do so\n                Object cellValueO = data;\n                if (DateUtils.isADateFormat(dataFormat, formatStr) && // don't try to handle Date value 0, let a 3 or 4-part format take care of it\n                data.doubleValue() != 0.0) {\n                    cellValueO = DateUtils.getJavaDate(data, use1904windowing);\n                }\n                // Wrap and return (non-cachable - CellFormat does that)\n                return new CellFormatResultWrapper(cfmt.apply(cellValueO));\n            } catch (Exception e) {\n                LOGGER.warn(\"Formatting failed for format {}, falling back\", formatStr, e);\n            }\n\n        }\n        // See if we already have it cached\n        Format format = formats.get(formatStr);\n        if (format != null) {\n            return format;\n\n        }\n        // Is it one of the special built in types, General or @?\n        if (\"General\".equalsIgnoreCase(formatStr) || \"@\".equals(formatStr)) {\n            format = getDefaultFormat();\n            addFormat(formatStr, format);\n\n            return format;\n        }\n        // Build a formatter, and cache it\n        format = createFormat(dataFormat, formatStr);\n        addFormat(formatStr, format);\n        return format;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "99", "src_id": "M35", "code": "    private static void buildStyleProperty(\n    StyleProperty styleProperty, WriteCellStyle writeCellStyle\n    ) {\n        if (styleProperty == null) {\n            return;\n\n        }\n        if (styleProperty.getDataFormatData() != null) {\n            if (writeCellStyle.getDataFormatData() == null) {\n                writeCellStyle.setDataFormatData(styleProperty.getDataFormatData());\n            } else {\n                DataFormatData.merge(styleProperty.getDataFormatData(), writeCellStyle.getDataFormatData());\n            }\n\n        }\n\n        if (styleProperty.getHidden() != null) {\n            writeCellStyle.setHidden(styleProperty.getHidden());\n        }\n        if (styleProperty.getLocked() != null) {\n            writeCellStyle.setLocked(styleProperty.getLocked());\n        }\n\n        if (styleProperty.getQuotePrefix() != null) {\n            writeCellStyle.setQuotePrefix(styleProperty.getQuotePrefix());\n        }\n\n        if (styleProperty.getHorizontalAlignment() != null) {\n            writeCellStyle.setHorizontalAlignment(styleProperty.getHorizontalAlignment());\n\n        }\n\n        if (styleProperty.getWrapped() != null) {\n            writeCellStyle.setWrapped(styleProperty.getWrapped());\n        }\n        if (styleProperty.getVerticalAlignment() != null) {\n            writeCellStyle.setVerticalAlignment(styleProperty.getVerticalAlignment());\n        }\n\n        if (styleProperty.getRotation() != null) {\n            writeCellStyle.setRotation(styleProperty.getRotation());\n        }\n\n        if (styleProperty.getIndent() != null) {\n            writeCellStyle.setIndent(styleProperty.getIndent());\n        }\n\n        if (styleProperty.getBorderLeft() != null) {\n            writeCellStyle.setBorderLeft(styleProperty.getBorderLeft());\n        }\n\n        if (styleProperty.getBorderRight() != null) {\n            writeCellStyle.setBorderRight(styleProperty.getBorderRight());\n        }\n\n        if (styleProperty.getBorderTop() != null) {\n            writeCellStyle.setBorderTop(styleProperty.getBorderTop());\n        }\n\n        if (styleProperty.getBorderBottom() != null) {\n            writeCellStyle.setBorderBottom(styleProperty.getBorderBottom());\n        }\n\n        if (styleProperty.getLeftBorderColor() != null) {\n            writeCellStyle.setLeftBorderColor(styleProperty.getLeftBorderColor());\n        }\n\n        if (styleProperty.getRightBorderColor() != null) {\n            writeCellStyle.setRightBorderColor(styleProperty.getRightBorderColor());\n        }\n\n        if (styleProperty.getTopBorderColor() != null) {\n            writeCellStyle.setTopBorderColor(styleProperty.getTopBorderColor());\n        }\n\n        if (styleProperty.getBottomBorderColor() != null) {\n            writeCellStyle.setBottomBorderColor(styleProperty.getBottomBorderColor());\n        }\n\n        if (styleProperty.getFillPatternType() != null) {\n            writeCellStyle.setFillPatternType(styleProperty.getFillPatternType());\n        }\n\n        if (styleProperty.getFillBackgroundColor() != null) {\n            writeCellStyle.setFillBackgroundColor(styleProperty.getFillBackgroundColor());\n\n        }\n        if (styleProperty.getFillForegroundColor() != null) {\n            writeCellStyle.setFillForegroundColor(styleProperty.getFillForegroundColor());\n\n        }\n        if (styleProperty.getShrinkToFit() != null) {\n            writeCellStyle.setShrinkToFit(styleProperty.getShrinkToFit());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "100", "src_id": "M90", "code": "    private void addJavaObjectToExcel(\n    Object oneRowData, Row row, int rowIndex, int relativeRowIndex\n    ) {\n        WriteHolder currentWriteHolder = writeContext.currentWriteHolder();\n\n        BeanMap beanMap = BeanMapUtils.create(oneRowData);\n\n        // Bean the contains of the Map Key method with poor performance,So to create a keySet here\n        Set<String> beanKeySet = new HashSet<>(beanMap.keySet());\n\n        Set<String> beanMapHandledSet = new HashSet<>();\n\n        int maxCellIndex = -1;\n\n        // If it's a class it needs to be cast by type\n        if (HeadKindEnum.CLASS.equals(writeContext.currentWriteHolder().excelWriteHeadProperty().getHeadKind())) {\n            Map<Integer, Head> headMap = writeContext.currentWriteHolder().excelWriteHeadProperty().getHeadMap();\n            for (Map.Entry<Integer, Head> entry : headMap.entrySet()) {\n                int columnIndex = entry.getKey();\n                Head head = entry.getValue();\n\n                String name = head.getFieldName();\n\n                if (!beanKeySet.contains(name)) {\n                    continue;\n\n                }\n                ExcelContentProperty excelContentProperty = ClassUtils.declaredExcelContentProperty(beanMap, currentWriteHolder.excelWriteHeadProperty().getHeadClazz(), name, currentWriteHolder);\n\n                CellWriteHandlerContext cellWriteHandlerContext = WriteHandlerUtils.createCellWriteHandlerContext(writeContext, row, rowIndex, head, columnIndex, relativeRowIndex, Boolean.FALSE, excelContentProperty);\n                WriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n\n                Cell cell = WorkBookUtil.createCell(row, columnIndex);\n                cellWriteHandlerContext.setCell(cell);\n                WriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n\n                cellWriteHandlerContext.setOriginalValue(beanMap.get(name));\n                cellWriteHandlerContext.setOriginalFieldClass(head.getField().getType());\n\n                converterAndSet(cellWriteHandlerContext);\n\n                WriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n\n                beanMapHandledSet.add(name);\n\n                maxCellIndex = Math.max(maxCellIndex, columnIndex);\n\n            }\n        }\n\n        // Finish\n        if (beanMapHandledSet.size() == beanMap.size()) {\n            return;\n\n        }\n\n        maxCellIndex++;\n\n        FieldCache fieldCache = ClassUtils.declaredFields(oneRowData.getClass(), writeContext.currentWriteHolder());\n        for (Map.Entry<Integer, FieldWrapper> entry : fieldCache.getSortedFieldMap().entrySet()) {\n            FieldWrapper field = entry.getValue();\n            String fieldName = field.getFieldName();\n\n            boolean uselessData = !beanKeySet.contains(fieldName) || beanMapHandledSet.contains(fieldName);\n            if (uselessData) {\n                continue;\n\n            }\n            Object value = beanMap.get(fieldName);\n            ExcelContentProperty excelContentProperty = ClassUtils.declaredExcelContentProperty(beanMap, currentWriteHolder.excelWriteHeadProperty().getHeadClazz(), fieldName, currentWriteHolder);\n\n            CellWriteHandlerContext cellWriteHandlerContext = WriteHandlerUtils.createCellWriteHandlerContext(writeContext, row, rowIndex, null, maxCellIndex, relativeRowIndex, Boolean.FALSE, excelContentProperty);\n            WriteHandlerUtils.beforeCellCreate(cellWriteHandlerContext);\n\n            // fix https://github.com/alibaba/easyexcel/issues/1870\n            // If there is data, it is written to the next cell\n            Cell cell = WorkBookUtil.createCell(row, maxCellIndex);\n            cellWriteHandlerContext.setCell(cell);\n            WriteHandlerUtils.afterCellCreate(cellWriteHandlerContext);\n            cellWriteHandlerContext.setOriginalValue(value);\n\n            cellWriteHandlerContext\n            .setOriginalFieldClass(FieldUtils.getFieldClass(beanMap, fieldName, value));\n            converterAndSet(cellWriteHandlerContext);\n\n            WriteHandlerUtils.afterCellDispose(cellWriteHandlerContext);\n\n            maxCellIndex++;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "101", "src_id": "M50", "code": "    public CellStyle createCellStyle(WriteCellStyle writeCellStyle, CellStyle originCellStyle) {\n        if (writeCellStyle == null) {\n            return originCellStyle;\n        }\n\n        short styleIndex = -1;\n\n        Font originFont = null;\n        boolean useCache = true;\n        if (originCellStyle != null) {\n            styleIndex = originCellStyle.getIndex();\n            if (originCellStyle instanceof XSSFCellStyle) {\n                originFont = ((XSSFCellStyle)originCellStyle).getFont();\n            } else {\n                if (originCellStyle instanceof HSSFCellStyle) {\n                    originFont = ((HSSFCellStyle)originCellStyle).getFont(workbook);\n                }\n\n            }\n            useCache = false;\n        }\n\n        Map<WriteCellStyle, CellStyle> cellStyleMap = cellStyleIndexMap.computeIfAbsent(styleIndex, key -> MapUtils.newHashMap());\n\n        CellStyle cellStyle = cellStyleMap.get(writeCellStyle);\n        if (cellStyle != null) {\n            return cellStyle;\n        }\n        if (log.isDebugEnabled()) {\n            log.info(\"create new style:{},{}\", writeCellStyle, originCellStyle);\n        }\n        WriteCellStyle tempWriteCellStyle = new WriteCellStyle();\n        WriteCellStyle.merge(writeCellStyle, tempWriteCellStyle);\n        cellStyle = StyleUtil.buildCellStyle(workbook, originCellStyle, tempWriteCellStyle);\n        Short dataFormat = createDataFormat(tempWriteCellStyle.getDataFormatData(), useCache);\n        if (dataFormat != null) {\n            cellStyle.setDataFormat(dataFormat);\n\n        }\n        Font font = createFont(tempWriteCellStyle.getWriteFont(), originFont, useCache);\n\n        if (font != null) {\n            cellStyle.setFont(font);\n        }\n        cellStyleMap.put(tempWriteCellStyle, cellStyle);\n        return cellStyle;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "102", "src_id": "M21", "code": "    private void buildHead(\n    AnalysisContext analysisContext, Map<Integer, ReadCellData<?>> cellDataMap\n    ) {\n        // Rule out empty head, and then take the largest column\n        if (MapUtils.isNotEmpty(cellDataMap)) {\n            cellDataMap.entrySet().stream().filter(entry -> CellDataTypeEnum.EMPTY != entry.getValue().getType()).forEach(entry -> analysisContext.readSheetHolder().setMaxNotEmptyDataHeadSize(entry.getKey()));\n\n        }\n        if (!HeadKindEnum.CLASS.equals(analysisContext.currentReadHolder().excelReadHeadProperty().getHeadKind())) {\n            return;\n\n        }\n        Map<Integer, String> dataMap = ConverterUtils.convertToStringMap(cellDataMap, analysisContext);\n        ExcelReadHeadProperty excelHeadPropertyData = analysisContext.readSheetHolder().excelReadHeadProperty();\n\n        Map<Integer, Head> headMapData = excelHeadPropertyData.getHeadMap();\n\n        Map<Integer, Head> tmpHeadMap = new HashMap<Integer, Head>(headMapData.size() * 4 / 3 + 1);\n        for (Map.Entry<Integer, Head> entry : headMapData.entrySet()) {\n            Head headData = entry.getValue();\n            if (headData.getForceIndex() || !headData.getForceName()) {\n                tmpHeadMap.put(entry.getKey(), headData);\n                continue;\n            }\n\n            List<String> headNameList = headData.getHeadNameList();\n            String headName = headNameList.get(headNameList.size() - 1);\n            for (Map.Entry<Integer, String> stringEntry : dataMap.entrySet()) {\n                if (stringEntry == null) {\n                    continue;\n\n                }\n                String headString = stringEntry.getValue();\n\n                Integer stringKey = stringEntry.getKey();\n\n                if (StringUtils.isEmpty(headString)) {\n                    continue;\n\n                }\n                if (analysisContext.currentReadHolder().globalConfiguration().getAutoTrim()) {\n                    headString = headString.trim();\n                }\n                if (headName.equals(headString)) {\n                    headData.setColumnIndex(stringKey);\n                    tmpHeadMap.put(stringKey, headData);\n\n                    break;\n                }\n            }\n        }\n\n        excelHeadPropertyData.setHeadMap(tmpHeadMap);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "8", "src_id": "M95", "code": "    public static HealthCountsStream getInstance(HystrixCommandKey commandKey, int numBuckets, int bucketSizeInMs) {\n        HealthCountsStream initialStream = streams.get(commandKey.name());\n        if (initialStream != null) return initialStream;else {\n            final HealthCountsStream healthStream;\n            synchronized (HealthCountsStream.class) {\n                HealthCountsStream existingStream = streams.get(commandKey.name());\n                if (existingStream != null) healthStream = existingStream;else {\n                    HealthCountsStream newStream = new HealthCountsStream(commandKey, numBuckets, bucketSizeInMs, HystrixCommandMetrics.appendEventToBucket);\n                    streams.putIfAbsent(commandKey.name(), newStream);\n                    healthStream = newStream;\n                } \n            }\n            healthStream.startCachingStreamValuesIfUnstarted();\n            return healthStream;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "9", "src_id": "M118", "code": "    public Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {\n        Map<CommandAndCacheKey, Integer> cachingDetector = new HashMap<CommandAndCacheKey, Integer>();\n        List<HystrixInvokableInfo<?>> nonCachedExecutions = new ArrayList<HystrixInvokableInfo<?>>(executions.size());\n        for (HystrixInvokableInfo<?> execution : executions) {\n            if (execution.getPublicCacheKey() != null) {\n                //eligible for caching - might be the initial, or might be from cache\n                CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), execution.getPublicCacheKey());\n                Integer count = cachingDetector.get(key);\n\n                if (count != null) cachingDetector.put(key, count + 1);else cachingDetector.put(key, 0);\n            }\n            if (execution.isResponseFromCache()) { \n                continue ; \n            }  \n            nonCachedExecutions.add(execution);\n        }\n\n        Map<ExecutionSignature, List<Integer>> commandDeduper = new HashMap<ExecutionSignature, List<Integer>>();\n        for (HystrixInvokableInfo<?> execution : nonCachedExecutions) {\n            int cachedCount = 0;\n            String cacheKey = execution.getPublicCacheKey();\n            if (cacheKey != null) {\n                CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), cacheKey);\n                cachedCount = cachingDetector.get(key);\n            }\n            ExecutionSignature signature = cachedCount > 0? ExecutionSignature.from(execution, cacheKey, cachedCount) : ExecutionSignature.from(execution); List<Integer> currentLatencyList = commandDeduper.get(signature);\n            if (currentLatencyList != null) { \n                currentLatencyList.add(execution.getExecutionTimeInMilliseconds());\n                continue; \n            }  \n            List<Integer> newLatencyList = new ArrayList<Integer>();\n            newLatencyList.add(execution.getExecutionTimeInMilliseconds());\n\n            commandDeduper.put(signature, newLatencyList);\n        }\n        return commandDeduper;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "10", "src_id": "M223", "code": "    public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties) {\n        final ThreadFactory threadFactory = getThreadFactory(threadPoolKey);\n        final boolean allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();\n        final int dynamicCoreSize = threadPoolProperties.coreSize().get();\n        final int keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();\n        final int maxQueueSize = threadPoolProperties.maxQueueSize().get();\n        final BlockingQueue<Runnable> workQueue = getBlockingQueue(maxQueueSize);\n        if (!allowMaximumSizeToDivergeFromCoreSize) return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);else {\n            final int dynamicMaximumSize = threadPoolProperties.maximumSize().get();\n            if (dynamicCoreSize <= dynamicMaximumSize) return new ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);else {\n                logger.error(\"Hystrix ThreadPool configuration at startup for : \" + threadPoolKey.name() + \" is trying to set coreSize = \" + dynamicCoreSize + \" and maximumSize = \" + dynamicMaximumSize + \".  Maximum size will be set to \" + dynamicCoreSize + \", the coreSize value, since it must be equal to or greater than the coreSize value\");\n                return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n            } \n        } }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "11", "src_id": "M498", "code": "    protected static String convertToJson(HystrixUtilization utilization) throws IOException {\n        StringWriter jsonString = new StringWriter();\n\n        JsonGenerator json = jsonFactory.createGenerator(jsonString);\n\n        json.writeStartObject();\n        json.writeStringField(\"type\", \"HystrixUtilization\");\n        json.writeObjectFieldStart(\"commands\");\n        for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n            final HystrixCommandKey key = entry.getKey();\n            final HystrixCommandUtilization commandUtilization = entry.getValue();\n            writeCommandUtilizationJson(json, key, commandUtilization);\n\n        }\n        json.writeEndObject();\n        json.writeObjectFieldStart(\"threadpools\");\n        for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n            final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n            final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n            writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n        }\n        json.writeEndObject();\n        json.writeEndObject();\n        json.close();\n        return jsonString.getBuffer().toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "12", "src_id": "M171", "code": "    EventCounts plus(HystrixEventType eventType, int count) {\n        BitSet newBitSet = (BitSet) events.clone();\n        int localNumEmits = numEmissions;\n\n        int localNumFallbackEmits =  numFallbackEmissions;\n        int localNumCollapsed = numCollapsed;\n        switch (eventType) {\n            case EMIT:\n                newBitSet.set(HystrixEventType.EMIT.ordinal());\n                localNumEmits += count;\n                break;\n            case FALLBACK_EMIT:\n                newBitSet.set(HystrixEventType.FALLBACK_EMIT.ordinal());\n                localNumFallbackEmits += count;\n                break;\n            case COLLAPSED:\n                newBitSet.set(HystrixEventType.COLLAPSED.ordinal());\n                localNumCollapsed += count;\n                break;\n            default:\n                newBitSet.set(eventType.ordinal());\n\n                break;\n        }\n        return new EventCounts(newBitSet, localNumEmits, localNumFallbackEmits, localNumCollapsed);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "13", "src_id": "M448", "code": "    private static void writeThreadPoolMetrics(final HystrixThreadPoolMetrics threadPoolMetrics, JsonGenerator json) throws IOException {\n        HystrixThreadPoolKey key = threadPoolMetrics.getThreadPoolKey();\n        json.writeStartObject();\n        json.writeStringField(\"type\", \"HystrixThreadPool\");\n        json.writeStringField(\"name\", key.name());\n\n        json.writeNumberField(\"currentTime\", System.currentTimeMillis());\n\n        json.writeNumberField(\"currentActiveCount\", threadPoolMetrics.getCurrentActiveCount().intValue());\n        json.writeNumberField(\"currentCompletedTaskCount\", threadPoolMetrics.getCurrentCompletedTaskCount().longValue());\n        json.writeNumberField(\"currentCorePoolSize\", threadPoolMetrics.getCurrentCorePoolSize().intValue());\n        json.writeNumberField(\"currentLargestPoolSize\", threadPoolMetrics.getCurrentLargestPoolSize().intValue());\n        json.writeNumberField(\"currentMaximumPoolSize\", threadPoolMetrics.getCurrentMaximumPoolSize().intValue());\n        json.writeNumberField(\"currentPoolSize\", threadPoolMetrics.getCurrentPoolSize().intValue());\n\n        json.writeNumberField(\"currentQueueSize\", threadPoolMetrics.getCurrentQueueSize().intValue());\n\n        json.writeNumberField(\"currentTaskCount\", threadPoolMetrics.getCurrentTaskCount().longValue());\n\n        safelyWriteNumberField(json, \"rollingCountThreadsExecuted\", new Func0<Long>() {\n            @Override\n            public Long call() {\n                return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.EXECUTED);\n            }\n        });\n\n        json.writeNumberField(\"rollingMaxActiveThreads\", threadPoolMetrics.getRollingMaxActiveThreads());\n        safelyWriteNumberField(json, \"rollingCountCommandRejections\", new Func0<Long>() {\n            @Override\n            public Long call() {\n                return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.REJECTED);\n            }\n        });\n\n        json.writeNumberField(\"propertyValue_queueSizeRejectionThreshold\", threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());\n        json.writeNumberField(\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());\n        json.writeNumberField(\"reportingHosts\", 1); // this will get summed across all instances in a cluster\n        json.writeEndObject();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "14", "src_id": "M69", "code": "    @Override\n    public String toString() {\n        StringBuffer sb = new StringBuffer();\n        List<HystrixEventType> foundEventTypes = new ArrayList<HystrixEventType>();\n        sb.append(getCommandKey().name()).append(\"[\");\n\n        for (HystrixEventType eventType : ALL_EVENT_TYPES) {\n            if (!(executionResult.getEventCounts().contains(eventType))) { \n                continue ; \n            }  \n            foundEventTypes.add(eventType);\n        }\n\n        int i = 0;\n\n        for (HystrixEventType eventType : foundEventTypes) {\n            sb.append(eventType.name());\n            int eventCount = executionResult.getEventCounts().getCount(eventType);\n\n            if (eventCount > 1) {\n                sb.append(\"x\").append(eventCount);\n            }\n            if (i < foundEventTypes.size() - 1) {\n                sb.append(\", \");\n            }\n            i++;\n        }\n\n        sb.append(\"][\").append(getExecutionLatency()).append(\" ms]\");\n        return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "15", "src_id": "M52", "code": "    @Override\n    public void run() {\n        while (true) {/**\n                     * Since this is a simple example and we know the exact HystrixCommandKeys we are interested in\n                     * we will retrieve the HystrixCommandMetrics objects directly.\n                     *\n                     * Typically you would instead retrieve metrics from where they are published which is by default\n                     * done using Servo: https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring\n                     */\n            // wait 5 seconds on each loop\n            try {\n                Thread.sleep(5000);\n            } catch (Exception e) {\n            // ignore\n            }\n            // we are using default names so can use class.getSimpleName() to derive the keys\n            HystrixCommandMetrics creditCardMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(CreditCardCommand.class.getSimpleName()));\n            HystrixCommandMetrics orderMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetOrderCommand.class.getSimpleName()));\n\n            HystrixCommandMetrics userAccountMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetUserAccountCommand.class.getSimpleName()));\n            HystrixCommandMetrics paymentInformationMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetPaymentInformationCommand.class.getSimpleName()));\n\n            if (!shouldLog) { \n                continue ; \n            }  \n\n            StringBuilder out = new StringBuilder();\n            out.append(\"\\n\");\n            out.append(\"#####################################################################################\").append(\"\\n\");\n            out.append(\"# CreditCardCommand: \" + getStatsStringFromMetrics(creditCardMetrics)).append(\"\\n\");\n\n            out.append(\"# GetOrderCommand: \" + getStatsStringFromMetrics(orderMetrics)).append(\"\\n\");\n\n            out.append(\"# GetUserAccountCommand: \" + getStatsStringFromMetrics(userAccountMetrics)).append(\"\\n\");\n            out.append(\"# GetPaymentInformationCommand: \" + getStatsStringFromMetrics(paymentInformationMetrics)).append(\"\\n\");\n            out.append(\"#####################################################################################\").append(\"\\n\");\n\n            System.out.println(out.toString());\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "16", "src_id": "M312", "code": "    private Observable<R> handleRequestCacheHitAndEmitValues(final HystrixCommandResponseFromCache<R> fromCache, final AbstractCommand<R> _cmd) {\n        try {\n            executionHook.onCacheHit(this);\n        } catch (Throwable hookEx) {\n            logger.warn(\"Error calling HystrixCommandExecutionHook.onCacheHit\", hookEx);\n        }\n\n        return fromCache.toObservableWithStateCopiedInto(this).doOnTerminate(new Action0() {\n            @Override\n            public void call() {\n                if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) cleanUpAfterResponseFromCache(false); //user code never ran\n                else if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) {\n                        cleanUpAfterResponseFromCache(true); //user code did run\n                    }\n            }\n        }).doOnUnsubscribe(new Action0() {\n            @Override\n            public void call() {\n                if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) cleanUpAfterResponseFromCache(false); //user code never ran\n                else if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.UNSUBSCRIBED)) {\n                        cleanUpAfterResponseFromCache(true); //user code did run\n                    }\n            }\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "17", "src_id": "M438", "code": "    private static void serializeUtilization(HystrixUtilization utilization, JsonGenerator json) {\n        try {\n            json.writeStartObject();\n            json.writeStringField(\"type\", \"HystrixUtilization\");\n            json.writeObjectFieldStart(\"commands\");\n            for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n                final HystrixCommandKey key = entry.getKey();\n                final HystrixCommandUtilization commandUtilization = entry.getValue();\n                writeCommandUtilizationJson(json, key, commandUtilization);\n\n            }\n            json.writeEndObject();\n            json.writeObjectFieldStart(\"threadpools\");\n            for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n                final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n                final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n                writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n            }\n            json.writeEndObject();\n            json.writeEndObject();\n            json.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "42", "src_id": "M1277", "code": "            public static Map<String, String> toStringMap(\n            Map<String, Object> input, boolean stringEscape) {\n        Map<String, String> output = \n        new HashMap<>(input.size());\n\n        for (Map.Entry<String, Object> entry : input.entrySet()) {\n    String key = entry.getKey();\n    Object obj = entry.getValue();\n    if (key == null) {\nthrow new NullPointerException(\"A null argument cannot be sent to Redis.\");\n    }\n    if (obj == null) {\n    throw new NullPointerException(\"A null argument cannot be sent to Redis.\");\n}\n    String str;\n    if (obj instanceof byte[]) {\nstr = SafeEncoder.encode((byte[]) obj);\n    } else if (obj instanceof redis.clients.jedis.GeoCoordinate) {\nredis.clients.jedis.GeoCoordinate geo = (redis.clients.jedis.GeoCoordinate) obj;\nstr = geo.getLongitude() + \",\" + geo.getLatitude();\n} else if (obj instanceof String) {\nif (stringEscape) { \nstr = escape((String) obj); \n} else { \nstr = (String) obj; \n} \n} else {\nstr = String.valueOf(obj);\n}\n\n    output.put(key, str);\n        }\n        return output;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "43", "src_id": "M902", "code": "            @Override\n            public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n    args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n    args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n    args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n    args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (ignore) {\n    args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n        if (labels != null) {\n    args.add(LABELS);\n    labels.entrySet()\n    .forEach((entry) -> \n    args.add(entry.getKey()).add(entry.getValue()));\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "44", "src_id": "M1131", "code": "            private static Object process(final RedisInputStream is) {\n        final byte b = is.readByte();\n        // System.out.println(\"BYTE: \" + (char) b);\n        switch (b) {\n    case PLUS_BYTE:\nreturn is.readLineBytes();\n    case DOLLAR_BYTE:\n    case EQUAL_BYTE:\nreturn processBulkReply(is);\n    case ASTERISK_BYTE:\nreturn processMultiBulkReply(is);\n    case UNDERSCORE_BYTE:\nreturn is.readNullCrLf();\n    case HASH_BYTE:\nreturn is.readBooleanCrLf();\n    case COLON_BYTE:\nreturn is.readLongCrLf();\n    case COMMA_BYTE:\nreturn is.readDoubleCrLf();\n    case LEFT_BRACE_BYTE:\nreturn is.readBigIntegerCrLf();\n    case PERCENT_BYTE : // TODO: currently just to start working with HELLO\nreturn processMapKeyValueReply(is);\n    case TILDE_BYTE : // TODO:\nreturn processMultiBulkReply(is);\n    case GREATER_THAN_BYTE:\nreturn processMultiBulkReply(is);\n    case MINUS_BYTE:\nprocessError(is);\nreturn null;\n// TODO: Blob error '!'\n    default:\nthrow new JedisConnectionException(\"Unknown reply: \" + (char) b);\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "45", "src_id": "M1057", "code": "            @Override\n            public Map.Entry<T, ProfilingInfo> build(Object data) {\n        List list = (List) data;\n\n        if (list == null || list.isEmpty()) {\n    return null;\n        }\n\n        if (list.get(0) instanceof KeyValue) { // RESP3\n    Object resultsData = null, profileData = null;\n\n    for (KeyValue keyValue : (List<KeyValue>) data) {\nString keyStr = BuilderFactory.STRING.build(keyValue.getKey());\nswitch (keyStr) {\ncase PROFILE_STR_REDIS7:\ncase PROFILE_STR_REDIS8:\nprofileData = keyValue.getValue();\nbreak;\ncase RESULTS_STR_REDIS7:\nresultsData = data;\nbreak;\ncase RESULTS_STR_REDIS8:\nresultsData = keyValue.getValue();\nbreak;\n}\n    }\n\n    assert resultsData != null : \"Could not detect Results data.\";\n\n    assert profileData != null : \"Could not detect Profile data.\";\n\n    return KeyValue\n    .of(\n    resultsBuilder.build(resultsData)\n    ,ProfilingInfo.PROFILING_INFO_BUILDER.build(profileData));\n        }\n\n        return KeyValue\n        .of(\n        resultsBuilder.build(list.get(0))\n        ,ProfilingInfo.PROFILING_INFO_BUILDER.build(list.get(1)));\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "46", "src_id": "M1229", "code": "            public SSLContext createSslContext() throws IOException, GeneralSecurityException {\n        KeyManager[] keyManagers = null;\n        TrustManager[] trustManagers = null;\n        if (sslVerifyMode == SslVerifyMode.FULL) {\n    this.sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        } else if (sslVerifyMode == SslVerifyMode.CA) {\nthis.sslParameters.setEndpointIdentificationAlgorithm(\"\");\n    } else if (sslVerifyMode == SslVerifyMode.INSECURE) {\ntrustManagers = new TrustManager[] { \nINSECURE_TRUST_MANAGER };\n}\n        if (keystoreResource != null) {\n    KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n\n    try (InputStream keystoreStream = keystoreResource.get()) {\nkeyStore.load(keystoreStream, keystorePassword);\n    }\n    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);\n    keyManagerFactory.init(keyStore, keystorePassword);\n    keyManagers = keyManagerFactory.getKeyManagers();\n        }\n\n        if (trustManagers == null && truststoreResource != null) {\n    KeyStore trustStore = KeyStore.getInstance(trustStoreType);\n    try (InputStream truststoreStream = truststoreResource.get()) {\ntrustStore.load(truststoreStream, truststorePassword);\n    }\n    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(trustManagerAlgorithm);\n    trustManagerFactory.init(trustStore);\n    trustManagers = trustManagerFactory.getTrustManagers();\n        }\n        SSLContext sslContext = SSLContext.getInstance(sslProtocol);\n\n        sslContext.init(keyManagers, trustManagers, null);\n        return sslContext;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "47", "src_id": "M894", "code": "            @Override\n            public TSInfo build(Object data) {\n        List<KeyValue> list = \n        (List<KeyValue>) data;\n\n        Map<String, Object> properties = new HashMap<>();\n\n        Map<String, String> labels = null;\n\n        Map<String, Rule> rules = null;\n\n        List<Map<String, Object>> chunks = null;\n        for (KeyValue propertyValue : list) {\n    String prop = \n    BuilderFactory.STRING.build(propertyValue.getKey());\n    Object value = propertyValue.getValue();\n\n    if (!(value instanceof List)) if (value instanceof byte[]) {\nvalue = BuilderFactory.STRING.build(value);\n\nif (DUPLICATE_POLICY_PROPERTY.equals(prop)) {\ntry {\nvalue = DuplicatePolicy.valueOf(((String) value).toUpperCase());\n} catch (Exception e) { \n}\n}\n} else {\nswitch (prop) {\ncase LABELS_PROPERTY:\nlabels = BuilderFactory.STRING_MAP.build(value);\n\nvalue = labels;\nbreak;\ncase RULES_PROPERTY:\nList<KeyValue> rulesDataList = \n(List<KeyValue>) value;\n\nMap<String, List<Object>> rulesValueMap = \nnew HashMap<>(rulesDataList.size(), 1f);\nrules = new HashMap<>(rulesDataList.size());\nfor (KeyValue rkv : rulesDataList) {\nString ruleName = BuilderFactory.STRING.build(rkv.getKey());\n\nList<Object> ruleValueList = \nBuilderFactory.ENCODED_OBJECT_LIST.build(rkv.getValue());\n\nrulesValueMap.put(ruleName, ruleValueList);\nrules.put(ruleName, new Rule(ruleName, ruleValueList));\n}\nvalue = rulesValueMap;\n\nbreak;\ncase CHUNKS_PROPERTY:\nList<List<KeyValue>> chunksDataList = (List<List<KeyValue>>) value;\nList<Map<String, Object>> chunksValueList = new ArrayList<>(chunksDataList.size());\nchunks = new ArrayList<>(chunksDataList.size());\nfor (List<KeyValue> chunkDataAsList : chunksDataList) {\nMap<String, Object> chunk = chunkDataAsList.stream().collect(\nCollectors.toMap(kv -> BuilderFactory.STRING.build(kv.getKey()),\nkv -> BuilderFactory.ENCODED_OBJECT.build(kv.getValue())));\nchunksValueList.add(chunk);\nchunks.add(chunk);\n}\nvalue = chunksValueList;\n\nbreak;\ndefault:\nvalue = SafeEncoder.encodeObject(value);\nbreak;\n}\n    } \n\n    properties.put(prop, value);\n        }\n        return new TSInfo(properties, labels, rules, chunks);\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "48", "src_id": "M897", "code": "            @Override\n            public void addParams(CommandArguments args) {\n        if (retentionPeriod != null) {\n    args.add(RETENTION).add(toByteArray(retentionPeriod));\n        }\n        if (encoding != null) {\n    args.add(ENCODING).add(encoding);\n        }\n        if (chunkSize != null) {\n    args.add(CHUNK_SIZE).add(toByteArray(chunkSize));\n        }\n        if (duplicatePolicy != null) {\n    args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (duplicatePolicy != null) {\n    args.add(DUPLICATE_POLICY).add(duplicatePolicy);\n        }\n        if (onDuplicate != null) {\n    args.add(ON_DUPLICATE).add(onDuplicate);\n        }\n\n        if (ignore) {\n    args.add(IGNORE).add(ignoreMaxTimediff).add(ignoreMaxValDiff);\n        }\n\n        if (labels != null) {\n    args.add(LABELS);\n    labels.entrySet()\n    .forEach((entry) -> \n    args.add(entry.getKey()).add(entry.getValue()));\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "49", "src_id": "M1213", "code": "            @Override\n            public Connection getConnection() {\n        List<ConnectionPool> pools = getShuffledNodesPool();\n        JedisException suppressed = null;\n        for (ConnectionPool pool : pools) {\n    Connection jedis = null;\n    try {\njedis = pool.getResource();\nif (jedis != null) { \njedis.ping();\n\nreturn jedis;\n} \n    } catch (JedisException ex) {\nif (suppressed == null) { // remembering first suppressed exception\nsuppressed = ex;\n}\nif (jedis != null) {\njedis.close();\n}\n    }\n        }\n        JedisException noReachableNode = new JedisException(\"No reachable shard.\");\n\n        if (suppressed != null) {\n    noReachableNode.addSuppressed(suppressed);\n        }\n\n        throw noReachableNode;\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "50", "src_id": "M9", "code": "            @Override\n            public CacheEntry set(CacheKey cacheKey, CacheEntry entry) {\n        lock.lock();\n\n        try {\n    entry = putIntoStore(cacheKey, entry);\n    EvictionPolicy policy = getEvictionPolicy();\n\n    policy.touch(cacheKey);\n\n    CacheKey evictedKey = policy.evictNext();\n\n    if (evictedKey != null) {\ndelete(evictedKey);\n\nstats.evict();\n    }\n\n    for (Object redisKey : cacheKey.getRedisKeys()) {\nByteBuffer mapKey = makeKeyForRedisKeysToCacheKeys(redisKey);\nif (redisKeysToCacheKeys.containsKey(mapKey)) {\nredisKeysToCacheKeys.get(mapKey).add(cacheKey);\n} else {\nSet<CacheKey<?>> set = ConcurrentHashMap.newKeySet();\n\nset.add(cacheKey);\n\nredisKeysToCacheKeys.put(mapKey, set);\n\n}\n    }\n\n    stats.load();\n    return entry;\n        } finally {\n    lock.unlock();\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "51", "src_id": "M1105", "code": "            @Override\n            public Class<?> build(Object data) {\n        if (data == null) {\n    return null;\n        }\n        String str = STRING.build(data);\n        switch (str) {\n    case \"null\":\nreturn null;\n    case \"boolean\":\nreturn boolean.class;\n    case \"integer\":\nreturn int.class;\n    case \"number\":\nreturn float.class;\n    case \"string\":\nreturn String.class;\n    case \"object\":\nreturn Object.class;\n    case \"array\":\nreturn List.class;\n    default:\nthrow new JedisException(\"Unknown type: \" + str);\n        }\n            }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "166", "src_id": "M1043", "code": "    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n\n        Thread thread = Thread.currentThread();\n\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n\n        Exception exception = null;\n\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException \n            || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "167", "src_id": "M1031", "code": "    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" \n            + conn.getHeaderField(\"Content-Range\"));\n        }\n\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // let the download thread handle this error\n            default:\n                if (200 > statusCode || statusCode > 299) {\n                    throw new HttpError(statusCode);\n                }\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "168", "src_id": "M827", "code": "    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n\n        final Elst obj = new Elst();\n\n        final boolean v1 = stream.read() == 1;\n\n        stream.skipBytes(3); // flags\n        final int entryCount = stream.readInt();\n        if (1> entryCount) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n        if (!v1) {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        }\n\n        else {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } \n\n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "169", "src_id": "M1048", "code": "    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n        if (DEBUG && !mMission.unknownLength && start > 0) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n        try {\n            long rangeStart = (mMission.unknownLength || 1> start) ? -1 : start;\n            int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n            mMission.establishConnection(mId, mConn);\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && start > 0) {\n                mMission.notifyProgress(-start);\n                start = 0;\n\n                mRetryCount--;\n\n                throw new DownloadMission.HttpError(416);\n            }\n            // secondary check for the file length\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            }\n\n            if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n            mF = mMission.storage.getStream();\n\n            mF.seek(mMission.offsets[mMission.current] + start);\n\n            mIs = mConn.getInputStream();\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n\n            int len = 0;\n\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n\n            dispose();\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n\n                return;\n            }\n\n            if (mMission.maxRetry <= mRetryCount++) {\n                mMission.notifyError(e);\n                return;\n            }\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n            run(); // try again\n\n            return;\n        }\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "170", "src_id": "M1141", "code": "    private void flushAuxiliar(long amount) throws IOException {\n        if (1> aux.length) {\n            return;\n        }\n        out.flush();\n\n        aux.flush();\n\n        boolean underflow = aux.length > aux.offset || out.length> out.offset;\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n        aux.target.seek(0);\n        out.target.seek(out.length);\n\n        long length = amount;\n\n        while (length > 0) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (1> read) {\n                amount -= length;\n                break;\n            }\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n\n        if (!underflow) {\n            out.offset += amount;\n            aux.offset -= amount;\n        } else {\n            if (out.length> out.offset) {\n                aux.offset = 0;\n            } else {\n                // calculate the aux underflow pointer\n                if (amount <= aux.offset) {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                } else {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } \n            } \n        } \n\n        out.length += amount;\n        if (out.length > maxLengthKnown) {\n            maxLengthKnown = out.length;\n        }\n        if (aux.length> amount) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n\n            aux.length -= amount;\n\n            length = aux.length;\n\n            while (length > 0) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n                writeOffset += read;\n\n                readOffset += read;\n\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n        if (aux.length > THRESHOLD_AUX_LENGTH) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n        }\n\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "171", "src_id": "M1106", "code": "    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n        request.append(\" [\");\n\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo) {\n                request.append(' ').append(recovery.toString()).append(' ');\n            }\n        }\n\n        request.append(\"]\");\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(mContext, new ErrorInfo(\n        ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "172", "src_id": "M1067", "code": "    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n\n            mission.mHandler = mHandler;\n\n            mission.maxRetry = mPrefMaxRetry;\n            // create metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile()) {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n\n            }\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                // noting to do here\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n\n                return;\n            }\n\n            boolean start = !mPrefQueueLimit || 1> getRunningMissionsCount();\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "173", "src_id": "M1136", "code": "    @Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n        if (!(format == null || format.equals(\"ttml\"))) {\n            if (format.equals(\"srt\")) {\n                byte[] buffer = new byte[8 * 1024];\n                int read;\n                while ((read = sources[0].read(buffer)) > 0) {\n                    out.write(buffer, 0, read);\n                }\n                return OK_RESULT;\n            }\n        } else {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n\n                return err instanceof IOException ? 1 : 8;\n            }\n\n            return OK_RESULT;\n        } \n\n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "174", "src_id": "M1047", "code": "    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (millis > 0) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n\n                    return;\n                }\n            }\n        }// if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == Thread.currentThread()) {\n                continue;\n            }\n            thread.interrupt();\n        }\n\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue;\n                }\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n                if (millis > 0) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "113", "src_id": "M1043", "code": "        private void doPostprocessing() {\n            errCode=ERROR_NOTHING;\n            errObject=null;\n\n            Thread thread=Thread.currentThread();\n\n            notifyPostProcessing(1);\n\n            if (DEBUG) {\n                thread.setName(\"[\"+TAG+\"]  ps = \"+psAlgorithm+\"  filename = \"+storage.getName());\n            }\n            Exception exception=null;\n            try {\n                psAlgorithm.run(this);\n            } catch (Exception err) {\n                Log.e(TAG, \"Post-processing failed. \"+psAlgorithm.toString(), err);\n                if (errinstanceofInterruptedIOException||errinstanceofClosedByInterruptException||thread.isInterrupted()) {\n                    notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                    return;\n                }\n                if (errCode==ERROR_NOTHING) {\n                    errCode=ERROR_POSTPROCESSING;\n                }\n                exception=err;\n            } finally {\n                notifyPostProcessing(errCode==ERROR_NOTHING ? 2 : 0);\n            }\n\n            if (errCode!=ERROR_NOTHING) {\n                if (exception==null) {\n                    exception=errObject;\n                }\n                notifyError(ERROR_POSTPROCESSING, exception);\n                return;\n            }\n\n            notifyFinished();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "114", "src_id": "M1031", "code": "        void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n            int statusCode=conn.getResponseCode();\n            if (DEBUG) {\n                Log.d(TAG, threadId+\":[request]  Range=\"+conn.getRequestProperty(\"Range\"));\n                Log.d(TAG, threadId+\":[response] Code=\"+statusCode);\n                Log.d(TAG, threadId+\":[response] Content-Length=\"+conn.getContentLength());\n                Log.d(TAG, threadId+\":[response] Content-Range=\"+conn.getHeaderField(\"Content-Range\"));\n            }\n            switch (statusCode) {\n                case 204:\n                case 205:\n                case 207:\n                    throw new HttpError(statusCode);\n                case 416:\n                    return; // let the download thread handle this error\n                default:\n                    if (statusCode<200||statusCode>299) {\n                        throw new HttpError(statusCode);\n                    }\n            }\n\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "115", "src_id": "M827", "code": "        private Elst parseEdts(final Box ref) throws IOException {\n            final Box b=untilBox(ref, ATOM_ELST);\n            if (b==null) {\n                return null;\n            }\n            final Elst obj=new Elst();\n            final boolean v1=stream.read()==1;\n            stream.skipBytes(3); // flags\n            final int entryCount=stream.readInt();\n            if (entryCount<1) {\n                obj.bMediaRate=0x00010000; // default media rate (1.0)\n                return obj;\n            }\n            if (v1) {\n                stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n                obj.mediaTime=stream.readLong();\n                // ignore all remain entries\n                stream.skipBytes((entryCount-1)*(DataReader.LONG_SIZE*2));\n            } else {\n                stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n                obj.mediaTime=stream.readInt();\n            }\n            obj.bMediaRate=stream.readInt();\n            return obj;\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "116", "src_id": "M1048", "code": "        @Override\n        public void run() {\n            boolean done;\n            long start=mMission.fallbackResumeOffset;\n\n            if (DEBUG&&!mMission.unknownLength&&start>0) {\n                Log.i(TAG, \"Resuming a single-thread download at \"+start);\n            }\n\n            try {\n                long rangeStart=(mMission.unknownLength||start<1) ? -1 : start;\n                int mId=1;\n                mConn=mMission.openConnection(false, rangeStart, -1);\n\n                if (mRetryCount==0&&rangeStart==-1) {\n                    // workaround: bypass android connection pool\n                    mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n                }\n                mMission.establishConnection(mId, mConn);\n                // check if the download can be resumed\n                if (mConn.getResponseCode()==416&&start>0) {\n                    mMission.notifyProgress(-start);\n                    start=0;\n\n                    mRetryCount--;\n\n                    throw new DownloadMission.HttpError(416);\n                }\n                // secondary check for the file length\n                if (!mMission.unknownLength)\n                {\n                    mMission.unknownLength=Utility.getContentLength(mConn)==-1;\n                }\n\n                if (mMission.unknownLength||mConn.getResponseCode()==200) {\n                    // restart amount of bytes downloaded\n                    mMission.done=mMission.offsets[mMission.current]-mMission.offsets[0];\n                }\n                mF=mMission.storage.getStream();\n                mF.seek(mMission.offsets[mMission.current]+start);\n                mIs=mConn.getInputStream();\n                byte[] buf=new byte[DownloadMission.BUFFER_SIZE];\n                int len=0;\n\n                while (mMission.running&&(len=mIs.read(buf, 0, buf.length))!=-1) {\n                    mF.write(buf, 0, len);\n                    start+=len;\n                    mMission.notifyProgress(len);\n                }\n\n                dispose();\n\n                // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n                done=len==-1;\n            } catch (Exception e) {\n                dispose();\n                mMission.fallbackResumeOffset=start;\n\n                if (!mMission.running||einstanceofClosedByInterruptException) {\n                    return;\n                }\n                if (einstanceofHttpError&&((HttpError) e).statusCode==ERROR_HTTP_FORBIDDEN) {\n                    // for youtube streams. The url has expired, recover\n                    dispose();\n                    mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n\n                    return;\n                }\n                if (mRetryCount++>=mMission.maxRetry) {\n                    mMission.notifyError(e);\n                    return;\n                }\n                if (DEBUG) {\n                    Log.e(TAG, \"got exception, retrying...\", e);\n                }\n                run(); // try again\n\n                return;\n            }\n            if (done) {\n                mMission.notifyFinished();\n            } else {\n                mMission.fallbackResumeOffset=start;\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "117", "src_id": "M1141", "code": "        private void flushAuxiliar(long amount) throws IOException {\n            if (aux.length<1) {\n                return;\n            }\n            out.flush();\n\n            aux.flush();\n\n            boolean underflow=aux.offset<aux.length||out.offset<out.length;\n            byte[] buffer=new byte[COPY_BUFFER_SIZE];\n            aux.target.seek(0);\n            out.target.seek(out.length);\n            long length=amount;\n\n            while (length>0) {\n                int read=(int) Math.min(length, Integer.MAX_VALUE);\n                read=aux.target.read(buffer, 0, Math.min(read, buffer.length));\n                if (read<1) {\n                    amount-=length;\n                    break;\n                }\n                out.writeProof(buffer, read);\n                length-=read;\n            }\n\n            if (underflow) {\n                if (out.offset>=out.length) {\n                    // calculate the aux underflow pointer\n                    if (aux.offset<amount) {\n                        out.offset+=aux.offset;\n                        aux.offset=0;\n                        out.target.seek(out.offset);\n                    } else {\n                        aux.offset-=amount;\n                        out.offset=out.length+amount;\n                    }\n                } else {\n                    aux.offset=0;\n                }\n            } else {\n                out.offset+=amount;\n                aux.offset-=amount;\n            }\n\n            out.length+=amount;\n\n            if (out.length>maxLengthKnown) {\n                maxLengthKnown=out.length;\n            }\n\n            if (amount<aux.length) {\n                // move the excess data to the beginning of the file\n                long readOffset=amount;\n                long writeOffset=0;\n\n                aux.length-=amount;\n\n                length=aux.length;\n\n                while (length>0) {\n                    int read=(int) Math.min(length, Integer.MAX_VALUE);\n                    read=aux.target.read(buffer, 0, Math.min(read, buffer.length));\n                    aux.target.seek(writeOffset);\n                    aux.writeProof(buffer, read);\n                    writeOffset+=read;\n                    readOffset+=read;\n\n                    length-=read;\n                    aux.target.seek(readOffset);\n                }\n                aux.target.setLength(aux.length);\n                return;\n            }\n\n            if (aux.length>THRESHOLD_AUX_LENGTH) {\n                aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n            }\n            aux.reset();\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "118", "src_id": "M1106", "code": "        private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n            StringBuilder request=new StringBuilder(256);\n            request.append(mission.source);\n            request.append(\" [\");\n            if (mission.recoveryInfo!=null) {\n                for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n                {\n                    request.append(' ').append(recovery.toString()).append(' ');\n                }\n            }\n\n            request.append(\"]\");\n\n            String service;\n\n            try {\n                service=NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n            } catch (Exception e) {\n                service=ErrorInfo.SERVICE_NONE;\n            }\n\n            ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "119", "src_id": "M1067", "code": "        void startMission(DownloadMission mission) {\n            synchronized (this) {\n                mission.timestamp=System.currentTimeMillis();\n                mission.mHandler=mHandler;\n                mission.maxRetry=mPrefMaxRetry;\n                // create metadata file\n                while (true) {\n                    mission.metadata=new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                    if (!mission.metadata.isFile()&&!mission.metadata.exists()) {\n                        try {\n                            if (!mission.metadata.createNewFile())\n                            {\n                                throw new RuntimeException(\"Cant create download metadata file\");\n                            }\n                        } catch (IOException e) {\n                            throw new RuntimeException(e);\n                        }\n                        break;\n                    }\n                    mission.timestamp=System.currentTimeMillis();\n                }\n                mSelfMissionsControl=true;\n                mMissionsPending.add(mission);\n                // Before continue, save the metadata in case the internet connection is not available\n                Utility.writeToFile(mission.metadata, mission);\n                if (mission.storage==null) {\n                    // noting to do here\n                    mission.errCode=DownloadMission.ERROR_FILE_CREATION;\n                    if (mission.errObject!=null)\n                    {\n                        mission.errObject=new IOException(\"DownloadMission.storage == NULL\");\n                    }\n                    return;\n                }\n                boolean start=!mPrefQueueLimit||getRunningMissionsCount()<1;\n                if (canDownloadInCurrentNetwork()&&start) {\n                    mission.start();\n                }\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "120", "src_id": "M1136", "code": "        @Override\n        int process(SharpStream out, SharpStream... sources) throws IOException {\n            // check if the subtitle is already in srt and copy, this should never happen\n            String format=getArgumentAt(0, null);\n            boolean ignoreEmptyFrames=getArgumentAt(1, \"true\").equals(\"true\");\n            if (format==null||format.equals(\"ttml\")) {\n                SrtFromTtmlWriter writer=new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n                try {\n                    writer.build(sources[0]);\n                } catch (Exception err) {\n                    Log.e(TAG, \"subtitle parse failed\", err);\n                    return errinstanceofIOException ? 1 : 8;\n                }\n                return OK_RESULT;\n            } else {\n                if (format.equals(\"srt\")) {\n                    byte[] buffer=new byte[8*1024];\n                    int read;\n                    while ((read=sources[0].read(buffer))>0) {\n                        out.write(buffer, 0, read);\n                    }\n\n                    return OK_RESULT;\n                }\n            }\n            throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \"+format);\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "121", "src_id": "M1047", "code": "        private void joinForThreads(int millis) {\n            final Thread currentThread=Thread.currentThread();\n            if (init!=null&&init!=currentThread&&init.isAlive()) {\n                init.interrupt();\n                if (millis>0) {\n                    try {\n                        init.join(millis);\n                    } catch (InterruptedException e) {\n                        Log.w(TAG, \"Initializer thread is still running\", e);\n                        return;\n                    }\n                }\n            }// if a thread is still alive, possible reasons:\n            //      slow device\n            //      the user is spamming start/pause buttons\n            //      start() method called quickly after pause()\n\n            for (Thread thread : threads) {\n                if (!thread.isAlive()||thread==Thread.currentThread()) {\n                    continue;\n                }\n                thread.interrupt();\n            }\n            try {\n                for (Thread thread : threads) {\n                    if (!thread.isAlive()) {\n                        continue;\n                    }\n                    if (DEBUG) {\n                        Log.w(TAG, \"thread alive: \"+thread.getName());\n                    }\n                    if (millis>0) {\n                        thread.join(millis);\n                    }\n                }\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"A download thread is still running\", e);\n            }\n        }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "146", "src_id": "M31", "code": "    private JsonNode validateLicense(String licenseKey, String machineFingerprint, LicenseContext context) throws Exception {\n      String requestBody = String.format(\"{\\\"meta\\\":{\\\"key\\\":\\\"%s\\\",\\\"scope\\\":{\\\"fingerprint\\\":\\\"%s\\\"}}}\", licenseKey, machineFingerprint);\n      HttpRequest request = HttpRequest.newBuilder().uri(URI.create(BASE_URL + \"/\" + ACCOUNT_ID + \"/licenses/actions/validate-key\")).header(\"Content-Type\", \"application/vnd.api+json\").header(\"Accept\", \"application/vnd.api+json\")// .header(\"Authorization\", \"License \" + licenseKey)\n      .POST(HttpRequest.BodyPublishers.ofString(requestBody)).build();\n      HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n      log.debug(\"ValidateLicenseResponse body: {}\", response.body());\n      JsonNode jsonResponse = objectMapper.readTree(response.body());\n      if (response.statusCode() == 200) {\n        JsonNode metaNode = jsonResponse.path(\"meta\");\n\n        boolean isValid = metaNode.path(\"valid\").asBoolean();\n        String detail = metaNode.path(\"detail\").asText();\n        String code = metaNode.path(\"code\").asText();\n\n        log.info(\"License validity: {}\", isValid);\n\n        log.info(\"Validation detail: {}\", detail);\n\n        log.info(\"Validation code: {}\", code);\n\n        // Check if the license itself has floating attribute\n        JsonNode licenseAttrs = jsonResponse.path(\"data\").path(\"attributes\");\n\n        if (!licenseAttrs.isMissingNode()) {\n\n          context.isFloatingLicense = licenseAttrs.path(\"floating\").asBoolean(false);\n\n          context.maxMachines = licenseAttrs.path(\"maxMachines\").asInt(1);\n\n          log.info(\"License floating (from license): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n\n        }\n\n        // Also check the policy for floating license support if included\n        JsonNode includedNode = jsonResponse.path(\"included\");\n        JsonNode policyNode = null;\n        if (includedNode.isArray()) {\n          for (JsonNode node : includedNode) {\n            if (\"policies\".equals(node.path(\"type\").asText())) {\n              policyNode = node;\n              break;\n\n            }\n          }\n        }\n\n        if (policyNode != null) {\n\n          // Check if this is a floating license from policy\n          boolean policyFloating = policyNode.path(\"attributes\").path(\"floating\").asBoolean(false);\n\n          int policyMaxMachines = policyNode.path(\"attributes\").path(\"maxMachines\").asInt(1);\n\n          // Policy takes precedence over license attributes\n          if (policyFloating) {\n            context.isFloatingLicense = true;\n            context.maxMachines = policyMaxMachines;\n          }\n\n          log.info(\"License floating (from policy): {}, maxMachines: {}\", context.isFloatingLicense, context.maxMachines);\n        }\n\n        // Extract user count, default to 1 if not specified\n        int users = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"users\").asInt(1);\n        applicationProperties.getPremium().setMaxUsers(users);\n        // Extract isEnterprise flag\n        context.isEnterpriseLicense = jsonResponse.path(\"data\").path(\"attributes\").path(\"metadata\").path(\"isEnterprise\").asBoolean(false);\n        log.debug(applicationProperties.toString());\n      } else {\n        log.error(\"Error validating license. Status code: {}\", response.statusCode());\n      }\n      return jsonResponse;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "147", "src_id": "M488", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/file/pdf\")\n    @Operation(\n    summary = \"Convert a file to a PDF using LibreOffice\",\n    description =\n    \"This endpoint converts a given file to a PDF using LibreOffice API  Input:ANY\" + \" Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> processFileToPDF(@ModelAttribute GeneralFile generalFile)\n    throws Exception {\n      MultipartFile inputFile = generalFile.getFileInput();\n\n      // unused but can start server instance if startup time is to long\n      // LibreOfficeListener.getInstance().start();\n      File file = null;\n      try {\n        file = convertToPdf(inputFile);\n        PDDocument doc = pdfDocumentFactory.load(file);\n        return WebResponseUtils.pdfDocToWebResponse(doc, Filenames.toSimpleFileName(inputFile.getOriginalFilename()).replaceFirst(\"[.][^.]+$\", \"\") + \"_convertedToPDF.pdf\");\n      } finally {\n        if (file != null) {\n          file.delete();\n        }\n      }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "148", "src_id": "M625", "code": "    @PostMapping(consumes = \"multipart/form-data\", value = \"/get-info-on-pdf\")\n    @Operation(summary = \"Summary here\", description = \"desc. Input:PDF Output:JSON Type:SISO\")\n    public ResponseEntity<byte[]> getPdfInfo(@ModelAttribute PDFFile request) throws IOException {\n      MultipartFile inputFile = request.getFileInput();\n\n      boolean readonly = true;\n      try (PDDocument pdfBoxDoc = pdfDocumentFactory.load(inputFile, readonly); ) {\n        ObjectMapper objectMapper = new ObjectMapper();\n\n        ObjectNode jsonOutput = objectMapper.createObjectNode();\n        // Metadata using PDFBox\n        PDDocumentInformation info = pdfBoxDoc.getDocumentInformation();\n        ObjectNode metadata = objectMapper.createObjectNode();\n        ObjectNode basicInfo = objectMapper.createObjectNode();\n        ObjectNode docInfoNode = objectMapper.createObjectNode();\n        ObjectNode compliancy = objectMapper.createObjectNode();\n        ObjectNode encryption = objectMapper.createObjectNode();\n        ObjectNode other = objectMapper.createObjectNode();\n        metadata.put(\"Title\", info.getTitle());\n\n        metadata.put(\"Author\", info.getAuthor());\n\n        metadata.put(\"Subject\", info.getSubject());\n\n        metadata.put(\"Keywords\", info.getKeywords());\n\n        metadata.put(\"Producer\", info.getProducer());\n\n        metadata.put(\"Creator\", info.getCreator());\n\n        metadata.put(\"CreationDate\", formatDate(info.getCreationDate()));\n        metadata.put(\"ModificationDate\", formatDate(info.getModificationDate()));\n        jsonOutput.set(\"Metadata\", metadata);\n\n        // Total file size of the PDF\n        long fileSizeInBytes = inputFile.getSize();\n\n        basicInfo.put(\"FileSizeInBytes\", fileSizeInBytes);\n        // Number of words, paragraphs, and images in the entire document\n        String fullText = new PDFTextStripper().getText(pdfBoxDoc);\n        String[] words = fullText.split(\"\\\\s+\");\n\n        int wordCount = words.length;\n        int paragraphCount = fullText.split(\"\\r\\n|\\r|\\n\").length;\n        basicInfo.put(\"WordCount\", wordCount);\n        basicInfo.put(\"ParagraphCount\", paragraphCount);\n        // Number of characters in the entire document (including spaces and special characters)\n        int charCount = fullText.length();\n        basicInfo.put(\"CharacterCount\", charCount);\n        // Initialize the flags and types\n        boolean hasCompression = false;\n        String compressionType = \"None\";\n        basicInfo.put(\"Compression\", hasCompression);\n        if (hasCompression) {\n          basicInfo.put(\"CompressionType\", compressionType);\n        }\n        String language = pdfBoxDoc.getDocumentCatalog().getLanguage();\n        basicInfo.put(\"Language\", language);\n        basicInfo.put(\"Number of pages\", pdfBoxDoc.getNumberOfPages());\n        PDDocumentCatalog catalog = pdfBoxDoc.getDocumentCatalog();\n        String pageMode = catalog.getPageMode().name();\n        // Document Information using PDFBox\n        docInfoNode.put(\"PDF version\", pdfBoxDoc.getVersion());\n        docInfoNode.put(\"Trapped\", info.getTrapped());\n        docInfoNode.put(\"Page Mode\", getPageModeDescription(pageMode));\n        ;\n        PDAcroForm acroForm = pdfBoxDoc.getDocumentCatalog().getAcroForm();\n        ObjectNode formFieldsNode = objectMapper.createObjectNode();\n        if (acroForm != null) {\n          for (PDField field : acroForm.getFieldTree()) {\n            formFieldsNode.put(field.getFullyQualifiedName(), field.getValueAsString());\n          }\n        }\n        jsonOutput.set(\"FormFields\", formFieldsNode);\n        // Generate structured summary data about PDF characteristics\n        ObjectNode summaryData = generatePDFSummaryData(pdfBoxDoc);\n\n        if (summaryData != null && 0< summaryData.size()) {\n          jsonOutput.set(\"SummaryData\", summaryData);\n        }\n\n        // embeed files TODO size\n        if (catalog.getNames() != null) {\n\n          PDEmbeddedFilesNameTreeNode efTree = catalog.getNames().getEmbeddedFiles();\n\n          ArrayNode embeddedFilesArray = objectMapper.createArrayNode();\n          if (efTree != null) {\n            Map<String, PDComplexFileSpecification> efMap = efTree.getNames();\n            if (efMap != null) {\n              for (Map.Entry<String, PDComplexFileSpecification> entry : efMap.entrySet()) {\n                ObjectNode embeddedFileNode = objectMapper.createObjectNode();\n                embeddedFileNode.put(\"Name\", entry.getKey());\n                PDEmbeddedFile embeddedFile = entry.getValue().getEmbeddedFile();\n\n                if (embeddedFile != null) {\n                  embeddedFileNode.put(\"FileSize\", embeddedFile.getLength()); // size in bytes\n                }\n\n                embeddedFilesArray.add(embeddedFileNode);\n\n              }\n            }\n          }\n          other.set(\"EmbeddedFiles\", embeddedFilesArray);\n        }\n\n        // attachments TODO size\n        ArrayNode attachmentsArray = objectMapper.createArrayNode();\n        for (PDPage page : pdfBoxDoc.getPages()) {\n          for (PDAnnotation annotation : page.getAnnotations()) {\n            if (annotation instanceof PDAnnotationFileAttachment fileAttachmentAnnotation) {\n\n              ObjectNode attachmentNode = objectMapper.createObjectNode();\n\n              attachmentNode.put(\"Name\", fileAttachmentAnnotation.getAttachmentName());\n              attachmentNode.put(\"Description\", fileAttachmentAnnotation.getContents());\n\n              attachmentsArray.add(attachmentNode);\n            }\n          }\n        }\n\n        other.set(\"Attachments\", attachmentsArray);\n        // Javascript\n        PDDocumentNameDictionary namesDict = catalog.getNames();\n        ArrayNode javascriptArray = objectMapper.createArrayNode();\n        if (namesDict != null) {\n\n          PDJavascriptNameTreeNode javascriptDict = namesDict.getJavaScript();\n\n          if (javascriptDict != null) {\n            try {\n              Map<String, PDActionJavaScript> jsEntries = javascriptDict.getNames();\n              for (Map.Entry<String, PDActionJavaScript> entry : jsEntries.entrySet()) {\n                ObjectNode jsNode = objectMapper.createObjectNode();\n\n                jsNode.put(\"JS Name\", entry.getKey());\n\n                PDActionJavaScript jsAction = entry.getValue();\n\n                if (jsAction != null) {\n                  String jsCodeStr = jsAction.getAction();\n                  if (jsCodeStr != null) {\n                    jsNode.put(\"JS Script Length\", jsCodeStr.length());\n                  }\n                }\n                javascriptArray.add(jsNode);\n              }\n            } catch (IOException e) {\n              log.error(\"exception\", e);\n            }\n          }\n        }\n\n        other.set(\"JavaScript\", javascriptArray);\n        // TODO size\n        PDOptionalContentProperties ocProperties = pdfBoxDoc.getDocumentCatalog().getOCProperties();\n        ArrayNode layersArray = objectMapper.createArrayNode();\n        if (ocProperties != null) {\n          for (PDOptionalContentGroup ocg : ocProperties.getOptionalContentGroups()) {\n            ObjectNode layerNode = objectMapper.createObjectNode();\n\n            layerNode.put(\"Name\", ocg.getName());\n            layersArray.add(layerNode);\n          }\n        }\n        other.set(\"Layers\", layersArray);// TODO Security\n\n        PDStructureTreeRoot structureTreeRoot = pdfBoxDoc.getDocumentCatalog().getStructureTreeRoot();\n\n        ArrayNode structureTreeArray;\n        try {\n          if (structureTreeRoot != null) {\n\n            structureTreeArray = exploreStructureTree(structureTreeRoot.getKids());\n\n            other.set(\"StructureTree\", structureTreeArray);\n\n          }\n        } catch (Exception e) {\n          // TODO Auto-generated catch block\n          log.error(\"exception\", e);\n        }\n\n        boolean isPdfACompliant = checkForStandard(pdfBoxDoc, \"PDF/A\");\n        boolean isPdfXCompliant = checkForStandard(pdfBoxDoc, \"PDF/X\");\n        boolean isPdfECompliant = checkForStandard(pdfBoxDoc, \"PDF/E\");\n        boolean isPdfVTCompliant = checkForStandard(pdfBoxDoc, \"PDF/VT\");\n        boolean isPdfUACompliant = checkForStandard(pdfBoxDoc, \"PDF/UA\");\n        boolean isPdfBCompliant = checkForStandard(pdfBoxDoc, \"PDF/B\"); // If you want to check for PDF/Broadcast, though this isn't\n        // an official ISO standard.\n        boolean isPdfSECCompliant = checkForStandard(pdfBoxDoc, \"PDF/SEC\"); // This might not be effective since PDF/SEC was under\n        // development in 2021.\n        compliancy.put(\"IsPDF/ACompliant\", isPdfACompliant);\n        compliancy.put(\"IsPDF/XCompliant\", isPdfXCompliant);\n        compliancy.put(\"IsPDF/ECompliant\", isPdfECompliant);\n        compliancy.put(\"IsPDF/VTCompliant\", isPdfVTCompliant);\n        compliancy.put(\"IsPDF/UACompliant\", isPdfUACompliant);\n        compliancy.put(\"IsPDF/BCompliant\", isPdfBCompliant);\n        compliancy.put(\"IsPDF/SECCompliant\", isPdfSECCompliant);\n\n        PDOutlineNode root = pdfBoxDoc.getDocumentCatalog().getDocumentOutline();\n        ArrayNode bookmarksArray = objectMapper.createArrayNode();\n        if (root != null) {\n          for (PDOutlineItem child : root.children()) {\n            addOutlinesToArray(child, bookmarksArray);\n          }\n        }\n        other.set(\"Bookmarks/Outline/TOC\", bookmarksArray);\n\n        PDMetadata pdMetadata = pdfBoxDoc.getDocumentCatalog().getMetadata();\n        String xmpString = null;\n        if (pdMetadata != null) {\n          try {\n            try (COSInputStream is = pdMetadata.createInputStream()) {\n              DomXmpParser domXmpParser = new DomXmpParser();\n              XMPMetadata xmpMeta = domXmpParser.parse(is);\n\n              ByteArrayOutputStream os = new ByteArrayOutputStream();\n              new XmpSerializer().serialize(xmpMeta, os, true);\n              xmpString = new String(os.toByteArray(), StandardCharsets.UTF_8);\n            }\n          } catch (XmpParsingException e) {\n\n            // XMP parsing failed, try to read raw metadata instead\n            log.debug(\"XMP parsing failed, reading raw metadata: {}\", e.getMessage());\n\n            try (COSInputStream is = pdMetadata.createInputStream()) {\n              byte[] metadataBytes = is.readAllBytes();\n              xmpString = new String(metadataBytes, StandardCharsets.UTF_8);\n            }\n          } catch (IOException e) {\n            log.error(\"exception\", e);\n          }\n        }\n        other.put(\"XMPMetadata\", xmpString);\n\n        if (pdfBoxDoc.isEncrypted()) {\n          encryption.put(\"IsEncrypted\", true);\n\n          // Retrieve encryption details using getEncryption()\n          PDEncryption pdfEncryption = pdfBoxDoc.getEncryption();\n          encryption.put(\"EncryptionAlgorithm\", pdfEncryption.getFilter());\n          encryption.put(\"KeyLength\", pdfEncryption.getLength());\n          // Add other encryption-related properties as needed\n        } else {\n          encryption.put(\"IsEncrypted\", false);\n        }\n\n        ObjectNode permissionsNode = objectMapper.createObjectNode();\n        setNodePermissions(pdfBoxDoc, permissionsNode);\n        ObjectNode pageInfoParent = objectMapper.createObjectNode();\n        for (int pageNum = 0; pageNum < pdfBoxDoc.getNumberOfPages(); pageNum++) {\n          ObjectNode pageInfo = objectMapper.createObjectNode();\n\n          // Retrieve the page\n          PDPage page = pdfBoxDoc.getPage(pageNum);\n\n          // Page-level Information\n          PDRectangle mediaBox = page.getMediaBox();\n          float width = mediaBox.getWidth();\n          float height = mediaBox.getHeight();\n\n          ObjectNode sizeInfo = objectMapper.createObjectNode();\n          getDimensionInfo(sizeInfo, width, height);\n          sizeInfo.put(\"Standard Page\", getPageSize(width, height));\n\n          pageInfo.set(\"Size\", sizeInfo);\n\n          pageInfo.put(\"Rotation\", page.getRotation());\n          pageInfo.put(\"Page Orientation\", getPageOrientation(width, height));\n\n          // Boxes\n          pageInfo.put(\"MediaBox\", mediaBox.toString());\n\n          // Assuming the following boxes are defined for your document; if not, you may get\n          // null values.\n          PDRectangle cropBox = page.getCropBox();\n\n          pageInfo.put(\"CropBox\", cropBox == null ? \"Undefined\" : cropBox.toString());\n\n          PDRectangle bleedBox = page.getBleedBox();\n\n          pageInfo.put(\"BleedBox\", bleedBox == null ? \"Undefined\" : bleedBox.toString());\n\n          PDRectangle trimBox = page.getTrimBox();\n\n          pageInfo.put(\"TrimBox\", trimBox == null ? \"Undefined\" : trimBox.toString());\n\n          PDRectangle artBox = page.getArtBox();\n\n          pageInfo.put(\"ArtBox\", artBox == null ? \"Undefined\" : artBox.toString());\n\n          // Content Extraction\n          PDFTextStripper textStripper = new PDFTextStripper();\n\n          textStripper.setStartPage(pageNum + 1);\n\n          textStripper.setEndPage(pageNum + 1);\n\n          String pageText = textStripper.getText(pdfBoxDoc);\n          pageInfo.put(\"Text Characters Count\", pageText.length()); //\n          // Annotations\n          List<PDAnnotation> annotations = page.getAnnotations();\n\n          int subtypeCount = 0;\n          int contentsCount = 0;\n          for (PDAnnotation annotation : annotations) {\n            if (annotation.getSubtype() != null) {\n              subtypeCount++; // Increase subtype count\n            }\n\n            if (annotation.getContents() != null) {\n              contentsCount++; // Increase contents count\n            }\n\n          }\n          ObjectNode annotationsObject = objectMapper.createObjectNode();\n          annotationsObject.put(\"AnnotationsCount\", annotations.size());\n          annotationsObject.put(\"SubtypeCount\", subtypeCount);\n          annotationsObject.put(\"ContentsCount\", contentsCount);\n          pageInfo.set(\"Annotations\", annotationsObject);\n          // Images (simplified)\n          // This part is non-trivial as images can be embedded in multiple ways in a PDF.\n          // Here is a basic structure to recognize image XObjects on a page.\n          ArrayNode imagesArray = objectMapper.createArrayNode();\n          PDResources resources = page.getResources();\n          for (COSName name : resources.getXObjectNames()) {\n            PDXObject xObject = resources.getXObject(name);\n            if (xObject instanceof PDImageXObject image) {\n              ObjectNode imageNode = objectMapper.createObjectNode();\n\n              imageNode.put(\"Width\", image.getWidth());\n\n              imageNode.put(\"Height\", image.getHeight());\n\n              if (image.getMetadata() != null && image.getMetadata().getFile() != null && image.getMetadata().getFile().getFile() != null) {\n                imageNode.put(\"Name\", image.getMetadata().getFile().getFile());\n              }\n              if (image.getColorSpace() != null) {\n                imageNode.put(\"ColorSpace\", image.getColorSpace().getName());\n              }\n              imagesArray.add(imageNode);\n            }\n          }\n\n          pageInfo.set(\"Images\", imagesArray);\n          // Links\n          ArrayNode linksArray = objectMapper.createArrayNode();\n          Set<String> uniqueURIs = new HashSet<>(); // To store unique URIs\n          for (PDAnnotation annotation : annotations) {\n            if (annotation instanceof PDAnnotationLink linkAnnotation) {\n              if (linkAnnotation.getAction() instanceof PDActionURI uriAction) {\n                String uri = uriAction.getURI();\n                uniqueURIs.add(uri); // Add to set to ensure uniqueness\n              }\n            }\n          }\n\n          // Add unique URIs to linksArray\n          for (String uri : uniqueURIs) {\n            ObjectNode linkNode = objectMapper.createObjectNode();\n\n            linkNode.put(\"URI\", uri);\n            linksArray.add(linkNode);\n          }\n\n          pageInfo.set(\"Links\", linksArray);\n          // Fonts\n          ArrayNode fontsArray = objectMapper.createArrayNode();\n          Map<String, ObjectNode> uniqueFontsMap = new HashMap<>();\n          for (COSName fontName : resources.getFontNames()) {\n            PDFont font = resources.getFont(fontName);\n\n            ObjectNode fontNode = objectMapper.createObjectNode();\n            fontNode.put(\"IsEmbedded\", font.isEmbedded());\n            // PDFBox provides Font's BaseFont (i.e., the font name) directly\n            fontNode.put(\"Name\", font.getName());\n\n            fontNode.put(\"Subtype\", font.getType());\n\n            PDFontDescriptor fontDescriptor = font.getFontDescriptor();\n\n            if (fontDescriptor != null) {\n              fontNode.put(\"ItalicAngle\", fontDescriptor.getItalicAngle());\n              int flags = fontDescriptor.getFlags();\n\n              fontNode.put(\"IsItalic\", (flags & 1) != 0);\n\n              fontNode.put(\"IsBold\", (flags & 64) != 0);\n\n              fontNode.put(\"IsFixedPitch\", (flags & 2) != 0);\n\n              fontNode.put(\"IsSerif\", (flags & 4) != 0);\n\n              fontNode.put(\"IsSymbolic\", (flags & 8) != 0);\n\n              fontNode.put(\"IsScript\", (flags & 16) != 0);\n\n              fontNode.put(\"IsNonsymbolic\", (flags & 32) != 0);\n\n              fontNode.put(\"FontFamily\", fontDescriptor.getFontFamily());\n              // Font stretch and BBox are not directly available in PDFBox's API, so\n              // these are omitted for simplicity\n              fontNode.put(\"FontWeight\", fontDescriptor.getFontWeight());\n            }\n\n            // Create a unique key for this font node based on its attributes\n            String uniqueKey = fontNode.toString();\n\n            // Increment count if this font exists, or initialize it if new\n            if (uniqueFontsMap.containsKey(uniqueKey)) {\n              ObjectNode existingFontNode = uniqueFontsMap.get(uniqueKey);\n              int count = existingFontNode.get(\"Count\").asInt() + 1;\n              existingFontNode.put(\"Count\", count);\n            } else {\n              fontNode.put(\"Count\", 1);\n              uniqueFontsMap.put(uniqueKey, fontNode);\n            }\n          }\n\n          // Add unique font entries to fontsArray\n          for (ObjectNode uniqueFontNode : uniqueFontsMap.values()) {\n            fontsArray.add(uniqueFontNode);\n          }\n          pageInfo.set(\"Fonts\", fontsArray);\n\n          // Access resources dictionary\n          ArrayNode colorSpacesArray = objectMapper.createArrayNode();\n\n          Iterable<COSName> colorSpaceNames = resources.getColorSpaceNames();\n          for (COSName name : colorSpaceNames) {\n            PDColorSpace colorSpace = resources.getColorSpace(name);\n\n            if (colorSpace instanceof PDICCBased iccBased) {\n              PDStream iccData = iccBased.getPDStream();\n              byte[] iccBytes = iccData.toByteArray();\n\n              // TODO: Further decode and analyze the ICC data if needed\n              ObjectNode iccProfileNode = objectMapper.createObjectNode();\n              iccProfileNode.put(\"ICC Profile Length\", iccBytes.length);\n              colorSpacesArray.add(iccProfileNode);\n            }\n          }\n          pageInfo.set(\"Color Spaces & ICC Profiles\", colorSpacesArray);\n          // Other XObjects\n          Map<String, Integer> xObjectCountMap = new HashMap<>(); // To store the count for each type\n          for (COSName name : resources.getXObjectNames()) {\n            PDXObject xObject = resources.getXObject(name);\n            String xObjectType;\n            if (!(xObject instanceof PDImageXObject)) {\n              if (xObject instanceof PDFormXObject) {\n                xObjectType = \"Form\";\n              } else {\n                xObjectType = \"Other\";\n              }\n              // Increment the count for this type in the map\n            } else {\n              xObjectType = \"Image\";\n            } \n            xObjectCountMap.put(xObjectType, xObjectCountMap.getOrDefault(xObjectType, 0) + 1);\n\n          }\n          // Add the count map to pageInfo (or wherever you want to store it)\n          ObjectNode xObjectCountNode = objectMapper.createObjectNode();\n          for (Map.Entry<String, Integer> entry : xObjectCountMap.entrySet()) {\n            xObjectCountNode.put(entry.getKey(), entry.getValue());\n          }\n          pageInfo.set(\"XObjectCounts\", xObjectCountNode);\n          ArrayNode multimediaArray = objectMapper.createArrayNode();\n          for (PDAnnotation annotation : annotations) {\n            if (\"RichMedia\".equals(annotation.getSubtype())) {\n              ObjectNode multimediaNode = objectMapper.createObjectNode();\n              // Extract details from the annotation as needed\n              multimediaArray.add(multimediaNode);\n            }\n          }\n\n          pageInfo.set(\"Multimedia\", multimediaArray);\n          pageInfoParent.set(\"Page \" + (pageNum + 1), pageInfo);\n        }\n\n        jsonOutput.set(\"BasicInfo\", basicInfo);\n\n        jsonOutput.set(\"DocumentInfo\", docInfoNode);\n\n        jsonOutput.set(\"Compliancy\", compliancy);\n\n        jsonOutput.set(\"Encryption\", encryption);\n\n        jsonOutput.set(\"Permissions\", permissionsNode); // set the node under \"Permissions\"\n        jsonOutput.set(\"Other\", other);\n        jsonOutput.set(\"PerPageInfo\", pageInfoParent);\n        // Save JSON to file\n        String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonOutput);\n        return WebResponseUtils.bytesToWebResponse(jsonString.getBytes(StandardCharsets.UTF_8), \"response.json\", MediaType.APPLICATION_JSON);\n      } catch (Exception e) {\n        log.error(\"exception\", e);\n      }\n      return null;\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "149", "src_id": "M24", "code": "    private boolean verifyCertificateLicense(String licenseFile, LicenseContext context) {\n      try {\n        String encodedPayload = licenseFile;\n        // Remove the header\n        encodedPayload = encodedPayload.replace(CERT_PREFIX, \"\");\n        // Remove the footer\n        encodedPayload = encodedPayload.replace(CERT_SUFFIX, \"\");\n        // Remove all newlines\n        encodedPayload = encodedPayload.replaceAll(\"\\\\r?\\\\n\", \"\");\n        byte[] payloadBytes = Base64.getDecoder().decode(encodedPayload);\n        String payload = new String(payloadBytes);\n        log.info(\"Decoded certificate payload: {}\", payload);\n        String encryptedData = \"\";\n        String encodedSignature = \"\";\n        String algorithm = \"\";\n        try {\n          JSONObject attrs = new JSONObject(payload);\n          encryptedData = (String) attrs.get(\"enc\");\n\n          encodedSignature = (String) attrs.get(\"sig\");\n\n          algorithm = (String) attrs.get(\"alg\");\n        } catch (JSONException e) {\n          log.error(\"Failed to parse license file: {}\", e.getMessage());\n          return false;\n\n        }\n\n        // Verify license file algorithm\n        if (!\"base64+ed25519\".equals(algorithm)) {\n\n          log.error(\"Unsupported algorithm: {}. Only base64+ed25519 is supported.\", algorithm);\n\n          return false;\n\n        }\n\n        // Verify signature\n        boolean isSignatureValid = verifyEd25519Signature(encryptedData, encodedSignature);\n\n        if (!isSignatureValid) {\n          log.error(\"License file signature is invalid\");\n\n          return false;\n\n        }\n\n        log.info(\"License file signature is valid\");\n        // Decode the base64 data\n        String decodedData;\n        try {\n          decodedData = new String(Base64.getDecoder().decode(encryptedData));\n        } catch (IllegalArgumentException e) {\n          log.error(\"Failed to decode license data: {}\", e.getMessage());\n          return false;\n\n        }\n        // Process the certificate data\n        boolean isValid = processCertificateData(decodedData, context);\n        return isValid;\n\n      } catch (Exception e) {\n        log.error(\"Error verifying certificate license: {}\", e.getMessage(), e);\n        return false;\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "150", "src_id": "M403", "code": "    private static void sanitizeHtmlFilesInZip(Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n    throws IOException {\n      try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n        try (ZipInputStream zipIn = ZipSecurity.createHardenedInputStream(new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n          ZipEntry entry = zipIn.getNextEntry();\n          while (entry != null) {\n            Path filePath = tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n            if (!entry.isDirectory()) {\n              Files.createDirectories(filePath.getParent());\n\n              if (entry.getName().toLowerCase().endsWith(\".html\") || entry.getName().toLowerCase().endsWith(\".htm\")) {\n\n                String content = new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n\n                String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n\n                Files.write(filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n              } else {\n                Files.copy(zipIn, filePath);\n              }\n            }\n            zipIn.closeEntry();\n            entry = zipIn.getNextEntry();\n          }\n        }\n\n        // Repack the sanitized files\n        zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n      } // tempUnzippedDir auto-cleaned\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "151", "src_id": "M317", "code": "    public static void addImageToDocument(PDDocument doc, PDImageXObject image, String fitOption, boolean autoRotate)\n    throws IOException {\n      boolean imageIsLandscape = image.getHeight()< image.getWidth();\n      PDRectangle pageSize = PDRectangle.A4;\n      if (autoRotate && imageIsLandscape) {\n        pageSize = new PDRectangle(pageSize.getHeight(), pageSize.getWidth());\n      }\n      if (\"fitDocumentToImage\".equals(fitOption)) {\n        pageSize = new PDRectangle(image.getWidth(), image.getHeight());\n      }\n\n      PDPage page = new PDPage(pageSize);\n\n      doc.addPage(page);\n      float pageWidth = page.getMediaBox().getWidth();\n      float pageHeight = page.getMediaBox().getHeight();\n      try (PDPageContentStream contentStream = new PDPageContentStream(doc, page, AppendMode.APPEND, true, true)) {\n        if (!(\"fillPage\".equals(fitOption) || \"fitDocumentToImage\".equals(fitOption))) {\n          if (\"maintainAspectRatio\".equals(fitOption)) {\n            float imageAspectRatio = (float) image.getWidth() / (float) image.getHeight();\n            float pageAspectRatio = pageWidth / pageHeight;\n            float scaleFactor = 1.0f;\n            if (pageAspectRatio< imageAspectRatio) {\n              scaleFactor = pageWidth / image.getWidth();\n            } else {\n              scaleFactor = pageHeight / image.getHeight();\n            }\n            float xPos = (pageWidth - (image.getWidth() * scaleFactor)) / 2;\n            float yPos = (pageHeight - (image.getHeight() * scaleFactor)) / 2;\n            contentStream.drawImage(image, xPos, yPos, image.getWidth() * scaleFactor, image.getHeight() * scaleFactor);\n          }\n        } else {\n          contentStream.drawImage(image, 0, 0, pageWidth, pageHeight);\n        } \n      } catch (IOException e) {\n        log.error(\"Error adding image to PDF\", e);\n        throw e;\n\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "152", "src_id": "M307", "code": "    public static String generateMachineFingerprint() {\n      try {\n        // Get the MAC address\n        StringBuilder sb = new StringBuilder();\n        InetAddress ip = InetAddress.getLocalHost();\n\n        NetworkInterface network = NetworkInterface.getByInetAddress(ip);\n\n        if (network == null) {\n          Enumeration<NetworkInterface> networks = NetworkInterface.getNetworkInterfaces();\n          while (networks.hasMoreElements()) {\n            NetworkInterface net = networks.nextElement();\n            byte[] mac = net.getHardwareAddress();\n            if (mac != null) {\n              for (int i = 0; i < mac.length; i++) {\n                sb.append(String.format(\"%02X\", mac[i]));\n              }\n              break; // Use the first network interface with a MAC address\n            }\n          }\n        } else {\n          byte[] mac = network.getHardwareAddress();\n          if (mac != null) {\n            for (int i = 0; i < mac.length; i++) {\n              sb.append(String.format(\"%02X\", mac[i]));\n            }\n          }\n        }\n        // Hash the MAC address for privacy and consistency\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n        byte[] hash = md.digest(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n        StringBuilder fingerprint = new StringBuilder();\n        for (byte b : hash) {\n          fingerprint.append(String.format(\"%02x\", b));\n        }\n\n        return fingerprint.toString();\n      } catch (Exception e) {\n        return \"GenericID\";\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "153", "src_id": "M135", "code": "    private void setCommonMetadata(PDDocument pdf, PdfMetadata pdfMetadata) {\n      String title = pdfMetadata.getTitle();\n\n      pdf.getDocumentInformation().setTitle(title);\n      pdf.getDocumentInformation().setProducer(stirlingPDFLabel);\n\n      pdf.getDocumentInformation().setSubject(pdfMetadata.getSubject());\n      pdf.getDocumentInformation().setKeywords(pdfMetadata.getKeywords());\n\n      pdf.getDocumentInformation().setModificationDate(Calendar.getInstance());\n\n      String author = pdfMetadata.getAuthor();\n\n      if (applicationProperties.getPremium().getProFeatures().getCustomMetadata().isAutoUpdateMetadata() && runningProOrHigher) {\n        author = applicationProperties.getPremium().getProFeatures().getCustomMetadata().getAuthor();\n        if (userService != null) {\n          author = author.replace(\"username\", userService.getCurrentUsername());\n        }\n      }\n      pdf.getDocumentInformation().setAuthor(author);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "154", "src_id": "M128", "code": "    @Bean(name = \"machineType\")\n    public String determineMachineType() {\n      try {\n        boolean isDocker = runningInDocker();\n        boolean isKubernetes = System.getenv(\"KUBERNETES_SERVICE_HOST\") != null;\n\n        boolean isBrowserOpen = \"true\".equalsIgnoreCase(env.getProperty(\"BROWSER_OPEN\"));\n\n        if (isKubernetes) {\n          return \"Kubernetes\";\n        } else {\n          if (!isDocker) {\n            if (isBrowserOpen) {\n              String os = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n              if (!(os.contains(\"win\"))) {\n                if (os.contains(\"mac\")) {\n                  return \"Client-mac\";\n                } else {\n                  return \"Client-unix\";\n                }\n              } else {\n                return \"Client-windows\";\n              } \n            } else {\n              return \"Server-jar\";\n            }\n          } else {\n            return \"Docker\";\n          } \n        }\n      } catch (Exception e) {\n        return \"Unknown\";\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "155", "src_id": "M101", "code": "    private void processRequest(int limitPerDay,\n    String identifier,\n    Map<String, Bucket> buckets,\n    HttpServletRequest request,\n    HttpServletResponse response,\n    FilterChain filterChain)\n    throws IOException, ServletException {\n\n      Bucket userBucket = buckets.computeIfAbsent(identifier, k -> createUserBucket(limitPerDay));\n\n      ConsumptionProbe probe = userBucket.tryConsumeAndReturnRemaining(1);\n      if (!(probe.isConsumed())) {\n        long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;\n        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());\n        response.setHeader(\"X-Rate-Limit-Retry-After-Seconds\", Newlines.stripAll(String.valueOf(waitForRefill)));\n        response.getWriter().write(\"Rate limit exceeded for POST requests.\");\n      } else {\n        response.setHeader(\"X-Rate-Limit-Remaining\", stripNewlines(Newlines.stripAll(Long.toString(probe.getRemainingTokens()))));\n        filterChain.doFilter(request, response);\n      } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "175", "src_id": "M1043", "code": "    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n        }\n        Exception exception = null;\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n                return;\n            }\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n            return;\n        }\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "176", "src_id": "M1031", "code": "    void establishConnection(int threadId, HttpURLConnection conn) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" + conn.getHeaderField(\"Content-Range\"));\n        }\n\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return;// let the download thread handle this error\n            default:\n                if (statusCode < 200 || 299< statusCode) {\n                    throw new HttpError(statusCode);\n                }\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "177", "src_id": "M827", "code": "    private Elst parseEdts(final Box ref) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n        }\n        final Elst obj = new Elst();\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n        if (!v1) {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        } else {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } \n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "178", "src_id": "M1048", "code": "    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n        if (DEBUG && !mMission.unknownLength && 0< start) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n        try {\n            long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n            int mId = 1;\n            mConn = mMission.openConnection(false, \n            rangeStart, \n            -1);\n\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \n                \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && 0< start) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            } if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n            mF = mMission.storage.getStream();\n            mF.seek(mMission.offsets[mMission.current] + start);\n            mIs = mConn.getInputStream();\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n            int len = 0;\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n            dispose();\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n            }\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n            }\n            run();// try again\n            return;\n        }\n\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "179", "src_id": "M1141", "code": "    private void flushAuxiliar(long amount) throws IOException {\n        if (aux.length < 1) {\n            return;\n        }\n        out.flush();\n        aux.flush();\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n        aux.target.seek(0);\n        out.target.seek(out.length);\n        long length = amount;\n        while (0< length) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n            out.writeProof(buffer, read);\n            length -= read;\n        }\n        if (!underflow) {\n            out.offset += amount;\n            aux.offset -= amount;\n        } else {\n            if (out.offset < out.length) {\n                aux.offset = 0;\n            } else {\n                // calculate the aux underflow pointer\n                if (aux.offset >= amount) {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                } else {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } \n            } \n        } \n        out.length += amount;\n        if (maxLengthKnown< out.length) {\n            maxLengthKnown = out.length;\n        }\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n            aux.length -= amount;\n            length = aux.length;\n            while (0< length) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n                aux.target.seek(writeOffset);\n                aux.writeProof(buffer, read);\n\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (THRESHOLD_AUX_LENGTH< aux.length) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH);// or setLength(0);\n        }\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "180", "src_id": "M1106", "code": "    private void showError(DownloadMission mission, UserAction action, @StringRes int reason) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n        request.append(\" [\");\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n            {\n                request.append(' ').append(recovery.toString()).append(' ');\n            }\n        }\n        request.append(\"]\");\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n\n        ErrorUtil.createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action,\n        service, request.toString(), reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "181", "src_id": "M1067", "code": "    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n            mission.mHandler = mHandler;\n            mission.maxRetry = mPrefMaxRetry;\n            // create metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, \n                String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile())\n                        {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n            mSelfMissionsControl = true;\n            mMissionsPending.add(mission);\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n            if (mission.storage == null) {\n                // noting to do here\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n\n                return;\n            }\n            boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "182", "src_id": "M1136", "code": "    importnull;@Override\n    int process(SharpStream out, SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n        String tmp = format.equals(\"ttml\");\n\n        if (!(format == null || tmp)) {\n            if (format.equals(\"srt\")) {\n                byte[] buffer = new byte[8 * 1024];\n                int read;\n                while (0< (read = sources[0].read(buffer))) {\n                    out.write(buffer, 0, read);\n                }\n                return OK_RESULT;\n            }\n        } else {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException ? 1 : 8;\n            }\n            return OK_RESULT;\n        } \n        throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "183", "src_id": "M1047", "code": "    private void joinForThreads(int millis) {\n        final Thread currentThread = Thread.currentThread();\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (0< millis) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n            }\n        }// if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == Thread.currentThread()) {\n                continue;\n            }\n            thread.interrupt();\n        }\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue;\n                }\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n                if (0< millis) {\n                    thread.join(millis);\n                }\n            }\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "184", "src_id": "M95", "code": "    public static HealthCountsStream getInstance(HystrixCommandKey commandKey, int numBuckets, int bucketSizeInMs) {\n      HealthCountsStream initialStream = streams.get(commandKey.name());\n      if (initialStream == null) {\n        final HealthCountsStream healthStream;\n        synchronized (HealthCountsStream.class) {\n          HealthCountsStream existingStream = streams.get(commandKey.name());\n          if (existingStream == null) {\n            HealthCountsStream newStream = new HealthCountsStream(commandKey, numBuckets, bucketSizeInMs, HystrixCommandMetrics.appendEventToBucket);\n\n            streams.putIfAbsent(commandKey.name(), newStream);\n            healthStream = newStream;\n          } else {\n            healthStream = existingStream;\n          }\n        }\n        healthStream.startCachingStreamValuesIfUnstarted();\n        return healthStream;\n      } else {\n        return initialStream;\n      } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "185", "src_id": "M118", "code": "    public Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {\n      Map<CommandAndCacheKey, Integer> cachingDetector = new HashMap<CommandAndCacheKey, Integer>();\n      List<HystrixInvokableInfo<?>> nonCachedExecutions = new ArrayList<HystrixInvokableInfo<?>>(executions.size());\n      for (HystrixInvokableInfo<?> execution : executions) {\n\n        if (execution.getPublicCacheKey() != null) {\n          //eligible for caching - might be the initial, or might be from cache\n          CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), execution.getPublicCacheKey());\n          Integer count = cachingDetector.get(key);\n\n          if (count != null) {\n            //key already seen\n            cachingDetector.put(key, count + 1);\n          } else {\n            //key not seen yet\n            cachingDetector.put(key, 0);\n          }\n\n        }\n\n        if (!execution.isResponseFromCache()) {\n          nonCachedExecutions.add(execution);\n        }\n      }\n\n      Map<ExecutionSignature, List<Integer>> commandDeduper = new HashMap<ExecutionSignature, List<Integer>>();\n      for (HystrixInvokableInfo<?> execution : nonCachedExecutions) {\n        int cachedCount = 0;\n\n        String cacheKey = execution.getPublicCacheKey();\n        if (cacheKey != null) {\n          CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), cacheKey);\n          cachedCount = cachingDetector.get(key);\n        }\n        ExecutionSignature signature = cachedCount > 0? ExecutionSignature.from(execution, cacheKey, cachedCount) : ExecutionSignature.from(execution); List<Integer> currentLatencyList = commandDeduper.get(signature);\n        if (currentLatencyList == null) {\n          List<Integer> newLatencyList = new ArrayList<Integer>();\n          newLatencyList.add(execution.getExecutionTimeInMilliseconds());\n          commandDeduper.put(signature, newLatencyList);\n        } else {\n          currentLatencyList.add(execution.getExecutionTimeInMilliseconds());\n        } \n      }\n\n      return commandDeduper;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "186", "src_id": "M223", "code": "    public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties) {\n      final ThreadFactory threadFactory = getThreadFactory(threadPoolKey);\n      final boolean allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();\n      final int dynamicCoreSize = threadPoolProperties.coreSize().get();\n      final int keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();\n      final int maxQueueSize = threadPoolProperties.maxQueueSize().get();\n      final BlockingQueue<Runnable> workQueue = getBlockingQueue(maxQueueSize);\n      if (allowMaximumSizeToDivergeFromCoreSize) {\n\n        final int dynamicMaximumSize = threadPoolProperties.maximumSize().get();\n\n        if (dynamicMaximumSize< dynamicCoreSize) {\n          logger.error(\"Hystrix ThreadPool configuration at startup for : \" + threadPoolKey.name() + \" is trying to set coreSize = \" + dynamicCoreSize + \" and maximumSize = \" + dynamicMaximumSize + \".  Maximum size will be set to \" + dynamicCoreSize + \", the coreSize value, since it must be equal to or greater than the coreSize value\");\n          return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n        } else {\n          return new ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n        }\n      } else {\n        return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "187", "src_id": "M498", "code": "    protected static String convertToJson(HystrixUtilization utilization) throws IOException {\n      StringWriter jsonString = new StringWriter();\n      JsonGenerator json = jsonFactory.createGenerator(jsonString);\n      json.writeStartObject();\n      json.writeStringField(\"type\", \"HystrixUtilization\");\n      json.writeObjectFieldStart(\"commands\");\n      for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n        final HystrixCommandKey key = entry.getKey();\n        final HystrixCommandUtilization commandUtilization = entry.getValue();\n        writeCommandUtilizationJson(json, key, commandUtilization);\n      }\n      json.writeEndObject();\n      json.writeObjectFieldStart(\"threadpools\");\n      for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n\n        final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n\n        final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n\n        writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n      }\n      json.writeEndObject();\n      json.writeEndObject();\n      json.close();\n      return jsonString.getBuffer().toString();\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "188", "src_id": "M171", "code": "    EventCounts plus(HystrixEventType eventType, int count) {\n      BitSet newBitSet = (BitSet) events.clone();\n      int localNumEmits = numEmissions;\n      int localNumFallbackEmits =  numFallbackEmissions;\n\n      int localNumCollapsed = numCollapsed;\n      switch (eventType) {\n        case EMIT:\n          newBitSet.set(HystrixEventType.EMIT.ordinal());\n          localNumEmits += count;\n          break;\n        case FALLBACK_EMIT:\n          newBitSet.set(HystrixEventType.FALLBACK_EMIT.ordinal());\n\n          localNumFallbackEmits += count;\n          break;\n        case COLLAPSED:\n          newBitSet.set(HystrixEventType.COLLAPSED.ordinal());\n          localNumCollapsed += count;\n          break;\n        default:\n          newBitSet.set(eventType.ordinal());\n          break;\n      }\n      return new EventCounts(newBitSet, localNumEmits, localNumFallbackEmits, localNumCollapsed);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "189", "src_id": "M448", "code": "    private static void writeThreadPoolMetrics(final HystrixThreadPoolMetrics threadPoolMetrics, JsonGenerator json) throws IOException {\n      HystrixThreadPoolKey key = threadPoolMetrics.getThreadPoolKey();\n      json.writeStartObject();\n      json.writeStringField(\"type\", \"HystrixThreadPool\");\n      json.writeStringField(\"name\", key.name());\n      json.writeNumberField(\"currentTime\", System.currentTimeMillis());\n      json.writeNumberField(\"currentActiveCount\", threadPoolMetrics.getCurrentActiveCount().intValue());\n      json.writeNumberField(\"currentCompletedTaskCount\", threadPoolMetrics.getCurrentCompletedTaskCount().longValue());\n\n      json.writeNumberField(\"currentCorePoolSize\", threadPoolMetrics.getCurrentCorePoolSize().intValue());\n\n      json.writeNumberField(\"currentLargestPoolSize\", \n      threadPoolMetrics.getCurrentLargestPoolSize().intValue());\n\n      json.writeNumberField(\"currentMaximumPoolSize\", \n      threadPoolMetrics.getCurrentMaximumPoolSize().intValue());\n\n      json.writeNumberField(\"currentPoolSize\", threadPoolMetrics.getCurrentPoolSize().intValue());\n\n      json.writeNumberField(\"currentQueueSize\", threadPoolMetrics.getCurrentQueueSize().intValue());\n\n      json.writeNumberField(\"currentTaskCount\", threadPoolMetrics.getCurrentTaskCount().longValue());\n\n      safelyWriteNumberField(json, \"rollingCountThreadsExecuted\", new Func0<Long>() {@Override\n        public Long call() {\n          return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.EXECUTED);\n        }\n      });\n      json.writeNumberField(\"rollingMaxActiveThreads\", threadPoolMetrics.getRollingMaxActiveThreads());\n      safelyWriteNumberField(json, \"rollingCountCommandRejections\", new Func0<Long>() {@Override\n        public Long call() {\n          return threadPoolMetrics.getRollingCount(HystrixEventType.ThreadPool.REJECTED);\n        }\n      });\n\n      json.writeNumberField(\"propertyValue_queueSizeRejectionThreshold\", threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());\n      json.writeNumberField(\"propertyValue_metricsRollingStatisticalWindowInMilliseconds\", \n      threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());\n      json.writeNumberField(\"reportingHosts\", 1); // this will get summed across all instances in a cluster\n      json.writeEndObject();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "190", "src_id": "M69", "code": "    @Override\n    public String toString() {\n      StringBuffer sb = new StringBuffer();\n      List<HystrixEventType> foundEventTypes = new ArrayList<HystrixEventType>();\n      sb.append(getCommandKey().name()).append(\"[\");\n      for (HystrixEventType eventType : ALL_EVENT_TYPES) {\n        if (executionResult.getEventCounts().contains(eventType)) {\n          foundEventTypes.add(eventType);\n        }\n      }\n      int i = 0;\n      for (HystrixEventType eventType : foundEventTypes) {\n        sb.append(eventType.name());\n        int eventCount = executionResult.getEventCounts().getCount(eventType);\n\n        if (1< eventCount) {\n          sb.append(\"x\").append(eventCount);\n        }\n\n        if (i < foundEventTypes.size() - 1) {\n          sb.append(\", \");\n        }\n\n        i++;\n      }\n      sb.append(\"][\").append(getExecutionLatency()).append(\" ms]\");\n      return sb.toString();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "191", "src_id": "M52", "code": "    @Override\n    public void run() {\n      while (true) { /**\n                     * Since this is a simple example and we know the exact HystrixCommandKeys we are interested in\n                     * we will retrieve the HystrixCommandMetrics objects directly.\n                     *\n                     * Typically you would instead retrieve metrics from where they are published which is by default\n                     * done using Servo: https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring\n                     */\n        // wait 5 seconds on each loop\n        try {\n          Thread.sleep(5000);\n        } catch (Exception e) { // ignore\n        }\n        // we are using default names so can use class.getSimpleName() to derive the keys\n        HystrixCommandMetrics creditCardMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(CreditCardCommand.class.getSimpleName()));\n        HystrixCommandMetrics orderMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetOrderCommand.class.getSimpleName()));\n        HystrixCommandMetrics userAccountMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetUserAccountCommand.class.getSimpleName()));\n        HystrixCommandMetrics paymentInformationMetrics = HystrixCommandMetrics.getInstance(HystrixCommandKey.Factory.asKey(GetPaymentInformationCommand.class.getSimpleName()));\n\n        if (shouldLog) {\n          // print out metrics\n          StringBuilder out = new StringBuilder();\n          out.append(\"\\n\");\n          out.append(\"#####################################################################################\").append(\"\\n\");\n          out.append(\"# CreditCardCommand: \" + getStatsStringFromMetrics(creditCardMetrics)).append(\"\\n\");\n\n          out.append(\"# GetOrderCommand: \" + getStatsStringFromMetrics(orderMetrics)).append(\"\\n\");\n\n          out.append(\"# GetUserAccountCommand: \" + getStatsStringFromMetrics(userAccountMetrics)).append(\"\\n\");\n\n          out.append(\"# GetPaymentInformationCommand: \" + getStatsStringFromMetrics(paymentInformationMetrics)).append(\"\\n\");\n\n          out.append(\"#####################################################################################\").append(\"\\n\");\n\n          System.out.println(out.toString());\n        }\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "192", "src_id": "M312", "code": "    private Observable<R> handleRequestCacheHitAndEmitValues(final HystrixCommandResponseFromCache<R> fromCache, final AbstractCommand<R> _cmd) {\n      try {\n        executionHook.onCacheHit(this);\n      } catch (Throwable hookEx) {\n        logger.warn(\"Error calling HystrixCommandExecutionHook.onCacheHit\", hookEx);\n      }\n      return fromCache.toObservableWithStateCopiedInto(this).doOnTerminate(new Action0() {@Override\n        public void call() {\n          if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) {\n            cleanUpAfterResponseFromCache(false); //user code never ran\n          } else {\n            if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) {\n              cleanUpAfterResponseFromCache(true); //user code did run\n            }\n          }\n        }\n      }).doOnUnsubscribe(new Action0() {@Override\n        public void call() {\n          if (commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) {\n            cleanUpAfterResponseFromCache(false); //user code never ran\n          } else {\n            if (commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.UNSUBSCRIBED)) {\n              cleanUpAfterResponseFromCache(true); //user code did run\n            }\n          }\n        }\n      });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "193", "src_id": "M438", "code": "    private static void serializeUtilization(HystrixUtilization utilization, JsonGenerator json) {\n      try {\n        json.writeStartObject();\n\n        json.writeStringField(\"type\", \"HystrixUtilization\");\n        json.writeObjectFieldStart(\"commands\");\n        for (Map.Entry<HystrixCommandKey, HystrixCommandUtilization> entry : utilization.getCommandUtilizationMap().entrySet()) {\n          final HystrixCommandKey key = entry.getKey();\n          final HystrixCommandUtilization commandUtilization = entry.getValue();\n          writeCommandUtilizationJson(json, key, commandUtilization);\n        }\n        json.writeEndObject();\n        json.writeObjectFieldStart(\"threadpools\");\n        for (Map.Entry<HystrixThreadPoolKey, HystrixThreadPoolUtilization> entry : utilization.getThreadPoolUtilizationMap().entrySet()) {\n\n          final HystrixThreadPoolKey threadPoolKey = entry.getKey();\n\n          final HystrixThreadPoolUtilization threadPoolUtilization = entry.getValue();\n\n          writeThreadPoolUtilizationJson(json, threadPoolKey, threadPoolUtilization);\n        }\n        json.writeEndObject();\n        json.writeEndObject();\n        json.close();\n\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "194", "src_id": "M1043", "code": "    private void doPostprocessing() {\n        errCode = ERROR_NOTHING;\n        errObject = null;\n        Thread thread = Thread.currentThread();\n        notifyPostProcessing(1);\n        if (DEBUG) {\n            thread.setName(\"[\" + TAG + \"]  ps = \" + psAlgorithm + \"  filename = \" + storage.getName());\n\n        }\n        Exception exception = null;\n        try {\n            psAlgorithm.run(this);\n        } catch (Exception err) {\n            Log.e(TAG, \"Post-processing failed. \" + psAlgorithm.toString(), err);\n            if (err instanceof InterruptedIOException \n            || err instanceof ClosedByInterruptException || thread.isInterrupted()) {\n                notifyError(DownloadMission.ERROR_POSTPROCESSING_STOPPED, null);\n\n                return;\n            }\n            if (errCode == ERROR_NOTHING) {\n                errCode = ERROR_POSTPROCESSING;\n            }\n            exception = err;\n        } finally {\n            notifyPostProcessing(errCode == ERROR_NOTHING ? 2 : 0);\n        }\n        if (errCode != ERROR_NOTHING) {\n            if (exception == null) {\n                exception = errObject;\n            }\n            notifyError(ERROR_POSTPROCESSING, exception);\n\n            return;\n        }\n        notifyFinished();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "195", "src_id": "M1031", "code": "    void establishConnection(\n    int threadId, HttpURLConnection conn\n    ) throws IOException, HttpError {\n        int statusCode = conn.getResponseCode();\n        if (DEBUG) {\n            Log.d(TAG, threadId + \":[request]  Range=\" + conn.getRequestProperty(\"Range\"));\n            Log.d(TAG, threadId + \":[response] Code=\" + statusCode);\n            Log.d(TAG, threadId + \":[response] Content-Length=\" + conn.getContentLength());\n            Log.d(TAG, threadId + \":[response] Content-Range=\" \n            + conn.getHeaderField(\"Content-Range\"));\n        }\n\n        switch (statusCode) {\n            case 204:\n            case 205:\n            case 207:\n                throw new HttpError(statusCode);\n            case 416:\n                return; // let the download thread handle this error\n            default:\n                if (statusCode < 200 || 299< statusCode) {\n                    throw new HttpError(statusCode);\n                }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "196", "src_id": "M827", "code": "    private Elst parseEdts(\n    final Box ref\n    ) throws IOException {\n        final Box b = untilBox(ref, ATOM_ELST);\n        if (b == null) {\n            return null;\n\n        }\n        final Elst obj = new Elst();\n        final boolean v1 = stream.read() == 1;\n        stream.skipBytes(3); // flags\n        final int entryCount = stream.readInt();\n        if (entryCount < 1) {\n            obj.bMediaRate = 0x00010000; // default media rate (1.0)\n            return obj;\n        }\n        if (!v1) {\n            stream.skipBytes(DataReader.INTEGER_SIZE); // segment duration\n            obj.mediaTime = stream.readInt();\n        } else {\n            stream.skipBytes(DataReader.LONG_SIZE); // segment duration\n            obj.mediaTime = stream.readLong();\n\n            // ignore all remain entries\n            stream.skipBytes((entryCount - 1) * (DataReader.LONG_SIZE * 2));\n        } \n\n        obj.bMediaRate = stream.readInt();\n        return obj;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "197", "src_id": "M1048", "code": "    @Override\n    public void run() {\n        boolean done;\n        long start = mMission.fallbackResumeOffset;\n\n        if (DEBUG && !mMission.unknownLength && 0< start) {\n            Log.i(TAG, \"Resuming a single-thread download at \" + start);\n        }\n\n        try {\n            long rangeStart = (mMission.unknownLength || start < 1) ? -1 : start;\n            int mId = 1;\n            mConn = mMission.openConnection(false, rangeStart, -1);\n            if (mRetryCount == 0 && rangeStart == -1) {\n                // workaround: bypass android connection pool\n                mConn.setRequestProperty(\"Range\", \"bytes=0-\");\n            }\n\n            mMission.establishConnection(mId, mConn);\n\n            // check if the download can be resumed\n            if (mConn.getResponseCode() == 416 && 0< start) {\n                mMission.notifyProgress(-start);\n                start = 0;\n                mRetryCount--;\n                throw new DownloadMission.HttpError(416);\n            }\n\n            // secondary check for the file length\n            if (!mMission.unknownLength) {\n                mMission.unknownLength = Utility.getContentLength(mConn) == -1;\n            } if (mMission.unknownLength || mConn.getResponseCode() == 200) {\n                // restart amount of bytes downloaded\n                mMission.done = mMission.offsets[mMission.current] - mMission.offsets[0];\n            }\n\n            mF = mMission.storage.getStream();\n\n            mF.seek(mMission.offsets[mMission.current] + start);\n\n            mIs = mConn.getInputStream();\n\n            byte[] buf = new byte[DownloadMission.BUFFER_SIZE];\n\n            int len = 0;\n\n            while (mMission.running && (len = mIs.read(buf, 0, buf.length)) != -1) {\n                mF.write(buf, 0, len);\n                start += len;\n                mMission.notifyProgress(len);\n            }\n            dispose();\n            // if thread goes interrupted check if the last part is written. This avoid re-download the whole file\n            done = len == -1;\n        } catch (Exception e) {\n            dispose();\n            mMission.fallbackResumeOffset = start;\n            if (!mMission.running || e instanceof ClosedByInterruptException) {\n                return;\n\n            }\n            if (e instanceof HttpError && ((HttpError) e).statusCode == ERROR_HTTP_FORBIDDEN) {\n                // for youtube streams. The url has expired, recover\n                dispose();\n                mMission.doRecover(ERROR_HTTP_FORBIDDEN);\n                return;\n            }\n            if (mRetryCount++ >= mMission.maxRetry) {\n                mMission.notifyError(e);\n                return;\n            }\n            if (DEBUG) {\n                Log.e(TAG, \"got exception, retrying...\", e);\n\n            }\n            run(); // try again\n            return;\n        }\n\n        if (done) {\n            mMission.notifyFinished();\n        } else {\n            mMission.fallbackResumeOffset = start;\n\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "198", "src_id": "M1141", "code": "    private void flushAuxiliar(\n    long amount\n    ) throws IOException {\n        if (aux.length < 1) {\n            return;\n\n        }\n        out.flush();\n        aux.flush();\n        boolean underflow = aux.offset < aux.length || out.offset < out.length;\n\n        byte[] buffer = new byte[COPY_BUFFER_SIZE];\n\n        aux.target.seek(0);\n        out.target.seek(out.length);\n        long length = amount;\n\n        while (0< length) {\n            int read = (int) Math.min(length, Integer.MAX_VALUE);\n\n            read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n            if (read < 1) {\n                amount -= length;\n                break;\n            }\n\n            out.writeProof(buffer, read);\n\n            length -= read;\n        }\n        if (!underflow) {\n            out.offset += amount;\n            aux.offset -= amount;\n        } else {\n            if (out.offset < out.length) {\n                aux.offset = 0;\n\n            }else {\n                // calculate the aux underflow pointer\n                if (aux.offset >= amount) {\n                    aux.offset -= amount;\n                    out.offset = out.length + amount;\n                } else {\n                    out.offset += aux.offset;\n                    aux.offset = 0;\n                    out.target.seek(out.offset);\n                } \n            } \n\n        } \n        out.length += amount;\n        if (maxLengthKnown< out.length) {\n            maxLengthKnown = out.length;\n        }\n        if (amount < aux.length) {\n            // move the excess data to the beginning of the file\n            long readOffset = amount;\n            long writeOffset = 0;\n            aux.length -= amount;\n            length = aux.length;\n            while (0< length) {\n                int read = (int) Math.min(length, Integer.MAX_VALUE);\n\n                read = aux.target.read(buffer, 0, Math.min(read, buffer.length));\n\n                aux.target.seek(writeOffset);\n\n                aux.writeProof(buffer, read);\n\n                writeOffset += read;\n                readOffset += read;\n                length -= read;\n                aux.target.seek(readOffset);\n            }\n\n            aux.target.setLength(aux.length);\n            return;\n        }\n\n        if (THRESHOLD_AUX_LENGTH< aux.length) {\n            aux.target.setLength(THRESHOLD_AUX_LENGTH); // or setLength(0);\n\n        }\n        aux.reset();\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "199", "src_id": "M1106", "code": "    private void showError(\n    DownloadMission mission, UserAction action, @StringRes int reason\n    ) {\n        StringBuilder request = new StringBuilder(256);\n        request.append(mission.source);\n        request.append(\" [\");\n\n        if (mission.recoveryInfo != null) {\n            for (MissionRecoveryInfo recovery : mission.recoveryInfo)\n            {\n                request.append(' ').append(recovery.toString()).append(' ');\n            }\n\n        }\n        request.append(\"]\");\n        String service;\n        try {\n            service = NewPipe.getServiceByUrl(mission.source).getServiceInfo().getName();\n\n        } catch (Exception e) {\n            service = ErrorInfo.SERVICE_NONE;\n        }\n        ErrorUtil\n        .createNotification(mContext, new ErrorInfo(ErrorInfo.Companion.throwableToStringList(mission.errObject), action, service, request.toString(), reason));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "200", "src_id": "M1067", "code": "    void startMission(DownloadMission mission) {\n        synchronized (this) {\n            mission.timestamp = System.currentTimeMillis();\n\n            mission.mHandler = mHandler;\n\n            mission.maxRetry = mPrefMaxRetry;\n\n            // create metadata file\n            while (true) {\n                mission.metadata = new File(mPendingMissionsDir, String.valueOf(mission.timestamp));\n                if (!mission.metadata.isFile() && !mission.metadata.exists()) {\n                    try {\n                        if (!mission.metadata.createNewFile())\n                        {\n                            throw new RuntimeException(\"Cant create download metadata file\");\n                        }\n\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                }\n                mission.timestamp = System.currentTimeMillis();\n            }\n\n            mSelfMissionsControl = true;\n\n            mMissionsPending.add(mission);\n\n            // Before continue, save the metadata in case the internet connection is not available\n            Utility.writeToFile(mission.metadata, mission);\n\n            if (mission.storage == null) {\n                // noting to do here\n                mission.errCode = DownloadMission.ERROR_FILE_CREATION;\n                if (mission.errObject != null) {\n                    mission.errObject = new IOException(\"DownloadMission.storage == NULL\");\n                }\n\n                return;\n            }\n            boolean start = !mPrefQueueLimit || getRunningMissionsCount() < 1;\n            if (canDownloadInCurrentNetwork() && start) {\n                mission.start();\n            }\n        }\n\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "201", "src_id": "M1136", "code": "    @Override int process(SharpStream out, SharpStream... sources) throws IOException {\n        // check if the subtitle is already in srt and copy, this should never happen\n        String format = getArgumentAt(0, null);\n        boolean ignoreEmptyFrames = getArgumentAt(1, \"true\").equals(\"true\");\n\n        if (!(format == null || format.equals(\"ttml\"))) {\n            if (format.equals(\"srt\")) {\n                byte[] buffer = new byte[8 * 1024];\n                int read;\n                while (0< (read = sources[0].read(buffer))) {\n                    out.write(buffer, 0, read);\n                }\n                return OK_RESULT;\n            }\n\n        } else {\n            SrtFromTtmlWriter writer = new SrtFromTtmlWriter(out, ignoreEmptyFrames);\n            try {\n                writer.build(sources[0]);\n            } catch (Exception err) {\n                Log.e(TAG, \"subtitle parse failed\", err);\n                return err instanceof IOException ? 1 : 8;\n            }\n            return OK_RESULT;\n        } throw new UnsupportedOperationException(\"Can't convert this subtitle, unimplemented format: \" + format);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "202", "src_id": "M1047", "code": "    private void joinForThreads(\n    int millis\n    ) {\n        final Thread currentThread = Thread.currentThread();\n        if (init != null && init != currentThread && init.isAlive()) {\n            init.interrupt();\n            if (0< millis) {\n                try {\n                    init.join(millis);\n                } catch (InterruptedException e) {\n                    Log.w(TAG, \"Initializer thread is still running\", e);\n                    return;\n                }\n\n            }\n        }// if a thread is still alive, possible reasons:\n        //      slow device\n        //      the user is spamming start/pause buttons\n        //      start() method called quickly after pause()\n\n        for (Thread thread : threads) {\n            if (!thread.isAlive() || thread == Thread.currentThread()) {\n                continue;\n\n            }\n\n            thread.interrupt();\n        }\n\n        try {\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue;\n\n                }\n\n                if (DEBUG) {\n                    Log.w(TAG, \"thread alive: \" + thread.getName());\n                }\n\n                if (0< millis) {\n                    thread.join(millis);\n                }\n            }\n\n        } catch (InterruptedException e) {\n            throw new RuntimeException(\"A download thread is still running\", e);\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "203", "src_id": "M491", "code": "    @SuppressLint(\"SwitchIntDef\") // only fit, fill and zoom are supported by NewPipe\n    @ResizeMode\n    public static int nextResizeModeAndSaveToPrefs(final Player player,@ResizeMode final int resizeMode) {\n        final int newResizeMode;\n        switch (resizeMode) {\n            case AspectRatioFrameLayout.RESIZE_MODE_FIT:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_FILL:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_ZOOM;\n                break;\n            case AspectRatioFrameLayout.RESIZE_MODE_ZOOM:\n            default:\n                newResizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;\n                break;\n        }\n        // save the new resize mode so it can be restored in a future session\n        player.getPrefs().edit().putInt(player.getContext().getString(R.string.last_resize_mode), newResizeMode).apply();\n        return newResizeMode;\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "204", "src_id": "M424", "code": "    @Override\n    public void onBroadcastReceived(final Intent intent) {\n        super.onBroadcastReceived(intent);\n        if (Intent.ACTION_CONFIGURATION_CHANGED.equals(intent.getAction())) {\n            // Close it because when changing orientation from portrait\n            // (in fullscreen mode) the size of queue layout can be larger than the screen size\n            closeItemsList();\n        } else {\n            if (ACTION_PLAY_PAUSE.equals(intent.getAction())) {\n                // Ensure that we have audio-only stream playing when a user\n                // started to play from notification's play button from outside of the app\n                if (!fragmentIsVisible) {\n                    onFragmentStopped();\n                }\n            } else {\n                if (!(VideoDetailFragment.ACTION_VIDEO_FRAGMENT_STOPPED.equals(intent.getAction()))) {\n                    if (VideoDetailFragment.ACTION_VIDEO_FRAGMENT_RESUMED.equals(intent.getAction())) {\n                        // Restore video source when user returns to the fragment\n                        fragmentIsVisible = true;\n                        player.useVideoSource(true);\n                        // When a user returns from background, the system UI will always be shown even if\n                        // controls are invisible: hide it in that case\n                        if (!isControlsVisible()) {\n                            hideSystemUIIfNeeded();\n                        }\n                    }\n                } else {\n                    fragmentIsVisible = false;\n                    onFragmentStopped();\n                } \n            }\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "205", "src_id": "M900", "code": "    @StyleRes\n    public static int getSettingsThemeStyle(final Context context) {\n        final Resources res = context.getResources();\n        final String lightTheme = res.getString(R.string.light_theme_key);\n        final String blackTheme = res.getString(R.string.black_theme_key);\n        final String automaticDeviceTheme = res.getString(R.string.auto_device_theme_key);\n        final String selectedTheme = getSelectedThemeKey(context);\n        if (selectedTheme.equals(lightTheme)) {\n            return R.style.LightSettingsTheme;\n        } else {\n            if (!(selectedTheme.equals(blackTheme))) {\n                if (selectedTheme.equals(automaticDeviceTheme)) {\n                    if (isDeviceDarkThemeEnabled(context)) {\n                        // use the dark theme variant preferred by the user\n                        final String selectedNightTheme \n                        = getSelectedNightThemeKey(context);\n                        if (selectedNightTheme.equals(blackTheme)) {\n                            return R.style.BlackSettingsTheme;\n                        } else {\n                            return R.style.DarkSettingsTheme;\n                        }\n                    } else {\n                        // there is only one day theme\n                        return R.style.LightSettingsTheme;\n                    }\n                } else {\n                    // default to dark theme\n                    return R.style.DarkSettingsTheme;\n                }\n            } else {\n                return R.style.BlackSettingsTheme;\n            } \n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "206", "src_id": "M895", "code": "    @Override\n    public Bitmap transform(final Bitmap source) {\n        if (DEBUG) {\n            Log.d(TAG, \"Thumbnail - transform() called\");\n        }\n        final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n        final Bitmap result = BitmapCompat.createScaledBitmap(source,(int)notificationThumbnailWidth,(int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)),null,true);\n\n        if (result == source || !result.isMutable()) {\n            // create a new mutable bitmap to prevent strange crashes on some\n            // devices (see #4638)\n            final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int)notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))),null,true);\n            source.recycle();\n\n            return copied;\n        } else {\n            source.recycle();\n            return result;\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "207", "src_id": "M225", "code": "    private void onBroadcastReceived(final Intent intent) {\n        if (intent == null || intent.getAction() == null) {\n            return;\n        }\n        if (DEBUG) {\n            Log.d(TAG, \"onBroadcastReceived() called with: intent = [\" + intent + \"]\");\n        }\n        switch (intent.getAction()) {\n            case AudioManager.ACTION_AUDIO_BECOMING_NOISY:\n                pause();\n                break;\n            case ACTION_CLOSE:\n                service.destroyPlayerAndStopService();\n                break;\n            case ACTION_PLAY_PAUSE:\n                playPause();\n                break;\n            case ACTION_PLAY_PREVIOUS:\n                playPrevious();\n                break;\n            case ACTION_PLAY_NEXT:\n                playNext();\n                break;\n            case ACTION_FAST_REWIND:\n                fastRewind();\n                break;\n            case ACTION_FAST_FORWARD:\n                fastForward();\n                break;\n            case ACTION_REPEAT:\n                cycleNextRepeatMode();\n                break;\n            case ACTION_SHUFFLE:\n                toggleShuffleModeEnabled();\n                break;\n            case Intent.ACTION_CONFIGURATION_CHANGED:\n                if (DEBUG) {\n                    Log.d(TAG, \"ACTION_CONFIGURATION_CHANGED received\");\n                }\n                break;\n        }\n        UIs.call(playerUi -> playerUi.onBroadcastReceived(intent));\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "208", "src_id": "M749", "code": "    private static void handleError(final Context context, final ErrorInfo errorInfo) {\n        if (errorInfo.getThrowable() != null) {\n            errorInfo.getThrowable().printStackTrace();\n        }\n        if (errorInfo.getThrowable() instanceof ReCaptchaException) {\n            Toast.makeText(context, R.string.recaptcha_request_toast, Toast.LENGTH_LONG).show();\n            // Starting ReCaptcha Challenge Activity\n            final Intent intent = new Intent(context, ReCaptchaActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n            context.startActivity(intent);\n        } else {\n            if (errorInfo.getThrowable() != null\n            && ExceptionUtils.isNetworkRelated(errorInfo.getThrowable())) {\n                Toast.makeText(context, R.string.network_error, Toast.LENGTH_LONG).show();\n            } else {\n                if (errorInfo.getThrowable() instanceof AgeRestrictedContentException) {\n                    Toast.makeText(context, R.string.restricted_video_no_stream, Toast.LENGTH_LONG).show();\n                } else {\n                    if (errorInfo.getThrowable() instanceof GeographicRestrictionException) {\n                        Toast.makeText(context, R.string.georestricted_content, Toast.LENGTH_LONG).show();\n                    } else {\n                        if (errorInfo.getThrowable() instanceof PaidContentException) {\n                            Toast.makeText(context, R.string.paid_content, Toast.LENGTH_LONG).show();\n                        } else {\n                            if (errorInfo.getThrowable() instanceof PrivateContentException) {\n                                Toast.makeText(context, R.string.private_content, Toast.LENGTH_LONG).show();\n                            } else {\n                                if (errorInfo.getThrowable() instanceof SoundCloudGoPlusContentException) {\n                                    Toast.makeText(context, R.string.soundcloud_go_plus_content, Toast.LENGTH_LONG).show();\n                                } else {\n                                    if (errorInfo.getThrowable() instanceof YoutubeMusicPremiumContentException) {\n                                        Toast.makeText(context, R.string.youtube_music_premium_content, Toast.LENGTH_LONG).show();\n                                    } else {\n                                        if (!(errorInfo.getThrowable() instanceof ContentNotAvailableException)) {\n                                            if (errorInfo.getThrowable() instanceof ContentNotSupportedException) {\n                                                Toast.makeText(context, R.string.content_not_supported, Toast.LENGTH_LONG).show();\n                                            } else {\n                                                ErrorUtil.createNotification(context, errorInfo);\n                                            }\n                                        } else {\n                                            Toast.makeText(context, R.string.content_not_available, Toast.LENGTH_LONG).show();\n                                        } \n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (context instanceof RouterActivity) {\n            ((RouterActivity)context).finish();\n        }\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "209", "src_id": "M999", "code": "    public static void openVideoDetailFragment(@NonNull final Context context,@NonNull final FragmentManager fragmentManager,final int serviceId,@Nullable final String url,@NonNull final String title,@Nullable final PlayQueue playQueue,final boolean switchingPlayers) {\n        final boolean autoPlay;\n        @Nullable final PlayerType playerType = PlayerHolder.getInstance().getType();\n        if (playerType == null) {\n            // no player open\n            autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n        } else {\n            if (!switchingPlayers) {\n                if (playerType == PlayerType.MAIN) {\n                    // opening new stream while already playing in main player\n                    autoPlay = PlayerHelper.isAutoplayAllowedByUser(context);\n                } else {\n                    // opening new stream while already playing in another player\n                    autoPlay = false;\n                }\n            } else {\n                // switching player to main player\n                autoPlay = PlayerHolder.getInstance().isPlaying(); // keep play/pause state\n            } \n        }\n        final RunnableWithVideoDetailFragment onVideoDetailFragmentReady = detailFragment -> {\n            expandMainPlayer(detailFragment.requireActivity());\n            detailFragment.setAutoPlay(autoPlay);\n            if (switchingPlayers) {\n                // Situation when user switches from players to main player. All needed data is\n                // here, we can start watching (assuming newQueue equals playQueue).\n                // Starting directly in fullscreen if the previous player type was popup.\n                detailFragment.openVideoPlayer(playerType == PlayerType.POPUP\n                || PlayerHelper.isStartMainPlayerFullscreenEnabled(context));\n            } else {\n                detailFragment.selectAndLoadVideo(serviceId, url, title, playQueue);\n            }\n\n            detailFragment.scrollToTop();\n        };\n        final Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_player_holder);\n        if (!(fragment instanceof VideoDetailFragment && fragment.isVisible())) {\n            // Specify no url here, otherwise the VideoDetailFragment will start loading the\n            // stream automatically if it's the first time it is being opened, but then\n            // onVideoDetailFragmentReady will kick in and start another loading process.\n            // See VideoDetailFragment.wasCleared() and its usage in doInitialLoadLogic().\n            final VideoDetailFragment instance = VideoDetailFragment.getInstance(serviceId, null, title, playQueue);\n            instance.setAutoPlay(autoPlay);\n            defaultTransaction(fragmentManager).replace(R.id.fragment_player_holder, instance).runOnCommit(() -> onVideoDetailFragmentReady.run(instance)).commit();\n        } else {\n            onVideoDetailFragmentReady.run((VideoDetailFragment)fragment);\n        } \n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "210", "src_id": "M698", "code": "    @Override\n    public void handleResult(@NonNull final ChannelInfo result) {\n        super.handleResult(result);\n        currentInfo = result;\n        setInitialData(result.getServiceId(), result.getOriginalUrl(), result.getName());\n\n        if (ImageStrategy.shouldLoadImages() && !result.getBanners().isEmpty()) {\n            PicassoHelper.loadBanner(result.getBanners()).tag(PICASSO_CHANNEL_TAG).into(binding.channelBannerImage);\n        } else {\n            // do not waste space for the banner, if the user disabled images or there is not one\n            binding.channelBannerImage.setImageDrawable(null);\n        }\n        PicassoHelper.loadAvatar(result.getAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.channelAvatarView);\n        PicassoHelper.loadAvatar(result.getParentChannelAvatars()).tag(PICASSO_CHANNEL_TAG).into(binding.subChannelAvatarView);\n        binding.channelTitleView.setText(result.getName());\n        binding.channelSubscriberView.setVisibility(View.VISIBLE);\n        if (result.getSubscriberCount() >= 0) {\n            binding.channelSubscriberView.setText(Localization.shortSubscriberCount(activity, result.getSubscriberCount()));\n        } else {\n            binding.channelSubscriberView.setText(R.string.subscribers_count_not_available);\n        }\n\n        if (!TextUtils.isEmpty(currentInfo.getParentChannelName())) {\n            binding.subChannelTitleView.setText(String.format(getString(R.string.channel_created_by), currentInfo.getParentChannelName()));\n            binding.subChannelTitleView.setVisibility(View.VISIBLE);\n            binding.subChannelAvatarView.setVisibility(View.VISIBLE);\n        }\n        updateRssButton();\n        channelContentNotSupported = false;\n        for (final Throwable throwable : result.getErrors()) {\n            if (throwable instanceof ContentNotSupportedException) {\n                channelContentNotSupported = true;\n                showContentNotSupportedIfNeeded();\n                break;\n            }\n        }\n        disposables.clear();\n        if (subscribeButtonMonitor != null) {\n            subscribeButtonMonitor.dispose();\n        }\n        updateTabs();\n        updateSubscription(result);\n        monitorSubscription(result);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "211", "src_id": "M379", "code": "    import null;@Override\n    public void onTextTracksChanged(@NonNull final Tracks currentTracks) {\n        super.onTextTracksChanged(currentTracks);\n        final boolean trackTypeTextSupported = !currentTracks.containsType(C.TRACK_TYPE_TEXT) || currentTracks.isTypeSupported(C.TRACK_TYPE_TEXT, false);\n        if (getPlayer().getTrackSelector().getCurrentMappedTrackInfo() == null\n        || !trackTypeTextSupported) {\n            binding.captionTextView.setVisibility(View.GONE);\n            return;\n        }\n\n        // Extract all loaded languages\n        final List<Tracks.Group> textTracks = currentTracks.getGroups().stream().filter(trackGroupInfo -> C.TRACK_TYPE_TEXT == trackGroupInfo.getType()).collect(Collectors.toList());\n        List<Tracks.Group>tmp = textTracks.stream().map(Tracks.Group::getMediaTrackGroup);\n        final List<String> availableLanguages = tmp.filter(textTrack -> 0< textTrack.length).map(textTrack -> textTrack.getFormat(0).language).collect(Collectors.toList());\n        // Find selected text track\n        final Optional<Format> selectedTracks = textTracks.stream().filter(Tracks.Group::isSelected).filter(info -> info.getMediaTrackGroup().length >= 1).map(info -> info.getMediaTrackGroup().getFormat(0)).findFirst();\n        // Build UI\n        buildCaptionMenu(availableLanguages);\n        if (player.getTrackSelector().getParameters().getRendererDisabled(player.getCaptionRendererIndex()) || selectedTracks.isEmpty()) {\n            binding.captionTextView.setText(R.string.caption_none);\n        } else {\n            binding.captionTextView.setText(selectedTracks.get().language);\n        }\n        binding.captionTextView.setVisibility(availableLanguages.isEmpty() ? View.GONE : View.VISIBLE);\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
{"project_name": "across-project", "pair_id": "212", "src_id": "M894", "code": "    public static RequestCreator loadScaledDownThumbnail(final Context context,@NonNull final List<Image> images) {\n        // scale down the notification thumbnail for performance\n        return PicassoHelper.loadThumbnail(images).transform(new Transformation() {\n            @Override\n            public Bitmap transform(final Bitmap source) {\n                if (DEBUG) {\n                    Log.d(TAG, \"Thumbnail - transform() called\");\n                }\n                final float notificationThumbnailWidth = Math.min(context.getResources().getDimension(R.dimen.player_notification_thumbnail_width), source.getWidth());\n\n                final Bitmap result = BitmapCompat.createScaledBitmap(source,(int)notificationThumbnailWidth,(int) (source.getHeight() / (source.getWidth() / notificationThumbnailWidth)),null,true);\n\n                if (result == source || !result.isMutable()) {\n                    // create a new mutable bitmap to prevent strange crashes on some\n                    // devices (see #4638)\n                    final Bitmap copied = BitmapCompat.createScaledBitmap(source,(int)notificationThumbnailWidth - 1,(int) (source.getHeight() / (source.getWidth() / (notificationThumbnailWidth - 1))),null,true);\n                    source.recycle();\n\n                    return copied;\n                } else {\n                    source.recycle();\n                    return result;\n                }\n            }\n\n            @Override\n            public String key() {\n                return PLAYER_THUMBNAIL_TRANSFORMATION_KEY;\n            }\n        });\n    }\n", "compilable": "", "test_passed": "", "successful_trans": ""}
